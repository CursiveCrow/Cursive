#include "cursive0/sema/type_expr.h"

#include <algorithm>
#include <array>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>
#include <unordered_set>
#include <utility>
#include <vector>

#include "cursive0/core/assert_spec.h"
#include "cursive0/sema/arrays_slices.h"
#include "cursive0/sema/function_types.h"
#include "cursive0/sema/literals.h"
#include "cursive0/sema/records.h"
#include "cursive0/sema/tuples.h"
#include "cursive0/sema/scopes.h"
#include "cursive0/sema/scopes_lookup.h"
#include "cursive0/sema/subtyping.h"
#include "cursive0/sema/type_equiv.h"

namespace cursive0::sema {

namespace {

// ยง5.2.12 definitions
static inline void SpecDefsTypeExpr() {
  SPEC_DEF("ExprJudg", "5.2.12");
  SPEC_DEF("UnresolvedExpr", "5.2.12");
  SPEC_DEF("StripPerm", "5.2.12");
  SPEC_DEF("BitcopyType", "5.2.12");
  SPEC_DEF("SignedIntTypes", "5.2.12");
  SPEC_DEF("NumericTypes", "5.2.12");
  SPEC_DEF("IntTypes", "5.2.12");
  SPEC_DEF("FloatTypes", "5.2.12");
  SPEC_DEF("EqType", "5.2.12");
  SPEC_DEF("OrdType", "5.2.12");
  SPEC_DEF("ValuePathType", "5.2.12");
  SPEC_DEF("UnsafeSpan", "5.2.12");
  SPEC_DEF("ArithOps", "5.2.12");
  SPEC_DEF("BitOps", "5.2.12");
  SPEC_DEF("ShiftOps", "5.2.12");
  SPEC_DEF("CmpOps", "5.2.12");
  SPEC_DEF("LogicOps", "5.2.12");
  SPEC_DEF("CastValid", "5.2.12");
  SPEC_DEF("AddrOfOk", "5.2.12");
  SPEC_DEF("SuccessMember", "5.2.12");
  SPEC_DEF("FieldVis", "5.2.12");
  SPEC_DEF("FieldVisible", "5.2.12");
  SPEC_DEF("FieldNames", "5.2.12");
  SPEC_DEF("FieldInitNames", "5.2.12");
  SPEC_DEF("FieldNameSet", "5.2.12");
  SPEC_DEF("FieldInitSet", "5.2.12");
  SPEC_DEF("RegionActiveType", "5.2.17");
  SPEC_DEF("InnermostActiveRegion", "5.2.17");
}

// Type sets
static constexpr std::array<std::string_view, 12> kIntTypes = {
    "i8", "i16", "i32", "i64", "i128", "isize",
    "u8", "u16", "u32", "u64", "u128", "usize"};

static constexpr std::array<std::string_view, 6> kSignedIntTypes = {
    "i8", "i16", "i32", "i64", "i128", "isize"};

static constexpr std::array<std::string_view, 3> kFloatTypes = {"f16", "f32",
                                                                "f64"};

static bool IsIntType(std::string_view name) {
  return std::find(kIntTypes.begin(), kIntTypes.end(), name) != kIntTypes.end();
}

static bool IsSignedIntType(std::string_view name) {
  return std::find(kSignedIntTypes.begin(), kSignedIntTypes.end(), name) !=
         kSignedIntTypes.end();
}

static bool IsFloatType(std::string_view name) {
  return std::find(kFloatTypes.begin(), kFloatTypes.end(), name) !=
         kFloatTypes.end();
}

static bool IsNumericType(std::string_view name) {
  return IsIntType(name) || IsFloatType(name);
}

static TypeLowerResult LowerType(const ScopeContext& ctx,
                                 const std::shared_ptr<syntax::Type>& type);

static constexpr std::uint64_t kPtrSize = 8;
static constexpr std::uint64_t kPtrAlign = 8;

static std::optional<std::uint64_t> PrimSize(std::string_view name) {
  if (name == "i8" || name == "u8") return 1;
  if (name == "i16" || name == "u16") return 2;
  if (name == "i32" || name == "u32") return 4;
  if (name == "i64" || name == "u64") return 8;
  if (name == "i128" || name == "u128") return 16;
  if (name == "f16") return 2;
  if (name == "f32") return 4;
  if (name == "f64") return 8;
  if (name == "bool") return 1;
  if (name == "char") return 4;
  if (name == "usize" || name == "isize") return kPtrSize;
  if (name == "()" || name == "!") return 0;
  return std::nullopt;
}

static std::optional<std::uint64_t> PrimAlign(std::string_view name) {
  if (name == "i8" || name == "u8") return 1;
  if (name == "i16" || name == "u16") return 2;
  if (name == "i32" || name == "u32") return 4;
  if (name == "i64" || name == "u64") return 8;
  if (name == "i128" || name == "u128") return 16;
  if (name == "f16") return 2;
  if (name == "f32") return 4;
  if (name == "f64") return 8;
  if (name == "bool") return 1;
  if (name == "char") return 4;
  if (name == "usize" || name == "isize") return kPtrAlign;
  if (name == "()" || name == "!") return 1;
  return std::nullopt;
}

static std::uint64_t AlignUp(std::uint64_t value, std::uint64_t align) {
  if (align == 0) {
    return value;
  }
  const std::uint64_t rem = value % align;
  if (rem == 0) {
    return value;
  }
  return value + (align - rem);
}

static std::optional<std::pair<std::uint64_t, std::uint64_t>>
LayoutOfSeq(const ScopeContext& ctx, const std::vector<TypeRef>& elems);

static std::optional<std::pair<std::uint64_t, std::uint64_t>>
LayoutOf(const ScopeContext& ctx, const TypeRef& type) {
  if (!type) {
    return std::nullopt;
  }
  if (const auto* perm = std::get_if<TypePerm>(&type->node)) {
    return LayoutOf(ctx, perm->base);
  }
  if (const auto* prim = std::get_if<TypePrim>(&type->node)) {
    const auto size = PrimSize(prim->name);
    const auto align = PrimAlign(prim->name);
    if (!size.has_value() || !align.has_value()) {
      return std::nullopt;
    }
    return std::make_pair(*size, *align);
  }
  if (std::holds_alternative<TypePtr>(type->node) ||
      std::holds_alternative<TypeRawPtr>(type->node) ||
      std::holds_alternative<TypeFunc>(type->node)) {
    return std::make_pair(kPtrSize, kPtrAlign);
  }
  if (const auto* slice = std::get_if<TypeSlice>(&type->node)) {
    (void)slice;
    return std::make_pair(2 * kPtrSize, kPtrAlign);
  }
  if (const auto* str = std::get_if<TypeString>(&type->node)) {
    if (!str->state.has_value()) {
      return std::nullopt;
    }
    if (*str->state == StringState::Managed) {
      return std::make_pair(3 * kPtrSize, kPtrAlign);
    }
    return std::make_pair(2 * kPtrSize, kPtrAlign);
  }
  if (const auto* bytes = std::get_if<TypeBytes>(&type->node)) {
    if (!bytes->state.has_value()) {
      return std::nullopt;
    }
    if (*bytes->state == BytesState::Managed) {
      return std::make_pair(3 * kPtrSize, kPtrAlign);
    }
    return std::make_pair(2 * kPtrSize, kPtrAlign);
  }
  if (const auto* range = std::get_if<TypeRange>(&type->node)) {
    (void)range;
    std::vector<TypeRef> fields;
    fields.push_back(MakeTypePrim("u8"));
    fields.push_back(MakeTypePrim("usize"));
    fields.push_back(MakeTypePrim("usize"));
    return LayoutOfSeq(ctx, fields);
  }
  if (const auto* array = std::get_if<TypeArray>(&type->node)) {
    const auto elem_layout = LayoutOf(ctx, array->element);
    if (!elem_layout.has_value()) {
      return std::nullopt;
    }
    const auto size = elem_layout->first * array->length;
    return std::make_pair(size, elem_layout->second);
  }
  if (const auto* tuple = std::get_if<TypeTuple>(&type->node)) {
    return LayoutOfSeq(ctx, tuple->elements);
  }
  if (const auto* path = std::get_if<TypePathType>(&type->node)) {
    syntax::Path syntax_path;
    syntax_path.reserve(path->path.size());
    for (const auto& comp : path->path) {
      syntax_path.push_back(comp);
    }
    const auto it = ctx.sigma.types.find(PathKeyOf(syntax_path));
    if (it == ctx.sigma.types.end()) {
      return std::nullopt;
    }
    if (const auto* record = std::get_if<syntax::RecordDecl>(&it->second)) {
      std::vector<TypeRef> fields;
      for (const auto& member : record->members) {
        if (const auto* field = std::get_if<syntax::FieldDecl>(&member)) {
          const auto lowered = LowerType(ctx, field->type);
          if (!lowered.ok || !lowered.type) {
            return std::nullopt;
          }
          fields.push_back(lowered.type);
        }
      }
      return LayoutOfSeq(ctx, fields);
    }
    if (const auto* alias = std::get_if<syntax::TypeAliasDecl>(&it->second)) {
      const auto lowered = LowerType(ctx, alias->type);
      if (!lowered.ok) {
        return std::nullopt;
      }
      return LayoutOf(ctx, lowered.type);
    }
  }
  return std::nullopt;
}

static std::optional<std::pair<std::uint64_t, std::uint64_t>>
LayoutOfSeq(const ScopeContext& ctx, const std::vector<TypeRef>& elems) {
  if (elems.empty()) {
    return std::make_pair(0ull, 1ull);
  }
  std::uint64_t offset = 0;
  std::uint64_t max_align = 1;
  for (const auto& elem : elems) {
    const auto layout = LayoutOf(ctx, elem);
    if (!layout.has_value()) {
      return std::nullopt;
    }
    const auto size = layout->first;
    const auto align = layout->second;
    max_align = std::max(max_align, align);
    offset = AlignUp(offset, align);
    offset += size;
  }
  const auto total = AlignUp(offset, max_align);
  return std::make_pair(total, max_align);
}

static std::optional<std::uint64_t> SizeOf(const ScopeContext& ctx,
                                           const TypeRef& type) {
  const auto layout = LayoutOf(ctx, type);
  if (!layout.has_value()) {
    return std::nullopt;
  }
  return layout->first;
}

static std::optional<std::uint64_t> AlignOf(const ScopeContext& ctx,
                                            const TypeRef& type) {
  const auto layout = LayoutOf(ctx, type);
  if (!layout.has_value()) {
    return std::nullopt;
  }
  return layout->second;
}

static bool IsPrimType(const TypeRef& type, std::string_view name) {
  if (!type) {
    return false;
  }
  const auto stripped = StripPerm(type);
  if (!stripped) {
    return false;
  }
  const auto* prim = std::get_if<TypePrim>(&stripped->node);
  return prim && prim->name == name;
}

static std::optional<std::string> GetPrimName(const TypeRef& type) {
  if (!type) {
    return std::nullopt;
  }
  const auto stripped = StripPerm(type);
  if (!stripped) {
    return std::nullopt;
  }
  const auto* prim = std::get_if<TypePrim>(&stripped->node);
  if (!prim) {
    return std::nullopt;
  }
  return prim->name;
}

// Parse a tuple index from an IntLiteral token
static std::optional<std::size_t> ParseTupleIndex(const syntax::Token& token) {
  if (token.kind != syntax::TokenKind::IntLiteral) {
    return std::nullopt;
  }
  // Simple decimal parsing (tuple indices are always small decimal numbers)
  std::size_t value = 0;
  for (char c : token.lexeme) {
    if (c == '_') continue;
    if (c < '0' || c > '9') return std::nullopt;
    value = value * 10 + static_cast<std::size_t>(c - '0');
  }
  return value;
}

// Forward declarations for mutual recursion
static ExprTypeResult TypeExprImpl(const ScopeContext& ctx,
                                   const StmtTypeContext& type_ctx,
                                   const syntax::ExprPtr& expr,
                                   const TypeEnv& env);

static PlaceTypeResult TypePlaceImpl(const ScopeContext& ctx,
                                     const StmtTypeContext& type_ctx,
                                     const syntax::ExprPtr& expr,
                                     const TypeEnv& env);

// Main place typing dispatcher
static ExprTypeResult TypeExprImpl(const ScopeContext& ctx,
                                   const StmtTypeContext& type_ctx,
                                   const syntax::ExprPtr& expr,
                                   const TypeEnv& env) {
  SpecDefsTypeExpr();
  ExprTypeResult result;

  if (!expr) {
    return result;
  }

  auto type_expr = [&](const syntax::ExprPtr& inner) {
    return TypeExprImpl(ctx, type_ctx, inner, env);
  };
  auto type_place = [&](const syntax::ExprPtr& inner) {
    return TypePlaceImpl(ctx, type_ctx, inner, env);
  };
  auto type_ident = [&](std::string_view name) -> ExprTypeResult {
    return TypeIdentifierExprImpl(ctx, syntax::IdentifierExpr{std::string(name)},
                                  env);
  };

  return std::visit(
      [&](const auto& node) -> ExprTypeResult {
        using T = std::decay_t<decltype(node)>;

        if constexpr (std::is_same_v<T, syntax::ErrorExpr>) {
          return TypeErrorExprImpl(ctx, node);
        } else if constexpr (std::is_same_v<T, syntax::LiteralExpr>) {
          return TypeLiteralExpr(ctx, node);
        } else if constexpr (std::is_same_v<T, syntax::IdentifierExpr>) {
          return TypeIdentifierExprImpl(ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::PathExpr>) {
          return TypePathExprImpl(ctx, node);
        } else if constexpr (std::is_same_v<T, syntax::FieldAccessExpr>) {
          return TypeFieldAccessExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::TupleAccessExpr>) {
          return TypeTupleAccessExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::IndexAccessExpr>) {
          return TypeIndexAccessValue(ctx, node, type_expr);
        } else if constexpr (std::is_same_v<T, syntax::BinaryExpr>) {
          return TypeBinaryExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::UnaryExpr>) {
          return TypeUnaryExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::CastExpr>) {
          return TypeCastExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::IfExpr>) {
          return TypeIfExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::RangeExpr>) {
          return TypeRangeExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::AddressOfExpr>) {
          return TypeAddressOfExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::DerefExpr>) {
          return TypeDerefExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::MoveExpr>) {
          return TypeMoveExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::PropagateExpr>) {
          return TypePropagateExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::RecordExpr>) {
          return TypeRecordExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::EnumLiteralExpr>) {
          return TypeEnumLiteralExprImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::TupleExpr>) {
          return TypeTupleExpr(ctx, node, type_expr);
        } else if constexpr (std::is_same_v<T, syntax::ArrayExpr>) {
          return TypeArrayExpr(ctx, node, type_expr);
        } else if constexpr (std::is_same_v<T, syntax::CallExpr>) {
          const auto record =
              TypeRecordDefaultCall(ctx, node.callee, node.args, type_expr);
          if (record.ok || record.diag_id.has_value()) {
            return record;
          }
          const auto call = TypeCall(ctx, node.callee, node.args, type_expr);
          ExprTypeResult r;
          if (!call.ok) {
            r.diag_id = call.diag_id;
            return r;
          }
          r.ok = true;
          r.type = call.type;
          return r;
        } else if constexpr (std::is_same_v<T, syntax::BlockExpr>) {
          return TypeBlockExpr(ctx, type_ctx, node, env, type_expr, type_ident,
                               type_place);
        } else if constexpr (std::is_same_v<T, syntax::UnsafeBlockExpr>) {
          return TypeUnsafeBlockExpr(ctx, type_ctx, node, env, type_expr,
                                     type_ident, type_place);
        } else if constexpr (std::is_same_v<T, syntax::LoopInfiniteExpr>) {
          return TypeLoopInfiniteExpr(ctx, type_ctx, node, env, type_expr,
                                      type_ident, type_place);
        } else if constexpr (std::is_same_v<T, syntax::LoopConditionalExpr>) {
          return TypeLoopConditionalExpr(ctx, type_ctx, node, env, type_expr,
                                         type_ident, type_place);
        } else if constexpr (std::is_same_v<T, syntax::LoopIterExpr>) {
          return TypeLoopIterExpr(ctx, type_ctx, node, env, type_expr,
                                  type_ident, type_place);
        } else if constexpr (std::is_same_v<T, syntax::AllocExpr>) {
          return TypeAllocExpr(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::TransmuteExpr>) {
          return TypeTransmuteExpr(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::QualifiedNameExpr>) {
          SPEC_RULE("Expr-Unresolved-Err");
          ExprTypeResult r;
          r.diag_id = "ResolveExpr-Ident-Err";
          return r;
        } else if constexpr (std::is_same_v<T, syntax::QualifiedApplyExpr>) {
          SPEC_RULE("Expr-Unresolved-Err");
          ExprTypeResult r;
          r.diag_id = "ResolveExpr-Ident-Err";
          return r;
        } else {
          ExprTypeResult r;
          r.diag_id = "Expr-Unsupported";
          return r;
        }
      },
      expr->node);
}

// Main place typing dispatcher
static PlaceTypeResult TypePlaceImpl(const ScopeContext& ctx,
                                     const StmtTypeContext& type_ctx,
                                     const syntax::ExprPtr& expr,
                                     const TypeEnv& env) {
  SpecDefsTypeExpr();
  PlaceTypeResult result;

  if (!expr) {
    return result;
  }

  auto type_place = [&](const syntax::ExprPtr& inner) {
    return TypePlaceImpl(ctx, type_ctx, inner, env);
  };
  auto type_expr = [&](const syntax::ExprPtr& inner) {
    return TypeExprImpl(ctx, type_ctx, inner, env);
  };

  return std::visit(
      [&](const auto& node) -> PlaceTypeResult {
        using T = std::decay_t<decltype(node)>;

        if constexpr (std::is_same_v<T, syntax::IdentifierExpr>) {
          return TypeIdentifierPlaceImpl(ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::FieldAccessExpr>) {
          return TypeFieldAccessPlaceImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::TupleAccessExpr>) {
          return TypeTupleAccessPlaceImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::DerefExpr>) {
          return TypeDerefPlaceImpl(ctx, type_ctx, node, env);
        } else if constexpr (std::is_same_v<T, syntax::IndexAccessExpr>) {
          return TypeIndexAccessPlace(ctx, node, type_place, type_expr);
        } else {
          PlaceTypeResult r;
          r.diag_id = "NotAPlace";
          return r;
        }
      },
      expr->node);
}

}  // namespace

//=============================================================================
// Public API
//=============================================================================

TypeRef StripPerm(const TypeRef& type) {
  SpecDefsTypeExpr();
  if (!type) {
    return type;
  }
  if (const auto* perm = std::get_if<TypePerm>(&type->node)) {
    return perm->base;
  }
  return type;
}

bool IsPlaceExpr(const syntax::ExprPtr& expr) {
  SpecDefsTypeExpr();
  if (!expr) {
    return false;
  }
  return std::visit(
      [](const auto& node) -> bool {
        using T = std::decay_t<decltype(node)>;
        if constexpr (std::is_same_v<T, syntax::IdentifierExpr>) {
          return true;
        } else if constexpr (std::is_same_v<T, syntax::FieldAccessExpr>) {
          return true;
        } else if constexpr (std::is_same_v<T, syntax::TupleAccessExpr>) {
          return true;
        } else if constexpr (std::is_same_v<T, syntax::IndexAccessExpr>) {
          return true;
        } else if constexpr (std::is_same_v<T, syntax::DerefExpr>) {
          return IsPlaceExpr(node.value);
        } else {
          return false;
        }
      },
      expr->node);
}

bool BitcopyType(const ScopeContext& /*ctx*/, const TypeRef& type) {
  SpecDefsTypeExpr();
  if (!type) {
    return false;
  }
  const auto stripped = StripPerm(type);
  if (!stripped) {
    return false;
  }

  return std::visit(
      [](const auto& node) -> bool {
        using T = std::decay_t<decltype(node)>;
        if constexpr (std::is_same_v<T, TypePrim>) {
          // All primitive types are bitcopy
          return true;
        } else if constexpr (std::is_same_v<T, TypePtr>) {
          return true;
        } else if constexpr (std::is_same_v<T, TypeRawPtr>) {
          return true;
        } else if constexpr (std::is_same_v<T, TypeRange>) {
          return true;
        } else {
          // Records, enums, tuples, etc. need deeper analysis
          // For now, assume non-bitcopy
          return false;
        }
      },
      stripped->node);
}

bool EqType(const TypeRef& type) {
  SpecDefsTypeExpr();
  const auto stripped = StripPerm(type);
  if (!stripped) {
    return false;
  }

  if (const auto* prim = std::get_if<TypePrim>(&stripped->node)) {
    if (IsNumericType(prim->name) || prim->name == "bool" ||
        prim->name == "char") {
      return true;
    }
  }

  if (std::holds_alternative<TypePtr>(stripped->node)) {
    return true;
  }

  if (std::holds_alternative<TypeRawPtr>(stripped->node)) {
    return true;
  }

  if (std::holds_alternative<TypeString>(stripped->node)) {
    return true;
  }

  if (std::holds_alternative<TypeBytes>(stripped->node)) {
    return true;
  }

  return false;
}

bool OrdType(const TypeRef& type) {
  SpecDefsTypeExpr();
  const auto stripped = StripPerm(type);
  if (!stripped) {
    return false;
  }

  const auto* prim = std::get_if<TypePrim>(&stripped->node);
  if (!prim) {
    return false;
  }

  return IsIntType(prim->name) || IsFloatType(prim->name) ||
         prim->name == "char";
}

bool CastValid(const TypeRef& source, const TypeRef& target) {
  SpecDefsTypeExpr();
  const auto src = StripPerm(source);
  const auto tgt = StripPerm(target);

  if (!src || !tgt) {
    return false;
  }

  const auto* src_prim = std::get_if<TypePrim>(&src->node);
  const auto* tgt_prim = std::get_if<TypePrim>(&tgt->node);

  if (!src_prim || !tgt_prim) {
    return false;
  }

  // Numeric to numeric
  if (IsNumericType(src_prim->name) && IsNumericType(tgt_prim->name)) {
    return true;
  }

  // Bool to int
  if (src_prim->name == "bool" && IsIntType(tgt_prim->name)) {
    return true;
  }

  // Int to bool
  if (IsIntType(src_prim->name) && tgt_prim->name == "bool") {
    return true;
  }

  // Char to u32
  if (src_prim->name == "char" && tgt_prim->name == "u32") {
    return true;
  }

  // U32 to char
  if (src_prim->name == "u32" && tgt_prim->name == "char") {
    return true;
  }

  return false;
}

bool IsInUnsafeSpan(const ScopeContext& /*ctx*/, const core::Span& /*span*/) {
  SpecDefsTypeExpr();
  // TODO: implement proper unsafe span checking
  return false;
}

ExprTypeResult TypeExpr(const ScopeContext& ctx,
                        const StmtTypeContext& type_ctx,
                        const syntax::ExprPtr& expr,
                        const TypeEnv& env) {
  SpecDefsTypeExpr();
  auto result = TypeExprImpl(ctx, type_ctx, expr, env);
  if (result.ok) {
    SPEC_RULE("Lift-Expr");
  }
  return result;
}

CheckResult CheckExprAgainst(const ScopeContext& ctx,
                             const StmtTypeContext& type_ctx,
                             const syntax::ExprPtr& expr,
                             const TypeRef& expected,
                             const TypeEnv& env) {
  SpecDefsTypeExpr();
  CheckResult result;

  if (!expr || !expected) {
    return result;
  }

  // Special case for if expressions
  if (const auto* if_expr = std::get_if<syntax::IfExpr>(&expr->node)) {
    return CheckIfExprImpl(ctx, type_ctx, *if_expr, expected, env);
  }

  // General case: infer and check subtyping
  const auto inferred = TypeExprImpl(ctx, type_ctx, expr, env);
  if (!inferred.ok) {
    result.diag_id = inferred.diag_id;
    return result;
  }

  const auto sub = Subtyping(ctx, inferred.type, expected);
  if (!sub.ok) {
    result.diag_id = sub.diag_id;
    return result;
  }
  if (!sub.subtype) {
    result.diag_id = "TypeMismatch";
    return result;
  }

  result.ok = true;
  return result;
}

CheckResult CheckPlaceAgainst(const ScopeContext& ctx,
                              const StmtTypeContext& type_ctx,
                              const syntax::ExprPtr& expr,
                              const TypeRef& expected,
                              const TypeEnv& env) {
  SpecDefsTypeExpr();
  CheckResult result;

  if (!expr || !expected) {
    return result;
  }

  const auto place = TypePlaceImpl(ctx, type_ctx, expr, env);
  if (!place.ok) {
    result.diag_id = place.diag_id;
    return result;
  }

  const auto sub = Subtyping(ctx, place.type, expected);
  if (!sub.ok) {
    result.diag_id = sub.diag_id;
    return result;
  }
  if (!sub.subtype) {
    return result;
  }

  SPEC_RULE("Place-Check");
  result.ok = true;
  return result;
}

PlaceTypeResult TypePlace(const ScopeContext& ctx,
                          const StmtTypeContext& type_ctx,
                          const syntax::ExprPtr& expr,
                          const TypeEnv& env) {
  return TypePlaceImpl(ctx, type_ctx, expr, env);
}

// Individual expression form handlers (public wrappers)
ExprTypeResult TypeIdentifierExpr(const ScopeContext& ctx,
                                  const syntax::IdentifierExpr& expr,
                                  const TypeEnv& env) {
  return TypeIdentifierExprImpl(ctx, expr, env);
}

ExprTypeResult TypePathExpr(const ScopeContext& ctx,
                            const syntax::PathExpr& expr) {
  return TypePathExprImpl(ctx, expr);
}

ExprTypeResult TypeFieldAccessExpr(const ScopeContext& ctx,
                                   const StmtTypeContext& type_ctx,
                                   const syntax::FieldAccessExpr& expr,
                                   const TypeEnv& env) {
  return TypeFieldAccessExprImpl(ctx, type_ctx, expr, env);
}

PlaceTypeResult TypeFieldAccessPlace(const ScopeContext& ctx,
                                     const StmtTypeContext& type_ctx,
                                     const syntax::FieldAccessExpr& expr,
                                     const TypeEnv& env) {
  return TypeFieldAccessPlaceImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeTupleAccessExpr(const ScopeContext& ctx,
                                   const StmtTypeContext& type_ctx,
                                   const syntax::TupleAccessExpr& expr,
                                   const TypeEnv& env) {
  return TypeTupleAccessExprImpl(ctx, type_ctx, expr, env);
}

PlaceTypeResult TypeTupleAccessPlace(const ScopeContext& ctx,
                                     const StmtTypeContext& type_ctx,
                                     const syntax::TupleAccessExpr& expr,
                                     const TypeEnv& env) {
  return TypeTupleAccessPlaceImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeBinaryExpr(const ScopeContext& ctx,
                              const StmtTypeContext& type_ctx,
                              const syntax::BinaryExpr& expr,
                              const TypeEnv& env) {
  return TypeBinaryExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeUnaryExpr(const ScopeContext& ctx,
                             const StmtTypeContext& type_ctx,
                             const syntax::UnaryExpr& expr,
                             const TypeEnv& env) {
  return TypeUnaryExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeCastExpr(const ScopeContext& ctx,
                            const StmtTypeContext& type_ctx,
                            const syntax::CastExpr& expr,
                            const TypeEnv& env) {
  return TypeCastExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeIfExpr(const ScopeContext& ctx,
                          const StmtTypeContext& type_ctx,
                          const syntax::IfExpr& expr,
                          const TypeEnv& env) {
  return TypeIfExprImpl(ctx, type_ctx, expr, env);
}

CheckResult CheckIfExpr(const ScopeContext& ctx,
                        const StmtTypeContext& type_ctx,
                        const syntax::IfExpr& expr,
                        const TypeRef& expected,
                        const TypeEnv& env) {
  return CheckIfExprImpl(ctx, type_ctx, expr, expected, env);
}

ExprTypeResult TypeRangeExpr(const ScopeContext& ctx,
                             const StmtTypeContext& type_ctx,
                             const syntax::RangeExpr& expr,
                             const TypeEnv& env) {
  return TypeRangeExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeAddressOfExpr(const ScopeContext& ctx,
                                 const StmtTypeContext& type_ctx,
                                 const syntax::AddressOfExpr& expr,
                                 const TypeEnv& env) {
  return TypeAddressOfExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeDerefExpr(const ScopeContext& ctx,
                             const StmtTypeContext& type_ctx,
                             const syntax::DerefExpr& expr,
                             const TypeEnv& env) {
  return TypeDerefExprImpl(ctx, type_ctx, expr, env);
}

PlaceTypeResult TypeDerefPlace(const ScopeContext& ctx,
                               const StmtTypeContext& type_ctx,
                               const syntax::DerefExpr& expr,
                               const TypeEnv& env) {
  return TypeDerefPlaceImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeMoveExpr(const ScopeContext& ctx,
                            const StmtTypeContext& type_ctx,
                            const syntax::MoveExpr& expr,
                            const TypeEnv& env) {
  return TypeMoveExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeAllocExpr(const ScopeContext& ctx,
                             const StmtTypeContext& type_ctx,
                             const syntax::AllocExpr& expr,
                             const TypeEnv& env) {
  SpecDefsTypeExpr();
  ExprTypeResult result;
  if (!expr.value) {
    return result;
  }

  if (expr.region_opt.has_value()) {
    const auto binding = BindOf(env, *expr.region_opt);
    if (!binding.has_value() || !RegionActiveType(binding->type)) {
      SPEC_RULE("Alloc-Region-NotFound-Err");
      result.diag_id = "Alloc-Region-NotFound-Err";
      return result;
    }
    const auto inner = TypeExprImpl(ctx, type_ctx, expr.value, env);
    if (!inner.ok) {
      result.diag_id = inner.diag_id;
      return result;
    }
    SPEC_RULE("T-Alloc-Explicit");
    result.ok = true;
    result.type = inner.type;
    return result;
  }

  const auto region = InnermostActiveRegion(env);
  if (!region.has_value()) {
    SPEC_RULE("Alloc-Implicit-NoRegion-Err");
    result.diag_id = "Alloc-Implicit-NoRegion-Err";
    return result;
  }

  const auto inner = TypeExprImpl(ctx, type_ctx, expr.value, env);
  if (!inner.ok) {
    result.diag_id = inner.diag_id;
    return result;
  }
  SPEC_RULE("T-Alloc-Implicit");
  result.ok = true;
  result.type = inner.type;
  return result;
}

ExprTypeResult TypeTransmuteExpr(const ScopeContext& ctx,
                                 const StmtTypeContext& type_ctx,
                                 const syntax::TransmuteExpr& expr,
                                 const TypeEnv& env) {
  SpecDefsTypeExpr();
  ExprTypeResult result;
  if (!type_ctx.in_unsafe) {
    SPEC_RULE("Transmute-Unsafe-Err");
    result.diag_id = "Transmute-Unsafe-Err";
    return result;
  }
  if (!expr.from || !expr.to || !expr.value) {
    return result;
  }

  const auto from = LowerType(ctx, expr.from);
  if (!from.ok) {
    result.diag_id = from.diag_id;
    return result;
  }
  const auto to = LowerType(ctx, expr.to);
  if (!to.ok) {
    result.diag_id = to.diag_id;
    return result;
  }

  const auto from_size = SizeOf(ctx, from.type);
  const auto to_size = SizeOf(ctx, to.type);
  if (!from_size.has_value() || !to_size.has_value()) {
    return result;
  }
  if (*from_size != *to_size) {
    SPEC_RULE("T-Transmute-SizeEq");
    result.diag_id = "T-Transmute-SizeEq";
    return result;
  }
  SPEC_RULE("T-Transmute-SizeEq");

  const auto from_align = AlignOf(ctx, from.type);
  const auto to_align = AlignOf(ctx, to.type);
  if (!from_align.has_value() || !to_align.has_value()) {
    return result;
  }
  if (*from_align != *to_align) {
    SPEC_RULE("T-Transmute-AlignEq");
    result.diag_id = "T-Transmute-AlignEq";
    return result;
  }
  SPEC_RULE("T-Transmute-AlignEq");

  const auto value = TypeExprImpl(ctx, type_ctx, expr.value, env);
  if (!value.ok) {
    result.diag_id = value.diag_id;
    return result;
  }
  const auto sub = Subtyping(ctx, value.type, from.type);
  if (!sub.ok) {
    result.diag_id = sub.diag_id;
    return result;
  }
  if (!sub.subtype) {
    return result;
  }

  SPEC_RULE("T-Transmute");
  result.ok = true;
  result.type = to.type;
  return result;
}

ExprTypeResult TypePropagateExpr(const ScopeContext& ctx,
                                 const StmtTypeContext& type_ctx,
                                 const syntax::PropagateExpr& expr,
                                 const TypeEnv& env) {
  return TypePropagateExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeRecordExpr(const ScopeContext& ctx,
                              const StmtTypeContext& type_ctx,
                              const syntax::RecordExpr& expr,
                              const TypeEnv& env) {
  return TypeRecordExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeEnumLiteralExpr(const ScopeContext& ctx,
                                   const StmtTypeContext& type_ctx,
                                   const syntax::EnumLiteralExpr& expr,
                                   const TypeEnv& env) {
  return TypeEnumLiteralExprImpl(ctx, type_ctx, expr, env);
}

ExprTypeResult TypeErrorExpr(const ScopeContext& ctx,
                             const syntax::ErrorExpr& expr) {
  return TypeErrorExprImpl(ctx, expr);
}

}  // namespace cursive0::sema
