record ParseUsizeResult {
  ok: bool
  value: usize
}

record RuleScan {
  count: usize
  payload_ok: bool
}

procedure write_stdout(fs: $FileSystem, msg: string@View) -> () {
  let _ = match fs~>write_stdout(msg) {
    ok: () => (),
    err: IoError => ()
  };
  return ();
}

procedure write_fail(fs: $FileSystem, rule_id: string@View, msg: string@View) -> () {
  write_stdout(fs, "FAIL|");
  write_stdout(fs, rule_id);
  write_stdout(fs, "|");
  write_stdout(fs, msg);
  write_stdout(fs, "\n");
  return ();
}

procedure slice_from_bytes(view: bytes@View) -> [u8] {
  let slice: [u8] = unsafe { transmute::<bytes@View, [u8]>(view) };
  return slice;
}

procedure string_from_slice(slice: [u8]) -> string@View {
  let view: bytes@View = bytes::view(slice);
  let out: string@View = unsafe { transmute::<bytes@View, string@View>(view) };
  return out;
}

procedure slice_len(slice: [u8]) -> usize {
  let view: bytes@View = bytes::view(slice);
  let len: usize = bytes::length(view);
  return len;
}

procedure byte_at(slice: [u8], idx: usize) -> u8 {
  var i: usize = 0usize;
  loop b in slice {
    if i == idx {
      return b;
    }
    i = i + 1usize;
  }
  return 0u8;
}

procedure slices_equal(a: [u8], b: [u8]) -> bool {
  let len_a: usize = slice_len(a);
  let len_b: usize = slice_len(b);
  if len_a != len_b {
    return false;
  }
  var idx: usize = 0usize;
  var ok: bool = true;
  loop v in a {
    let other: u8 = byte_at(b, idx);
    if v != other {
      ok = false;
      break;
    }
    idx = idx + 1usize;
  }
  return ok;
}

procedure slice_is_empty(slice: [u8]) -> bool {
  return slice_len(slice) == 0usize;
}

procedure slice_trim_cr(slice: [u8]) -> [u8] {
  let len: usize = slice_len(slice);
  if len == 0usize {
    return slice;
  }
  let last: u8 = byte_at(slice, len - 1usize);
  if last == 13u8 {
    return slice[0usize..(len - 1usize)];
  }
  return slice;
}

procedure slice_is_dash(slice: [u8]) -> bool {
  let trimmed: [u8] = slice_trim_cr(slice);
  if slice_len(trimmed) != 1usize {
    return false;
  }
  return byte_at(trimmed, 0usize) == 45u8;
}

procedure parse_usize(slice: [u8]) -> ParseUsizeResult {
  var out: usize = 0usize;
  var seen: bool = false;
  loop b in slice {
    let d: usize = b as usize;
    if d < 48usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    if d > 57usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    out = out * 10usize + (d - 48usize);
    seen = true;
  }
  if !seen {
    return ParseUsizeResult { ok: false, value: 0usize };
  }
  return ParseUsizeResult { ok: true, value: out };
}

procedure payload_has_key(payload: [u8], key: [u8]) -> bool {
  if slice_is_empty(key) {
    return false;
  }
  var seg_start: usize = 0usize;
  var eq_pos: usize = 0usize;
  var eq_found: bool = false;
  var idx: usize = 0usize;
  loop b in payload {
    if b == 61u8 && !eq_found {
      eq_pos = idx;
      eq_found = true;
    }
    if b == 59u8 {
      if eq_found {
        let seg_key: [u8] = payload[seg_start..eq_pos];
        if slices_equal(seg_key, key) {
          return true;
        }
      }
      seg_start = idx + 1usize;
      eq_found = false;
    }
    idx = idx + 1usize;
  }
  if eq_found {
    let seg_key: [u8] = payload[seg_start..eq_pos];
    if slices_equal(seg_key, key) {
      return true;
    }
  }
  return false;
}

procedure payload_keys_present(payload: [u8], keys: [u8]) -> bool {
  if slice_is_empty(keys) {
    return true;
  }
  if slice_is_dash(keys) {
    return true;
  }
  var key_start: usize = 0usize;
  var idx: usize = 0usize;
  loop b in keys {
    if b == 59u8 || b == 44u8 {
      let key_slice: [u8] = keys[key_start..idx];
      if !slice_is_empty(key_slice) {
        if !payload_has_key(payload, key_slice) {
          return false;
        }
      }
      key_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  let last_key: [u8] = keys[key_start..idx];
  if !slice_is_empty(last_key) {
    if !payload_has_key(payload, last_key) {
      return false;
    }
  }
  return true;
}

procedure check_trace_header(trace: [u8]) -> bool {
  let total: usize = slice_len(trace);
  if total == 0usize {
    return false;
  }
  var idx: usize = 0usize;
  var line_end: usize = total;
  loop b in trace {
    if b == 10u8 {
      line_end = idx;
      break;
    }
    idx = idx + 1usize;
  }
  let header: [u8] = trace[0usize..line_end];
  let lit: bytes@View = bytes::view_string("spec_trace_v1");
  let lit_slice: [u8] = slice_from_bytes(lit);
  return slices_equal(header, lit_slice);
}

procedure detect_trace_domain(trace: [u8]) -> bytes@View {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start {
            let domain_slice: [u8] = trace[domain_start..domain_end];
            return bytes::view(domain_slice);
          }
        }
        line_index = line_index + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  return bytes::view_string("");
}

procedure scan_trace_for_rule(trace: [u8],
                              domain: [u8],
                              rule_id: [u8],
                              keys: [u8]) -> RuleScan {
  var count: usize = 0usize;
  var payload_ok: bool = true;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, rule_id) {
              count = count + 1usize;
              if !slice_is_empty(keys) && !slice_is_dash(keys) {
                let payload_slice: [u8] = trace[payload_start..payload_end];
                if !payload_keys_present(payload_slice, keys) {
                  payload_ok = false;
                }
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if line_index > 0usize {
      if domain_end > domain_start && rule_end > rule_start {
        let dom_slice: [u8] = trace[domain_start..domain_end];
        let rule_slice: [u8] = trace[rule_start..rule_end];
        let domain_match: bool =
            slice_is_empty(domain) || slice_is_dash(domain) ||
            slices_equal(dom_slice, domain);
        if domain_match && slices_equal(rule_slice, rule_id) {
          count = count + 1usize;
          if !slice_is_empty(keys) && !slice_is_dash(keys) {
            let payload_slice: [u8] = trace[payload_start..payload_end];
            if !payload_keys_present(payload_slice, keys) {
              payload_ok = false;
            }
          }
        }
      }
    }
  }

  return RuleScan { count: count, payload_ok: payload_ok };
}

procedure verify_rules(fs: $FileSystem,
                       rules: [u8],
                       trace: [u8],
                       trace_domain: [u8]) -> usize {
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var min_start: usize = 0usize;
  var min_end: usize = 0usize;
  var max_start: usize = 0usize;
  var max_end: usize = 0usize;
  var keys_start: usize = 0usize;
  var keys_end: usize = 0usize;

  loop b in rules {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 1usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        min_start = field_start;
        min_end = field_end;
      } else if field_index == 3usize {
        max_start = field_start;
        max_end = field_end;
      } else if field_index == 4usize {
        keys_start = field_start;
        keys_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: [u8] = rules[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let rule_slice: [u8] = slice_trim_cr(rules[rule_start..rule_end]);
              let domain_slice: [u8] = slice_trim_cr(rules[domain_start..domain_end]);
              let min_slice: [u8] = slice_trim_cr(rules[min_start..min_end]);
              let max_slice: [u8] = slice_trim_cr(rules[max_start..max_end]);
              let keys_slice: [u8] = slice_trim_cr(rules[keys_start..keys_end]);

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Rule domain doesn't apply to this trace.
              } else if slice_is_empty(rule_slice) {
                write_fail(fs, "RuleParse", "missing_rule_id");
                failures = failures + 1usize;
              } else {
                var min_val: usize = 0usize;
                if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
                  let min_parsed: ParseUsizeResult = parse_usize(min_slice);
                  if min_parsed.ok {
                    min_val = min_parsed.value;
                  } else {
                    write_fail(fs, string_from_slice(rule_slice), "bad_min_count");
                    failures = failures + 1usize;
                  }
                }

                var max_specified: bool = false;
                var max_val: usize = 0usize;
                if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
                  let max_parsed: ParseUsizeResult = parse_usize(max_slice);
                  if max_parsed.ok {
                    max_val = max_parsed.value;
                    max_specified = true;
                  } else {
                    write_fail(fs, string_from_slice(rule_slice), "bad_max_count");
                    failures = failures + 1usize;
                  }
                }

                let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
                if !scan.payload_ok {
                  write_fail(fs, string_from_slice(rule_slice), "payload_keys_missing");
                  failures = failures + 1usize;
                }
                if scan.count < min_val {
                  write_fail(fs, string_from_slice(rule_slice), "count_below_min");
                  failures = failures + 1usize;
                }
                if max_specified && scan.count > max_val {
                  write_fail(fs, string_from_slice(rule_slice), "count_above_max");
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        rule_start = 0usize;
        rule_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        min_start = 0usize;
        min_end = 0usize;
        max_start = 0usize;
        max_end = 0usize;
        keys_start = 0usize;
        keys_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice: [u8] = rules[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let rule_slice: [u8] = slice_trim_cr(rules[rule_start..rule_end]);
        let domain_slice: [u8] = slice_trim_cr(rules[domain_start..domain_end]);
        let min_slice: [u8] = slice_trim_cr(rules[min_start..min_end]);
        let max_slice: [u8] = slice_trim_cr(rules[max_start..max_end]);
        let keys_slice: [u8] = slice_trim_cr(rules[keys_start..keys_end]);

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Rule domain doesn't apply to this trace.
        } else if !slice_is_empty(rule_slice) {
          var min_val: usize = 0usize;
          if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
            let min_parsed: ParseUsizeResult = parse_usize(min_slice);
            if min_parsed.ok {
              min_val = min_parsed.value;
            } else {
              write_fail(fs, string_from_slice(rule_slice), "bad_min_count");
              failures = failures + 1usize;
            }
          }

          var max_specified: bool = false;
          var max_val: usize = 0usize;
          if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
            let max_parsed: ParseUsizeResult = parse_usize(max_slice);
            if max_parsed.ok {
              max_val = max_parsed.value;
              max_specified = true;
            } else {
              write_fail(fs, string_from_slice(rule_slice), "bad_max_count");
              failures = failures + 1usize;
            }
          }

          let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
          if !scan.payload_ok {
            write_fail(fs, string_from_slice(rule_slice), "payload_keys_missing");
            failures = failures + 1usize;
          }
          if scan.count < min_val {
            write_fail(fs, string_from_slice(rule_slice), "count_below_min");
            failures = failures + 1usize;
          }
          if max_specified && scan.count > max_val {
            write_fail(fs, string_from_slice(rule_slice), "count_above_max");
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure check_edge_order(trace: [u8],
                           domain: [u8],
                           before_rule: [u8],
                           after_rule: [u8]) -> bool {
  var seen_before: bool = false;
  var violation: bool = false;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, before_rule) {
              seen_before = true;
            }
            if domain_match && slices_equal(rule_slice, after_rule) {
              if !seen_before {
                violation = true;
                break;
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if !violation && idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: [u8] = trace[domain_start..domain_end];
      let rule_slice: [u8] = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, before_rule) {
        seen_before = true;
      }
      if domain_match && slices_equal(rule_slice, after_rule) {
        if !seen_before {
          violation = true;
        }
      }
    }
  }

  return !violation;
}

procedure verify_edges(fs: $FileSystem,
                       edges: [u8],
                       trace: [u8],
                       trace_domain: [u8]) -> usize {
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var before_start: usize = 0usize;
  var before_end: usize = 0usize;
  var after_start: usize = 0usize;
  var after_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var group_start: usize = 0usize;
  var group_end: usize = 0usize;

  loop b in edges {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        before_start = field_start;
        before_end = field_end;
      } else if field_index == 1usize {
        after_start = field_start;
        after_end = field_end;
      } else if field_index == 2usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 3usize {
        group_start = field_start;
        group_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: [u8] = edges[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let before_slice: [u8] = slice_trim_cr(edges[before_start..before_end]);
              let after_slice: [u8] = slice_trim_cr(edges[after_start..after_end]);
              let domain_slice: [u8] = slice_trim_cr(edges[domain_start..domain_end]);
              let group_slice: [u8] = slice_trim_cr(edges[group_start..group_end]);

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Edge domain doesn't apply to this trace.
              } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
                write_fail(fs, string_from_slice(before_slice), "edge_group_by_unsupported");
                failures = failures + 1usize;
              } else {
                let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
                if !ok {
                  write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        before_start = 0usize;
        before_end = 0usize;
        after_start = 0usize;
        after_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        group_start = 0usize;
        group_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice: [u8] = edges[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let before_slice: [u8] = slice_trim_cr(edges[before_start..before_end]);
        let after_slice: [u8] = slice_trim_cr(edges[after_start..after_end]);
        let domain_slice: [u8] = slice_trim_cr(edges[domain_start..domain_end]);
        let group_slice: [u8] = slice_trim_cr(edges[group_start..group_end]);

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Edge domain doesn't apply to this trace.
        } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
          write_fail(fs, string_from_slice(before_slice), "edge_group_by_unsupported");
          failures = failures + 1usize;
        } else {
          let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
          if !ok {
            write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure diag_map_has_code(diag_map: [u8], code: [u8]) -> bool {
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  var field_start: usize = 0usize;
  var field_index: usize = 0usize;
  var code_start: usize = 0usize;
  var code_end: usize = 0usize;

  loop b in diag_map {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        code_start = field_start;
        code_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: [u8] = diag_map[line_start..line_end];
          if slice_len(line_slice) != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              if code_end > code_start {
                let map_code: [u8] = diag_map[code_start..code_end];
                if slices_equal(map_code, code) {
                  return true;
                }
              }
            }
          }
        }
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        code_start = 0usize;
        code_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_slice: [u8] = diag_map[line_start..idx];
    if slice_len(line_slice) != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        if code_end > code_start {
          let map_code: [u8] = diag_map[code_start..code_end];
          if slices_equal(map_code, code) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

procedure diag_map_has_entries(diag_map: [u8]) -> bool {
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  loop b in diag_map {
    if b == 10u8 {
      let line_end: usize = idx;
      if line_end > line_start {
        let line_slice: [u8] = diag_map[line_start..line_end];
        if slice_len(line_slice) != 0usize {
          let first: u8 = byte_at(line_slice, 0usize);
          if first != 35u8 {
            return true;
          }
        }
      }
      line_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  if idx > line_start {
    let line_slice: [u8] = diag_map[line_start..idx];
    if slice_len(line_slice) != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        return true;
      }
    }
  }
  return false;
}

procedure verify_diag(fs: $FileSystem, diag_map: [u8], diag_codes: [u8]) -> usize {
  if slice_is_empty(diag_codes) {
    return 0usize;
  }
  if !diag_map_has_entries(diag_map) {
    return 0usize;
  }
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  var failures: usize = 0usize;
  loop b in diag_codes {
    if b == 10u8 {
      let line_end: usize = idx;
      if line_end > line_start {
        let line_slice: [u8] = diag_codes[line_start..line_end];
        let line_len: usize = slice_len(line_slice);
        if line_len != 0usize {
          let first: u8 = byte_at(line_slice, 0usize);
          if first != 35u8 {
            if !diag_map_has_code(diag_map, line_slice) {
              write_fail(fs, string_from_slice(line_slice), "diag_unmapped");
              failures = failures + 1usize;
            }
          }
        }
      }
      line_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  if idx > line_start {
    let line_slice: [u8] = diag_codes[line_start..idx];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        if !diag_map_has_code(diag_map, line_slice) {
          write_fail(fs, string_from_slice(line_slice), "diag_unmapped");
          failures = failures + 1usize;
        }
      }
    }
  }
  return failures;
}

public procedure main(move ctx: Context) -> i32 {
  let fs: $FileSystem = ctx.fs;

  let trace_path: string@View = "spec/trace_current.tsv";
  let rules_path: string@View = "spec/verifier_rules.tsv";
  let edges_path: string@View = "spec/verifier_edges.tsv";
  let rules_current_path: string@View = "spec/verifier_rules_current.tsv";
  let edges_current_path: string@View = "spec/verifier_edges_current.tsv";
  let diag_path: string@View = "spec/verifier_diag.tsv";

  let trace_res = fs~>read_bytes(trace_path);
  let trace_data: bytes@Managed = match move trace_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "TraceRead", trace_path);
      return 1i32;
    }
  };
  let trace_view: bytes@View = bytes::as_view(trace_data);
  let trace_slice: [u8] = slice_from_bytes(trace_view);

  if !check_trace_header(trace_slice) {
    write_fail(fs, "TraceHeader", "expected spec_trace_v1");
    return 1i32;
  }

  let rules_res = fs~>read_bytes(rules_current_path);
  let rules_data: bytes@Managed = match move rules_res {
    data: bytes@Managed => data,
    err: IoError => {
      let fallback = fs~>read_bytes(rules_path);
      match move fallback {
        data: bytes@Managed => data,
        err: IoError => {
          write_fail(fs, "RulesRead", rules_path);
          return 1i32;
        }
      }
    }
  };
  let rules_view: bytes@View = bytes::as_view(rules_data);
  let rules_slice: [u8] = slice_from_bytes(rules_view);

  let edges_res = fs~>read_bytes(edges_current_path);
  let edges_data: bytes@Managed = match move edges_res {
    data: bytes@Managed => data,
    err: IoError => {
      let fallback = fs~>read_bytes(edges_path);
      match move fallback {
        data: bytes@Managed => data,
        err: IoError => {
          write_fail(fs, "EdgesRead", edges_path);
          return 1i32;
        }
      }
    }
  };
  let edges_view: bytes@View = bytes::as_view(edges_data);
  let edges_slice: [u8] = slice_from_bytes(edges_view);

  let diag_res = fs~>read_bytes(diag_path);
  let diag_data: bytes@Managed = match move diag_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "DiagRead", diag_path);
      return 1i32;
    }
  };
  let diag_view: bytes@View = bytes::as_view(diag_data);
  let diag_slice: [u8] = slice_from_bytes(diag_view);

  let diag_codes_path: string@View = "spec/diag_current.tsv";
  let diag_codes_res = fs~>read_bytes(diag_codes_path);
  let diag_codes_opt: bytes@Managed | () = match move diag_codes_res {
    data: bytes@Managed => data,
    err: IoError => ()
  };
  let diag_codes_slice: [u8] = match move diag_codes_opt {
    data: bytes@Managed => {
      let view: bytes@View = bytes::as_view(data);
      slice_from_bytes(view)
    },
    empty: () => {
      let view: bytes@View = bytes::view_string("");
      slice_from_bytes(view)
    }
  };

  var failures: usize = 0usize;
  let trace_domain_view: bytes@View = detect_trace_domain(trace_slice);
  let trace_domain_slice: [u8] = slice_from_bytes(trace_domain_view);

  failures = failures + verify_rules(fs, rules_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_edges(fs, edges_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_diag(fs, diag_slice, diag_codes_slice);

  if failures == 0usize {
    write_stdout(fs, "OK\n");
    return 0i32;
  }
  return 1i32;
}
