record ParseUsizeResult {
  ok: bool,
  value: usize
}

record RuleScan {
  count: usize,
  payload_ok: bool
}

record HexResult {
  ok: bool,
  value: u8
}

record DecodeResult {
  ok: bool,
  value: u8,
  next: usize
}

record SegmentResult {
  found: bool,
  start: usize,
  end: usize
}

record GroupMatchResult {
  matches: bool,
  missing: bool
}

record EdgeCheckResult {
  ok: bool,
  missing: bool
}

record DiagMatchResult {
  found: bool,
  ok: bool
}

procedure write_stdout(fs: $FileSystem, msg: string@View) -> () {
  let _ = match fs~>write_stdout(msg) {
    ok: () => (),
    err: IoError => ()
  };
  return ();
}

procedure write_fail(fs: $FileSystem, rule_id: string@View, msg: string@View) -> () {
  let fail_prefix: string@View = "FAIL|";
  let sep: string@View = "|";
  let newline: string@View = "\n";
  write_stdout(fs, fail_prefix);
  write_stdout(fs, rule_id);
  write_stdout(fs, sep);
  write_stdout(fs, msg);
  write_stdout(fs, newline);
  return ();
}

procedure slice_from_bytes(view: bytes@View) -> [u8] {
  let slice: [u8] = unsafe { transmute::<bytes@View, [u8]>(view) };
  return slice;
}

procedure string_from_slice(slice: [u8]) -> string@View {
  let view: bytes@View = bytes::view(slice);
  let out: string@View = unsafe { transmute::<bytes@View, string@View>(view) };
  return out;
}

procedure slice_len(slice: [u8]) -> usize {
  let view: bytes@View = bytes::view(slice);
  let len: usize = bytes::length(view);
  return len;
}

procedure byte_at(slice: [u8], idx: usize) -> u8 {
  var i: usize = 0usize;
  loop b in slice {
    if i == idx {
      return b;
    }
    i = i + 1usize;
  }
  return 0u8;
}

procedure slices_equal(a: [u8], b: [u8]) -> bool {
  let len_a: usize = slice_len(a);
  let len_b: usize = slice_len(b);
  if len_a != len_b {
    return false;
  }
  var idx: usize = 0usize;
  var ok: bool = true;
  loop v in a {
    let other: u8 = byte_at(b, idx);
    if v != other {
      ok = false;
      break;
    }
    idx = idx + 1usize;
  }
  return ok;
}

procedure slice_is_empty(slice: [u8]) -> bool {
  return slice_len(slice) == 0usize;
}

procedure slice_trim_cr(slice: [u8]) -> [u8] {
  let len: usize = slice_len(slice);
  if len == 0usize {
    return slice;
  }
  let last: u8 = byte_at(slice, len - 1usize);
  if last == 13u8 {
    return slice[0usize..(len - 1usize)];
  }
  return slice;
}

procedure slice_is_dash(slice: [u8]) -> bool {
  let trimmed: [u8] = slice_trim_cr(slice);
  if slice_len(trimmed) != 1usize {
    return false;
  }
  return byte_at(trimmed, 0usize) == 45u8;
}

procedure parse_usize(slice: [u8]) -> ParseUsizeResult {
  var out: usize = 0usize;
  var seen: bool = false;
  loop b in slice {
    let d: usize = b as usize;
    if d < 48usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    if d > 57usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    out = out * 10usize + (d - 48usize);
    seen = true;
  }
  if !seen {
    return ParseUsizeResult { ok: false, value: 0usize };
  }
  return ParseUsizeResult { ok: true, value: out };
}

procedure hex_value(b: u8) -> HexResult {
  if b >= 48u8 && b <= 57u8 {
    return HexResult { ok: true, value: b - 48u8 };
  }
  if b >= 65u8 && b <= 70u8 {
    return HexResult { ok: true, value: b - 55u8 };
  }
  if b >= 97u8 && b <= 102u8 {
    return HexResult { ok: true, value: b - 87u8 };
  }
  return HexResult { ok: false, value: 0u8 };
}

procedure decode_next(slice: [u8], idx: usize) -> DecodeResult {
  let len: usize = slice_len(slice);
  if idx >= len {
    return DecodeResult { ok: false, value: 0u8, next: idx };
  }
  let b: u8 = byte_at(slice, idx);
  if b != 37u8 {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  if idx + 2usize >= len {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  let hi: HexResult = hex_value(byte_at(slice, idx + 1usize));
  let lo: HexResult = hex_value(byte_at(slice, idx + 2usize));
  if !hi.ok || !lo.ok {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  let hi_val: usize = hi.value as usize;
  let lo_val: usize = lo.value as usize;
  let value: u8 = (hi_val * 16usize + lo_val) as u8;
  return DecodeResult { ok: true, value: value, next: idx + 3usize };
}

procedure decoded_equals(raw: [u8], expected: [u8]) -> bool {
  let raw_len: usize = slice_len(raw);
  let exp_len: usize = slice_len(expected);
  var raw_idx: usize = 0usize;
  var exp_idx: usize = 0usize;
  loop {
    if raw_idx >= raw_len {
      break;
    }
    let decoded: DecodeResult = decode_next(raw, raw_idx);
    if !decoded.ok {
      return false;
    }
    if exp_idx >= exp_len {
      return false;
    }
    let exp_b: u8 = byte_at(expected, exp_idx);
    if decoded.value != exp_b {
      return false;
    }
    raw_idx = decoded.next;
    exp_idx = exp_idx + 1usize;
  }
  return exp_idx == exp_len;
}

procedure decoded_equals_pair(a: [u8], b: [u8]) -> bool {
  let len_a: usize = slice_len(a);
  let len_b: usize = slice_len(b);
  var idx_a: usize = 0usize;
  var idx_b: usize = 0usize;
  loop {
    if idx_a >= len_a && idx_b >= len_b {
      return true;
    }
    if idx_a >= len_a || idx_b >= len_b {
      return false;
    }
    let dec_a: DecodeResult = decode_next(a, idx_a);
    let dec_b: DecodeResult = decode_next(b, idx_b);
    if !dec_a.ok || !dec_b.ok {
      return false;
    }
    if dec_a.value != dec_b.value {
      return false;
    }
    idx_a = dec_a.next;
    idx_b = dec_b.next;
  }
  return true;
}

procedure payload_find_value(payload: [u8], key: [u8]) -> SegmentResult {
  if slice_is_empty(key) {
    return SegmentResult { found: false, start: 0usize, end: 0usize };
  }
  var seg_start: usize = 0usize;
  var eq_pos: usize = 0usize;
  var eq_found: bool = false;
  var idx: usize = 0usize;
  loop b in payload {
    if b == 61u8 && !eq_found {
      eq_pos = idx;
      eq_found = true;
    }
    if b == 59u8 {
      if eq_found {
        let seg_key: [u8] = payload[seg_start..eq_pos];
        if decoded_equals(seg_key, key) {
          return SegmentResult { found: true, start: eq_pos + 1usize, end: idx };
        }
      }
      seg_start = idx + 1usize;
      eq_found = false;
    }
    idx = idx + 1usize;
  }
  if eq_found {
    let seg_key: [u8] = payload[seg_start..eq_pos];
    if decoded_equals(seg_key, key) {
      return SegmentResult { found: true, start: eq_pos + 1usize, end: idx };
    }
  }
  return SegmentResult { found: false, start: 0usize, end: 0usize };
}

procedure payload_has_key(payload: [u8], key: [u8]) -> bool {
  let seg: SegmentResult = payload_find_value(payload, key);
  return seg.found;
}

procedure payload_value_matches(payload: [u8], key: [u8], expected: [u8]) -> bool {
  let seg: SegmentResult = payload_find_value(payload, key);
  if !seg.found {
    return false;
  }
  let value_slice: [u8] = payload[seg.start..seg.end];
  return decoded_equals(value_slice, expected);
}

procedure payload_keys_present(payload: [u8], keys: [u8]) -> bool {
  if slice_is_empty(keys) {
    return true;
  }
  if slice_is_dash(keys) {
    return true;
  }
  var key_start: usize = 0usize;
  var idx: usize = 0usize;
  loop b in keys {
    if b == 59u8 || b == 44u8 {
      let key_slice: [u8] = keys[key_start..idx];
      if !slice_is_empty(key_slice) {
        if !payload_has_key(payload, key_slice) {
          return false;
        }
      }
      key_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  let last_key: [u8] = keys[key_start..idx];
  if !slice_is_empty(last_key) {
    if !payload_has_key(payload, last_key) {
      return false;
    }
  }
  return true;
}

procedure payload_group_matches(payload_a: [u8],
                                payload_b: [u8],
                                keys: [u8]) -> GroupMatchResult {
  if slice_is_empty(keys) || slice_is_dash(keys) {
    return GroupMatchResult { matches: true, missing: false };
  }
  var key_start: usize = 0usize;
  var idx: usize = 0usize;
  loop b in keys {
    if b == 59u8 || b == 44u8 {
      let key_slice: [u8] = keys[key_start..idx];
      if !slice_is_empty(key_slice) {
        let seg_a: SegmentResult = payload_find_value(payload_a, key_slice);
        let seg_b: SegmentResult = payload_find_value(payload_b, key_slice);
        if !seg_a.found || !seg_b.found {
          return GroupMatchResult { matches: false, missing: true };
        }
        let val_a: [u8] = payload_a[seg_a.start..seg_a.end];
        let val_b: [u8] = payload_b[seg_b.start..seg_b.end];
        if !decoded_equals_pair(val_a, val_b) {
          return GroupMatchResult { matches: false, missing: false };
        }
      }
      key_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  let last_key: [u8] = keys[key_start..idx];
  if !slice_is_empty(last_key) {
    let seg_a: SegmentResult = payload_find_value(payload_a, last_key);
    let seg_b: SegmentResult = payload_find_value(payload_b, last_key);
    if !seg_a.found || !seg_b.found {
      return GroupMatchResult { matches: false, missing: true };
    }
    let val_a: [u8] = payload_a[seg_a.start..seg_a.end];
    let val_b: [u8] = payload_b[seg_b.start..seg_b.end];
    if !decoded_equals_pair(val_a, val_b) {
      return GroupMatchResult { matches: false, missing: false };
    }
  }
  return GroupMatchResult { matches: true, missing: false };
}

procedure check_trace_header(trace: [u8]) -> bool {
  let total: usize = slice_len(trace);
  if total == 0usize {
    return false;
  }
  var idx: usize = 0usize;
  var line_end: usize = total;
  loop b in trace {
    if b == 10u8 {
      line_end = idx;
      break;
    }
    idx = idx + 1usize;
  }
  let header: [u8] = trace[0usize..line_end];
  let lit_str = "spec_trace_v1";
  let lit: bytes@View = bytes::view_string(lit_str);
  let lit_slice: [u8] = slice_from_bytes(lit);
  return slices_equal(header, lit_slice);
}

procedure detect_trace_domain(trace: [u8]) -> bytes@View {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start {
            let domain_slice: [u8] = trace[domain_start..domain_end];
            return bytes::view(domain_slice);
          }
        }
        line_index = line_index + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  let empty_str = "";
  return bytes::view_string(empty_str);
}

procedure scan_trace_for_rule(trace: [u8],
                              domain: [u8],
                              rule_id: [u8],
                              keys: [u8]) -> RuleScan {
  var count: usize = 0usize;
  var payload_ok: bool = true;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, rule_id) {
              count = count + 1usize;
              if !slice_is_empty(keys) && !slice_is_dash(keys) {
                let payload_slice: [u8] = trace[payload_start..payload_end];
                if !payload_keys_present(payload_slice, keys) {
                  payload_ok = false;
                }
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if line_index > 0usize {
      if domain_end > domain_start && rule_end > rule_start {
        let dom_slice: [u8] = trace[domain_start..domain_end];
        let rule_slice: [u8] = trace[rule_start..rule_end];
        let domain_match: bool =
            slice_is_empty(domain) || slice_is_dash(domain) ||
            slices_equal(dom_slice, domain);
        if domain_match && slices_equal(rule_slice, rule_id) {
          count = count + 1usize;
          if !slice_is_empty(keys) && !slice_is_dash(keys) {
            let payload_slice: [u8] = trace[payload_start..payload_end];
            if !payload_keys_present(payload_slice, keys) {
              payload_ok = false;
            }
          }
        }
      }
    }
  }

  return RuleScan { count: count, payload_ok: payload_ok };
}

procedure verify_rules(fs: $FileSystem,
                       rules: [u8],
                       trace: [u8],
                       trace_domain: const [u8]) -> usize {
  let msg_rule_parse = "RuleParse";
  let msg_missing_rule = "missing_rule_id";
  let msg_bad_min = "bad_min_count";
  let msg_bad_max = "bad_max_count";
  let msg_payload_keys = "payload_keys_missing";
  let msg_count_below = "count_below_min";
  let msg_count_above = "count_above_max";
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var min_start: usize = 0usize;
  var min_end: usize = 0usize;
  var max_start: usize = 0usize;
  var max_end: usize = 0usize;
  var keys_start: usize = 0usize;
  var keys_end: usize = 0usize;

  loop b in rules {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 1usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        min_start = field_start;
        min_end = field_end;
      } else if field_index == 3usize {
        max_start = field_start;
        max_end = field_end;
      } else if field_index == 4usize {
        keys_start = field_start;
        keys_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice = rules[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let rule_slice = slice_trim_cr(rules[rule_start..rule_end]);
              let domain_slice = slice_trim_cr(rules[domain_start..domain_end]);
              let min_slice = slice_trim_cr(rules[min_start..min_end]);
              let max_slice = slice_trim_cr(rules[max_start..max_end]);
              let keys_slice = slice_trim_cr(rules[keys_start..keys_end]);

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Rule domain doesn't apply to this trace.
              } else if slice_is_empty(rule_slice) {
                write_fail(fs, msg_rule_parse, msg_missing_rule);
                failures = failures + 1usize;
              } else {
                let rule_name: string@View = string_from_slice(rule_slice);
                var min_val: usize = 0usize;
                if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
                  let min_parsed: ParseUsizeResult = parse_usize(min_slice);
                  if min_parsed.ok {
                    min_val = min_parsed.value;
                  } else {
                    write_fail(fs, rule_name, msg_bad_min);
                    failures = failures + 1usize;
                  }
                }

                var max_specified: bool = false;
                var max_val: usize = 0usize;
                if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
                  let max_parsed: ParseUsizeResult = parse_usize(max_slice);
                  if max_parsed.ok {
                    max_val = max_parsed.value;
                    max_specified = true;
                  } else {
                    write_fail(fs, rule_name, msg_bad_max);
                    failures = failures + 1usize;
                  }
                }

                let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
                if !scan.payload_ok {
                  write_fail(fs, rule_name, msg_payload_keys);
                  failures = failures + 1usize;
                }
                if scan.count < min_val {
                  write_fail(fs, rule_name, msg_count_below);
                  failures = failures + 1usize;
                }
                if max_specified && scan.count > max_val {
                  write_fail(fs, rule_name, msg_count_above);
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        rule_start = 0usize;
        rule_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        min_start = 0usize;
        min_end = 0usize;
        max_start = 0usize;
        max_end = 0usize;
        keys_start = 0usize;
        keys_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice = rules[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let rule_slice = slice_trim_cr(rules[rule_start..rule_end]);
        let domain_slice = slice_trim_cr(rules[domain_start..domain_end]);
        let min_slice = slice_trim_cr(rules[min_start..min_end]);
        let max_slice = slice_trim_cr(rules[max_start..max_end]);
        let keys_slice = slice_trim_cr(rules[keys_start..keys_end]);

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Rule domain doesn't apply to this trace.
        } else if !slice_is_empty(rule_slice) {
          let rule_name: string@View = string_from_slice(rule_slice);
          var min_val: usize = 0usize;
          if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
            let min_parsed: ParseUsizeResult = parse_usize(min_slice);
            if min_parsed.ok {
              min_val = min_parsed.value;
            } else {
              write_fail(fs, rule_name, msg_bad_min);
              failures = failures + 1usize;
            }
          }

          var max_specified: bool = false;
          var max_val: usize = 0usize;
          if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
            let max_parsed: ParseUsizeResult = parse_usize(max_slice);
            if max_parsed.ok {
              max_val = max_parsed.value;
              max_specified = true;
            } else {
              write_fail(fs, rule_name, msg_bad_max);
              failures = failures + 1usize;
            }
          }

          let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
          if !scan.payload_ok {
            write_fail(fs, rule_name, msg_payload_keys);
            failures = failures + 1usize;
          }
          if scan.count < min_val {
            write_fail(fs, rule_name, msg_count_below);
            failures = failures + 1usize;
          }
          if max_specified && scan.count > max_val {
            write_fail(fs, rule_name, msg_count_above);
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure find_before_in_group(trace: [u8],
                               domain: [u8],
                               before_rule: [u8],
                               group_keys: [u8],
                               target_payload: [u8],
                               stop_idx: usize) -> EdgeCheckResult {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    if idx >= stop_idx {
      break;
    }
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, before_rule) {
              let payload_slice: [u8] = trace[payload_start..payload_end];
              let group = payload_group_matches(payload_slice, target_payload, group_keys);
              if group.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              if group.matches {
                return EdgeCheckResult { ok: true, missing: false };
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: [u8] = trace[domain_start..domain_end];
      let rule_slice: [u8] = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, before_rule) {
        let payload_slice: [u8] = trace[payload_start..payload_end];
        let group = payload_group_matches(payload_slice, target_payload, group_keys);
        if group.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        if group.matches {
          return EdgeCheckResult { ok: true, missing: false };
        }
      }
    }
  }

  return EdgeCheckResult { ok: false, missing: false };
}

procedure check_edge_order_grouped(trace: [u8],
                                   domain: [u8],
                                   before_rule: [u8],
                                   after_rule: [u8],
                                   group_keys: [u8]) -> EdgeCheckResult {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, after_rule) {
              let payload_slice: [u8] = trace[payload_start..payload_end];
              let self_group = payload_group_matches(payload_slice, payload_slice, group_keys);
              if self_group.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              let found = find_before_in_group(trace,
                                               domain,
                                               before_rule,
                                               group_keys,
                                               payload_slice,
                                               line_start);
              if found.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              if !found.ok {
                return EdgeCheckResult { ok: false, missing: false };
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: [u8] = trace[domain_start..domain_end];
      let rule_slice: [u8] = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, after_rule) {
        let payload_slice: [u8] = trace[payload_start..payload_end];
        let self_group = payload_group_matches(payload_slice, payload_slice, group_keys);
        if self_group.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        let found = find_before_in_group(trace,
                                         domain,
                                         before_rule,
                                         group_keys,
                                         payload_slice,
                                         line_start);
        if found.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        if !found.ok {
          return EdgeCheckResult { ok: false, missing: false };
        }
      }
    }
  }

  return EdgeCheckResult { ok: true, missing: false };
}

procedure check_edge_order(trace: [u8],
                           domain: [u8],
                           before_rule: [u8],
                           after_rule: [u8]) -> bool {
  var seen_before: bool = false;
  var violation: bool = false;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: [u8] = trace[domain_start..domain_end];
            let rule_slice: [u8] = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, before_rule) {
              seen_before = true;
            }
            if domain_match && slices_equal(rule_slice, after_rule) {
              if !seen_before {
                violation = true;
                break;
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if !violation && idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: [u8] = trace[domain_start..domain_end];
      let rule_slice: [u8] = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, before_rule) {
        seen_before = true;
      }
      if domain_match && slices_equal(rule_slice, after_rule) {
        if !seen_before {
          violation = true;
        }
      }
    }
  }

  return !violation;
}

procedure verify_edges(fs: $FileSystem,
                       edges: [u8],
                       trace: [u8],
                       trace_domain: const [u8]) -> usize {
  let msg_edge_group_missing = "edge_group_by_missing";
  let msg_edge_violation = "edge_order_violation";
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var before_start: usize = 0usize;
  var before_end: usize = 0usize;
  var after_start: usize = 0usize;
  var after_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var group_start: usize = 0usize;
  var group_end: usize = 0usize;

  loop b in edges {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        before_start = field_start;
        before_end = field_end;
      } else if field_index == 1usize {
        after_start = field_start;
        after_end = field_end;
      } else if field_index == 2usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 3usize {
        group_start = field_start;
        group_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice = edges[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let before_slice = slice_trim_cr(edges[before_start..before_end]);
              let after_slice = slice_trim_cr(edges[after_start..after_end]);
              let domain_slice = slice_trim_cr(edges[domain_start..domain_end]);
              let group_slice = slice_trim_cr(edges[group_start..group_end]);
              let before_name: string@View = string_from_slice(before_slice);

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Edge domain doesn't apply to this trace.
              } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
                let check: EdgeCheckResult =
                    check_edge_order_grouped(trace, domain_slice, before_slice, after_slice, group_slice);
                if check.missing {
                  write_fail(fs, before_name, msg_edge_group_missing);
                  failures = failures + 1usize;
                } else if !check.ok {
                  write_fail(fs, before_name, msg_edge_violation);
                  failures = failures + 1usize;
                }
              } else {
                let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
                if !ok {
                  write_fail(fs, before_name, msg_edge_violation);
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        before_start = 0usize;
        before_end = 0usize;
        after_start = 0usize;
        after_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        group_start = 0usize;
        group_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice = edges[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let before_slice = slice_trim_cr(edges[before_start..before_end]);
        let after_slice = slice_trim_cr(edges[after_start..after_end]);
        let domain_slice = slice_trim_cr(edges[domain_start..domain_end]);
        let group_slice = slice_trim_cr(edges[group_start..group_end]);
        let before_name: string@View = string_from_slice(before_slice);

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Edge domain doesn't apply to this trace.
        } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
          let check: EdgeCheckResult =
              check_edge_order_grouped(trace, domain_slice, before_slice, after_slice, group_slice);
          if check.missing {
            write_fail(fs, before_name, msg_edge_group_missing);
            failures = failures + 1usize;
          } else if !check.ok {
            write_fail(fs, before_name, msg_edge_violation);
            failures = failures + 1usize;
          }
        } else {
          let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
          if !ok {
            write_fail(fs, before_name, msg_edge_violation);
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure diag_map_has_code(diag_map: const [u8], code: const [u8]) -> bool {
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  var field_start: usize = 0usize;
  var field_index: usize = 0usize;
  var code_start: usize = 0usize;
  var code_end: usize = 0usize;

  loop b in diag_map {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        code_start = field_start;
        code_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice = diag_map[line_start..line_end];
          if slice_len(line_slice) != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              if code_end > code_start {
                let map_code = diag_map[code_start..code_end];
                if slices_equal(map_code, code) {
                  return true;
                }
              }
            }
          }
        }
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        code_start = 0usize;
        code_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_slice = diag_map[line_start..idx];
    if slice_len(line_slice) != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        if code_end > code_start {
          let map_code = diag_map[code_start..code_end];
          if slices_equal(map_code, code) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

procedure diag_map_has_entries(diag_map: const [u8]) -> bool {
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  loop b in diag_map {
    if b == 10u8 {
      let line_end: usize = idx;
      if line_end > line_start {
        let line_slice = diag_map[line_start..line_end];
        if slice_len(line_slice) != 0usize {
          let first: u8 = byte_at(line_slice, 0usize);
          if first != 35u8 {
            return true;
          }
        }
      }
      line_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  if idx > line_start {
    let line_slice = diag_map[line_start..idx];
    if slice_len(line_slice) != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        return true;
      }
    }
  }
  return false;
}

procedure verify_diag(fs: $FileSystem, diag_map: [u8], diag_codes: [u8]) -> usize {
  let msg_diag_unmapped = "diag_unmapped";
  if slice_is_empty(diag_codes) {
    return 0usize;
  }
  if !diag_map_has_entries(diag_map) {
    return 0usize;
  }
  var idx: usize = 0usize;
  var line_start: usize = 0usize;
  var failures: usize = 0usize;
  loop b in diag_codes {
    if b == 10u8 {
      let line_end: usize = idx;
      if line_end > line_start {
        let line_slice = diag_codes[line_start..line_end];
        let line_len: usize = slice_len(line_slice);
        if line_len != 0usize {
          let first: u8 = byte_at(line_slice, 0usize);
          if first != 35u8 {
            if !diag_map_has_code(diag_map, line_slice) {
              let code_name: string@View = string_from_slice(line_slice);
              write_fail(fs, code_name, msg_diag_unmapped);
              failures = failures + 1usize;
            }
          }
        }
      }
      line_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_slice = diag_codes[line_start..idx];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        if !diag_map_has_code(diag_map, line_slice) {
          let code_name: string@View = string_from_slice(line_slice);
          write_fail(fs, code_name, msg_diag_unmapped);
          failures = failures + 1usize;
        }
      }
    }
  }
  return failures;
}

public procedure main(move ctx: Context) -> i32 {
  let fs: $FileSystem = ctx.fs;

  let msg_trace_read = "TraceRead";
  let msg_trace_header = "TraceHeader";
  let msg_trace_header_expected = "expected spec_trace_v1";
  let msg_rules_read = "RulesRead";
  let msg_edges_read = "EdgesRead";
  let msg_diag_read = "DiagRead";

  let trace_path: string@View = "spec/trace_current.tsv";
  let rules_path: string@View = "spec/verifier_rules.tsv";
  let edges_path: string@View = "spec/verifier_edges.tsv";
  let rules_current_path: string@View = "spec/verifier_rules_current.tsv";
  let edges_current_path: string@View = "spec/verifier_edges_current.tsv";
  let diag_path: string@View = "spec/verifier_diag.tsv";

  let trace_res = fs~>read_bytes(trace_path);
  let trace_data: bytes@Managed = match move trace_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, msg_trace_read, trace_path);
      return 1i32;
    }
  };
  let trace_view: bytes@View = bytes::as_view(trace_data);
  let trace_slice: [u8] = slice_from_bytes(trace_view);

  if !check_trace_header(trace_slice) {
    write_fail(fs, msg_trace_header, msg_trace_header_expected);
    return 1i32;
  }

  let rules_res = fs~>read_bytes(rules_current_path);
  let rules_data: bytes@Managed = match move rules_res {
    data: bytes@Managed => data,
    err: IoError => {
      let fallback = fs~>read_bytes(rules_path);
      match move fallback {
        fallback_data: bytes@Managed => fallback_data,
        fallback_err: IoError => {
          write_fail(fs, msg_rules_read, rules_path);
          return 1i32;
        }
      }
    }
  };
  let rules_view: bytes@View = bytes::as_view(rules_data);
  let rules_slice: [u8] = slice_from_bytes(rules_view);

  let edges_res = fs~>read_bytes(edges_current_path);
  let edges_data: bytes@Managed = match move edges_res {
    data: bytes@Managed => data,
    err: IoError => {
      let fallback = fs~>read_bytes(edges_path);
      match move fallback {
        fallback_data: bytes@Managed => fallback_data,
        fallback_err: IoError => {
          write_fail(fs, msg_edges_read, edges_path);
          return 1i32;
        }
      }
    }
  };
  let edges_view: bytes@View = bytes::as_view(edges_data);
  let edges_slice: [u8] = slice_from_bytes(edges_view);

  let diag_res = fs~>read_bytes(diag_path);
  let diag_data: bytes@Managed = match move diag_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, msg_diag_read, diag_path);
      return 1i32;
    }
  };
  let diag_view: bytes@View = bytes::as_view(diag_data);
  let diag_slice: [u8] = slice_from_bytes(diag_view);

  let diag_codes_path: string@View = "spec/diag_current.tsv";
  let diag_codes_res = fs~>read_bytes(diag_codes_path);
  let diag_codes_opt: bytes@Managed | () = match move diag_codes_res {
    data: bytes@Managed => data,
    err: IoError => ()
  };
  let diag_codes_slice: [u8] = match move diag_codes_opt {
    data: bytes@Managed => {
      let view: bytes@View = bytes::as_view(data);
      slice_from_bytes(view)
    },
    empty: () => {
      let empty_str = "";
      let view: bytes@View = bytes::view_string(empty_str);
      slice_from_bytes(view)
    }
  };

  var failures: usize = 0usize;
  let trace_domain_view: bytes@View = detect_trace_domain(trace_slice);
  let trace_domain_slice: [u8] = slice_from_bytes(trace_domain_view);

  failures = failures + verify_rules(fs, rules_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_edges(fs, edges_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_diag(fs, diag_slice, diag_codes_slice);

  if failures == 0usize {
    let ok_msg: string@View = "OK\n";
    write_stdout(fs, ok_msg);
    return 0i32;
  }
  return 1i32;
}
