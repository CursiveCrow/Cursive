record ParseUsizeResult {
  ok: bool,
  value: usize
}

record RuleScan {
  count: usize,
  payload_ok: bool
}

record HexResult {
  ok: bool,
  value: u8
}

record DecodeResult {
  ok: bool,
  value: u8,
  next: usize
}

record SegmentResult {
  found: bool,
  start: usize,
  end: usize
}

record GroupMatchResult {
  matches: bool,
  missing: bool
}

record EdgeCheckResult {
  ok: bool,
  missing: bool
}

record DiagMatchResult {
  found: bool,
  ok: bool
}

type ByteSlice = [u8]

procedure write_stdout(fs: $FileSystem, msg: string@View) -> () {
  let _ = match fs~>write_stdout(msg) {
    ok: () => (),
    err: IoError => ()
  };
  return ();
}

procedure write_fail(fs: $FileSystem, rule_id: string@View, msg: string@View) -> () {
  let fail_prefix: string@View = "FAIL|";
  let sep: string@View = "|";
  let newline: string@View = "\n";
  write_stdout(fs, fail_prefix);
  write_stdout(fs, rule_id);
  write_stdout(fs, sep);
  write_stdout(fs, msg);
  write_stdout(fs, newline);
  return ();
}

procedure slice_from_bytes(view: bytes@View) -> ByteSlice {
  let slice: ByteSlice = unsafe { transmute::<bytes@View, ByteSlice>(view) };
  return slice;
}

procedure string_from_slice(slice: ByteSlice) -> string@View {
  let view: bytes@View = bytes::view(slice);
  let out: string@View = unsafe { transmute::<bytes@View, string@View>(view) };
  return out;
}

procedure slice_len(slice: ByteSlice) -> usize {
  let view: bytes@View = bytes::view(slice);
  let len: usize = bytes::length(view);
  return len;
}

procedure byte_at(slice: ByteSlice, idx: usize) -> u8 {
  var i: usize = 0usize;
  loop b in slice {
    if i == idx {
      return b;
    }
    i = i + 1usize;
  }
  return 0u8;
}

procedure slices_equal(a: ByteSlice, b: ByteSlice) -> bool {
  let len_a: usize = slice_len(a);
  let len_b: usize = slice_len(b);
  if len_a != len_b {
    return false;
  }
  var idx: usize = 0usize;
  var ok: bool = true;
  loop v in a {
    let other: u8 = byte_at(b, idx);
    if v != other {
      ok = false;
      break;
    }
    idx = idx + 1usize;
  }
  return ok;
}

procedure slice_is_empty(slice: ByteSlice) -> bool {
  return slice_len(slice) == 0usize;
}

procedure slice_is_dash(slice: ByteSlice) -> bool {
  if slice_len(slice) != 1usize {
    return false;
  }
  return byte_at(slice, 0usize) == 45u8;
}

procedure parse_usize(slice: ByteSlice) -> ParseUsizeResult {
  var out: usize = 0usize;
  var seen: bool = false;
  loop b in slice {
    let d: usize = b as usize;
    if d < 48usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    if d > 57usize {
      return ParseUsizeResult { ok: false, value: 0usize };
    }
    out = out * 10usize + (d - 48usize);
    seen = true;
  }
  if !seen {
    return ParseUsizeResult { ok: false, value: 0usize };
  }
  return ParseUsizeResult { ok: true, value: out };
}

procedure hex_value(b: u8) -> HexResult {
  if b >= 48u8 && b <= 57u8 {
    return HexResult { ok: true, value: b - 48u8 };
  }
  if b >= 65u8 && b <= 70u8 {
    return HexResult { ok: true, value: b - 55u8 };
  }
  if b >= 97u8 && b <= 102u8 {
    return HexResult { ok: true, value: b - 87u8 };
  }
  return HexResult { ok: false, value: 0u8 };
}

procedure decode_next(slice: ByteSlice, idx: usize) -> DecodeResult {
  let len: usize = slice_len(slice);
  if idx >= len {
    return DecodeResult { ok: false, value: 0u8, next: idx };
  }
  let b: u8 = byte_at(slice, idx);
  if b != 37u8 {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  if idx + 2usize >= len {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  let hi: HexResult = hex_value(byte_at(slice, idx + 1usize));
  let lo: HexResult = hex_value(byte_at(slice, idx + 2usize));
  if !hi.ok || !lo.ok {
    return DecodeResult { ok: true, value: b, next: idx + 1usize };
  }
  let hi_val: usize = hi.value as usize;
  let lo_val: usize = lo.value as usize;
  let value: u8 = (hi_val * 16usize + lo_val) as u8;
  return DecodeResult { ok: true, value: value, next: idx + 3usize };
}

procedure decoded_equals(raw: ByteSlice, expected: ByteSlice) -> bool {
  let raw_len: usize = slice_len(raw);
  let exp_len: usize = slice_len(expected);
  var raw_idx: usize = 0usize;
  var exp_idx: usize = 0usize;
  loop {
    if raw_idx >= raw_len {
      break;
    }
    let decoded: DecodeResult = decode_next(raw, raw_idx);
    if !decoded.ok {
      return false;
    }
    if exp_idx >= exp_len {
      return false;
    }
    let exp_b: u8 = byte_at(expected, exp_idx);
    if decoded.value != exp_b {
      return false;
    }
    raw_idx = decoded.next;
    exp_idx = exp_idx + 1usize;
  }
  return exp_idx == exp_len;
}

procedure decoded_equals_pair(a: ByteSlice, b: ByteSlice) -> bool {
  let len_a: usize = slice_len(a);
  let len_b: usize = slice_len(b);
  var idx_a: usize = 0usize;
  var idx_b: usize = 0usize;
  loop {
    if idx_a >= len_a && idx_b >= len_b {
      return true;
    }
    if idx_a >= len_a || idx_b >= len_b {
      return false;
    }
    let dec_a: DecodeResult = decode_next(a, idx_a);
    let dec_b: DecodeResult = decode_next(b, idx_b);
    if !dec_a.ok || !dec_b.ok {
      return false;
    }
    if dec_a.value != dec_b.value {
      return false;
    }
    idx_a = dec_a.next;
    idx_b = dec_b.next;
  }
  return true;
}

procedure payload_find_value(payload: ByteSlice, key: ByteSlice) -> SegmentResult {
  if slice_is_empty(key) {
    return SegmentResult { found: false, start: 0usize, end: 0usize };
  }
  var seg_start: usize = 0usize;
  var eq_pos: usize = 0usize;
  var eq_found: bool = false;
  var idx: usize = 0usize;
  loop b in payload {
    if b == 61u8 && !eq_found {
      eq_pos = idx;
      eq_found = true;
    }
    if b == 59u8 {
      if eq_found {
        let seg_key: ByteSlice = payload[seg_start..eq_pos];
        if decoded_equals(seg_key, key) {
          return SegmentResult { found: true, start: eq_pos + 1usize, end: idx };
        }
      }
      seg_start = idx + 1usize;
      eq_found = false;
    }
    idx = idx + 1usize;
  }
  if eq_found {
    let seg_key: ByteSlice = payload[seg_start..eq_pos];
    if decoded_equals(seg_key, key) {
      return SegmentResult { found: true, start: eq_pos + 1usize, end: idx };
    }
  }
  return SegmentResult { found: false, start: 0usize, end: 0usize };
}

procedure payload_has_key(payload: ByteSlice, key: ByteSlice) -> bool {
  let seg: SegmentResult = payload_find_value(payload, key);
  return seg.found;
}

procedure payload_value_matches(payload: ByteSlice, key: ByteSlice, expected: ByteSlice) -> bool {
  let seg: SegmentResult = payload_find_value(payload, key);
  if !seg.found {
    return false;
  }
  let value_slice: ByteSlice = payload[seg.start..seg.end];
  return decoded_equals(value_slice, expected);
}

procedure payload_keys_present(payload: ByteSlice, keys: ByteSlice) -> bool {
  if slice_is_empty(keys) {
    return true;
  }
  if slice_is_dash(keys) {
    return true;
  }
  var key_start: usize = 0usize;
  var idx: usize = 0usize;
  loop b in keys {
    if b == 59u8 || b == 44u8 {
      let key_slice: ByteSlice = keys[key_start..idx];
      if !slice_is_empty(key_slice) {
        if !payload_has_key(payload, key_slice) {
          return false;
        }
      }
      key_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  let last_key: ByteSlice = keys[key_start..idx];
  if !slice_is_empty(last_key) {
    if !payload_has_key(payload, last_key) {
      return false;
    }
  }
  return true;
}

procedure payload_group_matches(payload_a: ByteSlice,
                                payload_b: ByteSlice,
                                keys: ByteSlice) -> GroupMatchResult {
  if slice_is_empty(keys) || slice_is_dash(keys) {
    return GroupMatchResult { matches: true, missing: false };
  }
  var key_start: usize = 0usize;
  var idx: usize = 0usize;
  loop b in keys {
    if b == 59u8 || b == 44u8 {
      let key_slice: ByteSlice = keys[key_start..idx];
      if !slice_is_empty(key_slice) {
        let seg_a: SegmentResult = payload_find_value(payload_a, key_slice);
        let seg_b: SegmentResult = payload_find_value(payload_b, key_slice);
        if !seg_a.found || !seg_b.found {
          return GroupMatchResult { matches: false, missing: true };
        }
        let val_a: ByteSlice = payload_a[seg_a.start..seg_a.end];
        let val_b: ByteSlice = payload_b[seg_b.start..seg_b.end];
        if !decoded_equals_pair(val_a, val_b) {
          return GroupMatchResult { matches: false, missing: false };
        }
      }
      key_start = idx + 1usize;
    }
    idx = idx + 1usize;
  }
  let last_key: ByteSlice = keys[key_start..idx];
  if !slice_is_empty(last_key) {
    let seg_a: SegmentResult = payload_find_value(payload_a, last_key);
    let seg_b: SegmentResult = payload_find_value(payload_b, last_key);
    if !seg_a.found || !seg_b.found {
      return GroupMatchResult { matches: false, missing: true };
    }
    let val_a: ByteSlice = payload_a[seg_a.start..seg_a.end];
    let val_b: ByteSlice = payload_b[seg_b.start..seg_b.end];
    if !decoded_equals_pair(val_a, val_b) {
      return GroupMatchResult { matches: false, missing: false };
    }
  }
  return GroupMatchResult { matches: true, missing: false };
}

procedure check_trace_header(trace: ByteSlice) -> bool {
  let total: usize = slice_len(trace);
  if total == 0usize {
    return false;
  }
  var idx: usize = 0usize;
  var line_end: usize = total;
  loop b in trace {
    if b == 10u8 {
      line_end = idx;
      break;
    }
    idx = idx + 1usize;
  }
  let header: ByteSlice = trace[0usize..line_end];
  let lit: bytes@View = bytes::view_string("spec_trace_v1");
  let lit_slice: ByteSlice = slice_from_bytes(lit);
  return slices_equal(header, lit_slice);
}

procedure detect_trace_domain(trace: ByteSlice) -> bytes@View {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start {
            let domain_slice: ByteSlice = trace[domain_start..domain_end];
            return bytes::view(domain_slice);
          }
        }
        line_index = line_index + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  return bytes::view_string("");
}

procedure scan_trace_for_rule(trace: ByteSlice,
                              domain: ByteSlice,
                              rule_id: ByteSlice,
                              keys: ByteSlice) -> RuleScan {
  var count: usize = 0usize;
  var payload_ok: bool = true;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: ByteSlice = trace[domain_start..domain_end];
            let rule_slice: ByteSlice = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, rule_id) {
              count = count + 1usize;
              if !slice_is_empty(keys) && !slice_is_dash(keys) {
                let payload_slice: ByteSlice = trace[payload_start..payload_end];
                if !payload_keys_present(payload_slice, keys) {
                  payload_ok = false;
                }
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if line_index > 0usize {
      if domain_end > domain_start && rule_end > rule_start {
        let dom_slice: ByteSlice = trace[domain_start..domain_end];
        let rule_slice: ByteSlice = trace[rule_start..rule_end];
        let domain_match: bool =
            slice_is_empty(domain) || slice_is_dash(domain) ||
            slices_equal(dom_slice, domain);
        if domain_match && slices_equal(rule_slice, rule_id) {
          count = count + 1usize;
          if !slice_is_empty(keys) && !slice_is_dash(keys) {
            let payload_slice: ByteSlice = trace[payload_start..payload_end];
            if !payload_keys_present(payload_slice, keys) {
              payload_ok = false;
            }
          }
        }
      }
    }
  }

  return RuleScan { count: count, payload_ok: payload_ok };
}

procedure verify_rules(fs: $FileSystem,
                       rules: ByteSlice,
                       trace: ByteSlice,
                       trace_domain: ByteSlice) -> usize {
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var min_start: usize = 0usize;
  var min_end: usize = 0usize;
  var max_start: usize = 0usize;
  var max_end: usize = 0usize;
  var keys_start: usize = 0usize;
  var keys_end: usize = 0usize;

  loop b in rules {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 1usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        min_start = field_start;
        min_end = field_end;
      } else if field_index == 3usize {
        max_start = field_start;
        max_end = field_end;
      } else if field_index == 4usize {
        keys_start = field_start;
        keys_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: ByteSlice = rules[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let rule_slice: ByteSlice = rules[rule_start..rule_end];
              let domain_slice: ByteSlice = rules[domain_start..domain_end];
              let min_slice: ByteSlice = rules[min_start..min_end];
              let max_slice: ByteSlice = rules[max_start..max_end];
              let keys_slice: ByteSlice = rules[keys_start..keys_end];

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Rule domain doesn't apply to this trace.
              } else if slice_is_empty(rule_slice) {
                write_fail(fs, "RuleParse", "missing_rule_id");
                failures = failures + 1usize;
              } else {
                var min_val: usize = 0usize;
                if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
                  let min_parsed: ParseUsizeResult = parse_usize(min_slice);
                  if min_parsed.ok {
                    min_val = min_parsed.value;
                  } else {
                    write_fail(fs, string_from_slice(rule_slice), "bad_min_count");
                    failures = failures + 1usize;
                  }
                }

                var max_specified: bool = false;
                var max_val: usize = 0usize;
                if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
                  let max_parsed: ParseUsizeResult = parse_usize(max_slice);
                  if max_parsed.ok {
                    max_val = max_parsed.value;
                    max_specified = true;
                  } else {
                    write_fail(fs, string_from_slice(rule_slice), "bad_max_count");
                    failures = failures + 1usize;
                  }
                }

                let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
                if !scan.payload_ok {
                  write_fail(fs, string_from_slice(rule_slice), "payload_keys_missing");
                  failures = failures + 1usize;
                }
                if scan.count < min_val {
                  write_fail(fs, string_from_slice(rule_slice), "count_below_min");
                  failures = failures + 1usize;
                }
                if max_specified && scan.count > max_val {
                  write_fail(fs, string_from_slice(rule_slice), "count_above_max");
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        rule_start = 0usize;
        rule_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        min_start = 0usize;
        min_end = 0usize;
        max_start = 0usize;
        max_end = 0usize;
        keys_start = 0usize;
        keys_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice: ByteSlice = rules[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let rule_slice: ByteSlice = rules[rule_start..rule_end];
        let domain_slice: ByteSlice = rules[domain_start..domain_end];
        let min_slice: ByteSlice = rules[min_start..min_end];
        let max_slice: ByteSlice = rules[max_start..max_end];
        let keys_slice: ByteSlice = rules[keys_start..keys_end];

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Rule domain doesn't apply to this trace.
        } else if !slice_is_empty(rule_slice) {
          var min_val: usize = 0usize;
          if !slice_is_empty(min_slice) && !slice_is_dash(min_slice) {
            let min_parsed: ParseUsizeResult = parse_usize(min_slice);
            if min_parsed.ok {
              min_val = min_parsed.value;
            } else {
              write_fail(fs, string_from_slice(rule_slice), "bad_min_count");
              failures = failures + 1usize;
            }
          }

          var max_specified: bool = false;
          var max_val: usize = 0usize;
          if !slice_is_empty(max_slice) && !slice_is_dash(max_slice) {
            let max_parsed: ParseUsizeResult = parse_usize(max_slice);
            if max_parsed.ok {
              max_val = max_parsed.value;
              max_specified = true;
            } else {
              write_fail(fs, string_from_slice(rule_slice), "bad_max_count");
              failures = failures + 1usize;
            }
          }

          let scan: RuleScan = scan_trace_for_rule(trace, domain_slice, rule_slice, keys_slice);
          if !scan.payload_ok {
            write_fail(fs, string_from_slice(rule_slice), "payload_keys_missing");
            failures = failures + 1usize;
          }
          if scan.count < min_val {
            write_fail(fs, string_from_slice(rule_slice), "count_below_min");
            failures = failures + 1usize;
          }
          if max_specified && scan.count > max_val {
            write_fail(fs, string_from_slice(rule_slice), "count_above_max");
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure find_before_in_group(trace: ByteSlice,
                               domain: ByteSlice,
                               before_rule: ByteSlice,
                               group_keys: ByteSlice,
                               target_payload: ByteSlice,
                               stop_idx: usize) -> EdgeCheckResult {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    if idx >= stop_idx {
      break;
    }
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: ByteSlice = trace[domain_start..domain_end];
            let rule_slice: ByteSlice = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, before_rule) {
              let payload_slice: ByteSlice = trace[payload_start..payload_end];
              let group = payload_group_matches(payload_slice, target_payload, group_keys);
              if group.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              if group.matches {
                return EdgeCheckResult { ok: true, missing: false };
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: ByteSlice = trace[domain_start..domain_end];
      let rule_slice: ByteSlice = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, before_rule) {
        let payload_slice: ByteSlice = trace[payload_start..payload_end];
        let group = payload_group_matches(payload_slice, target_payload, group_keys);
        if group.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        if group.matches {
          return EdgeCheckResult { ok: true, missing: false };
        }
      }
    }
  }

  return EdgeCheckResult { ok: false, missing: false };
}

procedure check_edge_order_grouped(trace: ByteSlice,
                                   domain: ByteSlice,
                                   before_rule: ByteSlice,
                                   after_rule: ByteSlice,
                                   group_keys: ByteSlice) -> EdgeCheckResult {
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: ByteSlice = trace[domain_start..domain_end];
            let rule_slice: ByteSlice = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, after_rule) {
              let payload_slice: ByteSlice = trace[payload_start..payload_end];
              let self_group = payload_group_matches(payload_slice, payload_slice, group_keys);
              if self_group.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              let found = find_before_in_group(trace,
                                               domain,
                                               before_rule,
                                               group_keys,
                                               payload_slice,
                                               line_start);
              if found.missing {
                return EdgeCheckResult { ok: false, missing: true };
              }
              if !found.ok {
                return EdgeCheckResult { ok: false, missing: false };
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: ByteSlice = trace[domain_start..domain_end];
      let rule_slice: ByteSlice = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, after_rule) {
        let payload_slice: ByteSlice = trace[payload_start..payload_end];
        let self_group = payload_group_matches(payload_slice, payload_slice, group_keys);
        if self_group.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        let found = find_before_in_group(trace,
                                         domain,
                                         before_rule,
                                         group_keys,
                                         payload_slice,
                                         line_start);
        if found.missing {
          return EdgeCheckResult { ok: false, missing: true };
        }
        if !found.ok {
          return EdgeCheckResult { ok: false, missing: false };
        }
      }
    }
  }

  return EdgeCheckResult { ok: true, missing: false };
}

procedure check_edge_order(trace: ByteSlice,
                           domain: ByteSlice,
                           before_rule: ByteSlice,
                           after_rule: ByteSlice) -> bool {
  var seen_before: bool = false;
  var violation: bool = false;

  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if domain_end > domain_start && rule_end > rule_start {
            let dom_slice: ByteSlice = trace[domain_start..domain_end];
            let rule_slice: ByteSlice = trace[rule_start..rule_end];
            let domain_match: bool =
                slice_is_empty(domain) || slice_is_dash(domain) ||
                slices_equal(dom_slice, domain);
            if domain_match && slices_equal(rule_slice, before_rule) {
              seen_before = true;
            }
            if domain_match && slices_equal(rule_slice, after_rule) {
              if !seen_before {
                violation = true;
                break;
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        domain_start = 0usize;
        domain_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if !violation && idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 0usize {
      domain_start = field_start;
      domain_end = field_end;
    } else if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    }
    if domain_end > domain_start && rule_end > rule_start {
      let dom_slice: ByteSlice = trace[domain_start..domain_end];
      let rule_slice: ByteSlice = trace[rule_start..rule_end];
      let domain_match: bool =
          slice_is_empty(domain) || slice_is_dash(domain) ||
          slices_equal(dom_slice, domain);
      if domain_match && slices_equal(rule_slice, before_rule) {
        seen_before = true;
      }
      if domain_match && slices_equal(rule_slice, after_rule) {
        if !seen_before {
          violation = true;
        }
      }
    }
  }

  return !violation;
}

procedure verify_edges(fs: $FileSystem,
                       edges: ByteSlice,
                       trace: ByteSlice,
                       trace_domain: ByteSlice) -> usize {
  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var before_start: usize = 0usize;
  var before_end: usize = 0usize;
  var after_start: usize = 0usize;
  var after_end: usize = 0usize;
  var domain_start: usize = 0usize;
  var domain_end: usize = 0usize;
  var group_start: usize = 0usize;
  var group_end: usize = 0usize;

  loop b in edges {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        before_start = field_start;
        before_end = field_end;
      } else if field_index == 1usize {
        after_start = field_start;
        after_end = field_end;
      } else if field_index == 2usize {
        domain_start = field_start;
        domain_end = field_end;
      } else if field_index == 3usize {
        group_start = field_start;
        group_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: ByteSlice = edges[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let before_slice: ByteSlice = edges[before_start..before_end];
              let after_slice: ByteSlice = edges[after_start..after_end];
              let domain_slice: ByteSlice = edges[domain_start..domain_end];
              let group_slice: ByteSlice = edges[group_start..group_end];

              if !slice_is_empty(trace_domain) &&
                 !slice_is_empty(domain_slice) &&
                 !slices_equal(domain_slice, trace_domain) {
                // Edge domain doesn't apply to this trace.
              } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
                let check: EdgeCheckResult =
                    check_edge_order_grouped(trace, domain_slice, before_slice, after_slice, group_slice);
                if check.missing {
                  write_fail(fs, string_from_slice(before_slice), "edge_group_by_missing");
                  failures = failures + 1usize;
                } else if !check.ok {
                  write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
                  failures = failures + 1usize;
                }
              } else {
                let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
                if !ok {
                  write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
                  failures = failures + 1usize;
                }
              }
            }
          }
        }

        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        before_start = 0usize;
        before_end = 0usize;
        after_start = 0usize;
        after_end = 0usize;
        domain_start = 0usize;
        domain_end = 0usize;
        group_start = 0usize;
        group_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice: ByteSlice = edges[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let before_slice: ByteSlice = edges[before_start..before_end];
        let after_slice: ByteSlice = edges[after_start..after_end];
        let domain_slice: ByteSlice = edges[domain_start..domain_end];
        let group_slice: ByteSlice = edges[group_start..group_end];

        if !slice_is_empty(trace_domain) &&
           !slice_is_empty(domain_slice) &&
           !slices_equal(domain_slice, trace_domain) {
          // Edge domain doesn't apply to this trace.
        } else if !slice_is_empty(group_slice) && !slice_is_dash(group_slice) {
          let check: EdgeCheckResult =
              check_edge_order_grouped(trace, domain_slice, before_slice, after_slice, group_slice);
          if check.missing {
            write_fail(fs, string_from_slice(before_slice), "edge_group_by_missing");
            failures = failures + 1usize;
          } else if !check.ok {
            write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
            failures = failures + 1usize;
          }
        } else {
          let ok: bool = check_edge_order(trace, domain_slice, before_slice, after_slice);
          if !ok {
            write_fail(fs, string_from_slice(before_slice), "edge_order_violation");
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

procedure match_diag_entry(diag: ByteSlice,
                           code: ByteSlice,
                           severity: ByteSlice,
                           message: ByteSlice) -> DiagMatchResult {
  var idx: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var code_start: usize = 0usize;
  var code_end: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var msg_start: usize = 0usize;
  var msg_end: usize = 0usize;
  var sev_start: usize = 0usize;
  var sev_end: usize = 0usize;

  loop b in diag {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 0usize {
        code_start = field_start;
        code_end = field_end;
      } else if field_index == 1usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 2usize {
        msg_start = field_start;
        msg_end = field_end;
      } else if field_index == 3usize {
        sev_start = field_start;
        sev_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        let line_end: usize = idx;
        if line_end > line_start {
          let line_slice: ByteSlice = diag[line_start..line_end];
          let line_len: usize = slice_len(line_slice);
          if line_len != 0usize {
            let first: u8 = byte_at(line_slice, 0usize);
            if first != 35u8 {
              let code_slice: ByteSlice = diag[code_start..code_end];
              if !slice_is_empty(code_slice) && decoded_equals(code, code_slice) {
                let rule_slice: ByteSlice = diag[rule_start..rule_end];
                if !slice_is_empty(rule_slice) && !slice_is_dash(rule_slice) {
                  return DiagMatchResult { found: true, ok: false };
                }
                let msg_slice: ByteSlice = diag[msg_start..msg_end];
                if !slice_is_empty(msg_slice) && !slice_is_dash(msg_slice) {
                  if !decoded_equals(message, msg_slice) {
                    return DiagMatchResult { found: true, ok: false };
                  }
                }
                let sev_slice: ByteSlice = diag[sev_start..sev_end];
                if !slice_is_empty(sev_slice) && !slice_is_dash(sev_slice) {
                  if !decoded_equals(severity, sev_slice) {
                    return DiagMatchResult { found: true, ok: false };
                  }
                }
                return DiagMatchResult { found: true, ok: true };
              }
            }
          }
        }
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        code_start = 0usize;
        code_end = 0usize;
        rule_start = 0usize;
        rule_end = 0usize;
        msg_start = 0usize;
        msg_end = 0usize;
        sev_start = 0usize;
        sev_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start {
    let line_end: usize = idx;
    let line_slice: ByteSlice = diag[line_start..line_end];
    let line_len: usize = slice_len(line_slice);
    if line_len != 0usize {
      let first: u8 = byte_at(line_slice, 0usize);
      if first != 35u8 {
        let code_slice: ByteSlice = diag[code_start..code_end];
        if !slice_is_empty(code_slice) && decoded_equals(code, code_slice) {
          let rule_slice: ByteSlice = diag[rule_start..rule_end];
          if !slice_is_empty(rule_slice) && !slice_is_dash(rule_slice) {
            return DiagMatchResult { found: true, ok: false };
          }
          let msg_slice: ByteSlice = diag[msg_start..msg_end];
          if !slice_is_empty(msg_slice) && !slice_is_dash(msg_slice) {
            if !decoded_equals(message, msg_slice) {
              return DiagMatchResult { found: true, ok: false };
            }
          }
          let sev_slice: ByteSlice = diag[sev_start..sev_end];
          if !slice_is_empty(sev_slice) && !slice_is_dash(sev_slice) {
            if !decoded_equals(severity, sev_slice) {
              return DiagMatchResult { found: true, ok: false };
            }
          }
          return DiagMatchResult { found: true, ok: true };
        }
      }
    }
  }

  return DiagMatchResult { found: false, ok: true };
}

procedure verify_diag(fs: $FileSystem, trace: ByteSlice, diag: ByteSlice) -> usize {
  let diag_rule_view: bytes@View = bytes::view_string("Diag-Emit");
  let diag_rule_slice: ByteSlice = slice_from_bytes(diag_rule_view);
  let code_view: bytes@View = bytes::view_string("code");
  let severity_view: bytes@View = bytes::view_string("severity");
  let message_view: bytes@View = bytes::view_string("message");
  let code_key: ByteSlice = slice_from_bytes(code_view);
  let severity_key: ByteSlice = slice_from_bytes(severity_view);
  let message_key: ByteSlice = slice_from_bytes(message_view);

  var failures: usize = 0usize;
  var idx: usize = 0usize;
  var line_index: usize = 0usize;
  var line_start: usize = 0usize;

  var field_index: usize = 0usize;
  var field_start: usize = 0usize;
  var rule_start: usize = 0usize;
  var rule_end: usize = 0usize;
  var payload_start: usize = 0usize;
  var payload_end: usize = 0usize;

  loop b in trace {
    let is_tab: bool = b == 9u8;
    let is_nl: bool = b == 10u8;
    if is_tab || is_nl {
      let field_end: usize = idx;
      if field_index == 2usize {
        rule_start = field_start;
        rule_end = field_end;
      } else if field_index == 8usize {
        payload_start = field_start;
        payload_end = field_end;
      }
      field_index = field_index + 1usize;
      field_start = idx + 1usize;

      if is_nl {
        if line_index > 0usize {
          if rule_end > rule_start {
            let rule_slice: ByteSlice = trace[rule_start..rule_end];
            if slices_equal(rule_slice, diag_rule_slice) {
              let payload_slice: ByteSlice = trace[payload_start..payload_end];
              let code_seg: SegmentResult = payload_find_value(payload_slice, code_key);
              let severity_seg: SegmentResult = payload_find_value(payload_slice, severity_key);
              let message_seg: SegmentResult = payload_find_value(payload_slice, message_key);
              if !code_seg.found {
                write_fail(fs, "DiagVerify", "payload_missing_code");
                failures = failures + 1usize;
              } else if !severity_seg.found {
                write_fail(fs, "DiagVerify", "payload_missing_severity");
                failures = failures + 1usize;
              } else if !message_seg.found {
                write_fail(fs, "DiagVerify", "payload_missing_message");
                failures = failures + 1usize;
              } else {
                let code_slice: ByteSlice = payload_slice[code_seg.start..code_seg.end];
                let severity_slice: ByteSlice = payload_slice[severity_seg.start..severity_seg.end];
                let message_slice: ByteSlice = payload_slice[message_seg.start..message_seg.end];
                let diag_match: DiagMatchResult =
                    match_diag_entry(diag, code_slice, severity_slice, message_slice);
                if !diag_match.found {
                  write_fail(fs, string_from_slice(code_slice), "diag_unknown");
                  failures = failures + 1usize;
                } else if !diag_match.ok {
                  write_fail(fs, string_from_slice(code_slice), "diag_mismatch");
                  failures = failures + 1usize;
                }
              }
            }
          }
        }
        line_index = line_index + 1usize;
        line_start = idx + 1usize;
        field_index = 0usize;
        field_start = idx + 1usize;
        rule_start = 0usize;
        rule_end = 0usize;
        payload_start = 0usize;
        payload_end = 0usize;
      }
    }
    idx = idx + 1usize;
  }

  if idx > line_start && line_index > 0usize {
    let field_end: usize = idx;
    if field_index == 2usize {
      rule_start = field_start;
      rule_end = field_end;
    } else if field_index == 8usize {
      payload_start = field_start;
      payload_end = field_end;
    }
    if rule_end > rule_start {
      let rule_slice: ByteSlice = trace[rule_start..rule_end];
      if slices_equal(rule_slice, diag_rule_slice) {
        let payload_slice: ByteSlice = trace[payload_start..payload_end];
        let code_seg: SegmentResult = payload_find_value(payload_slice, code_key);
        let severity_seg: SegmentResult = payload_find_value(payload_slice, severity_key);
        let message_seg: SegmentResult = payload_find_value(payload_slice, message_key);
        if !code_seg.found {
          write_fail(fs, "DiagVerify", "payload_missing_code");
          failures = failures + 1usize;
        } else if !severity_seg.found {
          write_fail(fs, "DiagVerify", "payload_missing_severity");
          failures = failures + 1usize;
        } else if !message_seg.found {
          write_fail(fs, "DiagVerify", "payload_missing_message");
          failures = failures + 1usize;
        } else {
          let code_slice: ByteSlice = payload_slice[code_seg.start..code_seg.end];
          let severity_slice: ByteSlice = payload_slice[severity_seg.start..severity_seg.end];
          let message_slice: ByteSlice = payload_slice[message_seg.start..message_seg.end];
          let diag_match: DiagMatchResult =
              match_diag_entry(diag, code_slice, severity_slice, message_slice);
          if !diag_match.found {
            write_fail(fs, string_from_slice(code_slice), "diag_unknown");
            failures = failures + 1usize;
          } else if !diag_match.ok {
            write_fail(fs, string_from_slice(code_slice), "diag_mismatch");
            failures = failures + 1usize;
          }
        }
      }
    }
  }

  return failures;
}

public procedure main(move ctx: Context) -> i32 {
  let fs: $FileSystem = ctx.fs;

  let trace_path: string@View = "spec/trace_current.tsv";
  let rules_path: string@View = "spec/verifier_rules.tsv";
  let edges_path: string@View = "spec/verifier_edges.tsv";
  let diag_path: string@View = "spec/verifier_diag.tsv";

  let trace_res = fs~>read_bytes(trace_path);
  let trace_data: bytes@Managed = match move trace_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "TraceRead", trace_path);
      return 1i32;
    }
  };
  let trace_view: bytes@View = bytes::as_view(trace_data);
  let trace_slice: ByteSlice = slice_from_bytes(trace_view);

  if !check_trace_header(trace_slice) {
    write_fail(fs, "TraceHeader", "expected spec_trace_v1");
    return 1i32;
  }

  let rules_res = fs~>read_bytes(rules_path);
  let rules_data: bytes@Managed = match move rules_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "RulesRead", rules_path);
      return 1i32;
    }
  };
  let rules_view: bytes@View = bytes::as_view(rules_data);
  let rules_slice: ByteSlice = slice_from_bytes(rules_view);

  let edges_res = fs~>read_bytes(edges_path);
  let edges_data: bytes@Managed = match move edges_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "EdgesRead", edges_path);
      return 1i32;
    }
  };
  let edges_view: bytes@View = bytes::as_view(edges_data);
  let edges_slice: ByteSlice = slice_from_bytes(edges_view);

  let diag_res = fs~>read_bytes(diag_path);
  let diag_data: bytes@Managed = match move diag_res {
    data: bytes@Managed => data,
    err: IoError => {
      write_fail(fs, "DiagRead", diag_path);
      return 1i32;
    }
  };
  let diag_view: bytes@View = bytes::as_view(diag_data);
  let diag_slice: ByteSlice = slice_from_bytes(diag_view);

  var failures: usize = 0usize;
  let trace_domain_view: bytes@View = detect_trace_domain(trace_slice);
  let trace_domain_slice: ByteSlice = slice_from_bytes(trace_domain_view);

  failures = failures + verify_rules(fs, rules_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_edges(fs, edges_slice, trace_slice, trace_domain_slice);
  failures = failures + verify_diag(fs, trace_slice, diag_slice);

  if failures == 0usize {
    let ok_msg: string@View = "OK\n";
    write_stdout(fs, ok_msg);
    return 0i32;
  }
  return 1i32;
}
