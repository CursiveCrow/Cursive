#!/usr/bin/env python3
import argparse
import re
import sys
from pathlib import Path

CODE_RE = re.compile(r"^[EWI]-[A-Z]{3}-[0-9]{4}$")
TABLE_RE = re.compile(r"^###\s+8\.\d+\.\s+([A-Z]-[A-Z]{3})")


def strip_ticks(text: str) -> str:
    text = text.strip()
    if text.startswith("`") and text.endswith("`") and len(text) >= 2:
        return text[1:-1].strip()
    return text


def parse_table_row(line: str) -> list:
    raw = line.strip()
    if not raw.startswith("|"):
        return []
    raw = raw.strip("|")
    return [cell.strip() for cell in raw.split("|")]


def c_escape(text: str) -> str:
    text = text.replace("\\", "\\\\")
    text = text.replace('"', "\\\"")
    text = text.replace("\n", "\\n")
    text = text.replace("\r", "\\r")
    return text


def parse_spec(spec_path: Path):
    text = spec_path.read_text(encoding="utf-8")
    lines = text.splitlines()

    rows = []
    seen = {}
    in_appendix = False
    current_table = None
    i = 0

    while i < len(lines):
        line = lines[i]

        if line.startswith("## 8. Appendix A - Diagnostic Codes"):
            in_appendix = True
            i += 1
            continue

        if in_appendix and line.startswith("## ") and not line.startswith("###"):
            break

        if in_appendix:
            m = TABLE_RE.match(line)
            if m:
                current_table = m.group(1)

            if line.lstrip().startswith("|") and "Code" in line and "Condition" in line:
                headers = [h.lower().replace(" ", "") for h in parse_table_row(line)]
                if i + 1 >= len(lines):
                    raise ValueError("Unexpected end of file after table header")
                i += 1  # skip separator row
                i += 1
                if i >= len(lines):
                    break
                for j in range(i, len(lines)):
                    row_line = lines[j]
                    if not row_line.lstrip().startswith("|"):
                        i = j - 1
                        break
                    cells = parse_table_row(row_line)
                    if not cells:
                        continue
                    if len(cells) < len(headers):
                        raise ValueError(f"Row has too few cells: {row_line}")
                    if any(set(cell.strip()) <= set(":- ") for cell in cells):
                        continue

                    def idx(name: str) -> int:
                        name = name.lower().replace(" ", "")
                        if name not in headers:
                            raise ValueError(f"Missing column '{name}' in table header")
                        return headers.index(name)

                    code = strip_ticks(cells[idx("code")])
                    severity = strip_ticks(cells[idx("severity")])
                    condition = cells[idx("condition")].strip()

                    if not CODE_RE.match(code):
                        raise ValueError(f"Invalid diagnostic code format: {code}")
                    if severity not in {"Error", "Warning"}:
                        raise ValueError(f"Unsupported severity for {code}: {severity}")
                    if any(ord(ch) > 127 for ch in condition):
                        raise ValueError(f"Non-ASCII condition for {code}")

                    if code in seen:
                        prev = seen[code]
                        if prev["condition"] != condition or prev["severity"] != severity:
                            raise ValueError(
                                f"Inconsistent rows for {code}: {prev} vs {row_line}"
                            )
                    else:
                        seen[code] = {
                            "code": code,
                            "severity": severity,
                            "condition": condition,
                            "table": current_table or "",
                        }
                        rows.append(seen[code])
                i += 1
                continue

        i += 1

    rows.sort(key=lambda row: row["code"])
    return rows


def render(rows) -> str:
    lines = []
    lines.append("// Generated by tools/diag_message_gen.py. DO NOT EDIT.")
    lines.append("// Source: docs/Cursive0.md")
    lines.append("")
    lines.append("static const DiagMessageEntry kDiagMessages[] = {")
    for row in rows:
        code = row["code"]
        cond = c_escape(row["condition"])
        sev = row["severity"]
        sev_expr = "Severity::Error" if sev == "Error" else "Severity::Warning"
        lines.append(f"  {{\"{code}\", {sev_expr}, \"{cond}\"}},")
    lines.append("};")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    script_dir = Path(__file__).resolve().parent
    default_spec = script_dir / ".." / "docs" / "Cursive0.md"
    default_out = script_dir / ".." / "src" / "core" / "diagnostic_messages_table.inc"

    parser = argparse.ArgumentParser(
        description="Generate diagnostic message table from Cursive0.md"
    )
    parser.add_argument("--spec", default=str(default_spec), help="Path to Cursive0.md")
    parser.add_argument("--out", default=str(default_out), help="Output .inc path")
    parser.add_argument("--check", action="store_true", help="Check output matches existing file")

    args = parser.parse_args()

    spec_path = Path(args.spec)
    out_path = Path(args.out)

    rows = parse_spec(spec_path)
    out_text = render(rows)

    if args.check:
        if not out_path.exists():
            print(f"Missing output file: {out_path}", file=sys.stderr)
            return 1
        current = out_path.read_text(encoding="utf-8")
        if current != out_text:
            print("diagnostic_messages_table.inc is out of date. Re-run diag_message_gen.py.", file=sys.stderr)
            return 1
        return 0

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(out_text, encoding="utf-8")
    return 0


if __name__ == "__main__":
    sys.exit(main())
