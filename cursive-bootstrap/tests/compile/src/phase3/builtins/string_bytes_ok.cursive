# SPEC_COV: StringFrom-Ok
# SPEC_COV: StringFrom-Err
# SPEC_COV: StringAsView-Ok
# SPEC_COV: StringToManaged-Ok
# SPEC_COV: StringToManaged-Err
# SPEC_COV: StringCloneWith-Ok
# SPEC_COV: StringCloneWith-Err
# SPEC_COV: StringAppend-Ok
# SPEC_COV: StringAppend-Err
# SPEC_COV: StringLength
# SPEC_COV: StringIsEmpty
# SPEC_COV: BytesWithCapacity-Ok
# SPEC_COV: BytesWithCapacity-Err
# SPEC_COV: BytesFromSlice-Ok
# SPEC_COV: BytesFromSlice-Err
# SPEC_COV: BytesAsView-Ok
# SPEC_COV: BytesToManaged-Ok
# SPEC_COV: BytesToManaged-Err
# SPEC_COV: BytesView-Ok
# SPEC_COV: BytesViewString-Ok
# SPEC_COV: BytesAppend-Ok
# SPEC_COV: BytesAppend-Err
# SPEC_COV: BytesLength
# SPEC_COV: BytesIsEmpty

procedure use_string_bytes(heap: $HeapAllocator) -> () {
  let raw: *imm i32 = null;
  let heap_dyn: $HeapAllocator = unsafe {
    transmute::<(*imm i32, *imm i32), $HeapAllocator>((raw, raw))
  };

  let s_view: string@View = "hi";
  let cap: usize = 2;
  let arr: [u8; 2] = [1u8, 2u8];
  let slice: [u8] = arr;

  let _s_from = string::from(s_view, heap);
  let _s_to = string::to_managed(s_view, heap);
  let _s_len: usize = string::length(s_view);
  let _s_empty: bool = string::is_empty(s_view);

  let _b_with = bytes::with_capacity(cap, heap);
  let _b_from = bytes::from_slice(slice, heap);
  let b_view: bytes@View = bytes::view(slice);
  let b_view_string: bytes@View = bytes::view_string(s_view);
  let _b_to = bytes::to_managed(b_view, heap);
  let _b_len: usize = bytes::length(b_view_string);
  let _b_empty: bool = bytes::is_empty(b_view_string);

  let _b_from_dyn = bytes::from_slice(slice, heap_dyn);
  ()
}

public procedure main(ctx: Context) -> i32 {
  return 0;
}
