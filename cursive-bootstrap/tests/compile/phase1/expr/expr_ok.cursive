# SPEC_COV: Parse-Expr
# SPEC_COV: Parse-Range-To
# SPEC_COV: Parse-Range-ToInc
# SPEC_COV: Parse-Range-Full
# SPEC_COV: Parse-Range-Lhs
# SPEC_COV: Parse-RangeTail-None
# SPEC_COV: Parse-RangeTail-From
# SPEC_COV: Parse-RangeTail-Excl
# SPEC_COV: Parse-RangeTail-Incl
# SPEC_COV: Parse-LeftChain
# SPEC_COV: Parse-LeftChain-Stop
# SPEC_COV: Parse-LeftChain-Cons
# SPEC_COV: Parse-Power
# SPEC_COV: Parse-PowerTail-None
# SPEC_COV: Parse-PowerTail-Cons
# SPEC_COV: Parse-Cast
# SPEC_COV: Parse-CastTail-None
# SPEC_COV: Parse-CastTail-As
# SPEC_COV: Parse-Unary-Prefix
# SPEC_COV: Parse-Unary-Deref
# SPEC_COV: Parse-Unary-AddressOf
# SPEC_COV: Parse-Unary-Move
# SPEC_COV: Parse-Unary-Widen
# SPEC_COV: Parse-Unary-Postfix
# SPEC_COV: Parse-Postfix
# SPEC_COV: Parse-Literal-Expr
# SPEC_COV: Parse-Null-Ptr
# SPEC_COV: Parse-Alloc-Implicit
# SPEC_COV: Parse-Identifier-Expr
# SPEC_COV: Parse-Qualified-Name
# SPEC_COV: Parse-Qualified-Apply-Paren
# SPEC_COV: Parse-Qualified-Apply-Brace
# SPEC_COV: Parse-Parenthesized-Expr
# SPEC_COV: Parse-Tuple-Literal
# SPEC_COV: Parse-Array-Literal
# SPEC_COV: Parse-Record-Literal-ModalState
# SPEC_COV: Parse-Record-Literal
# SPEC_COV: Parse-If-Expr
# SPEC_COV: Parse-Match-Expr
# SPEC_COV: Parse-Loop-Expr
# SPEC_COV: Parse-Block-Expr
# SPEC_COV: Parse-Unsafe-Expr
# SPEC_COV: Parse-Transmute-Expr-ShiftSplit
# SPEC_COV: Parse-Transmute-Expr
# SPEC_COV: Parse-PostfixTail-Stop
# SPEC_COV: Parse-PostfixTail-Cons
# SPEC_COV: Postfix-Field
# SPEC_COV: Postfix-TupleIndex
# SPEC_COV: Postfix-Index
# SPEC_COV: Postfix-Call
# SPEC_COV: Postfix-MethodCall
# SPEC_COV: Postfix-Propagate
# SPEC_COV: Parse-ArgList-Empty
# SPEC_COV: Parse-ArgList-Cons
# SPEC_COV: Parse-Arg
# SPEC_COV: Parse-ArgMoveOpt-None
# SPEC_COV: Parse-ArgMoveOpt-Yes
# SPEC_COV: Parse-ExprList-Cons
# SPEC_COV: Parse-TupleExprElems-Empty
# SPEC_COV: Parse-TupleExprElems-Single
# SPEC_COV: Parse-TupleExprElems-Many
# SPEC_COV: Parse-FieldInitList-Cons
# SPEC_COV: Parse-FieldInit-Explicit
# SPEC_COV: Parse-FieldInit-Shorthand
# SPEC_COV: Parse-MatchArms-Cons
# SPEC_COV: Parse-MatchArm
# SPEC_COV: Parse-MatchArmsTail-End
# SPEC_COV: Parse-MatchArmsTail-Comma
# SPEC_COV: Parse-GuardOpt-None
# SPEC_COV: Parse-GuardOpt-Yes
# SPEC_COV: Parse-ArmBody-Block
# SPEC_COV: Parse-ArmBody-Expr
# SPEC_COV: Parse-ArgTail-End
# SPEC_COV: Parse-ArgTail-Comma
# SPEC_COV: Parse-ExprListTail-End
# SPEC_COV: Parse-ExprListTail-Comma
# SPEC_COV: Parse-FieldInitTail-End
# SPEC_COV: Parse-FieldInitTail-Comma
# SPEC_COV: Parse-LoopTail-Infinite
# SPEC_COV: Parse-LoopTail-Iter
# SPEC_COV: Parse-LoopTail-Cond
# SPEC_COV: TryParsePatternIn-Ok
# SPEC_COV: TryParsePatternIn-Fail
# SPEC_COV: Parse-ElseOpt-None
# SPEC_COV: Parse-ElseOpt-If
# SPEC_COV: Parse-ElseOpt-Block
# SPEC_COV: Parse-ExprOpt-None
# SPEC_COV: Parse-ExprOpt-Yes
# SPEC_COV: Parse-Place-Deref
# SPEC_COV: Parse-Place-Postfix
let r1 = .. let r2 = ..=x let r3 = x.. let r4 = x..y let r5 = x..=y let r6 = ..y let b1 = 1 + 2 * 3 let b2 = 1 << 2 let b3 = 1 & 2 | 3 ^ 4 let b4 = 1 == 2 || 3 != 4 let p = 2 ** 3 ** 4 let c = x as i32 let u1 = !x let u2 = -x let u3 = *x let u4 = &x let u5 = move x let u6 = widen x let u7 = &*x let pf1 = x.y let pf2 = x.0 let pf3 = x[0] let pf4 = x(1) let pf5 = x~>foo(1) let pf6 = x? let n = Ptr::null() let a = ^x let qn = Mod::val let qa = Mod::fun(1) let qb = Mod::Rec { f: 1 } let par = (1 + 2) let tup = (1, 2) let tup1 = (1;) let empty = () let arr = [1, 2] let rec = Rec { a: 1, b } let modal_state = Rec@State { a: 1 } let if1 = if true { } else { } let if2 = if true { } else if false { } let if3 = if true { } let m1 = match x { y => y } let m2 = match x { y if true => y, z => { } } let l1 = loop { } let l2 = loop x { } let l3 = loop x in y { } let blk = { } let un = unsafe { } let tr1 = transmute::<i32, i32>(x) let tr2 = transmute::<i32, i32>>(x) let call0 = foo() let call1 = foo(1) let call2 = foo(1, 2) let callm = foo(move x, y)

public procedure main(ctx: Context) -> i32 {
  0
}
