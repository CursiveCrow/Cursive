# Cursive 0

- [Cursive 0](#cursive-0)
  - [0. Front Matter](#0-front-matter)
    - [0.1. Status and Scope (Bootstrap, Informative)](#01-status-and-scope-bootstrap-informative)
    - [0.2. Deviations from the Root Specification (Cursive0)](#02-deviations-from-the-root-specification-cursive0)
    - [0.3. Bootstrap Milestones and Equivalence](#03-bootstrap-milestones-and-equivalence)
    - [0.4. Document Conventions](#04-document-conventions)
  - [1. Foundations](#1-foundations)
    - [1.1. Conformance](#11-conformance)
    - [1.2. Behavior Types](#12-behavior-types)
    - [1.4. Unsupported Constructs Policy](#14-unsupported-constructs-policy)
    - [1.5. Target and ABI Assumptions](#15-target-and-abi-assumptions)
    - [1.6. Diagnostics Infrastructure](#16-diagnostics-infrastructure)
    - [1.7. Host Primitives](#17-host-primitives)
  - [2. Phase 0: Build/Project Model](#2-phase-0-buildproject-model)
    - [2.1. Project Root and Manifest](#21-project-root-and-manifest)
    - [2.2. Assemblies](#22-assemblies)
    - [2.3. Deterministic Ordering and Case Folding](#23-deterministic-ordering-and-case-folding)
    - [2.4. Module Discovery](#24-module-discovery)
    - [2.5. Output Artifacts and Linking](#25-output-artifacts-and-linking)
    - [2.6. Tool Resolution and IR Assembly Inputs](#26-tool-resolution-and-ir-assembly-inputs)
    - [2.7. Unwind and FFI Surface](#27-unwind-and-ffi-surface)
  - [3. Phase 1: Source Loading, Lexing, Parsing](#3-phase-1-source-loading-lexing-parsing)
    - [3.1. Source Loading and Normalization](#31-source-loading-and-normalization)
    - [3.2. Lexical Analysis](#32-lexical-analysis)
    - [3.3. Grammar, Parsing, and AST Construction](#33-grammar-parsing-and-ast-construction)
    - [3.4. Module Aggregation](#34-module-aggregation)
  - [4. Phase 2: Compile-Time Execution (Deferred in Cursive0)](#4-phase-2-compile-time-execution-deferred-in-cursive0)
  - [5. Phase 3: Name Resolution + Type Checking](#5-phase-3-name-resolution--type-checking)
    - [5.1. Name Resolution and Scopes (Cursive0)](#51-name-resolution-and-scopes-cursive0)
    - [5.2. Type System Core (Cursive0)](#52-type-system-core-cursive0)
    - [5.3. Classes and Record Methods (Cursive0)](#53-classes-and-record-methods-cursive0)
    - [5.4. Modal Types (Definitions)](#54-modal-types-definitions)
    - [5.5. State-Specific Fields](#55-state-specific-fields)
    - [5.6. Transitions and State-Specific Methods](#56-transitions-and-state-specific-methods)
    - [5.7. Modal Widening (`widen`)](#57-modal-widening-widen)
    - [5.8. String and Bytes Types and States](#58-string-and-bytes-types-and-states)
    - [5.9. Capabilities and Context (Cursive0)](#59-capabilities-and-context-cursive0)
    - [5.10. Enum Discriminant Defaults](#510-enum-discriminant-defaults)
    - [5.11. Foundational Classes (Cursive0)](#511-foundational-classes-cursive0)
    - [5.12. Initialization Planning](#512-initialization-planning)
  - [6. Phase 4: Code Generation](#6-phase-4-code-generation)
    - [6.0. Codegen Model and Judgments](#60-codegen-model-and-judgments)
    - [6.1. Layout and Representation](#61-layout-and-representation)
    - [6.2. ABI Lowering (Cursive0)](#62-abi-lowering-cursive0)
    - [6.3. Symbols, Mangling, and Linkage](#63-symbols-mangling-and-linkage)
    - [6.4. Expression Lowering and Evaluation Order](#64-expression-lowering-and-evaluation-order)
    - [6.5. Statement and Block Lowering](#65-statement-and-block-lowering)
    - [6.6. Pattern Matching Lowering](#66-pattern-matching-lowering)
    - [6.7. Globals and Initialization](#67-globals-and-initialization)
    - [6.8. Cleanup, Drop, and Unwinding](#68-cleanup-drop-and-unwinding)
    - [6.9. Built-ins Runtime Interface](#69-built-ins-runtime-interface)
    - [6.10. Dynamic Dispatch](#610-dynamic-dispatch)
    - [6.11. Checks and Panic](#611-checks-and-panic)
    - [6.12. LLVM 21 Backend Requirements](#612-llvm-21-backend-requirements)
  - [7. Dynamic Semantics](#7-dynamic-semantics)
    - [7.1. Initialization Order and Poisoning](#71-initialization-order-and-poisoning)
    - [7.2. Modal Layout (Dynamic Semantics)](#72-modal-layout-dynamic-semantics)
    - [7.3. Modal Pattern Matching](#73-modal-pattern-matching)
    - [7.4. Deterministic Destruction and Unwinding (Cursive0)](#74-deterministic-destruction-and-unwinding-cursive0)
    - [7.5. String Literal Semantics](#75-string-literal-semantics)
    - [7.6. Dynamic Class Objects](#76-dynamic-class-objects)
    - [7.7. FileSystem and File Operations](#77-filesystem-and-file-operations)
    - [7.8. Interpreter Entrypoint (Project-Level)](#78-interpreter-entrypoint-project-level)
  - [8. Appendix A - Diagnostic Codes](#8-appendix-a---diagnostic-codes)
    - [8.0. DiagIdâ€“Code Map](#80-diagidâcode-map)
    - [8.1. E-PRJ (Project)](#81-e-prj-project)
    - [8.2. E-MOD (Module)](#82-e-mod-module)
    - [8.3. E-OUT (Output and Linking)](#83-e-out-output-and-linking)
    - [8.4. E-SRC (Source)](#84-e-src-source)
    - [8.5. E-CNF (Conformance / Limits)](#85-e-cnf-conformance--limits)
    - [8.6. E-UNS (Unsupported Constructs)](#86-e-uns-unsupported-constructs)
    - [8.7. E-MEM (Memory)](#87-e-mem-memory)
    - [8.8. W-MOD (Module Warnings)](#88-w-mod-module-warnings)
    - [8.9. W-SRC (Source Warnings)](#89-w-src-source-warnings)
    - [8.10. E-TYP (Types)](#810-e-typ-types)
    - [8.11. W-SYS (System Warnings)](#811-w-sys-system-warnings)
    - [8.12. E-SEM (Semantics)](#812-e-sem-semantics)
    - [8.13. W-SEM (Semantic Warnings)](#813-w-sem-semantic-warnings)
  - [9. Appendix B - Notation and Glossary](#9-appendix-b---notation-and-glossary)
    - [9.1. Notation Conventions](#91-notation-conventions)
    - [9.2. Helper Functions and Relations](#92-helper-functions-and-relations)

## 0. Front Matter

### 0.1. Status and Scope (Bootstrap, Informative)

**Phase.**
Phase = {Phase0, Phase1, Phase2, Phase3, Phase4}

**PhaseStatus.**
PhaseStatus = {Implemented, Deferred, InProgress}

**PhaseStatusMap.**
PhaseStatus(Phase0) = Implemented
PhaseStatus(Phase1) = Implemented
PhaseStatus(Phase2) = Deferred
PhaseStatus(Phase3) = InProgress
PhaseStatus(Phase4) = InProgress

**PhaseSection.**
PhaseSection(Phase0) = 2
PhaseSection(Phase1) = 3
PhaseSection(Phase2) = 4
PhaseSection(Phase3) = 5
PhaseSection(Phase4) = 6

### 0.2. Deviations from the Root Specification (Cursive0)

**DeviationId.**
DeviationId = {D_BootstrapEquivalence, D_SourceNormalization, D_ModuleOrdering, D_KeywordReservation, D_GenericTokenization, D_UnsafeSpanClassification, D_GroupingTrailingCommas, D_UnsupportedGrammarFamilies, D_SingleAssemblyVisibility, D_OverloadingScope, D_Permissions, D_ParamPassing, D_PointerAddressOf, D_RegionOptionsSyntax, D_TypeInference, D_RecordUpdate, D_RangeExpressions, D_RangePatterns, D_FieldVisibilityDefault, D_EnumDiscriminantControls, D_UnionLayout, D_LayoutAttributes, D_CallingConventionToolchain, D_SymbolVisibilityMechanism, D_FileSystemSemantics}

- `System` in Cursive0 omits `time()` and `get_env` returns `string | ()`; this is a bootstrap restriction.

**DeviationRef.**
DeviationRef(D_BootstrapEquivalence) = {"0.3.2"}
DeviationRef(D_SourceNormalization) = {"3.1.1"}
DeviationRef(D_ModuleOrdering) = {"2.3.1", "2.3.2", "2.3.3"}
DeviationRef(D_KeywordReservation) = {"3.2.3"}
DeviationRef(D_GenericTokenization) = {"3.2.9"}
DeviationRef(D_UnsafeSpanClassification) = {"3.2.12"}
DeviationRef(D_GroupingTrailingCommas) = {"3.3.4"}
DeviationRef(D_UnsupportedGrammarFamilies) = {"3.3.2.7"}
DeviationRef(D_SingleAssemblyVisibility) = {"5.1.4"}
DeviationRef(D_OverloadingScope) = {"5.1.5", "5.3"}
DeviationRef(D_Permissions) = {"1.1.1", "5.2.2"}
DeviationRef(D_ParamPassing) = {"5.2.4", "5.3.2", "5.2.15"}
DeviationRef(D_PointerAddressOf) = {"1.1.1", "5.2.12", "5.2.16"}
DeviationRef(D_RegionOptionsSyntax) = {"3.3.4", "5.2.17"}
DeviationRef(D_TypeInference) = {"5.2.9"}
DeviationRef(D_RecordUpdate) = {"3.3.4"}
DeviationRef(D_RangeExpressions) = {"5.2.12"}
DeviationRef(D_RangePatterns) = {"5.2.13"}
DeviationRef(D_FieldVisibilityDefault) = {"5.2.2", "5.3.2"}
DeviationRef(D_EnumDiscriminantControls) = {"5.10", "6.1.4"}
DeviationRef(D_UnionLayout) = {"6.1.4", "6.1.4.1"}
DeviationRef(D_LayoutAttributes) = {"6.1.3"}
DeviationRef(D_CallingConventionToolchain) = {"6.2.1", "6.2.3"}
DeviationRef(D_SymbolVisibilityMechanism) = {"6.3.4"}
DeviationRef(D_FileSystemSemantics) = {"7.7"}

### 0.3. Bootstrap Milestones and Equivalence

#### 0.3.1. Bootstrap Milestones and Invariants

**BootstrapCompiler.**
BootstrapCompiler = {cursivec0, cursivec1, cursivec2}

**BootstrapName.**
BootstrapName(cursivec0) = "cursivec0"
BootstrapName(cursivec1) = "cursivec1"
BootstrapName(cursivec2) = "cursivec2"

**BootstrapImpl.**
BootstrapImpl(cursivec0) = {"C++", "LLVM"}
BootstrapImpl(cursivec1) = {"Cursive"}
BootstrapImpl(cursivec2) = {"Cursive"}

**CompilerSourceProject.**
CompilerSource ∈ Project

**ProducesCompiler.**
ProducesCompiler : BootstrapCompiler × Project ⇀ BootstrapCompiler

**Milestone Invariants.**
M0 ⇔ Status(cursivec0, CompilerSource) = ok ∧ Subset(CompilerSource, S0)
M1 ⇔ Status(cursivec1, CompilerSource) = ok ∧ ProducesCompiler(cursivec1, CompilerSource) = cursivec2
M2 ⇔ ∀ P ∈ Project. BootstrapEq(cursivec1, cursivec2, P)

#### 0.3.2. Observable Behavior Equivalence for Bootstrap

**Compiler Observable Behavior.**

Under(p, O) ⇔ prefix(Normalize(p), Normalize(O))
IsFile(p) ⇔ FSKind(p) = File

DiagObs(d) = ⟨d.code, d.severity, d.message, d.span⟩
DiagStream(C, P) = [DiagObs(d_1), …, DiagObs(d_k)]
Status(C, P) = ok ⇔ ∀ d ∈ DiagStream(C, P). d.severity ≠ Error
Status(C, P) = fail ⇔ ∃ d ∈ DiagStream(C, P). d.severity = Error
ExitCode(C, P) = 0 ⇔ Status(C, P) = ok
ExitCode(C, P) = 1 ⇔ Status(C, P) = fail
Executable(P) ⇔ P.assembly.kind = `executable`
IRSet(P) = {IRPath(P, m, e) | m ∈ ModuleList(P)} if P.assembly.emit_ir = e ∈ {"ll", "bc"}
IRSet(P) = ∅ if P.assembly.emit_ir ∉ {"ll", "bc"}
ExeSet(P) =
 {ExePath(P)}  if Executable(P)
 ∅             otherwise
RequiredOutputs(P) = {ObjPath(P, m) | m ∈ ModuleList(P)} ∪ IRSet(P) ∪ ExeSet(P)
Artifacts(C, P) = RequiredOutputs(P) ⇔ Status(C, P) = ok
Artifacts(C, P) = ∅ ⇔ Status(C, P) = fail

ObsComp(C, P) = ⟨Status(C, P), ExitCode(C, P), DiagStream(C, P), Artifacts(C, P)⟩

**Bootstrap Equivalence.**
BootstrapEq(C_a, C_b, P) ⇔ ObsComp(C_a, P) = ObsComp(C_b, P) ∧ (Status(C_a, P) = ok ⇒ Artifacts(C_a, P) = RequiredOutputs(P))

### 0.4. Document Conventions

**NormativeKeywords.**
NormativeKeywords = {`MUST`, `MUST NOT`, `SHOULD`, `SHOULD NOT`, `MAY`}

**DocScope.**
DocScope = {ConformanceTarget, SupportedSubset, RequiredBehavior(`cursivec0`)}

**DiagnosticCodeFormat.**
DiagPrefix = {E, W, I}
DiagCategory = [A-Z]^3
DiagDigits = [0-9]^4
DiagCode = DiagPrefix ++ "-" ++ DiagCategory ++ "-" ++ DiagDigits
Bucket(Digits) = Digits[0..1]
Seq(Digits) = Digits[2..3]

## 1. Foundations

### 1.1. Conformance

**C0Conforming.**
C0Conforming(P) ⇔ WF(P) ∧ Subset(P, S0)

**WF.**
WF(P) ⇔ ∃ Γ. Project(Γ) = P ∧ ∀ j ∈ ReqJudgments(P). Γ ⊢ j ⇓ ok

**ReqJudgments.**
ReqJudgments(P) = [Phase1Order(P), Phase3Order(P), Phase4Order(P)]

**Phase1Order.**
Γ ⊢ Phase1Order(P) ⇓ ok ⇔ ∃ Ms. Γ ⊢ ParseModules(P) ⇓ Ms

**Phase4Order.**
Γ ⊢ Phase4Order(P) ⇓ ok ⇔ ∃ Objs, IRs, Exe. Γ ⊢ OutputPipeline(P) ⇓ (Objs, IRs, Exe)

**Constructs.**
TypeNodes(P, m) = { t | t ∈ Type ∧ Subnode(ASTModule(P, m), t) }
StmtNodes(P, m) = { s | s ∈ Stmt ∧ Subnode(ASTModule(P, m), s) }

ItemKind(UsingDecl(_)) = `using_decl`
ItemKind(ProcedureDecl(_, _, _, _, _, _, _)) = `procedure`
ItemKind(RecordDecl(_, _, _, _, _, _)) = `record`
ItemKind(EnumDecl(_, _, _, _, _, _)) = `enum`
ItemKind(ModalDecl(_, _, _, _, _, _)) = `modal`
ItemKind(ClassDecl(_, _, _, _, _)) = `class`
ItemKind(TypeAliasDecl(_, _, _, _, _)) = `type_alias`
ItemKind(StaticDecl(_, _, _, _, _)) = `static_decl`
ItemKind(_) = ⊥

TopDeclConstructs(P) = { ItemKind(it) | m ∈ P.modules ∧ it ∈ ASTModule(P, m).items ∧ ItemKind(it) ≠ ⊥ }

TypeCtor(TypePerm(_, base)) = TypeCtor(base)
TypeCtor(TypePrim(name)) = {name}
TypeCtor(TypeTuple(elems)) = {`tuple`} ∪ ⋃_{t ∈ elems} TypeCtor(t)
TypeCtor(TypeArray(elem, _)) = {`array`} ∪ TypeCtor(elem)
TypeCtor(TypeSlice(elem)) = {`slice`} ∪ TypeCtor(elem)
TypeCtor(TypeUnion(members)) = {`union`} ∪ ⋃_{t ∈ members} TypeCtor(t)
TypeCtor(TypeFunc(params, ret)) = {`function`} ∪ ⋃_{⟨_, t⟩ ∈ params} TypeCtor(t) ∪ TypeCtor(ret)
TypeCtor(TypePtr(elem, _)) = {`ptr`} ∪ TypeCtor(elem)
TypeCtor(TypeRawPtr(_, elem)) = {`rawptr`} ∪ TypeCtor(elem)
TypeCtor(TypeString(_)) = {`string`}
TypeCtor(TypeBytes(_)) = {`bytes`}
TypeCtor(TypeDynamic(_)) = {`dyn_class`}
TypeCtor(TypeModalState(_, _)) = {`modal`}
TypeCtor(TypePath(["Region"])) = {`region`}
TypeCtor(TypePath(["RegionOptions"])) = {`region_options`}
TypeCtor(TypePath(p)) = {`record`} if RecordDecl(p) defined
TypeCtor(TypePath(p)) = {`enum`} if EnumDecl(p) defined
TypeCtor(_) = ∅

TypeConstructs(P) = ⋃_{m ∈ P.modules} ⋃_{t ∈ TypeNodes(P, m)} TypeCtor(t)

PermOfType(TypePerm(p, _)) = {p}
PermOfType(_) = ∅
RecvPerms(members) = { p | ∃ vis, ov, name, recv, params, ret, body, span, doc. MethodDecl(vis, ov, name, recv, params, ret, body, span, doc) ∈ members ∧ recv = ReceiverShorthand(p) }
ClassRecvPerms(items) = { p | ∃ vis, name, recv, params, ret, body, span, doc. ClassMethodDecl(vis, name, recv, params, ret, body, span, doc) ∈ items ∧ recv = ReceiverShorthand(p) }
PermConstructs(P) = ⋃_{m ∈ P.modules} ⋃_{t ∈ TypeNodes(P, m)} PermOfType(t) ∪ ⋃_{m ∈ P.modules} ⋃_{RecordDecl(_, _, _, members, _, _) ∈ ASTModule(P, m).items} RecvPerms(members) ∪ ⋃_{m ∈ P.modules} ⋃_{ClassDecl(_, _, _, items, _) ∈ ASTModule(P, m).items} ClassRecvPerms(items)

ExprKind(Literal(_)) = `literal`
ExprKind(Identifier(_)) = `identifier`
ExprKind(FieldAccess(_, _)) = `field_access`
ExprKind(TupleAccess(_, _)) = `tuple_index`
ExprKind(IndexAccess(_, _)) = `index`
ExprKind(IfExpr(_, _, _)) = `if`
ExprKind(MatchExpr(_, _)) = `match`
ExprKind(LoopInfinite(_)) = `loop`
ExprKind(LoopConditional(_, _)) = `loop`
ExprKind(LoopIter(_, _, _, _)) = `loop`
ExprKind(MoveExpr(_)) = `move`
ExprKind(Unary(`"widen"`, _)) = `widen`
ExprKind(TransmuteExpr(_, _, _)) = `transmute`
ExprKind(UnsafeBlockExpr(_)) = `unsafe`
ExprKind(AllocExpr(_, _)) = `region_alloc`
ExprKind(MethodCall(_, _, _)) = `method_call`
ExprKind(Propagate(_)) = `union_propagate`
ExprKind(_) = ⊥

StmtKind(LetStmt(_)) = `let`
StmtKind(VarStmt(_)) = `var`
StmtKind(ShadowLetStmt(_, _, _)) = `shadow`
StmtKind(ShadowVarStmt(_, _, _)) = `shadow`
StmtKind(AssignStmt(_, _)) = `assign`
StmtKind(CompoundAssignStmt(_, _, _)) = `compound_assign`
StmtKind(DeferStmt(_)) = `defer`
StmtKind(RegionStmt(_, _, _)) = `region`
StmtKind(FrameStmt(_, _)) = `frame`
StmtKind(ReturnStmt(_)) = `return`
StmtKind(ResultStmt(_)) = `result`
StmtKind(BreakStmt(_)) = `break`
StmtKind(ContinueStmt) = `continue`
StmtKind(UnsafeBlockStmt(_)) = `unsafe`
StmtKind(_) = ⊥

ExprStmtConstructs(P) = { ExprKind(e) | m ∈ P.modules ∧ e ∈ ExprNodes(P, m) ∧ ExprKind(e) ≠ ⊥ } ∪ { StmtKind(s) | m ∈ P.modules ∧ s ∈ StmtNodes(P, m) ∧ StmtKind(s) ≠ ⊥ }

CapConstructs(P) = { c | c ∈ {`Context`, `FileSystem`, `HeapAllocator`} ∧ ∃ m, t. m ∈ P.modules ∧ t ∈ TypeNodes(P, m) ∧ t = TypePath([c]) }

Constructs(P) = TopDeclConstructs(P) ∪ TypeConstructs(P) ∪ PermConstructs(P) ∪ ExprStmtConstructs(P) ∪ CapConstructs(P)

**Subset.**
Subset(P, S0) ⇔ Constructs(P) ⊆ S0

**(Reject-IllFormed)**
¬ C0Conforming(P)
─────────────────
Γ ⊢ Reject(P)

**TranslationPhases.**

TranslationPhases = [Phase1, Phase2, Phase3, Phase4]

#### 1.1.1. Cursive0 Subset (S0)

S0 = S_Lex ∪ S_Modules ∪ S_TopDecl ∪ S_Types ∪ S_Perms ∪ S_ExprStmt ∪ S_Caps

**S_Lex.**
S_Lex = RulesIn({"3.1", "3.2", "3.3"})

**S_Modules.**
S_Modules = RulesIn({"2", "3.3.6.3", "5.1"})

**S_TopDecl.**
S_TopDecl = {`using_decl`, `procedure`, `record`, `enum`, `modal`, `class`, `type_alias`, `static_decl`}

**S_Types.**
PrimTypes_C0 = IntTypes ∪ FloatTypes ∪ {`bool`, `char`, `()`, `!`}
TypeCtors_C0 = {`tuple`, `array`, `slice`, `record`, `enum`, `union`, `function`, `ptr`, `rawptr`, `string`, `bytes`, `region_options`, `region`, `dyn_class`}
S_Types = PrimTypes_C0 ∪ TypeCtors_C0

**S_Perms.**
S_Perms = PermSet_C0

**S_ExprStmt.**
S_ExprStmt = {`literal`, `identifier`, `field_access`, `tuple_index`, `index`, `if`, `loop`, `match`, `break`, `continue`, `return`, `result`, `defer`, `region`, `frame`, `union_propagate`, `let`, `var`, `shadow`, `assign`, `compound_assign`, `move`, `widen`, `transmute`, `unsafe`, `region_alloc`, `method_call`}

**S_Caps.**
S_Caps = {`Context`, `FileSystem`, `HeapAllocator`}
  
**PermSet (Cursive0).**
PermSet_C0 = {`const`, `unique`}

**(Perm-Shared-Unsupported)**
PermSyntax ∈ {`shared`, `~%`}    c = Code(Perm-Shared-Unsupported)
───────────────────────────────────────────────────────────────
Γ ⊢ Emit(c)

**Subset Lexeme Basis.**
Let S be a source file and let K satisfy Γ ⊢ Tokenize(S) ⇓ (K, _).
Any use of PermSyntax or UnsupportedForm MUST be based on token lexemes in K (and, where specified elsewhere, the AST produced by ParseFile(S)); implementations MUST NOT match substrings inside identifiers.
See Â§3.2.2 and Â§3.2.7.

S0Unsupported = {`derive`, `extern`, `attribute`, `import`, `opaque_type`, `refinement_type`, `closure`, `pipeline`, `async`, `parallel`, `dispatch`, `spawn`, `metaprogramming`, `Network`, `Reactor`, `GPUFactory`, `CPUFactory`, `AsyncRuntime`}

### 1.2. Behavior Types

**BehaviorClass.**
BehaviorClass = {Specified, UVB}

UVBRel = {ReadPtrSigma(RawPtr(q, addr), σ), WritePtrSigma(RawPtr(q, addr), v, σ)}

**IllFormed.**
StaticJudgSet = WFModulePathJudg ∪ LinkJudg ∪ ParseJudgment ∪ ResolvePathJudg ∪ ResolveExprListJudg ∪ ResolveEnumPayloadJudg ∪ ResolveCalleeJudg ∪ ResolveArmJudg ∪ ResolveStmtSeqJudg ∪ TypeEqJudg ∪ ConstLenJudg ∪ SubtypingJudg ∪ PermSubJudg ∪ ArgsOkTJudg ∪ TypeInfJudg ∪ StmtJudg ∪ PatJudg ∪ ExprJudg ∪ MatchJudg ∪ DeclJudg ∪ BJudgment ∪ ArgPassJudg ∪ ProvPlaceJudg ∪ ProvExprJudg ∪ ProvStmtJudg ∪ BlockProvJudg ∪ ArgsOkJudg ∪ TypeWFJudg ∪ StringBytesJudg ∪ BitcopyDropJudg ∪ TypeRefsJudg ∪ ValueRefsJudg ∪ CodegenJudg ∪ LayoutJudg ∪ EncodeConstJudg ∪ ValidValueJudg ∪ RecordLayoutJudg ∪ UnionLayoutJudg ∪ TupleLayoutJudg ∪ RangeLayoutJudg ∪ EnumLayoutJudg ∪ ModalLayoutJudg ∪ DynLayoutJudg ∪ ABITyJudg ∪ ABIParamJudg ∪ ABIRetJudg ∪ ABICallJudg ∪ LowerCallJudg ∪ MangleJudg ∪ LinkageJudg ∪ EvalOrderJudg ∪ LowerExprJudg ∪ LowerStmtJudg ∪ PatternLowerJudg ∪ LowerBindJudg ∪ GlobalsJudg ∪ ConstInitJudg ∪ CleanupJudg ∪ RuntimeIfcJudg ∪ DynDispatchJudg ∪ ChecksJudg ∪ LLVMAttrJudg ∪ RuntimeDeclJudg ∪ LLVMTyJudg ∪ LLVMEmitJudg ∪ LowerIRJudg ∪ BindStorageJudg ∪ LLVMCallJudg ∪ VTableJudg ∪ LiteralEmitJudg ∪ BuiltinSymJudg ∪ DropHookJudg ∪ EntryJudg ∪ PoisonJudg
StaticRuleSet = { r | Conclusion(r) ∈ StaticJudgSet }
Conclusion(r) = J    (r is written (π_1 … π_k) / J)
Premises(r) = [π_1, …, π_k]    (r is written (π_1 … π_k) / _)
Subject(Γ ⊢ j) = j_0 where j_0 is the leftmost term to the right of ⊢
EnvOf(Γ ⊢ j) = Γ
θ ranges over substitutions of metavariables in r
Applies(r, x) ⇔ ∃ θ. Subject(Conclusion(r)[θ]) = x
PremisesHold(r, x) ⇔ ∃ θ. Subject(Conclusion(r)[θ]) = x ∧ Γ_r = EnvOf(Conclusion(r)[θ]) ∧ ∀ π ∈ Premises(r)[θ]. π ≠ ⊥ ∧ (π is a judgment ⇒ Γ_r ⊢ π)
IllFormed(x) ⇔ ∃ r ∈ StaticRuleSet. Applies(r, x) ∧ ¬ PremisesHold(r, x)

**Undefinedness Policy.**
StaticUndefined(J) ⇔ ∃ r. Conclusion(r) = J ∧ ∃ π ∈ Premises(r). π = ⊥
DynamicUndefined(R) ⇔ R ∈ UVBRel ∧ R undefined
Behavior(R) = Specified ⇔ ¬ DynamicUndefined(R)
Behavior(R) = UVB ⇔ DynamicUndefined(R)

RuleId(r) = id ⇔ r is labeled (id)
DiagIdOf(J) = id ⇔ ∃ r. Conclusion(r) = J ∧ RuleId(r) = id
DiagIdOf(J) = ⊥ ⇔ ¬ ∃ r. Conclusion(r) = J ∧ RuleId(r) defined

**(Static-Undefined)**
StaticUndefined(J)    Code(DiagIdOf(J)) = c
───────────────────────────────────────
Γ ⊢ J ⇑ c

**(Static-Undefined-NoCode)**
StaticUndefined(J)    Code(DiagIdOf(J)) = ⊥
────────────────────────────────────────
Γ ⊢ J ⇑

**(Dynamic-Undefined-UVB)**
DynamicUndefined(R)
────────────────────────────
Γ ⊢ Behavior(R) = UVB

**Static vs. Runtime Checks.**

CheckKind = {PatternExhaustiveness, TypeCompatibility, PermissionViolations, ProvenanceEscape, ArrayBounds, SafePointerValidity, IntegerOverflow, SliceBounds, IntDivisionByZero}

StaticCheck = {PatternExhaustiveness, TypeCompatibility, PermissionViolations, ProvenanceEscape, ArrayBounds, SafePointerValidity}
RuntimeCheck = {IntegerOverflow, SliceBounds, IntDivisionByZero}

RuntimeBehavior(IntegerOverflow) = Panic
RuntimeBehavior(SliceBounds) = Panic
RuntimeBehavior(IntDivisionByZero) = Panic

ResourceExhaustion ⇒ OutsideConformance

**Error Recovery (Cursive0).**
LexRecovery = SkipToNextTokenStart
ParseRecovery = SyncSet({`;`, `}`, `EOF`})
TypeRecovery = ContinueDecls
MaxErrorCount ∈ ℕ ∪ {∞}
SuggestedMaxErrorCount = 100
AbortOnErrorCount(n) ⇔ n ≥ MaxErrorCount

### 1.4. Unsupported Constructs Policy

**UnsupportedConstruct.**
UnsupportedConstruct = {`key_system`, `attribute_syntax`, `extern_block`, `foreign_decl`, `class_generics`, `class_where_clause`, `associated_type`, `modal_class`, `class_contract`}

**(WF-Attr-Unsupported)**
`[[...]]` ∈ M
───────────────────────────────────────────────
Γ ⊢ Emit(Code(WF-Attr-Unsupported))

UnsupportedForm = UnsupportedConstruct ∪ S0Unsupported ∪ UnsupportedGrammarFamily ∪ UnsupportedClassItem ∪ UnsupportedWhereClause ∪ ComptimeForm

**(Unsupported-Construct)**
f ∈ UnsupportedForm
──────────────────────────────────────────────
Γ ⊢ Emit(Code(Unsupported-Construct))

### 1.5. Target and ABI Assumptions

TargetArch = Win64
Endianness = Little
PtrSizeBytes = PtrSize
LayoutSpec = RulesIn({"6.1.1", "6.1.2", "6.1.3", "6.1.4", "6.1.5", "6.1.6"})

Target = "x86_64-pc-windows-msvc"
Win64 = Target

### 1.6. Diagnostics Infrastructure

#### 1.6.1. Source Locations and Spans

**SourceLocation.**

SourceLocation = ⟨file, offset, line, column⟩

**Span.**

Span = ⟨file, start_offset, end_offset, start_line, start_col, end_line, end_col⟩

SpanRange(sp) = [sp.start_offset, sp.end_offset)

**(WF-Location)**
0 ≤ o    Γ ⊢ Locate(S, o) ⇓ ℓ_loc
────────────────────────────────
Γ ⊢ ℓ_loc : LocationOk

**(WF-Span)**
0 ≤ s ≤ e ≤ S.byte_len    Γ ⊢ Locate(S, s) ⇓ ℓ_s    Γ ⊢ Locate(S, e) ⇓ ℓ_e
──────────────────────────────────────────────────────────────────────────
Γ ⊢ ⟨S.path, s, e, ℓ_s.line, ℓ_s.column, ℓ_e.line, ℓ_e.column⟩ : SpanOk

**Span Construction**

ClampSpan(S, s, e) = (s', e')
s' = min(s, S.byte_len)
e' = min(max(e, s'), S.byte_len)

**(Span-Of)**
Γ ⊢ ClampSpan(S, s, e) ⇓ (s', e')    Γ ⊢ ⟨S.path, s', e', line_s, col_s, line_e, col_e⟩ : SpanOk
────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ SpanOf(S, s, e) ⇓ ⟨S.path, s', e', line_s, col_s, line_e, col_e⟩

#### 1.6.2. Token Spans

**TokenKind.**

TokenKind_C0 = TokenKind_(§ 3.2.4) ∪ {Unknown}

**(No-Unknown-Ok)**
∀ t ∈ K. t.kind ≠ Unknown
─────────────────────────
Γ ⊢ K : TokenStreamOk

**RawToken.**

RawToken = ⟨kind, lexeme, s, e⟩

**Token.**

Token = ⟨kind, lexeme, span⟩

**(Attach-Token-Ok)**
Γ ⊢ SpanOf(S, s, e) ⇓ sp
───────────────────────────────────────────────
Γ ⊢ AttachSpan(S, ⟨k, ℓ, s, e⟩) ⇓ ⟨k, ℓ, sp⟩

**Token Stream Attachment (Bigâ€‘Step)**

**(Attach-Tokens-Ok)**
∀ r ∈ rs, Γ ⊢ AttachSpan(S, r) ⇓ t    ts = [t | r ∈ rs]
──────────────────────────────────────────────────────────────
Γ ⊢ AttachSpans(S, rs) ⇓ ts

#### 1.6.3. Diagnostics: Records and Emission

**Diagnostic.**

Severity = {Error, Warning}

**Diagnostic Stream.**
Δ = [d_1, …, d_n]

**(Emit-Append)**
────────────────────────────────────────────
Γ ⊢ Emit(Δ, d) ⇓ (Δ ++ [d])

**Emit (Implicit).**
Emit(c) = Emit(Δ, ⟨c, Severity(c), Message(c), ⊥⟩)
Emit(c, sp) = Emit(Δ, ⟨c, Severity(c), Message(c), sp⟩)

Severity(c) = SeverityColumn(c)
Message(c) = ConditionColumn(c)

CompileStatus(Δ) =
 fail  if HasError(Δ)
 ok    otherwise

#### 1.6.4. Diagnostic Code Selection

SpecCode : DiagId ⇀ DiagCode
SpecCode(id) = ⊥
C0Code : DiagId ⇀ DiagCode

**(Code-Spec)**
SpecCode(id) = c
────────────────────────────
Γ ⊢ Code(id) ⇓ c

**(Code-C0)**
SpecCode(id) = ⊥    C0Code(id) = c
────────────────────────────────
Γ ⊢ Code(id) ⇓ c

**DiagIdâ€“Code Mapping.**
id emits a diagnostic
────────────────────────────
Γ ⊢ Emit(Code(id))
⇑ ≡ ⇑ Code(id)

**Resolution Failure.**
NoDiag(↑)

#### 1.6.5. Diagnostic Ordering

**(Order)**
Δ = [d_1, d_2, …, d_n]
──────────────────────────────────────────────────
Γ ⊢ Order(Δ) ⇓ [d_1, d_2, …, d_n]

#### 1.6.6. Diagnostic Rendering

Render(d) =
 code ++ " (" ++ sev ++ ")" ++ msg ++ " @" ++ loc  if d.span ≠ ⊥
 code ++ " (" ++ sev ++ ")" ++ msg                if d.span = ⊥

code = d.code
sev =
 "error"   if d.severity = Error
 "warning" if d.severity = Warning
msg =
 "\""      if d.message = "\""
 ": " ++ d.message  otherwise
loc = d.span.file ++ ":" ++ d.span.start_line ++ ":" ++ d.span.start_col
PermLexeme(const) = "const"
PermLexeme(unique) = "unique"
PermLexeme(shared) = "shared"
QualLexeme(imm) = "imm"
QualLexeme(mut) = "mut"
PtrStateSuffix(⊥) = ""
PtrStateSuffix(Valid) = "@Valid"
PtrStateSuffix(Null) = "@Null"
PtrStateSuffix(Expired) = "@Expired"
StringStateSuffix(⊥) = ""
StringStateSuffix(View) = "@View"
StringStateSuffix(Managed) = "@Managed"
BytesStateSuffix(⊥) = ""
BytesStateSuffix(View) = "@View"
BytesStateSuffix(Managed) = "@Managed"
ParamRender(⟨⊥, T⟩) = TypeRender(T)
ParamRender(⟨move, T⟩) = "move " ++ TypeRender(T)
TypeRender(TypePrim(name)) = name
TypeRender(TypeRange) = "TypeRange"
TypeRender(TypePerm(p, T)) = PermLexeme(p) ++ " " ++ TypeRender(T)
TypeRender(TypeUnion([T_1, …, T_n])) = Join(" | ", [TypeRender(T_1), …, TypeRender(T_n)])
TypeRender(TypeFunc([⟨m_1, T_1⟩, …, ⟨m_n, T_n⟩], R)) = "(" ++ Join(", ", [ParamRender(⟨m_1, T_1⟩), …, ParamRender(⟨m_n, T_n⟩)]) ++ ") -> " ++ TypeRender(R)
TypeRender(TypeTuple([])) = "()"
TypeRender(TypeTuple([T])) = "(" ++ TypeRender(T) ++ ";)"
TypeRender(TypeTuple([T_1, …, T_n])) = "(" ++ Join(", ", [TypeRender(T_1), …, TypeRender(T_n)]) ++ ")"
TypeRender(TypeArray(T, e)) = "[" ++ TypeRender(T) ++ "; " ++ ArrayLen(e) ++ "]"
TypeRender(TypeSlice(T)) = "[" ++ TypeRender(T) ++ "]"
TypeRender(TypePtr(T, s)) = "Ptr<" ++ TypeRender(T) ++ ">" ++ PtrStateSuffix(s)
TypeRender(TypeRawPtr(q, T)) = "* " ++ QualLexeme(q) ++ " " ++ TypeRender(T)
TypeRender(TypeString(st)) = "string" ++ StringStateSuffix(st)
TypeRender(TypeBytes(st)) = "bytes" ++ BytesStateSuffix(st)
TypeRender(TypeDynamic(p)) = "$" ++ StringOfPath(p)
TypeRender(TypeModalState(p, S)) = StringOfPath(p) ++ "@" ++ S
TypeRender(TypePath(p)) = StringOfPath(p)

#### 1.6.7. Diagnostics without Source Spans

**(NoSpan-External)**
Origin(d) = External
──────────────────────
Γ ⊢ d.span = ⊥

### 1.7. Host Primitives

FSPrim = {FSOpenRead, FSOpenWrite, FSOpenAppend, FSCreateWrite, FSReadFile, FSReadBytes, FSWriteFile, FSWriteStdout, FSWriteStderr, FSExists, FSRemove, FSOpenDir, FSCreateDir, FSEnsureDir, FSKind, FSRestrict}
FilePrim = {FileReadAll, FileReadAllBytes, FileWrite, FileFlush, FileClose}
DirPrim = {DirNext, DirClose}

HostPrim = {ParseTOML, ReadBytes, WriteFile, ResolveTool, ResolveRuntimeLib, Invoke, AssembleIR, InvokeLinker} ∪ FSPrim ∪ FilePrim ∪ DirPrim
HostPrimDiag = {ParseTOML, ReadBytes, WriteFile, ResolveTool, ResolveRuntimeLib, Invoke, AssembleIR, InvokeLinker}
HostPrimRuntime = FSPrim ∪ FilePrim ∪ DirPrim
MapsToDiagOrRuntime(p) ⇔ p ∈ HostPrimDiag ∪ HostPrimRuntime
HostPrimFail(p) ⇔ p ∈ HostPrim ∧ ∃ args. Γ ⊢ p(args) ⇑

HostPrimFail(p) ∧ ¬ MapsToDiagOrRuntime(p) ⇒ IllFormed(p)

## 2. Phase 0: Build/Project Model

**Assembly Kind.**
AssemblyKind = {`executable`, `library`}

**Assembly Record.**
Assembly = ⟨name, kind, root, out_dir, emit_ir, source_root, outputs, modules⟩

**Project Record.**
Project = ⟨root, assemblies, assembly, source_root, outputs, modules⟩
Assemblies(P) = P.assemblies
Assembly(P) = P.assembly
AsmNames(P) = [A.name | A ∈ Assemblies(P)]
AsmByName(P, n) = A ⇔ A ∈ Assemblies(P) ∧ A.name = n ∧ (∀ B ∈ Assemblies(P). B.name = n ⇒ B = A)

**Build/Project Validation Scope.**
Phase0Checks = RulesIn({"2"})
SourceChecks = RulesIn({"3", "4", "5", "6"})
Phase0Checks ∩ SourceChecks = ∅

**Command-Line Output.**
DumpProject(P, dump) =
 ProjectSummary(P) ++ OutputSummary(P)  if dump = false
 ProjectSummary(P) ++ OutputSummary(P) ++ ["file:" ++ f | d ∈ Modules(P.source_root), f ∈ CompilationUnit(d)]  if dump = true

ProjectSummary(P) = [⟨`project_root`, P.root⟩, ⟨`assemblies`, AsmNames(P)⟩, ⟨`assembly_name`, P.assembly.name⟩, ⟨`source_root`, P.source_root⟩, ⟨`output_root`, OutputRoot(P)⟩, ⟨`module_list`, ModuleList(P)⟩]

OutputSummary(P) = [⟨`module`, m, `obj`, ObjPath(P, m), `ir`, IROpt(P, m)⟩ | m ∈ ModuleList(P)]

IROpt(P, m) =
 IRPath(P, m, P.assembly.emit_ir)  if P.assembly.emit_ir ≠ `none`
 ⊥                                if P.assembly.emit_ir = `none`

### 2.1. Project Root and Manifest

**Manifest Parsing (Big-Step)**

ParseTOML : Path ⇀ TOMLTable

**(Parse-Manifest-Ok)**
ParseTOML(R/`Cursive.toml`) ⇓ T
────────────────────────────────
Γ ⊢ ParseManifest(R) ⇓ T

**(Parse-Manifest-Missing)**
¬ exists(R/`Cursive.toml`)    c = Code(Parse-Manifest-Missing)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseManifest(R) ⇑ c

**(Parse-Manifest-Err)**
ParseTOML(R/`Cursive.toml`) ⇑    c = Code(Parse-Manifest-Err)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseManifest(R) ⇑ c

**Manifest Required (No Single-File Fallback).**
If Γ ⊢ ParseManifest(R) ⇑ c, then Γ ⊢ LoadProject(R, target) ⇑ c and the implementation MUST NOT attempt any single-file or heuristic fallback project construction.

**Manifest Path Resolution.**
Manifest lookup MUST use host filesystem path resolution semantics for R/`Cursive.toml` and MUST NOT perform additional case verification.

**Manifest Schema (Cursive0)**

n = t.name
k = t.kind
r = t.root
o = t.out_dir
e = t.emit_ir

**(WF-Assembly-Name)**
Γ ⊢ n : Identifier    Γ ⊢ n : NotKeyword
────────────────────────────────────────
Γ ⊢ n : Name

**(WF-Assembly-Name-Err)**
¬(Γ ⊢ n : Identifier ∧ Γ ⊢ n : NotKeyword)    c = Code(WF-Assembly-Name-Err)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ n : Name ⇑ c

**(WF-Assembly-Kind)**
k ∈ AssemblyKind
──────────────────
Γ ⊢ k : Kind

**(WF-Assembly-Kind-Err)**
k ∉ AssemblyKind    c = Code(WF-Assembly-Kind-Err)
──────────────────────────────────────────────────
Γ ⊢ k : Kind ⇑ c

**(WF-Assembly-Root-Path)**
Γ ⊢ r : RelPath
────────────────
Γ ⊢ r : RootPath

**(WF-Assembly-Root-Path-Err)**
¬(Γ ⊢ r : RelPath)    c = Code(WF-Assembly-Root-Path-Err)
────────────────────────────────────────────────────────
Γ ⊢ r : RootPath ⇑ c

**(WF-Assembly-OutDir-Path)**
o = ⊥ ∨ Γ ⊢ o : RelPath
────────────────────────
Γ ⊢ o : OutDirPath

**(WF-Assembly-OutDir-Path-Err)**
o ≠ ⊥    ¬(Γ ⊢ o : RelPath)    c = Code(WF-Assembly-OutDir-Path-Err)
────────────────────────────────────────────────────────────────────
Γ ⊢ o : OutDirPath ⇑ c

**(WF-Assembly-EmitIR)**
e ∈ {⊥, `none`, `ll`, `bc`}
───────────────────────────
Γ ⊢ e : EmitIR

**(WF-Assembly-EmitIR-Err)**
e ∉ {⊥, `none`, `ll`, `bc`}    c = Code(WF-Assembly-EmitIR-Err)
─────────────────────────────────────────────────────────────────
Γ ⊢ e : EmitIR ⇑ c

**Manifest Validation (Big-Step)**

Keys(T) = Dom(T)
AsmField(T) = T[`assembly`]
AsmTables(T) =
 [AsmField(T)]  if IsTable(AsmField(T))
 AsmField(T)    if IsArrayTable(AsmField(T))
 ⊥              otherwise

**(WF-TopKeys)**
Keys(T) ⊆ {`assembly`}
────────────────────────
Γ ⊢ T : TopKeys

**(WF-TopKeys-Err)**
¬(Keys(T) ⊆ {`assembly`})    c = Code(WF-TopKeys-Err)
──────────────────────────────────────────────────────
Γ ⊢ T : TopKeys ⇑ c

**(WF-Assembly-Table)**
AsmTables(T) ≠ ⊥
────────────────────────
Γ ⊢ T : AssemblyTable

**(WF-Assembly-Table-Err)**
AsmTables(T) = ⊥    c = Code(WF-Assembly-Table-Err)
────────────────────────────────────────────────────
Γ ⊢ T : AssemblyTable ⇑ c

**(WF-Assembly-Count)**
AsmTables(T) = Ts    |Ts| ≥ 1
────────────────────────────────
Γ ⊢ T : AssemblyCount

**(WF-Assembly-Count-Err)**
AsmTables(T) = Ts    |Ts| = 0    c = Code(WF-Assembly-Count-Err)
───────────────────────────────────────────────────────────────
Γ ⊢ T : AssemblyCount ⇑ c

**(WF-Assembly-Name-Dup)**
AsmTables(T) = Ts    Distinct([t.name | t ∈ Ts])
────────────────────────────────────────────────
Γ ⊢ T : AssemblyNames

**(WF-Assembly-Name-Dup-Err)**
AsmTables(T) = Ts    ¬ Distinct([t.name | t ∈ Ts])    c = Code(WF-Assembly-Name-Dup)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : AssemblyNames ⇑ c

Req = {`name`, `kind`, `root`}
Opt = {`out_dir`, `emit_ir`}

**(WF-Assembly-Keys)**
Keys(t) ⊆ (Req ∪ Opt)
──────────────────────
Γ ⊢ t : KnownKeys

**(WF-Assembly-Keys-Err)**
¬(Keys(t) ⊆ (Req ∪ Opt))    c = Code(WF-Assembly-Keys-Err)
───────────────────────────────────────────────────────────
Γ ⊢ t : KnownKeys ⇑ c

**(WF-Assembly-Required-Types)**
∀ k ∈ Req. IsString(t[k])
──────────────────────────
Γ ⊢ t : ReqTypes

**(WF-Assembly-Required-Types-Err)**
∃ k ∈ Req. t[k] = ⊥ ∨ ¬ IsString(t[k])    c = Code(WF-Assembly-Required-Types-Err)
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ t : ReqTypes ⇑ c

**(WF-Assembly-Optional-Types)**
t[`out_dir`] ∈ {string, ⊥}
──────────────────────────
Γ ⊢ t : OutDirType

**(WF-Assembly-OutDirType-Err)**
t[`out_dir`] ∉ {string, ⊥}    c = Code(WF-Assembly-OutDirType-Err)
──────────────────────────────────────────────────────────────────
Γ ⊢ t : OutDirType ⇑ c

t[`emit_ir`] ∈ {string, ⊥}
──────────────────────────
Γ ⊢ t : EmitIRType

**(WF-Assembly-EmitIRType-Err)**
t[`emit_ir`] ∉ {string, ⊥}    c = Code(WF-Assembly-EmitIRType-Err)
──────────────────────────────────────────────────────────────────
Γ ⊢ t : EmitIRType ⇑ c

**Path Resolution**
WinSep = {"\\", "/"}
AsciiLetter(c) ⇔ (c ∈ {"A", …, "Z"} ∨ c ∈ {"a", …, "z"})
DriveRooted(p) ⇔ |p| ≥ 3 ∧ AsciiLetter(At(p, 0)) ∧ At(p, 1) = ":" ∧ At(p, 2) ∈ WinSep
UNC(p) ⇔ StartsWith(p, "//") ∨ StartsWith(p, "\\\\")
RootRelative(p) ⇔ (StartsWith(p, "/") ∨ StartsWith(p, "\\")) ∧ ¬ UNC(p) ∧ ¬ DriveRooted(p)
RootTag(p) =
 p[0..2)  if DriveRooted(p)
 "//"     if UNC(p)
 "/"      if RootRelative(p)
 "\""     otherwise
Tail(p) =
 p[3..|p|)  if DriveRooted(p)
 p[2..|p|)  if UNC(p)
 p[1..|p|)  if RootRelative(p)
 p         otherwise
Segs(p) = [ p[i..j) | 0 ≤ i < j ≤ |p| ∧ (∀ k ∈ [i, j). At(p, k) ∉ WinSep) ∧ (i = 0 ∨ At(p, i-1) ∈ WinSep) ∧ (j = |p| ∨ At(p, j) ∈ WinSep) ]
PathComps(p) =
 Segs(p)  if RootTag(p) = "\""
 [RootTag(p)] ++ Segs(Tail(p))  otherwise
JoinComp([]) = "\""
JoinComp([c]) = c
JoinComp(c::cs) =
 c ++ JoinComp(cs)          if c ∈ {"/", "//"}
 c ++ "/" ++ JoinComp(cs)   if DriveRooted(c ++ "/")
 c ++ "/" ++ JoinComp(cs)   otherwise
Join(a, b) =
 b  if AbsPath(b)
 JoinComp(PathComps(a) ++ PathComps(b))  otherwise

AbsPath(p) ⇔ DriveRooted(p) ∨ UNC(p) ∨ RootRelative(p)
is_relative(p) ⇔ ¬ AbsPath(p)
Join : Path × Path → Path
Normalize : Path → Path
Canon : Path ⇀ Path
prefix(p, q) ⇔ PathPrefix(PathComps(q), PathComps(p))
Normalize(p) = JoinComp([ c | c ∈ PathComps(p) ∧ c ≠ "." ])
Canon(p) = ⊥ ⇔ ∃ c ∈ PathComps(Normalize(p)). c = ".."
Canon(p) = Normalize(p) ⇔ ¬ ∃ c ∈ PathComps(Normalize(p)). c = ".."
Drop(0, xs) = xs    Drop(n, []) = []    Drop(n, x::xs) = Drop(n-1, xs) (n > 0)
relative(p, base) = rel ⇔ Canon(p) = p' ∧ Canon(base) = b' ∧ PathPrefix(PathComps(b'), PathComps(p')) ∧ rel = JoinComp(Drop(|PathComps(b')|, PathComps(p')))
Basename(p) =
 "\""  if |PathComps(p)| = 0
 last(PathComps(p))  otherwise
last([x]) = x    last(x::xs) = last(xs) (|xs| > 0)

b = Basename(p)
D = { j | 0 ≤ j < |b| ∧ b[j] = "." }
FileExt(p) =
 "\""  if D = ∅
 "\""  if D ≠ ∅ ∧ max(D) = 0
 b[max(D)..|b|)  if D ≠ ∅ ∧ max(D) > 0

**(Resolve-Canonical)**
p' = Normalize(Join(R, p))    Canon(R) = R'    Canon(p') = p''
─────────────────────────────────────────────────────────────
Γ ⊢ Resolve(R, p) ⇓ (R', p'')

**(Resolve-Canonical-Err)**
p' = Normalize(Join(R, p))    (Canon(R) = ⊥ ∨ Canon(p') = ⊥)    c = Code(Resolve-Canonical-Err)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Resolve(R, p) ⇑ c

**(WF-RelPath)**
is_relative(p)    Γ ⊢ Resolve(R, p) ⇓ (R', p'')    prefix(p'', R')
──────────────────────────────────────────────────────────────────────
Γ ⊢ p : RelPath

**(WF-RelPath-Err)**
¬ is_relative(p) ∨ (Γ ⊢ Resolve(R, p) ⇓ (R', p'') ∧ ¬ prefix(p'', R'))    c = Code(WF-RelPath-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ p : RelPath ⇑ c

Project(Γ) = P ⇔ Γ.project = P

**Project Load (Small-Step)**

AssemblyTarget = Name ∪ {⊥}
ProjLoadState = {Start(R, target), Parsed(R, target, T), Validated(R, target, T), ProjAsmScan(R, target, T, Ts, As), Discovered(P), Error(code)}

**(Step-Parse)**
Γ ⊢ ParseManifest(R) ⇓ T
────────────────────────────────────────────────────────
⟨Start(R, target)⟩ → ⟨Parsed(R, target, T)⟩

**(Step-Parse-Err)**
Γ ⊢ ParseManifest(R) ⇑ c
──────────────────────────────────────────────
⟨Start(R, target)⟩ → ⟨Error(c)⟩

**(Step-Validate)**
Γ ⊢ ValidateManifest(T) ⇓ ok
──────────────────────────────────────────────────────────
⟨Parsed(R, target, T)⟩ → ⟨Validated(R, target, T)⟩

**(Step-Validate-Err)**
Γ ⊢ ValidateManifest(T) ⇑ c
───────────────────────────────────────────────
⟨Parsed(R, target, T)⟩ → ⟨Error(c)⟩

**Manifest Validation (Deterministic).**

ChecksAsm(t) = [Γ ⊢ t : KnownKeys, Γ ⊢ t : ReqTypes, Γ ⊢ t : OutDirType, Γ ⊢ t : EmitIRType, Γ ⊢ t.name : Name, Γ ⊢ t.kind : Kind, Γ ⊢ t.emit_ir : EmitIR, Γ ⊢ t.root : RootPath, Γ ⊢ t.out_dir : OutDirPath]
BaseChecks(T) = [Γ ⊢ T : TopKeys, Γ ⊢ T : AssemblyTable, Γ ⊢ T : AssemblyCount, Γ ⊢ T : AssemblyNames]
AsmChecks(T) =
 []  if AsmTables(T) = ⊥
 ++_{t ∈ AsmTables(T)} ChecksAsm(t)  otherwise
Checks(T) = BaseChecks(T) ++ AsmChecks(T)

FirstFail([]) = ⊥
FirstFail(J::Js) = c ⇔ Γ ⊢ J ⇑ c
FirstFail(J::Js) = FirstFail(Js) ⇔ Γ ⊢ J ⇓ ok

**(ValidateManifest-Ok)**
FirstFail(Checks(T)) = ⊥
────────────────────────────────────
Γ ⊢ ValidateManifest(T) ⇓ ok

**(ValidateManifest-Err)**
FirstFail(Checks(T)) = c
───────────────────────────────────
Γ ⊢ ValidateManifest(T) ⇑ c

**(Step-Asm-Init)**
Ts = AsmTables(T)
──────────────────────────────────────────────────────────
⟨Validated(R, target, T)⟩ → ⟨ProjAsmScan(R, target, T, Ts, [])⟩

**(Step-Asm-Cons)**
Γ ⊢ BuildAssembly(R, t_0) ⇓ A
────────────────────────────────────────────────────────────────────────────────────────────
⟨ProjAsmScan(R, target, T, t_0::ts, As)⟩ → ⟨ProjAsmScan(R, target, T, ts, As ++ [A])⟩

**(Step-Asm-Err)**
Γ ⊢ BuildAssembly(R, t_0) ⇑ c
──────────────────────────────────────────────────────────────
⟨ProjAsmScan(R, target, T, t_0::ts, As)⟩ → ⟨Error(c)⟩

**(Step-Asm-Done)**
Γ ⊢ SelectAssembly(As, target) ⇓ A_0    P = ⟨root = R, assemblies = As, assembly = A_0, source_root = A_0.source_root, outputs = A_0.outputs, modules = A_0.modules⟩
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨ProjAsmScan(R, target, T, [], As)⟩ → ⟨Discovered(P)⟩

**(Step-Asm-Done-Err)**
Γ ⊢ SelectAssembly(As, target) ⇑ c
───────────────────────────────────────────────
⟨ProjAsmScan(R, target, T, [], As)⟩ → ⟨Error(c)⟩

**Assembly Selection**

**(Select-Only)**
|As| = 1    target = ⊥    As = [A_0]
──────────────────────────────────────────────
Γ ⊢ SelectAssembly(As, target) ⇓ A_0

**(Select-By-Name)**
target ≠ ⊥    A ∈ As    A.name = target
──────────────────────────────────────────────
Γ ⊢ SelectAssembly(As, target) ⇓ A

**(Select-Err)**
(target = ⊥ ∧ |As| ≠ 1) ∨ (target ≠ ⊥ ∧ ¬ ∃ A ∈ As. A.name = target)    c = Code(Assembly-Select-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ SelectAssembly(As, target) ⇑ c

**Assembly Build (Big-Step)**

**(BuildAssembly-Ok)**
Γ ⊢ Resolve(R, t.root) ⇓ (R', S)    Γ ⊢ S : SourceRoot    Γ ⊢ Modules(S, t.name) ⇓ M    L = sort_{≺_mod}(M)    A = ⟨name = t.name, kind = t.kind, root = t.root, out_dir = t.out_dir, emit_ir = t.emit_ir, source_root = S, outputs = OutputPaths(R, t), modules = L⟩
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ BuildAssembly(R, t) ⇓ A

**(BuildAssembly-Err-Resolve)**
Γ ⊢ Resolve(R, t.root) ⇑ c
─────────────────────────────────
Γ ⊢ BuildAssembly(R, t) ⇑ c

**(BuildAssembly-Err-Root)**
Γ ⊢ Resolve(R, t.root) ⇓ (R', S)    Γ ⊢ S : SourceRoot ⇑ c
─────────────────────────────────────────────────────────────
Γ ⊢ BuildAssembly(R, t) ⇑ c

**(BuildAssembly-Err-Modules)**
Γ ⊢ Resolve(R, t.root) ⇓ (R', S)    Γ ⊢ S : SourceRoot    Γ ⊢ Modules(S, t.name) ⇑ c
────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ BuildAssembly(R, t) ⇑ c

**Project Load (Big-Step)**

**(LoadProject-Ok)**
Γ ⊢ ParseManifest(R) ⇓ T    Γ ⊢ ValidateManifest(T) ⇓ ok    AsmTables(T) = [t_1, …, t_n]    ∀ i, Γ ⊢ BuildAssembly(R, t_i) ⇓ A_i    As = [A_1, …, A_n]    Γ ⊢ SelectAssembly(As, target) ⇓ A_0    P = ⟨root = R, assemblies = As, assembly = A_0, source_root = A_0.source_root, outputs = A_0.outputs, modules = A_0.modules⟩
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LoadProject(R, target) ⇓ P

**(LoadProject-Err)**
Γ ⊢ LoadProject(R, target) →* ⟨Error(c)⟩
────────────────────────────────────────────
Γ ⊢ LoadProject(R, target) ⇑ c

**Well-Formed Project Root**

**(WF-Project-Root)**
exists(`Cursive.toml` at R)
───────────────────────────
⊢ R : ProjectRoot

### 2.2. Assemblies

A_0.kind ∈ AssemblyKind
────────────────────────
Γ ⊢ A_0 : Assembly


### 2.3. Deterministic Ordering and Case Folding

#### 2.3.1. Module File Processing Order
FoldPath(r) = JoinComp([CaseFold(NFC(c)) | c ∈ PathComps(r)])

FileKey(f, d) =
 ⟨FoldPath(rel), rel⟩  if relative(f, d) ⇓ rel
 ⟨⊥, Basename(f)⟩      if relative(f, d) ⇑

f_1 ≺_file f_2 ⇔ Utf8LexLess(FileKey(f_1, d), FileKey(f_2, d))

**(FileOrder-Rel-Fail)**
relative(f, d) ⇑    c = Code(FileOrder-Rel-Fail)
────────────────────────────────────────────────
Γ ⊢ Emit(c)

#### 2.3.2. Module Path Case-Folding Algorithm

**Fold.**
Fold(p) = [CaseFold(NFC(c)) | c ∈ p]

#### 2.3.3. Directory Enumeration Order

DirKey(d, S) =
 ⟨FoldPath(rel), rel⟩  if relative(d, S) ⇓ rel
 ⟨⊥, Basename(d)⟩      if relative(d, S) ⇑

d_1 ≺_dir d_2 ⇔ Utf8LexLess(DirKey(d_1, S), DirKey(d_2, S))

DirSeq(S) = sort_{≺_dir}(Dirs(S))

**(DirSeq-Read-Err)**
Dirs(S) ⇑    c = Code(DirSeq-Read-Err)
──────────────────────────────────────
Γ ⊢ Emit(c)

**(DirSeq-Rel-Fail)**
relative(d, S) ⇑    c = Code(DirSeq-Rel-Fail)
──────────────────────────────────────────────
Γ ⊢ Emit(c)

### 2.4. Module Discovery

**Dirs.**
Dirs(S) = { d | is_dir(d) ∧ relative(d, S) ⇓ r }
S ∈ Dirs(S)

**(WF-Source-Root)**
is_dir(S)
──────────────
Γ ⊢ S : SourceRoot

**(WF-Source-Root-Err)**
¬ is_dir(S)    c = Code(WF-Source-Root-Err)
───────────────────────────────────────────
Γ ⊢ S : SourceRoot ⇑ c

**(Module-Dir)**
∃ f ∈ Files(d) : FileExt(f) = ".cursive"
─────────────────────────────────────────
Γ ⊢ d : ModuleDir

Modules(S) = { d ∈ Dirs(S) | Γ ⊢ d : ModuleDir }

**Module Discovery (Big-Step)**

**(Modules-Ok)**
⟨DiscStart(S, A)⟩ →* ⟨DiscDone(M)⟩
──────────────────────────────────
Γ ⊢ Modules(S, A) ⇓ M

**(Modules-Err)**
⟨DiscStart(S, A)⟩ →* ⟨Error(c)⟩
─────────────────────────────────
Γ ⊢ Modules(S, A) ⇑ c

Files(d) = { f | f ∈ d ∧ FileExt(f) = ".cursive" }

CompilationUnit(d) = sort_{≺_file}(Files(d))

**(CompilationUnit-Rel-Fail)**
∃ f ∈ Files(d). relative(f, d) ⇑    c = Code(FileOrder-Rel-Fail)
─────────────────────────────────────────────────────────────────
Γ ⊢ CompilationUnit(d) ⇑ c


**Module Path.**

**(Module-Path-Root)**
relative(d, S) = ε
────────────────────────────
Γ ⊢ ModulePath(d, S, A) = A

**(Module-Path-Rel)**
relative(d, S) = c_1 / … / c_n
──────────────────────────────────────────────
Γ ⊢ ModulePath(d, S, A) = c_1 :: … :: c_n

**(Module-Path-Rel-Fail)**
relative(d, S) ⇑
────────────────────────────────
Γ ⊢ ModulePath(d, S, A) ⇑

WFModulePathJudg = {WF-Module-Path}

**(WF-Module-Path-Ok)**
∀ comp ∈ p, (Γ ⊢ comp : Identifier) ∧ ¬ Keyword(comp)
────────────────────────────────────────────────────────
Γ ⊢ WF-Module-Path(p) ⇓ ok

**(WF-Module-Path-Reserved)**
∃ comp ∈ p. Keyword(comp)    c = Code(WF-Module-Path-Reserved)
────────────────────────────────────────────────────────────────
Γ ⊢ WF-Module-Path(p) ⇑ c

**(WF-Module-Path-Ident-Err)**
∃ comp ∈ p. ¬(Γ ⊢ comp : Identifier)    c = Code(WF-Module-Path-Ident-Err)
──────────────────────────────────────────────────────────────────────────
Γ ⊢ WF-Module-Path(p) ⇑ c

**(WF-Module-Path-Collision)**
p_1 ≠ p_2    Fold(p_1) = Fold(p_2)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(Code(WF-Module-Path-Collision))    Γ ⊢ Emit(W-MOD-1101, ⊥)

**Module Discovery (Small-Step)**
DiscState = {DiscStart(S, A), DiscScan(S, A, Pending, M, Seen), DiscDone(M), Error(code)}

**(Disc-Start)**
────────────────────────────────────────────────────────────────────────────
⟨DiscStart(S, A)⟩ → ⟨DiscScan(S, A, DirSeq(S), [], ∅)⟩

**(Disc-Skip)**
Γ ⊬ d : ModuleDir
────────────────────────────────────────────────────────────
⟨DiscScan(S, A, d::ds, M, Seen)⟩ → ⟨DiscScan(S, A, ds, M, Seen)⟩

**(Disc-Add)**
Γ ⊢ d : ModuleDir    Γ ⊢ ModulePath(d, S, A) = p    Γ ⊢ WF-Module-Path(p) ⇓ ok    Fold(p) ∉ dom(Seen)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨DiscScan(S, A, d::ds, M, Seen)⟩ → ⟨DiscScan(S, A, ds, M ++ [p], Seen ∪ {Fold(p) ↦ p})⟩

**(Disc-Collision)**
Γ ⊢ d : ModuleDir    Γ ⊢ ModulePath(d, S, A) = p    Γ ⊢ WF-Module-Path(p) ⇓ ok    Fold(p) ∈ dom(Seen)    Seen[Fold(p)] ≠ p
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨DiscScan(S, A, d::ds, M, Seen)⟩ → ⟨Error(Code(Disc-Collision))⟩

**(Disc-Invalid-Component)**
Γ ⊢ d : ModuleDir    Γ ⊢ ModulePath(d, S, A) = p    Γ ⊢ WF-Module-Path(p) ⇑ c
────────────────────────────────────────────────────────────────────────────────────────────────
⟨DiscScan(S, A, d::ds, M, Seen)⟩ → ⟨Error(c)⟩

**(Disc-Rel-Fail)**
Γ ⊢ d : ModuleDir    relative(d, S) ⇑
────────────────────────────────────────────────────────────────────────────
⟨DiscScan(S, A, d::ds, M, Seen)⟩ → ⟨Error(Code(Disc-Rel-Fail))⟩

**(Disc-Done)**
──────────────────────────────────────────────────────────────
⟨DiscScan(S, A, [], M, Seen)⟩ → ⟨DiscDone(M)⟩

**(WF-Import-Unsupported)**
import_decl ∈ M
────────────────────────────────────────────────
Γ ⊢ Emit(Code(WF-Import-Unsupported))

### 2.5. Output Artifacts and Linking

**Output Root.**

O = OutputRoot(P) =
 P.root/P.assembly.out_dir  if provided
 P.root/`build`             otherwise

**Output Hygiene (Cursive0).**
OutputHygiene(P) ⇔ ∀ p ∈ RequiredOutputs(P). Under(p, OutputRoot(P))

OutputPaths(R, A).root =
 R/A.out_dir  if provided
 R/`build`    otherwise
OutputPaths(R, A).obj_dir = OutputPaths(R, A).root/`obj`
OutputPaths(R, A).ir_dir = OutputPaths(R, A).root/`ir`
OutputPaths(R, A).bin_dir = OutputPaths(R, A).root/`bin`

P.outputs = P.assembly.outputs

**Object File Naming**

PathToPrefix(s) = Concat([BMap(b) | b ∈ Utf8(NFC(s))])
BMap(b) =
 chr(b)           if b ∈ [0-9A-Za-z]
 "_x" ++ Hex2(b)  otherwise

mangle(s) = PathToPrefix(s)
MangleModulePath(p) = mangle(PathString(PathKey(p)))

obj(m) = O / `obj` / (MangleModulePath(p) ++ ".obj")

**Executable Naming**

exe = O / `bin` / (assembly_name ++ ".exe")

**Output and Linking Semantics (Formal Rules)**

path(m) = m.path
S = P.source_root

**Module Emission Order.**

m_1 ≺_mod m_2 ⇔ Utf8LexLess(Fold(path(m_1)), Fold(path(m_2))) ∨ (Fold(path(m_1)) = Fold(path(m_2)) ∧ Utf8LexLess(path(m_1), path(m_2)))

Utf8LexLess(a, b) ⇔ LexBytes(Utf8(a), Utf8(b))

**(ModuleList-Ok)**
Γ ⊢ Modules(S, P.assembly.name) ⇓ M    L = sort_{≺_mod}(M)
───────────────────────────────────────────────────────────
Γ ⊢ ModuleList(P) ⇓ L

**(ModuleList-Err)**
Γ ⊢ Modules(S, P.assembly.name) ⇑ c
────────────────────────────────────
Γ ⊢ ModuleList(P) ⇑ c

**Output Paths.**
O = OutputRoot(P)
assembly_name = P.assembly.name
ext(e) =
 ".ll"  if e = `ll`
 ".bc"  if e = `bc`

ObjPath(P, m) = O / `obj` / (MangleModulePath(path(m)) ++ ".obj")
IRPath(P, m, e) = O / `ir` / (MangleModulePath(path(m)) ++ ext(e))
ExePath(P) =
 O / `bin` / (assembly_name ++ ".exe")  if Executable(P)
 ⊥                                     otherwise

ObjPaths(P, ms) = [ObjPath(P, m) | m ∈ ms]
IRPaths(P, ms, e) = [IRPath(P, m, e) | m ∈ ms]

**Module Index and Symbol Name.**
ModuleList(P) = [m_1, …, m_n]
Index(P, m_i) = i
pad4(i) = PadLeft(Decimal(i), '0', 4)
SymbolName(P, m) =
 "main"  if path(m) = P.assembly.name
 "mod" ++ pad4(Index(P, m))  otherwise

trunc8(s) = PadRight(Take(Utf8(s), 8), 8, 0x00)

**LLVM Target Constants.**
LLVMTriple = "x86_64-pc-windows-msvc"
LLVMDataLayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

IsRootModule(P, m) ⇔ path(m) = P.assembly.name

WithEntry(P, m, IR) =
 IR ++ [EntryStub(P)]  if Executable(P) ∧ IsRootModule(P, m)
 IR                    otherwise

**(CodegenObj-LLVM)**
Project(Γ) = P    Γ ⊢ CodegenModule(m) ⇓ IR    IR' = WithEntry(P, m, IR)    Γ ⊢ LowerIR(IR') ⇓ L    Γ ⊢ EmitObj(L) ⇓ b
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ CodegenObj(m) ⇓ b

**(CodegenIR-LLVM)**
Project(Γ) = P    e ∈ {`ll`, `bc`}    Γ ⊢ CodegenModule(m) ⇓ IR    IR' = WithEntry(P, m, IR)    Γ ⊢ LowerIR(IR') ⇓ L    Γ ⊢ EmitLLVM(L) ⇓ b
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ CodegenIR(m, e) ⇓ b

**File Emission.**
WriteFileOk(p, b) ⇒ Overwrites(p, b)

**Directory Creation.**
EnsureDir(p) ⇓ ok ⇒ IsDir(p)

**Emit Objects**

**(Emit-Objects-Empty)**
────────────────────────────────────────
Γ ⊢ EmitObjects([], P) ⇓ []

**(Emit-Objects-Cons)**
Γ ⊢ CodegenObj(m) ⇓ b    Γ ⊢ WriteFile(ObjPath(P, m), b) ⇓ ok    Γ ⊢ EmitObjects(ms, P) ⇓ L
────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ EmitObjects(m::ms, P) ⇓ ObjPath(P, m)::L

**Emit IR**

**(Emit-IR-None)**
e = `none`
───────────────────────────────
Γ ⊢ EmitIR(ms, P, e) ⇓ []

**(Emit-IR-Cons-LL)**
e = `ll`    Γ ⊢ CodegenIR(m, e) ⇓ b    Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇓ ok    Γ ⊢ EmitIR(ms, P, e) ⇓ L
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ EmitIR(m::ms, P, e) ⇓ IRPath(P, m, e)::L

**(Emit-IR-Cons-BC)**
e = `bc`    Γ ⊢ CodegenIR(m, `ll`) ⇓ t    Γ ⊢ ResolveTool(`llvm-as`) ⇓ a    Γ ⊢ AssembleIR(a, t) ⇓ b    Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇓ ok    Γ ⊢ EmitIR(ms, P, e) ⇓ L
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ EmitIR(m::ms, P, e) ⇓ IRPath(P, m, e)::L

EmitIRFail(m, P, `ll`) ⇔ Γ ⊢ CodegenIR(m, `ll`) ⇑ ∨ (∃ b. Γ ⊢ CodegenIR(m, `ll`) ⇓ b ∧ Γ ⊢ WriteFile(IRPath(P, m, `ll`), b) ⇑)
EmitIRFail(m, P, `bc`) ⇔
 Γ ⊢ CodegenIR(m, `ll`) ⇑ ∨
 (∃ t. Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇑) ∨
 (∃ t, a. Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇓ a ∧ Γ ⊢ AssembleIR(a, t) ⇑) ∨
 (∃ t, a, b. Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇓ a ∧ Γ ⊢ AssembleIR(a, t) ⇓ b ∧ Γ ⊢ WriteFile(IRPath(P, m, `bc`), b) ⇑)

**(Emit-IR-Err)**
EmitIRFail(m, P, e)    c = Code(Out-IR-Err)
────────────────────────────────────────────
Γ ⊢ EmitIR(m::ms, P, e) ⇑ c

LinkJudg = {ResolveRuntimeLib, Link}
RuntimeLibName = "cursive0_rt.lib"
RuntimeLibPath(P) = P.root / `runtime` / RuntimeLibName

**(ResolveRuntimeLib-Ok)**
Γ ⊢ ReadBytes(RuntimeLibPath(P)) ⇓ _
──────────────────────────────────────────────
Γ ⊢ ResolveRuntimeLib(P) ⇓ RuntimeLibPath(P)

**(ResolveRuntimeLib-Err)**
Γ ⊢ ReadBytes(RuntimeLibPath(P)) ⇑
─────────────────────────────────
Γ ⊢ ResolveRuntimeLib(P) ⇑

LinkerSyms : Path × List(Path) × Path ⇀ ℘(Symbol)
RuntimeRequiredSyms = RuntimeSyms
MissingRuntimeSym(t, L, exe) ⇔ RuntimeRequiredSyms ⊈ LinkerSyms(t, L, exe)

LinkObjs(P) = ObjPaths(P, ModuleList(P))
LinkInputs(P) = LinkObjs(P) ++ [RuntimeLibPath(P)]
LinkFlags(P) = ["/OUT:" ++ ExePath(P), "/ENTRY:main", "/SUBSYSTEM:CONSOLE", "/NODEFAULTLIB"]
LinkArgsOk(P, L, exe) ⇔ L = LinkInputs(P) ∧ exe = ExePath(P) ∧ LinkFlags(P) = ["/OUT:" ++ ExePath(P), "/ENTRY:main", "/SUBSYSTEM:CONSOLE", "/NODEFAULTLIB"]

**(Link-Ok)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    Γ ⊢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) ⇓ ok
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Link(Objs, P) ⇓ ok

**(Link-NotFound)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇑    c = Code(Out-Link-NotFound)
─────────────────────────────────────────────────────────────────────────────
Γ ⊢ Link(Objs, P) ⇑ c

**(Link-Runtime-Missing)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇑    c = Code(Out-Link-Runtime-Missing)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Link(Objs, P) ⇑ c

**(Link-Runtime-Incompatible)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    c = Code(Out-Link-Runtime-Incompatible)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Link(Objs, P) ⇑ c

**(Link-Fail)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    ¬ MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    Γ ⊢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) ⇑    c = Code(Out-Link-Fail)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Link(Objs, P) ⇑ c

**Output Pipeline (Big-Step)**
O = OutputRoot(P)
ms = ModuleList(P)
e = P.assembly.emit_ir

**(Output-Pipeline)**
Executable(P)    Γ ⊢ EnsureDir(O) ⇓ ok    Γ ⊢ EnsureDir(O / `obj`) ⇓ ok    Γ ⊢ EnsureDir(O / `bin`) ⇓ ok    (e = `none` ∨ Γ ⊢ EnsureDir(O / `ir`) ⇓ ok)    Γ ⊢ EmitObjects(ms, P) ⇓ Objs    Γ ⊢ EmitIR(ms, P, e) ⇓ IRs    Γ ⊢ Link(Objs, P) ⇓ ok
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ OutputPipeline(P) ⇓ (Objs, IRs, ExePath(P))

**(Output-Pipeline-Lib)**
¬ Executable(P)    Γ ⊢ EnsureDir(O) ⇓ ok    Γ ⊢ EnsureDir(O / `obj`) ⇓ ok    (e = `none` ∨ Γ ⊢ EnsureDir(O / `ir`) ⇓ ok)    Γ ⊢ EmitObjects(ms, P) ⇓ Objs    Γ ⊢ EmitIR(ms, P, e) ⇓ IRs
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ OutputPipeline(P) ⇓ (Objs, IRs, ⊥)

**(Output-Pipeline-Err)**
⟨OutStart(P)⟩ →* ⟨Error(c)⟩
────────────────────────────────
Γ ⊢ OutputPipeline(P) ⇑ c

**Output Pipeline (Small-Step)**
OutState = {OutStart(P), OutDirs(P), OutObjs(P, ms, Objs), OutIR(P, ms, Objs, IRs, e), OutLink(P, Objs, IRs), OutDone(Objs, IRs, Exe), Error(code)}
O = OutputRoot(P)
ms = ModuleList(P)
e = P.assembly.emit_ir

**(Out-Start)**
────────────────────────────────────────
⟨OutStart(P)⟩ → ⟨OutDirs(P)⟩

**(Out-Dirs-Ok)**
Γ ⊢ EnsureDir(O) ⇓ ok    Γ ⊢ EnsureDir(O / `obj`) ⇓ ok    (¬ Executable(P) ∨ Γ ⊢ EnsureDir(O / `bin`) ⇓ ok)    (e = `none` ∨ Γ ⊢ EnsureDir(O / `ir`) ⇓ ok)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutDirs(P)⟩ → ⟨OutObjs(P, ms, [])⟩

**(Out-Dirs-Err)**
Γ ⊢ EnsureDir(O) ⇑ ∨ Γ ⊢ EnsureDir(O / `obj`) ⇑ ∨ (Executable(P) ∧ Γ ⊢ EnsureDir(O / `bin`) ⇑) ∨ (e ∈ {`ll`, `bc`} ∧ Γ ⊢ EnsureDir(O / `ir`) ⇑)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutDirs(P)⟩ → ⟨Error(Code(Out-Dirs-Err))⟩

**(Out-Obj-Collision)**
¬ Distinct(L ++ ObjPaths(P, ms))
──────────────────────────────────────────────
⟨OutObjs(P, ms, L)⟩ → ⟨Error(Code(Out-Obj-Collision))⟩

**(Out-Obj-Cons)**
Γ ⊢ CodegenObj(m) ⇓ b    Γ ⊢ WriteFile(ObjPath(P, m), b) ⇓ ok
─────────────────────────────────────────────────────────────────────────────
⟨OutObjs(P, m::ms, L)⟩ → ⟨OutObjs(P, ms, L ++ [ObjPath(P, m)])⟩

**(Out-Obj-Err)**
Γ ⊢ CodegenObj(m) ⇑ ∨ (Γ ⊢ CodegenObj(m) ⇓ b ∧ Γ ⊢ WriteFile(ObjPath(P, m), b) ⇑)
──────────────────────────────────────────────────────────────────────────────────────────────
⟨OutObjs(P, m::ms, L)⟩ → ⟨Error(Code(Out-Obj-Err))⟩

**(Out-Obj-Done)**
────────────────────────────────────────────────────────────────────
⟨OutObjs(P, [], L)⟩ → ⟨OutIR(P, ModuleList(P), L, [], e)⟩

**(Out-IR-None)**
e = `none`    Executable(P)
─────────────────────────────────────────────────────────────────────
⟨OutIR(P, ms, Objs, IRs, e)⟩ → ⟨OutLink(P, Objs, IRs)⟩

**(Out-IR-None-NoLink)**
e = `none`    ¬ Executable(P)
────────────────────────────────────────────────────────────────────────
⟨OutIR(P, ms, Objs, IRs, e)⟩ → ⟨OutDone(Objs, IRs, ⊥)⟩

**(Out-IR-Collision)**
e ∈ {`ll`, `bc`}    ¬ Distinct(IRs ++ IRPaths(P, ms, e))
──────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, ms, Objs, IRs, e)⟩ → ⟨Error(Code(Out-IR-Collision))⟩

**(Out-IR-Cons-LL)**
e = `ll`    Γ ⊢ CodegenIR(m, e) ⇓ b    Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇓ ok
────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, m::ms, Objs, IRs, e)⟩ → ⟨OutIR(P, ms, Objs, IRs ++ [IRPath(P, m, e)], e)⟩

**(Out-IR-Cons-BC)**
e = `bc`    Γ ⊢ CodegenIR(m, `ll`) ⇓ t    Γ ⊢ ResolveTool(`llvm-as`) ⇓ a    Γ ⊢ AssembleIR(a, t) ⇓ b    Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇓ ok
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, m::ms, Objs, IRs, e)⟩ → ⟨OutIR(P, ms, Objs, IRs ++ [IRPath(P, m, e)], e)⟩

**(Out-IR-Err)**
(e = `ll` ∧ (Γ ⊢ CodegenIR(m, e) ⇑ ∨ (Γ ⊢ CodegenIR(m, e) ⇓ b ∧ Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇑))) ∨
(e = `bc` ∧ (Γ ⊢ CodegenIR(m, `ll`) ⇑ ∨ (Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇑) ∨ (Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇓ a ∧ Γ ⊢ AssembleIR(a, t) ⇑) ∨ (Γ ⊢ CodegenIR(m, `ll`) ⇓ t ∧ Γ ⊢ ResolveTool(`llvm-as`) ⇓ a ∧ Γ ⊢ AssembleIR(a, t) ⇓ b ∧ Γ ⊢ WriteFile(IRPath(P, m, e), b) ⇑)))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, m::ms, Objs, IRs, e)⟩ → ⟨Error(Code(Out-IR-Err))⟩

**(Out-IR-Done)**
e ∈ {`ll`, `bc`}    ms = []    Executable(P)
─────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, ms, Objs, IRs, e)⟩ → ⟨OutLink(P, Objs, IRs)⟩

**(Out-IR-Done-NoLink)**
e ∈ {`ll`, `bc`}    ms = []    ¬ Executable(P)
────────────────────────────────────────────────────────────────────────────────
⟨OutIR(P, ms, Objs, IRs, e)⟩ → ⟨OutDone(Objs, IRs, ⊥)⟩

**(Out-Link-Ok)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    Γ ⊢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) ⇓ ok
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutLink(P, Objs, IRs)⟩ → ⟨OutDone(Objs, IRs, ExePath(P))⟩

**(Out-Link-NotFound)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇑
────────────────────────────────────────────────────────────────────────────
⟨OutLink(P, Objs, IRs)⟩ → ⟨Error(Code(Out-Link-NotFound))⟩

**(Out-Link-Runtime-Missing)**
Executable(P)    Γ ⊢ ResolveRuntimeLib(P) ⇑
──────────────────────────────────────────────────────────────────────────────
⟨OutLink(P, Objs, IRs)⟩ → ⟨Error(Code(Out-Link-Runtime-Missing))⟩

**(Out-Link-Runtime-Incompatible)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutLink(P, Objs, IRs)⟩ → ⟨Error(Code(Out-Link-Runtime-Incompatible))⟩

**(Out-Link-Fail)**
Executable(P)    Γ ⊢ ResolveTool(`lld-link`) ⇓ t    Γ ⊢ ResolveRuntimeLib(P) ⇓ lib    ¬ MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    Γ ⊢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) ⇑
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨OutLink(P, Objs, IRs)⟩ → ⟨Error(Code(Out-Link-Fail))⟩

### 2.6. Tool Resolution and IR Assembly Inputs

SearchDirs(P) =
 [Env(`C0_LLVM_BIN`)]  if Env(`C0_LLVM_BIN`) ≠ ⊥ ∧ Env(`C0_LLVM_BIN`) ≠ ""
 [P.root/`llvm/llvm-21.1.8-x86_64/bin`]  if RepoLLVM(P)
 PATHDirs  otherwise

**(ResolveTool-Ok)**
Project(Γ) = P    SearchDirs(P) contains x at t
───────────────────────────────────────────────
Γ ⊢ ResolveTool(x) ⇓ t

**(ResolveTool-Err-Linker)**
Project(Γ) = P    x = `lld-link`    SearchDirs(P) does not contain x
─────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTool(x) ⇑

**(ResolveTool-Err-IR)**
Project(Γ) = P    x = `llvm-as`    SearchDirs(P) does not contain x
────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTool(x) ⇑

**(AssembleIR-Ok)**
Invoke(a, t) ⇓ b
────────────────────────
Γ ⊢ AssembleIR(a, t) ⇓ b

**(AssembleIR-Err)**
Invoke(a, t) ⇑
────────────────────────
Γ ⊢ AssembleIR(a, t) ⇑

### 2.7. Unwind and FFI Surface

**(WF-Unwind-Unsupported)**
`[[unwind]]` ∈ M
──────────────────────────────────────────────
Γ ⊢ Emit(Code(WF-Unwind-Unsupported))

## 3. Phase 1: Source Loading, Lexing, Parsing

### 3.1. Source Loading and Normalization

**Source File Record.**

SourceFile = ⟨path, bytes, scalars, text, byte_len, line_starts, line_count⟩

S.text = EncodeUTF8(S.scalars)
S.byte_len = ByteLen(S.text)
S.line_count = |S.line_starts|

**Unicode Scalars and UTF-8.**
Byte = { n ∈ ℕ | 0 ≤ n ≤ 255 }
Bytes = [Byte]
UnicodeScalar = { u ∈ ℕ | 0 ≤ u ≤ 0x10FFFF ∧ u ∉ [0xD800, 0xDFFF] }
Scalars = [UnicodeScalar]
String = Scalars
Utf8Len(u) =
 1  if 0 ≤ u ≤ 0x7F
 2  if 0x80 ≤ u ≤ 0x7FF
 3  if 0x800 ≤ u ≤ 0xFFFF
 4  if 0x10000 ≤ u ≤ 0x10FFFF
EncodeUTF8(u) =
 [u]  if 0 ≤ u ≤ 0x7F
 [0xC0 ∨ (u >> 6), 0x80 ∨ (u & 0x3F)]  if 0x80 ≤ u ≤ 0x7FF
 [0xE0 ∨ (u >> 12), 0x80 ∨ ((u >> 6) & 0x3F), 0x80 ∨ (u & 0x3F)]  if 0x800 ≤ u ≤ 0xFFFF
 [0xF0 ∨ (u >> 18), 0x80 ∨ ((u >> 12) & 0x3F), 0x80 ∨ ((u >> 6) & 0x3F), 0x80 ∨ (u & 0x3F)]  if 0x10000 ≤ u ≤ 0x10FFFF
EncodeUTF8([]) = []
EncodeUTF8(u::U) = EncodeUTF8(u) ++ EncodeUTF8(U)
DecodeUTF8(B) = U ⇔ EncodeUTF8(U) = B
Utf8Valid(B) ⇔ ∃ U. DecodeUTF8(B) = U
Utf8(s) = EncodeUTF8(s)


#### 3.1.1. Unicode Normalization Outside Identifiers

NormalizeOutsideIdentifiers : Scalars → Scalars
NormalizeOutsideIdentifiers(T) = T

#### 3.1.2. Lexically Sensitive Unicode Enforcement
T = S.scalars
LexSensitivePos(S) = [ p | 0 ≤ p < |T| ∧ Sensitive(T[p]) ∧ ¬ InsideLiteralOrComment(p) ]
Γ ⊢ LexSecure(S, K, LexSensitivePos(S)) ⇓ ok
#### 3.1.3. UTF-8 Decoding and BOM Handling


**(Decode-Ok)**
DecodeUTF8(B) ⇓ U
────────────────────────
Γ ⊢ Decode(B) ⇓ U

**(Decode-Err)**
DecodeUTF8(B) ⇑
────────────────────────
Γ ⊢ Decode(B) ⇑

StripLeadBOM([]) = []
StripLeadBOM(U+FEFF::U) = U
StripLeadBOM(u::U) = u::U  if u ≠ U+FEFF

**(StripBOM-Empty)**
────────────────────────────────────────
Γ ⊢ StripBOM([]) ⇓ ([], false, ⊥)

**(StripBOM-None)**
U = u_0::u_1::…    u_0 ≠ U+FEFF    ∀ i > 0, u_i ≠ U+FEFF
────────────────────────────────────────────────────────────
Γ ⊢ StripBOM(U) ⇓ (U, false, ⊥)

**(StripBOM-Start)**
U = U+FEFF::U_1    ∀ i, U_1[i] ≠ U+FEFF
────────────────────────────────────────────
Γ ⊢ StripBOM(U) ⇓ (U_1, true, ⊥)

**(StripBOM-Embedded)**
U' = StripLeadBOM(U)    b = (U ≠ [] ∧ U[0] = U+FEFF)    i = min{ p | 0 ≤ p < |U'| ∧ U'[p] = U+FEFF }
──────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ StripBOM(U) ⇓ (U', b, i)

#### 3.1.4. Line Ending Normalization and Logical Lines

CR = U+000D
LF = U+000A

**(Norm-Empty)**
────────────────────────────────────────
Γ ⊢ NormalizeLF([]) ⇓ []

**(Norm-CRLF)**
Γ ⊢ NormalizeLF(U) ⇓ V
────────────────────────────────────────────────────────
Γ ⊢ NormalizeLF([CR, LF] ++ U) ⇓ [LF] ++ V

**(Norm-CR)**
U = [] ∨ U[0] ≠ LF    Γ ⊢ NormalizeLF(U) ⇓ V
──────────────────────────────────────────────────────────
Γ ⊢ NormalizeLF([CR] ++ U) ⇓ [LF] ++ V

**(Norm-LF)**
Γ ⊢ NormalizeLF(U) ⇓ V
────────────────────────────────────────────
Γ ⊢ NormalizeLF([LF] ++ U) ⇓ [LF] ++ V

**(Norm-Other)**
c ≠ CR    c ≠ LF    Γ ⊢ NormalizeLF(U) ⇓ V
────────────────────────────────────────────
Γ ⊢ NormalizeLF([c] ++ U) ⇓ [c] ++ V

**Logical Line Map.**

Utf8Offsets([]) = [0]
Utf8Offsets(c::cs) = [0] ++ [o + Utf8Len(c) | o ∈ Utf8Offsets(cs)]

LineStarts(T) = [0] ++ [Utf8Offsets(T)[i] + 1 | 0 ≤ i < |T| ∧ T[i] = LF]
LineCount(T) = |LineStarts(T)|

**Locate (Line/Column).**
L = S.line_starts
o' = min(o, S.byte_len)
k = max{ j | L[j] ≤ o' }

Γ ⊢ Locate(S, o) ⇓ ⟨file = S.path, offset = o', line = k + 1, col = o' - L[k] + 1⟩

#### 3.1.5. Prohibited Code Points

Prohibited(c) ⇔ General_Category(c) = Cc ∧ c ∉ {U+0009, U+000A, U+000C, U+000D}

LiteralSpan(T) = ⋃ { [ByteOf(T, i), ByteOf(T, j)) | StringRange(T, i, j) ∨ CharRange(T, i, j) }

**(WF-Prohibited)**
∀ i, Prohibited(T[i]) ⇒ ByteOf(T, i) ∈ LiteralSpan(T)
───────────────────────────────────────────────────────
Γ ⊢ T : NoProhibited

#### 3.1.6. NFC Normalization for Identifiers and Module Paths

NFC(s) = UnicodeNFC_{15.0.0}(s)

CaseFold(s) = UnicodeCaseFold_{15.0.0}(s)

**Totality.**
The functions NFC and CaseFold are total on sequences of Unicode scalar values. All inputs to IdKey and PathKey MUST be Unicode scalar sequences; inputs are produced by LoadSource, which rejects invalid UTF-8.

IdKey(s) = NFC(s)
IdEq(s_1, s_2) ⇔ IdKey(s_1) = IdKey(s_2)

PathKey(p) = [NFC(c_1), …, NFC(c_n)]
PathEq(p, q) ⇔ PathKey(p) = PathKey(q)

#### 3.1.7. Newline Tokens and Statement Termination

Tokenize : SourceFile ⇀ (Token* × DocComment*)
Tokenize(S) = (K, D) ⇒ LexNewline(K, S) ∧ LexNoComments(K, S)

Depth(K, 0) = 0
Depth(K, i+1) = Depth(K, i) + δ(K[i])
δ(t) =
 1   if t ∈ {Punctuator("("), Punctuator("["), Punctuator("{")}
 -1  if t ∈ {Punctuator(")"), Punctuator("]"), Punctuator("}")}
 0   otherwise

Prev(K, i) = ⊥ ⇔ { j | j < i ∧ K[j].kind ≠ newline ∧ ∀ k. j < k < i ⇒ K[k].kind ≠ newline } = ∅
Prev(K, i) = K[j] ⇔ j = max{ j | j < i ∧ K[j].kind ≠ newline ∧ ∀ k. j < k < i ⇒ K[k].kind ≠ newline }
Next(K, i) = ⊥ ⇔ { j | j > i ∧ K[j].kind ≠ newline } = ∅
Next(K, i) = K[j] ⇔ j = min{ j | j > i ∧ K[j].kind ≠ newline }

Ambig = {"+", "-", "*", "&", "|"}
BeginsOperand(t) ⇔ t.kind ∈ {Identifier, IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral} ∨ (t.kind = Punctuator ∧ t.lexeme ∈ {"(", "[", "{"}) ∨ (t.kind = Operator ∧ t.lexeme ∈ {"!", "-", "&", "*", "^"}) ∨ (t.kind = Keyword ∧ t.lexeme ∈ {"if", "match", "loop", "unsafe", "move", "transmute", "widen"})
UnaryOnly = {"!", "~", "?"}

Continue(K, i) ⇔ Depth(K, i) > 0 ∨ (∃ t. Prev(K, i) = t ∧ (t.lexeme = "," ∨ (t.kind = Operator ∧ ((t.lexeme ∈ Ambig ∧ ∃ u. Next(K, i) = u ∧ BeginsOperand(u)) ∨ t.lexeme ∉ UnaryOnly)))) ∨ (∃ u. Next(K, i) = u ∧ u.lexeme ∈ {".", "::", "~>"})

Filter(K) = [ K[i] | K[i].kind ≠ newline ∨ ¬ Continue(K, i) ]

IsTerminator(t) ⇔ t = Punctuator(";") ∨ t.kind = newline
BoundaryTokens(K, i) = { t | t = K[i] ∨ t = Prev(K, i) ∨ t = Next(K, i) } \ {⊥}
HasTerminator(F, i) ⇔ ∃ t ∈ BoundaryTokens(F, i). IsTerminator(t)
RequiredTerminator : Token* × ℕ → Bool
ContinuesLine : Token* × ℕ → Bool
ContinuesLine(K, i) ⇔ K[i].kind = newline ∧ Continue(K, i)
RequiredTerminator(K, i) ⇔ K[i].kind = newline ∧ ¬ ContinuesLine(K, i)

**(Missing-Terminator-Err)**
RequiredTerminator(K, i)    ¬ HasTerminator(Filter(K), i)    c = Code(Missing-Terminator-Err)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c)


#### 3.1.8. Source Loading Pipeline (Small-Step and Big-Step)

SourceLoadState = {Start(f, B), Sized(f, B), Decoded(f, B, U), BomStripped(f, B, U, b, j), Normalized(f, B, T, j), LineMapped(f, B, T, L), Validated(S), Error(code)}
B ∈ Bytes
U ∈ Scalars
T ∈ Scalars
L = LineStarts(T)
j ∈ ℕ ∪ {⊥}

**(Step-Size)**
────────────────────────────────────────
⟨Start(f, B)⟩ → ⟨Sized(f, B)⟩

**(Step-Decode)**
Γ ⊢ Decode(B) ⇓ U
────────────────────────────────────────────
⟨Sized(f, B)⟩ → ⟨Decoded(f, B, U)⟩

**(Step-Decode-Err)**
Γ ⊢ Decode(B) ⇑
───────────────────────────────────────────────────────────
⟨Sized(f, B)⟩ → ⟨Error(Code(Step-Decode-Err))⟩

**(Step-BOM)**
Γ ⊢ StripBOM(U) ⇓ (U', b, j)
────────────────────────────────────────────────
⟨Decoded(f, B, U)⟩ → ⟨BomStripped(f, B, U', b, j)⟩

**(Step-Norm)**
T = NormalizeOutsideIdentifiers(U)    Γ ⊢ NormalizeLF(T) ⇓ V
─────────────────────────────────────────────────────────────
⟨BomStripped(f, B, U, b, j)⟩ → ⟨Normalized(f, B, V, j)⟩

**(Step-EmbeddedBOM-Err)**
j ≠ ⊥
───────────────────────────────────────────────────────────
⟨Normalized(f, B, T, j)⟩ → ⟨Error(Code(Step-EmbeddedBOM-Err))⟩

**(Step-LineMap)**
j = ⊥    L = LineStarts(T)
────────────────────────────────────────────────────────────
⟨Normalized(f, B, T, j)⟩ → ⟨LineMapped(f, B, T, L)⟩

**(Step-Prohibited)**
Γ ⊢ T : NoProhibited    S = ⟨path = f, bytes = B, scalars = T, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = L, line_count = |L|⟩
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LineMapped(f, B, T, L)⟩ → ⟨Validated(S)⟩

**(Step-Prohibited-Err)**
Γ ⊬ T : NoProhibited
────────────────────────────────────────────────────────────
⟨LineMapped(f, B, T, L)⟩ → ⟨Error(Code(Step-Prohibited-Err))⟩

**Source Load (Big-Step)**

**(LoadSource-Ok)**
Γ ⊢ Decode(B) ⇓ U    Γ ⊢ StripBOM(U) ⇓ (U', b, ⊥)    Γ ⊢ NormalizeLF(NormalizeOutsideIdentifiers(U')) ⇓ T    L = LineStarts(T)    Γ ⊢ T : NoProhibited    S = ⟨path = f, bytes = B, scalars = T, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = L, line_count = |L|⟩
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LoadSource(f, B) ⇓ S

**(LoadSource-Err)**
Γ ⊢ LoadSource(f, B) →* ⟨Error(c)⟩
──────────────────────────────────────
Γ ⊢ LoadSource(f, B) ⇑ c

#### 3.1.9. Diagnostic Spans for Source Loading

S_tmp = ⟨path = f, bytes = B, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = LineStarts(T), line_count = |LineStarts(T)|⟩

O = Utf8Offsets(T)
O[|T|] = ByteLen(T)

SpanAtIndex(T, i) = SpanOf(S_tmp, O[i], O[i+1])

SpanAtLineStart(T, k) = SpanOf(S_tmp, s, e)
s =
 LineStarts(T)[k]  if k < |LineStarts(T)|
 ByteLen(T)        otherwise
e = min(s + 1, ByteLen(T))

If b = true, the warning W-SRC-0101 MUST be emitted even if LoadSource ultimately fails.


**(Span-BOM-Warn)**
b = true    e = min(1, ByteLen(T))
──────────────────────────────────────────────
Γ ⊢ Emit(W-SRC-0101, SpanOf(S_tmp, 0, e))

**(Span-BOM-Embedded)**
j ≠ ⊥    i = min{ p | 0 ≤ p < |T| ∧ T[p] = U+FEFF }
───────────────────────────────────────────────────────────────────
Γ ⊢ Emit(E-SRC-0103, SpanAtIndex(T, i))

**(Span-Prohibited)**
i = min{ p | 0 ≤ p < |T| ∧ Prohibited(T[p]) ∧ O[p] ∉ LiteralSpan(T) }
─────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(E-SRC-0104, SpanAtIndex(T, i))

**(NoSpan-Decode)**
────────────────────────────────────────
Γ ⊢ Emit(E-SRC-0101, ⊥)

### 3.2. Lexical Analysis

#### 3.2.1. Inputs, Outputs, and Records

**LexerInput.**
T = S.scalars
B = S.text
n = S.byte_len
LexerInput(S) = ⟨T, B, n⟩

**LexerOutput.**
LexerOutput(S) = ⟨K, D⟩
K ∈ Token*    D ∈ DocComment*

**EOF Token.**
EOFSpan(S) = SpanOfText(S, |T|, |T|)
TokenEOF(S) = ⟨EOF, ε, EOFSpan(S)⟩

**LexemeBinding.**
TokenRange(S, t) = (i, j) ⇔ t.span = SpanOfText(S, i, j)
LexemeBinding(S, T, K) ⇔ ∀ t ∈ K. ∃ i, j. TokenRange(S, t) = (i, j) ∧ t.lexeme = Lexeme(T, i, j)

**DocComment.**

DocComment = ⟨kind, text, span⟩

DocKind = {LineDoc, ModuleDoc}
StripLeadingSpace(s) =
 s[1..|s|)  if |s| > 0 ∧ At(s, 0) = U+0020
 s          otherwise
DocBody(T, i, j) = StripLeadingSpace(T[i+3..j))
DocMarker(T, i) =
 LineDoc    if T[i..i+3] = "///"
 ModuleDoc  if T[i..i+3] = "//!"
 ⊥          otherwise

**Newline Tokens.**
NewlineTokenAt(S, T, i) ⇔ T[i] = LF ∧ ¬ InsideLiteralOrComment(i)
LexNewline(K, S) ⇔ ∀ i. NewlineTokenAt(S, T, i) ⇒ ∃ t ∈ K. t.kind = Newline ∧ TokenRange(S, t) = (i, i+1)
TokenInComment(S, t) ⇔ ∃ i, j, a, b. TokenRange(S, t) = (i, j) ∧ (LineCommentRange(T, a, b) ∨ BlockCommentRange(T, a, b)) ∧ a ≤ i ∧ j ≤ b
LexNoComments(K, S) ⇔ ∀ t ∈ K. ¬ TokenInComment(S, t)

**Indices and Lexemes.**
T = S.scalars
O = Utf8Offsets(T)
ScalarIndex(T) = { i | 0 ≤ i ≤ |T| }

ByteOf(T, i) = O[i]

SpanOfText(S, i, j) = SpanOf(S, ByteOf(T, i), ByteOf(T, j))

Lexeme(T, i, j) = T[i..j)

#### 3.2.2. Character Classes

c ∈ UnicodeScalar

**Whitespace.**

Whitespace(c) ⇔ c ∈ {U+0020, U+0009, U+000C}

**Line Feed.**

LineFeed(c) ⇔ c = U+000A

**Identifier Characters.**
XID_Start : UnicodeScalar → Bool
XID_Continue : UnicodeScalar → Bool

IdentStart(c) ⇔ c = '_' ∨ XID_Start(c)
IdentContinue(c) ⇔ c = '_' ∨ XID_Continue(c)

XIDVersion = "15.0.0"
XID_Start(c) ⇔ c ∈ UAX31_XID_Start_{15.0.0}
XID_Continue(c) ⇔ c ∈ UAX31_XID_Continue_{15.0.0}

**Non-Characters.**

NonCharacter(c) ⇔ c ∈ [U+FDD0, U+FDEF] ∨ (c & 0xFFFF) ∈ {0xFFFE, 0xFFFF}

**Digits.**

DecDigit(c) ⇔ c ∈ {'0' … '9'}
HexDigit(c) ⇔ DecDigit(c) ∨ c ∈ {'a' … 'f', 'A' … 'F'}
OctDigit(c) ⇔ c ∈ {'0' … '7'}
BinDigit(c) ⇔ c ∈ {'0', '1'}

**Lexically Sensitive Characters.**

Sensitive(c) ⇔ c ∈ {U+202A … U+202E, U+2066 … U+2069, U+200C, U+200D}

#### 3.2.3. Reserved Lexemes

**Reserved.**
Reserved = {`as`, `break`, `class`, `continue`, `else`, `enum`, `false`, `defer`, `frame`, `if`, `imm`, `import`, `internal`, `let`, `loop`, `match`, `modal`, `move`, `mut`, `null`, `private`, `procedure`, `protected`, `public`, `record`, `region`, `result`, `return`, `shadow`, `shared`, `transition`, `transmute`, `true`, `type`, `unique`, `unsafe`, `var`, `widen`, `using`, `const`, `override`}

FutureReserved = ∅

**Keyword Predicate.**
Keyword(s) ⇔ s ∈ Reserved

**Reserved Namespaces.**
ReservedNamespacePrefix = {`cursive.`}
ReservedIdentPrefix = {`gen_`}
ReservedNamespacePhase = Phase3

**Universe-Protected Bindings.**
UniverseProtected = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `f16`, `f32`, `f64`, `bool`, `char`, `usize`, `isize`, `Self`, `Drop`, `Bitcopy`, `Clone`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, `Context`, `System`, `Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`}
UniverseProtectedPhase = Phase3

#### 3.2.4. Token Kinds

TokenKind ∈ {Identifier, Keyword(k), IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral, Operator(o), Punctuator(p), Newline, Unknown}

**Operator Set.**
OperatorSet = {"+", "-", "*", "/", "%", "**", "==", "!=", "<", "<=", ">", ">=", "&&", "||", "!", "&", "|", "^", "<<", ">>", "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>=", ":=", "<:", "..", "..=", "=>", "->", "::", "~", "~>", "~!", "?", "#", "@", "$"}

**Punctuator Set.**
PunctuatorSet = {"(", ")", "[", "]", "{", "}", ",", ":", ";", "."}

OperatorSet ∩ PunctuatorSet = ∅

#### 3.2.5. Comment and Whitespace Scanning

T = S.scalars

**Line Comment Scan.**

**(Scan-Line-Comment)**
T[i] = '/'    T[i+1] = '/'    j = min{ p | i ≤ p ∧ (p = |T| ∨ T[p] = LF) }
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ScanLineComment(T, i) ⇓ j

**Doc Comment Classification.**
kind = DocMarker(T, i)
body = DocBody(T, i, j)

**(Doc-Comment)**
Γ ⊢ ScanLineComment(T, i) ⇓ j    kind ≠ ⊥
──────────────────────────────────────────────────────────────
Γ ⊢ DocComment(T, i) ⇓ ⟨kind, body, SpanOfText(S, i, j)⟩

LineCommentTokens(T, i) = []
LineCommentNext(T, i) = j where Γ ⊢ ScanLineComment(T, i) ⇓ j

**Block Comment Scan (Nested).**
BlockState = { BlockScan(T, i, d, i_0) | 0 ≤ i_0 ≤ i ≤ |T| ∧ d ∈ ℕ } ∪ { BlockDone(j) | 0 ≤ j ≤ |T| }

**(Block-Start)**
T[i] = '/'    T[i+1] = '*'
───────────────────────────────────────────────────────────
⟨BlockScan(T, i, d, i_0)⟩ → ⟨BlockScan(T, i+2, d+1, i_0)⟩

**(Block-End)**
T[i] = '*'    T[i+1] = '/'    d > 1
───────────────────────────────────────────────────────────
⟨BlockScan(T, i, d, i_0)⟩ → ⟨BlockScan(T, i+2, d-1, i_0)⟩

**(Block-Done)**
T[i] = '*'    T[i+1] = '/'    d = 1
───────────────────────────────────────────────────────
⟨BlockScan(T, i, d, i_0)⟩ → ⟨BlockDone(i+2)⟩

**(Block-Step)**
T[i..i+2] ≠ "/*"    T[i..i+2] ≠ "*/"
───────────────────────────────────────────────────────────
⟨BlockScan(T, i, d, i_0)⟩ → ⟨BlockScan(T, i+1, d, i_0)⟩

**(Block-Comment-Unterminated)**
⟨BlockScan(T, i, d, i_0)⟩ →* ⟨BlockScan(T, |T|, d, i_0)⟩    d > 0    c = Code(Block-Comment-Unterminated)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, i_0, i_0+2))

#### 3.2.6. Literal Lexing

T = S.scalars

**Syntax.**

```ebnf
integer_literal  ::= (decimal_integer | hex_integer | octal_integer | binary_integer) int_suffix?
decimal_integer  ::= dec_digit ("_"* dec_digit)*
hex_integer      ::= "0x" hex_digit ("_"* hex_digit)*
octal_integer    ::= "0o" oct_digit ("_"* oct_digit)*
binary_integer   ::= "0b" bin_digit ("_"* bin_digit)*
int_suffix       ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"

float_literal ::= decimal_integer "." decimal_integer? exponent? float_suffix?
exponent      ::= ("e" | "E") ("+" | "-")? decimal_integer
float_suffix  ::= "f16" | "f32" | "f64"

string_literal   ::= '"' (string_char | escape_sequence)* '"'
string_char      ::= string_char_unit
escape_sequence  ::= "\n" | "\r" | "\t" | "\\" | "\"" | "\'" | "\0" | "\x" hex_digit hex_digit | "\u{" hex_digit+ "}"

char_literal ::= "'" (char_content | escape_sequence) "'"
char_content ::= char_content_unit

bool_literal ::= "true" | "false"
null_literal ::= "null"
```

**Escape Validity.**
SimpleEscape = {`\\`, `\"`, `\'`, `\n`, `\r`, `\t`, `\0`}
EscapeOk(`\\`) ∧ EscapeOk(`\"`) ∧ EscapeOk(`\'`) ∧ EscapeOk(`\n`) ∧ EscapeOk(`\r`) ∧ EscapeOk(`\t`) ∧ EscapeOk(`\0`)
EscapeOk("\\x" h_1 h_2) ⇔ HexDigit(h_1) ∧ HexDigit(h_2)
EscapeOk("\\u{" h_1 … h_n "}") ⇔ 1 ≤ n ≤ 6 ∧ UnicodeScalar(HexValue(h_1 … h_n))

StringChar(c) ⇔ UnicodeScalar(c) ∧ c ≠ "\"" ∧ c ≠ "\\" ∧ c ≠ U+000A
CharContent(c) ⇔ UnicodeScalar(c) ∧ c ≠ "'" ∧ c ≠ "\\" ∧ c ≠ U+000A
string_char_unit = { c | StringChar(c) }
char_content_unit = { c | CharContent(c) }

**Underscore Constraints.**
BasePrefix = {"0x", "0o", "0b"}
IntSuffixSet = {"i8", "i16", "i32", "i64", "i128", "u8", "u16", "u32", "u64", "u128", "isize", "usize"}
FloatSuffixSet = {"f16", "f32", "f64"}
NumSuffix = IntSuffixSet ∪ FloatSuffixSet
StartsWithUnderscore(s) ⇔ At(s, 0) = "_"
EndsWithUnderscore(s) ⇔ At(s, |s|-1) = "_"
AfterBasePrefixUnderscore(s) ⇔ ∃ p ∈ BasePrefix. StartsWith(s, Concat(p, "_"))
AdjacentExponentUnderscore(s) ⇔ ∃ i. At(s, i) = "_" ∧ ((i > 0 ∧ At(s, i-1) ∈ {"e", "E"}) ∨ (i+1 < |s| ∧ At(s, i+1) ∈ {"e", "E"}))
BeforeSuffixUnderscore(s) ⇔ ∃ suf ∈ NumSuffix. EndsWith(s, Concat("_", suf))
NumericUnderscoreOk(s) ⇔ ¬ StartsWithUnderscore(s) ∧ ¬ EndsWithUnderscore(s) ∧ ¬ AfterBasePrefixUnderscore(s) ∧ ¬ AdjacentExponentUnderscore(s) ∧ ¬ BeforeSuffixUnderscore(s)

**Numeric Scan (Maximal Prefix).**

DecRun(T, i) = max({i} ∪ { j | i < j ≤ |T| ∧ ∀ k ∈ [i, j). (DecDigit(T[k]) ∨ T[k] = "_") })
HexRun(T, i) = max({i} ∪ { j | i < j ≤ |T| ∧ ∀ k ∈ [i, j). (HexDigit(T[k]) ∨ T[k] = "_") })
OctRun(T, i) = max({i} ∪ { j | i < j ≤ |T| ∧ ∀ k ∈ [i, j). (OctDigit(T[k]) ∨ T[k] = "_") })
BinRun(T, i) = max({i} ∪ { j | i < j ≤ |T| ∧ ∀ k ∈ [i, j). (BinDigit(T[k]) ∨ T[k] = "_") })

SuffixMatch(T, i, U) = max({i} ∪ { j | i < j ≤ |T| ∧ Lexeme(T, i, j) ∈ U })

ExpSignEnd(T, i) =
 i+1  if i < |T| ∧ T[i] ∈ {"+", "-"}
 i    otherwise

ExpEnd(T, i) =
 DecRun(T, ExpSignEnd(T, i+1))  if i < |T| ∧ T[i] ∈ {"e", "E"}
 i                              otherwise

DecCoreEnd(T, i) =
 ExpEnd(T, q)  if p = DecRun(T, i) ∧ p < |T| ∧ T[p] = "." ∧ q = DecRun(T, p+1)
 ExpEnd(T, p)  if p = DecRun(T, i) ∧ (p ≥ |T| ∨ T[p] ≠ ".")

NumericCoreEnd(T, i) =
 HexRun(T, i+2)  if T[i..i+2] = "0x"
 OctRun(T, i+2)  if T[i..i+2] = "0o"
 BinRun(T, i+2)  if T[i..i+2] = "0b"
 DecCoreEnd(T, i)  otherwise

NumericScanEnd(T, i) = SuffixMatch(T, NumericCoreEnd(T, i), NumSuffix)

HasDot(T, i, j) ⇔ ∃ p. i ≤ p < j ∧ T[p] = "."
HasExp(T, i, j) ⇔ ∃ p. i ≤ p < j ∧ T[p] ∈ {"e", "E"}

NumericKind(T, i) =
 FloatLiteral  if SuffixMatch(T, NumericCoreEnd(T, i), FloatSuffixSet) > NumericCoreEnd(T, i)
 FloatLiteral  if HasDot(T, i, NumericCoreEnd(T, i)) ∨ HasExp(T, i, NumericCoreEnd(T, i))
 IntLiteral    otherwise

**(Lex-Int)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericKind(T, i) = IntLiteral
───────────────────────────────────────────────────────────────────────────────
Γ ⊢ IntLiteral(T, i) ⇓ j

**(Lex-Float)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericKind(T, i) = FloatLiteral
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ FloatLiteral(T, i) ⇓ j

NumericLexemeOk(T, i, j) ⇔ (Lexeme(T, i, j) matches integer_literal ∨ Lexeme(T, i, j) matches float_literal) ∧ NumericUnderscoreOk(Lexeme(T, i, j))
NumericLexemeBad(T, i, j) ⇔ ¬ NumericLexemeOk(T, i, j)

**(Lex-Numeric-Err)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericLexemeBad(T, i, j)    c = Code(Lex-Numeric-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, i, j))

**Leading Zeros.**
Digits(s) = Remove(s, "_")
DecimalLeadingZero(T, i, j) ⇔ Lexeme(T, i, j) matches decimal_integer ∧ |Digits(Lexeme(T, i, j))| > 1 ∧ At(Digits(Lexeme(T, i, j)), 0) = '0'

DecimalLeadingZero(T, i, j)
──────────────────────────────────────────────
Γ ⊢ Emit(W-SRC-0301, SpanOfText(S, i, j))

**EscapeSequences.**
EscapeValue(`\\`) = 0x5C
EscapeValue(`\"`) = 0x22
EscapeValue(`\'`) = 0x27
EscapeValue(`\n`) = 0x0A
EscapeValue(`\r`) = 0x0D
EscapeValue(`\t`) = 0x09
EscapeValue(`\0`) = 0x00
EscapeValue("\\x" h_1 h_2) = HexValue(h_1 h_2)
EscapeValue("\\u{" h_1 … h_n "}") = EncodeUTF8(HexValue(h_1 … h_n))

**(Lex-String)**
Lexeme(T, i, j) matches string_literal
────────────────────────────────────────────
Γ ⊢ StringLiteral(T, i) ⇓ j

BackslashCount(T, p) = max{ k | 0 ≤ k ≤ p ∧ ∀ r ∈ [p-k, p). T[r] = "\\" }
UnescapedQuote(T, p) ⇔ T[p] = "\"" ∧ BackslashCount(T, p) mod 2 = 0
StringTerminator(T, i) = min{ q | q > i ∧ (UnescapedQuote(T, q) ∨ T[q] = LF ∨ q = |T|) }
LineFeedOrEOFBeforeClose(T, i) ⇔ StringTerminator(T, i) = |T| ∨ T[StringTerminator(T, i)] = LF
EscapeMatch(T, p, q) ⇔ Lexeme(T, p, q) matches escape_sequence ∧ EscapeOk(Lexeme(T, p, q))
BadEscapeAt(T, p) ⇔ T[p] = "\\" ∧ ¬ ∃ q. EscapeMatch(T, p, q)
FirstBadEscape(T, i) = min{ p | i < p < StringTerminator(T, i) ∧ BadEscapeAt(T, p) }

**(Lex-String-Unterminated)**
LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-String-Unterminated)
────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, i, i+1))

**(Lex-String-BadEscape)**
FirstBadEscape(T, i) = p    c = Code(Lex-String-BadEscape)
───────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, p, p+1))

**(Lex-Char)**
Lexeme(T, i, j) matches char_literal
─────────────────────────────────────────
Γ ⊢ CharLiteral(T, i) ⇓ j

**Character Literal Encoding.**
CharValueRange = { x | 0 ≤ x ≤ 0x10FFFF ∧ x ∉ [0xD800, 0xDFFF] }
CharRepr = `u32`
SizeOf(`char`) = 4
AlignOf(`char`) = 4

UnescapedApostrophe(T, p) ⇔ T[p] = "'" ∧ BackslashCount(T, p) mod 2 = 0
CharTerminator(T, i) = min{ q | q > i ∧ (UnescapedApostrophe(T, q) ∨ T[q] = LF ∨ q = |T|) }
CharLiteralInvalid(T, i) ⇔ CharScalarCount(T, i) ≠ 1
CharScalarCountFrom(T, p, q) = 0 ⇔ p ≥ q
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, p+1, q) ⇔ p < q ∧ T[p] ≠ "\\"
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, r, q) ⇔ p < q ∧ T[p] = "\\" ∧ EscapeMatch(T, p, r)
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, p+1, q) ⇔ p < q ∧ T[p] = "\\" ∧ ¬ ∃ r. EscapeMatch(T, p, r)
CharScalarCount(T, i) = CharScalarCountFrom(T, i+1, CharTerminator(T, i))

**(Lex-Char-Unterminated)**
LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-Char-Unterminated)
─────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, i, i+1))

**(Lex-Char-BadEscape)**
FirstBadEscape(T, i) = p    c = Code(Lex-Char-BadEscape)
─────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, p, p+1))

**(Lex-Char-Invalid)**
CharLiteralInvalid(T, i)    c = Code(Lex-Char-Invalid)
────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, i, i+1))

**Literal Tokenization Helpers.**

StringTok(T, i) = { (StringLiteral, j) | StringLiteral(T, i) ⇓ j }
CharTok(T, i) = { (CharLiteral, j) | CharLiteral(T, i) ⇓ j }
IntTok(T, i) = { (IntLiteral, j) | IntLiteral(T, i) ⇓ j }
FloatTok(T, i) = { (FloatLiteral, j) | FloatLiteral(T, i) ⇓ j }

#### 3.2.7. Identifier and Keyword Lexing

T = S.scalars

**Identifier Scan.**
IdentScanEnd(T, i) = min{ j | j > i ∧ (¬ IdentContinue(T[j]) ∨ j = |T|) ∧ ∀ k ∈ (i, j). IdentContinue(T[k]) }

**(Lex-Identifier)**
IdentStart(T[i])    j = IdentScanEnd(T, i)    s = Lexeme(T, i, j)
────────────────────────────────────────────────────────────────
Γ ⊢ Ident(T, i) ⇓ (s, j)

**(Lex-Ident-InvalidUnicode)**
k = min{ p | i ≤ p < j ∧ NonCharacter(T[p]) }    c = Code(Lex-Ident-InvalidUnicode)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, SpanOfText(S, k, k+1))

**(Lex-Ident-Token)**
Γ ⊢ Ident(T, i) ⇓ (s, j)    Γ ⊢ ClassifyIdent(s) ⇓ k
──────────────────────────────────────────────────────────────
Γ ⊢ IdentToken(T, i) ⇓ (k, j)

**Keyword Classification.**
ClassifyIdent(s) =
 BoolLiteral  if s ∈ {"true", "false"}
 NullLiteral  if s = "null"
 Keyword(s)   if Keyword(s)
 Identifier   otherwise

#### 3.2.8. Operator and Punctuator Lexing

OpSet = OperatorSet
PuncSet = PunctuatorSet

OpMatch(T, i) = { (o, j) | o ∈ OpSet ∧ Lexeme(T, i, j) = o }
PuncMatch(T, i) = { (p, j) | p ∈ PuncSet ∧ Lexeme(T, i, j) = p }

OpTok(T, i) = { (Operator(o), j) | (o, j) ∈ OpMatch(T, i) }
PuncTok(T, i) = { (Punctuator(p), j) | (p, j) ∈ PuncMatch(T, i) }

#### 3.2.9. Maximal-Munch Rule

T = S.scalars

IsQuote(c) ⇔ c ∈ {"\"", "'"}
Candidates(T, i) =
 StringTok(T, i) ∪ CharTok(T, i)  if IsQuote(T[i])
 FloatTok(T, i) ∪ IntTok(T, i)    if DecDigit(T[i])
 IdentToken(T, i)                 if IdentStart(T[i])
 OpTok(T, i) ∪ PuncTok(T, i)       if OpTok(T, i) ≠ ∅ ∨ PuncTok(T, i) ≠ ∅
 ∅                                otherwise

Longest(C) = { (k, j) ∈ C | ∀ (k', j') ∈ C, j ≥ j' }

KindPriority(IntLiteral) = 3
KindPriority(FloatLiteral) = 3
KindPriority(StringLiteral) = 3
KindPriority(CharLiteral) = 3
KindPriority(BoolLiteral) = 3
KindPriority(NullLiteral) = 3
KindPriority(Identifier) = 2
KindPriority(Keyword(_)) = 2
KindPriority(Operator(_)) = 1
KindPriority(Punctuator(_)) = 0

PickLongest(C) = argmax_{(k, j) ∈ C} ⟨j, KindPriority(k)⟩

**(Max-Munch)**
PickLongest(C) = (k, j)
──────────────────────────────
Γ ⊢ NextToken(T, i) ⇓ (k, j)

**(Max-Munch-Err)**
Candidates(T, i) = ∅    c = Code(Max-Munch-Err)
────────────────────────────────────────────────
Γ ⊢ NextToken(T, i) ⇑ c

SpanOfErr(Max-Munch-Err, S, i) = SpanOfText(S, i, i+1)

GenericCloseException = false

#### 3.2.10. Lexical Security

T = S.scalars
O = Utf8Offsets(T)

**Literal/Comment Ranges.**
LineCommentRange(T, i, j) ⇔ Γ ⊢ ScanLineComment(T, i) ⇓ j
BlockCommentRange(T, i, j) ⇔ T[i..i+2] = "/*" ∧ ⟨BlockScan(T, i, 0, i)⟩ →* ⟨BlockDone(j)⟩
StringRange(T, i, j) ⇔ Γ ⊢ StringLiteral(T, i) ⇓ j
CharRange(T, i, j) ⇔ Γ ⊢ CharLiteral(T, i) ⇓ j
InsideLiteralOrComment(i) ⇔ ∃ a, b. a ≤ i < b ∧ (LineCommentRange(T, a, b) ∨ BlockCommentRange(T, a, b) ∨ StringRange(T, a, b) ∨ CharRange(T, a, b))

**Sensitive Positions in a Span.**

SensitiveInSpan(T, i, j) = [ p | i ≤ p < j ∧ Sensitive(T[p]) ]

**Unsafe Spans (Token-Only).**

IsLBrace(t) ⇔ t.kind = Punctuator("{")
IsRBrace(t) ⇔ t.kind = Punctuator("}")

NextNonNewline(K, i) = ⊥ ⇔ { j | j ≥ i ∧ K[j].kind ≠ Newline } = ∅
NextNonNewline(K, i) = j ⇔ j = min{ j | j ≥ i ∧ K[j].kind ≠ Newline }

MatchBrace(K, j) = min{ k | k > j ∧ Balance(j, k) = 0 ∧ ∀ m ∈ (j, k), Balance(j, m) > 0 }

Balance(K, j, m) = |{ x | j ≤ x ≤ m ∧ IsLBrace(K[x]) }| - |{ x | j ≤ x ≤ m ∧ IsRBrace(K[x]) }|
MatchBrace(K, j) = ⊥ ⇔ { k | k > j ∧ Balance(K, j, k) = 0 ∧ ∀ m ∈ (j, k). Balance(K, j, m) > 0 } = ∅

SpanFrom(t_a, t_b) = ⟨t_a.span.file, t_a.span.start_offset, t_b.span.end_offset, t_a.span.start_line, t_a.span.start_col, t_b.span.end_line, t_b.span.end_col⟩

UnsafeSpans(K) = { SpanFrom(K[j], K[k]) | K[i].kind = Keyword("unsafe"), j = NextNonNewline(K, i+1), K[j].kind = Punctuator("{"), k = MatchBrace(K, j), k ≠ ⊥ }

UnsafeAtByte(b) ⇔ ∃ sp ∈ UnsafeSpans(K). b ∈ SpanRange(sp)

UnsafeSpanMode = TokenOnly

**Lexical Security Check.**
Sens = [ p | Sensitive(T[p]) ∧ ¬ InsideLiteralOrComment(p) ]

**(LexSecure-Err)**
i = min{ p | p ∈ Sens ∧ ¬ UnsafeAtByte(ByteOf(T, p)) }    c = Code(LexSecure-Err)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LexSecure(S, K, Sens) ⇑ c

**(LexSecure-Warn)**
∀ p ∈ Sens, UnsafeAtByte(ByteOf(T, p))    Γ ⊢ EmitList(LexSecureWarns(S, Sens))
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LexSecure(S, K, Sens) ⇓ ok

LexSecureWarns(S, Sens) = [ ⟨W-SRC-0308, SpanOfText(S, p, p+1)⟩ | p ∈ Sens ]
LexSecureErrSpan(S, i) = SpanOfText(S, i, i+1)

#### 3.2.11. Tokenization (Small-Step)

LexState = {LexStart(S), LexScan(S, i, K, D, Sens), LexDone(K, D, Sens), LexError(code)}
T = S.scalars
|T| = len(T)

**(Lex-Start)**
────────────────────────────────────────────
⟨LexStart(S)⟩ → ⟨LexScan(S, 0, [], [], [])⟩

**(Lex-End)**
i ≥ |T|
──────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexDone(K, D, Sens)⟩

**(Lex-Whitespace)**
Whitespace(T[i])
───────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, i+1, K, D, Sens)⟩

**(Lex-Newline)**
T[i] = LF
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, i+1, K ++ [⟨newline, Lexeme(T, i, i+1), SpanOfText(S, i, i+1)⟩], D, Sens)⟩

**(Lex-Line-Comment)**
T[i..i+2] = "//"    T[i..i+3] ∉ {"///", "//!"}    Γ ⊢ ScanLineComment(T, i) ⇓ j
──────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K, D, Sens)⟩

**(Lex-Doc-Comment)**
T[i..i+3] ∈ {"///", "//!"}    Γ ⊢ ScanLineComment(T, i) ⇓ j    Γ ⊢ DocComment(T, i) ⇓ d
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K, D ++ [d], Sens)⟩

**(Lex-Block-Comment)**
T[i..i+2] = "/*"    ⟨BlockScan(T, i, 0, i)⟩ →* ⟨BlockDone(j)⟩
──────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K, D, Sens)⟩

**(Lex-String-Unterminated-Recover)**
T[i] = "\""    LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-String-Unterminated)    Γ ⊢ Emit(c, SpanOfText(S, i, i+1))    j = StringTerminator(T, i)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K, D, Sens)⟩

**(Lex-Char-Unterminated-Recover)**
T[i] = "'"    LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-Char-Unterminated)    Γ ⊢ Emit(c, SpanOfText(S, i, i+1))    j = CharTerminator(T, i)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K, D, Sens)⟩

**(Lex-Sensitive)**
Sensitive(T[i])
────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, i+1, K, D, Sens ++ [i])⟩

SensitiveTok(T, i, j, k) =
 []                    if k ∈ {StringLiteral, CharLiteral}
 SensitiveInSpan(T, i, j)  otherwise

**(Lex-Token)**
¬ Whitespace(T[i])    T[i] ≠ LF    T[i..i+2] ∉ {"//", "/*"}    ¬ Sensitive(T[i])    Γ ⊢ NextToken(T, i) ⇓ (k, j)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexScan(S, j, K ++ [⟨k, Lexeme(T, i, j), SpanOfText(S, i, j)⟩], D, Sens ++ SensitiveTok(T, i, j, k))⟩

**(Lex-Token-Err)**
¬ Whitespace(T[i])    T[i] ≠ LF    T[i..i+2] ∉ {"//", "/*"}    ¬ (T[i] = "\"" ∧ LineFeedOrEOFBeforeClose(T, i))    ¬ (T[i] = "'" ∧ LineFeedOrEOFBeforeClose(T, i))    ¬ Sensitive(T[i])    Γ ⊢ NextToken(T, i) ⇑ c
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨LexScan(S, i, K, D, Sens)⟩ → ⟨LexError(c)⟩

#### 3.2.12. Tokenize (Big-Step)

**(Tokenize-Ok)**
⟨LexStart(S)⟩ →* ⟨LexDone(K, D, Sens)⟩    Γ ⊢ LexSecure(S, K, Sens) ⇓ ok
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ Tokenize(S) ⇓ (K, D)

**(Tokenize-Secure-Err)**
⟨LexStart(S)⟩ →* ⟨LexDone(K, D, Sens)⟩    Γ ⊢ LexSecure(S, K, Sens) ⇑ c
─────────────────────────────────────────────────────────────────────────────
Γ ⊢ Tokenize(S) ⇑ c

**(Tokenize-Err)**
⟨LexStart(S)⟩ →* ⟨LexError(c)⟩
────────────────────────────────────
Γ ⊢ Tokenize(S) ⇑ c

Phase1LexDiagRefs = {"8.4", "8.5", "8.8"}

### 3.3. Grammar, Parsing, and AST Construction

#### 3.3.1. Inputs, Outputs, and Invariants

**Inputs.**
ParseInputs(U, K, D, K') ⇔ U = [S_1, …, S_n] ∧ K = [K_1, …, K_n] ∧ D = [D_1, …, D_n] ∧ (∀ i. Γ ⊢ Tokenize(S_i) ⇓ (K_i, D_i)) ∧ K' = [Filter(K_i) | 1 ≤ i ≤ n]
ParseUnitSources(U) ⇔ ∃ d, f_1, …, f_n, B_1, …, B_n. CompilationUnit(d) = [f_1, …, f_n] ∧ U = [S_1, …, S_n] ∧ ∧_{i=1}^n (Γ ⊢ ReadBytes(f_i) ⇓ B_i ∧ Γ ⊢ LoadSource(f_i, B_i) ⇓ S_i)

**Outputs.**
ParseOutputs(U, F) ⇔ Γ ⊢ ParseUnit(U) ⇓ F
F = [F_1, …, F_n]

ModuleAggregationRef = {"3.4.1", "3.4.2"}

**Parsing Phase Invariants.**

**(Phase1-Complete)**
∀ i, Γ ⊢ ParseFile(S_i) ⇓ F_i
────────────────────────────────────────
Γ ⊢ ParseUnit(U) ⇓ [F_1, …, F_n]

PhaseExec(Phase1, U) ⇔ Γ ⊢ ParseUnit(U) ⇓ F
∀ p ∈ {Phase2, Phase3, Phase4}. PhaseExec(p, U) ⇒ PhaseExec(Phase1, U)

**(Phase1-Declarations)**
Γ ⊢ ParseUnit(U) ⇓ [F_1, …, F_n]    ∀ i, F_i.items = I_i
──────────────────────────────────────────────────────────────
Γ ⊢ AllDecls(U) = I_1 ++ … ++ I_n

**(Phase1-Forward-Refs)**
──────────────────────────────────────────────────────────────
Γ ⊢ ParsePhase(U) ⇓ NoResolutionConstraints

#### 3.3.2. AST Node Catalog (Cursive0 Subset)

ASTNode = ASTItem ∪ ASTExpr ∪ ASTPattern ∪ ASTType ∪ ASTStmt
SpanOfNode : ASTNode → Span
DocOf : ASTNode → (DocList ∪ {⊥})

SpanDefault(P, P') = SpanBetween(P, P')
DocDefault = []
DocOptDefault = ⊥
FillSpan(n, P, P') =
 n[span := SpanDefault(P, P')]  if SpanMissing(n)
 n                             otherwise
FillDoc(n) =
 n[doc := DocDefault]  if DocMissing(n)
 n                     otherwise
FillDocOpt(n) =
 n[doc_opt := DocOptDefault]  if DocOptMissing(n)
 n                            otherwise
ParseCtor(n, P, P') = FillDocOpt(FillDoc(FillSpan(n, P, P')))
DocAssociationRef = {"3.3.11"}

**Doc Lists.**

DocList = [DocComment]
DocCommentRef = {"3.2.1"}

**Paths.**

Path = [identifier]
ModulePath = Path
TypePath = Path
ClassPath = Path
PathString(p) = StringOfPath(p)
StringOfPathRef = {"3.4.1"}

##### 3.3.2.1. Module and Files

**ASTModule.**

ASTModule = ⟨path, items, module_doc⟩
ASTModule.path ∈ Path
ASTModule.items ∈ [ASTItem]
ASTModule.module_doc ∈ DocList

**ASTFile.**

ASTFile = ⟨path, items, module_doc⟩
ASTFile.path ∈ Path
ASTFile.items ∈ [ASTItem]
ASTFile.module_doc ∈ DocList

##### 3.3.2.2. Items

ASTItem ∈ {UsingDecl, StaticDecl, ProcedureDecl, RecordDecl, EnumDecl, ModalDecl, ClassDecl, TypeAliasDecl, ErrorItem}

**UsingDecl.**

UsingDecl = ⟨vis, clause, span, doc⟩

**UsingClause.**

UsingClause ∈ {UsingPath = ⟨path, alias_opt⟩, UsingList = ⟨module_path, specs⟩}

UsingSpec = ⟨name, alias_opt⟩

**StaticDecl.**

StaticDecl = ⟨vis, mut, binding, span, doc⟩

mut ∈ {`let`, `var`}

**ProcedureDecl.**

ProcedureDecl = ⟨vis, name, params, return_type_opt, body, span, doc⟩

**RecordDecl.**

RecordDecl = ⟨vis, name, implements, members, span, doc⟩

RecordDecl.implements ∈ [ClassPath]

RecordMember ∈ {FieldDecl = ⟨vis, name, type, init_opt, span, doc_opt⟩, MethodDecl = ⟨vis, override, name, receiver, params, return_type_opt, body, span, doc_opt⟩}
Receiver ∈ {ReceiverShorthand(perm), ReceiverExplicit(mode_opt, type)}
perm ∈ {`const`, `unique`, `shared`}
mode_opt ∈ {`move`, ⊥}

**EnumDecl.**

EnumDecl = ⟨vis, name, implements, variants, span, doc⟩

EnumDecl.implements ∈ [ClassPath]

VariantDecl = ⟨name, payload_opt, discriminant_opt, span, doc_opt⟩

VariantPayload ∈ {TuplePayload = [Type], RecordPayload = [FieldDecl]}
∀ f ∈ RecordPayload. f.init_opt = ⊥

**ModalDecl.**

ModalDecl = ⟨vis, name, implements, states, span, doc⟩

ModalDecl.implements ∈ [ClassPath]

StateBlock = ⟨name, members, span, doc_opt⟩

StateMember ∈ {StateFieldDecl = ⟨vis, name, type, span, doc_opt⟩, StateMethodDecl = ⟨vis, name, params, return_type_opt, body, span, doc_opt⟩, TransitionDecl = ⟨vis, name, params, target_state, body, span, doc_opt⟩}

**ClassDecl.**

ClassDecl = ⟨vis, name, supers, items, span, doc⟩

ClassDecl.supers ∈ [ClassPath]

ClassItem ∈ {ClassFieldDecl = ⟨vis, name, type, span, doc_opt⟩, ClassMethodDecl = ⟨vis, name, receiver, params, return_type_opt, body_opt, span, doc_opt⟩}
AbstractClassMethod(m) ⇔ ∃ vis, name, recv, params, ret, span, doc. m = ClassMethodDecl(vis, name, recv, params, ret, ⊥, span, doc)
ConcreteClassMethod(m) ⇔ ∃ vis, name, recv, params, ret, body, span, doc. m = ClassMethodDecl(vis, name, recv, params, ret, body, span, doc) ∧ body ≠ ⊥

**TypeAliasDecl.**

TypeAliasDecl = ⟨vis, name, type, span, doc⟩
AliasBodyRef = {"6.1.4"}
AliasStep(TypePath(p)) = AliasBody(p) if defined; otherwise TypePath(p)
AliasStep(T) = T if T ∉ {TypePath(p)}
AliasNorm(T) =
 TypePerm(perm, AliasNorm(base))  if T = TypePerm(perm, base)
 TypeTuple([AliasNorm(t) | t ∈ elems])  if T = TypeTuple(elems)
 TypeArray(AliasNorm(elem), size_expr)  if T = TypeArray(elem, size_expr)
 TypeSlice(AliasNorm(elem))  if T = TypeSlice(elem)
 TypeUnion([AliasNorm(t) | t ∈ members])  if T = TypeUnion(members)
 TypeFunc([⟨m, AliasNorm(t)⟩ | ⟨m, t⟩ ∈ params], AliasNorm(ret))  if T = TypeFunc(params, ret)
 TypeDynamic(AliasPath(path))  if T = TypeDynamic(path)
 TypeModalState(AliasPath(path), state)  if T = TypeModalState(path, state)
 TypePtr(AliasNorm(elem), ptr_state_opt)  if T = TypePtr(elem, ptr_state_opt)
 TypeRawPtr(qual, AliasNorm(elem))  if T = TypeRawPtr(qual, elem)
 AliasNorm(AliasStep(T))  if T = TypePath(p)
 T  otherwise
AliasPath(p) = p if AliasBody(p) undefined
AliasPath(p) = AliasPath(p') if AliasBody(p) = TypePath(p')
AliasTransparent(T, U) ⇔ AliasNorm(T) = AliasNorm(U)
AliasGraph = { ⟨p, q⟩ | AliasBody(p) = T ∧ q ∈ TypePaths(T) }
TypePaths(TypePrim(_)) = ∅
TypePaths(TypeRange) = ∅
TypePaths(TypePerm(_, T)) = TypePaths(T)
TypePaths(TypeTuple([T_1, …, T_n])) = ⋃_{i=1}^n TypePaths(T_i)
TypePaths(TypeArray(T, _)) = TypePaths(T)
TypePaths(TypeSlice(T)) = TypePaths(T)
TypePaths(TypeUnion([T_1, …, T_n])) = ⋃_{i=1}^n TypePaths(T_i)
TypePaths(TypeFunc([⟨_, T_1⟩, …, ⟨_, T_n⟩], R)) = (⋃_{i=1}^n TypePaths(T_i)) ∪ TypePaths(R)
TypePaths(TypePtr(T, _)) = TypePaths(T)
TypePaths(TypeRawPtr(_, T)) = TypePaths(T)
TypePaths(TypeString(_)) = ∅
TypePaths(TypeBytes(_)) = ∅
TypePaths(TypeDynamic(p)) = {p}
TypePaths(TypeModalState(p, _)) = {p}
TypePaths(TypePath(p)) = {p}
AliasCycle(p) ⇔ p ∈ Reach^+(AliasGraph, p)
**(TypeAlias-Recursive-Err)**
AliasCycle(p)    c = Code(TypeAlias-Recursive-Err)
────────────────────────────────────────────────────
Γ ⊢ p : TypeAliasOk ⇑ c
**(TypeAlias-Ok)**
¬ AliasCycle(p)
────────────────────────
Γ ⊢ p : TypeAliasOk

**ErrorItem.**

ErrorItem = ⟨span⟩
IsDecl(ErrorItem(_)) = false

##### 3.3.2.3. Types

**Type.**
Type = {TypePerm(perm, base), TypePrim(name), TypeTuple(elems), TypeArray(elem, size_expr), TypeSlice(elem), TypeUnion(members), TypeFunc(params, ret), TypePath(path), TypeDynamic(path), TypeString(string_state_opt), TypeBytes(bytes_state_opt), TypeModalState(path, state), TypePtr(elem, ptr_state_opt), TypeRawPtr(qual, elem), TypeRange}

Perm = {`const`, `unique`, `shared`}
Qual = {`imm`, `mut`}
PtrStateOpt = {⊥, `Valid`, `Null`, `Expired`}
StringStateOpt = {⊥, `@Managed`, `@View`}
BytesStateOpt = {⊥, `@Managed`, `@View`}
Name ∈ PrimTypes_C0

ParamMode = {`move`, ⊥}
ParamType = ⟨mode, type⟩ where mode ∈ ParamMode ∧ type ∈ Type

TypeRangeSyntax = ⊥

**Range Record.**
RangeFieldType(`kind`) = `u8`
RangeFieldType(`lo`) = `usize`
RangeFieldType(`hi`) = `usize`

##### 3.3.2.4. Expressions

**Literal Tokens.**
LiteralKind = {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
LiteralToken = { t ∈ Token | t.kind ∈ LiteralKind }

**Expr.**
RangeKind = {`To`, `ToInclusive`, `Full`, `From`, `Exclusive`, `Inclusive`}
Expr = {Literal(lit), PtrNullExpr, Identifier(name), QualifiedName(path, name), QualifiedApply(path, name, form), Path(path, name), ErrorExpr(span), TupleExpr(elems), ArrayExpr(elems), RecordExpr(type_ref, fields), EnumLiteral(path, payload_opt), FieldAccess(base, name), TupleAccess(base, index), IndexAccess(base, index_expr), Call(callee, args), MethodCall(base, name, args), Unary(op, expr), Binary(op, left, right), Cast(expr, type), Range(kind, lo_opt, hi_opt), IfExpr(cond, then_block, else_opt), MatchExpr(scrutinee, arms), LoopInfinite(body), LoopConditional(cond, body), LoopIter(pattern, type_opt, iter, body), BlockExpr(stmts, tail_opt), UnsafeBlockExpr(body), MoveExpr(place), TransmuteExpr(src_type, dst_type, expr), AllocExpr(region_opt, expr), Propagate(expr), AddressOf(place), Deref(expr)}
ExprSpan : Expr → Span

TypeRef = {TypePath(path), ModalStateRef(path, state)}

**Qualified Expressions.**
ParenForm = {Paren(args) | args ∈ Arg*}
BraceForm = {Brace(fields) | fields ∈ FieldInit*}
QualForm = ParenForm ∪ BraceForm
∀ P, P', e. (Γ ⊢ ParseExpr(P) ⇓ (P', e)) ⇒ e ∉ {Path(_, _), EnumLiteral(_, _)}

**Argument.**
Arg = ⟨moved, expr, span⟩ where moved ∈ {true, false}

MovedArg(moved, e) =
 MoveExpr(e)  if moved = true ∧ IsPlace(e)
 e            otherwise

**Field Initializer.**
FieldInit = ⟨name, expr⟩

##### 3.3.2.5. Patterns

Pattern = {LiteralPattern(lit), WildcardPattern, IdentifierPattern(name), TypedPattern(name, type), TuplePattern(elems), RecordPattern(type_path, fields), EnumPattern(type_path, name, payload_opt), ModalPattern(state_name, fields_opt), RangePattern(kind, lo, hi)}
PatternSpan : Pattern → Span

FieldPattern = ⟨name, pattern_opt, span⟩

EnumPayloadPattern = {TuplePayloadPattern([Pattern]), RecordPayloadPattern([FieldPattern])}

ModalPayloadPattern = {ModalRecordPayload([FieldPattern])}

##### 3.3.2.6. Statements

Stmt = {LetStmt(binding), VarStmt(binding), ErrorStmt(span), ShadowLetStmt(name, type_opt, init), ShadowVarStmt(name, type_opt, init), AssignStmt(place, expr), CompoundAssignStmt(place, op, expr), ExprStmt(expr), DeferStmt(block), RegionStmt(opts_opt, alias_opt, block), FrameStmt(target_opt, block), ReturnStmt(expr_opt), ResultStmt(expr), BreakStmt(expr_opt), ContinueStmt, UnsafeBlockStmt(block)}

binding = ⟨pattern, type_opt, op, init, span⟩
opts_opt ∈ {⊥} ∪ Expr    alias_opt ∈ {⊥} ∪ Identifier
target_opt ∈ {⊥} ∪ Identifier

##### 3.3.2.7. Unsupported Grammar Families (Cursive0 Decision)

UnsupportedGrammarFamily = {`attributes`, `extern_ffi`, `generics`, `contracts`, `keys`, `concurrency`, `async`, `metaprogramming`}
UnsupportedGrammarFamily ⊆ UnsupportedForm

#### 3.3.3. Parser State and Judgments

**Parser State.**

PState = ⟨K, i, D, j, d, Δ⟩

TokStream(P) = K
TokIndex(P) = i
DocStream(P) = D
DocIndex(P) = j
Depth(P) = d
DiagStream(P) = Δ

**Helper Functions.**

Tok(P) =
 K[i]                        if i < |K|
 ⟨EOF, ε, EOFSpan(K)⟩         if i = |K|

SourceOf(K) = S ⇔ Γ ⊢ Tokenize(S) ⇓ (K_raw, D) ∧ K = Filter(K_raw)
EOFSpan(K) = EOFSpan(SourceOf(K))

Advance(P) = ⟨K, i+1, D, j, d, Δ⟩
Clone(P) = ⟨K, i, D, j, d, []⟩
MergeDiag(P_b, P_d, P_s) = ⟨TokStream(P_s), TokIndex(P_s), DocStream(P_s), DocIndex(P_s), Depth(P_s), DiagStream(P_b) ++ DiagStream(P_d)⟩

**Parser Index Invariant.**
PStateOk(P) ⇔ 0 ≤ i ≤ |K|

AdvanceOrEOF(P) =
 Advance(P)  if i < |K|
 P           if i = |K|

LastConsumed(P, P') =
 K[i'-1]  if i' > i
 Tok(P)   if i' = i
SpanBetween(P, P') = SpanFrom(Tok(P), LastConsumed(P, P'))

SplitSpan2(sp) = (sp_L, sp_R) where
 sp_L.file = sp.file ∧ sp_R.file = sp.file
 sp_L.start_offset = sp.start_offset ∧ sp_L.end_offset = sp.start_offset + 1
 sp_R.start_offset = sp.start_offset + 1 ∧ sp_R.end_offset = sp.start_offset + 2
 sp_L.start_line = sp.start_line ∧ sp_L.end_line = sp.start_line
 sp_R.start_line = sp.start_line ∧ sp_R.end_line = sp.start_line
 sp_L.start_col = sp.start_col ∧ sp_L.end_col = sp.start_col + 1
 sp_R.start_col = sp.start_col + 1 ∧ sp_R.end_col = sp.start_col + 2

SplitShiftR(P) = ⟨K', i, D, j, d, Δ⟩
where Tok(P) = ⟨Operator(">>"), ">>", sp⟩ ∧ (sp_L, sp_R) = SplitSpan2(sp)
K' = K[0..i) ++ [⟨Operator(">"), ">", sp_L⟩, ⟨Operator(">"), ">", sp_R⟩] ++ K[i+1..]

**Judgments (Big-Step).**
ParseJudgment = {ParseFile, ParseModule, ParseItem, ParseStmt, ParseExpr, ParsePattern, ParseType}

#### 3.3.4. Grammar Subset and Cursive0 Lexeme Policy

**Lexeme Predicates.**
IsIdent(t) ⇔ t.kind = Identifier
IsKw(t, s) ⇔ t.kind = Keyword(s)
IsOp(t, s) ⇔ t.kind = Operator(s)
IsPunc(t, s) ⇔ t.kind = Punctuator(s)
Lexeme(t) = t.lexeme

**Contextual Keywords.**
CtxKeyword = {"in"}
Ctx(t, s) ⇔ IsIdent(t) ∧ Lexeme(t) = s ∧ s ∈ CtxKeyword
¬ Ctx(t, "as") ∧ ¬ Ctx(t, "move")

**Cursive0 Declaration Keywords.**
UsingKeyword = "using"
Keyword("use") = false

**Union Propagation.**
UnionPropTok(t) ⇔ IsOp(t, "?")
UnionPropForm(e) ⇔ ∃ e_0. e = Propagate(e_0)

**Cursive0 Type Restrictions.**
TypeWhereTok(t) ⇔ IsIdent(t) ∧ Lexeme(t) = "where"
OpaqueTypeTok(t) ⇔ IsIdent(t) ∧ Lexeme(t) = "opaque"
TypeArgsUnsupported(P) ⇔ Γ ⊢ ParseTypePath(P) ⇓ (P_1, path) ∧ IsOp(Tok(P_1), "<") ∧ path ≠ [`Ptr`]
C0TypeRestricted(P) ⇔ TypeArgsUnsupported(P) ∨ TypeWhereTok(Tok(P)) ∨ OpaqueTypeTok(Tok(P))

**Syntax (Cursive0 Subset).**

```ebnf
module            ::= item*
item              ::= using_decl | static_decl | procedure_decl | record_decl | enum_decl | modal_decl | class_decl | type_alias_decl
using_decl         ::= visibility? "using" using_clause
using_clause       ::= using_path ("as" identifier)? | using_list
path               ::= identifier ("::" identifier)*
module_path        ::= path
using_path         ::= path
type_path          ::= path
using_list         ::= module_path "{" using_specifier ("," using_specifier)* "}"
using_specifier    ::= identifier ("as" identifier)?

static_decl        ::= visibility? ("let" | "var") binding_decl
binding_decl       ::= pattern (":" type)? binding_op expression
procedure_decl     ::= visibility? "procedure" identifier signature block_expr
signature          ::= "(" param_list? ")" ("->" type)?
param_list         ::= param ("," param)*
param              ::= param_mode? identifier ":" type
param_mode         ::= "move"
record_decl        ::= visibility? "record" identifier implements_clause? "{" record_body? "}"
enum_decl          ::= visibility? "enum" identifier implements_clause? "{" variant_list? "}"
modal_decl         ::= visibility? "modal" identifier implements_clause? "{" state_block+ "}"
class_decl         ::= visibility? "class" identifier ("<:" superclass_bounds)? "{" class_body? "}"
type_alias_decl    ::= visibility? "type" identifier "=" type

record_body        ::= record_member ("," record_member)*
record_member      ::= record_field_decl | method_def
method_def         ::= visibility? "override"? "procedure" identifier "(" receiver ("," param_list)? ")" ("->" type)? block_expr
receiver           ::= receiver_shorthand | explicit_receiver
receiver_shorthand ::= "~" | "~!"
explicit_receiver  ::= param_mode? "self" ":" type

implements_clause  ::= "<:" class_list
class_list         ::= class_path ("," class_path)*
class_path         ::= type_path

state_block        ::= "@" state_name "{" state_member* "}"
state_name         ::= identifier
state_member       ::= state_field_decl | state_method_def | transition_def
state_field_decl   ::= visibility? identifier ":" type
state_method_def   ::= visibility? "procedure" identifier "(" param_list ")" ("->" type)? block_expr
transition_def     ::= visibility? "transition" identifier "(" param_list ")" "->" "@" target_state block_expr
target_state       ::= identifier

superclass_bounds  ::= class_path ("+" class_path)*
class_body         ::= class_item*
class_item         ::= class_method_decl | class_field_decl
class_method_decl  ::= visibility? "procedure" identifier "(" receiver ("," param_list)? ")" ("->" type)? class_method_body
class_method_body  ::= block_expr | terminator
class_field_decl   ::= visibility? identifier ":" type terminator

visibility         ::= "public" | "internal" | "private" | "protected"

record_field_decl_list ::= record_field_decl ("," record_field_decl)*
record_field_decl  ::= visibility? identifier ":" type record_field_init_opt?
record_field_init_opt ::= "=" expression
field_decl_list    ::= field_decl ("," field_decl)*
field_decl         ::= visibility? identifier ":" type
variant_list       ::= variant ("," variant)*
variant            ::= identifier variant_payload? ("=" integer_literal)?
variant_payload    ::= "(" type_list? ")" | "{" field_decl_list? "}"
type_list          ::= type ("," type)*

statement          ::= binding_stmt | shadow_binding | assignment_stmt | expr_stmt | defer_stmt | region_stmt | frame_stmt | return_stmt | result_stmt | break_stmt | continue_stmt | unsafe_block
binding_stmt       ::= ("let" | "var") pattern (":" type)? binding_op expression terminator
shadow_binding     ::= "shadow" ("let" | "var") identifier (":" type)? "=" expression terminator
assignment_stmt    ::= place_expr "=" expression terminator
compound_assign    ::= place_expr compound_op expression terminator
expr_stmt          ::= expression terminator
defer_stmt         ::= "defer" block_expr
region_stmt        ::= "region" region_opts? region_alias? block_expr
region_opts        ::= "(" expression ")"
region_alias       ::= "as" identifier
frame_stmt         ::= "frame" block_expr | identifier "." "frame" block_expr
return_stmt        ::= "return" expression? terminator?
result_stmt        ::= "result" expression terminator?
break_stmt         ::= "break" expression? terminator?
continue_stmt      ::= "continue" terminator?
unsafe_block       ::= "unsafe" block_expr

binding_op         ::= "=" | ":="
compound_op        ::= "+=" | "-=" | "*=" | "/=" | "%="
terminator         ::= ";" | newline
newline            ::= "\n"

expression         ::= range_expression | logical_or_expr
range_expression   ::= exclusive_range | inclusive_range | from_range | to_range | to_inclusive_range | full_range
exclusive_range    ::= logical_or_expr ".." logical_or_expr
inclusive_range    ::= logical_or_expr "..=" logical_or_expr
from_range         ::= logical_or_expr ".."
to_range           ::= ".." logical_or_expr
to_inclusive_range ::= "..=" logical_or_expr
full_range         ::= ".."
logical_or_expr    ::= logical_and_expr ("||" logical_and_expr)*
logical_and_expr   ::= comparison_expr ("&&" comparison_expr)*
comparison_expr    ::= bitwise_or_expr (("==" | "!=" | "<" | "<=" | ">" | ">=") bitwise_or_expr)*
bitwise_or_expr    ::= bitwise_xor_expr ("|" bitwise_xor_expr)*
bitwise_xor_expr   ::= bitwise_and_expr ("^" bitwise_and_expr)*
bitwise_and_expr   ::= shift_expr ("&" shift_expr)*
shift_expr         ::= additive_expr (("<<" | ">>") additive_expr)*
additive_expr      ::= multiplicative_expr (("+" | "-") multiplicative_expr)*
multiplicative_expr ::= power_expr (("*" | "/" | "%") power_expr)*
power_expr         ::= cast_expr ("**" power_expr)?
cast_expr          ::= unary_expr ("as" type)?

unary_expr          ::= unary_operator unary_expr | address_of_expr | move_expr | postfix_expr
unary_operator      ::= "!" | "-" | "*" | "widen"
address_of_expr     ::= "&" place_expr
move_expr           ::= "move" place_expr

postfix_expr        ::= primary_expr postfix_suffix*
postfix_suffix      ::= "." identifier | "." decimal_literal | "[" expression "]" | "~>" identifier "(" argument_list? ")" | "(" argument_list? ")" | "?"

primary_expr        ::= literal | null_ptr_expr | identifier_expr | qualified_expr | tuple_literal | array_literal | record_literal | if_expr | match_expr | loop_expr | block_expr | unsafe_expr | transmute_expr
                   | alloc_expr
unsafe_expr         ::= "unsafe" block_expr
transmute_expr      ::= "transmute" "::" "<" type "," type ">" "(" expression ")"
identifier_expr     ::= identifier
qualified_expr      ::= type_path "::" identifier qualified_suffix?
qualified_suffix    ::= "(" argument_list? ")" | "{" field_init_list "}"
null_ptr_expr       ::= "Ptr" "::" "null" "(" ")"
alloc_expr          ::= "^" expression

parenthesized_expr  ::= "(" expression ")"

tuple_literal       ::= "(" tuple_expr_elements? ")"
tuple_expr_elements ::= expression ";" | expression ("," expression)+
array_literal       ::= "[" expression_list "]"
expression_list     ::= expression ("," expression)*
record_literal      ::= (type_path | state_specific_type) "{" field_init_list "}"
field_init_list     ::= field_init ("," field_init)*
field_init          ::= identifier ":" expression | identifier


argument_list       ::= argument ("," argument)*
argument            ::= "move"? expression

if_expr             ::= "if" expression block_expr ("else" (block_expr | if_expr))?
match_expr          ::= "match" expression "{" match_arm ("," match_arm)* "}"
match_arm           ::= pattern ("if" expression)? "=>" arm_body
arm_body            ::= expression | block_expr

loop_expr           ::= "loop" block_expr | "loop" expression block_expr | "loop" pattern (":" type)? "in" expression block_expr

block_expr          ::= "{" statement* expression? "}"

place_expr          ::= "*" place_expr | postfix_expr

pattern             ::= literal_pattern | wildcard_pattern | identifier_pattern | typed_pattern | tuple_pattern | record_pattern | enum_pattern | modal_pattern | range_pattern
literal_pattern     ::= literal
wildcard_pattern    ::= "_"
identifier_pattern  ::= identifier
typed_pattern       ::= identifier ":" type

tuple_pattern       ::= "(" tuple_pattern_elements? ")"
tuple_pattern_elements ::= pattern ";" | pattern ("," pattern)+
record_pattern      ::= type_path "{" field_pattern_list? "}"
field_pattern_list  ::= field_pattern ("," field_pattern)*
field_pattern       ::= identifier (":" pattern)?

enum_pattern        ::= type_path "::" identifier enum_payload_pattern?
enum_payload_pattern ::= "(" tuple_pattern_elements? ")" | "{" field_pattern_list? "}"

modal_pattern       ::= "@" identifier ("{" field_pattern_list? "}")?

range_pattern       ::= pattern (".." | "..=") pattern

type                ::= permission? non_permission_type
permission          ::= "const" | "unique" | "shared"
non_permission_type ::= union_type | non_union_type
union_type          ::= non_union_type ("|" non_union_type)+
non_union_type      ::= primitive_type | tuple_type | function_type | array_type | slice_type | safe_pointer_type | raw_pointer_type | string_type | bytes_type | dynamic_type | state_specific_type | type_path

primitive_type      ::= integer_type | float_type | bool_type | char_type | unit_type | never_type
integer_type        ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"
float_type          ::= "f16" | "f32" | "f64"
bool_type           ::= "bool"
char_type           ::= "char"
unit_type           ::= "(" ")"
never_type          ::= "!"

tuple_type          ::= "(" tuple_type_elements? ")"
tuple_type_elements ::= type ";" | type ("," type)+
function_type       ::= "(" param_type_list? ")" "->" type
param_type_list     ::= param_type ("," param_type)*
param_type          ::= "move"? type
array_type          ::= "[" type ";" const_expression "]"
slice_type          ::= "[" type "]"

string_type         ::= "string" ("@" ("Managed" | "View"))?
bytes_type          ::= "bytes" ("@" ("Managed" | "View"))?

state_specific_type ::= type_path "@" state_name

safe_pointer_type   ::= "Ptr" "<" type ">" ("@" pointer_state)?
pointer_state       ::= "Valid" | "Null" | "Expired"
raw_pointer_type    ::= "*" ("imm" | "mut") type

dynamic_type        ::= "$" type_path

const_expression    ::= expression
```

**Method Context (Cursive0).**

RecordMembers(M) = { m | m occurs as RecordMember in M }
ClassItems(M) = { m | m occurs as ClassItem in M }
MethodDecls(M) = { m | m = MethodDecl(…) ∧ m occurs in M }
ClassMethodDecls(M) = { m | m = ClassMethodDecl(…) ∧ m occurs in M }
MethodContextOk(M) ⇔ MethodDecls(M) ⊆ RecordMembers(M) ∧ ClassMethodDecls(M) ⊆ ClassItems(M)

**(Method-Context-Err)**
¬ MethodContextOk(M)    c = Code(Method-Context-Err)
────────────────────────────────────────────────────
Γ ⊢ Emit(c)

#### 3.3.5. Token Consumption (Small-Step, Success-Only)

ConsumeState = {Consume(P, k), ConsumeDone(P)}
ParseRejectRules = ∅

**(Tok-Consume-Kind)**
Tok(P).kind = k
────────────────────────────────────────────────
⟨Consume(P, k)⟩ → ⟨ConsumeDone(Advance(P))⟩

**(Tok-Consume-Keyword)**
IsKw(Tok(P), s)
────────────────────────────────────────────────────────────
⟨Consume(P, Keyword(s))⟩ → ⟨ConsumeDone(Advance(P))⟩

**(Tok-Consume-Operator)**
IsOp(Tok(P), s)
────────────────────────────────────────────────────────────
⟨Consume(P, Operator(s))⟩ → ⟨ConsumeDone(Advance(P))⟩

**(Tok-Consume-Punct)**
IsPunc(Tok(P), s)
────────────────────────────────────────────────────────────
⟨Consume(P, Punctuator(s))⟩ → ⟨ConsumeDone(Advance(P))⟩

**List Parsing (Small-Step)**

ListState = {ListStart(P), ListScan(P, xs), ListDone(P, xs)}

**(List-Start)**
────────────────────────────────────────
⟨ListStart(P)⟩ → ⟨ListScan(P, [])⟩

**(List-Cons)**
Γ ⊢ ParseElem(P) ⇓ (P', x)
──────────────────────────────────────────────────────
⟨ListScan(P, xs)⟩ → ⟨ListScan(P', xs ++ [x])⟩

**(List-Done)**
Tok(P) ∈ EndSet
──────────────────────────────────────
⟨ListScan(P, xs)⟩ → ⟨ListDone(P, xs)⟩

EndSet ⊆ TokenKind
TrailingComma(P, EndSet) ⇔ IsPunc(Tok(P), ",") ∧ Tok(Advance(P)) ∈ EndSet

**(Trailing-Comma-Err)**
TrailingComma(P, EndSet)    c = Code(Unsupported-Construct)
─────────────────────────────────────────────────────────────
Γ ⊢ Emit(c, Tok(P).span)

#### 3.3.6. Module and Item Parsing

**ParseFile (Big-Step).**
Γ ⊢ Tokenize(S) ⇓ (K_raw, D)
K = Filter(K_raw)
P_0 = ⟨K, 0, D, 0, 0, []⟩

**(ParseFile-Ok)**
Γ ⊢ ParseItems(P_0) ⇓ (P_1, I, MDoc)
────────────────────────────────────────────────
Γ ⊢ ParseFile(S) ⇓ ⟨S.path, I, MDoc⟩

ParseModule ∈ RulesIn({"3.4.1", "3.4.2"})

**Item Sequence (Big-Step).**

**(ParseItems-Empty)**
Tok(P) = EOF
──────────────────────────────────────
Γ ⊢ ParseItems(P) ⇓ (P, [], [])

**(ParseItems-Cons)**
Tok(P) ≠ EOF    Γ ⊢ ParseItem(P) ⇓ (P_1, it)    Γ ⊢ ParseItems(P_1) ⇓ (P_2, I, M)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItems(P) ⇓ (P_2, [it] ++ I, M)

TopLevelItem ⊆ item

##### 3.3.6.1. Identifiers and Paths

**(Parse-Ident)**
IsIdent(Tok(P))
──────────────────────────────────────────────────────────────
Γ ⊢ ParseIdent(P) ⇓ (Advance(P), Lexeme(Tok(P)))

**(Parse-Ident-Err)**
¬ IsIdent(Tok(P))    c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P).span)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseIdent(P) ⇓ (P, "_")

**(Parse-ModulePath)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, id)    Γ ⊢ ParseModulePathTail(P_1, [id]) ⇓ (P_2, path)
───────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModulePath(P) ⇓ (P_2, path)

**(Parse-ModulePathTail-End)**
¬ IsOp(Tok(P), "::")
──────────────────────────────────────────────
Γ ⊢ ParseModulePathTail(P, xs) ⇓ (P, xs)

**(Parse-ModulePathTail-Cons)**
IsOp(Tok(P), "::")    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, id)    Γ ⊢ ParseModulePathTail(P_1, xs ++ [id]) ⇓ (P_2, ys)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModulePathTail(P, xs) ⇓ (P_2, ys)

##### 3.3.6.2. Visibility Parsing

**(Parse-Vis-Opt)**
IsKw(Tok(P), v)    v ∈ {`public`, `internal`, `private`, `protected`}
────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVis(P) ⇓ (Advance(P), v)

**(Parse-Vis-Default)**
¬ IsKw(Tok(P), v)
──────────────────────────────────────────
Γ ⊢ ParseVis(P) ⇓ (P, `internal`)

##### 3.3.6.3. Using Declarations

**(Parse-Using-Path)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `using`)    Γ ⊢ ParseModulePath(Advance(P_1)) ⇓ (P_2, path)    Γ ⊢ ParseAliasOpt(P_2) ⇓ (P_3, alias_opt)
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_3, ⟨UsingDecl, vis, ⟨UsingPath, path, alias_opt⟩, SpanBetween(P, P_3), []⟩)

**(Parse-Using-List)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `using`)    Γ ⊢ ParseModulePath(Advance(P_1)) ⇓ (P_2, mp)    IsPunc(Tok(P_2), "{")    Γ ⊢ ParseUsingList(Advance(P_2)) ⇓ (P_3, specs)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_3, ⟨UsingDecl, vis, ⟨UsingList, mp, specs⟩, SpanBetween(P, P_3), []⟩)

##### 3.3.6.4. Static Declarations

**(Parse-Static-Decl)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    Tok(P_1) = Keyword(kw)    kw ∈ {`let`, `var`}    mut = kw    Γ ⊢ ParseBindingAfterLetVar(P_1) ⇓ (P_2, bind)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_2, ⟨StaticDecl, vis, mut, bind, SpanBetween(P, P_2), []⟩)

##### 3.3.6.5. Procedure Declarations

**(Parse-Procedure)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseSignature(P_2) ⇓ (P_3, params, ret_opt)    Γ ⊢ ParseBlock(P_3) ⇓ (P_4, body)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_4, ⟨ProcedureDecl, vis, name, params, ret_opt, body, SpanBetween(P, P_4), []⟩)

##### 3.3.6.6. Record Declarations

**(Parse-Record)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `record`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseImplementsOpt(P_2) ⇓ (P_3, impls)    Γ ⊢ ParseRecordBody(P_3) ⇓ (P_4, members)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_4, ⟨RecordDecl, vis, name, impls, members, SpanBetween(P, P_4), []⟩)

##### 3.3.6.7. Enum Declarations

**(Parse-Enum)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `enum`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseImplementsOpt(P_2) ⇓ (P_3, impls)    Γ ⊢ ParseEnumBody(P_3) ⇓ (P_4, variants)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_4, ⟨EnumDecl, vis, name, impls, variants, SpanBetween(P, P_4), []⟩)

##### 3.3.6.8. Modal Declarations

**(Parse-Modal)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `modal`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseImplementsOpt(P_2) ⇓ (P_3, impls)    Γ ⊢ ParseModalBody(P_3) ⇓ (P_4, states)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_4, ⟨ModalDecl, vis, name, impls, states, SpanBetween(P, P_4), []⟩)

**(Parse-Class)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `class`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseSuperclassOpt(P_2) ⇓ (P_3, supers)    Γ ⊢ ParseClassBody(P_3) ⇓ (P_4, items)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_4, ⟨ClassDecl, vis, name, supers, items, SpanBetween(P, P_4), []⟩)

**(Parse-ModalBody)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseStateBlockList(Advance(P)) ⇓ (P_1, states)    IsPunc(Tok(P_1), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModalBody(P) ⇓ (Advance(P_1), states)

**(Parse-StateBlock)**
IsOp(Tok(P), "@")    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, name)    IsPunc(Tok(P_1), "{")    Γ ⊢ ParseStateMemberList(Advance(P_1)) ⇓ (P_2, members)    IsPunc(Tok(P_2), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateBlock(P) ⇓ (Advance(P_2), ⟨name, members, SpanBetween(P, P_2), []⟩)

**(Parse-StateMember-Field)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    Γ ⊢ ParseIdent(P_1) ⇓ (P_2, name)    IsPunc(Tok(P_2), ":")    Γ ⊢ ParseType(Advance(P_2)) ⇓ (P_3, ty)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateMember(P) ⇓ (P_3, ⟨StateFieldDecl, vis, name, ty, SpanBetween(P, P_3), []⟩)

**(Parse-StateMember-Method)**
Γ ⊢ ParseVis(P) ⇓ (P_0, vis)    IsKw(Tok(P_0), `procedure`)    Γ ⊢ ParseIdent(Advance(P_0)) ⇓ (P_1, name)    Γ ⊢ ParseSignature(P_1) ⇓ (P_2, params, ret_opt)    Γ ⊢ ParseBlock(P_2) ⇓ (P_3, body)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateMember(P) ⇓ (P_3, ⟨StateMethodDecl, vis, name, params, ret_opt, body, SpanBetween(P, P_3), []⟩)

**(Parse-StateMember-Transition)**
Γ ⊢ ParseVis(P) ⇓ (P_0, vis)    IsKw(Tok(P_0), `transition`)    Γ ⊢ ParseIdent(Advance(P_0)) ⇓ (P_1, name)    IsPunc(Tok(P_1), "(")    Γ ⊢ ParseParamList(Advance(P_1)) ⇓ (P_2, params)    IsPunc(Tok(P_2), ")")    P_2' = Advance(P_2)    IsOp(Tok(P_2'), "->")    IsOp(Tok(Advance(P_2')), "@")    Γ ⊢ ParseIdent(Advance(Advance(P_2'))) ⇓ (P_3, target)    Γ ⊢ ParseBlock(P_3) ⇓ (P_4, body)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateMember(P) ⇓ (P_4, ⟨TransitionDecl, vis, name, params, target, body, SpanBetween(P, P_4), []⟩)

##### 3.3.6.9. Implements Clauses

**(Parse-Implements-None)**
¬ IsOp(Tok(P), "<:")
──────────────────────────────────────────────
Γ ⊢ ParseImplementsOpt(P) ⇓ (P, [])

**(Parse-Implements-Yes)**
IsOp(Tok(P), "<:")    Γ ⊢ ParseClassList(Advance(P)) ⇓ (P_1, cls)
───────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseImplementsOpt(P) ⇓ (P_1, cls)

**(Parse-ClassList-Cons)**
Γ ⊢ ParseClassPath(P) ⇓ (P_1, c_0)    Γ ⊢ ParseClassListTail(P_1, [c_0]) ⇓ (P_2, cs)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassList(P) ⇓ (P_2, cs)

**(Parse-ClassListTail-End)**
¬ IsPunc(Tok(P), ",")
──────────────────────────────────────────────
Γ ⊢ ParseClassListTail(P, cs) ⇓ (P, cs)

**(Parse-ClassListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseClassPath(Advance(P)) ⇓ (P_1, c)    Γ ⊢ ParseClassListTail(P_1, cs ++ [c]) ⇓ (P_2, cs')
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassListTail(P, cs) ⇓ (P_2, cs')


##### 3.3.6.10. Class Declarations

**(Parse-Superclass-None)**
¬ IsOp(Tok(P), "<:")
──────────────────────────────────────────────
Γ ⊢ ParseSuperclassOpt(P) ⇓ (P, [])

**(Parse-Superclass-Yes)**
IsOp(Tok(P), "<:")    Γ ⊢ ParseSuperclassBounds(Advance(P)) ⇓ (P_1, supers)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseSuperclassOpt(P) ⇓ (P_1, supers)

**(Parse-SuperclassBounds-Cons)**
Γ ⊢ ParseClassPath(P) ⇓ (P_1, c_0)    Γ ⊢ ParseSuperclassBoundsTail(P_1, [c_0]) ⇓ (P_2, cs)
──────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseSuperclassBounds(P) ⇓ (P_2, cs)

**(Parse-SuperclassBoundsTail-End)**
¬ IsOp(Tok(P), "+")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseSuperclassBoundsTail(P, cs) ⇓ (P, cs)

**(Parse-SuperclassBoundsTail-Plus)**
IsOp(Tok(P), "+")    Γ ⊢ ParseClassPath(Advance(P)) ⇓ (P_1, c)    Γ ⊢ ParseSuperclassBoundsTail(P_1, cs ++ [c]) ⇓ (P_2, cs')
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseSuperclassBoundsTail(P, cs) ⇓ (P_2, cs')

**(Parse-ClassBody)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseClassItemList(Advance(P)) ⇓ (P_1, items)    IsPunc(Tok(P_1), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassBody(P) ⇓ (Advance(P_1), items)

**(Parse-ClassItemList-End)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────
Γ ⊢ ParseClassItemList(P) ⇓ (P, [])

**(Parse-ClassItemList-Cons)**
¬ IsPunc(Tok(P), "}")    Γ ⊢ ParseClassItem(P) ⇓ (P_1, it)    Γ ⊢ ParseClassItemList(P_1) ⇓ (P_2, rest)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassItemList(P) ⇓ (P_2, [it] ++ rest)

**(Parse-ClassItem-Method)**
Γ ⊢ ParseVis(P) ⇓ (P_0, vis)    IsKw(Tok(P_0), `procedure`)    Γ ⊢ ParseIdent(Advance(P_0)) ⇓ (P_1, name)    Γ ⊢ ParseMethodSignature(P_1) ⇓ (P_2, receiver, params, ret_opt)    Γ ⊢ ParseClassMethodBody(P_2) ⇓ (P_3, body_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassItem(P) ⇓ (P_3, ⟨ClassMethodDecl, vis, name, receiver, params, ret_opt, body_opt, SpanBetween(P, P_3), []⟩)

**(Parse-ClassItem-Field)**
Γ ⊢ ParseVis(P) ⇓ (P_0, vis)    Γ ⊢ ParseIdent(P_0) ⇓ (P_1, name)    IsPunc(Tok(P_1), ":")    Γ ⊢ ParseType(Advance(P_1)) ⇓ (P_2, ty)    Γ ⊢ ConsumeTerminatorReq(P_2) ⇓ P_3
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseClassItem(P) ⇓ (P_3, ⟨ClassFieldDecl, vis, name, ty, SpanBetween(P, P_3), []⟩)

**(Parse-ClassMethodBody-Concrete)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseBlock(P) ⇓ (P_1, body)
──────────────────────────────────────────────────────────
Γ ⊢ ParseClassMethodBody(P) ⇓ (P_1, body)

**(Parse-ClassMethodBody-Abstract)**
¬ IsPunc(Tok(P), "{")    Γ ⊢ ConsumeTerminatorReq(P) ⇓ P_1
──────────────────────────────────────────────────────────
Γ ⊢ ParseClassMethodBody(P) ⇓ (P_1, ⊥)

UnsupportedClassItem = {`modal_class`, `type_item`, `abstract_state`, `override_in_class`}
UnsupportedClassItem ⊆ UnsupportedForm

##### 3.3.6.11. Type Alias Declarations

**(Parse-Type-Alias)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `type`)    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    IsOp(Tok(P_2), "=")    Γ ⊢ ParseType(Advance(P_2)) ⇓ (P_3, ty)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_3, ⟨TypeAliasDecl, vis, name, ty, SpanBetween(P, P_3), []⟩)

UnsupportedWhereClause = {`where_clause`}
UnsupportedWhereClause ⊆ UnsupportedForm

##### 3.3.6.13. Item Helper Parsing Rules

**Type Paths.**

**(Parse-TypePath)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, id)    Γ ⊢ ParseTypePathTail(P_1, [id]) ⇓ (P_2, path)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTypePath(P) ⇓ (P_2, path)


**(Parse-ClassPath)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)
────────────────────────────────────────────
Γ ⊢ ParseClassPath(P) ⇓ (P_1, path)

**(Parse-TypePathTail-End)**
¬ IsOp(Tok(P), "::")
────────────────────────────────────────────
Γ ⊢ ParseTypePathTail(P, xs) ⇓ (P, xs)

**(Parse-TypePathTail-Cons)**
IsOp(Tok(P), "::")    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, id)    Γ ⊢ ParseTypePathTail(P_1, xs ++ [id]) ⇓ (P_2, ys)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTypePathTail(P, xs) ⇓ (P_2, ys)

**Qualified Head.**


**(Parse-QualifiedHead)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, id_0)    IsOp(Tok(P_1), "::")    Γ ⊢ ParseModulePathTail(P_1, [id_0]) ⇓ (P_2, xs)    xs = ys ++ [name]    |xs| ≥ 2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseQualifiedHead(P) ⇓ (P_2, ys, name)

**Using Lists.**


**(Parse-UsingSpec)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    Γ ⊢ ParseAliasOpt(P_1) ⇓ (P_2, alias_opt)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseUsingSpec(P) ⇓ (P_2, ⟨name, alias_opt⟩)

**Bindings.**

**(Parse-BindingAfterLetVar)**
Tok(P) = kw ∈ {Keyword(`let`), Keyword(`var`)}    Γ ⊢ ParsePattern(Advance(P)) ⇓ (P_1, pat)    Γ ⊢ ParseTypeAnnotOpt(P_1) ⇓ (P_2, ty_opt)    Tok(P_2) ∈ {Operator("="), Operator(":=")}    op = Tok(P_2)    Γ ⊢ ParseExpr(Advance(P_2)) ⇓ (P_3, init)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseBindingAfterLetVar(P) ⇓ (P_3, ⟨pat, ty_opt, op, init, SpanBetween(P, P_3)⟩)

**(Parse-ShadowBinding)**
Tok(P) = kw ∈ {Keyword(`let`), Keyword(`var`)}    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, name)    Γ ⊢ ParseTypeAnnotOpt(P_1) ⇓ (P_2, ty_opt)    IsOp(Tok(P_2), "=")    Γ ⊢ ParseExpr(Advance(P_2)) ⇓ (P_3, init)    s = (ShadowLetStmt(name, ty_opt, init) if kw = Keyword(`let`) else ShadowVarStmt(name, ty_opt, init))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseShadowBinding(P) ⇓ (P_3, s)

**Record Bodies.**

**(Parse-RecordBody)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseRecordMemberList(Advance(P)) ⇓ (P_1, members)    IsPunc(Tok(P_1), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordBody(P) ⇓ (Advance(P_1), members)

**Record Member Lists.**

**(Parse-RecordMemberList-End)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────
Γ ⊢ ParseRecordMemberList(P) ⇓ (P, [])

**(Parse-RecordMemberList-Cons)**
Γ ⊢ ParseRecordMember(P) ⇓ (P_1, m)    Γ ⊢ ParseRecordMemberTail(P_1, [m]) ⇓ (P_2, ms)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordMemberList(P) ⇓ (P_2, ms)

**(Parse-RecordMemberTail-End)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────
Γ ⊢ ParseRecordMemberTail(P, xs) ⇓ (P, xs)

**(Parse-RecordMemberTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordMemberTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-RecordMemberTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseRecordMember(Advance(P)) ⇓ (P_1, m)    Γ ⊢ ParseRecordMemberTail(P_1, xs ++ [m]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordMemberTail(P, xs) ⇓ (P_2, ys)

**Record Members.**

**(Parse-RecordMember-Method)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Γ ⊢ ParseMethodDefAfterVis(P_1, vis) ⇓ (P_2, m)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordMember(P) ⇓ (P_2, m)

**(Parse-RecordMember-Field)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    ¬ IsKw(Tok(P_1), `procedure`)    Γ ⊢ ParseRecordFieldDeclAfterVis(P_1, vis) ⇓ (P_2, f)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordMember(P) ⇓ (P_2, f)

**Record Method Definitions.**

**(Parse-MethodDefAfterVis)**
Γ ⊢ ParseOverrideOpt(P) ⇓ (P_0, ov)    IsKw(Tok(P_0), `procedure`)    Γ ⊢ ParseIdent(Advance(P_0)) ⇓ (P_1, name)    Γ ⊢ ParseMethodSignature(P_1) ⇓ (P_2, receiver, params, ret_opt)    Γ ⊢ ParseBlock(P_2) ⇓ (P_3, body)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMethodDefAfterVis(P, vis) ⇓ (P_3, ⟨MethodDecl, vis, ov, name, receiver, params, ret_opt, body, SpanBetween(P, P_3), []⟩)

**(Parse-Override-Yes)**
IsKw(Tok(P), `override`)
────────────────────────────────────────────
Γ ⊢ ParseOverrideOpt(P) ⇓ (Advance(P), true)

**(Parse-Override-No)**
¬ IsKw(Tok(P), `override`)
──────────────────────────────────────────
Γ ⊢ ParseOverrideOpt(P) ⇓ (P, false)


**(Parse-MethodSignature)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseReceiver(Advance(P)) ⇓ (P_1, r)    Γ ⊢ ParseMethodParams(P_1) ⇓ (P_2, params)    IsPunc(Tok(P_2), ")")    Γ ⊢ ParseReturnOpt(Advance(P_2)) ⇓ (P_3, ret_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMethodSignature(P) ⇓ (P_3, r, params, ret_opt)

**(Parse-MethodParams-None)**
IsPunc(Tok(P), ")")
────────────────────────────────────────────
Γ ⊢ ParseMethodParams(P) ⇓ (P, [])

**(Parse-MethodParams-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseParamList(Advance(P)) ⇓ (P_1, params)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMethodParams(P) ⇓ (P_1, params)

**Receiver Parsing.**

**(Parse-Receiver-Short-Const)**
IsOp(Tok(P), "~")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseReceiver(P) ⇓ (Advance(P), ReceiverShorthand(`const`))

**(Parse-Receiver-Short-Unique)**
IsOp(Tok(P), "~!")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseReceiver(P) ⇓ (Advance(P), ReceiverShorthand(`unique`))

**(Parse-Receiver-Explicit)**
Γ ⊢ ParseParamModeOpt(P) ⇓ (P_1, mode)    IsIdent(Tok(P_1))    Lexeme(Tok(P_1)) = `self`    IsPunc(Tok(Advance(P_1)), ":")    Γ ⊢ ParseType(Advance(Advance(P_1))) ⇓ (P_2, ty)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseReceiver(P) ⇓ (P_2, ReceiverExplicit(mode, ty))

**State Block Lists.**

**(Parse-StateBlockList-Empty)**
IsPunc(Tok(P), "}")
───────────────────────────────────────────────
Γ ⊢ ParseStateBlockList(P) ⇓ (P, [])

**(Parse-StateBlockList-Cons)**
Γ ⊢ ParseStateBlock(P) ⇓ (P_1, st)    Γ ⊢ ParseStateBlockList(P_1) ⇓ (P_2, sts)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateBlockList(P) ⇓ (P_2, [st] ++ sts)

**State Member Lists.**

**(Parse-StateMemberList-End)**
IsPunc(Tok(P), "}")
───────────────────────────────────────────────
Γ ⊢ ParseStateMemberList(P) ⇓ (P, [])

**(Parse-StateMemberList-Cons)**
Γ ⊢ ParseStateMember(P) ⇓ (P_1, m)    Γ ⊢ ParseStateMemberList(P_1) ⇓ (P_2, ms)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStateMemberList(P) ⇓ (P_2, [m] ++ ms)


**Enum Bodies.**

**(Parse-EnumBody)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseVariantList(Advance(P)) ⇓ (P_1, vars)    IsPunc(Tok(P_1), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseEnumBody(P) ⇓ (Advance(P_1), vars)

**Parameters and Returns.**

**(Parse-ParamList-Empty)**
IsPunc(Tok(P), ")")
────────────────────────────────────────────
Γ ⊢ ParseParamList(P) ⇓ (P, [])

**(Parse-ParamList-Cons)**
Γ ⊢ ParseParam(P) ⇓ (P_1, param)    Γ ⊢ ParseParamTail(P_1, [param]) ⇓ (P_2, params)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamList(P) ⇓ (P_2, params)

**(Parse-ReturnOpt-None)**
¬ IsOp(Tok(P), "->")
─────────────────────────────────────────────
Γ ⊢ ParseReturnOpt(P) ⇓ (P, ⊥)

**(Parse-ReturnOpt-Arrow)**
IsOp(Tok(P), "->")    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, ty)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseReturnOpt(P) ⇓ (P_1, ty)

**(Parse-AliasOpt-None)**
¬ IsKw(Tok(P), `as`)
───────────────────────────────────────────
Γ ⊢ ParseAliasOpt(P) ⇓ (P, ⊥)

**(Parse-AliasOpt-Yes)**
IsKw(Tok(P), `as`)    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, id)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseAliasOpt(P) ⇓ (P_1, id)

**(Parse-TypeAnnotOpt-None)**
¬ IsPunc(Tok(P), ":")
─────────────────────────────────────────────
Γ ⊢ ParseTypeAnnotOpt(P) ⇓ (P, ⊥)

**(Parse-TypeAnnotOpt-Yes)**
IsPunc(Tok(P), ":")    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, ty)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseTypeAnnotOpt(P) ⇓ (P_1, ty)

**(Parse-UsingList-Empty)**
IsPunc(Tok(P), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────
Γ ⊢ ParseUsingList(P) ⇓ (Advance(P), [])

**(Parse-UsingList-Cons)**
Γ ⊢ ParseUsingSpec(P) ⇓ (P_1, s)    Γ ⊢ ParseUsingListTail(P_1, [s]) ⇓ (P_2, specs)    IsPunc(Tok(P_2), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseUsingList(P) ⇓ (Advance(P_2), specs)

**(Parse-UsingListTail-End)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────
Γ ⊢ ParseUsingListTail(P, xs) ⇓ (P, xs)

**(Parse-UsingListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseUsingListTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-UsingListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseUsingSpec(Advance(P)) ⇓ (P_1, s)    Γ ⊢ ParseUsingListTail(P_1, xs ++ [s]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseUsingListTail(P, xs) ⇓ (P_2, ys)

**(Parse-RecordFieldDeclList-Empty)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclList(P) ⇓ (P, [])

**(Parse-RecordFieldDeclList-Cons)**
Γ ⊢ ParseRecordFieldDecl(P) ⇓ (P_1, f)    Γ ⊢ ParseRecordFieldDeclTail(P_1, [f]) ⇓ (P_2, fields)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclList(P) ⇓ (P_2, fields)

**(Parse-RecordFieldDecl)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    Γ ⊢ ParseRecordFieldDeclAfterVis(P_1, vis) ⇓ (P_2, f)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDecl(P) ⇓ (P_2, f)

**(Parse-RecordFieldDeclAfterVis)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    IsPunc(Tok(P_1), ":")    Γ ⊢ ParseType(Advance(P_1)) ⇓ (P_2, ty)    Γ ⊢ ParseRecordFieldInitOpt(P_2) ⇓ (P_3, init_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclAfterVis(P, vis) ⇓ (P_3, ⟨vis, name, ty, init_opt⟩)

**(Parse-RecordFieldInitOpt-None)**
¬ IsOp(Tok(P), "=")
────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldInitOpt(P) ⇓ (P, ⊥)

**(Parse-RecordFieldInitOpt-Yes)**
IsOp(Tok(P), "=")    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldInitOpt(P) ⇓ (P_1, e)

**(Parse-RecordFieldDeclTail-End)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclTail(P, xs) ⇓ (P, xs)

**(Parse-RecordFieldDeclTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-RecordFieldDeclTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseRecordFieldDecl(Advance(P)) ⇓ (P_1, f)    Γ ⊢ ParseRecordFieldDeclTail(P_1, xs ++ [f]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRecordFieldDeclTail(P, xs) ⇓ (P_2, ys)

**(Parse-FieldDeclList-Empty)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────
Γ ⊢ ParseFieldDeclList(P) ⇓ (P, [])

**(Parse-FieldDeclList-Cons)**
Γ ⊢ ParseFieldDecl(P) ⇓ (P_1, f)    Γ ⊢ ParseFieldDeclTail(P_1, [f]) ⇓ (P_2, fields)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldDeclList(P) ⇓ (P_2, fields)

**(Parse-FieldDecl)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    Γ ⊢ ParseIdent(P_1) ⇓ (P_2, name)    IsPunc(Tok(P_2), ":")    Γ ⊢ ParseType(Advance(P_2)) ⇓ (P_3, ty)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldDecl(P) ⇓ (P_3, ⟨vis, name, ty, ⊥⟩)

**(Parse-FieldDeclTail-End)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────────
Γ ⊢ ParseFieldDeclTail(P, xs) ⇓ (P, xs)

**(Parse-FieldDeclTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldDeclTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-FieldDeclTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseFieldDecl(Advance(P)) ⇓ (P_1, f)    Γ ⊢ ParseFieldDeclTail(P_1, xs ++ [f]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldDeclTail(P, xs) ⇓ (P_2, ys)

**(Parse-VariantList-Empty)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────
Γ ⊢ ParseVariantList(P) ⇓ (P, [])

**(Parse-VariantList-Cons)**
Γ ⊢ ParseVariant(P) ⇓ (P_1, v)    Γ ⊢ ParseVariantTail(P_1, [v]) ⇓ (P_2, vs)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantList(P) ⇓ (P_2, vs)

**(Parse-Variant)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    Γ ⊢ ParseVariantPayloadOpt(P_1) ⇓ (P_2, payload_opt)    Γ ⊢ ParseVariantDiscriminantOpt(P_2) ⇓ (P_3, disc_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariant(P) ⇓ (P_3, ⟨name, payload_opt, disc_opt⟩)

**(Parse-VariantPayloadOpt-None)**
Tok(P) ∉ {Punctuator("("), Punctuator("{")}
────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantPayloadOpt(P) ⇓ (P, ⊥)

**(Parse-VariantPayloadOpt-Tuple)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseTypeList(Advance(P)) ⇓ (P_1, ts)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantPayloadOpt(P) ⇓ (Advance(P_1), TuplePayload(ts))

**(Parse-VariantPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseFieldDeclList(Advance(P)) ⇓ (P_1, fs)    IsPunc(Tok(P_1), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantPayloadOpt(P) ⇓ (Advance(P_1), RecordPayload(fs))

**(Parse-VariantDiscriminantOpt-None)**
¬ IsOp(Tok(P), "=")
─────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantDiscriminantOpt(P) ⇓ (P, ⊥)

**(Parse-VariantDiscriminantOpt-Yes)**
IsOp(Tok(P), "=")    t = Tok(Advance(P))    t.kind = IntLiteral
──────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantDiscriminantOpt(P) ⇓ (Advance(Advance(P)), t)
**(Parse-VariantTail-End)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────
Γ ⊢ ParseVariantTail(P, xs) ⇓ (P, xs)

**(Parse-VariantTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-VariantTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseVariant(Advance(P)) ⇓ (P_1, v)    Γ ⊢ ParseVariantTail(P_1, xs ++ [v]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseVariantTail(P, xs) ⇓ (P_2, ys)

**(Parse-Param)**
Γ ⊢ ParseParamModeOpt(P) ⇓ (P_1, mode)    Γ ⊢ ParseIdent(P_1) ⇓ (P_2, name)    IsPunc(Tok(P_2), ":")    Γ ⊢ ParseType(Advance(P_2)) ⇓ (P_3, ty)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParam(P) ⇓ (P_3, ⟨mode, name, ty⟩)

**(Parse-ParamMode-None)**
¬ IsKw(Tok(P), `move`)
──────────────────────────────────────────────
Γ ⊢ ParseParamModeOpt(P) ⇓ (P, ⊥)

**(Parse-ParamMode-Move)**
IsKw(Tok(P), `move`)
─────────────────────────────────────────────────
Γ ⊢ ParseParamModeOpt(P) ⇓ (Advance(P), `move`)

**(Parse-ParamTail-End)**
IsPunc(Tok(P), ")")
────────────────────────────────────────────
Γ ⊢ ParseParamTail(P, xs) ⇓ (P, xs)

**(Parse-ParamTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-ParamTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseParam(Advance(P)) ⇓ (P_1, p)    Γ ⊢ ParseParamTail(P_1, xs ++ [p]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamTail(P, xs) ⇓ (P_2, ys)
**(Parse-Signature)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseParamList(Advance(P)) ⇓ (P_1, params)    IsPunc(Tok(P_1), ")")    Γ ⊢ ParseReturnOpt(Advance(P_1)) ⇓ (P_2, ret_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseSignature(P) ⇓ (P_2, params, ret_opt)



##### 3.3.6.14. Unsupported Constructs (Parsing)

**(Parse-Import-Unsupported)**
IsKw(Tok(P), `import`)    Γ ⊢ Emit(Code(WF-Import-Unsupported))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**(Parse-Attribute-Unsupported)**
IsPunc(Tok(P), "[")    IsPunc(Tok(Advance(P)), "[")    Γ ⊢ Emit(Code(WF-Attr-Unsupported))    Γ ⊢ SyncItem(P) ⇓ P_1
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_1, ErrorItem(SpanBetween(P, P_1)))

**(Parse-Modal-Class-Unsupported)**
IsKw(Tok(P), `modal`)    IsKw(Tok(Advance(P)), `class`)    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (SyncItem(Advance(Advance(P))), ErrorItem(SpanBetween(P, Advance(Advance(P)))))

**(Parse-Extern-Unsupported)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `extern`    Γ ⊢ Emit(Code(Parse-Extern-Unsupported))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**(Parse-Use-Unsupported)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `use`    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**(Return-At-Module-Err)**
IsKw(Tok(P), `return`)    Γ ⊢ Emit(Code(Return-At-Module-Err))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**Generic Syntax Rejection.**
AngleDelta(Operator("<")) = 1
AngleDelta(Operator(">")) = -1
AngleDelta(Operator(">>")) = -2
AngleDelta(t) = 0 if t.kind ∉ {Operator("<"), Operator(">"), Operator(">>")}

AngleStep(P, d) = ⟨Advance(P), d + AngleDelta(Tok(P))⟩
AngleScan(P_0, P, d) ⇓ P'
Tok(P) = EOF
────────────────────────────────────────
AngleScan(P_0, P, d) ⇓ P_0
Tok(P) ≠ EOF    AngleStep(P, d) = ⟨P_1, d_1⟩    d_1 ≠ 0    AngleScan(P_0, P_1, d_1) ⇓ P'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────
AngleScan(P_0, P, d) ⇓ P'
Tok(P) ≠ EOF    AngleStep(P, d) = ⟨P_1, d_1⟩    d_1 = 0
────────────────────────────────────────────────────────────────────────
AngleScan(P_0, P, d) ⇓ P_1

SkipAngles(P_0) ⇓ P' ⇔ AngleScan(P_0, P_0, 0) ⇓ P'

**(Parse-Generic-Header-Unsupported)**
Γ ⊢ ParseVis(P) ⇓ (P_1, vis)    Tok(P_1) = Keyword(kw)    kw ∈ {`procedure`, `record`, `enum`, `class`, `modal`, `type`}    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    IsOp(Tok(P_2), "<")    P_2' = SkipAngles(P_2)    Γ ⊢ Emit(Code(Unsupported-Construct))    Γ ⊢ SyncItem(P_2') ⇓ P_3
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_3, ErrorItem(SpanBetween(P, P_3)))


**(Parse-Item-Err)**
c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Γ ⊢ SyncItem(P_1) ⇓ P_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseItem(P) ⇓ (P_2, ErrorItem(SpanBetween(P, P_2)))

#### 3.3.7. Type Parsing (C0 Subset)

**Type Start Predicate.**
TypeStart(t) ⇔ IsKw(t, `const`) ∨ IsKw(t, `unique`) ∨ IsKw(t, `shared`) ∨ Lexeme(t) ∈ PrimTypes_C0 ∨ IsPunc(t, "(") ∨ IsPunc(t, "[") ∨ IsOp(t, "*") ∨ IsOp(t, "$") ∨ Lexeme(t) ∈ {`string`, `Ptr`} ∨ IsIdent(t)

**(Parse-Type)**
Γ ⊢ ParsePermOpt(P) ⇓ (P_1, perm_opt)    Γ ⊢ ParseNonPermType(P_1) ⇓ (P_2, base)    Γ ⊢ ParseUnionTail(P_2) ⇓ (P_3, ts)    base' = (base if ts = [] else TypeUnion([base] ++ ts))    ty = (base' if perm_opt = ⊥ else TypePerm(perm_opt, base'))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseType(P) ⇓ (P_3, ty)

**(Parse-Type-Err)**
Γ ⊢ ParsePermOpt(P) ⇓ (P_1, perm_opt)    c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P_1).span)    base = TypePrim("!")    ty = (base if perm_opt = ⊥ else TypePerm(perm_opt, base))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseType(P) ⇓ (P_1, ty)


**(Parse-Perm-Const)**
IsKw(Tok(P), `const`)
──────────────────────────────────────────────
Γ ⊢ ParsePermOpt(P) ⇓ (Advance(P), `const`)

**(Parse-Perm-Unique)**
IsKw(Tok(P), `unique`)
──────────────────────────────────────────────
Γ ⊢ ParsePermOpt(P) ⇓ (Advance(P), `unique`)

**(Parse-Perm-Shared)**
IsKw(Tok(P), `shared`)
──────────────────────────────────────────────
Γ ⊢ ParsePermOpt(P) ⇓ (Advance(P), `shared`)

**(Parse-Perm-None)**
¬ (IsKw(Tok(P), `const`) ∨ IsKw(Tok(P), `unique`) ∨ IsKw(Tok(P), `shared`))
────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePermOpt(P) ⇓ (P, ⊥)

**(Parse-UnionTail-None)**
¬ IsOp(Tok(P), "|")
──────────────────────────────────────────────
Γ ⊢ ParseUnionTail(P) ⇓ (P, [])

**(Parse-UnionTail-Cons)**
IsOp(Tok(P), "|")    Γ ⊢ ParseNonPermType(Advance(P)) ⇓ (P_1, t_1)    Γ ⊢ ParseUnionTail(P_1) ⇓ (P_2, ts)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnionTail(P) ⇓ (P_2, [t_1] ++ ts)


**Non-Permission Types.**

PrimLexemeSet = PrimTypes_C0 \ {"()", "!"}
BuiltinTypePath(path) ⇔ (|path| = 1 ∧ path[0] ∈ PrimLexemeSet) ∨ path = ["string"] ∨ path = ["bytes"]

**(Parse-Prim-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) ∈ PrimLexemeSet
────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(P), TypePrim(Lexeme(Tok(P))))

**(Parse-Unit-Type)**
IsPunc(Tok(P), "(")    IsPunc(Tok(Advance(P)), ")")
──────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(Advance(P)), TypePrim("()"))

**(Parse-Never-Type)**
IsOp(Tok(P), "!")
────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(P), TypePrim("!"))

**(Parse-Func-Type)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseParamTypeList(Advance(P)) ⇓ (P_1, params)    IsPunc(Tok(P_1), ")")    IsOp(Tok(Advance(P_1)), "->")    Γ ⊢ ParseType(Advance(Advance(P_1))) ⇓ (P_2, ret)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_2, TypeFunc(params, ret))

**(Parse-Tuple-Type)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseTupleTypeElems(Advance(P)) ⇓ (P_1, elems)    elems ≠ []    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(P_1), TypeTuple(elems))

**(Parse-Array-Type)**
IsPunc(Tok(P), "[")    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, t)    IsPunc(Tok(P_1), ";")    Γ ⊢ ParseExpr(Advance(P_1)) ⇓ (P_2, e)    IsPunc(Tok(P_2), "]")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(P_2), TypeArray(t, e))

**(Parse-Slice-Type)**
IsPunc(Tok(P), "[")    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, t)    IsPunc(Tok(P_1), "]")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (Advance(P_1), TypeSlice(t))

**(Parse-Safe-Pointer-Type-ShiftSplit)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "<")    Γ ⊢ ParseType(Advance(Advance(P))) ⇓ (P_1, t)    IsOp(Tok(P_1), ">>")    P_1' = SplitShiftR(P_1)    Γ ⊢ ParsePtrState(Advance(P_1')) ⇓ (P_2, st_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_2, TypePtr(t, st_opt))

**(Parse-Safe-Pointer-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "<")    Γ ⊢ ParseType(Advance(Advance(P))) ⇓ (P_1, t)    IsOp(Tok(P_1), ">")    Γ ⊢ ParsePtrState(Advance(P_1)) ⇓ (P_2, st_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_2, TypePtr(t, st_opt))

**(Parse-Raw-Pointer-Type)**
IsOp(Tok(P), "*")    IsKw(Tok(Advance(P)), q)    q ∈ {`imm`, `mut`}    Γ ⊢ ParseType(Advance(Advance(P))) ⇓ (P_1, t)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_1, TypeRawPtr(q, t))

**(Parse-String-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `string`    Γ ⊢ ParseStringState(Advance(P)) ⇓ (P_1, st_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_1, TypeString(st_opt))

**(Parse-Bytes-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `bytes`    Γ ⊢ ParseBytesState(Advance(P)) ⇓ (P_1, st_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_1, TypeBytes(st_opt))

**(Parse-Dynamic-Type)**
IsOp(Tok(P), "$")    Γ ⊢ ParseTypePath(Advance(P)) ⇓ (P_1, path)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_1, TypeDynamic(path))

**(Parse-Modal-State-Type)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    IsOp(Tok(P_1), "@")    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, state)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_2, TypeModalState(path, state))

**(Parse-Type-Generic-Unsupported)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    IsOp(Tok(P_1), "<")    path ≠ [`Ptr`]    P_1' = SkipAngles(P_1)    Γ ⊢ Emit(Code(Unsupported-Construct))    Γ ⊢ SyncType(P_1') ⇓ P_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_2, TypePath(path))

**(Parse-Type-Path)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    ¬ IsOp(Tok(P_1), "@")    ¬ IsOp(Tok(P_1), "<")    ¬ BuiltinTypePath(path)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseNonPermType(P) ⇓ (P_1, TypePath(path))

##### 3.3.7.1. Type Helper Parsing Rules

**Tuple Type Elements.**

**(Parse-TupleTypeElems-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseTupleTypeElems(P) ⇓ (P, [])

**(Parse-TupleTypeElems-One)**
Γ ⊢ ParseType(P) ⇓ (P_1, t)    IsPunc(Tok(P_1), ";")
────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleTypeElems(P) ⇓ (Advance(P_1), [t])

**(Parse-TupleTypeElems-TrailingComma)**
Γ ⊢ ParseType(P) ⇓ (P_1, t)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleTypeElems(P) ⇓ (Advance(P_1), [t])

**(Parse-TupleTypeElems-Many)**
Γ ⊢ ParseType(P) ⇓ (P_1, t_1)    IsPunc(Tok(P_1), ",")    Γ ⊢ ParseType(Advance(P_1)) ⇓ (P_2, t_2)    Γ ⊢ ParseTypeListTail(P_2, [t_2]) ⇓ (P_3, ts)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleTypeElems(P) ⇓ (P_3, [t_1] ++ ts)

**Param Type Lists.**

**(Parse-ParamTypeList-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseParamTypeList(P) ⇓ (P, [])

**(Parse-ParamTypeList-Cons)**
Γ ⊢ ParseParamType(P) ⇓ (P_1, pt)    Γ ⊢ ParseParamTypeListTail(P_1, [pt]) ⇓ (P_2, pts)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamTypeList(P) ⇓ (P_2, pts)

**(Parse-ParamTypeListTail-End)**
¬ IsPunc(Tok(P), ",")
────────────────────────────────────────────────────
Γ ⊢ ParseParamTypeListTail(P, ps) ⇓ (P, ps)

**(Parse-ParamTypeListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseParamType(Advance(P)) ⇓ (P_1, pt)    Γ ⊢ ParseParamTypeListTail(P_1, ps ++ [pt]) ⇓ (P_2, ps')
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamTypeListTail(P, ps) ⇓ (P_2, ps')

**Param Types.**

**(Parse-ParamType-Move)**
IsKw(Tok(P), `move`)    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, ty)
────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamType(P) ⇓ (P_1, ⟨`move`, ty⟩)

**(Parse-ParamType-Plain)**
¬ IsKw(Tok(P), `move`)    Γ ⊢ ParseType(P) ⇓ (P_1, ty)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseParamType(P) ⇓ (P_1, ⟨⊥, ty⟩)

**String State.**

**(Parse-StringState-None)**
¬ IsOp(Tok(P), "@")
───────────────────────────────────────────────
Γ ⊢ ParseStringState(P) ⇓ (P, ⊥)

**(Parse-StringState-Managed)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Managed`
────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStringState(P) ⇓ (Advance(Advance(P)), `Managed`)

**(Parse-StringState-View)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `View`
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStringState(P) ⇓ (Advance(Advance(P)), `View`)

**Bytes State.**

**(Parse-BytesState-None)**
¬ IsOp(Tok(P), "@")
───────────────────────────────────────────────
Γ ⊢ ParseBytesState(P) ⇓ (P, ⊥)

**(Parse-BytesState-Managed)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Managed`
────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseBytesState(P) ⇓ (Advance(Advance(P)), `Managed`)

**(Parse-BytesState-View)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `View`
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseBytesState(P) ⇓ (Advance(Advance(P)), `View`)

**Pointer State.**

**(Parse-PtrState-None)**
¬ IsOp(Tok(P), "@")
──────────────────────────────────────────────
Γ ⊢ ParsePtrState(P) ⇓ (P, ⊥)

**(Parse-PtrState-Valid)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Valid`
────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePtrState(P) ⇓ (Advance(Advance(P)), `Valid`)

**(Parse-PtrState-Null)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Null`
──────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePtrState(P) ⇓ (Advance(Advance(P)), `Null`)

**(Parse-PtrState-Expired)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Expired`
──────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePtrState(P) ⇓ (Advance(Advance(P)), `Expired`)

**Type Lists.**

**(Parse-TypeList-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseTypeList(P) ⇓ (P, [])

**(Parse-TypeList-Cons)**
Γ ⊢ ParseType(P) ⇓ (P_1, t)    Γ ⊢ ParseTypeListTail(P_1, [t]) ⇓ (P_2, ts)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTypeList(P) ⇓ (P_2, ts)

**(Parse-TypeListTail-End)**
Tok(P) ∈ {Punctuator(")"), Punctuator("}")}
──────────────────────────────────────────────────────────────
Γ ⊢ ParseTypeListTail(P, xs) ⇓ (P, xs)

**(Parse-TypeListTail-TrailingComma)**
IsPunc(Tok(P), ",")    Tok(Advance(P)) ∈ {Punctuator(")"), Punctuator("}")}    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTypeListTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-TypeListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, t)    Γ ⊢ ParseTypeListTail(P_1, xs ++ [t]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTypeListTail(P, xs) ⇓ (P_2, ys)

#### 3.3.8. Expression Parsing and Precedence

**Operator Sets.**
LogicalOrOps = {"||"}
LogicalAndOps = {"&&"}
ComparisonOps = {"==", "!=", "<", "<=", ">", ">="}
BitOrOps = {"|"}
BitXorOps = {"^"}
BitAndOps = {"&"}
AddOps = {"+", "-"}
MulOps = {"*", "/", "%"}

**(Parse-Expr)**
Γ ⊢ ParseRange(P) ⇓ (P_1, e)
──────────────────────────────────────────────
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)

##### 3.3.8.1. Range Expressions

ExprStart(t) ⇔ IsIdent(t) ∨ (t ∈ LiteralToken) ∨ IsPunc(t, "(") ∨ IsPunc(t, "[") ∨ IsPunc(t, "{")
              ∨ IsOp(t, "!") ∨ IsOp(t, "-") ∨ IsOp(t, "&") ∨ IsOp(t, "*") ∨ IsOp(t, "^")
              ∨ IsKw(t, `if`) ∨ IsKw(t, `match`) ∨ IsKw(t, `loop`) ∨ IsKw(t, `unsafe`) ∨ IsKw(t, `move`) ∨ IsKw(t, `transmute`) ∨ IsKw(t, `widen`)

**(Parse-Range-To)**
IsOp(Tok(P), "..")    Γ ⊢ ParseLogicalOr(Advance(P)) ⇓ (P_1, e)
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRange(P) ⇓ (P_1, Range(To, ⊥, e))

**(Parse-Range-ToInc)**
IsOp(Tok(P), "..=")    Γ ⊢ ParseLogicalOr(Advance(P)) ⇓ (P_1, e)
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRange(P) ⇓ (P_1, Range(ToInclusive, ⊥, e))

**(Parse-Range-Full)**
IsOp(Tok(P), "..")    Tok(Advance(P)) ∉ ExprStart
────────────────────────────────────────────────────────────────
Γ ⊢ ParseRange(P) ⇓ (Advance(P), Range(Full, ⊥, ⊥))

**(Parse-Range-Lhs)**
Γ ⊢ ParseLogicalOr(P) ⇓ (P_1, e_0)    Γ ⊢ ParseRangeTail(P_1, e_0) ⇓ (P_2, e)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRange(P) ⇓ (P_2, e)

**(Parse-RangeTail-None)**
¬ (IsOp(Tok(P), "..") ∨ IsOp(Tok(P), "..="))
───────────────────────────────────────────────────────────────
Γ ⊢ ParseRangeTail(P, e) ⇓ (P, e)

**(Parse-RangeTail-From)**
IsOp(Tok(P), "..")    Tok(Advance(P)) ∉ ExprStart
────────────────────────────────────────────────────────────────
Γ ⊢ ParseRangeTail(P, e_0) ⇓ (Advance(P), Range(From, e_0, ⊥))

**(Parse-RangeTail-Excl)**
IsOp(Tok(P), "..")    Tok(Advance(P)) ∈ ExprStart    Γ ⊢ ParseLogicalOr(Advance(P)) ⇓ (P_1, e_1)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRangeTail(P, e_0) ⇓ (P_1, Range(Exclusive, e_0, e_1))

**(Parse-RangeTail-Incl)**
IsOp(Tok(P), "..=")    Γ ⊢ ParseLogicalOr(Advance(P)) ⇓ (P_1, e_1)
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRangeTail(P, e_0) ⇓ (P_1, Range(Inclusive, e_0, e_1))

##### 3.3.8.2. Binary Operator Chains

Γ ⊢ ParseLogicalOr(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, LogicalOrOps, ParseLogicalAnd) ⇓ (P', e)
Γ ⊢ ParseLogicalAnd(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, LogicalAndOps, ParseComparison) ⇓ (P', e)
Γ ⊢ ParseComparison(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, ComparisonOps, ParseBitOr) ⇓ (P', e)
Γ ⊢ ParseBitOr(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, BitOrOps, ParseBitXor) ⇓ (P', e)
Γ ⊢ ParseBitXor(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, BitXorOps, ParseBitAnd) ⇓ (P', e)
Γ ⊢ ParseBitAnd(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, BitAndOps, ParseShift) ⇓ (P', e)
Γ ⊢ ParseShift(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, ShiftOps, ParseAdd) ⇓ (P', e)
Γ ⊢ ParseAdd(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, AddOps, ParseMul) ⇓ (P', e)
Γ ⊢ ParseMul(P) ⇓ (P', e) ⇔ Γ ⊢ ParseLeftChain(P, MulOps, ParsePower) ⇓ (P', e)

**(Parse-LeftChain)**
Γ ⊢ ParseHigher(P) ⇓ (P_1, e_0)    Γ ⊢ ParseLeftChainTail(P_1, e_0, OpSet, ParseHigher) ⇓ (P_2, e)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseLeftChain(P, OpSet, ParseHigher) ⇓ (P_2, e)

**(Parse-LeftChain-Stop)**
Tok(P) ∉ OpSet
──────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseLeftChainTail(P, e, OpSet, ParseHigher) ⇓ (P, e)

**(Parse-LeftChain-Cons)**
Tok(P) = op ∈ OpSet    Γ ⊢ ParseHigher(Advance(P)) ⇓ (P_1, e_1)    e' = Binary(op, e, e_1)    Γ ⊢ ParseLeftChainTail(P_1, e', OpSet, ParseHigher) ⇓ (P_2, e'')
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseLeftChainTail(P, e, OpSet, ParseHigher) ⇓ (P_2, e'')


##### 3.3.8.3. Power (Right-Associative)

**(Parse-Power)**
Γ ⊢ ParseCast(P) ⇓ (P_1, e_0)    Γ ⊢ ParsePowerTail(P_1, e_0) ⇓ (P_2, e)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePower(P) ⇓ (P_2, e)

**(Parse-PowerTail-None)**
¬ IsOp(Tok(P), "**")
──────────────────────────────────────────────
Γ ⊢ ParsePowerTail(P, e) ⇓ (P, e)

**(Parse-PowerTail-Cons)**
IsOp(Tok(P), "**")    Γ ⊢ ParsePower(Advance(P)) ⇓ (P_1, e_1)
────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePowerTail(P, e_0) ⇓ (P_1, Binary("**", e_0, e_1))

##### 3.3.8.4. Cast Expressions

**(Parse-Cast)**
Γ ⊢ ParseUnary(P) ⇓ (P_1, e)    Γ ⊢ ParseCastTail(P_1, e) ⇓ (P_2, e')
────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseCast(P) ⇓ (P_2, e')

**(Parse-CastTail-None)**
¬ IsKw(Tok(P), `as`)
──────────────────────────────────────────────
Γ ⊢ ParseCastTail(P, e) ⇓ (P, e)

**(Parse-CastTail-As)**
IsKw(Tok(P), `as`)    Γ ⊢ ParseType(Advance(P)) ⇓ (P_1, t)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseCastTail(P, e) ⇓ (P_1, Cast(e, t))

##### 3.3.8.5. Unary and Postfix

**(Parse-Unary-Prefix)**
Tok(P) = op ∈ {"!", "-"}    Γ ⊢ ParseUnary(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, Unary(op, e))

**(Parse-Unary-Deref)**
IsOp(Tok(P), "*")    Γ ⊢ ParseUnary(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, Deref(e))

**(Parse-Unary-AddressOf)**
IsOp(Tok(P), "&")    Γ ⊢ ParsePlace(Advance(P)) ⇓ (P_1, p)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, AddressOf(p))

**(Parse-Unary-Move)**
IsKw(Tok(P), `move`)    Γ ⊢ ParsePlace(Advance(P)) ⇓ (P_1, p)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, MoveExpr(p))

**(Parse-Unary-Widen)**
IsKw(Tok(P), `widen`)    Γ ⊢ ParseUnary(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, Unary(`widen`, e))

**(Parse-Unary-Postfix)**
Γ ⊢ ParsePostfix(P) ⇓ (P_1, e)
──────────────────────────────────────────────
Γ ⊢ ParseUnary(P) ⇓ (P_1, e)

**(Parse-Postfix)**
Γ ⊢ ParsePrimary(P) ⇓ (P_1, e_0)    Γ ⊢ ParsePostfixTail(P_1, e_0) ⇓ (P_2, e)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePostfix(P) ⇓ (P_2, e)

##### 3.3.8.6. Primary Expressions

**(Parse-Comptime-Unsupported)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `comptime`    IsPunc(Tok(Advance(P)), "{")    Γ ⊢ Emit(Code(Unsupported-Construct))    Γ ⊢ SyncStmt(P) ⇓ P_1
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, ErrorExpr(SpanBetween(P, P_1)))

**(Parse-Literal-Expr)**
Tok(P).kind ∈ {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
───────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P), Literal(Tok(P)))

**(Parse-Null-Ptr)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "::")    Tok(Advance(Advance(P))).kind = NullLiteral    IsPunc(Tok(Advance(Advance(Advance(P)))), "(")    IsPunc(Tok(Advance(Advance(Advance(Advance(P))))), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(Advance(Advance(Advance(Advance(P))))), PtrNullExpr)

**(Parse-Alloc-Implicit)**
IsOp(Tok(P), "^")    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, AllocExpr(⊥, e))


**(Parse-Identifier-Expr)**
IsIdent(Tok(P))    ¬ IsOp(Tok(Advance(P)), "::")    ¬ IsOp(Tok(Advance(P)), "@")    ¬ IsPunc(Tok(Advance(P)), "{")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P), Identifier(Lexeme(Tok(P))))

**(Parse-Qualified-Generic-Unsupported)**
Γ ⊢ ParseQualifiedHead(P) ⇓ (P_1, path, name)    IsOp(Tok(P_1), "<")    P_1' = SkipAngles(P_1)    Γ ⊢ Emit(Code(Unsupported-Construct))    Γ ⊢ SyncStmt(P_1') ⇓ P_2
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_2, ErrorExpr(SpanBetween(P, P_2)))

**(Parse-Qualified-Name)**
Γ ⊢ ParseQualifiedHead(P) ⇓ (P_1, path, name)    Tok(P_1) ∉ {Punctuator("("), Punctuator("{")}    ¬ IsOp(Tok(P_1), "@")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, QualifiedName(path, name))

**(Parse-Qualified-Apply-Paren)**
Γ ⊢ ParseQualifiedHead(P) ⇓ (P_1, path, name)    IsPunc(Tok(P_1), "(")    Γ ⊢ ParseArgList(Advance(P_1)) ⇓ (P_2, args)    IsPunc(Tok(P_2), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_2), QualifiedApply(path, name, Paren(args)))

**(Parse-Qualified-Apply-Brace)**
Γ ⊢ ParseQualifiedHead(P) ⇓ (P_1, path, name)    IsPunc(Tok(P_1), "{")    Γ ⊢ ParseFieldInitList(Advance(P_1)) ⇓ (P_2, fields)    IsPunc(Tok(P_2), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_2), QualifiedApply(path, name, Brace(fields)))

**(Parse-Parenthesized-Expr)**
IsPunc(Tok(P), "(")    ¬ TupleParen(P)    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_1), e)

**(Parse-Tuple-Literal)**
IsPunc(Tok(P), "(")    TupleParen(P)    Γ ⊢ ParseTupleExprElems(Advance(P)) ⇓ (P_1, elems)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_1), TupleExpr(elems))

**(Parse-Array-Literal)**
IsPunc(Tok(P), "[")    Γ ⊢ ParseExprList(Advance(P)) ⇓ (P_1, elems)    IsPunc(Tok(P_1), "]")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_1), ArrayExpr(elems))

**(Parse-Record-Literal-ModalState)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    IsOp(Tok(P_1), "@")    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, state)    IsPunc(Tok(P_2), "{")    Γ ⊢ ParseFieldInitList(Advance(P_2)) ⇓ (P_3, fields)    IsPunc(Tok(P_3), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_3), RecordExpr(ModalStateRef(path, state), fields))

**(Parse-Record-Literal)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    |path| = 1    IsPunc(Tok(P_1), "{")    Γ ⊢ ParseFieldInitList(Advance(P_1)) ⇓ (P_2, fields)    IsPunc(Tok(P_2), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_2), RecordExpr(TypePath(path), fields))


RuleSet(ParsePrimary_NoBrace) = RuleSet(ParsePrimary) \ {Parse-Record-Literal, Parse-Record-Literal-ModalState, Parse-Qualified-Apply-Brace}
RuleSet(ParsePostfix_NoBrace) = RuleSet(ParsePostfix) with ParsePrimary replaced by ParsePrimary_NoBrace
RuleSet(ParseUnary_NoBrace) = RuleSet(ParseUnary) with ParsePostfix replaced by ParsePostfix_NoBrace
RuleSet(ParseLogicalOr_NoBrace) = RuleSet(ParseLogicalOr) with ParseLogicalAnd replaced by ParseLogicalAnd_NoBrace
RuleSet(ParseLogicalAnd_NoBrace) = RuleSet(ParseLogicalAnd) with ParseComparison replaced by ParseComparison_NoBrace
RuleSet(ParseComparison_NoBrace) = RuleSet(ParseComparison) with ParseBitOr replaced by ParseBitOr_NoBrace
RuleSet(ParseBitOr_NoBrace) = RuleSet(ParseBitOr) with ParseBitXor replaced by ParseBitXor_NoBrace
RuleSet(ParseBitXor_NoBrace) = RuleSet(ParseBitXor) with ParseBitAnd replaced by ParseBitAnd_NoBrace
RuleSet(ParseBitAnd_NoBrace) = RuleSet(ParseBitAnd) with ParseShift replaced by ParseShift_NoBrace
RuleSet(ParseShift_NoBrace) = RuleSet(ParseShift) with ParseAdd replaced by ParseAdd_NoBrace
RuleSet(ParseAdd_NoBrace) = RuleSet(ParseAdd) with ParseMul replaced by ParseMul_NoBrace
RuleSet(ParseMul_NoBrace) = RuleSet(ParseMul) with ParsePower replaced by ParsePower_NoBrace
RuleSet(ParseRange_NoBrace) = RuleSet(ParseRange) with ParseLogicalOr replaced by ParseLogicalOr_NoBrace
RuleSet(ParseExpr_NoBrace) = RuleSet(ParseExpr) with ParseRange replaced by ParseRange_NoBrace

Γ ⊢ ParseRange_NoBrace(P) ⇓ (P_1, e)
───────────────────────────────────────────────
Γ ⊢ ParseExpr_NoBrace(P) ⇓ (P_1, e)

**(Parse-If-Expr)**
IsKw(Tok(P), `if`)    Γ ⊢ ParseExpr_NoBrace(Advance(P)) ⇓ (P_1, c)    Γ ⊢ ParseBlock(P_1) ⇓ (P_2, b1)    Γ ⊢ ParseElseOpt(P_2) ⇓ (P_3, b2)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_3, IfExpr(c, b1, b2))

**(Parse-Match-Expr)**
IsKw(Tok(P), `match`)    Γ ⊢ ParseExpr_NoBrace(Advance(P)) ⇓ (P_1, e)    IsPunc(Tok(P_1), "{")    Γ ⊢ ParseMatchArms(Advance(P_1)) ⇓ (P_2, arms)    IsPunc(Tok(P_2), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_2), MatchExpr(e, arms))

**(Parse-Loop-Expr)**
IsKw(Tok(P), `loop`)    Γ ⊢ ParseLoopTail(Advance(P)) ⇓ (P_1, loop)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, loop)

**(Parse-Block-Expr)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseBlock(P) ⇓ (P_1, b)
──────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, b)

**(Parse-Unsafe-Expr)**
IsKw(Tok(P), `unsafe`)    Γ ⊢ ParseBlock(Advance(P)) ⇓ (P_1, b)
──────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_1, UnsafeBlockExpr(b))

**(Parse-Transmute-Expr-ShiftSplit)**
IsKw(Tok(P), `transmute`)    IsOp(Tok(Advance(P)), "::")    IsOp(Tok(Advance(Advance(P))), "<")    Γ ⊢ ParseType(Advance(Advance(Advance(P)))) ⇓ (P_1, t1)    IsPunc(Tok(P_1), ",")    Γ ⊢ ParseType(Advance(P_1)) ⇓ (P_2, t2)    IsOp(Tok(P_2), ">>")    P_2' = SplitShiftR(P_2)    IsOp(Tok(P_2'), ">")    IsPunc(Tok(Advance(P_2')), "(")    Γ ⊢ ParseExpr(Advance(Advance(P_2'))) ⇓ (P_3, e)    IsPunc(Tok(P_3), ")")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_3), TransmuteExpr(t1, t2, e))

**(Parse-Transmute-Expr)**
IsKw(Tok(P), `transmute`)    IsOp(Tok(Advance(P)), "::")    IsOp(Tok(Advance(Advance(P))), "<")    Γ ⊢ ParseType(Advance(Advance(Advance(P)))) ⇓ (P_1, t1)    IsPunc(Tok(P_1), ",")    Γ ⊢ ParseType(Advance(P_1)) ⇓ (P_2, t2)    IsOp(Tok(P_2), ">")    IsPunc(Tok(Advance(P_2)), "(")    Γ ⊢ ParseExpr(Advance(Advance(P_2))) ⇓ (P_3, e)    IsPunc(Tok(P_3), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (Advance(P_3), TransmuteExpr(t1, t2, e))


**(Parse-Primary-Err)**
c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Γ ⊢ SyncStmt(P_1) ⇓ P_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePrimary(P) ⇓ (P_2, ErrorExpr(SpanBetween(P, P_2)))

##### 3.3.8.7. Expression Helper Parsing Rules

**Postfix Tail.**

**(Parse-PostfixTail-Stop)**
Tok(P) ∉ PostfixStart
──────────────────────────────────────────────
Γ ⊢ ParsePostfixTail(P, e) ⇓ (P, e)

**(Parse-PostfixTail-Cons)**
Tok(P) ∈ PostfixStart    Γ ⊢ PostfixStep(P, e) ⇓ (P_1, e_1)    Γ ⊢ ParsePostfixTail(P_1, e_1) ⇓ (P_2, e_2)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePostfixTail(P, e) ⇓ (P_2, e_2)

PostfixStart = {Punctuator("."), Punctuator("["), Punctuator("("), Operator("~>"), Operator("?")}

**(Postfix-Field)**
IsPunc(Tok(P), ".")    IsIdent(Tok(Advance(P)))    name = Lexeme(Tok(Advance(P)))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(Advance(P)), FieldAccess(e, name))

**(Postfix-TupleIndex)**
IsPunc(Tok(P), ".")    t = Tok(Advance(P))    t.kind = IntLiteral    idx = IntValue(t)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(Advance(P)), TupleAccess(e, idx))

**(Postfix-Index)**
IsPunc(Tok(P), "[")    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, idx)    IsPunc(Tok(P_1), "]")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(P_1), IndexAccess(e, idx))

**(Postfix-Call)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseArgList(Advance(P)) ⇓ (P_1, args)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(P_1), Call(e, args))

**(Postfix-MethodCall)**
IsOp(Tok(P), "~>")    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, name)    IsPunc(Tok(P_1), "(")    Γ ⊢ ParseArgList(Advance(P_1)) ⇓ (P_2, args)    IsPunc(Tok(P_2), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(P_2), MethodCall(e, name, args))

**(Postfix-Propagate)**
IsOp(Tok(P), "?")
──────────────────────────────────────────────────────────────
Γ ⊢ PostfixStep(P, e) ⇓ (Advance(P), Propagate(e))

**Argument Lists.**

**(Parse-ArgList-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseArgList(P) ⇓ (P, [])

**(Parse-ArgList-Cons)**
Γ ⊢ ParseArg(P) ⇓ (P_1, a)    Γ ⊢ ParseArgTail(P_1, [a]) ⇓ (P_2, args)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseArgList(P) ⇓ (P_2, args)

**(Parse-Arg)**
Γ ⊢ ParseArgMoveOpt(P) ⇓ (P_1, moved)    Γ ⊢ ParseExpr(P_1) ⇓ (P_2, e)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseArg(P) ⇓ (P_2, ⟨moved, e, SpanBetween(P, P_2)⟩)

**(Parse-ArgMoveOpt-None)**
¬ IsKw(Tok(P), `move`)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseArgMoveOpt(P) ⇓ (P, false)

**(Parse-ArgMoveOpt-Yes)**
IsKw(Tok(P), `move`)
──────────────────────────────────────────────────────
Γ ⊢ ParseArgMoveOpt(P) ⇓ (Advance(P), true)

**Expression Lists.**

**(Parse-ExprList-Cons)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)    Γ ⊢ ParseExprListTail(P_1, [e]) ⇓ (P_2, es)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseExprList(P) ⇓ (P_2, es)

**(Parse-ExprList-Empty)**
Tok(P) ∈ {Punctuator(")"), Punctuator("]")}    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseExprList(P) ⇓ (P, [])

**Tuple Expression Elements.**

**(Parse-TupleExprElems-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseTupleExprElems(P) ⇓ (P, [])

**(Parse-TupleExprElems-Single)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)    IsPunc(Tok(P_1), ";")
────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleExprElems(P) ⇓ (Advance(P_1), [e])

**(Parse-TupleExprElems-TrailingComma)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleExprElems(P) ⇓ (Advance(P_1), [e])

**(Parse-TupleExprElems-Many)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e_1)    IsPunc(Tok(P_1), ",")    Γ ⊢ ParseExpr(Advance(P_1)) ⇓ (P_2, e_2)    Γ ⊢ ParseExprListTail(P_2, [e_2]) ⇓ (P_3, es)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTupleExprElems(P) ⇓ (P_3, [e_1] ++ es)

**Tuple vs Parenthesized Disambiguation.**
ParenDelta(Punctuator("(")) = 1
ParenDelta(Punctuator(")")) = -1
ParenDelta(t) = 0 if t.kind ∉ {Punctuator("("), Punctuator(")")}

TupleScan(P, d) ⇓ b
Tok(P) = EOF
────────────────────────────────────────
TupleScan(P, d) ⇓ false
Tok(P) = Punctuator(")") ∧ d = 1
────────────────────────────────────────────
TupleScan(P, d) ⇓ false
Tok(P) ∈ {Punctuator(","), Punctuator(";")} ∧ d = 1
──────────────────────────────────────────────
TupleScan(P, d) ⇓ true
Tok(P) ∉ {Punctuator(")"), Punctuator(","), Punctuator(";")}    TupleScan(Advance(P), d + ParenDelta(Tok(P))) ⇓ b
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
TupleScan(P, d) ⇓ b

TupleParen(P) ⇔ IsPunc(Tok(P), "(") ∧ (IsPunc(Tok(Advance(P)), ")") ∨ TupleScan(Advance(P), 1) ⇓ true)
**Field Initializers.**

**(Parse-FieldInitList-Empty)**
IsPunc(Tok(P), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInitList(P) ⇓ (P, [])

**(Parse-FieldInitList-Cons)**
Γ ⊢ ParseFieldInit(P) ⇓ (P_1, f)    Γ ⊢ ParseFieldInitTail(P_1, [f]) ⇓ (P_2, fs)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInitList(P) ⇓ (P_2, fs)


**(Parse-FieldInit-Explicit)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    IsPunc(Tok(P_1), ":")    Γ ⊢ ParseExpr(Advance(P_1)) ⇓ (P_2, e)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInit(P) ⇓ (P_2, ⟨name, e⟩)

**(Parse-FieldInit-Shorthand)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    ¬ IsPunc(Tok(P_1), ":")
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInit(P) ⇓ (P_1, ⟨name, Identifier(name)⟩)

**Match Arms.**

**(Parse-MatchArms-Cons)**
Γ ⊢ ParseMatchArm(P) ⇓ (P_1, a)    Γ ⊢ ParseMatchArmsTail(P_1, [a]) ⇓ (P_2, arms)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMatchArms(P) ⇓ (P_2, arms)

**(Parse-MatchArm)**
Γ ⊢ ParsePattern(P) ⇓ (P_1, pat)    Γ ⊢ ParseGuardOpt(P_1) ⇓ (P_2, guard_opt)    IsOp(Tok(P_2), "=>")    Γ ⊢ ParseArmBody(Advance(P_2)) ⇓ (P_3, body)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMatchArm(P) ⇓ (P_3, ⟨pat, guard_opt, body⟩)

**(Parse-MatchArmsTail-End)**
Tok(P) = Punctuator("}")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseMatchArmsTail(P, xs) ⇓ (P, xs)

**(Parse-MatchArmsTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseMatchArm(Advance(P)) ⇓ (P_1, a)    Γ ⊢ ParseMatchArmsTail(P_1, xs ++ [a]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseMatchArmsTail(P, xs) ⇓ (P_2, ys)

**(Parse-GuardOpt-None)**
¬ IsKw(Tok(P), `if`)
──────────────────────────────────────────────
Γ ⊢ ParseGuardOpt(P) ⇓ (P, ⊥)

**(Parse-GuardOpt-Yes)**
IsKw(Tok(P), `if`)    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseGuardOpt(P) ⇓ (P_1, e)

**(Parse-ArmBody-Block)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseBlock(P) ⇓ (P_1, b)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseArmBody(P) ⇓ (P_1, b)

**(Parse-ArmBody-Expr)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)
──────────────────────────────────────────────
Γ ⊢ ParseArmBody(P) ⇓ (P_1, e)

**Argument and Expression Tail Lists.**

**(Parse-ArgTail-End)**
IsPunc(Tok(P), ")")
───────────────────────────────────────────
Γ ⊢ ParseArgTail(P, xs) ⇓ (P, xs)

**(Parse-ArgTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseArgTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-ArgTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseArg(Advance(P)) ⇓ (P_1, a)    Γ ⊢ ParseArgTail(P_1, xs ++ [a]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseArgTail(P, xs) ⇓ (P_2, ys)

**(Parse-ExprListTail-End)**
Tok(P) ∈ {Punctuator(")"), Punctuator("]"), Punctuator("}")}
──────────────────────────────────────────────────────────────
Γ ⊢ ParseExprListTail(P, xs) ⇓ (P, xs)

**(Parse-ExprListTail-TrailingComma)**
IsPunc(Tok(P), ",")    Tok(Advance(P)) ∈ {Punctuator(")"), Punctuator("]"), Punctuator("}")}    Γ ⊢ Emit(Code(Unsupported-Construct))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseExprListTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-ExprListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)    Γ ⊢ ParseExprListTail(P_1, xs ++ [e]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseExprListTail(P, xs) ⇓ (P_2, ys)

**(Parse-FieldInitTail-End)**
IsPunc(Tok(P), "}")
──────────────────────────────────────────────
Γ ⊢ ParseFieldInitTail(P, xs) ⇓ (P, xs)

**(Parse-FieldInitTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInitTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-FieldInitTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseFieldInit(Advance(P)) ⇓ (P_1, f)    Γ ⊢ ParseFieldInitTail(P_1, xs ++ [f]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldInitTail(P, xs) ⇓ (P_2, ys)
**Loop Tail.**

**(Parse-LoopTail-Infinite)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseBlock(P) ⇓ (P_1, b)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseLoopTail(P) ⇓ (P_1, LoopInfinite(b))

**(Parse-LoopTail-Iter)**
Γ ⊢ TryParsePatternIn(P) ⇓ (P_1, pat)    Γ ⊢ ParseTypeAnnotOpt(P_1) ⇓ (P_2, ty_opt)    IsIdent(Tok(P_2))    Lexeme(Tok(P_2)) = `in`    Γ ⊢ ParseExpr_NoBrace(Advance(P_2)) ⇓ (P_3, iter)    Γ ⊢ ParseBlock(P_3) ⇓ (P_4, body)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseLoopTail(P) ⇓ (P_4, LoopIter(pat, ty_opt, iter, body))

**(Parse-LoopTail-Cond)**
Γ ⊢ ParseExpr_NoBrace(P) ⇓ (P_1, cond)    Γ ⊢ ParseBlock(P_1) ⇓ (P_2, body)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseLoopTail(P) ⇓ (P_2, LoopConditional(cond, body))

**(TryParsePatternIn-Ok)**
P_c = Clone(P)    Γ ⊢ ParsePattern(P_c) ⇓ (P_1, pat)    Γ ⊢ ParseTypeAnnotOpt(P_1) ⇓ (P_2, ty_opt)    IsIdent(Tok(P_2))    Lexeme(Tok(P_2)) = `in`    P' = MergeDiag(P, P_2, P_1)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TryParsePatternIn(P) ⇓ (P', pat)

**(TryParsePatternIn-Fail)**
P_c = Clone(P)    ¬ (Γ ⊢ ParsePattern(P_c) ⇓ (P_1, pat) ∧ Γ ⊢ ParseTypeAnnotOpt(P_1) ⇓ (P_2, ty_opt) ∧ IsIdent(Tok(P_2)) ∧ Lexeme(Tok(P_2)) = `in`)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TryParsePatternIn(P) ↑

**Else Clause.**

**(Parse-ElseOpt-None)**
¬ IsKw(Tok(P), `else`)
──────────────────────────────────────────────
Γ ⊢ ParseElseOpt(P) ⇓ (P, ⊥)

**(Parse-ElseOpt-If)**
IsKw(Tok(P), `else`)    IsKw(Tok(Advance(P)), `if`)    Γ ⊢ ParsePrimary(Advance(P)) ⇓ (P_1, e)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseElseOpt(P) ⇓ (P_1, e)

**(Parse-ElseOpt-Block)**
IsKw(Tok(P), `else`)    Γ ⊢ ParseBlock(Advance(P)) ⇓ (P_1, b)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseElseOpt(P) ⇓ (P_1, b)

**Optional Expression.**

**(Parse-ExprOpt-None)**
Tok(P) ∈ {Punctuator(";"), Punctuator("}"), Newline, EOF}
──────────────────────────────────────────────────────────────
Γ ⊢ ParseExprOpt(P) ⇓ (P, ⊥)

**(Parse-ExprOpt-Yes)**
Tok(P) ∉ {Punctuator(";"), Punctuator("}"), Newline, EOF}    Γ ⊢ ParseExpr(P) ⇓ (P_1, e)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseExprOpt(P) ⇓ (P_1, e)

**Place Expressions.**

IsPlace(e) ⇔ e ∈ {Identifier(_), FieldAccess(_, _), TupleAccess(_, _), IndexAccess(_, _)} ∨ (∃ p. e = Deref(p) ∧ IsPlace(p))
PlaceExprParseErr = Parse-Syntax-Err

**(Parse-Place-Deref)**
IsOp(Tok(P), "*")    Γ ⊢ ParsePlace(Advance(P)) ⇓ (P_1, p)
────────────────────────────────────────────────────────────────
Γ ⊢ ParsePlace(P) ⇓ (P_1, Deref(p))

**(Parse-Place-Postfix)**
Γ ⊢ ParsePostfix(P) ⇓ (P_1, e)    IsPlace(e)
──────────────────────────────────────────────────────────────
Γ ⊢ ParsePlace(P) ⇓ (P_1, e)

**(Parse-Place-Err)**
Γ ⊢ ParsePostfix(P) ⇓ (P_1, e)    ¬ IsPlace(e)    c = Code(PlaceExprParseErr)    Γ ⊢ Emit(c, Tok(P).span)    Γ ⊢ SyncStmt(P_1) ⇓ P_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePlace(P) ⇓ (P_2, ErrorExpr(SpanBetween(P, P_2)))

#### 3.3.9. Pattern Parsing

**(Parse-Pattern)**
Γ ⊢ ParsePatternRange(P) ⇓ (P_1, pat)
───────────────────────────────────────────────
Γ ⊢ ParsePattern(P) ⇓ (P_1, pat)

**(Parse-Pattern-Err)**
c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P).span)
────────────────────────────────────────────────────────────────
Γ ⊢ ParsePattern(P) ⇓ (P, WildcardPattern)

**(Parse-Pattern-Range-None)**
Γ ⊢ ParsePatternAtom(P) ⇓ (P_1, p)    ¬ (IsOp(Tok(P_1), "..") ∨ IsOp(Tok(P_1), "..="))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternRange(P) ⇓ (P_1, p)

**(Parse-Pattern-Range)**
Γ ⊢ ParsePatternAtom(P) ⇓ (P_1, p_0)    Tok(P_1) = op ∈ {"..", "..="}    Γ ⊢ ParsePatternAtom(Advance(P_1)) ⇓ (P_2, p_1)    kind = (`Exclusive` if op = ".." else `Inclusive`)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternRange(P) ⇓ (P_2, RangePattern(kind, p_0, p_1))

**(Parse-Pattern-Literal)**
Tok(P).kind ∈ {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
───────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (Advance(P), LiteralPattern(Tok(P)))

**(Parse-Pattern-Wildcard)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = "_"
──────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (Advance(P), WildcardPattern)

**(Parse-Pattern-Typed)**
IsIdent(Tok(P))    IsPunc(Tok(Advance(P)), ":")    Γ ⊢ ParseType(Advance(Advance(P))) ⇓ (P_1, ty)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (P_1, TypedPattern(Lexeme(Tok(P)), ty))

**(Parse-Pattern-Identifier)**
IsIdent(Tok(P))
────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (Advance(P), IdentifierPattern(Lexeme(Tok(P))))

**(Parse-Pattern-Tuple)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseTuplePatternElems(Advance(P)) ⇓ (P_1, elems)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (Advance(P_1), TuplePattern(elems))

**(Parse-Pattern-Record)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    IsPunc(Tok(P_1), "{")    Γ ⊢ ParseFieldPatternList(Advance(P_1)) ⇓ (P_2, fields)    IsPunc(Tok(P_2), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (Advance(P_2), RecordPattern(path, fields))

**(Parse-Pattern-Enum)**
Γ ⊢ ParseTypePath(P) ⇓ (P_1, path)    IsOp(Tok(P_1), "::")    Γ ⊢ ParseIdent(Advance(P_1)) ⇓ (P_2, name)    Γ ⊢ ParseEnumPatternPayloadOpt(P_2) ⇓ (P_3, payload_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (P_3, EnumPattern(path, name, payload_opt))

**(Parse-Pattern-Modal)**
IsOp(Tok(P), "@")    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, name)    Γ ⊢ ParseModalPatternPayloadOpt(P_1) ⇓ (P_2, fields_opt)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternAtom(P) ⇓ (P_2, ModalPattern(name, fields_opt))

##### 3.3.9.1. Pattern Helper Parsing Rules

**Pattern Lists.**

**(Parse-PatternList-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParsePatternList(P) ⇓ (P, [])

**(Parse-PatternList-Cons)**
Γ ⊢ ParsePattern(P) ⇓ (P_1, p)    Γ ⊢ ParsePatternListTail(P_1, [p]) ⇓ (P_2, ps)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternList(P) ⇓ (P_2, ps)

**(Parse-PatternListTail-End)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParsePatternListTail(P, xs) ⇓ (P, xs)

**(Parse-PatternListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternListTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-PatternListTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParsePattern(Advance(P)) ⇓ (P_1, p)    Γ ⊢ ParsePatternListTail(P_1, xs ++ [p]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParsePatternListTail(P, xs) ⇓ (P_2, ys)

**Tuple Pattern Elements.**

**(Parse-TuplePatternElems-Empty)**
IsPunc(Tok(P), ")")
──────────────────────────────────────────────
Γ ⊢ ParseTuplePatternElems(P) ⇓ (P, [])

**(Parse-TuplePatternElems-Single)**
Γ ⊢ ParsePattern(P) ⇓ (P_1, p)    IsPunc(Tok(P_1), ";")
────────────────────────────────────────────────────────────────
Γ ⊢ ParseTuplePatternElems(P) ⇓ (Advance(P_1), [p])

**(Parse-TuplePatternElems-TrailingComma)**
Γ ⊢ ParsePattern(P) ⇓ (P_1, p)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTuplePatternElems(P) ⇓ (Advance(P_1), [p])

**(Parse-TuplePatternElems-Many)**
Γ ⊢ ParsePattern(P) ⇓ (P_1, p_1)    IsPunc(Tok(P_1), ",")    Γ ⊢ ParsePattern(Advance(P_1)) ⇓ (P_2, p_2)    Γ ⊢ ParsePatternListTail(P_2, [p_2]) ⇓ (P_3, ps)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseTuplePatternElems(P) ⇓ (P_3, [p_1] ++ ps)

**Field Pattern Lists.**

**(Parse-FieldPatternList-Empty)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternList(P) ⇓ (P, [])

**(Parse-FieldPatternList-Cons)**
Γ ⊢ ParseFieldPattern(P) ⇓ (P_1, f)    Γ ⊢ ParseFieldPatternTail(P_1, [f]) ⇓ (P_2, fs)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternList(P) ⇓ (P_2, fs)

**(Parse-FieldPattern)**
Γ ⊢ ParseIdent(P) ⇓ (P_1, name)    Γ ⊢ ParseFieldPatternTailOpt(P_1, name) ⇓ (P_2, pat_opt)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPattern(P) ⇓ (P_2, ⟨name, pat_opt, SpanBetween(P, P_2)⟩)

**(Parse-FieldPatternTailOpt-None)**
¬ IsPunc(Tok(P), ":")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternTailOpt(P, name) ⇓ (P, ⊥)

**(Parse-FieldPatternTailOpt-Yes)**
IsPunc(Tok(P), ":")    Γ ⊢ ParsePattern(Advance(P)) ⇓ (P_1, pat)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternTailOpt(P, name) ⇓ (P_1, pat)

**(Parse-FieldPatternTail-End)**
IsPunc(Tok(P), "}")
────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternTail(P, xs) ⇓ (P, xs)

**(Parse-FieldPatternTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    Γ ⊢ Emit(Code(Unsupported-Construct))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternTail(P, xs) ⇓ (Advance(P), xs)

**(Parse-FieldPatternTail-Comma)**
IsPunc(Tok(P), ",")    Γ ⊢ ParseFieldPattern(Advance(P)) ⇓ (P_1, f)    Γ ⊢ ParseFieldPatternTail(P_1, xs ++ [f]) ⇓ (P_2, ys)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseFieldPatternTail(P, xs) ⇓ (P_2, ys)
**Enum Pattern Payload.**

**(Parse-EnumPatternPayloadOpt-None)**
Tok(P) ∉ {Punctuator("("), Punctuator("{")}
──────────────────────────────────────────────────────────────
Γ ⊢ ParseEnumPatternPayloadOpt(P) ⇓ (P, ⊥)

**(Parse-EnumPatternPayloadOpt-Tuple)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseTuplePatternElems(Advance(P)) ⇓ (P_1, ps)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseEnumPatternPayloadOpt(P) ⇓ (Advance(P_1), TuplePayloadPattern(ps))

**(Parse-EnumPatternPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseFieldPatternList(Advance(P)) ⇓ (P_1, fs)    IsPunc(Tok(P_1), "}")
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseEnumPatternPayloadOpt(P) ⇓ (Advance(P_1), RecordPayloadPattern(fs))

**Modal Pattern Payload.**

**(Parse-ModalPatternPayloadOpt-None)**
¬ IsPunc(Tok(P), "{")
──────────────────────────────────────────────────────────────
Γ ⊢ ParseModalPatternPayloadOpt(P) ⇓ (P, ⊥)

**(Parse-ModalPatternPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseFieldPatternList(Advance(P)) ⇓ (P_1, fs)    IsPunc(Tok(P_1), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModalPatternPayloadOpt(P) ⇓ (Advance(P_1), ModalRecordPayload(fs))

#### 3.3.10. Statement and Block Parsing

**Statement Terminators.**
StmtTerm = {Punctuator(";"), Newline}
Terminates(t) ⇔ t ∈ StmtTerm

**(Parse-Statement)**
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, s)    Γ ⊢ ConsumeTerminatorOpt(P_1, s) ⇓ P_2
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmt(P) ⇓ (P_2, s)

**(Parse-Statement-Err)**
c = Code(Parse-Syntax-Err)    Γ ⊢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Γ ⊢ SyncStmt(P_1) ⇓ P_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmt(P) ⇓ (P_2, ErrorStmt(SpanBetween(P, P_2)))


**(Parse-Binding-Stmt)**
Tok(P) ∈ {Keyword(`let`), Keyword(`var`)}    Γ ⊢ ParseBindingAfterLetVar(P) ⇓ (P_1, bind)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, LetOrVarStmt(P, bind))

**(Parse-Shadow-Stmt)**
IsKw(Tok(P), `shadow`)    Tok(Advance(P)) ∈ {Keyword(`let`), Keyword(`var`)}    Γ ⊢ ParseShadowBinding(Advance(P)) ⇓ (P_1, s)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, s)

**(Parse-Assign-Stmt)**
Γ ⊢ ParsePlace(P) ⇓ (P_1, p)    Tok(P_1) ∈ {Operator("="), Operator("+="), Operator("-="), Operator("*="), Operator("/="), Operator("%=")}    Γ ⊢ ParseExpr(Advance(P_1)) ⇓ (P_2, e)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_2, AssignOrCompound(P_1, p, e))

**(Parse-Return-Stmt)**
IsKw(Tok(P), `return`)    Γ ⊢ ParseExprOpt(Advance(P)) ⇓ (P_1, e_opt)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, ReturnStmt(e_opt))

**(Parse-Result-Stmt)**
IsKw(Tok(P), `result`)    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, ResultStmt(e))

**(Parse-Break-Stmt)**
IsKw(Tok(P), `break`)    Γ ⊢ ParseExprOpt(Advance(P)) ⇓ (P_1, e_opt)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, BreakStmt(e_opt))

**(Parse-Continue-Stmt)**
IsKw(Tok(P), `continue`)
──────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (Advance(P), ContinueStmt)

**(Parse-Unsafe-Block)**
IsKw(Tok(P), `unsafe`)    Γ ⊢ ParseBlock(Advance(P)) ⇓ (P_1, b)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, UnsafeBlockStmt(b))

**(Parse-Defer-Stmt)**
IsKw(Tok(P), `defer`)    Γ ⊢ ParseBlock(Advance(P)) ⇓ (P_1, b)
──────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, DeferStmt(b))

**(Parse-Region-Opts-None)**
¬ IsPunc(Tok(P), "(")
────────────────────────────────────────────────
Γ ⊢ ParseRegionOptsOpt(P) ⇓ (P, ⊥)

**(Parse-Region-Opts-Some)**
IsPunc(Tok(P), "(")    Γ ⊢ ParseExpr(Advance(P)) ⇓ (P_1, e)    IsPunc(Tok(P_1), ")")
────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseRegionOptsOpt(P) ⇓ (Advance(P_1), e)

**(Parse-Region-Alias-None)**
¬ IsKw(Tok(P), `as`)
──────────────────────────────────────────────
Γ ⊢ ParseRegionAliasOpt(P) ⇓ (P, ⊥)

**(Parse-Region-Alias-Some)**
IsKw(Tok(P), `as`)    Γ ⊢ ParseIdent(Advance(P)) ⇓ (P_1, name)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseRegionAliasOpt(P) ⇓ (P_1, name)

**(Parse-Region-Stmt)**
IsKw(Tok(P), `region`)    Γ ⊢ ParseRegionOptsOpt(Advance(P)) ⇓ (P_1, opts_opt)    Γ ⊢ ParseRegionAliasOpt(P_1) ⇓ (P_2, alias_opt)    Γ ⊢ ParseBlock(P_2) ⇓ (P_3, b)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_3, RegionStmt(opts_opt, alias_opt, b))

**(Parse-Frame-Stmt)**
IsKw(Tok(P), `frame`)    Γ ⊢ ParseBlock(Advance(P)) ⇓ (P_1, b)
────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, FrameStmt(⊥, b))

**(Parse-Frame-Explicit)**
IsIdent(Tok(P))    IsPunc(Tok(Advance(P)), ".")    IsKw(Tok(Advance(Advance(P))), `frame`)    name = Lexeme(Tok(P))    Γ ⊢ ParseBlock(Advance(Advance(Advance(P)))) ⇓ (P_1, b)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, FrameStmt(name, b))

**(Parse-Expr-Stmt)**
Γ ⊢ ParseExpr(P) ⇓ (P_1, e)
──────────────────────────────────────────────
Γ ⊢ ParseStmtCore(P) ⇓ (P_1, ExprStmt(e))

**Block Parsing.**

**(Parse-Block)**
IsPunc(Tok(P), "{")    Γ ⊢ ParseStmtSeq(Advance(P)) ⇓ (P_1, stmts, tail)    IsPunc(Tok(P_1), "}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseBlock(P) ⇓ (Advance(P_1), BlockExpr(stmts, tail))

##### 3.3.10.1. Statement Helper Parsing Rules
**Terminator Consumption.**

ReqTerm(s) ⇔ s ∈ {LetStmt(_), VarStmt(_), ShadowLetStmt(_), ShadowVarStmt(_), AssignStmt(_, _), CompoundAssignStmt(_, _, _), ExprStmt(_)}

**(ConsumeTerminatorOpt-Req-Yes)**
ReqTerm(s)    IsTerm(Tok(P))
──────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorOpt(P, s) ⇓ Advance(P)

**(ConsumeTerminatorOpt-Req-No)**
ReqTerm(s)    ¬ IsTerm(Tok(P))    Emit(Code(Missing-Terminator-Err), Span = Tok(P).span)    Γ ⊢ SyncStmt(P) ⇓ P_1
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorOpt(P, s) ⇓ P_1

**(ConsumeTerminatorOpt-Opt-Yes)**
¬ ReqTerm(s)    IsTerm(Tok(P))
──────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorOpt(P, s) ⇓ Advance(P)

**(ConsumeTerminatorOpt-Opt-No)**
¬ ReqTerm(s)    ¬ IsTerm(Tok(P))
──────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorOpt(P, s) ⇓ P

**(ConsumeTerminatorReq-Yes)**
Tok(P) ∈ {Punctuator(";"), Newline}
──────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorReq(P) ⇓ Advance(P)

**(ConsumeTerminatorReq-No)**
Tok(P) ∉ {Punctuator(";"), Newline}    c = Code(Missing-Terminator-Err)    Γ ⊢ Emit(c, Tok(P).span)    Γ ⊢ SyncStmt(P) ⇓ P_1
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ConsumeTerminatorReq(P) ⇓ P_1

**Let/Var Statements.**

**(LetOrVarStmt-Let)**
Tok(P) = Keyword(`let`)
──────────────────────────────────────────────
Γ ⊢ LetOrVarStmt(P, bind) ⇓ LetStmt(bind)

**(LetOrVarStmt-Var)**
Tok(P) = Keyword(`var`)
──────────────────────────────────────────────
Γ ⊢ LetOrVarStmt(P, bind) ⇓ VarStmt(bind)

**Assignments.**

**(AssignOrCompound-Assign)**
Tok(P_1) = Operator("=")
──────────────────────────────────────────────
Γ ⊢ AssignOrCompound(P_1, p, e) ⇓ AssignStmt(p, e)

**(AssignOrCompound-Compound)**
Tok(P_1) = Operator(op)    op ∈ {"+=", "-=", "*=", "/=", "%="}
────────────────────────────────────────────────────────────────────────────
Γ ⊢ AssignOrCompound(P_1, p, e) ⇓ CompoundAssignStmt(p, op, e)

**Statement Sequences.**

**(ParseStmtSeq-End)**
Tok(P) = Punctuator("}")
──────────────────────────────────────────────
Γ ⊢ ParseStmtSeq(P) ⇓ (P, [], ⊥)

**(ParseStmtSeq-TailExpr)**
Tok(P) ∉ {Punctuator("}")}    Γ ⊢ ParseExpr(P) ⇓ (P_1, e)    Tok(P_1) = Punctuator("}")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtSeq(P) ⇓ (P_1, [], e)

**(ParseStmtSeq-Cons)**
Γ ⊢ ParseStmt(P) ⇓ (P_1, s)    Γ ⊢ ParseStmtSeq(P_1) ⇓ (P_2, ss, tail)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseStmtSeq(P) ⇓ (P_2, [s] ++ ss, tail)

#### 3.3.11. Doc Comment Association (Phase 1)

DocSeq(D) = D
ItemSeq(Items) = Items

**(Attach-Doc-Line)**
d.kind = LineDoc    Items = [i_1, …, i_k]    j = min{ t | d.span.end_offset ≤ i_t.span.start_offset }
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ AttachDoc(d, i_j)
LineDocTarget(d, Items) = i_j ⇔ Γ ⊢ AttachDoc(d, i_j)
LineDocsFor(i, D, Items) = [d ∈ D | d.kind = LineDoc ∧ LineDocTarget(d, Items) = i]

**(Attach-Doc-Module)**
d.kind = ModuleDoc
──────────────────────────────────────────────
Γ ⊢ AttachModuleDoc(d)

ModuleDocs(D) = [d ∈ D | d.kind = ModuleDoc]

#### 3.3.12. Error Recovery and Synchronization

**Statement Synchronization Set.**

SyncStmt = {Punctuator(";"), Newline, Punctuator("}"), EOF}

**Item Synchronization Set.**

SyncItem = {Keyword(`procedure`), Keyword(`record`), Keyword(`enum`), Keyword(`modal`), Keyword(`class`), Keyword(`type`), Keyword(`using`), Keyword(`let`), Keyword(`var`), Punctuator("}"), EOF}

**Type Synchronization Set.**

SyncType = {Punctuator(","), Punctuator(";"), Newline, Punctuator(")"), Punctuator("]"), Punctuator("}"), EOF}

**(Sync-Stmt-Stop)**
Tok(P) ∈ {Punctuator("}"), EOF}
──────────────────────────────────────────────
Γ ⊢ SyncStmt(P) ⇓ P

**(Sync-Stmt-Consume)**
Tok(P) ∈ {Punctuator(";"), Newline}
──────────────────────────────────────────────
Γ ⊢ SyncStmt(P) ⇓ Advance(P)

**(Sync-Stmt-Advance)**
Tok(P) ∉ SyncStmt
──────────────────────────────────────────────
Γ ⊢ SyncStmt(P) ⇓ SyncStmt(Advance(P))

**(Sync-Item-Stop)**
Tok(P) ∈ SyncItem
──────────────────────────────────────────────
Γ ⊢ SyncItem(P) ⇓ P

**(Sync-Item-Advance)**
Tok(P) ∉ SyncItem
──────────────────────────────────────────────
Γ ⊢ SyncItem(P) ⇓ SyncItem(Advance(P))

**(Sync-Type-Stop)**
Tok(P) ∈ {Punctuator(")"), Punctuator("]"), Punctuator("}"), EOF}
──────────────────────────────────────────────
Γ ⊢ SyncType(P) ⇓ P

**(Sync-Type-Consume)**
Tok(P) ∈ {Punctuator(","), Punctuator(";"), Newline}
──────────────────────────────────────────────
Γ ⊢ SyncType(P) ⇓ Advance(P)

**(Sync-Type-Advance)**
Tok(P) ∉ SyncType
──────────────────────────────────────────────
Γ ⊢ SyncType(P) ⇓ SyncType(Advance(P))

StmtParseErrRule = Parse-Statement-Err
ItemParseErrRule = Parse-Item-Err

#### 3.3.13. Diagnostics (Phase 1)

Phase1DiagRules = {Unsupported-Construct, Missing-Terminator-Err, Parse-Syntax-Err}

**(Parse-Syntax-Err)**
GenericParseRules = {Parse-Ident-Err, Parse-Type-Err, Parse-Pattern-Err, Parse-Primary-Err, Parse-Statement-Err, Parse-Item-Err}

r ∈ GenericParseRules    PremisesHold(r, P)
────────────────────────────────────────────────
Γ ⊢ Emit(Code(Parse-Syntax-Err))

### 3.4. Module Aggregation

#### 3.4.1. Inputs, Outputs, and Invariants

ModuleAggInputs(P) = ⟨P.modules, P.source_root, { CompilationUnit(DirOf(p, P.source_root)) | p ∈ P.modules }⟩
ModuleAggOutputs(P) = ⟨{ ParseModule(p, P.source_root) | p ∈ P.modules }, { NameMap(P, p) | p ∈ P.modules }, G, InitOrder, InitPlan⟩
ModuleMap(P, p) = M ⇔ Γ ⊢ ParseModules(P) ⇓ Ms ∧ M ∈ Ms ∧ M.path = p
PathOfModule(p) = [c_1, …, c_n] ⇔ p = c_1 :: ··· :: c_n
StringOfPath([c_1, …, c_n]) = Join("::", [c_1, …, c_n])
NameCollectAfterParse(P) ⇔ Γ ⊢ ParseModules(P) ⇓ Ms ∧ ∀ M ∈ Ms. ∃ N. Γ ⊢ CollectNames(M) ⇓ N
NameCollectOrderIndepRef = {"5.1.5"}
ForwardRefOrderRef = {"5.12"}

#### 3.4.2. Module Aggregation (`ParseModule`)

**Module Directory of a Module Path.**

**(DirOf-Root)**
p = A
──────────────────────────────────────────────
Γ ⊢ DirOf(p, S) = S

**(DirOf-Rel)**
p = c_1 :: ··· :: c_n    n ≥ 1
──────────────────────────────────────────────────────────────
Γ ⊢ DirOf(p, S) = S / c_1 / ··· / c_n

A = P.assembly.name

**ParseModule (Big-Step).**
U = CompilationUnit(DirOf(p, S))
U = [f_1, …, f_n]
ReadBytes : Path ⇀ Bytes

**(ReadBytes-Ok)**
read_ok(f) = B
──────────────────────────────────────────────
Γ ⊢ ReadBytes(f) ⇓ B

**(ReadBytes-Err)**
read_ok(f) ⇑    c = Code(ReadBytes-Err)
──────────────────────────────────────────────
Γ ⊢ ReadBytes(f) ⇑ c

Bytes(f) = B ⇔ Γ ⊢ ReadBytes(f) ⇓ B

**(ParseModule-Ok)**
∀ i, Γ ⊢ ReadBytes(f_i) ⇓ B_i    Γ ⊢ LoadSource(f_i, B_i) ⇓ S_i    Γ ⊢ ParseFile(S_i) ⇓ F_i
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModule(p, S) ⇓ ⟨p, F_1.items ++ ··· ++ F_n.items, F_1.module_doc ++ ··· ++ F_n.module_doc⟩

**(ParseModule-Err-Read)**
∃ i, Γ ⊢ ReadBytes(f_i) ⇑ c
──────────────────────────────────────────────
Γ ⊢ ParseModule(p, S) ⇑ c

**(ParseModule-Err-Load)**
∃ i, Γ ⊢ ReadBytes(f_i) ⇓ B_i    Γ ⊢ LoadSource(f_i, B_i) ⇑ c
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModule(p, S) ⇑ c

**LoadSource Short-Circuit.**
If Γ ⊢ LoadSource(f, B) ⇑ c for any file in a compilation unit, ParseModule MUST NOT invoke Tokenize, ParseFile, or subset checks for that file.

**(ParseModule-Err-Unit)**
Γ ⊢ CompilationUnit(DirOf(p, S)) ⇑ c
──────────────────────────────────────────────
Γ ⊢ ParseModule(p, S) ⇑ c

**(ParseModule-Err-Parse)**
∃ i, Γ ⊢ ReadBytes(f_i) ⇓ B_i    Γ ⊢ LoadSource(f_i, B_i) ⇓ S_i    Γ ⊢ ParseFile(S_i) ⇑ c
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModule(p, S) ⇑ c

ParseFileBestEffort(S) ⇔ ∃ F. Γ ⊢ ParseFile(S) ⇓ F
ParseFileOk(S) ⇔ ParseFileBestEffort(S) ∧ ¬ HasError(ParseFileDiag(S))
ParseFileDiag(S) = Δ ⇔ Γ ⊢ Tokenize(S) ⇓ (K_raw, D) ∧ K = Filter(K_raw) ∧ P_0 = ⟨K, 0, D, 0, 0, []⟩ ∧ Γ ⊢ ParseItems(P_0) ⇓ (P_1, I, MDoc) ∧ DiagStream(P_1) = Δ
HasError(Δ) ⇔ ∃ d ∈ Δ. d.severity = Error

**ParseModule (Small-Step).**
ModState = {ModStart(p, S), ModScan(p, S, U, items, docs), ModDone(M), Error(code)}

**(Mod-Start)**
U = CompilationUnit(DirOf(p, S))
──────────────────────────────────────────────
⟨ModStart(p, S)⟩ → ⟨ModScan(p, S, U, [], [])⟩

**(Mod-Start-Err-Unit)**
Γ ⊢ CompilationUnit(DirOf(p, S)) ⇑ c
──────────────────────────────────────────────
⟨ModStart(p, S)⟩ → ⟨Error(c)⟩

**(Mod-Scan)**
U = f :: fs    Γ ⊢ ReadBytes(f) ⇓ B    Γ ⊢ LoadSource(f, B) ⇓ S_f    Γ ⊢ ParseFile(S_f) ⇓ F
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨ModScan(p, S, f :: fs, items, docs)⟩ → ⟨ModScan(p, S, fs, items ++ F.items, docs ++ F.module_doc)⟩

**(Mod-Scan-Err-Read)**
U = f :: fs    Γ ⊢ ReadBytes(f) ⇑ c
──────────────────────────────────────────────────────────────
⟨ModScan(p, S, f :: fs, items, docs)⟩ → ⟨Error(c)⟩

**(Mod-Scan-Err-Load)**
U = f :: fs    Γ ⊢ ReadBytes(f) ⇓ B    Γ ⊢ LoadSource(f, B) ⇑ c
──────────────────────────────────────────────────────────────────────────────
⟨ModScan(p, S, f :: fs, items, docs)⟩ → ⟨Error(c)⟩

**(Mod-Scan-Err-Parse)**
U = f :: fs    Γ ⊢ ReadBytes(f) ⇓ B    Γ ⊢ LoadSource(f, B) ⇓ S_f    Γ ⊢ ParseFile(S_f) ⇑ c
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨ModScan(p, S, f :: fs, items, docs)⟩ → ⟨Error(c)⟩

**(Mod-Done)**
──────────────────────────────────────────────────────────────────────────────
⟨ModScan(p, S, [], items, docs)⟩ → ⟨ModDone(⟨p, items, docs⟩)⟩

**ParseModules (Big-Step).**

P.modules = [p_1, …, p_k]

**(ParseModules-Ok)**
∀ i, Γ ⊢ ParseModule(p_i, P.source_root) ⇓ M_i
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ParseModules(P) ⇓ [M_1, …, M_k]

**(ParseModules-Err)**
∃ i, Γ ⊢ ParseModule(p_i, P.source_root) ⇑ c
──────────────────────────────────────────────
Γ ⊢ ParseModules(P) ⇑ c

## 4. Phase 2: Compile-Time Execution (Deferred in Cursive0)

ComptimeForm = {`comptime`}
ComptimeForm ⊆ UnsupportedForm

## 5. Phase 3: Name Resolution + Type Checking

### 5.1. Name Resolution and Scopes (Cursive0)

#### 5.1.1. Scope Context and Identifiers

IdKeyRef = {"3.1.6"}
ScopeKey(S) ⇔ dom(S) ⊆ {IdKey(x) | x ∈ Identifier}

Σ = ⟨Σ.Mods, Σ.Types, Σ.Classes⟩
Σ.Mods ∈ [ASTModule]
Σ.Types : Path ⇀ TypeDecl
Σ.Classes : Path ⇀ ClassDecl

Γ = ⟨P, Σ, m, S⟩
Project(Γ) = P
ResCtx(Γ) = ⟨Σ, m⟩
CurrentModule(Γ) = m
Scopes(Γ) = S

EntityKind = {Value, Type, Class, ModuleAlias}
EntitySource = {Decl, Using, RegionAlias}
Entity = ⟨kind, origin_opt, target_opt, source⟩
origin_opt ∈ ModulePath ∪ {⊥}    target_opt ∈ Identifier ∪ {⊥}

**Unified Namespace.**

S : IdKey ⇀ Entity

Scopes(Γ) = [S_1, …, S_k, S_proc, S_module, S_universe]    (k ≥ 0)

LocalScopes(Γ) = [S_1, …, S_k]
ProcScope(Γ) = S_proc
ModuleScope(Γ) = S_module
UniverseScope(Γ) = S_universe

UniverseProtectedRef = {"3.2.3"}

UniverseBindings = { IdKey(x) ↦ ⟨Type, ⊥, ⊥, Decl⟩ | x ∈ UniverseProtected } ∪ { IdKey(`cursive`) ↦ ⟨ModuleAlias, `cursive`, ⊥, Decl⟩ }
S_universe = UniverseBindings

BytePrefix(p, s) ⇔ ∃ r. s = p ++ r
Prefix(s, p) ⇔ BytePrefix(p, s)

ReservedGen(x) ⇔ Prefix(IdKey(x), IdKey(`gen_`))
ReservedCursive(x) ⇔ IdEq(x, `cursive`)
ReservedId(x) ⇔ ReservedGen(x) ∨ ReservedCursive(x)
ReservedModulePath(path) ⇔ (|path| ≥ 1 ∧ IdEq(path[0], `cursive`)) ∨ (∃ i. ReservedGen(path[i]))

<!-- Source: "The `cursive.*` namespace prefix is reserved for specification-defined features. User programs and vendor extensions MUST NOT use this namespace." -->

PrimTypeNames = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `f16`, `f32`, `f64`, `bool`, `char`, `usize`, `isize`}
SpecialTypeNames = {`Self`, `Drop`, `Bitcopy`, `Clone`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, `Context`, `System`}
AsyncTypeNames = {`Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`}

PrimTypeKeys = {IdKey(x) | x ∈ PrimTypeNames}
SpecialTypeKeys = {IdKey(x) | x ∈ SpecialTypeNames}
AsyncTypeKeys = {IdKey(x) | x ∈ AsyncTypeNames}

KeywordKey(n) ⇔ ∃ s. n = IdKey(s) ∧ Keyword(s)

#### 5.1.2. Name Introduction and Shadowing

dom(S) = keys(S)
Scopes(Γ) = [S_cur] ++ Γ_out
InScope(S, x) ⇔ IdKey(x) ∈ dom(S)
InOuter(Γ, x) ⇔ ∃ S ∈ Γ_out. InScope(S, x)

**(Intro-Ok)**
¬ InScope(S_cur, x)    ¬ InOuter(Γ, x)    ¬ ReservedId(x)    (S_cur ≠ S_module ∨ x ∉ UniverseProtected)    Scopes(Γ') = [S_cur[IdKey(x) ↦ ent]] ++ Γ_out    Project(Γ') = Project(Γ)    ResCtx(Γ') = ResCtx(Γ)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Intro(x, ent) ⇓ Γ'

**(Intro-Dup)**
InScope(S_cur, x)
──────────────────────────────────────────────
Γ ⊢ Intro(x, ent) ⇑

**(Intro-Shadow-Required)**
¬ InScope(S_cur, x)    InOuter(Γ, x)    c = Code(Intro-Shadow-Required)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Intro(x, ent) ⇑ c

**(Shadow-Ok)**
¬ InScope(S_cur, x)    InOuter(Γ, x)    ¬ ReservedId(x)    (S_cur ≠ S_module ∨ x ∉ UniverseProtected)    Scopes(Γ') = [S_cur[IdKey(x) ↦ ent]] ++ Γ_out    Project(Γ') = Project(Γ)    ResCtx(Γ') = ResCtx(Γ)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ShadowIntro(x, ent) ⇓ Γ'

**(Shadow-Unnecessary)**
¬ InScope(S_cur, x)    ¬ InOuter(Γ, x)    c = Code(Shadow-Unnecessary)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ShadowIntro(x, ent) ⇑ c

**(Intro-Reserved-Gen-Err)**
ReservedGen(x)    c = Code(Intro-Reserved-Gen-Err)
──────────────────────────────────────────────────────
Γ ⊢ Intro(x, ent) ⇑ c

**(Intro-Reserved-Cursive-Err)**
ReservedCursive(x)    c = Code(Intro-Reserved-Cursive-Err)
──────────────────────────────────────────────────────────
Γ ⊢ Intro(x, ent) ⇑ c

**(Shadow-Reserved-Gen-Err)**
ReservedGen(x)    c = Code(Shadow-Reserved-Gen-Err)
────────────────────────────────────────────────────────
Γ ⊢ ShadowIntro(x, ent) ⇑ c

**(Shadow-Reserved-Cursive-Err)**
ReservedCursive(x)    c = Code(Shadow-Reserved-Cursive-Err)
────────────────────────────────────────────────────────────
Γ ⊢ ShadowIntro(x, ent) ⇑ c

**Deterministic Rule Priority (Intro / ShadowIntro).**

When multiple Intro/ShadowIntro rules are simultaneously applicable, an implementation MUST apply the first matching clause in the following ordered checks.

**Intro Priority.**
1. If ReservedGen(x) then apply **(Intro-Reserved-Gen-Err)**.
2. Else if ReservedCursive(x) then apply **(Intro-Reserved-Cursive-Err)**.
3. Else if InScope(S_cur, x) then apply **(Intro-Dup)**.
4. Else if InOuter(Γ, x) then apply **(Intro-Shadow-Required)**.
5. Else if the premises of **(Intro-Ok)** hold then apply **(Intro-Ok)**.
6. Otherwise, Γ ⊢ Intro(x, ent) ⇑ with no diagnostic code.

**ShadowIntro Priority.**
1. If ReservedGen(x) then apply **(Shadow-Reserved-Gen-Err)**.
2. Else if ReservedCursive(x) then apply **(Shadow-Reserved-Cursive-Err)**.
3. Else if InScope(S_cur, x) then Γ ⊢ ShadowIntro(x, ent) ⇑ with no diagnostic code.
4. Else if ¬ InOuter(Γ, x) then apply **(Shadow-Unnecessary)**.
5. Else if the premises of **(Shadow-Ok)** hold then apply **(Shadow-Ok)**.
6. Otherwise, Γ ⊢ ShadowIntro(x, ent) ⇑ with no diagnostic code.

**Binding Introduction Selection.**
If a binding is introduced by a syntactic form without the `shadow` keyword, the implementation MUST invoke Intro for that binding. If a binding is introduced by a `shadow` form (e.g., `ShadowLetStmt`/`ShadowVarStmt`), the implementation MUST invoke ShadowIntro for that binding. The implementation MUST NOT substitute the other judgment.

**Module-Scope Name Validation.**

Names(N) = dom(N)

**(Validate-Module-Ok)**
∀ n ∈ Names(N). ¬ KeywordKey(n) ∧ n ∉ PrimTypeKeys ∧ n ∉ SpecialTypeKeys ∧ n ∉ AsyncTypeKeys
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModuleNames(N) ⇓ ok

**(Validate-Module-Keyword-Err)**
∃ n ∈ Names(N). KeywordKey(n)    c = Code(Validate-Module-Keyword-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModuleNames(N) ⇑ c

**(Validate-Module-Prim-Shadow-Err)**
∃ n ∈ Names(N). n ∈ PrimTypeKeys    c = Code(Validate-Module-Prim-Shadow-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModuleNames(N) ⇑ c

**(Validate-Module-Special-Shadow-Err)**
∃ n ∈ Names(N). n ∈ SpecialTypeKeys    c = Code(Validate-Module-Special-Shadow-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModuleNames(N) ⇑ c

**(Validate-Module-Async-Shadow-Err)**
∃ n ∈ Names(N). n ∈ AsyncTypeKeys    c = Code(Validate-Module-Async-Shadow-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModuleNames(N) ⇑ c

#### 5.1.3. Lookup

**Unqualified Lookup.**

Scopes(Γ) = [S_1, …, S_n]
i = min{j | IdKey(x) ∈ dom(S_j)}

**(Lookup-Unqualified)**
i defined
──────────────────────────────────────────────
Γ ⊢ Lookup(x) ⇓ S_i[IdKey(x)]

**(Lookup-Unqualified-None)**
i undefined
──────────────────────────────────────────────
Γ ⊢ Lookup(x) ↑

**Kind Filtering.**
ValueKind(ent) ⇔ ent.kind = Value
TypeKind(ent) ⇔ ent.kind = Type
ClassKind(ent) ⇔ ent.kind = Class
ModuleKind(ent) ⇔ ent.kind = ModuleAlias
RegionAlias(ent) ⇔ ent.source = RegionAlias

RegionAliasName(Γ, x) ⇔ Γ ⊢ ResolveValueName(x) ⇓ ent ∧ RegionAlias(ent)

**(Resolve-Value-Name)**
Γ ⊢ Lookup(x) ⇓ ent    ValueKind(ent)
──────────────────────────────────────────────
Γ ⊢ ResolveValueName(x) ⇓ ent

**(Resolve-Type-Name)**
Γ ⊢ Lookup(x) ⇓ ent    TypeKind(ent)
──────────────────────────────────────────────
Γ ⊢ ResolveTypeName(x) ⇓ ent

**(Resolve-Class-Name)**
Γ ⊢ Lookup(x) ⇓ ent    ClassKind(ent)
──────────────────────────────────────────────
Γ ⊢ ResolveClassName(x) ⇓ ent

**(Resolve-Module-Name)**
Γ ⊢ Lookup(x) ⇓ ent    ModuleKind(ent)
──────────────────────────────────────────────
Γ ⊢ ResolveModuleName(x) ⇓ ent

**Qualified Lookup.**
P = Project(Γ)
m = CurrentModule(Γ)
ModulePaths = { p | p ∈ P.modules }
Alias = AliasMap(m)

**(Resolve-ModulePath)**
Γ ⊢ AliasExpand(path, Alias) ⇓ path'    StringOfPath(path') ∈ ModuleNames
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveModulePath(path, Alias, ModuleNames) ⇓ path'

**(ResolveModulePath-Err)**
Γ ⊢ AliasExpand(path, Alias) ⇓ path'    StringOfPath(path') ∉ ModuleNames    c = Code(ResolveModulePath-Err)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveModulePath(path, Alias, ModuleNames) ⇑ c

**(Resolve-Qualified)**
Γ ⊢ ResolveModulePath(path, Alias, ModuleNames) ⇓ mp    NameMap(P, mp)[IdKey(name)] = ent    Γ ⊢ CanAccess(m, DeclOf(mp, name)) ⇓ ok    K(ent)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualified(path, name, K) ⇓ ent

K ∈ {ValueKind, TypeKind, ClassKind, ModuleKind}

#### 5.1.4. Visibility and Accessibility

DeclOf(mp, name) = it ⇔ ModuleOf(it) = mp ∧ IdKey(name) ∈ dom(ItemBindings(it, mp))
ModuleOf(it) = p ⇔ it ∈ ASTModule(P, p).items
ModuleOfPath(path) = mp ⇔ SplitLast(path) = (mp, name)
Vis(it) = it.vis

**(Access-Public)**
Vis(it) = `public`
──────────────────────────────────────────────
Γ ⊢ CanAccess(m, it) ⇓ ok

**(Access-Internal)**
Vis(it) = `internal`
──────────────────────────────────────────────
Γ ⊢ CanAccess(m, it) ⇓ ok

**(Access-Private)**
Vis(it) = `private`    ModuleOf(it) = m
──────────────────────────────────────────────────────────────
Γ ⊢ CanAccess(m, it) ⇓ ok

**(Access-Protected)**
Vis(it) = `protected`    ModuleOf(it) = m
──────────────────────────────────────────────────────────────
Γ ⊢ CanAccess(m, it) ⇓ ok

**(Access-Err)**
Vis(it) ∈ {`private`, `protected`}    ModuleOf(it) ≠ m    c = Code(Access-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ CanAccess(m, it) ⇑ c

**Top-Level `protected`.**

TopLevelDecl(it) ⇔ it ∈ ASTModule(P, ModuleOf(it)).items

**(Protected-TopLevel-Ok)**
Vis(it) ≠ `protected`
──────────────────────────────────────────────
Γ ⊢ TopLevelVis(it) ⇓ ok

**(Protected-TopLevel-Err)**
Vis(it) = `protected`    TopLevelDecl(it)    c = Code(Protected-TopLevel-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TopLevelVis(it) ⇑ c

#### 5.1.5. Top-Level Name Collection (Order Independence)

**Order Independence.**
∀ items'. Permutation(items', items) ∧ Γ ⊢ CollectNames(items, p, ∅) ⇓ N ⇒ Γ ⊢ CollectNames(items', p, ∅) ⇓ N

**Binding Kinds.**

BindKind = {Value, Type, Class, ModuleAlias}
BindSource = {Decl, Using}
NameInfo = ⟨kind, origin, target_opt, source⟩
P = Project(Γ)
NameMap(P, mp) = N ⇔ ModuleMap(P, mp) = M ∧ Γ ⊢ CollectNames(M) ⇓ N
AliasMap(m) = { n ↦ origin | NameMap(P, m)[n].kind = ModuleAlias }
UsingMap(m) = { n ↦ ⟨k, origin, target_opt⟩ | NameMap(P, m)[n].source = Using ∧ NameMap(P, m)[n].kind = k ∧ k ∈ {Value, Type, Class} }
UsingValueMap(m) = { n ↦ origin | NameMap(P, m)[n].source = Using ∧ NameMap(P, m)[n].kind = Value }
UsingTypeMap(m) = { n ↦ origin | NameMap(P, m)[n].source = Using ∧ NameMap(P, m)[n].kind ∈ {Type, Class} }
TypeMap(m) = { n ↦ origin | NameMap(P, m)[n].kind = Type }
ClassMap(m) = { n ↦ origin | NameMap(P, m)[n].kind = Class }

**Pattern Name Extraction.**

──────────────────────────────────────────────
Γ ⊢ PatNames(IdentifierPattern(x)) ⇓ [x]

**(Pat-Typed)**
──────────────────────────────────────────────
Γ ⊢ PatNames(TypedPattern(x, _)) ⇓ [x]

**(Pat-Wild)**
──────────────────────────────────────────────
Γ ⊢ PatNames(WildcardPattern) ⇓ []

**(Pat-Lit)**
──────────────────────────────────────────────
Γ ⊢ PatNames(LiteralPattern(lit)) ⇓ []

∀ i, Γ ⊢ PatNames(p_i) ⇓ N_i
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(TuplePattern([p_1, …, p_n])) ⇓ N_1 ++ ··· ++ N_n

**(Pat-Record-Field-Explicit)**
Γ ⊢ PatNames(p) ⇓ N
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(⟨name, pattern_opt = p, span⟩) ⇓ N

**(Pat-Record-Field-Implicit)**
──────────────────────────────────────────────
Γ ⊢ PatNames(⟨name, pattern_opt = ⊥, span⟩) ⇓ [name]

∀ i, Γ ⊢ PatNames(f_i) ⇓ N_i
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(RecordPattern(_, [f_1, …, f_n])) ⇓ N_1 ++ ··· ++ N_n

**(Pat-Enum-None)**
──────────────────────────────────────────────
Γ ⊢ PatNames(EnumPattern(_, _, ⊥)) ⇓ []

**(Pat-Enum-Tuple)**
∀ i, Γ ⊢ PatNames(p_i) ⇓ N_i
──────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(EnumPattern(_, _, TuplePayloadPattern([p_1, …, p_n]))) ⇓ N_1 ++ ··· ++ N_n

**(Pat-Enum-Record)**
∀ i, Γ ⊢ PatNames(f_i) ⇓ N_i
──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(EnumPattern(_, _, RecordPayloadPattern([f_1, …, f_n]))) ⇓ N_1 ++ ··· ++ N_n

**(Pat-Range)**
Γ ⊢ PatNames(p_l) ⇓ N_l    Γ ⊢ PatNames(p_h) ⇓ N_h
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ PatNames(RangePattern(_, p_l, p_h)) ⇓ N_l ++ N_h

**Using Bindings.**
ModuleNames = { StringOfPath(p) | p ∈ ModulePaths }
Last([c_1, …, c_n]) = c_n if n ≥ 1
IsModulePath(path) ⇔ StringOfPath(path) ∈ ModuleNames
SplitLast(path) = (mp, name) ⇔ path = mp ++ [name] ∧ |path| ≥ 2
ModuleByPath(P, p) = m ⇔ ASTModule(P, p) = m

**Item Names.**
ItemNames(mp) = { n | NameMap(P, mp)[n].kind ∈ {Value, Type, Class} }

**Using Spec Names.**
UsingSpecName(⟨name, alias_opt⟩) = name
UsingSpecNames([s_1, …, s_n]) = [UsingSpecName(s_1), …, UsingSpecName(s_n)]

**Declared Names (Non-Using).**

**(DeclNames-Empty)**
──────────────────────────────────────────────
Γ ⊢ DeclNames([], p) ⇓ ∅

**(DeclNames-Using)**
Γ ⊢ DeclNames(rest, p) ⇓ D
────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ DeclNames(⟨UsingDecl, _, _, _, _⟩ :: rest, p) ⇓ D

**(DeclNames-Item)**
it ≠ ⟨UsingDecl, _, _, _, _⟩    Γ ⊢ ItemBindings(it, p) ⇓ B    Γ ⊢ DeclNames(rest, p) ⇓ D
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ DeclNames(it :: rest, p) ⇓ Names(B) ∪ D

DeclNames(m) = DeclNames(m.items, m.path)

**Item-Path Resolution.**

**(ItemOfPath)**
|path| ≥ 2    SplitLast(path) = (mp, name)    IsModulePath(mp)    m = ModuleByPath(P, mp)    IdKey(name) ∈ ItemNames(mp)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemOfPath(path) ⇓ (mp, name)

**(ItemOfPath-None)**
¬ (|path| ≥ 2 ∧ SplitLast(path) = (mp, name) ∧ IsModulePath(mp) ∧ m = ModuleByPath(P, mp) ∧ IdKey(name) ∈ ItemNames(mp))
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemOfPath(path) ↑

**Using Path Resolution.**

**(Resolve-Using-Item)**
Γ ⊢ ItemOfPath(path) ⇓ (mp, name)    ¬ IsModulePath(path)
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveUsingPath(path) ⇓ ⟨Item, mp, name⟩

**(Resolve-Using-Module)**
IsModulePath(path)    Γ ⊢ ItemOfPath(path) ↑
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveUsingPath(path) ⇓ ⟨Module, path⟩

**(Resolve-Using-Ambig)**
IsModulePath(path)    Γ ⊢ ItemOfPath(path) ⇓ (mp, name)    c = Code(Resolve-Using-Ambig)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveUsingPath(path) ⇑ c

**(Resolve-Using-None)**
¬ IsModulePath(path)    Γ ⊢ ItemOfPath(path) ↑    c = Code(Resolve-Using-None)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveUsingPath(path) ⇑ c

**(Using-Path-Item)**
u = ⟨UsingDecl, vis, ⟨UsingPath, path, alias_opt⟩, _, _⟩    Γ ⊢ ResolveUsingPath(path) ⇓ ⟨Item, mp, item⟩    Γ ⊢ CanAccess(m, DeclOf(mp, item)) ⇓ ok    (vis = `public` ⇒ Vis(DeclOf(mp, item)) = `public`)    NameMap(P, mp)[IdKey(item)] = ⟨k, _, _, _⟩    k ∈ {Value, Type, Class}    name = alias_opt if present, else item
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇓ [(name, ⟨k, mp, item, Using⟩)]

**(Using-Path-Item-Public-Err)**
u = ⟨UsingDecl, `public`, ⟨UsingPath, path, _⟩, _, _⟩    Γ ⊢ ResolveUsingPath(path) ⇓ ⟨Item, mp, item⟩    Vis(DeclOf(mp, item)) ≠ `public`    c = Code(Using-Path-Item-Public-Err)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇑ c

**(Using-Path-Module)**
u = ⟨UsingDecl, _, ⟨UsingPath, path, alias_opt⟩, _, _⟩    Γ ⊢ ResolveUsingPath(path) ⇓ ⟨Module, path⟩    name = alias_opt if present, else Last(path)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇓ [(name, ⟨ModuleAlias, path, ⊥, Using⟩)]

**(Using-List)**
u = ⟨UsingDecl, vis, ⟨UsingList, mp, [s_1, …, s_n]⟩, _, _⟩    Distinct(UsingSpecNames([s_1, …, s_n]))    ∀ i, s_i = ⟨name_i, alias_i⟩    NameMap(P, mp)[IdKey(name_i)] = ⟨k_i, _, _, _⟩    k_i ∈ {Value, Type, Class}    Γ ⊢ CanAccess(m, DeclOf(mp, name_i)) ⇓ ok    (vis = `public` ⇒ Vis(DeclOf(mp, name_i)) = `public`)    bind_i = ⟨(alias_i if present else name_i), ⟨k_i, mp, name_i, Using⟩⟩
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇓ [bind_1, …, bind_n]

**(Using-List-Dup)**
u = ⟨UsingDecl, _, ⟨UsingList, _, specs⟩, _, _⟩    ¬ Distinct(UsingSpecNames(specs))    c = Code(Using-List-Dup)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇑ c

**(Using-List-Public-Err)**
u = ⟨UsingDecl, `public`, ⟨UsingList, mp, [s_1, …, s_n]⟩, _, _⟩    ∃ i. s_i = ⟨name_i, _⟩ ∧ Vis(DeclOf(mp, name_i)) ≠ `public`    c = Code(Using-List-Public-Err)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ UsingNames(u) ⇑ c

**Item Bindings.**

**(Bind-Procedure)**
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨ProcedureDecl, _, name, _, _, _, _, _⟩, p) ⇓ [(name, ⟨Value, p, ⊥, Decl⟩)]

**(Bind-Record)**
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨RecordDecl, _, name, _, _, _, _⟩, p) ⇓ [(name, ⟨Type, p, ⊥, Decl⟩)]

**(Bind-Enum)**
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨EnumDecl, _, name, _, _, _, _⟩, p) ⇓ [(name, ⟨Type, p, ⊥, Decl⟩)]

**(Bind-Class)**
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨ClassDecl, _, name, _, _, _, _⟩, p) ⇓ [(name, ⟨Class, p, ⊥, Decl⟩)]

**(Bind-TypeAlias)**
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨TypeAliasDecl, _, name, _, _, _⟩, p) ⇓ [(name, ⟨Type, p, ⊥, Decl⟩)]

**(Bind-Static)**
Γ ⊢ PatNames(pat) ⇓ N
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(⟨StaticDecl, _, _, ⟨pat, _, _, _, _⟩, _, _⟩, p) ⇓ [(n, ⟨Value, p, ⊥, Decl⟩) | n ∈ N]

**(Bind-Using)**
Γ ⊢ UsingNames(u) ⇓ B
──────────────────────────────────────────────
Γ ⊢ ItemBindings(u, p) ⇓ B

**(Bind-Using-Err)**
Γ ⊢ UsingNames(u) ⇑ c
──────────────────────────────────────────────
Γ ⊢ ItemBindings(u, p) ⇑ c

**(Bind-ErrorItem)**
──────────────────────────────────────────────────────────────
Γ ⊢ ItemBindings(ErrorItem(_), p) ⇓ []

**CollectNames (Big-Step).**

**(Collect-Ok)**
Γ ⊢ CollectNames(items, p, ∅) ⇓ N
──────────────────────────────────────────────
Γ ⊢ CollectNames(M) ⇓ N

**(Collect-Scan)**
Γ ⊢ ItemBindings(it, p) ⇓ B    DisjointNames(B, N)    NoDup(B)    Γ ⊢ CollectNames(rest, p, N ∪ B) ⇓ N'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ CollectNames(it :: rest, p, N) ⇓ N'

**(Collect-Dup)**
Γ ⊢ ItemBindings(it, p) ⇓ B    (¬ DisjointNames(B, N) ∨ ¬ NoDup(B))    c = Code(Collect-Dup)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ CollectNames(it :: rest, p, N) ⇑ c

**(Collect-Err)**
Γ ⊢ ItemBindings(it, p) ⇑ c
────────────────────────────────────────────────────────────────
Γ ⊢ CollectNames(it :: rest, p, N) ⇑ c

Names(B) = { n | (n, _) ∈ B }
NoDup(B) ⇔ Distinct(Names(B))
DisjointNames(B, N) ⇔ Names(B) ∩ dom(N) = ∅
N ∪ B = { (n, v) | (n, v) ∈ N ∨ (n, v) ∈ B }

**CollectNames (Small-Step).**
NamesState = {NamesStart(M), NamesScan(items, p, N), NamesDone(N), Error(code)}

**(Names-Start)**
────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨NamesStart(M)⟩ → ⟨NamesScan(M.items, M.path, ∅)⟩

**(Names-Step)**
Γ ⊢ ItemBindings(it, p) ⇓ B    DisjointNames(B, N)    NoDup(B)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨NamesScan(it :: rest, p, N)⟩ → ⟨NamesScan(rest, p, N ∪ B)⟩

**(Names-Step-Dup)**
Γ ⊢ ItemBindings(it, p) ⇓ B    (¬ DisjointNames(B, N) ∨ ¬ NoDup(B))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
⟨NamesScan(it :: rest, p, N)⟩ → ⟨Error(Code(Names-Step-Dup))⟩

**(Names-Step-Err)**
Γ ⊢ ItemBindings(it, p) ⇑ c
────────────────────────────────────────────────────────────────
⟨NamesScan(it :: rest, p, N)⟩ → ⟨Error(c)⟩

**(Names-Done)**
──────────────────────────────────────────────────────────────
⟨NamesScan([], p, N)⟩ → ⟨NamesDone(N)⟩


#### 5.1.6. Qualified Disambiguation (Resolution-Time)

ResolveQualifiedForm : Expr ⇀ Expr

ResolveArgs : [Arg] ⇀ [Arg]
ResolveFieldInits : [FieldInit] ⇀ [FieldInit]
ResolveRecordPath : Path × Identifier ⇀ Path
ResolveEnumUnit : Path × Identifier ⇀ Path
ResolveEnumTuple : Path × Identifier ⇀ Path
ResolveEnumRecord : Path × Identifier ⇀ Path

**(ResolveArgs-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveArgs([]) ⇓ []

**(ResolveArgs-Cons)**
Γ ⊢ ResolveExpr(e) ⇓ e'    Γ ⊢ ResolveArgs(rest) ⇓ rest'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveArgs([⟨moved, e, span⟩] ++ rest) ⇓ [⟨moved, e', span⟩] ++ rest'

**(ResolveFieldInits-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveFieldInits([]) ⇓ []

**(ResolveFieldInits-Cons)**
Γ ⊢ ResolveExpr(e) ⇓ e'    Γ ⊢ ResolveFieldInits(rest) ⇓ rest'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldInits([⟨f, e⟩] ++ rest) ⇓ [⟨f, e'⟩] ++ rest'

ResolvePathJudg = {ResolveRecordPath, ResolveEnumUnit, ResolveEnumTuple, ResolveEnumRecord}

**(Resolve-RecordPath)**
Γ ⊢ ResolveTypePath(path ++ [name]) ⇓ p    RecordDecl(p) = R
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveRecordPath(path, name) ⇓ p

**(Resolve-EnumUnit)**
Γ ⊢ ResolveTypePath(path) ⇓ p    EnumDecl(p) = E    VariantPayload(E, name) = ⊥
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumUnit(path, name) ⇓ p

**(Resolve-EnumTuple)**
Γ ⊢ ResolveTypePath(path) ⇓ p    EnumDecl(p) = E    VariantPayload(E, name) = TuplePayload(_)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumTuple(path, name) ⇓ p

**(Resolve-EnumRecord)**
Γ ⊢ ResolveTypePath(path) ⇓ p    EnumDecl(p) = E    VariantPayload(E, name) = RecordPayload(_)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumRecord(path, name) ⇓ p

**(ResolveQual-Name-Value)**
Γ ⊢ ResolveQualified(path, name, ValueKind) ⇓ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)    PathOfModule(mp) = path'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedName(path, name)) ⇓ Path(path', name')

**(ResolveQual-Name-Record)**
Γ ⊢ ResolveRecordPath(path, name) ⇓ p    SplitLast(p) = (mp, name')
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedName(path, name)) ⇓ Path(mp, name')

**(ResolveQual-Name-Enum)**
Γ ⊢ ResolveQualified(path, name, ValueKind) ↑    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumUnit(path, name) ⇓ p
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedName(path, name)) ⇓ EnumLiteral(FullPath(p, name), ⊥)

**(ResolveQual-Name-Err)**
Γ ⊢ ResolveQualified(path, name, ValueKind) ↑    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumUnit(path, name) ↑    c = Code(ResolveExpr-Ident-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedName(path, name)) ⇑ c

**(ResolveQual-Apply-Value)**
Γ ⊢ ResolveArgs(args) ⇓ args'    Γ ⊢ ResolveQualified(path, name, ValueKind) ⇓ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)    PathOfModule(mp) = path'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) ⇓ Call(Path(path', name'), args')

**(ResolveQual-Apply-Record)**
Γ ⊢ ResolveArgs(args) ⇓ args'    Γ ⊢ ResolveRecordPath(path, name) ⇓ p    SplitLast(p) = (mp, name')
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) ⇓ Call(Path(mp, name'), args')

**(ResolveQual-Apply-Enum-Tuple)**
Γ ⊢ ResolveArgs(args) ⇓ args'    Γ ⊢ ResolveQualified(path, name, ValueKind) ↑    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumTuple(path, name) ⇓ p
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) ⇓ EnumLiteral(FullPath(p, name), Paren(ArgsExprs(args')))

**(ResolveQual-Apply-Err)**
Γ ⊢ ResolveArgs(args) ⇓ args'    Γ ⊢ ResolveQualified(path, name, ValueKind) ↑    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumTuple(path, name) ↑    c = Code(ResolveExpr-Ident-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) ⇑ c

**Qualified Apply (Brace).**

**(ResolveQual-Apply-RecordLit)**
Γ ⊢ ResolveFieldInits(fields) ⇓ fields'    Γ ⊢ ResolveRecordPath(path, name) ⇓ p
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) ⇓ RecordExpr(TypePath(p), fields')

**(ResolveQual-Apply-Enum-Record)**
Γ ⊢ ResolveFieldInits(fields) ⇓ fields'    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumRecord(path, name) ⇓ p
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) ⇓ EnumLiteral(FullPath(p, name), Brace(fields'))

**(ResolveQual-Apply-Brace-Err)**
Γ ⊢ ResolveFieldInits(fields) ⇓ fields'    Γ ⊢ ResolveRecordPath(path, name) ↑    Γ ⊢ ResolveEnumRecord(path, name) ↑    c = Code(ResolveExpr-Ident-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) ⇑ c

#### 5.1.7. Resolution Pass (Big-Step and Small-Step)

$$P = \text{Project}(\Gamma)$$
$$m = \text{CurrentModule}(\Gamma)$$
$$M = \text{ASTModule}(P, m)$$
ResolveInputs = ⟨M, ModulePaths, { NameMap(P, p) | p ∈ ModulePaths }⟩
ResolveOutputs = ⟨M'⟩
PathOfModuleRef = {"3.4.1"}

**(Validate-ModulePath-Ok)**
¬ ReservedModulePath(PathOfModule(p))
──────────────────────────────────────────────
Γ ⊢ ValidateModulePath(p) ⇓ ok

**(Validate-ModulePath-Reserved-Err)**
ReservedModulePath(PathOfModule(p))    c = Code(Validate-ModulePath-Reserved-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ValidateModulePath(p) ⇑ c

**(ResolveModule-Ok)**
Γ ⊢ CollectNames(M) ⇓ N    Γ ⊢ ValidateModulePath(M.path) ⇓ ok    Γ ⊢ ValidateModuleNames(N) ⇓ ok    S_module = N    Γ_N = [S_module, S_universe]    Γ_N ⊢ ResolveItems(M.items) ⇓ items'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveModule(M) ⇓ ⟨M.path, items', M.module_doc⟩

**(ResolveItems-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveItems([]) ⇓ []

**(ResolveItems-Cons)**
Γ ⊢ TopLevelVis(it) ⇓ ok    Γ ⊢ ResolveItem(it) ⇓ it'    Γ ⊢ ResolveItems(rest) ⇓ rest'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItems(it :: rest) ⇓ it' :: rest'

**(ResolveItem-Static)**
Γ ⊢ ResolvePattern(pat) ⇓ pat'    Γ ⊢ ResolveExpr(init) ⇓ init'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(StaticDecl(vis, mut, ⟨pat, ty_opt, op, init, span⟩, span', doc)) ⇓ StaticDecl(vis, mut, ⟨pat', ty_opt', op, init', span⟩, span', doc)

**(ResolveItem-Procedure)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ_p = [S_proc, S_module, S_universe]    Γ_p ⊢ ResolveParams(params) ⇓ params'    Γ_p ⊢ ResolveTypeOpt(ret_opt) ⇓ ret_opt'    Γ_p ⊢ ResolveExpr(body) ⇓ body'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(ProcedureDecl(vis, name, params, ret_opt, body, span, doc)) ⇓ ProcedureDecl(vis, name, params', ret_opt', body', span, doc)

**(ResolveItem-Using)**
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(UsingDecl(vis, clause, span, doc)) ⇓ UsingDecl(vis, clause, span, doc)

**(ResolveItem-TypeAlias)**
Γ ⊢ ResolveType(ty) ⇓ ty'
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(TypeAliasDecl(vis, name, ty, span, doc)) ⇓ TypeAliasDecl(vis, name, ty', span, doc)

**(ResolveItem-Record)**
R = RecordDecl(vis, name, impls, members, span, doc)    Γ ⊢ ResolveClassPathList(impls) ⇓ impls'    Γ ⊢ ResolveRecordMemberList(R, members) ⇓ members'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(R) ⇓ RecordDecl(vis, name, impls', members', span, doc)

**(ResolveItem-Enum)**
Γ ⊢ ResolveClassPathList(impls) ⇓ impls'    Γ ⊢ ResolveVariantList(vars) ⇓ vars'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(EnumDecl(vis, name, impls, vars, span, doc)) ⇓ EnumDecl(vis, name, impls', vars', span, doc)

**(ResolveItem-Modal)**
Γ ⊢ ResolveClassPathList(impls) ⇓ impls'    Γ ⊢ ResolveStateBlockList(states) ⇓ states'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(ModalDecl(vis, name, impls, states, span, doc)) ⇓ ModalDecl(vis, name, impls', states', span, doc)

**(ResolveItem-Class)**
Γ ⊢ ResolveClassPathList(supers) ⇓ supers'    Γ ⊢ ResolveClassItemList(items) ⇓ items'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveItem(ClassDecl(vis, name, supers, items, span, doc)) ⇓ ClassDecl(vis, name, supers', items', span, doc)

**Self Binding for Methods.**

**(BindSelf-Record)**
RecordPath(R) = p    SplitLast(p) = (mp, name)    S_proc' = S_proc[IdKey(`Self`) ↦ ⟨Type, mp, name, Decl⟩]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ BindSelfRecord(R, S_proc) ⇓ S_proc'

**(BindSelf-Class)**
S_proc' = S_proc[IdKey(`Self`) ↦ ⟨Type, ⊥, ⊥, Decl⟩]
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ BindSelfClass(S_proc) ⇓ S_proc'

**(ResolveReceiver-Shorthand)**
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveReceiver(ReceiverShorthand(perm)) ⇓ ReceiverShorthand(perm)

**(ResolveReceiver-Explicit)**
Γ ⊢ ResolveType(ty) ⇓ ty'
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveReceiver(ReceiverExplicit(mode_opt, ty)) ⇓ ReceiverExplicit(mode_opt, ty')

**(ResolveClassPathList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveClassPathList([]) ⇓ []

**(ResolveClassPathList-Cons)**
Γ ⊢ ResolveClassPath(p) ⇓ p'    Γ ⊢ ResolveClassPathList(ps) ⇓ ps'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassPathList(p :: ps) ⇓ p' :: ps'

**(ResolveTypeList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveTypeList([]) ⇓ []

**(ResolveTypeList-Cons)**
Γ ⊢ ResolveType(t) ⇓ t'    Γ ⊢ ResolveTypeList(ts) ⇓ ts'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTypeList(t :: ts) ⇓ t' :: ts'

**(ResolveFieldDecl)**
Γ ⊢ ResolveType(ty) ⇓ ty'    Γ ⊢ ResolveExprOpt(init_opt) ⇓ init_opt'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldDecl(FieldDecl(vis, name, ty, init_opt, span, doc_opt)) ⇓ FieldDecl(vis, name, ty', init_opt', span, doc_opt)

**(ResolveFieldDeclList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveFieldDeclList([]) ⇓ []

**(ResolveFieldDeclList-Cons)**
Γ ⊢ ResolveFieldDecl(f) ⇓ f'    Γ ⊢ ResolveFieldDeclList(fs) ⇓ fs'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldDeclList(f :: fs) ⇓ f' :: fs'

**(ResolveRecordMember-Field)**
Γ ⊢ ResolveFieldDecl(f) ⇓ f'
──────────────────────────────────────────────
Γ ⊢ ResolveRecordMember(R, f) ⇓ f'

**(ResolveRecordMember-Method)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ ⊢ BindSelfRecord(R, S_proc) ⇓ S_proc'    Γ_m = [S_proc', S_module, S_universe]    Γ_m ⊢ ResolveReceiver(recv) ⇓ recv'    Γ_m ⊢ ResolveParams(params) ⇓ params'    Γ_m ⊢ ResolveTypeOpt(ret_opt) ⇓ ret_opt'    Γ_m ⊢ ResolveExpr(body) ⇓ body'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveRecordMember(R, MethodDecl(vis, override, name, recv, params, ret_opt, body, span, doc_opt)) ⇓ MethodDecl(vis, override, name, recv', params', ret_opt', body', span, doc_opt)

**(ResolveRecordMemberList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveRecordMemberList(R, []) ⇓ []

**(ResolveRecordMemberList-Cons)**
Γ ⊢ ResolveRecordMember(R, m) ⇓ m'    Γ ⊢ ResolveRecordMemberList(R, ms) ⇓ ms'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveRecordMemberList(R, m :: ms) ⇓ m' :: ms'

**(ResolveClassItem-Field)**
Γ ⊢ ResolveType(ty) ⇓ ty'
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassItem(ClassFieldDecl(vis, name, ty, span, doc_opt)) ⇓ ClassFieldDecl(vis, name, ty', span, doc_opt)

**(ResolveClassItem-Method-Abstract)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ ⊢ BindSelfClass(S_proc) ⇓ S_proc'    Γ_m = [S_proc', S_module, S_universe]    Γ_m ⊢ ResolveReceiver(recv) ⇓ recv'    Γ_m ⊢ ResolveParams(params) ⇓ params'    Γ_m ⊢ ResolveTypeOpt(ret_opt) ⇓ ret_opt'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassItem(ClassMethodDecl(vis, name, recv, params, ret_opt, ⊥, span, doc_opt)) ⇓ ClassMethodDecl(vis, name, recv', params', ret_opt', ⊥, span, doc_opt)

**(ResolveClassItem-Method-Concrete)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ ⊢ BindSelfClass(S_proc) ⇓ S_proc'    Γ_m = [S_proc', S_module, S_universe]    Γ_m ⊢ ResolveReceiver(recv) ⇓ recv'    Γ_m ⊢ ResolveParams(params) ⇓ params'    Γ_m ⊢ ResolveTypeOpt(ret_opt) ⇓ ret_opt'    Γ_m ⊢ ResolveExpr(body) ⇓ body'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassItem(ClassMethodDecl(vis, name, recv, params, ret_opt, body, span, doc_opt)) ⇓ ClassMethodDecl(vis, name, recv', params', ret_opt', body', span, doc_opt)

**(ResolveClassItemList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveClassItemList([]) ⇓ []

**(ResolveClassItemList-Cons)**
Γ ⊢ ResolveClassItem(it) ⇓ it'    Γ ⊢ ResolveClassItemList(its) ⇓ its'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassItemList(it :: its) ⇓ it' :: its'

**(ResolveVariantPayloadOpt-None)**
──────────────────────────────────────────────
Γ ⊢ ResolveVariantPayloadOpt(⊥) ⇓ ⊥

**(ResolveVariantPayloadOpt-Tuple)**
Γ ⊢ ResolveTypeList(ts) ⇓ ts'
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveVariantPayloadOpt(TuplePayload(ts)) ⇓ TuplePayload(ts')

**(ResolveVariantPayloadOpt-Record)**
Γ ⊢ ResolveFieldDeclList(fs) ⇓ fs'
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveVariantPayloadOpt(RecordPayload(fs)) ⇓ RecordPayload(fs')

**(ResolveVariant)**
Γ ⊢ ResolveVariantPayloadOpt(payload_opt) ⇓ payload_opt'    Γ ⊢ ResolveExprOpt(disc_opt) ⇓ disc_opt'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveVariant(VariantDecl(name, payload_opt, disc_opt, span, doc_opt)) ⇓ VariantDecl(name, payload_opt', disc_opt', span, doc_opt)

**(ResolveVariantList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveVariantList([]) ⇓ []

**(ResolveVariantList-Cons)**
Γ ⊢ ResolveVariant(v) ⇓ v'    Γ ⊢ ResolveVariantList(vs) ⇓ vs'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveVariantList(v :: vs) ⇓ v' :: vs'

**(ResolveStateMember-Field)**
Γ ⊢ ResolveType(ty) ⇓ ty'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateMember(StateFieldDecl(vis, name, ty, span, doc_opt)) ⇓ StateFieldDecl(vis, name, ty', span, doc_opt)

**(ResolveStateMember-Method)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ_m = [S_proc, S_module, S_universe]    Γ_m ⊢ ResolveParams(params) ⇓ params'    Γ_m ⊢ ResolveTypeOpt(ret_opt) ⇓ ret_opt'    Γ_m ⊢ ResolveExpr(body) ⇓ body'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateMember(StateMethodDecl(vis, name, params, ret_opt, body, span, doc_opt)) ⇓ StateMethodDecl(vis, name, params', ret_opt', body', span, doc_opt)

**(ResolveStateMember-Transition)**
S_proc = { IdKey(p.name) ↦ ⟨Value, ⊥, ⊥, Decl⟩ | p ∈ params }    Γ_m = [S_proc, S_module, S_universe]    Γ_m ⊢ ResolveParams(params) ⇓ params'    Γ_m ⊢ ResolveExpr(body) ⇓ body'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateMember(TransitionDecl(vis, name, params, target_state, body, span, doc_opt)) ⇓ TransitionDecl(vis, name, params', target_state, body', span, doc_opt)

**(ResolveStateMemberList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveStateMemberList([]) ⇓ []

**(ResolveStateMemberList-Cons)**
Γ ⊢ ResolveStateMember(m) ⇓ m'    Γ ⊢ ResolveStateMemberList(ms) ⇓ ms'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateMemberList(m :: ms) ⇓ m' :: ms'

**(ResolveStateBlock)**
Γ ⊢ ResolveStateMemberList(members) ⇓ members'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateBlock(StateBlock(name, members, span, doc_opt)) ⇓ StateBlock(name, members', span, doc_opt)

**(ResolveStateBlockList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveStateBlockList([]) ⇓ []

**(ResolveStateBlockList-Cons)**
Γ ⊢ ResolveStateBlock(b) ⇓ b'    Γ ⊢ ResolveStateBlockList(bs) ⇓ bs'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStateBlockList(b :: bs) ⇓ b' :: bs'

**(ResolveTypeOpt-None)**
──────────────────────────────────────────────
Γ ⊢ ResolveTypeOpt(⊥) ⇓ ⊥

**(ResolveTypeOpt-Some)**
Γ ⊢ ResolveType(ty) ⇓ ty'
──────────────────────────────────────────────
Γ ⊢ ResolveTypeOpt(ty) ⇓ ty'

**(ResolveExprOpt-None)**
──────────────────────────────────────────────
Γ ⊢ ResolveExprOpt(⊥) ⇓ ⊥

**(ResolveExprOpt-Some)**
Γ ⊢ ResolveExpr(e) ⇓ e'
──────────────────────────────────────────────
Γ ⊢ ResolveExprOpt(e) ⇓ e'

**(ResolveTypePath-Ident)**
|path| = 1    Γ ⊢ ResolveTypeName(path[0]) ⇓ ent    ent.origin_opt = p    name = (ent.target_opt if present, else path[0])
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTypePath(path) ⇓ FullPath(PathOfModule(p), name)

**(ResolveTypePath-Ident-Local)**
|path| = 1    Γ ⊢ ResolveTypeName(path[0]) ⇓ ent    ent.origin_opt = ⊥    name = (ent.target_opt if present, else path[0])
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTypePath(path) ⇓ [name]

**(ResolveTypePath-Qual)**
|path| ≥ 2    path = p ++ [name]    Γ ⊢ ResolveQualified(p, name, TypeKind) ⇓ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveTypePath(path) ⇓ FullPath(PathOfModule(mp), name')

LocalTypePath(path) ⇔ |path| = 1 ∧ Γ ⊢ ResolveTypeName(path[0]) ⇓ ent ∧ ent.origin_opt = ⊥

**(ResolveClassPath-Ident)**
|path| = 1    Γ ⊢ ResolveClassName(path[0]) ⇓ ent    ent.origin_opt = p    name = (ent.target_opt if present, else path[0])
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassPath(path) ⇓ FullPath(PathOfModule(p), name)

**(ResolveClassPath-Qual)**
|path| ≥ 2    path = p ++ [name]    Γ ⊢ ResolveQualified(p, name, ClassKind) ⇓ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveClassPath(path) ⇓ FullPath(PathOfModule(mp), name')

**(ResolveType-Path)**
Γ ⊢ ResolveTypePath(path) ⇓ path'
──────────────────────────────────────────────
Γ ⊢ ResolveType(TypePath(path)) ⇓ TypePath(path')

**(ResolveType-Dynamic)**
Γ ⊢ ResolveClassPath(path) ⇓ path'
──────────────────────────────────────────────
Γ ⊢ ResolveType(TypeDynamic(path)) ⇓ TypeDynamic(path')

**(ResolveType-ModalState)**
Γ ⊢ ResolveTypePath(path) ⇓ path'
──────────────────────────────────────────────────────────────
Γ ⊢ ResolveType(TypeModalState(path, state)) ⇓ TypeModalState(path', state)

**(ResolveTypeRef-Path)**
Γ ⊢ ResolveTypePath(path) ⇓ path'
──────────────────────────────────────────────
Γ ⊢ ResolveTypeRef(TypePath(path)) ⇓ TypePath(path')

**(ResolveTypeRef-ModalState)**
Γ ⊢ ResolveTypePath(path) ⇓ path'
──────────────────────────────────────────────────────────────
Γ ⊢ ResolveTypeRef(ModalStateRef(path, state)) ⇓ ModalStateRef(path', state)

**(ResolveType-Hom)**
∀ i, Γ ⊢ ResolveType(t_i) ⇓ t_i'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveType(C(t_1, …, t_n)) ⇓ C(t_1', …, t_n')

**(ResolveParam)**
Γ ⊢ ResolveType(p.type) ⇓ ty'
──────────────────────────────────────────────
Γ ⊢ ResolveParam(p) ⇓ p[type = ty']

**(ResolveParams-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveParams([]) ⇓ []

**(ResolveParams-Cons)**
Γ ⊢ ResolveParam(p) ⇓ p'    Γ ⊢ ResolveParams(ps) ⇓ ps'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveParams(p :: ps) ⇓ p' :: ps'

ResolvePattern : Pattern ⇀ Pattern

**(ResolvePat-Wild)**
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(WildcardPattern) ⇓ WildcardPattern

**(ResolvePat-Ident)**
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(IdentifierPattern(x)) ⇓ IdentifierPattern(x)

**(ResolvePat-Literal)**
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(LiteralPattern(lit)) ⇓ LiteralPattern(lit)

**(ResolvePat-Typed)**
Γ ⊢ ResolveType(ty) ⇓ ty'
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(TypedPattern(x, ty)) ⇓ TypedPattern(x, ty')

**(ResolvePat-Tuple)**
Γ ⊢ ResolvePatternList(ps) ⇓ ps'
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(TuplePattern(ps)) ⇓ TuplePattern(ps')

**(ResolvePat-Record)**
Γ ⊢ ResolveTypePath(tp) ⇓ tp'    Γ ⊢ ResolveFieldPatternList(fs) ⇓ fs'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(RecordPattern(tp, fs)) ⇓ RecordPattern(tp', fs')

**(ResolvePat-Enum-Record-Fallback)**
Γ ⊢ ResolveTypePath(tp) ⇓ tp_e    EnumDecl(tp_e) ↑    Γ ⊢ ResolveTypePath(tp ++ [name]) ⇓ tp_r    Γ ⊢ ResolveFieldPatternList(fs) ⇓ fs'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(EnumPattern(tp, name, RecordPayloadPattern(fs))) ⇓ RecordPattern(tp_r, fs')

**(ResolvePat-Enum)**
Γ ⊢ ResolveTypePath(tp) ⇓ tp'    Γ ⊢ ResolveEnumPayloadPattern(payload_opt) ⇓ payload_opt'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(EnumPattern(tp, name, payload_opt)) ⇓ EnumPattern(tp', name, payload_opt')

**(ResolvePat-Modal)**
Γ ⊢ ResolveFieldPatternListOpt(fields_opt) ⇓ fields_opt'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(ModalPattern(state, fields_opt)) ⇓ ModalPattern(state, fields_opt')

**(ResolvePat-Range)**
Γ ⊢ ResolvePattern(p_l) ⇓ p_l'    Γ ⊢ ResolvePattern(p_h) ⇓ p_h'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePattern(RangePattern(kind, p_l, p_h)) ⇓ RangePattern(kind, p_l', p_h')

**(ResolvePatternList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolvePatternList([]) ⇓ []

**(ResolvePatternList-Cons)**
Γ ⊢ ResolvePattern(p) ⇓ p'    Γ ⊢ ResolvePatternList(ps) ⇓ ps'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolvePatternList(p :: ps) ⇓ p' :: ps'

**(ResolveFieldPattern-Implicit)**
──────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldPattern(⟨name, ⊥, span⟩) ⇓ ⟨name, ⊥, span⟩

**(ResolveFieldPattern-Explicit)**
Γ ⊢ ResolvePattern(p) ⇓ p'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldPattern(⟨name, p, span⟩) ⇓ ⟨name, p', span⟩

**(ResolveFieldPatternList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveFieldPatternList([]) ⇓ []

**(ResolveFieldPatternList-Cons)**
Γ ⊢ ResolveFieldPattern(f) ⇓ f'    Γ ⊢ ResolveFieldPatternList(fs) ⇓ fs'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldPatternList(f :: fs) ⇓ f' :: fs'

**(ResolveEnumPayloadPattern-None)**
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayloadPattern(⊥) ⇓ ⊥

**(ResolveEnumPayloadPattern-Tuple)**
Γ ⊢ ResolvePatternList(ps) ⇓ ps'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayloadPattern(TuplePayloadPattern(ps)) ⇓ TuplePayloadPattern(ps')

**(ResolveEnumPayloadPattern-Record)**
Γ ⊢ ResolveFieldPatternList(fs) ⇓ fs'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayloadPattern(RecordPayloadPattern(fs)) ⇓ RecordPayloadPattern(fs')

**(ResolveFieldPatternListOpt-None)**
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldPatternListOpt(⊥) ⇓ ⊥

**(ResolveFieldPatternListOpt-Some)**
Γ ⊢ ResolveFieldPatternList(fs) ⇓ fs'
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveFieldPatternListOpt(fs) ⇓ fs'

**(ResolveExpr-Ident)**
Γ ⊢ ResolveValueName(x) ⇓ ent
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(Identifier(x)) ⇓ Identifier(x)

**(ResolveExpr-Ident-Err)**
Γ ⊢ ResolveValueName(x) ⇑    c = Code(ResolveExpr-Ident-Err)
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(Identifier(x)) ⇑ c

**(ResolveExpr-Qualified)**
Γ ⊢ ResolveQualifiedForm(e) ⇓ e'
──────────────────────────────────────────────
Γ ⊢ ResolveExpr(e) ⇓ e'

ResolveArgsRef = {"5.1.6"}
ResolveFieldInitsRef = {"5.1.6"}

ResolveExprListJudg = {ResolveExprList}

**(ResolveExprList-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveExprList([]) ⇓ []

**(ResolveExprList-Cons)**
Γ ⊢ ResolveExpr(e) ⇓ e'    Γ ⊢ ResolveExprList(es) ⇓ es'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExprList(e :: es) ⇓ e' :: es'

ResolveEnumPayloadJudg = {ResolveEnumPayload}

**(ResolveEnumPayload-None)**
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayload(⊥) ⇓ ⊥

**(ResolveEnumPayload-Tuple)**
Γ ⊢ ResolveExprList(es) ⇓ es'
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayload(Paren(es)) ⇓ Paren(es')

**(ResolveEnumPayload-Record)**
Γ ⊢ ResolveFieldInits(fields) ⇓ fields'
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveEnumPayload(Brace(fields)) ⇓ Brace(fields')

ResolveCalleeJudg = {ResolveCallee}

**(ResolveCallee-Ident-Value)**
Γ ⊢ ResolveValueName(x) ⇓ ent
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveCallee(Identifier(x), args) ⇓ Identifier(x)

**(ResolveCallee-Ident-Record)**
Γ ⊢ ResolveValueName(x) ⇑    args = []    Γ ⊢ ResolveTypeName(x) ⇓ ent    ent.origin_opt = p    name = (ent.target_opt if present, else x)    RecordDecl(FullPath(PathOfModule(p), name)) = R
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveCallee(Identifier(x), args) ⇓ Identifier(x)

**(ResolveCallee-Path-Value)**
Γ ⊢ ResolveQualified(path, name, ValueKind) ⇓ ent
──────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveCallee(Path(path, name), args) ⇓ Path(path, name)

**(ResolveCallee-Path-Record)**
Γ ⊢ ResolveRecordPath(path, name) ⇓ p    args = []
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveCallee(Path(path, name), args) ⇓ Path(path, name)

**(ResolveCallee-Other)**
Γ ⊢ ResolveExpr(callee) ⇓ callee'
──────────────────────────────────────────────────────────────
Γ ⊢ ResolveCallee(callee, args) ⇓ callee'

**(ResolveExpr-Call)**
Γ ⊢ ResolveArgs(args) ⇓ args'    Γ ⊢ ResolveCallee(callee, args') ⇓ callee'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(Call(callee, args)) ⇓ Call(callee', args')

**(ResolveExpr-RecordExpr)**
Γ ⊢ ResolveTypeRef(tr) ⇓ tr'    Γ ⊢ ResolveFieldInits(fields) ⇓ fields'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(RecordExpr(tr, fields)) ⇓ RecordExpr(tr', fields')

**(ResolveExpr-EnumLiteral)**
Γ ⊢ ResolveEnumPayload(payload_opt) ⇓ payload_opt'
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(EnumLiteral(path, payload_opt)) ⇓ EnumLiteral(path, payload_opt')

ResolveArmJudg = {ResolveArm, ResolveArms}

**(ResolveArm)**
Γ_0 = PushScope(Γ)    Γ_0 ⊢ ResolvePattern(p) ⇓ p'    Γ_0 ⊢ BindPattern(p') ⇓ Γ_1    Γ_1 ⊢ ResolveExprOpt(g) ⇓ g'    Γ_1 ⊢ ResolveExpr(b) ⇓ b'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveArm(⟨p, g, b⟩) ⇓ ⟨p', g', b'⟩

**(ResolveArms-Empty)**
──────────────────────────────────────────────
Γ ⊢ ResolveArms([]) ⇓ []

**(ResolveArms-Cons)**
Γ ⊢ ResolveArm(a) ⇓ a'    Γ ⊢ ResolveArms(as) ⇓ as'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveArms(a :: as) ⇓ a' :: as'

**(ResolveExpr-Match)**
Γ ⊢ ResolveExpr(scrutinee) ⇓ scrutinee'    Γ ⊢ ResolveArms(arms) ⇓ arms'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(MatchExpr(scrutinee, arms)) ⇓ MatchExpr(scrutinee', arms')

**(ResolveExpr-LoopIter)**
Γ ⊢ ResolvePattern(pat) ⇓ pat'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'    Γ ⊢ ResolveExpr(iter) ⇓ iter'    Γ_0 = PushScope(Γ)    Γ_0 ⊢ BindPattern(pat') ⇓ Γ_1    Γ_1 ⊢ ResolveExpr(body) ⇓ body'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(LoopIter(pat, ty_opt, iter, body)) ⇓ LoopIter(pat', ty_opt', iter', body')

**(ResolveExpr-Alloc-Explicit-ByAlias)**
Γ ⊢ ResolveValueName(r) ⇓ ent    RegionAlias(ent)    Γ ⊢ ResolveExpr(e) ⇓ e'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(Binary("^", Identifier(r), e)) ⇓ AllocExpr(r, e')

ResolveExprRules = {ResolveExpr-Ident, ResolveExpr-Qualified, ResolveExpr-Call, ResolveExpr-RecordExpr, ResolveExpr-EnumLiteral, ResolveExpr-Match, ResolveExpr-LoopIter, ResolveExpr-Alloc-Explicit-ByAlias, ResolveExpr-Hom, ResolveExpr-Alloc-Implicit, ResolveExpr-Alloc-Explicit, ResolveExpr-Block}

NoSpecificResolveExpr(e) ⇔ ¬ ∃ r ∈ ResolveExprRules \ {ResolveExpr-Hom}. PremisesHold(r, e)

**(ResolveExpr-Hom)**
NoSpecificResolveExpr(C(e_1, …, e_n))    ∀ i, Γ ⊢ ResolveExpr(e_i) ⇓ e_i'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(C(e_1, …, e_n)) ⇓ C(e_1', …, e_n')

**(ResolveExpr-Alloc-Implicit)**
Γ ⊢ ResolveExpr(e) ⇓ e'
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(AllocExpr(⊥, e)) ⇓ AllocExpr(⊥, e')

**(ResolveExpr-Alloc-Explicit)**
Γ ⊢ ResolveValueName(r) ⇓ ent    Γ ⊢ ResolveExpr(e) ⇓ e'
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(AllocExpr(r, e)) ⇓ AllocExpr(r, e')

ResolveStmtSeqJudg = {ResolveStmtSeq}

**(ResolveStmtSeq-Empty)**
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmtSeq([]) ⇓ (Γ, [])

**(ResolveStmtSeq-Cons)**
Γ ⊢ ResolveStmt(s) ⇓ (Γ_1, s')    Γ_1 ⊢ ResolveStmtSeq(ss) ⇓ (Γ_2, ss')
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmtSeq(s :: ss) ⇓ (Γ_2, s' :: ss')

**(ResolveExpr-Block)**
Γ_0 = PushScope(Γ)    Γ_0 ⊢ ResolveStmtSeq(stmts) ⇓ (Γ_1, stmts')    (tail_opt = ⊥ ⇒ tail_opt' = ⊥)    (tail_opt = e ⇒ Γ_1 ⊢ ResolveExpr(e) ⇓ e' ∧ tail_opt' = e')
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveExpr(BlockExpr(stmts, tail_opt)) ⇓ BlockExpr(stmts', tail_opt')

**(BindNames-Empty)**
──────────────────────────────────────────────
Γ ⊢ BindNames([]) ⇓ Γ

**(BindNames-Cons)**
Γ ⊢ Intro(x, ⟨Value, ⊥, ⊥, Decl⟩) ⇓ Γ_1    Γ_1 ⊢ BindNames(xs) ⇓ Γ_2
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ BindNames(x :: xs) ⇓ Γ_2

**(BindPattern)**
Γ ⊢ PatNames(p) ⇓ ns    Γ ⊢ BindNames(ns) ⇓ Γ'
────────────────────────────────────────────────────────────────
Γ ⊢ BindPattern(p) ⇓ Γ'

**(ResolveStmt-Let)**
Γ ⊢ ResolveExpr(init) ⇓ init'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'    Γ ⊢ ResolvePattern(pat) ⇓ pat'    Γ ⊢ BindPattern(pat') ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(LetStmt(⟨pat, ty_opt, op, init, span⟩)) ⇓ (Γ', LetStmt(⟨pat', ty_opt', op, init', span⟩))

**(ResolveStmt-Var)**
Γ ⊢ ResolveExpr(init) ⇓ init'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'    Γ ⊢ ResolvePattern(pat) ⇓ pat'    Γ ⊢ BindPattern(pat') ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(VarStmt(⟨pat, ty_opt, op, init, span⟩)) ⇓ (Γ', VarStmt(⟨pat', ty_opt', op, init', span⟩))

**(ResolveStmt-ShadowLet)**
Γ ⊢ ResolveExpr(init) ⇓ init'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'    Γ ⊢ ShadowIntro(x, ⟨Value, ⊥, ⊥, Decl⟩) ⇓ Γ'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(ShadowLetStmt(x, ty_opt, init)) ⇓ (Γ', ShadowLetStmt(x, ty_opt', init'))

**(ResolveStmt-ShadowVar)**
Γ ⊢ ResolveExpr(init) ⇓ init'    Γ ⊢ ResolveTypeOpt(ty_opt) ⇓ ty_opt'    Γ ⊢ ShadowIntro(x, ⟨Value, ⊥, ⊥, Decl⟩) ⇓ Γ'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(ShadowVarStmt(x, ty_opt, init)) ⇓ (Γ', ShadowVarStmt(x, ty_opt', init'))

**(ResolveStmt-Defer)**
Γ ⊢ ResolveExpr(b) ⇓ b'
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(DeferStmt(b)) ⇓ (Γ, DeferStmt(b'))

**(ResolveStmt-Frame-Implicit)**
Γ ⊢ ResolveExpr(b) ⇓ b'
────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(FrameStmt(⊥, b)) ⇓ (Γ, FrameStmt(⊥, b'))

**(ResolveStmt-Frame-Explicit)**
Γ ⊢ ResolveValueName(r) ⇓ ent    Γ ⊢ ResolveExpr(b) ⇓ b'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(FrameStmt(r, b)) ⇓ (Γ, FrameStmt(r, b'))

**(ResolveStmt-Region)**
Γ ⊢ ResolveExprOpt(opts_opt) ⇓ opts_opt'    (alias_opt = ⊥ ⇒ Γ_r = Γ)    (alias_opt = r ⇒ Γ ⊢ Intro(r, ⟨Value, ⊥, ⊥, RegionAlias⟩) ⇓ Γ_r)    Γ_r ⊢ ResolveExpr(b) ⇓ b'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveStmt(RegionStmt(opts_opt, alias_opt, b)) ⇓ (Γ, RegionStmt(opts_opt', alias_opt, b'))

ResolveExprOpt(⊥) = ⊥
ResolveExprOpt(e) = e' ⇔ Γ ⊢ ResolveExpr(e) ⇓ e'

ResState = {ResStart(M), ResNames(M, N), ResItems(M, N), ResDone(M'), Error(code)}

**(Res-Start)**
──────────────────────────────────────────────
⟨ResStart(M)⟩ → ⟨ResNames(M, _)⟩

**(Res-Names)**
Γ ⊢ CollectNames(M) ⇓ N
──────────────────────────────────────────────────────────────
⟨ResNames(M, _)⟩ → ⟨ResItems(M, N)⟩

**(Res-Items)**
Γ ⊢ ResolveModule(M) ⇓ M'
──────────────────────────────────────────────────────────────
⟨ResItems(M, N)⟩ → ⟨ResDone(M')⟩

**ResolveModules (Big-Step).**

**(ResolveModules-Ok)**
Γ ⊢ ParseModules(P) ⇓ [M_1, …, M_k]    ∀ i, Γ ⊢ ResolveModule(M_i) ⇓ M_i'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveModules(P) ⇓ [M_1', …, M_k']

**(ResolveModules-Err-Parse)**
Γ ⊢ ParseModules(P) ⇑ c
──────────────────────────────────────────────────────────────
Γ ⊢ ResolveModules(P) ⇑ c

**(ResolveModules-Err-Resolve)**
Γ ⊢ ParseModules(P) ⇓ [M_1, …, M_k]    ∃ i. Γ ⊢ ResolveModule(M_i) ⇑ c
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ResolveModules(P) ⇑ c

### 5.2. Type System Core (Cursive0)

#### 5.2.1. Type Equivalence

TypeEqJudg = {≡}
ConstLenJudg = {ConstLen}

**(ConstLen-Lit)**
e = Literal(lit)    lit.kind = IntLiteral    InRange(IntValue(lit), "usize")    n = IntValue(lit)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ConstLen(e) ⇓ n

**(ConstLen-Path)**
e = Path(path, name)    ValuePathType(path, name) = T    StaticDecl(_, _, ⟨IdentPattern(name), _, "=", init, _⟩, _, _) ∈ Γ    Γ ⊢ ConstLen(init) ⇓ n
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ConstLen(e) ⇓ n

**(ConstLen-Err)**
¬ ∃ n. Γ ⊢ ConstLen(e) ⇓ n    c = Code(ConstLen-Err)
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ConstLen(e) ⇑ c

MembersEq([T_1, …, T_n], [U_1, …, U_n]) ⇔ ∃ U'. Permutation(U', [U_1, …, U_n]) ∧ ∀ i. 0 ≤ i < n ⇒ Γ ⊢ T_i ≡ U'[i]

**(T-Equiv-Prim)**
T = TypePrim(n)    U = TypePrim(n)
──────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Perm)**
T = TypePerm(p, T_0)    U = TypePerm(p, U_0)    Γ ⊢ T_0 ≡ U_0
────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Tuple)**
T = TypeTuple([T_1, …, T_n])    U = TypeTuple([U_1, …, U_n])    ∀ i, Γ ⊢ T_i ≡ U_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Array)**
T = TypeArray(T_0, e_0)    U = TypeArray(U_0, e_1)    Γ ⊢ ConstLen(e_0) ⇓ n    Γ ⊢ ConstLen(e_1) ⇓ n    Γ ⊢ T_0 ≡ U_0
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Slice)**
T = TypeSlice(T_0)    U = TypeSlice(U_0)    Γ ⊢ T_0 ≡ U_0
────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Func)**
T = TypeFunc([⟨m_1, T_1⟩, …, ⟨m_n, T_n⟩], R)    U = TypeFunc([⟨m_1, U_1⟩, …, ⟨m_n, U_n⟩], S)    ∀ i, Γ ⊢ T_i ≡ U_i    Γ ⊢ R ≡ S
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Union)**
T = TypeUnion([T_1, …, T_n])    U = TypeUnion([U_1, …, U_n])    MembersEq([T_1, …, T_n], [U_1, …, U_n])
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Path)**
T = TypePath(p)    U = TypePath(p)
──────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-ModalState)**
T = TypeModalState(p, S)    U = TypeModalState(p, S)
──────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-String)**
T = TypeString(st)    U = TypeString(st)
──────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Bytes)**
T = TypeBytes(st)    U = TypeBytes(st)
──────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Range)**
T = TypeRange    U = TypeRange
──────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Ptr)**
T = TypePtr(T_0, s)    U = TypePtr(U_0, s)    Γ ⊢ T_0 ≡ U_0
────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-RawPtr)**
T = TypeRawPtr(q, T_0)    U = TypeRawPtr(q, U_0)    Γ ⊢ T_0 ≡ U_0
────────────────────────────────────────────────────────────────
Γ ⊢ T ≡ U

**(T-Equiv-Dynamic)**
T = TypeDynamic(p)    U = TypeDynamic(p)
──────────────────────────────────────────────
Γ ⊢ T ≡ U

#### 5.2.2. Subtyping

SubtypingJudg = {<:}

∀ T, U ∈ IntTypes. T ≠ U ⇒ ¬(Γ ⊢ T <: U)

∀ T, U ∈ FloatTypes. T ≠ U ⇒ ¬(Γ ⊢ T <: U)

PermSubJudg = {PermSub}

**(Perm-Const)**
──────────────────────────────────────────────
`const` PermSub `const`

**(Perm-Unique)**
──────────────────────────────────────────────
`unique` PermSub `unique`

**(Perm-Unique-Const)**
──────────────────────────────────────────────
`unique` PermSub `const`

**(Sub-Perm)**
T = TypePerm(p, T_0)    U = TypePerm(q, U_0)    PermSub(p, q)    Γ ⊢ T_0 <: U_0
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Never)**
T ∈ 𝒯
──────────────────────────────────────────────────────────────
Γ ⊢ TypePrim("!") <: T

**(Sub-Tuple)**
T = TypeTuple([T_1, …, T_n])    U = TypeTuple([U_1, …, U_n])    ∀ i, Γ ⊢ T_i <: U_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Array)**
T = TypeArray(T_0, e_0)    U = TypeArray(U_0, e_1)    Γ ⊢ ConstLen(e_0) ⇓ n    Γ ⊢ ConstLen(e_1) ⇓ n    Γ ⊢ T_0 <: U_0
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Slice)**
T = TypeSlice(T_0)    U = TypeSlice(U_0)    Γ ⊢ T_0 <: U_0
────────────────────────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Range)**
T = TypeRange    U = TypeRange
──────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Ptr-State)**
s ∈ {`Valid`, `Null`}
──────────────────────────────────────────────────────────────
Γ ⊢ TypePtr(T, s) <: TypePtr(T, ⊥)

**(Sub-Modal-Niche)**
Σ.Types[p] = `modal` M    S ∈ States(M)    NicheCompatible(M, S)
────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TypeModalState(p, S) <: TypePath(p)

**(Sub-Func)**
T = TypeFunc([⟨m_1, T_1⟩, …, ⟨m_n, T_n⟩], R)    U = TypeFunc([⟨m_1, U_1⟩, …, ⟨m_n, U_n⟩], S)    ∀ i, Γ ⊢ U_i <: T_i    Γ ⊢ R <: S
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T <: U

Member(T, U) ⇔ U = TypeUnion([U_1, …, U_n]) ∧ ∃ i. Γ ⊢ T ≡ U_i

**(Sub-Member-Union)**
Member(T, U)
──────────────────────────────────────────────
Γ ⊢ T <: U

**(Sub-Union-Width)**
U_1 = TypeUnion([T_1, …, T_n])    U_2 = TypeUnion([U_1', …, U_m'])    ∀ i, Member(T_i, U_2)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ U_1 <: U_2

SubtypingRules = RulesIn({"5.2.2", "5.3.1", "5.7", "5.8"})

#### 5.2.3. Function Types

**(T-Proc-As-Value)**
procedure f(m_1 x_1 : T_1, …, m_n x_n : T_n) -> R declared
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ f : TypeFunc([⟨m_1, T_1⟩, …, ⟨m_n, T_n⟩], R)

FuncTypeRules = RulesIn({"5.2.1", "5.2.2"})

#### 5.2.4. Procedure Calls

ArgsOkTJudg = {ArgsOk_T}
ParamMode(⟨mode, T⟩) = mode
ParamType(⟨mode, T⟩) = T
ArgMoved(⟨moved, e, span⟩) = moved
ArgExpr(⟨moved, e, span⟩) = e
PlaceType(p) = T ⇔ Γ; R; L ⊢ p :place T
ArgType(a) =
  { ExprType(MovedArg(ArgMoved(a), ArgExpr(a)))  if ArgMoved(a) = true
    PlaceType(ArgExpr(a))                        if ArgMoved(a) = false }

**(ArgsT-Empty)**
──────────────────────────────────────────────
Γ; R; L ⊢ ArgsOk_T([], [])

**(ArgsT-Cons)**
Γ; R; L ⊢ MovedArg(moved, e) ⇐ T_p ⊣ ∅    moved = true    Γ; R; L ⊢ ArgsOk_T(ps, as)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ArgsOk_T([⟨`move`, T_p⟩] ++ ps, [⟨moved, e, _⟩] ++ as)

**(ArgsT-Cons-Ref)**
Γ; R; L ⊢ e ⇐_place T_p    AddrOfOk(e)    moved = false    Γ; R; L ⊢ ArgsOk_T(ps, as)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ArgsOk_T([⟨⊥, T_p⟩] ++ ps, [⟨moved, e, _⟩] ++ as)

**(T-Call)**
Γ; R; L ⊢ callee : TypeFunc(params, R_c)    Γ; R; L ⊢ ArgsOk_T(params, args)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) : R_c

**(Call-Callee-NotFunc)**
Γ; R; L ⊢ callee : T    T ≠ TypeFunc(_, _)    ¬(RecordCallee(callee) ∧ args = [])    c = Code(Call-Callee-NotFunc)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

**(Call-ArgCount-Err)**
Γ; R; L ⊢ callee : TypeFunc(params, _)    |params| ≠ |args|    c = Code(Call-ArgCount-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

**(Call-ArgType-Err)**
Γ; R; L ⊢ callee : TypeFunc(params, _)    ∃ i. ¬(Γ; R; L ⊢ ArgType(args[i]) <: ParamType(params[i]))    c = Code(Call-ArgType-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

**(Call-Move-Missing)**
Γ; R; L ⊢ callee : TypeFunc(params, _)    ∃ i. ParamMode(params[i]) = `move` ∧ ArgMoved(args[i]) = false    c = Code(Call-Move-Missing)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

**(Call-Move-Unexpected)**
Γ; R; L ⊢ callee : TypeFunc(params, _)    ∃ i. ParamMode(params[i]) = ⊥ ∧ ArgMoved(args[i]) = true    c = Code(Call-Move-Unexpected)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

**(Call-Arg-NotPlace)**
Γ; R; L ⊢ callee : TypeFunc(params, _)    ∃ i. ParamMode(params[i]) = ⊥ ∧ ¬ IsPlace(ArgExpr(args[i]))    c = Code(Call-Arg-NotPlace)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇑ c

#### 5.2.5. Tuples

**(T-Unit-Literal)**
────────────────────────────────────────────────────────────────
Γ ⊢ TupleExpr([]) : TypePrim("()")

**(T-Tuple-Literal)**
n ≥ 1    ∀ i, Γ ⊢ e_i : T_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleExpr([e_1, …, e_n]) : TypeTuple([T_1, …, T_n])

**(T-Tuple-Index)**
Γ ⊢ e : TypeTuple([T_0, …, T_{n-1}])    0 ≤ i < n    BitcopyType(T_i)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) : T_i

**(T-Tuple-Index-Perm)**
Γ ⊢ e : TypePerm(p, TypeTuple([T_0, …, T_{n-1}]))    0 ≤ i < n    BitcopyType(TypePerm(p, T_i))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) : TypePerm(p, T_i)

**(P-Tuple-Index)**
Γ ⊢ e :place TypeTuple([T_0, …, T_{n-1}])    0 ≤ i < n
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) :place T_i

**(P-Tuple-Index-Perm)**
Γ ⊢ e :place TypePerm(p, TypeTuple([T_0, …, T_{n-1}]))    0 ≤ i < n
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) :place TypePerm(p, T_i)

ConstTupleIndex(i) ⇔ ∃ n ∈ ℤ. i = n

**(TupleIndex-NonConst)**
¬ ConstTupleIndex(i)    c = Code(TupleIndex-NonConst)
────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) ⇑ c

**(TupleIndex-OOB)**
Γ ⊢ e : TypeTuple([T_0, …, T_{n-1}])    (i < 0 ∨ i ≥ n)    c = Code(TupleIndex-OOB)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) ⇑ c

**(TupleAccess-NotTuple)**
Γ ⊢ e : T    StripPerm(T) ≠ TypeTuple(_)    c = Code(TupleAccess-NotTuple)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TupleAccess(e, i) ⇑ c

#### 5.2.6. Arrays and Slices

ConstIndex(e) ⇔ ∃ n. Γ ⊢ ConstLen(e) ⇓ n

**(T-Array-Literal-List)**
∀ i, Γ ⊢ e_i : T
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ArrayExpr([e_1, …, e_n]) : TypeArray(T, Literal(IntLiteral(n)))

**(T-Index-Array)**
Γ ⊢ e_1 : TypeArray(T, len)    Γ ⊢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Γ ⊢ ConstLen(e_2) ⇓ i    Γ ⊢ ConstLen(len) ⇓ n    i < n    BitcopyType(T)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : T

**(T-Index-Array-Perm)**
Γ ⊢ e_1 : TypePerm(p, TypeArray(T, len))    Γ ⊢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Γ ⊢ ConstLen(e_2) ⇓ i    Γ ⊢ ConstLen(len) ⇓ n    i < n    BitcopyType(TypePerm(p, T))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : TypePerm(p, T)

**(Index-Array-NonConst-Err)**
Γ ⊢ e_1 : TypeArray(T, _)    Γ ⊢ e_2 : TypePrim("usize")    ¬ ConstIndex(e_2)    c = Code(Index-Array-NonConst-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

**(Index-Array-OOB-Err)**
Γ ⊢ e_1 : TypeArray(T, len)    ConstIndex(e_2)    Γ ⊢ ConstLen(e_2) ⇓ i    Γ ⊢ ConstLen(len) ⇓ n    i ≥ n    c = Code(Index-Array-OOB-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

**(Index-Slice-Direct-Err)**
Γ ⊢ e_1 : TypeSlice(T)    Γ ⊢ e_2 : TypePrim("usize")    c = Code(Index-Slice-Direct-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

**(Index-Slice-Perm-Direct-Err)**
Γ ⊢ e_1 : TypePerm(p, TypeSlice(T))    Γ ⊢ e_2 : TypePrim("usize")    c = Code(Index-Slice-Direct-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

**(T-Slice-From-Array)**
Γ ⊢ e_1 : TypeArray(T, n)    Γ; R; L ⊢ e_2 : Range    BitcopyType(TypeSlice(T))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : TypeSlice(T)

**(T-Slice-From-Array-Perm)**
Γ ⊢ e_1 : TypePerm(p, TypeArray(T, n))    Γ; R; L ⊢ e_2 : Range    BitcopyType(TypePerm(p, TypeSlice(T)))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : TypePerm(p, TypeSlice(T))

**(T-Slice-From-Slice)**
Γ ⊢ e_1 : TypeSlice(T)    Γ; R; L ⊢ e_2 : Range    BitcopyType(TypeSlice(T))
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : TypeSlice(T)

**(T-Slice-From-Slice-Perm)**
Γ ⊢ e_1 : TypePerm(p, TypeSlice(T))    Γ; R; L ⊢ e_2 : Range    BitcopyType(TypePerm(p, TypeSlice(T)))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) : TypePerm(p, TypeSlice(T))

**(P-Index-Array)**
Γ ⊢ e_1 :place TypeArray(T, len)    Γ ⊢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Γ ⊢ ConstLen(e_2) ⇓ i    Γ ⊢ ConstLen(len) ⇓ n    i < n
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place T

**(P-Index-Array-Perm)**
Γ ⊢ e_1 :place TypePerm(p, TypeArray(T, len))    Γ ⊢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Γ ⊢ ConstLen(e_2) ⇓ i    Γ ⊢ ConstLen(len) ⇓ n    i < n
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place TypePerm(p, T)

**(P-Slice-From-Array)**
Γ ⊢ e_1 :place TypeArray(T, n)    Γ; R; L ⊢ e_2 : Range
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place TypeSlice(T)

**(P-Slice-From-Array-Perm)**
Γ ⊢ e_1 :place TypePerm(p, TypeArray(T, n))    Γ; R; L ⊢ e_2 : Range
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place TypePerm(p, TypeSlice(T))

**(P-Slice-From-Slice)**
Γ ⊢ e_1 :place TypeSlice(T)    Γ; R; L ⊢ e_2 : Range
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place TypeSlice(T)

**(P-Slice-From-Slice-Perm)**
Γ ⊢ e_1 :place TypePerm(p, TypeSlice(T))    Γ; R; L ⊢ e_2 : Range
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) :place TypePerm(p, TypeSlice(T))

**(Coerce-Array-Slice)**
Γ ⊢ e : TypePerm(p, TypeArray(T, n))
──────────────────────────────────────────────────────────────
Γ ⊢ e : TypePerm(p, TypeSlice(T))

**(Index-Array-NonUsize)**
Γ ⊢ e_1 : TypeArray(T, _)    Γ ⊢ e_2 : T_i    T_i ≠ TypePrim("usize")    c = Code(Index-Array-NonUsize)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

**(Index-NonIndexable)**
Γ ⊢ e_1 : T    StripPerm(T) ∉ {TypeArray(_, _), TypeSlice(_)}    c = Code(Index-NonIndexable)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ IndexAccess(e_1, e_2) ⇑ c

#### 5.2.7. Union Types

Members(TypeUnion([T_1, …, T_n])) = [T_1, …, T_n]
DistinctMembers(U) = [T_i ∈ Members(U) | ∀ j < i. ¬(Γ ⊢ T_i ≡ T_j)]
SetMembers(U) = { T | T ∈ DistinctMembers(U) }

**(T-Union-Intro)**
Γ ⊢ e : T    Member(T, U)
──────────────────────────────────────────────
Γ ⊢ e : U

**(Union-DirectAccess-Err)**
Γ; R; L ⊢ e : U    StripPerm(U) = TypeUnion(_)    c = Code(Union-DirectAccess-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) ⇑ c

#### 5.2.8. Default Record Construction

Fields(R) = Fields_{§ 5.3.2}(R)

InitOk(f) ⇔ f = FieldDecl(vis, name, T_f, init_opt, span, doc) ∧ (init_opt = ⊥) ∨ (init_opt = e ∧ Γ; ⊥; ⊥ ⊢ e : T ∧ Γ ⊢ T <: T_f)

**(WF-Record)**
∀ f ∈ Fields(R), InitOk(f)    ∀ f_i ≠ f_j, f_i.name ≠ f_j.name
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ R record wf

**(WF-Record-DupField)**
∃ f_i ≠ f_j. f_i.name = f_j.name    c = Code(WF-Record-DupField)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ R record wf ⇑ c

DefaultConstructible(R) ⇔ ∀ f ∈ Fields(R). f.init_opt ≠ ⊥
RecordPath(R) = FullPath(ModuleOf(R), R.name)
RecordCallee(callee) = R ⇔ (callee = Identifier(name) ∨ callee = Path(path, name)) ∧ Γ ⊢ ResolveTypeName(name) ⇓ ent ∧ ent.origin_opt = mp ∧ name' = (ent.target_opt if present, else name) ∧ RecordDecl(FullPath(PathOfModule(mp), name')) = R

**(T-Record-Default)**
RecordCallee(callee) = R    Γ ⊢ R record wf    DefaultConstructible(R)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Call(callee, []) : TypePath(RecordPath(R))

**(Record-Default-Init-Err)**
RecordCallee(callee) = R    ¬ DefaultConstructible(R)    c = Code(Record-Default-Init-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Call(callee, []) ⇑ c

#### 5.2.9. Type Inference (Cursive0)

TypeInfJudg = {⇒, ⇐, Solve}

Constraint = Type × Type
ConstraintSet = ℘(Constraint)
Solve(C) ⇓ id ⇔ C = ∅
Solve(C) ⇑ ⇔ C ≠ ∅
∀ Γ, R, L, e, T, C. Γ; R; L ⊢ e ⇒ T ⊣ C ⇒ C = ∅
∀ Γ, R, L, e, T, C. Γ; R; L ⊢ e ⇐ T ⊣ C ⇒ C = ∅

**(Syn-Expr)**
Γ; R; L ⊢ e : T
──────────────────────────────────────────────
Γ; R; L ⊢ e ⇒ T ⊣ ∅

**(Syn-Ident)**
(x : T) ∈ Γ
──────────────────────────────────────────────
Γ; R; L ⊢ Identifier(x) ⇒ T ⊣ ∅

**(Syn-Unit)**
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ TupleExpr([]) ⇒ TypePrim("()") ⊣ ∅

**(Syn-Tuple)**
n ≥ 1    ∀ i, Γ; R; L ⊢ e_i ⇒ T_i ⊣ C_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ TupleExpr([e_1, …, e_n]) ⇒ TypeTuple([T_1, …, T_n]) ⊣ ⋃_i C_i

**(Syn-Call)**
Γ; R; L ⊢ callee ⇒ TypeFunc(params, R_c) ⊣ C_0    Γ; R; L ⊢ ArgsOk_T(params, args)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇒ R_c ⊣ C_0

**(Syn-Call-Err)**
Γ; R; L ⊢ Call(callee, args) ⇑ c
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Call(callee, args) ⇒ T ⊣ C ⇑ c

**(Chk-Subsumption-Modal-NonNiche)**
Γ; R; L ⊢ e ⇒ S ⊣ C    StripPerm(S) = TypeModalState(p, S_s)    StripPerm(T) = TypePath(p)    Σ.Types[p] = `modal` M    ¬ NicheCompatible(M, S_s)    c = Code(Chk-Subsumption-Modal-NonNiche)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ e ⇐ T ⇑ c

**(Chk-Subsumption)**
Γ; R; L ⊢ e ⇒ S ⊣ C    Γ ⊢ S <: T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ e ⇐ T ⊣ C

**(Chk-Null-Ptr)**
T = TypePtr(U, s)    s ∈ {`Null`, ⊥}
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ PtrNullExpr ⇐ T ⊣ ∅

PtrNullExpected(T) ⇔ T = TypePtr(U, s) ∧ s ∈ {`Null`, ⊥}

**(Syn-PtrNull-Err)**
c = Code(PtrNull-Infer-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ PtrNullExpr ⇒ T ⊣ C ⇑ c

**(Chk-PtrNull-Err)**
¬ PtrNullExpected(T)    c = Code(PtrNull-Infer-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ PtrNullExpr ⇐ T ⊣ C ⇑ c

#### 5.2.10. Literal Expressions (Cursive0)

IntTypes = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `isize`, `usize`}
FloatTypes = {`f16`, `f32`, `f64`}
FloatFormat("f16") = `binary16`    FloatFormat("f32") = `binary32`    FloatFormat("f64") = `binary64`
FloatBitWidth("f16") = 16    FloatBitWidth("f32") = 32    FloatBitWidth("f64") = 64
FloatValueSet(t) = { v | v is a value representable by IEEE 754-2019 format FloatFormat(t) }
IEEE754Encode(t, v) = bits ⇔ v ∈ FloatValueSet(t) ∧ bits ∈ [0, 2^{FloatBitWidth(t)} - 1] ∧ ((v is NaN in IEEE 754-2019 format FloatFormat(t) ∧ bits = CanonicalNaNBits(t)) ∨ (v is not NaN in IEEE 754-2019 format FloatFormat(t) ∧ bits is the IEEE 754-2019 encoding of v in format FloatFormat(t)))
CanonicalNaNBits("f16") = 0x7E00    CanonicalNaNBits("f32") = 0x7FC00000    CanonicalNaNBits("f64") = 0x7FF8000000000000
CanonicalNaN(t) = v ⇔ IEEE754Encode(t, v) = CanonicalNaNBits(t)
NonNaNValueSet(t) = { v ∈ FloatValueSet(t) | IEEE754Encode(t, v) ≠ CanonicalNaNBits(t) }
LSB(n) = n mod 2
EvenSignificandLSB(t, v) ⇔ LSB(IEEE754Encode(t, v)) = 0
DefaultInt = `i32`
DefaultFloat = `f64`
IntValue : Token ⇀ ℤ    FloatValue : Token ⇀ ℝ
IntSuffix : Token ⇀ IntTypes    FloatSuffix : Token ⇀ FloatTypes
IntCore(s) ⇔ s matches (`decimal_integer` | `hex_integer` | `octal_integer` | `binary_integer`)
FloatCore(s) ⇔ s matches `float_literal`
StripIntSuffix(s) = ⟨core, t⟩ ⇔ s = core ++ t ∧ t ∈ IntSuffixSet ∧ IntCore(core)
StripIntSuffix(s) = ⟨s, ⊥⟩ ⇔ ¬ ∃ t. s = core ++ t ∧ t ∈ IntSuffixSet ∧ IntCore(core)
StripFloatSuffix(s) = ⟨core, t⟩ ⇔ s = core ++ t ∧ t ∈ FloatSuffixSet ∧ FloatCore(core)
StripFloatSuffix(s) = ⟨s, ⊥⟩ ⇔ ¬ ∃ t. s = core ++ t ∧ t ∈ FloatSuffixSet ∧ FloatCore(core)
IntSuffix(lit) = t ⇔ lit.kind = IntLiteral ∧ StripIntSuffix(Lexeme(lit)) = ⟨_, t⟩
FloatSuffix(lit) = t ⇔ lit.kind = FloatLiteral ∧ StripFloatSuffix(Lexeme(lit)) = ⟨_, t⟩
IntValueCore(s) = v ⇔ (s = "0x" ++ h ∧ v = HexValue(Digits(h))) ∨ (s = "0o" ++ o ∧ v = OctValue(Digits(o))) ∨ (s = "0b" ++ b ∧ v = BinValue(Digits(b))) ∨ (s matches `decimal_integer` ∧ v = DecValue(Digits(s)))
IntValue(lit) = v ⇔ lit.kind = IntLiteral ∧ StripIntSuffix(Lexeme(lit)) = ⟨core, _⟩ ∧ IntValueCore(core) = v
FloatParts(s) = ⟨a, b, e⟩ ⇔ s = a ++ "." ++ b ++ exp ∧ (exp = "" ⇒ e = 0) ∧ (exp ≠ "" ⇒ exp = "e" ++ sign ++ d ∨ exp = "E" ++ sign ++ d) ∧ (sign = "" ⇒ e = DecValue(Digits(d))) ∧ (sign = "+" ⇒ e = DecValue(Digits(d))) ∧ (sign = "-" ⇒ e = -DecValue(Digits(d)))
FloatValueCore(s) = v ⇔ FloatParts(s) = ⟨a, b, e⟩ ∧ v = (DecValue(Digits(a)) · 10^{|Digits(b)|} + DecValue(Digits(b))) · 10^{e - |Digits(b)|}
FloatValue(lit) = v ⇔ lit.kind = FloatLiteral ∧ StripFloatSuffix(Lexeme(lit)) = ⟨core, _⟩ ∧ FloatValueCore(core) = v
InRange(v, T) ⇔ v ∈ RangeOf(T)
RangeOf : TypePrimName → ℘(ℝ)
RangeOf(t) = [-2^{w-1}, 2^{w-1} - 1] if t ∈ SignedIntTypes ∧ w = IntWidth(t)
RangeOf(t) = [0, 2^{w} - 1] if t ∈ UnsignedIntTypes ∧ w = IntWidth(t)
RangeOf(t) undefined otherwise

**(T-Int-Literal-Suffix)**
lit.kind = IntLiteral    IntSuffix(lit) = t    InRange(IntValue(lit), t)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim(t)

**(T-Int-Literal-Default)**
lit.kind = IntLiteral    IntSuffix(lit) = ⊥    InRange(IntValue(lit), `i32`)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim("i32")

**(T-Float-Literal-Suffix)**
lit.kind = FloatLiteral    FloatSuffix(lit) = t
────────────────────────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim(t)

**(T-Float-Literal-Default)**
lit.kind = FloatLiteral    FloatSuffix(lit) = ⊥
────────────────────────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim("f64")

**(T-Bool-Literal)**
lit.kind = BoolLiteral
──────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim("bool")

**(T-Char-Literal)**
lit.kind = CharLiteral
──────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypePrim("char")

**(T-String-Literal)**
lit.kind = StringLiteral
──────────────────────────────────────────────────────────────
Γ ⊢ Literal(lit) : TypeString(`@View`)

**(Syn-Literal)**
Γ ⊢ Literal(lit) : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇒ T ⊣ ∅

NullLiteralExpected(T) ⇔ T = TypeRawPtr(q, U)

**(Chk-Int-Literal)**
lit.kind = IntLiteral    T = TypePrim(t)    t ∈ IntTypes    InRange(IntValue(lit), t)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇐ T ⊣ ∅

**(Chk-Float-Literal)**
lit.kind = FloatLiteral    T = TypePrim(t)    t ∈ FloatTypes
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇐ T ⊣ ∅

**(Chk-Null-Literal)**
lit.kind = NullLiteral    T = TypeRawPtr(q, U)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇐ T ⊣ ∅

**(Syn-Null-Literal-Err)**
lit.kind = NullLiteral    c = Code(NullLiteral-Infer-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇒ T ⊣ C ⇑ c

**(Chk-Null-Literal-Err)**
lit.kind = NullLiteral    ¬ NullLiteralExpected(T)    c = Code(NullLiteral-Infer-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Literal(lit) ⇐ T ⊣ C ⇑ c

#### 5.2.11. Statement Typing (Cursive0)

MutKind = {`let`, `var`}
Bind = {⟨mut, T⟩ | mut ∈ MutKind ∧ T ∈ Type}
BindOf(Γ, x) = ⟨mut, T⟩ ⇔ ⟨mut, T⟩ is the binding for x in the nearest scope of Scopes(Γ)
(x : T) ∈ Γ ⇔ ∃ mut. BindOf(Γ, x) = ⟨mut, T⟩
MutOf(Γ, x) = mut ⇔ BindOf(Γ, x) = ⟨mut, T⟩

StmtJudg = {Γ; R; L ⊢ s ⇒ Γ' ▷ ⟨Res, Brk, BrkVoid⟩, Γ; R; L ⊢ ss ⇒ Γ' ▷ ⟨Res, Brk, BrkVoid⟩, Γ; R; L ⊢ e : T, Γ; R; L ⊢ b : T, Γ; R; L ⊢ BlockInfo(b) ⇓ ⟨T, Brk, BrkVoid⟩, Γ ⊢ pat ⇐ T ⊣ B}

LoopFlag = {⊥, `loop`}

PushScope(Γ) = Γ' ⇔ Scopes(Γ') = [∅] ++ Scopes(Γ) ∧ Project(Γ') = Project(Γ) ∧ ResCtx(Γ') = ResCtx(Γ)
PopScope(Γ') = Γ ⇔ Scopes(Γ') = [_] ++ Scopes(Γ) ∧ Project(Γ') = Project(Γ) ∧ ResCtx(Γ') = ResCtx(Γ)

IntroEnt = ⟨Value, ⊥, ⊥, Decl⟩

**(IntroAll-Empty)**
────────────────────────────────────────────────────────────────
IntroAll(Γ, []) ⇓ Γ

**(IntroAll-Cons)**
Γ ⊢ Intro(x, IntroEnt) ⇓ Γ_1    IntroAll(Γ_1 ∪ {x ↦ ⟨`let`, T⟩}, rest) ⇓ Γ_2
────────────────────────────────────────────────────────────────────────────────────────────────
IntroAll(Γ, [(x, T)] ++ rest) ⇓ Γ_2

**(IntroAllVar-Empty)**
────────────────────────────────────────────────────────────────
IntroAllVar(Γ, []) ⇓ Γ

**(IntroAllVar-Cons)**
Γ ⊢ Intro(x, IntroEnt) ⇓ Γ_1    IntroAllVar(Γ_1 ∪ {x ↦ ⟨`var`, T⟩}, rest) ⇓ Γ_2
────────────────────────────────────────────────────────────────────────────────────────────────
IntroAllVar(Γ, [(x, T)] ++ rest) ⇓ Γ_2

**(ShadowAll-Empty)**
────────────────────────────────────────────────────────────────
ShadowAll(Γ, []) ⇓ Γ

**(ShadowAll-Cons)**
Γ ⊢ ShadowIntro(x, IntroEnt) ⇓ Γ_1    ShadowAll(Γ_1 ∪ {x ↦ ⟨`let`, T⟩}, rest) ⇓ Γ_2
────────────────────────────────────────────────────────────────────────────────────────────────
ShadowAll(Γ, [(x, T)] ++ rest) ⇓ Γ_2

**(ShadowAllVar-Empty)**
────────────────────────────────────────────────────────────────
ShadowAllVar(Γ, []) ⇓ Γ

**(ShadowAllVar-Cons)**
Γ ⊢ ShadowIntro(x, IntroEnt) ⇓ Γ_1    ShadowAllVar(Γ_1 ∪ {x ↦ ⟨`var`, T⟩}, rest) ⇓ Γ_2
────────────────────────────────────────────────────────────────────────────────────────────────
ShadowAllVar(Γ, [(x, T)] ++ rest) ⇓ Γ_2

ResType([T_1, …, T_n]) = T ⇔ n ≥ 1 ∧ ∀ i. Γ ⊢ T_i ≡ T
ResType([]) = ⊥

LoopTypeInf(Brk, BrkVoid) =
  { TypePrim("!")    if Brk = [] ∧ BrkVoid = false
    TypePrim("()")   if Brk = [] ∧ BrkVoid = true
    T                if BrkVoid = false ∧ ResType(Brk) = T
    ⊥                otherwise }

LoopTypeFin(Brk, BrkVoid) =
  { TypePrim("()")   if Brk = []
    T                if BrkVoid = false ∧ ResType(Brk) = T
    ⊥                otherwise }

**Statement Sequences**

**(StmtSeq-Empty)**
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ [] ⇒ Γ ▷ ⟨[], [], false⟩

**(StmtSeq-Cons)**
Γ; R; L ⊢ s ⇒ Γ_1 ▷ ⟨Res_1, Brk_1, B_1⟩    Γ_1; R; L ⊢ ss ⇒ Γ_2 ▷ ⟨Res_2, Brk_2, B_2⟩
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ s :: ss ⇒ Γ_2 ▷ ⟨Res_1 ++ Res_2, Brk_1 ++ Brk_2, B_1 ∨ B_2⟩

**Bindings**

binding = ⟨pat, ty_opt, op, init, _⟩

**(T-LetStmt-Ann)**
ty_opt = T_a    Γ; R; L ⊢ init ⇐ T_a ⊣ ∅    Γ ⊢ pat ⇐ T_a ⊣ B    Distinct(PatNames(pat))    IntroAll(Γ, B) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ LetStmt(binding) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-LetStmt-Ann-Mismatch)**
ty_opt = T_a    Γ; R; L ⊢ init ⇒ T_i ⊣ C    ¬(Γ ⊢ T_i <: T_a)    c = Code(T-LetStmt-Ann-Mismatch)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ LetStmt(binding) ⇑ c

**(T-LetStmt-Infer)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇓ θ    T_b = θ(T_i)    Γ ⊢ pat ⇐ T_b ⊣ B    Distinct(PatNames(pat))    IntroAll(Γ, B) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ LetStmt(binding) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-LetStmt-Infer-Err)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇑    c = Code(T-LetStmt-Infer-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ LetStmt(binding) ⇑ c

**(T-VarStmt-Ann)**
ty_opt = T_a    Γ; R; L ⊢ init ⇐ T_a ⊣ ∅    Γ ⊢ pat ⇐ T_a ⊣ B    Distinct(PatNames(pat))    IntroAllVar(Γ, B) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ VarStmt(binding) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-VarStmt-Ann-Mismatch)**
ty_opt = T_a    Γ; R; L ⊢ init ⇒ T_i ⊣ C    ¬(Γ ⊢ T_i <: T_a)    c = Code(T-VarStmt-Ann-Mismatch)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ VarStmt(binding) ⇑ c

**(T-VarStmt-Infer)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇓ θ    T_b = θ(T_i)    Γ ⊢ pat ⇐ T_b ⊣ B    Distinct(PatNames(pat))    IntroAllVar(Γ, B) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ VarStmt(binding) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-VarStmt-Infer-Err)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇑    c = Code(T-VarStmt-Infer-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ VarStmt(binding) ⇑ c

**(T-ShadowLetStmt-Ann)**
ty_opt = T_a    Γ; R; L ⊢ init ⇐ T_a ⊣ ∅    ShadowAll(Γ, [⟨name, T_a⟩]) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowLetStmt(name, ty_opt, init) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-ShadowLetStmt-Ann-Mismatch)**
ty_opt = T_a    Γ; R; L ⊢ init ⇒ T_i ⊣ C    ¬(Γ ⊢ T_i <: T_a)    c = Code(T-ShadowLetStmt-Ann-Mismatch)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowLetStmt(name, ty_opt, init) ⇑ c

**(T-ShadowLetStmt-Infer)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇓ θ    T_b = θ(T_i)    ShadowAll(Γ, [⟨name, T_b⟩]) ⇓ Γ'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowLetStmt(name, ty_opt, init) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-ShadowLetStmt-Infer-Err)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇑    c = Code(T-ShadowLetStmt-Infer-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowLetStmt(name, ty_opt, init) ⇑ c

**(T-ShadowVarStmt-Ann)**
ty_opt = T_a    Γ; R; L ⊢ init ⇐ T_a ⊣ ∅    ShadowAllVar(Γ, [⟨name, T_a⟩]) ⇓ Γ'
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowVarStmt(name, ty_opt, init) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-ShadowVarStmt-Ann-Mismatch)**
ty_opt = T_a    Γ; R; L ⊢ init ⇒ T_i ⊣ C    ¬(Γ ⊢ T_i <: T_a)    c = Code(T-ShadowVarStmt-Ann-Mismatch)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowVarStmt(name, ty_opt, init) ⇑ c

**(T-ShadowVarStmt-Infer)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇓ θ    T_b = θ(T_i)    ShadowAllVar(Γ, [⟨name, T_b⟩]) ⇓ Γ'
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowVarStmt(name, ty_opt, init) ⇒ Γ' ▷ ⟨[], [], false⟩

**(T-ShadowVarStmt-Infer-Err)**
ty_opt = ⊥    Γ; R; L ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇑    c = Code(T-ShadowVarStmt-Infer-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ShadowVarStmt(name, ty_opt, init) ⇑ c

**Assignments**

PlaceRoot(Identifier(x)) = x
PlaceRoot(FieldAccess(p, _)) = PlaceRoot(p)
PlaceRoot(TupleAccess(p, _)) = PlaceRoot(p)
PlaceRoot(IndexAccess(p, _)) = PlaceRoot(p)
PlaceRoot(Deref(p)) = PlaceRoot(p)

**(T-Assign)**
IsPlace(p)    PlaceRoot(p) = x    MutOf(Γ, x) = `var`    Γ; R; L ⊢ p :place T_p    Γ; R; L ⊢ e ⇐ T_p ⊣ ∅
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AssignStmt(p, e) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-CompoundAssign)**
IsPlace(p)    PlaceRoot(p) = x    MutOf(Γ, x) = `var`    Γ; R; L ⊢ p :place T_p    StripPerm(T_p) = TypePrim(t)    t ∈ NumericTypes    Γ; R; L ⊢ e : T_e    Γ ⊢ T_e <: TypePrim(t)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ CompoundAssignStmt(p, op, e) ⇒ Γ ▷ ⟨[], [], false⟩

**(Assign-NotPlace)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    ¬ IsPlace(p)    c = Code(Assign-NotPlace)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ stmt ⇑ c

**(Assign-Immutable-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    PlaceRoot(p) = x    MutOf(Γ, x) = `let`    c = Code(Assign-Immutable-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ stmt ⇑ c

**(Assign-Type-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    Γ; R; L ⊢ p :place T_p    Γ; R; L ⊢ e ⇒ T_e ⊣ C    ((stmt = AssignStmt(p, e) ∧ ¬(Γ ⊢ T_e <: T_p)) ∨ (stmt = CompoundAssignStmt(p, op, e) ∧ (¬(Γ ⊢ T_e <: StripPerm(T_p)) ∨ ¬ ∃ t. StripPerm(T_p) = TypePrim(t) ∧ t ∈ NumericTypes)))    c = Code(Assign-Type-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ stmt ⇑ c

**Const-Qualified Places.**

**(Assign-Const-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    Γ; R; L ⊢ p : TypePerm(`const`, T)    c = Code(Assign-Const-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ stmt ⇑ c

**Expression and Unsafe Statements**

**(T-ExprStmt)**
Γ; R; L ⊢ e : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ExprStmt(e) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-UnsafeStmt)**
Γ; R; L ⊢ b : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ UnsafeBlockStmt(b) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-DeferStmt)**
Γ; R; L ⊢ b ⇐ TypePrim("()") ⊣ ∅    DeferSafe(b)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ DeferStmt(b) ⇒ Γ ▷ ⟨[], [], false⟩

**(Defer-NonUnit-Err)**
Γ; R; L ⊢ b : T_b    T_b ≠ TypePrim("()")    c = Code(Defer-NonUnit-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ DeferStmt(b) ⇑ c

**(Defer-NonLocal-Err)**
¬ DeferSafe(b)    c = Code(Defer-NonLocal-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ DeferStmt(b) ⇑ c

**(HasNonLocalCtrl-Return)**
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(ReturnStmt(_), in_loop)

**(HasNonLocalCtrl-Result)**
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(ResultStmt(_), in_loop)

**(HasNonLocalCtrl-Break)**
in_loop = false
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(BreakStmt(_), in_loop)

**(HasNonLocalCtrl-Continue)**
in_loop = false
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(ContinueStmt, in_loop)

**(HasNonLocalCtrl-LoopInfinite)**
HasNonLocalCtrl(body, true)
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(LoopInfinite(body), in_loop)

**(HasNonLocalCtrl-LoopConditional)**
HasNonLocalCtrl(body, true)
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(LoopConditional(_, body), in_loop)

**(HasNonLocalCtrl-LoopIter)**
HasNonLocalCtrl(body, true)
────────────────────────────────────────────────────────────────
HasNonLocalCtrl(LoopIter(_, _, _, body), in_loop)

**(HasNonLocalCtrl-Child)**
C ∉ {LoopInfinite, LoopConditional, LoopIter}    ∃ i. HasNonLocalCtrl(x_i, in_loop)
────────────────────────────────────────────────────────────────────────────────────────────────
HasNonLocalCtrl(C(x_1, …, x_n), in_loop)

DeferSafe(b) ⇔ ¬ HasNonLocalCtrl(b, false)

**(T-RegionStmt)**
RegionOptsExpr(opts_opt) = opts    Γ; R; L ⊢ opts ⇐ TypePath([`RegionOptions`]) ⊣ ∅    RegionBind(Γ, alias_opt) = Γ_r    Γ_r; R; L ⊢ b : T_b
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RegionStmt(opts_opt, alias_opt, b) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-FrameStmt-Implicit)**
FrameBind(Γ, ⊥) = Γ_f    Γ_f; R; L ⊢ b : T_b
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FrameStmt(⊥, b) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-FrameStmt-Explicit)**
FrameBind(Γ, r) = Γ_f    Γ_f; R; L ⊢ b : T_b
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FrameStmt(r, b) ⇒ Γ ▷ ⟨[], [], false⟩

**(Frame-NoActiveRegion-Err)**
InnermostActiveRegion(Γ) undefined    c = Code(Frame-NoActiveRegion-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FrameStmt(⊥, b) ⇑ c

**(Frame-Target-NotActive-Err)**
Γ; R; L ⊢ Identifier(r) : T_r    ¬ RegionActiveType(T_r)    c = Code(Frame-Target-NotActive-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FrameStmt(r, b) ⇑ c

**Control Flow Statements**

**(T-Return-Value)**
Γ; R; L ⊢ e ⇐ R ⊣ ∅
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ReturnStmt(e) ⇒ Γ ▷ ⟨[], [], false⟩

**(T-Return-Unit)**
R = TypePrim("()")
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ReturnStmt(⊥) ⇒ Γ ▷ ⟨[], [], false⟩

**(Return-Type-Err)**
Γ; R; L ⊢ e : T    ¬(Γ ⊢ T <: R)    c = Code(Return-Type-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ReturnStmt(e) ⇑ c

**(Return-Unit-Err)**
R ≠ TypePrim("()")    c = Code(Return-Type-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ReturnStmt(⊥) ⇑ c

**(T-ResultStmt)**
Γ; R; L ⊢ e : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ResultStmt(e) ⇒ Γ ▷ ⟨[T], [], false⟩

ResultNotLast(stmts) ⇔ ∃ pre, rest, e. stmts = pre ++ [ResultStmt(e)] ++ rest ∧ rest ≠ []

FirstResultSpan([]) = ⊥
FirstResultSpan(ResultStmt(e) :: rest) = span(ResultStmt(e))
FirstResultSpan(s :: rest) = FirstResultSpan(rest) if s ≠ ResultStmt(_)

**(Warn-Result-Unreachable)**
ResultNotLast(stmts)    FirstResultSpan(stmts) = sp    Γ ⊢ Emit(W-SEM-1001, sp)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok

**(Warn-Result-Ok)**
¬ ResultNotLast(stmts)
──────────────────────────────────────────────
Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok

**(T-Break-Value)**
L = `loop`    Γ; R; L ⊢ e : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BreakStmt(e) ⇒ Γ ▷ ⟨[], [T], false⟩

**(T-Break-Unit)**
L = `loop`
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BreakStmt(⊥) ⇒ Γ ▷ ⟨[], [], true⟩

**(Break-Outside-Loop)**
L ≠ `loop`    c = Code(Break-Outside-Loop)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BreakStmt(_) ⇑ c

**(T-Continue)**
L = `loop`
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ContinueStmt ⇒ Γ ▷ ⟨[], [], false⟩

**(Continue-Outside-Loop)**
L ≠ `loop`    c = Code(Continue-Outside-Loop)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ContinueStmt ⇑ c

**(T-ErrorStmt)**
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ErrorStmt(_) ⇒ Γ ▷ ⟨[], [], false⟩

**Block Expressions**

LastStmt([]) = ⊥
LastStmt([s_1, …, s_n]) = s_n    (n ≥ 1)

**(BlockInfo-Res)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = T    (tail_opt = e ⇒ Γ_1; R; L ⊢ e : T_e)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockInfo(BlockExpr(stmts, tail_opt)) ⇓ ⟨T, Brk, BrkVoid⟩

**(BlockInfo-Res-Err)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Res ≠ []    ¬ ∃ T. ResType(Res) = T    c = Code(BlockInfo-Res-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockInfo(BlockExpr(stmts, tail_opt)) ⇑ c

**(BlockInfo-Tail)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = e    Γ_1; R; L ⊢ e : T
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockInfo(BlockExpr(stmts, tail_opt)) ⇓ ⟨T, Brk, BrkVoid⟩

**(BlockInfo-ReturnTail)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = ⊥    LastStmt(stmts) = ReturnStmt(_)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockInfo(BlockExpr(stmts, ⊥)) ⇓ ⟨TypePrim("!"), Brk, BrkVoid⟩

**(BlockInfo-Unit)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = ⊥    LastStmt(stmts) ≠ ReturnStmt(_)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockInfo(BlockExpr(stmts, ⊥)) ⇓ ⟨TypePrim("()"), Brk, BrkVoid⟩

**(T-Block)**
Γ; R; L ⊢ BlockInfo(b) ⇓ ⟨T, _, _⟩
──────────────────────────────────────────────
Γ; R; L ⊢ b : T

**(Chk-Block-Tail)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = e    Γ_1; R; L ⊢ e ⇐ T ⊣ ∅
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockExpr(stmts, tail_opt) ⇐ T ⊣ ∅

**(Chk-Block-Return)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = ⊥    LastStmt(stmts) = ReturnStmt(_)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockExpr(stmts, ⊥) ⇐ T ⊣ ∅

**(Chk-Block-Unit)**
Γ_0 = PushScope(Γ)    Γ_0; R; L ⊢ stmts ⇒ Γ_1 ▷ ⟨Res, Brk, BrkVoid⟩    Γ ⊢ WarnResultUnreachable(stmts) ⇓ ok    ResType(Res) = ⊥    tail_opt = ⊥    LastStmt(stmts) ≠ ReturnStmt(_)    T = TypePrim("()")
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ BlockExpr(stmts, ⊥) ⇐ T ⊣ ∅

**(T-Unsafe-Expr)**
Γ; R; L ⊢ b : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ UnsafeBlockExpr(b) : T

**(Chk-Unsafe-Expr)**
Γ; R; L ⊢ b ⇐ T ⊣ ∅
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ UnsafeBlockExpr(b) ⇐ T ⊣ ∅

**Loop Expressions**

**(T-Loop-Infinite)**
Γ; R; `loop` ⊢ BlockInfo(body) ⇓ ⟨T_b, Brk, BrkVoid⟩    LoopTypeInf(Brk, BrkVoid) = T
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LoopInfinite(body) : T

**(T-Loop-Conditional)**
Γ; R; L ⊢ cond : TypePrim("bool")    Γ; R; `loop` ⊢ BlockInfo(body) ⇓ ⟨T_b, Brk, BrkVoid⟩    LoopTypeFin(Brk, BrkVoid) = T
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LoopConditional(cond, body) : T

**(T-Loop-Iter)**
(Γ; R; L ⊢ iter : TypePerm(p, TypeSlice(T)) ∨ Γ; R; L ⊢ iter : TypeSlice(T) ∨ Γ; R; L ⊢ iter : TypePerm(p, TypeArray(T, n)) ∨ Γ; R; L ⊢ iter : TypeArray(T, n))    (ty_opt = ⊥ ⇒ T_p = T)    (ty_opt = T_a ⇒ Γ ⊢ T <: T_a ∧ T_p = T_a)    Γ ⊢ pat ⇐ T_p ⊣ B    Distinct(PatNames(pat))    Γ_0 = PushScope(Γ)    IntroAll(Γ_0, B) ⇓ Γ_1    Γ_1; R; `loop` ⊢ BlockInfo(body) ⇓ ⟨T_b, Brk, BrkVoid⟩    LoopTypeFin(Brk, BrkVoid) = T_r
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ LoopIter(pat, ty_opt, iter, body) : T_r

**Irrefutable Binding Patterns**

PatJudg = {Γ ⊢ pat ⇐ T ⊣ B}

**(Pat-Dup-Err)**
¬ Distinct(PatNames(pat))    c = Code(Pat-Dup-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ pat ⇐ T ⇑ c

**(Pat-Wildcard)**
──────────────────────────────────────────────
Γ ⊢ _ ⇐ T ⊣ ∅

**(Pat-Ident)**
──────────────────────────────────────────────
Γ ⊢ x ⇐ T ⊣ {x ↦ T}

**(Pat-Unit)**
T = TypePrim("()")
──────────────────────────────────────────────
Γ ⊢ () ⇐ T ⊣ ∅

**(Pat-Tuple-Arity-Err)**
T = TypeTuple([T_1, …, T_n])    ps = [p_1, …, p_m]    m ≠ n    c = Code(Pat-Tuple-Arity-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ (p_1, …, p_m) ⇐ T ⇑ c

**(Pat-Tuple)**
T = TypeTuple([T_1, …, T_n])    ∀ i, Γ ⊢ p_i ⇐ T_i ⊣ B_i    B = ⊎_i B_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ (p_1, …, p_n) ⇐ T ⊣ B

**(Pat-Record)**
RecordDecl(p) = R ⇔ RecordPath(R) = p
FieldType(R, f) = T_f ⇔ ⟨_, f, T_f, _, _, _⟩ ∈ Fields(R)
FieldName(⟨f, _, _⟩) = f
PatOf(⟨f, ⊥, _⟩) = IdentifierPattern(f)
PatOf(⟨f, p, _⟩) = p    if p ≠ ⊥

T = TypePath(p)    RecordDecl(p) = R    ∀ fp ∈ fs, FieldType(R, FieldName(fp)) = T_f ∧ FieldVisible(m, R, FieldName(fp)) ∧ Γ ⊢ PatOf(fp) ⇐ T_f ⊣ B_f    B = ⊎_{fp ∈ fs} B_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ p{fs} ⇐ T ⊣ B

**(RecordPattern-UnknownField-Bind)**
T = TypePath(p)    RecordDecl(p) = R    ∃ fp ∈ fs. FieldName(fp) ∉ FieldNameSet(R)    c = Code(RecordPattern-UnknownField)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ p{fs} ⇐ T ⇑ c

**(Let-Refutable-Pattern-Err)**
pat ∈ {TypedPattern(_, _), LiteralPattern(_), EnumPattern(_, _, _), ModalPattern(_, _), RangePattern(_, _, _)}    c = Code(Let-Refutable-Pattern-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ pat ⇐ T ⇑ c

#### 5.2.12. Expression Typing (Cursive0)

UnresolvedExpr = {QualifiedName(_, _), QualifiedApply(_, _, _)}

**(Expr-Unresolved-Err)**
e ∈ UnresolvedExpr    c = Code(ResolveExpr-Ident-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ e ⇑ c

ExprJudg = {Γ; R; L ⊢ e : T, Γ; R; L ⊢ e ⇐ T ⊣ C, Γ; R; L ⊢ p :place T, Γ; R; L ⊢ p ⇐_place T, Γ; R; L ⊢ r : Range}

**(Lift-Expr)**
Γ ⊢ e : T
──────────────────────────────────────────────
Γ; R; L ⊢ e : T

**(Place-Check)**
Γ; R; L ⊢ p :place S    Γ ⊢ S <: T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ p ⇐_place T

StripPerm(T) =
  { T_0   if T = TypePerm(p, T_0)
    T     otherwise }
BitcopyType(T) ⇔ BitcopyTypeCore(T)
SignedIntTypes = {i8, i16, i32, i64, i128, isize}
NumericTypes = IntTypes ∪ FloatTypes
EqType(T) ⇔ (StripPerm(T) = TypePrim(t) ∧ t ∈ NumericTypes ∪ {`bool`, `char`}) ∨ StripPerm(T) = TypePtr(U, s) ∨ StripPerm(T) = TypeRawPtr(q, U) ∨ StripPerm(T) = TypeString(st) ∨ StripPerm(T) = TypeBytes(st)
OrdType(T) ⇔ StripPerm(T) = TypePrim(t) ∧ t ∈ IntTypes ∪ FloatTypes ∪ {`char`}
ValuePathType : Path × Ident ⇀ Type
ValuePathType(path, name) = StaticType(path, name) if StaticType(path, name) defined
ValuePathType(path, name) = TypeFunc([⟨mode, T⟩ | ⟨mode, x, T⟩ ∈ params], ProcReturn(ret_opt)) if DeclOf(path, name) = ProcedureDecl(_, name, params, ret_opt, _, _, _)
ValuePathType(path, name) undefined otherwise
UnsafeSpan(span) ⇔ ∃ U, K, D, K', i. ParseInputs(U, K, D, K') ∧ SourceOf(K'_i).path = span.file ∧ ∃ sp ∈ UnsafeSpans(K'_i). span ⊆ sp


**Identifiers and Paths**

**(T-Ident)**
(x : T) ∈ Γ    BitcopyType(T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Identifier(x) : T

**(T-Path-Value)**
ValuePathType(path, name) = T
──────────────────────────────────────────────
Γ; R; L ⊢ Path(path, name) : T

**Place Typing**

**(P-Ident)**
(x : T) ∈ Γ
──────────────────────────────────────────────
Γ; R; L ⊢ Identifier(x) :place T

**Record Field Access**

FieldVis(R, f) = vis ⇔ ⟨vis, f, T_f, _⟩ ∈ Fields(R)
FieldVisible(m, R, f) ⇔ FieldVis(R, f) ∈ {`public`, `internal`} ∨ (FieldVis(R, f) ∈ {`private`, `protected`} ∧ ModuleOfPath(RecordPath(R)) = m)

**(T-Field-Record)**
Γ; R; L ⊢ e : TypePath(p)    RecordDecl(p) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)    BitcopyType(T_f)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) : T_f

**(T-Field-Record-Perm)**
Γ; R; L ⊢ e : TypePerm(p, TypePath(q))    RecordDecl(q) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)    BitcopyType(TypePerm(p, T_f))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) : TypePerm(p, T_f)

**(P-Field-Record)**
Γ; R; L ⊢ e :place TypePath(p)    RecordDecl(p) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) :place T_f

**(P-Field-Record-Perm)**
Γ; R; L ⊢ e :place TypePerm(p, TypePath(q))    RecordDecl(q) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) :place TypePerm(p, T_f)

**(FieldAccess-Unknown)**
Γ; R; L ⊢ e : TypePath(p)    RecordDecl(p) = R    f ∉ FieldNameSet(R)    c = Code(FieldAccess-Unknown)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) ⇑ c

**(FieldAccess-NotVisible)**
Γ; R; L ⊢ e : TypePath(p)    RecordDecl(p) = R    f ∈ FieldNameSet(R)    ¬ FieldVisible(m, R, f)    c = Code(FieldAccess-NotVisible)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) ⇑ c

**(FieldAccess-Enum)**
Γ; R; L ⊢ e : TypePath(p)    EnumDecl(p) = E    c = Code(FieldAccess-Unknown)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ FieldAccess(e, f) ⇑ c

**(ValueUse-NonBitcopyPlace)**
IsPlace(e)    ¬ BitcopyType(ExprType(e))    c = Code(ValueUse-NonBitcopyPlace)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ e ⇑ c

**Error Expression**

**(T-ErrorExpr)**
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ ErrorExpr(_) : TypePrim("!")

**Range Expressions**

Γ; R; L ⊢ r : Range ⇒ ExprType(r) = TypeRange

**(Range-Full)**
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`Full`, ⊥, ⊥) : Range

**(Range-To)**
Γ; R; L ⊢ e : TypePrim("usize")
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`To`, ⊥, e) : Range

**(Range-ToInclusive)**
Γ; R; L ⊢ e : TypePrim("usize")
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`ToInclusive`, ⊥, e) : Range

**(Range-From)**
Γ; R; L ⊢ e : TypePrim("usize")
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`From`, e, ⊥) : Range

**(Range-Exclusive)**
Γ; R; L ⊢ e_1 : TypePrim("usize")    Γ; R; L ⊢ e_2 : TypePrim("usize")
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`Exclusive`, e_1, e_2) : Range

**(Range-Inclusive)**
Γ; R; L ⊢ e_1 : TypePrim("usize")    Γ; R; L ⊢ e_2 : TypePrim("usize")
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Range(`Inclusive`, e_1, e_2) : Range

**(Range-NonIndex-Err)**
e = Range(kind, lo_opt, hi_opt)    c = Code(Range-NonIndex-Err)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ e ⇑ c

**If Expressions**

**(T-If)**
Γ; R; L ⊢ c : TypePrim("bool")    Γ; R; L ⊢ b_t : T    Γ; R; L ⊢ b_f : T
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ IfExpr(c, b_t, b_f) : T

**(T-If-No-Else)**
Γ; R; L ⊢ c : TypePrim("bool")    Γ; R; L ⊢ b_t : TypePrim("()")
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ IfExpr(c, b_t, ⊥) : TypePrim("()")

**(Chk-If)**
Γ; R; L ⊢ c : TypePrim("bool")    Γ; R; L ⊢ b_t ⇐ T ⊣ ∅    Γ; R; L ⊢ b_f ⇐ T ⊣ ∅
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ IfExpr(c, b_t, b_f) ⇐ T ⊣ ∅

**(Chk-If-No-Else)**
Γ; R; L ⊢ c : TypePrim("bool")    T = TypePrim("()")    Γ; R; L ⊢ b_t ⇐ T ⊣ ∅
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ IfExpr(c, b_t, ⊥) ⇐ T ⊣ ∅

**Unary Operators**

**(T-Not-Bool)**
Γ; R; L ⊢ e : TypePrim("bool")
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Unary("!", e) : TypePrim("bool")

**(T-Not-Int)**
Γ; R; L ⊢ e : TypePrim(t)    t ∈ IntTypes
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Unary("!", e) : TypePrim(t)

**(T-Neg)**
Γ; R; L ⊢ e : TypePrim(t)    t ∈ SignedIntTypes ∪ FloatTypes
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Unary("-", e) : TypePrim(t)

**Binary Operators**

ArithOps = {"+", "-", "*", "/", "%", "**"}
BitOps = {"&", "|", "^"}
ShiftOps = {"<<", ">>"}
CmpOps = {"==", "!=", "<", "<=", ">", ">="}
LogicOps = {"&&", "||"}

**(T-Arith)**
Γ; R; L ⊢ e_1 : T    Γ; R; L ⊢ e_2 : T    StripPerm(T) = TypePrim(t)    t ∈ NumericTypes    op ∈ ArithOps
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Bitwise)**
Γ; R; L ⊢ e_1 : T    Γ; R; L ⊢ e_2 : T    StripPerm(T) = TypePrim(t)    t ∈ IntTypes    op ∈ BitOps
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Shift)**
Γ; R; L ⊢ e_1 : T_1    Γ; R; L ⊢ e_2 : TypePrim("u32")    StripPerm(T_1) = TypePrim(t)    t ∈ IntTypes    op ∈ ShiftOps
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Compare-Eq)**
Γ; R; L ⊢ e_1 : T    Γ; R; L ⊢ e_2 : T    EqType(T)    op ∈ {"==", "!="}
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim("bool")

**(T-Compare-Ord)**
Γ; R; L ⊢ e_1 : T    Γ; R; L ⊢ e_2 : T    OrdType(T)    op ∈ {"<", "<=", ">", ">="}
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim("bool")

**(T-Logical)**
Γ; R; L ⊢ e_1 : TypePrim("bool")    Γ; R; L ⊢ e_2 : TypePrim("bool")    op ∈ LogicOps
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Binary(op, e_1, e_2) : TypePrim("bool")

**Casts**

S' = StripPerm(S)
T' = StripPerm(T)
CastValid(S, T) ⇔ (S' = TypePrim(s) ∧ T' = TypePrim(t) ∧ s, t ∈ NumericTypes) ∨ (S' = TypePrim("bool") ∧ T' = TypePrim(t) ∧ t ∈ IntTypes) ∨ (S' = TypePrim(t) ∧ t ∈ IntTypes ∧ T' = TypePrim("bool")) ∨ (S' = TypePrim("char") ∧ T' = TypePrim("u32")) ∨ (S' = TypePrim("u32") ∧ T' = TypePrim("char"))

**(T-Cast)**
Γ; R; L ⊢ e : S    CastValid(S, T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Cast(e, T) : T

**Address-Of, Dereference, Move**

AddrOfOk(p) ⇔ IsPlace(p) ∧ (p = IndexAccess(_, idx) ⇒ Γ; R; L ⊢ idx : T_i ∧ StripPerm(T_i) = TypePrim("usize"))

**(T-AddrOf)**
Γ; R; L ⊢ p :place T    AddrOfOk(p)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AddressOf(p) : TypePtr(T, `Valid`)

**(T-Alloc-Explicit)**
Γ; R; L ⊢ e : T    Γ; R; L ⊢ Identifier(r) : T_r    RegionActiveType(T_r)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AllocExpr(r, e) : T

**(T-Alloc-Implicit)**
InnermostActiveRegion(Γ) = r    Γ; R; L ⊢ e : T
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AllocExpr(⊥, e) : T

**(Alloc-Region-NotFound-Err)**
$$\frac{e = \text{AllocExpr}(r, \_) \quad r \ne \bot \quad \Gamma; R; L \vdash \text{Identifier}(r) : T_r \quad \neg \text{RegionActiveType}(T_r) \quad c = \text{Code}(\text{Alloc-Region-NotFound-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

**(Alloc-Implicit-NoRegion-Err)**
$$\frac{e = \text{AllocExpr}(\bot, \_) \quad \text{InnermostActiveRegion}(\Gamma)\ \text{undefined} \quad c = \text{Code}(\text{Alloc-Implicit-NoRegion-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

**(T-Deref-Ptr)**
Γ; R; L ⊢ e : TypePtr(T, `Valid`)    BitcopyType(T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) : T

**(T-Deref-Raw)**
UnsafeSpan(span(Deref(e)))    Γ; R; L ⊢ e : TypeRawPtr(q, T)    BitcopyType(T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) : T

**(P-Deref-Ptr)**
Γ; R; L ⊢ e : TypePtr(T, `Valid`)
──────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) :place T

**(P-Deref-Raw-Imm)**
UnsafeSpan(span(Deref(e)))    Γ; R; L ⊢ e : TypeRawPtr(`imm`, T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) :place TypePerm(`const`, T)

**(P-Deref-Raw-Mut)**
UnsafeSpan(span(Deref(e)))    Γ; R; L ⊢ e : TypeRawPtr(`mut`, T)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) :place TypePerm(`unique`, T)

**(T-Move)**
Γ; R; L ⊢ p :place T
──────────────────────────────────────────────
Γ; R; L ⊢ MoveExpr(p) : T

**(AddrOf-NonPlace)**
¬ IsPlace(e)    c = Code(AddrOf-NonPlace)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AddressOf(e) ⇑ c

**(AddrOf-Index-Array-NonUsize)**
p = IndexAccess(base, idx)    Γ; R; L ⊢ base : TypeArray(T, n)    Γ; R; L ⊢ idx : T_i    StripPerm(T_i) ≠ TypePrim("usize")    c = Code(Index-Array-NonUsize)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AddressOf(p) ⇑ c

**(AddrOf-Index-Slice-NonUsize)**
p = IndexAccess(base, idx)    Γ; R; L ⊢ base : TypeSlice(T, n)    Γ; R; L ⊢ idx : T_i    StripPerm(T_i) ≠ TypePrim("usize")    c = Code(Index-Slice-NonUsize)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ AddressOf(p) ⇑ c

**(Deref-Null)**
Γ; R; L ⊢ e : TypePtr(T, `Null`)    c = Code(Deref-Null)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) ⇑ c

**(Deref-Expired)**
Γ; R; L ⊢ e : TypePtr(T, `Expired`)    c = Code(Deref-Expired)
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) ⇑ c

**(Deref-Raw-Unsafe)**
Γ; R; L ⊢ e : TypeRawPtr(q, T)    ¬ UnsafeSpan(span(Deref(e)))    c = Code(Deref-Raw-Unsafe)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Deref(e) ⇑ c

**Transmute**

**(T-Transmute-SizeEq)**
Γ ⊢ sizeof(t_1) = sizeof(t_2)
────────────────────────────────────────────────────────────────
Γ ⊢ TransmuteSizeOk(t_1, t_2)

**(T-Transmute-AlignEq)**
Γ ⊢ alignof(t_1) = alignof(t_2)
────────────────────────────────────────────────────────────────
Γ ⊢ TransmuteAlignOk(t_1, t_2)

**(T-Transmute)**
UnsafeSpan(span(TransmuteExpr(t_1, t_2, e)))    Γ ⊢ t_1 wf    Γ ⊢ t_2 wf    Γ ⊢ TransmuteSizeOk(t_1, t_2)    Γ ⊢ TransmuteAlignOk(t_1, t_2)    Γ; R; L ⊢ e : t_1
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ TransmuteExpr(t_1, t_2, e) : t_2

**(Transmute-Unsafe-Err)**
¬ UnsafeSpan(span(TransmuteExpr(t_1, t_2, e)))    c = Code(Transmute-Unsafe-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ TransmuteExpr(t_1, t_2, e) ⇑ c

**Propagation (`?`)**

SuccessMember(R, U) = T_s ⇔ U = TypeUnion([T_1, …, T_n]) ∧ ¬(Γ ⊢ T_s <: R) ∧ ∀ i ≠ s. Γ ⊢ T_i <: R

**(T-Propagate)**
Γ; R; L ⊢ e : U    SuccessMember(R, U) = T_s
────────────────────────────────────────────────────────────────
Γ; R; L ⊢ Propagate(e) : T_s

**Record Literals**

FieldNames(R) = [ f.name | f ∈ Fields(R) ]
FieldInitNames(fields) = [ f | ⟨f, _⟩ ∈ fields ]
Set(xs) = { x | x ∈ xs }
FieldNameSet(R) = Set(FieldNames(R))
FieldInitSet(fields) = Set(FieldInitNames(fields))

**(T-Record-Literal)**
RecordDecl(p) = R    Distinct(FieldInitNames(fields))    FieldInitSet(fields) = FieldNameSet(R)    ∀ ⟨f, e⟩ ∈ fields, FieldType(R, f) = T_f ∧ FieldVisible(m, R, f) ∧ Γ; R; L ⊢ e ⇐ T_f ⊣ ∅
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) : TypePath(p)

**(Record-FieldInit-Dup)**
RecordDecl(p) = R    ¬ Distinct(FieldInitNames(fields))    c = Code(Record-FieldInit-Dup)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) ⇑ c

**(Record-FieldInit-Missing)**
RecordDecl(p) = R    FieldInitSet(fields) ≠ FieldNameSet(R)    c = Code(Record-FieldInit-Missing)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) ⇑ c

**(Record-Field-Unknown)**
RecordDecl(p) = R    ∃ ⟨f, e⟩ ∈ fields. f ∉ FieldNameSet(R)    c = Code(Record-Field-Unknown)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) ⇑ c

**(Record-Field-NotVisible)**
RecordDecl(p) = R    ∃ ⟨f, e⟩ ∈ fields. ¬ FieldVisible(m, R, f)    c = Code(Record-Field-NotVisible)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) ⇑ c

**(Record-Field-NonBitcopy-Move)**
RecordDecl(p) = R    ∃ ⟨f, e⟩ ∈ fields. FieldType(R, f) = T_f ∧ ¬ BitcopyType(T_f) ∧ IsPlace(e) ∧ e ≠ MoveExpr(_)    c = Code(Record-Field-NonBitcopy-Move)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ RecordExpr(TypePath(p), fields) ⇑ c

**Enum Literals**

EnumDecl(p) = E ⇔ EnumPathOf(E) = p
VariantPayload(E, v) = payload_opt ⇔ ∃ disc, span, doc. VariantDecl(v, payload_opt, disc, span, doc) ∈ E.variants
VariantFieldNames(fs) = [ f | FieldDecl(_, f, _, _, _, _) ∈ fs ]
VariantFieldNameSet(fs) = Set(VariantFieldNames(fs))

EnumFieldType(E, v, f) = T_f ⇔ VariantPayload(E, v) = RecordPayload(fs) ∧ ⟨_, f, T_f, _, _, _⟩ ∈ fs

**(T-Enum-Lit-Unit)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = ⊥
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ EnumLiteral(path, ⊥) : TypePath(EnumPath(path))

**(T-Enum-Lit-Tuple)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = TuplePayload([T_1, …, T_n])    ∀ i, Γ; R; L ⊢ e_i ⇐ T_i ⊣ ∅
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ EnumLiteral(path, Paren([e_1, …, e_n])) : TypePath(EnumPath(path))

**(T-Enum-Lit-Record)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = RecordPayload(fs)    Distinct(FieldInitNames(fields))    FieldInitSet(fields) = VariantFieldNameSet(fs)    ∀ ⟨f, e⟩ ∈ fields, Γ; R; L ⊢ e ⇐ EnumFieldType(E, v, f) ⊣ ∅
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ EnumLiteral(path, Brace(fields)) : TypePath(EnumPath(path))

#### 5.2.13. Pattern Matching (Cursive0)

MatchJudg = {Γ ⊢ pat ◁ T ⊣ B, Γ; R; L ⊢ ArmBody(body) : T, Γ; R; L ⊢ ArmBody(body) ⇐ T}

PermWrap(T, B) =
  { { x ↦ TypePerm(p, T_x) | x ↦ T_x ∈ B }    if T = TypePerm(p, U)
    B                                      otherwise }

**(Pat-StripPerm)**
Γ ⊢ pat ◁ StripPerm(T) ⊣ B
──────────────────────────────────────────────
Γ ⊢ pat ◁ T ⊣ PermWrap(T, B)

PatternEffectRules = RulesIn({"5.2.15"})

ConstPatInt(p) = n ⇔ p = LiteralPattern(IntLiteral(n))

**(ArmBody-Expr)**
Γ; R; L ⊢ e : T
──────────────────────────────────────────────
Γ; R; L ⊢ ArmBody(e) : T

**(ArmBody-Block)**
Γ; R; L ⊢ b : T
──────────────────────────────────────────────
Γ; R; L ⊢ ArmBody(b) : T

**(ArmBody-Expr-Chk)**
Γ; R; L ⊢ e ⇐ T ⊣ ∅
──────────────────────────────────────────────
Γ; R; L ⊢ ArmBody(e) ⇐ T

**(ArmBody-Block-Chk)**
Γ; R; L ⊢ b ⇐ T ⊣ ∅
──────────────────────────────────────────────
Γ; R; L ⊢ ArmBody(b) ⇐ T

**(Pat-Dup-R-Err)**
¬ Distinct(PatNames(pat))    c = Code(Pat-Dup-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ pat ◁ T ⇑ c

**(Pat-Wildcard-R)**
──────────────────────────────────────────────
Γ ⊢ _ ◁ T ⊣ ∅

**(Pat-Ident-R)**
──────────────────────────────────────────────
Γ ⊢ x ◁ T ⊣ {x ↦ T}

**(Pat-Literal-R)**
Γ ⊢ Literal(lit) : T_l    Γ ⊢ T_l <: T
────────────────────────────────────────────────────────────────
Γ ⊢ LiteralPattern(lit) ◁ T ⊣ ∅

**(Pat-Tuple-R-Arity-Err)**
StripPerm(T) = TypeTuple([T_1, …, T_n])    ps = [p_1, …, p_m]    m ≠ n    c = Code(Pat-Tuple-Arity-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TuplePattern(ps) ◁ T ⇑ c

**(Pat-Tuple-R)**
StripPerm(T) = TypeTuple([T_1, …, T_n])    ∀ i, Γ ⊢ p_i ◁ T_i ⊣ B_i    B = ⊎_i B_i
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ TuplePattern([p_1, …, p_n]) ◁ T ⊣ B

**(Pat-Record-R)**
StripPerm(T) = TypePath(p)    RecordDecl(p) = R    ∀ fp ∈ fs, FieldType(R, FieldName(fp)) = T_f ∧ FieldVisible(m, R, FieldName(fp)) ∧ Γ ⊢ PatOf(fp) ◁ T_f ⊣ B_f    B = ⊎_{fp ∈ fs} B_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ RecordPattern(p, fs) ◁ T ⊣ B

**(RecordPattern-UnknownField)**
StripPerm(T) = TypePath(p)    RecordDecl(p) = R    ∃ fp ∈ fs. FieldName(fp) ∉ FieldNameSet(R)    c = Code(RecordPattern-UnknownField)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ RecordPattern(p, fs) ◁ T ⇑ c

**(Pat-Enum-Unit-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = ⊥
────────────────────────────────────────────────────────────────
Γ ⊢ EnumPattern(p, v, ⊥) ◁ T ⊣ ∅

**(Pat-Enum-Tuple-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = TuplePayload([T_1, …, T_n])    ∀ i, Γ ⊢ p_i ◁ T_i ⊣ B_i    B = ⊎_i B_i
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ EnumPattern(p, v, TuplePayloadPattern([p_1, …, p_n])) ◁ T ⊣ B

**(Pat-Enum-Record-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = RecordPayload(fs')    ∀ fp ∈ fs, EnumFieldType(E, v, FieldName(fp)) = T_f ∧ Γ ⊢ PatOf(fp) ◁ T_f ⊣ B_f    B = ⊎_{fp ∈ fs} B_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ EnumPattern(p, v, RecordPayloadPattern(fs)) ◁ T ⊣ B

**(Pat-Modal-R)**
StripPerm(T) = TypePath(p)    Σ.Types[p] = `modal` M    S ∈ States(M)    ∀ fp ∈ fs, PayloadMap(M, S)(FieldName(fp)) = T_f ∧ Γ ⊢ PatOf(fp) ◁ T_f ⊣ B_f    B = ⊎_{fp ∈ fs} B_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ModalPattern(S, fs) ◁ T ⊣ B

**(Pat-Modal-State-R)**
StripPerm(T) = TypeModalState(p, S)    Σ.Types[p] = `modal` M    ∀ fp ∈ fs, PayloadMap(M, S)(FieldName(fp)) = T_f ∧ Γ ⊢ PatOf(fp) ◁ T_f ⊣ B_f    B = ⊎_{fp ∈ fs} B_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ModalPattern(S, fs) ◁ T ⊣ B

**(Pat-Range-R)**
StripPerm(T) = TypePrim(t)    t ∈ IntTypes    ConstPatInt(p_l) = n_l    ConstPatInt(p_h) = n_h    (kind = ".." ⇒ n_l < n_h)    (kind = "..=" ⇒ n_l ≤ n_h)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ RangePattern(kind, p_l, p_h) ◁ T ⊣ ∅

**(RangePattern-NonConst)**
(ConstPatInt(p_l) undefined ∨ ConstPatInt(p_h) undefined)    c = Code(RangePattern-NonConst)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ RangePattern(kind, p_l, p_h) ◁ T ⇑ c

**(RangePattern-Empty)**
ConstPatInt(p_l) = n_l    ConstPatInt(p_h) = n_h    ((kind = "..") ⇒ n_l ≥ n_h)    ((kind = "..=") ⇒ n_l > n_h)    c = Code(RangePattern-Empty)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ RangePattern(kind, p_l, p_h) ◁ T ⇑ c

AllEq_Γ([T_1, …, T_n]) ⇔ ∀ i. Γ ⊢ T_i ≡ T_1
Irrefutable(pat, T) ⇔ pat = WildcardPattern ∨ pat = IdentifierPattern(_) ∨ (pat = TuplePattern([p_1, …, p_n]) ∧ StripPerm(T) = TypeTuple([T_1, …, T_n]) ∧ ∀ i. Irrefutable(p_i, T_i)) ∨ (pat = RecordPattern(p, fs) ∧ StripPerm(T) = TypePath(p) ∧ RecordDecl(p) = R ∧ ∀ fp ∈ fs. Irrefutable(PatOf(fp), FieldType(R, FieldName(fp))))
HasIrrefutableArm(arms, T) ⇔ ∃ arm ∈ arms. ∃ p, g, b. arm = ⟨p, g, b⟩ ∧ Irrefutable(p, T)

**Enum Match**

VariantNames(E) = [ v.name | v ∈ E.variants ]
ArmVariants(arms) = { v | ∃ p, g, b. ⟨p, g, b⟩ ∈ arms ∧ p = EnumPattern(_, v, _) }

**(T-Match-Enum)**
Γ; R; L ⊢ e : TypePath(p)    EnumDecl(p) = E    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypePath(p) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) : T_i    AllEq_Γ([T_1, …, T_k])    (HasIrrefutableArm(arms, TypePath(p)) ∨ ArmVariants(arms) = VariantNames(E))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) : T_1

**Modal Match**

StateNames(M) = States(M)
ArmStates(arms) = { s | ∃ p, g, b. ⟨p, g, b⟩ ∈ arms ∧ p = ModalPattern(_, s) }

**(T-Match-Modal)**
Γ; R; L ⊢ e : TypePath(p)    Σ.Types[p] = `modal` M    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypePath(p) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) : T_i    AllEq_Γ([T_1, …, T_k])    (HasIrrefutableArm(arms, TypePath(p)) ∨ ArmStates(arms) = StateNames(M))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) : T_1

**(Match-Modal-NonExhaustive)**
Γ; R; L ⊢ e : TypePath(p)    Σ.Types[p] = `modal` M    ¬(HasIrrefutableArm(arms, TypePath(p)) ∨ ArmStates(arms) = StateNames(M))    c = Code(Match-Modal-NonExhaustive)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇑ c

**Union Match**

UnionTypes(U) = [T_1, …, T_n] ⇔ U = TypeUnion([T_1, …, T_n])
ArmUnionTypes(arms) = { T | ∃ p, g, b. ⟨p, g, b⟩ ∈ arms ∧ p = Pat-Union(T, _) }
UnionTypesExhaustive(arms, types) ⇔ ∀ T ∈ types. ∃ arm ∈ arms. ∃ p, g, b. arm = ⟨p, g, b⟩ ∧ p = Pat-Union(T, _)

**(T-Match-Union)**
Γ; R; L ⊢ e : TypeUnion([T_1, …, T_n])    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypeUnion([T_1, …, T_n]) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) : T_i'    AllEq_Γ([T_1', …, T_k'])    (HasIrrefutableArm(arms, TypeUnion([T_1, …, T_n])) ∨ UnionTypesExhaustive(arms, [T_1, …, T_n]))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) : T_1'

**(Match-Union-NonExhaustive)**
Γ; R; L ⊢ e : TypeUnion([T_1, …, T_n])    ¬(HasIrrefutableArm(arms, TypeUnion([T_1, …, T_n])) ∨ UnionTypesExhaustive(arms, [T_1, …, T_n]))    c = Code(Match-Union-NonExhaustive)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇑ c

**(Chk-Match-Union)**
Γ; R; L ⊢ e : TypeUnion([T_1, …, T_n])    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypeUnion([T_1, …, T_n]) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) ⇐ T    (HasIrrefutableArm(arms, TypeUnion([T_1, …, T_n])) ∨ UnionTypesExhaustive(arms, [T_1, …, T_n]))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇐ T ⊣ ∅

**Other Matches**

**(T-Match-Other)**
Γ; R; L ⊢ e : T    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ T ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) : T_i    AllEq_Γ([T_1, …, T_k])    HasIrrefutableArm(arms, T)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) : T_1

**(Chk-Match-Enum)**
Γ; R; L ⊢ e : TypePath(p)    EnumDecl(p) = E    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypePath(p) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) ⇐ T    (HasIrrefutableArm(arms, TypePath(p)) ∨ ArmVariants(arms) = VariantNames(E))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇐ T ⊣ ∅

**(Chk-Match-Modal)**
Γ; R; L ⊢ e : TypePath(p)    Σ.Types[p] = `modal` M    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ TypePath(p) ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) ⇐ T    (HasIrrefutableArm(arms, TypePath(p)) ∨ ArmStates(arms) = StateNames(M))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇐ T ⊣ ∅

**(Chk-Match-Other)**
Γ; R; L ⊢ e : T_s    ∀ i, arm_i = ⟨p_i, g_i, b_i⟩    Γ ⊢ p_i ◁ T_s ⊣ B_i    Distinct(PatNames(p_i))    Γ_i = IntroAll(Γ, B_i)    (g_i ≠ ⊥ ⇒ Γ_i; R; L ⊢ g_i : TypePrim("bool"))    Γ_i; R; L ⊢ ArmBody(b_i) ⇐ T    HasIrrefutableArm(arms, T_s)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; R; L ⊢ MatchExpr(e, arms) ⇐ T ⊣ ∅

#### 5.2.14. Declaration Typing (Cursive0)

DeclJudg = {Γ ⊢ ProcedureDecl : ok, Γ ⊢ StaticDecl : ok, Γ ⊢ RecordDecl : ok, Γ ⊢ EnumDecl : ok, Γ ⊢ ModalDecl : ok, Γ ⊢ ClassDecl : ok}

**DeclTyping.**
DeclTyping(Ms) ⇓ ok ⇔ ∀ M ∈ Ms. Γ ⊢ DeclTypingMod(M) ⇓ ok
DeclTypingMod(M) ⇓ ok ⇔ ∀ it ∈ M.items. Γ ⊢ DeclTypingItem(M.path, it) ⇓ ok

ProvBindCheck(params, body) ⇓ ok ⇔ body = BlockExpr(stmts, tail_opt) ∧ ∃ vec{π}. |vec{π}| = |params| ∧ Γ; InitProvEnv(params, vec{π}, []) ⊢ BlockProv(stmts, tail_opt) ⇓ π

DeclTypingItem(m, UsingDecl(_)) ⇓ ok
DeclTypingItem(m, StaticDecl(_, _, _, _, _)) ⇓ ok ⇔ Γ ⊢ StaticDecl : ok
DeclTypingItem(m, TypeAliasDecl(_, name, _, _, _)) ⇓ ok ⇔ Γ ⊢ FullPath(m, name) : TypeAliasOk
DeclTypingItem(m, ProcedureDecl(_, _, params, _, body, _, _) = item) ⇓ ok ⇔ Γ ⊢ ProcedureDecl : ok ∧ ProcBindCheck(m, item) ⇓ ok ∧ ProvBindCheck(params, body) ⇓ ok
DeclTypingItem(m, R) ⇓ ok ⇔ R = RecordDecl(_, _, _, _, _, _) ∧ Γ ⊢ R record : ok ∧ ∀ md ∈ Methods(R). MethodBindCheck(m, TypePath(RecordPath(R)), md) ⇓ ok ∧ ProvBindCheck(MethodParamsDecl(TypePath(RecordPath(R)), md), md.body) ⇓ ok
DeclTypingItem(m, E) ⇓ ok ⇔ E = EnumDecl(_, _, _, _, _, _) ∧ Γ ⊢ E enum : ok
DeclTypingItem(m, M) ⇓ ok ⇔ M = ModalDecl(_, _, _, _, _, _) ∧ Γ ⊢ M modal : ok ∧ ∀ S ∈ States(M), ∀ md ∈ Methods(S). StateMethodBindCheck(m, M, S, md) ⇓ ok ∧ ProvBindCheck(StateMethodParams(M, S, md), md.body) ⇓ ok ∧ ∀ tr ∈ Transitions(S). TransitionBindCheck(m, M, S, tr) ⇓ ok ∧ ProvBindCheck(TransitionParams(M, S, tr), tr.body) ⇓ ok
DeclTypingItem(m, Cl) ⇓ ok ⇔ Cl = ClassDecl(_, _, _, _, _) ∧ Γ ⊢ Cl : ok ∧ ∀ md ∈ ClassMethods(Cl). (md.body_opt = ⊥ ∨ (ClassMethodBindCheck(m, Cl, md) ⇓ ok ∧ ProvBindCheck(ClassMethodParams(Cl, md), md.body_opt) ⇓ ok))

ParamBinds(params) = [⟨x, T⟩ | ⟨_, x, T⟩ ∈ params]
ProcReturn(ret_opt) =
  { TypePrim("()")   if ret_opt = ⊥
    ret_opt          otherwise }
ReturnAnnOk(ret_opt) ⇔ ret_opt ≠ ⊥

ExplicitReturn(BlockExpr(stmts, tail_opt)) ⇔ tail_opt = ⊥ ∧ stmts ≠ [] ∧ LastStmt(stmts) = ReturnStmt(_)

VisRank(`public`) = 3    VisRank(`internal`) = 2    VisRank(`private`) = 1    VisRank(`protected`) = 1
FieldVisOk(R) ⇔ ∀ f ∈ Fields(R). VisRank(f.vis) ≤ VisRank(R.vis)
StateMemberVisOk(M) ⇔ ∀ S ∈ States(M), ∀ m ∈ Payload(M, S) ∪ Methods(S) ∪ Transitions(S). VisRank(m.vis) ≤ VisRank(M.vis)

**(WF-ProcedureDecl)**
Distinct(ParamNames(params))    ReturnAnnOk(ret_opt)    R = ProcReturn(ret_opt)    ∀ ⟨_, x_i, T_i⟩ ∈ params, Γ ⊢ T_i wf    Γ_0 = PushScope(Γ)    IntroAll(Γ_0, ParamBinds(params)) ⇓ Γ_1    Γ_1; R; ⊥ ⊢ body : T_b    Γ ⊢ T_b <: R    (R ≠ TypePrim("()") ⇒ ExplicitReturn(body))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ProcedureDecl : ok

**(WF-ProcedureDecl-MissingReturnType)**
item = ProcedureDecl(_, _, _, ret_opt, _, _, _)    ¬ ReturnAnnOk(ret_opt)    c = Code(WF-ProcedureDecl-MissingReturnType)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ item ⇑ c

**(WF-ProcBody-ExplicitReturn-Err)**
item = ProcedureDecl(_, _, _, ret_opt, body, _, _)    R = ProcReturn(ret_opt)    R ≠ TypePrim("()")    ¬ ExplicitReturn(body)    c = Code(WF-ProcBody-ExplicitReturn-Err)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ item ⇑ c

StaticVisOk(vis, mut) ⇔ ¬ (vis = `public` ∧ mut = `var`)

**(WF-StaticDecl)**
binding = ⟨pat, ty_opt, op, init, _⟩    StaticVisOk(vis, mut)    ty_opt = T_a    Γ; ⊥; ⊥ ⊢ init ⇐ T_a ⊣ ∅    Γ ⊢ pat ⇐ T_a ⊣ B    Distinct(PatNames(pat))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ StaticDecl : ok

**(WF-StaticDecl-Ann-Mismatch)**
item = StaticDecl(vis, mut, ⟨pat, ty_opt, op, init, _⟩, _, _)    ty_opt = T_a    Γ; ⊥; ⊥ ⊢ init ⇒ T_i ⊣ C    Solve(C) ⇓ θ    ¬(Γ ⊢ θ(T_i) <: T_a)    c = Code(WF-StaticDecl-Ann-Mismatch)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ item ⇑ c

**(WF-StaticDecl-MissingType)**
item = StaticDecl(_, _, ⟨pat, ty_opt, op, init, _⟩, _, _)    ty_opt = ⊥    c = Code(WF-StaticDecl-MissingType)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ item ⇑ c

**(StaticVisOk-Err)**
item = StaticDecl(vis, mut, _, _, _)    ¬ StaticVisOk(vis, mut)    c = Code(StaticVisOk-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ item ⇑ c

**(WF-RecordDecl)**
∀ f ∈ Fields(R), Γ ⊢ f.type wf    FieldVisOk(R)    Γ ⊢ R record wf    Γ ⊢ Methods(R) : ok    Γ ⊢ TypePath(RecordPath(R)) : ImplementsOk
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ R record : ok

**(FieldVisOk-Err)**
R = RecordDecl(_, _, _, _, _, _)    ¬ FieldVisOk(R)    c = Code(FieldVisOk-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ R ⇑ c

EnumPathOf(E) = FullPath(ModuleOf(E), E.name)

**Enum Variant Visibility.**

VariantVis(E, v) = Vis(E)
VariantVisible(m, E, v) ⇔ Γ ⊢ CanAccess(m, E) ⇓ ok

**(WF-EnumDecl)**
variants ≠ []    Distinct([v.name | v ∈ variants])    ∀ v ∈ variants, Γ ⊢ v.payload_opt wf    EnumDiscriminants(E) ⇓ _    Γ ⊢ TypePath(EnumPathOf(E)) : ImplementsOk
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ E enum : ok

PayloadOptWF(⊥)
PayloadOptWF(TuplePayload([T_1, …, T_n])) ⇔ ∀ i. Γ ⊢ T_i wf
PayloadOptWF(RecordPayload([⟨f_1, T_1⟩, …, ⟨f_k, T_k⟩])) ⇔ Distinct([f_1, …, f_k]) ∧ ∀ i. Γ ⊢ T_i wf

Γ ⊢ payload_opt wf ⇔ PayloadOptWF(payload_opt)

ModalPath(M) = FullPath(ModuleOf(M), M.name)

**(WF-ModalDecl)**
p = ModalPath(M)    Γ ⊢ `modal` M wf    StateMemberVisOk(M)    Γ ⊢ TypePath(p) : ImplementsOk    ∀ S ∈ States(M), ∀ md ∈ Methods(S), Γ ⊢ md : StateMethodOK(M, S)    Γ ⊢ md : StateMethodBodyOK(p, S)    ∀ tr ∈ Transitions(S), Γ ⊢ tr : TransitionOK(M, S)    Γ ⊢ tr : TransitionBodyOK(p, S)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ M modal : ok

**(StateMemberVisOk-Err)**
M = ModalDecl(_, _, _, _, _, _)    ¬ StateMemberVisOk(M)    c = Code(StateMemberVisOk-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ M ⇑ c

**(WF-ClassDecl)**
Γ ⊢ Cl : ClassOk
──────────────────────────────────────────────
Γ ⊢ Cl : ok

**Program Entry Point (Cursive0).**

MainDecls(P) = [ d | m ∈ P.modules, d ∈ ASTModule(P, m).items, d = ProcedureDecl(vis, name, params, ret_opt, body, span, doc), name = `main` ]

TypeParams(ProcedureDecl(_)) = []
MainGeneric(d) ⇔ TypeParams(d) ≠ []

MainSigOk(d) ⇔ d = ProcedureDecl(vis, `main`, params, ret_opt, _, _, _) ∧ vis = `public` ∧ params = [⟨mode, name, ty⟩] ∧ mode ∈ {⊥, `move`} ∧ ty = TypePath([`Context`]) ∧ BuiltInContext(TypePath([`Context`])) ∧ ret_opt = TypePrim("i32")
MainConsumesContext(d) ⇔ MainSigOk(d) ∧ ∃ mode. d.params = [⟨mode, _, _⟩] ∧ mode = `move`
MainRetainsContext(d) ⇔ MainSigOk(d) ∧ ∃ mode. d.params = [⟨mode, _, _⟩] ∧ mode = ⊥

MainCheck : Project ⇀ ok

**(Main-Ok)**
Executable(P)    MainDecls(P) = [d]    ¬ MainGeneric(d)    MainSigOk(d)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇓ ok

**(Main-Bypass-Lib)**
¬ Executable(P)
──────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇓ ok

**(Main-Multiple)**
Executable(P)    |MainDecls(P)| > 1    c = Code(Main-Multiple)
────────────────────────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇑ c

**(Main-Generic-Err)**
Executable(P)    MainDecls(P) = [d]    MainGeneric(d)    c = Code(Main-Generic-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇑ c

**(Main-Signature-Err)**
Executable(P)    MainDecls(P) = [d]    ¬ MainSigOk(d)    c = Code(Main-Signature-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇑ c

**(Main-Missing)**
Executable(P)    MainDecls(P) = []    c = Code(Main-Missing)
────────────────────────────────────────────────────────────────
Γ ⊢ MainCheck(P) ⇑ c

MainDiagRefs = {"8.2"}

Phase3Checks(P, Ms) = [Γ ⊢ ResolveModules(P) ⇓ Ms, Γ ⊢ DeclTyping(Ms) ⇓ ok, Γ ⊢ MainCheck(P) ⇓ ok]
Phase3Order(P) ⇔ ∃ Ms. FirstFail(Phase3Checks(P, Ms)) = ⊥

#### 5.2.15. Binding and Permission State (Cursive0)

**Binding State.**

BindingState ::= Valid | Moved | PartiallyMoved(F)    (F ⊆ Name)

**Binding Metadata.**

Movability ::= mov | immov
Responsibility ::= resp | alias
Mutability = {`let`, `var`}
BindInfo ::= ⟨state, mov, mut, resp⟩    (mut ∈ Mutability)

**Binding Environment.**

BindScope = Map(Identifier, BindInfo)
𝔅 = [BindScope]

PushScope_B(𝔅) = [∅] ++ 𝔅
PopScope_B([_] ++ 𝔅) = 𝔅

Lookup_B([σ] ++ 𝔅', x) =
  { σ[x]                if x ∈ dom(σ)
    Lookup_B(𝔅', x)     otherwise }
Lookup_B([], x) = ⊥

Update_B([σ] ++ 𝔅', x, info) =
  { [σ[x ↦ info]] ++ 𝔅'            if x ∈ dom(σ)
    [σ] ++ Update_B(𝔅', x, info)   otherwise }
Update_B([], x, info) = ⊥

Intro_B([σ] ++ 𝔅', x, info) = [σ[x ↦ info]] ++ 𝔅'
ShadowIntro_B(𝔅, x, info) = Update_B(𝔅, x, info)

**Permission of a Type.**

PermOf(TypePerm(p, T)) = p
PermOf(T) = `const`    if T ≠ TypePerm(_, _)

**Permission State.**

ActiveState ::= Active | Inactive

PermKey = Identifier × FieldPath
PermScope = Map(PermKey, ActiveState)
Π = [PermScope]

PushScope_Π(Π) = [∅] ++ Π
PopScope_Π([_] ++ Π) = Π

Lookup_Π([σ] ++ Π', k) =
  { Inactive             if k ∈ dom(σ) ∧ σ[k] = Inactive
    Lookup_Π(Π', k)      otherwise }
Lookup_Π([], k) = Active

Update_Π([σ] ++ Π', k, s) = [σ[k ↦ s]] ++ Π'

**Join at Control-Flow Merge.**

JoinState(Moved, s) = Moved
JoinState(s, Moved) = Moved
JoinState(PartiallyMoved(F_1), PartiallyMoved(F_2)) = PartiallyMoved(F_1 ∪ F_2)
JoinState(Valid, PartiallyMoved(F)) = PartiallyMoved(F)
JoinState(PartiallyMoved(F), Valid) = PartiallyMoved(F)
JoinState(Valid, Valid) = Valid

JoinBindInfo(⟨s_1, mv_1, mut_1, resp_1⟩, ⟨s_2, mv_2, mut_2, resp_2⟩) =
  { ⟨JoinState(s_1, s_2), mv_1, mut_1, resp_1⟩   if mv_1 = mv_2 ∧ mut_1 = mut_2 ∧ resp_1 = resp_2
    ⊥                                            otherwise }

JoinScope_B(B_1, B_2) =
  { { x ↦ JoinBindInfo(B_1[x], B_2[x]) | x ∈ dom(B_1) }    if dom(B_1) = dom(B_2) ∧ ∀ x ∈ dom(B_1). JoinBindInfo(B_1[x], B_2[x]) ≠ ⊥
    ⊥                                                      otherwise }

Join_B([], []) = []
Join_B(B_1 :: 𝔅_1, B_2 :: 𝔅_2) =
  { JoinScope_B(B_1, B_2) :: Join_B(𝔅_1, 𝔅_2)    if JoinScope_B(B_1, B_2) ≠ ⊥ ∧ Join_B(𝔅_1, 𝔅_2) ≠ ⊥
    ⊥                                           otherwise }
Join_B(𝔅_1, 𝔅_2) = ⊥    if |𝔅_1| ≠ |𝔅_2|

JoinPermState(Active, Active) = Active
JoinPermState(_, _) = Inactive    otherwise

PermAt(B, x) =
  { B[x]     if x ∈ dom(B)
    Active   otherwise }

JoinScope_Π(B_1, B_2) = { x ↦ JoinPermState(PermAt(B_1, x), PermAt(B_2, x)) | x ∈ dom(B_1) ∪ dom(B_2) }

JoinPerm([], []) = []
JoinPerm(B_1 :: Π_1, B_2 :: Π_2) =
  { JoinScope_Π(B_1, B_2) :: JoinPerm(Π_1, Π_2)    if JoinScope_Π(B_1, B_2) ≠ ⊥ ∧ JoinPerm(Π_1, Π_2) ≠ ⊥
    ⊥                                             otherwise }
JoinPerm(Π_1, Π_2) = ⊥    if |Π_1| ≠ |Π_2|

**Place Roots and Field Heads.**

FieldHead(Identifier(x)) = ⊥
FieldHead(FieldAccess(p, f)) =
  { f                if FieldHead(p) = ⊥
    FieldHead(p)     otherwise }
FieldHead(TupleAccess(p, _)) = FieldHead(p)
FieldHead(IndexAccess(p, _)) = FieldHead(p)
FieldHead(Deref(p)) = ⊥

**Access Legality.**

AccessStateOk(Valid, p) = true
AccessStateOk(PartiallyMoved(F), p) = (FieldHead(p) = f ∧ f ∉ F)
AccessStateOk(Moved, p) = false

AccessOk_B(𝔅, p) ⇔ x = PlaceRoot(p) ∧ Lookup_B(𝔅, x) = ⟨s, _, _, _⟩ ∧ AccessStateOk(s, p)

AccessOk_Π(Π, p) ⇔ (PermOf(ExprType(p)) ≠ `unique`) ∨ AccessPathOk(Π, p)

AccessOk(𝔅, Π, p) ⇔ AccessOk_B(𝔅, p) ∧ AccessOk_Π(Π, p)

**Binding Introduction.**

MovOf("=") = mov
MovOf(":=") = immov

IsMoveExpr(MoveExpr(_)) = true
IsMoveExpr(_) = false    otherwise

RespOfInit(init) =
  { resp    if ¬ IsPlace(init)
    resp    if IsMoveExpr(init)
    alias   otherwise }

**Temporary Lifetime.**

InitExpr(⟨_, _, _, init, _⟩) = init

BindInitScope(e) = BindScope(s) ⇔
  (s = LetStmt(binding) ∧ InitExpr(binding) = e) ∨
  (s = VarStmt(binding) ∧ InitExpr(binding) = e) ∨
  (s = ShadowLetStmt(_, _, e)) ∨
  (s = ShadowVarStmt(_, _, e))

TempScope(e) =
  { BindInitScope(e)                  if BindInitScope(e) ≠ ⊥
    StmtScope(EnclosingStmt(e))       otherwise }

TempValue(e) ⇔ ¬ IsPlace(e)

TempOrderList([]) = []
TempOrderList([e] ++ es) = TempOrder(e) ++ TempOrderList(es)

TempOrder(e) =
  { TempOrderList(Children_LTR(e)) ++ [e]    if TempValue(e)
    TempOrderList(Children_LTR(e))          otherwise }

TempOrderStmt(s) = TempOrderList(StmtExprs(s))

ControlExpr(ReturnStmt(e)) = e    ControlExpr(ResultStmt(e)) = e    ControlExpr(BreakStmt(e)) = e
ControlExpr(s) = ⊥    if s ∉ {ReturnStmt(_), ResultStmt(_), BreakStmt(_)}

TempStmtList(s) = [ e ∈ TempOrderStmt(s) | TempScope(e) = StmtScope(s) ∧ e ≠ ControlExpr(s) ]
TempDropOrder(s) = Rev(TempStmtList(s))

**Judgments.**

BJudgment = {Γ; 𝔅; Π ⊢ e ⇒ 𝔅' ▷ Π', Γ; 𝔅; Π ⊢ s ⇒ 𝔅' ▷ Π'}

ExprType(e) = T ⇔ Γ; R; L ⊢ e : T
ExprType(p) = T ⇔ IsPlace(p) ∧ Γ; R; L ⊢ p :place T

BindType(⟨pat, ty_opt, op, init, _⟩) = T ⇔ ty_opt = T
BindType(⟨pat, ⊥, op, init, _⟩) = θ(T_i) ⇔ Γ; R; L ⊢ init ⇒ T_i ⊣ C ∧ Solve(C) ⇓ θ
BindType(ShadowLetStmt(_, ty_opt, init)) = T ⇔ ty_opt = T
BindType(ShadowLetStmt(_, ⊥, init)) = θ(T_i) ⇔ Γ; R; L ⊢ init ⇒ T_i ⊣ C ∧ Solve(C) ⇓ θ
BindType(ShadowVarStmt(_, ty_opt, init)) = T ⇔ ty_opt = T
BindType(ShadowVarStmt(_, ⊥, init)) = θ(T_i) ⇔ Γ; R; L ⊢ init ⇒ T_i ⊣ C ∧ Solve(C) ⇓ θ

MapUnion(M_1, M_2) = { x ↦ (M_2[x] if x ∈ dom(M_2) else M_1[x]) | x ∈ dom(M_1) ∪ dom(M_2) }

IntroAll_B([σ] ++ 𝔅', B) = [MapUnion(σ, B)] ++ 𝔅'

ShadowAll_B(𝔅, B) = ShadowAll_B(𝔅, Entries(B))
ShadowAll_B(𝔅, []) = 𝔅
ShadowAll_B(𝔅, [⟨x, info⟩] ++ xs) = ShadowAll_B(ShadowIntro_B(𝔅, x, info), xs)

BindInfoMap(f, B, mv, mut) = { x ↦ ⟨Valid, MovEff(mv, f(B[x])), mut, f(B[x])⟩ | x ∈ dom(B) }

MovEff(mv, resp) = mv    MovEff(mv, alias) = immov

T_Region = TypeModalState([`Region`], `Active`)
RegionBindName(Γ, alias_opt) =
  { alias_opt         if alias_opt ≠ ⊥
    FreshRegion(Γ)    otherwise }
RegionBindMap(Γ, alias_opt) = { r ↦ T_Region | r = RegionBindName(Γ, alias_opt) }
RegionBindInfo(Γ, alias_opt) = BindInfoMap(λ U. resp, RegionBindMap(Γ, alias_opt), mov, `let`)
FrameBindInfo(Γ) = RegionBindInfo(Γ, ⊥)

Names(B) = dom(B)

JoinAll_B([]) = ⊥
JoinAll_B([𝔅]) = 𝔅
JoinAll_B(𝔅_1 :: 𝔅_2 :: rest) = JoinAll_B([Join_B(𝔅_1, 𝔅_2)] ++ rest)

JoinAllPerm([]) = ⊥
JoinAllPerm([Π]) = Π
JoinAllPerm(Π_1 :: Π_2 :: rest) = JoinAllPerm([JoinPerm(Π_1, Π_2)] ++ rest)

Top([σ] ++ Π') = σ

SetTop([σ] ++ Π', σ') = [σ'] ++ Π'

InactivateScope(σ, K) = { x ↦ (Inactive if x ∈ K else σ[x]) | x ∈ dom(σ) ∪ K }

Roots(Π_2, Π_1) = { k | Top(Π_2)[k] = Inactive ∧ Lookup_Π(Π_1, k) = Active }

ConsumeOnMove(𝔅, e) =
  { Update_B(𝔅, x, ⟨Moved, mv, mut, resp⟩)    if IsMoveExpr(e) ∧ x = PlaceRoot(MoveInner(e)) ∧ Lookup_B(𝔅, x) = ⟨s, mv, mut, resp⟩
    𝔅                                         otherwise }

MoveInner(MoveExpr(p)) = p

OptList(⊥) = []
OptList(e) = [e]    if e ≠ ⊥

$$\text{StmtExprs}(\text{LetStmt}(\langle \_,\_,\_, init,\_ \rangle)) = [init]$$
$$\text{StmtExprs}(\text{VarStmt}(\langle \_,\_,\_, init,\_ \rangle)) = [init]$$
$$\text{StmtExprs}(\text{ShadowLetStmt}(\_,\_,init)) = [init]$$
StmtExprs(ShadowVarStmt(_, _, init)) = [init]
StmtExprs(AssignStmt(p, e)) = [e, p]
StmtExprs(CompoundAssignStmt(p, _, e)) = [p, e]
StmtExprs(ExprStmt(e)) = [e]
StmtExprs(ReturnStmt(e_opt)) = OptList(e_opt)
StmtExprs(ResultStmt(e)) = [e]
StmtExprs(BreakStmt(e_opt)) = OptList(e_opt)
StmtExprs(ContinueStmt) = []
StmtExprs(DeferStmt(_)) = []
StmtExprs(UnsafeBlockStmt(b)) = [b]
StmtExprs(RegionStmt(opts_opt, _, b)) = [RegionOptsExpr(opts_opt), b]
StmtExprs(FrameStmt(_, b)) = [b]
StmtExprs(ErrorStmt(_)) = []

StmtScope(s) = s
BindScope(s) = BlockOfStmt(s)
EnclosingStmt(e) = s ⇔ e ∈ SubExprs(s) ∧ ∀ s' ∈ SubStmts(s). e ∉ SubExprs(s')
BlockOfStmt(s) = b ⇔ s ∈ BlockStmts(b) ∧ ∀ b' ∈ SubBlocks(b). s ∉ BlockStmts(b')

BlockStmts(BlockExpr(stmts, _)) = stmts

StmtBlocks(UnsafeBlockStmt(b)) = [b]
StmtBlocks(DeferStmt(b)) = [b]
StmtBlocks(RegionStmt(_, _, b)) = [b]
StmtBlocks(FrameStmt(_, b)) = [b]
StmtBlocks(s) = []    if s ∉ {UnsafeBlockStmt(_), DeferStmt(_), RegionStmt(_, _, _), FrameStmt(_, _)}

SubExprs(s) = SubExprsList(StmtExprs(s))
SubExprsList([]) = ∅
SubExprsList([e] ++ es) = {e} ∪ SubExprsList(Children_LTR(e)) ∪ SubExprsList(es)

SubStmts(s) = SubStmtsList(StmtBlocks(s))
SubStmtsList([]) = ∅
SubStmtsList([b] ++ bs) = BlockStmts(b) ∪ SubStmtsSeq(BlockStmts(b)) ∪ SubStmtsList(bs)
SubStmtsSeq([]) = ∅
SubStmtsSeq([s] ++ ss) = SubStmts(s) ∪ SubStmtsSeq(ss)

SubBlocks(b) = SubBlocksSeq(BlockStmts(b))
SubBlocksSeq([]) = ∅
SubBlocksSeq([s] ++ ss) = StmtBlocks(s) ∪ (⋃_{b' ∈ StmtBlocks(s)} SubBlocks(b')) ∪ SubBlocksSeq(ss)

Entries(B) = [⟨x_1, B[x_1]⟩, …, ⟨x_n, B[x_n]⟩] ⇔ [x_1, …, x_n] enumerates dom(B) without repetition

SynthParams([⟨m_1, T_1⟩, …, ⟨m_n, T_n⟩]) = [⟨m_1, ⊥, T_1⟩, …, ⟨m_n, ⊥, T_n⟩]

CalleeProc(Identifier(x)) = proc ⇔ Γ ⊢ ResolveValueName(x) ⇓ ent ∧ ent.origin_opt = mp ∧ name = (ent.target_opt if present, else x) ∧ DeclOf(mp, name) = proc ∧ proc = ProcedureDecl(_)
CalleeProc(Path(path, name)) = proc ⇔ Γ ⊢ ResolveQualified(path, name, ValueKind) ⇓ ent ∧ ent.origin_opt = mp ∧ name' = (ent.target_opt if present, else name) ∧ DeclOf(mp, name') = proc ∧ proc = ProcedureDecl(_)

Params(Call(callee, args)) =
  { proc.params            if CalleeProc(callee) = proc
    SynthParams(params)    if ExprType(callee) = TypeFunc(params, _)
    ⊥                      otherwise }

MethodOf(base, name) = m ⇔ LookupMethod(StripPerm(ExprType(base)), name) = m
RecvBase(base, name) = T ⇔ MethodOf(base, name) = m ∧ T = StripPerm(ExprType(base))

RecvParams(base, name) = [⟨RecvMode(m.receiver), `self`, RecvType(T, m.receiver)⟩] ++ m.params ⇔ MethodOf(base, name) = m ∧ RecvBase(base, name) = T

**Static Binding Maps (Module Scope).**

StaticBindTypesMod(P, m) = ++_{item ∈ ASTModule(P, m).items, item = StaticDecl(_, _, binding, _, _)} StaticBindTypes(binding)

StaticBindInfo(item) = BindInfoMap(λ U. RespOfInit(init), StaticBindTypes(binding), MovOf(op), mut) ⇔ item = StaticDecl(_, mut, binding, _, _) ∧ binding = ⟨_, _, op, init, _⟩

StaticBindMap(P, m) = ++_{item ∈ ASTModule(P, m).items, item = StaticDecl(_, _, _, _, _)} StaticBindInfo(item)

**Procedure Entry.**

𝔅_global = IntroAll_B(PushScope_B(𝔅), StaticBindMap(Project(Γ), m))
𝔅_proc = IntroAll_B(PushScope_B(𝔅_global), ParamBindMap(params))

ParamBindMap([]) = ∅
ParamBindMap([⟨mode, x, T⟩] ++ ps) = MapUnion(ParamBindMap(ps), { x ↦ ⟨Valid, ParamMov(mode), `let`, ParamResp(mode)⟩ })
MethodParamBindMap(base, name) = ParamBindMap(RecvParams(base, name))

ParamTypeMap([]) = ∅
ParamTypeMap([⟨mode, x, T⟩] ++ ps) = MapUnion(ParamTypeMap(ps), { x ↦ T })

ParamMov(`move`) = mov    ParamMov(⊥) = immov
ParamResp(`move`) = resp    ParamResp(⊥) = alias

B_params = ParamTypeMap(params)
B_static = StaticBindTypesMod(Project(Γ), m)
Π_global = [{ x ↦ Active | (x:T) ∈ B_static ∧ PermOf(T) = `unique` }]
Π_proc = [{ x ↦ Active | (x:T) ∈ B_params ∧ PermOf(T) = `unique` }] ++ Π_global

**Expression Rules (Selected).**

**(B-Place)**
IsPlace(p)    AccessOk(𝔅, Π, p)
──────────────────────────────────────────────
Γ; 𝔅; Π ⊢ p ⇒ 𝔅 ▷ Π

**(B-Place-Unique-Err)**
IsPlace(p)    Γ; R; L ⊢ p : T_p    PermOf(T_p) = `unique`    ¬ AccessPathOk(Π, p)    c = Code(B-Place-Unique-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ p ⇑ c

**(B-Place-Moved-Err)**
IsPlace(p)    Γ; R; L ⊢ p : T_p    x = PlaceRoot(p)    Lookup_B(𝔅, x) = ⟨s, _, _, _⟩    (s = Moved ∨ (s = PartiallyMoved(F) ∧ (FieldHead(p) = ⊥ ∨ FieldHead(p) ∈ F)))    (PermOf(T_p) ≠ `unique` ∨ AccessPathOk(Π, p))    c = Code(B-Place-Moved-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ p ⇑ c

**(B-Move-Whole)**
IsPlace(p)    x = PlaceRoot(p)    FieldHead(p) = ⊥    Lookup_B(𝔅, x) = ⟨Valid, mv, m, r⟩    mv = mov
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇒ Update_B(𝔅, x, ⟨Moved, mov, m, r⟩) ▷ Π

**(B-Move-Field)**
IsPlace(p)    x = PlaceRoot(p)    FieldHead(p) = f    Γ; R; L ⊢ p : T_p    PermOf(T_p) = `unique`    Lookup_B(𝔅, x) = ⟨s, mv, m, r⟩    mv = mov
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇒ Update_B(𝔅, x, ⟨PM(s, f), mov, m, r⟩) ▷ Π

PM(Valid, f) = PartiallyMoved({f})
PM(PartiallyMoved(F), f) = PartiallyMoved(F ∪ {f})
PM(Moved, f) = ⊥

**(B-Move-Whole-Moved-Err)**
IsPlace(p)    FieldHead(p) = ⊥    x = PlaceRoot(p)    Lookup_B(𝔅, x) = ⟨s, mv, _, _⟩    s ≠ Valid    mv = mov    c = Code(B-Move-Whole-Moved-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

**(B-Move-Field-Moved-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Γ; R; L ⊢ p : T_p    PermOf(T_p) = `unique`    Lookup_B(𝔅, x) = ⟨s, mv, _, _⟩    (s = Moved ∨ (s = PartiallyMoved(F) ∧ f ∈ F))    mv = mov    c = Code(B-Move-Field-Moved-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

**(B-Move-Field-NonUnique-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Γ; R; L ⊢ p : T_p    PermOf(T_p) ≠ `unique`    Lookup_B(𝔅, x) = ⟨_, mv, _, _⟩    mv = mov    c = Code(B-Move-Field-NonUnique-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

**(B-Move-Whole-Immovable-Err)**
IsPlace(p)    FieldHead(p) = ⊥    x = PlaceRoot(p)    Lookup_B(𝔅, x) = ⟨_, mv, _, _⟩    mv = immov    c = Code(B-Move-Whole-Immovable-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

**(B-Move-Field-Immovable-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Lookup_B(𝔅, x) = ⟨_, mv, _, _⟩    mv = immov    c = Code(B-Move-Field-Immovable-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

BExprRules = {B-Place, B-Move-Whole, B-Move-Field, B-Call, B-MethodCall, B-Transition, B-Expr-Sub}

NoSpecificBExpr(e) ⇔ ¬ ∃ r ∈ BExprRules \ {B-Expr-Sub}. PremisesHold(r, e)

**(B-Expr-Sub)**
NoSpecificBExpr(e)    Children_LTR(e) = [e_1, …, e_n]    Γ; 𝔅_0; Π_0 ⊢ e_1 ⇒ 𝔅_1 ▷ Π_1  …  Γ; 𝔅_{n-1}; Π_{n-1} ⊢ e_n ⇒ 𝔅_n ▷ Π_n
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅_0; Π_0 ⊢ e ⇒ 𝔅_n ▷ Π_n

**Call and Method Argument Passing.**

**Field-Path Permission Tracking.**

FieldPath = [Name]

FieldPathOf(Identifier(x)) = []
FieldPathOf(FieldAccess(p, f)) = FieldPathOf(p) ++ [f]
FieldPathOf(TupleAccess(p, _)) = FieldPathOf(p)
FieldPathOf(IndexAccess(p, _)) = FieldPathOf(p)
FieldPathOf(Deref(p)) = []

PlacePath(p) =
  { (PlaceRoot(p), [])            if p = Identifier(x)
    (PlaceRoot(p), FieldPathOf(p))    otherwise }

Prefixes([]) = [[]]
Prefixes([f] ++ fs) = [[]] ∪ { [f] ++ p | p ∈ Prefixes(fs) }
AncPaths(p) = { (PlaceRoot(p), fp) | fp ∈ Prefixes(FieldPathOf(p)) }

AccessPathOk(Π, p) ⇔ ∀ k ∈ AncPaths(p). Lookup_Π(Π, k) = Active

DowngradeUniquePath(Π, mode, p) =
  { SetTop(Π, InactivateScope(Top(Π), AncPaths(p)))    if mode = ⊥ ∧ IsPlace(p) ∧ PermOf(ExprType(p)) = `unique`
    Π                                                 otherwise }

DowngradeUnique(Π, mode, e) =
  { DowngradeUniquePath(Π, mode, e)    if IsPlace(e)
    Π                                 otherwise }

DowngradeUniqueBind(Π, init, T_b) =
  { DowngradeUniquePath(Π, ⊥, init)    if IsPlace(init) ∧ PermOf(ExprType(init)) = `unique` ∧ PermOf(T_b) = `const`
    Π                                  otherwise }

RemoveKeys(σ, D) = { k ↦ σ[k] | k ∈ dom(σ) ∧ k ∉ D }
Reactivate([σ] ++ Π', D) = [RemoveKeys(σ, D)] ++ Π'

ArgPassExpr(mode, moved, e) =
  { MovedArg(moved, e)    if mode = `move` ∧ moved = true
    e                     otherwise }

ArgPassJudg = {Γ; 𝔅; Π ⊢ ArgPass(params, args) ⇒ 𝔅' ▷ Π', D}

**(B-ArgPass-Empty)**
────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ArgPass([], []) ⇒ 𝔅 ▷ Π, ∅

**(B-ArgPass-Move-Missing)**
params = [⟨`move`, _, T_p⟩] ++ ps    args = [⟨moved, e, _⟩] ++ as    moved = false    c = Code(B-ArgPass-Move-Missing)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ArgPass(params, args) ⇑ c

**(B-ArgPass-Cons)**
Γ; 𝔅; Π ⊢ ArgPassExpr(mode, moved, e) ⇒ 𝔅_1 ▷ Π_1    (mode = ⊥ ⇒ IsPlace(e))    Π_2 = DowngradeUnique(Π_1, mode, e)    Γ; 𝔅_1; Π_2 ⊢ ArgPass(ps, as) ⇒ 𝔅_2 ▷ Π_3, D
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ArgPass([⟨mode, _, T_p⟩] ++ ps, [⟨moved, e, _⟩] ++ as) ⇒ 𝔅_2 ▷ Π_3, D ∪ Roots(Π_2, Π_1)

**(B-Call)**
Γ; 𝔅; Π ⊢ f ⇒ 𝔅_1 ▷ Π_1    Γ; 𝔅_1; Π_1 ⊢ ArgPass(Params(Call(f, args)), args) ⇒ 𝔅_2 ▷ Π_2, D    Π_3 = Reactivate(Π_2, D)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ Call(f, args) ⇒ 𝔅_2 ▷ Π_3

**(B-MethodCall)**
Γ; 𝔅; Π ⊢ base ⇒ 𝔅_1 ▷ Π_1    Γ; 𝔅_1; Π_1 ⊢ ArgPass(RecvParams(base, name), args) ⇒ 𝔅_2 ▷ Π_2, D    Π_3 = Reactivate(Π_2, D)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MethodCall(base, name, args) ⇒ 𝔅_2 ▷ Π_3

**(B-Transition)**
Γ; 𝔅; Π ⊢ e_self ⇒ 𝔅_0 ▷ Π_0    x = PlaceRoot(e_self)    Lookup_B(𝔅_0, x) = ⟨Valid, mov, m, r⟩    mov = mov    𝔅_1 = Update_B(𝔅_0, x, ⟨Moved, mov, m, r⟩)    Γ; 𝔅_1; Π_0 ⊢ ArgPass(tr.params, args) ⇒ 𝔅_2 ▷ Π_1, D
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ e_self ↠ t(args) ⇒ 𝔅_2 ▷ Reactivate(Π_1, D)

**Statement Rules (Selected).**

**(B-Seq-Empty)**
──────────────────────────────────────────────
Γ; 𝔅; Π ⊢ [] ⇒ 𝔅 ▷ Π

**(B-Seq-Cons)**
Γ; 𝔅; Π ⊢ s ⇒ 𝔅_1 ▷ Π_1    Γ; 𝔅_1; Π_1 ⊢ ss ⇒ 𝔅_2 ▷ Π_2
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ s :: ss ⇒ 𝔅_2 ▷ Π_2

**(B-LetVar-UniqueNonMove-Err)**
T_b = BindType(⟨pat, ty_opt, op, init, _⟩)    PermOf(T_b) = `unique`    IsPlace(init)    ¬ IsMoveExpr(init)    c = Code(B-LetVar-UniqueNonMove-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ LetOrVarStmt(⟨pat, ty_opt, op, init, _⟩) ⇑ c

**(B-LetVar)**
Γ; 𝔅; Π ⊢ init ⇒ 𝔅_1 ▷ Π_1    T_b = BindType(⟨pat, ty_opt, op, init, _⟩)    Π_2 = DowngradeUniqueBind(Π_1, init, T_b)    𝔅_2 = ConsumeOnMove(𝔅_1, init)    Γ ⊢ pat ⇐ T_b ⊣ B    𝔅_3 = IntroAll_B(𝔅_2, BindInfoMap(λ U. RespOfInit(init), B, MovOf(op), mut))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ LetOrVarStmt(⟨pat, ty_opt, op, init, _⟩) ⇒ 𝔅_3 ▷ Π_2

**(B-ShadowLet-UniqueNonMove-Err)**
T_b = BindType(ShadowLetStmt(x, ty_opt, init))    PermOf(T_b) = `unique`    IsPlace(init)    ¬ IsMoveExpr(init)    c = Code(B-ShadowLet-UniqueNonMove-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ShadowLetStmt(x, ty_opt, init) ⇑ c

**(B-ShadowLet)**
Γ; 𝔅; Π ⊢ init ⇒ 𝔅_1 ▷ Π_1    T_b = BindType(ShadowLetStmt(x, ty_opt, init))    Π_2 = DowngradeUniqueBind(Π_1, init, T_b)    𝔅_2 = ConsumeOnMove(𝔅_1, init)    B = { x ↦ T_b }    𝔅_3 = ShadowAll_B(𝔅_2, BindInfoMap(λ U. RespOfInit(init), B, MovOf("="), `let`))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ShadowLetStmt(x, ty_opt, init) ⇒ 𝔅_3 ▷ Π_2

**(B-ShadowVar-UniqueNonMove-Err)**
T_b = BindType(ShadowVarStmt(x, ty_opt, init))    PermOf(T_b) = `unique`    IsPlace(init)    ¬ IsMoveExpr(init)    c = Code(B-ShadowVar-UniqueNonMove-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ShadowVarStmt(x, ty_opt, init) ⇑ c

**(B-ShadowVar)**
Γ; 𝔅; Π ⊢ init ⇒ 𝔅_1 ▷ Π_1    T_b = BindType(ShadowVarStmt(x, ty_opt, init))    Π_2 = DowngradeUniqueBind(Π_1, init, T_b)    𝔅_2 = ConsumeOnMove(𝔅_1, init)    B = { x ↦ T_b }    𝔅_3 = ShadowAll_B(𝔅_2, BindInfoMap(λ U. RespOfInit(init), B, MovOf("="), `var`))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ShadowVarStmt(x, ty_opt, init) ⇒ 𝔅_3 ▷ Π_2

**(B-ExprStmt)**
Γ; 𝔅; Π ⊢ e ⇒ 𝔅_1 ▷ Π_1
────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ExprStmt(e) ⇒ 𝔅_1 ▷ Π_1

**(B-ResultStmt)**
Γ; 𝔅; Π ⊢ e ⇒ 𝔅_1 ▷ Π_1
────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ResultStmt(e) ⇒ 𝔅_1 ▷ Π_1

**(B-UnsafeStmt)**
Γ; 𝔅; Π ⊢ b ⇒ 𝔅_1 ▷ Π_1
──────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ UnsafeBlockStmt(b) ⇒ 𝔅_1 ▷ Π_1

**(B-Defer)**
Γ; 𝔅; Π ⊢ b ⇒ 𝔅_1 ▷ Π_1    𝔅_1 = 𝔅    Π_1 = Π
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ DeferStmt(b) ⇒ 𝔅 ▷ Π

**(B-RegionStmt)**
(opts_opt = ⊥ ⇒ 𝔅_0 = 𝔅 ∧ Π_0 = Π) ∧ (opts_opt = e ⇒ Γ; 𝔅; Π ⊢ e ⇒ 𝔅_0 ▷ Π_0)    𝔅_1 = PushScope_B(𝔅_0)    Π_1 = PushScope_Π(Π_0)    𝔅_2 = IntroAll_B(𝔅_1, RegionBindInfo(Γ, alias_opt))    Γ; 𝔅_2; Π_1 ⊢ b ⇒ 𝔅_3 ▷ Π_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ RegionStmt(opts_opt, alias_opt, b) ⇒ PopScope_B(𝔅_3) ▷ PopScope_Π(Π_2)

**(B-FrameStmt)**
𝔅_1 = PushScope_B(𝔅)    Π_1 = PushScope_Π(Π)    𝔅_2 = IntroAll_B(𝔅_1, FrameBindInfo(Γ))    Γ; 𝔅_2; Π_1 ⊢ b ⇒ 𝔅_3 ▷ Π_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ FrameStmt(r_opt, b) ⇒ PopScope_B(𝔅_3) ▷ PopScope_Π(Π_2)

**(B-Assign-Immutable-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    PlaceRoot(p) = x    Lookup_B(𝔅, x) = ⟨_, _, `let`, _⟩    c = Code(B-Assign-Immutable-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ stmt ⇑ c

**(B-Assign)**
IsPlace(p)    PlaceRoot(p) = x    Lookup_B(𝔅, x) = ⟨s, mov, `var`, r⟩    Γ; 𝔅; Π ⊢ e ⇒ 𝔅_1 ▷ Π_1
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ AssignStmt(p, e) ⇒ Update_B(𝔅_1, x, ⟨Valid, mov, `var`, r⟩) ▷ Π_1

**(B-Assign-Const-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    Γ; R; L ⊢ p : TypePerm(`const`, T)    c = Code(B-Assign-Const-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ stmt ⇑ c

**(B-If)**
Γ; 𝔅; Π ⊢ c ⇒ 𝔅_c ▷ Π_c    Γ; 𝔅_c; Π_c ⊢ b_t ⇒ 𝔅_t ▷ Π_t    Γ; 𝔅_c; Π_c ⊢ b_f ⇒ 𝔅_f ▷ Π_f
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ IfExpr(c, b_t, b_f) ⇒ Join_B(𝔅_t, 𝔅_f) ▷ JoinPerm(Π_t, Π_f)

**(B-Match)**
Γ; 𝔅; Π ⊢ e ⇒ 𝔅_0 ▷ Π_0    Γ; R; L ⊢ e : T    moved = IsMoveExpr(e)    𝔅_1 = ConsumeOnMove(𝔅_0, e)    ∀ i, Γ; PushScope_B(𝔅_1); PushScope_Π(Π_0) ⊢ Arm(moved, p_i, g_i, b_i) ⇒ 𝔅_i ▷ Π_i
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MatchExpr(e, arms) ⇒ JoinAll_B([𝔅_i]) ▷ JoinAllPerm([Π_i])

RespOfScrutinee(true) = resp
RespOfScrutinee(false) = alias

**(B-Arm)**
Γ ⊢ p ⇑ T ⊣ B    𝔅_0 = IntroAll_B(𝔅, BindInfoMap(λ U. RespOfScrutinee(moved), B, mov, `let`))    (g ≠ ⊥ ⇒ Γ; 𝔅_0; Π ⊢ g ⇒ 𝔅_1 ▷ Π_1)    (g = ⊥ ⇒ 𝔅_1 = 𝔅_0 ∧ Π_1 = Π)    Γ; 𝔅_1; Π_1 ⊢ b ⇒ 𝔅_2 ▷ Π_2
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ Arm(moved, p, g, b) ⇒ 𝔅_2 ▷ Π_2


**(B-Block)**
Γ; PushScope_B(𝔅); PushScope_Π(Π) ⊢ stmts ⇒ 𝔅_1 ▷ Π_1
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ BlockExpr(stmts, tail_opt) ⇒ PopScope_B(𝔅_1) ▷ PopScope_Π(Π_1)

**Loop Fixpoint.**

Moved <_B PartiallyMoved(F) <_B Valid
PartiallyMoved(F_1) <_B PartiallyMoved(F_2) ⇔ F_1 ⊇ F_2
x ≤_B y ⇔ x <_B y ∨ x = y
Active <_Π Inactive
x ≤_Π y ⇔ x <_Π y ∨ x = y
𝔅_1 ≤ 𝔅_2 ⇔ ∀ i. 𝔅_1[i] ≤_B 𝔅_2[i]
Π_1 ≤_Π Π_2 ⇔ ∀ i. Π_1[i] ≤_Π Π_2[i]

LoopStep : (𝔅, Π) → (𝔅, Π)
F(𝔅, Π) = (Join_B(𝔅_0, 𝔅'), JoinPerm(Π_0, Π')) where (𝔅', Π') = LoopStep(𝔅, Π)
(𝔅_0, Π_0) = (𝔅_init, Π_init)
(𝔅_{k+1}, Π_{k+1}) = F(𝔅_k, Π_k)
n = min{ k | (𝔅_k, Π_k) = (𝔅_{k+1}, Π_{k+1}) }
LoopFix(𝔅_init, Π_init, LoopStep) = (𝔅_n, Π_n)

**(B-Loop-Infinite)**
LoopStep(𝔅, Π) = (𝔅_b, Π_b) where Γ; 𝔅; Π ⊢ body ⇒ 𝔅_b ▷ Π_b    (𝔅', Π') = LoopFix(𝔅, Π, LoopStep)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ LoopInfinite(body) ⇒ 𝔅' ▷ Π'

**(B-Loop-Conditional)**
LoopStep(𝔅, Π) = (𝔅_b, Π_b) where Γ; 𝔅; Π ⊢ cond ⇒ 𝔅_c ▷ Π_c ∧ Γ; 𝔅_c; Π_c ⊢ body ⇒ 𝔅_b ▷ Π_b    (𝔅', Π') = LoopFix(𝔅, Π, LoopStep)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ LoopConditional(cond, body) ⇒ 𝔅' ▷ Π'

**(B-Loop-Iter)**
Γ; 𝔅; Π ⊢ iter ⇒ 𝔅_0 ▷ Π_0    Γ ⊢ pat ⇐ T_p ⊣ B    LoopStep(𝔅, Π) = (𝔅_b, Π_b) where 𝔅_1 = PushScope_B(𝔅) ∧ 𝔅_2 = IntroAll_B(𝔅_1, BindInfoMap(λ U. resp, B, mov, `let`)) ∧ Π_1 = PushScope_Π(Π) ∧ Γ; 𝔅_2; Π_1 ⊢ body ⇒ 𝔅_3 ▷ Π_2 ∧ 𝔅_b = PopScope_B(𝔅_3) ∧ Π_b = PopScope_Π(Π_2)    (𝔅', Π') = LoopFix(𝔅_0, Π_0, LoopStep)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ LoopIter(pat, ty_opt, iter, body) ⇒ 𝔅' ▷ Π'

**(B-Return)**
Γ; 𝔅; Π ⊢ e ⇒ 𝔅_1 ▷ Π_1
────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ReturnStmt(e) ⇒ 𝔅_1 ▷ Π_1

**(B-Return-Unit)**
──────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ReturnStmt(⊥) ⇒ 𝔅 ▷ Π

**(B-Break)**
Γ; 𝔅; Π ⊢ e ⇒ 𝔅_1 ▷ Π_1
────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ BreakStmt(e) ⇒ 𝔅_1 ▷ Π_1

**(B-Break-Unit)**
──────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ BreakStmt(⊥) ⇒ 𝔅 ▷ Π

**(B-Continue)**
──────────────────────────────────────────────
Γ; 𝔅; Π ⊢ ContinueStmt ⇒ 𝔅 ▷ Π

**(B-Move-Unique-Err)**
IsPlace(p)    Γ; R; L ⊢ p : T_p    PermOf(T_p) = `unique`    ¬ AccessPathOk(Π, p)    c = Code(B-Place-Unique-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; 𝔅; Π ⊢ MoveExpr(p) ⇑ c

**Procedure/Method Binding-Check.**

Init_B(m, params) = IntroAll_B(PushScope_B(IntroAll_B(PushScope_B([]), StaticBindMap(Project(Γ), m))), ParamBindMap(params))
Init_Π(m, params) = [{ x ↦ Active | (x:T) ∈ ParamTypeMap(params) ∧ PermOf(T) = `unique` }] ++ [{ x ↦ Active | (x:T) ∈ StaticBindTypesMod(Project(Γ), m) ∧ PermOf(T) = `unique` }]

BindCheck(m, params, body) ⇓ ok ⇔ Γ; Init_B(m, params); Init_Π(m, params) ⊢ body ⇒ 𝔅' ▷ Π'

ProcBindCheck(m, ProcedureDecl(_, _, params, _, body, _, _)) ⇓ ok ⇔ BindCheck(m, params, body) ⇓ ok

MethodParamsDecl(T, m) = [⟨RecvMode(m.receiver), `self`, RecvType(T, m.receiver)⟩] ++ m.params
MethodBindCheck(m, T, md) ⇓ ok ⇔ md.body = body ∧ BindCheck(m, MethodParamsDecl(T, md), body) ⇓ ok
ClassMethodBindCheck(m, Cl, md) ⇓ ok ⇔ md.body_opt = body ∧ BindCheck(m, ClassMethodParams(Cl, md), body) ⇓ ok
StateMethodBindCheck(m, M, S, md) ⇓ ok ⇔ md.body = body ∧ BindCheck(m, StateMethodParams(M, S, md), body) ⇓ ok
TransitionBindCheck(m, M, S, tr) ⇓ ok ⇔ tr.body = body ∧ BindCheck(m, TransitionParams(M, S, tr), body) ⇓ ok

BindDiagRefs = {"8.2", "8.7", "8.10"}

#### 5.2.16. Safe Pointer Types (Cursive0)

PtrState = {`Valid`, `Null`, `Expired`}

Ptr<T> = TypePtr(T, ⊥)
Ptr<T>@s = TypePtr(T, s)    (s ≠ ⊥)

**Static Semantics**

BitcopyType(TypePtr(T, s))
CloneType(TypePtr(T, s))
¬ DropType(TypePtr(T, s))

sizeof(`Ptr<T>`) = sizeof(`usize`)    alignof(`Ptr<T>`) = alignof(`usize`)
PtrDiagRefs = {"8.10"}

#### 5.2.17. Regions, Frames, and Provenance (Cursive0)

**Built-in Record Type `RegionOptions`.**

RegionOptionsFields = [
  ⟨`public`, `stack_size`, TypePrim("usize"), Literal(IntLiteral(0)), ⊥, ⊥⟩,
  ⟨`public`, `name`, TypeString(⊥), Literal(StringLiteral("\"")), ⊥, ⊥⟩
]

RegionOptionsDecl = RecordDecl(`public`, `RegionOptions`, [], RegionOptionsFields, ⊥, ⊥)

Σ.Types[`RegionOptions`] = RegionOptionsDecl

RegionPrealloc(opts) = opts.stack_size
NoPrealloc(opts) ⇔ RegionPrealloc(opts) = 0

**Region/Frame Helpers.**

RegionActiveType(T) ⇔ StripPerm(T) = TypeModalState([`Region`], `Active`)

FreshRegion(Γ) ∈ Name \ dom(Γ)

RegionOptsExpr(⊥) = Call(Identifier(`RegionOptions`), [])
RegionOptsExpr(e) = e    if e ≠ ⊥

RegionBind(Γ, alias_opt) = Γ_r ⇔ r =
  { alias_opt           if alias_opt ≠ ⊥
    FreshRegion(Γ)      otherwise } ∧ IntroAll(Γ, [⟨r, TypeModalState([`Region`], `Active`)⟩]) ⇓ Γ_r

InnermostActiveRegion([]) = ⊥
InnermostActiveRegion([σ] ++ Γ') =
  { r                         if ∃ r. r ∈ dom(σ) ∧ RegionActiveType(σ[r])
    InnermostActiveRegion(Γ')  otherwise }

FrameBind(Γ, target_opt) = Γ_f ⇔ r =
  { InnermostActiveRegion(Γ)    if target_opt = ⊥
    target_opt                  if target_opt ≠ ⊥ ∧ Γ; R; L ⊢ Identifier(target_opt) : T_r ∧ RegionActiveType(T_r) } ∧ F = FreshRegion(Γ) ∧ IntroAll(Γ, [⟨F, TypeModalState([`Region`], `Active`)⟩]) ⇓ Γ_f

**Provenance Tags.**

π ::= π_Global | π_Stack(S) | π_Heap | π_Region(r) | ⊥

**Lifetime Order.**

π_1 < π_2 ⇔ (π_1 = π_Region(r_inner) ∧ π_2 = π_Region(r_outer) ∧ RegionNesting(r_inner, r_outer)) ∨ (π_1 = π_Region(r) ∧ π_2 = π_Stack(S)) ∨ (π_1 = π_Stack(S) ∧ π_2 = π_Heap) ∨ (π_1 = π_Heap ∧ π_2 = π_Global) ∨ (π_1 = π_Global ∧ π_2 = ⊥)

π_1 ≤ π_2 ⇔ π_1 = π_2 ∨ (π_1 < π_2) ∨ ∃ π. (π_1 < π ∧ π ≤ π_2)

FrameTargetRel(F, r) ⇔ FrameTarget(Γ, F) = r
FrameTargetRel(F, r) ⇒ π_Region(F) < π_Region(r)

JoinProv(π_1, π_2) =
  { π_1    if π_1 ≤ π_2
    π_2    if π_2 ≤ π_1
    ⊥      otherwise }

JoinAllProv([]) = ⊥
JoinAllProv([π]) = π
JoinAllProv([π_1, π_2] ++ ps) = JoinAllProv([JoinProv(π_1, π_2)] ++ ps)

**Provenance Environment.**

Ω = ⟨Σ_π, RS⟩
Scope_π = ⟨S, M⟩ where M : Ident ⇀ π
Σ_π ∈ [Scope_π]
RegionEntry_π = ⟨tag, target⟩
RS ∈ [RegionEntry_π]

ScopeId(⟨S, M⟩) = S
ScopeMap(⟨S, M⟩) = M
TopScopeId([⟨S, M⟩] ++ Σ_π) = S
StackProv(Σ_π) = π_Stack(TopScopeId(Σ_π))

PushScope_π(Σ_π) = [⟨S, ∅⟩] ++ Σ_π    (S fresh)
PopScope_π([_] ++ Σ_π) = Σ_π

Lookup_π([⟨S, M⟩] ++ Σ_π, x) =
  { M[x]                if x ∈ dom(M)
    Lookup_π(Σ_π, x)     otherwise }

Intro_π([⟨S, M⟩] ++ Σ_π, x, π) = [⟨S, M[x ↦ π]⟩] ++ Σ_π

ShadowIntro_π(Σ_π, x, π) =
  { [⟨S, M[x ↦ π]⟩] ++ Σ_π'                    if Σ_π = [⟨S, M⟩] ++ Σ_π' ∧ x ∈ dom(M)
    [⟨S, M⟩] ++ ShadowIntro_π(Σ_π', x, π)     if Σ_π = [⟨S, M⟩] ++ Σ_π' ∧ x ∉ dom(M)
    ⊥                                         if Σ_π = [] }

IntroAll_π(Σ_π, [], π) = Σ_π
IntroAll_π(Σ_π, [x] ++ xs, π) = IntroAll_π(Intro_π(Σ_π, x, π), xs, π)

ShadowAll_π(Σ_π, [], π) = Σ_π
ShadowAll_π(Σ_π, [x] ++ xs, π) = ShadowAll_π(ShadowIntro_π(Σ_π, x, π), xs, π)

ParamProvMap(params, vecπ) = { x_i ↦ π_i | params = [⟨_, x_i, _⟩], vecπ = [π_i] }
InitProvEnv(params, vecπ, RS) = ⟨[⟨S, ParamProvMap(params, vecπ)⟩], RS⟩    (S fresh)

AllocTag([], r) = ⊥
AllocTag([⟨tag, target⟩] ++ RS, ⊥) = tag
AllocTag([⟨tag, target⟩] ++ RS, r) =
  { tag              if target = r
    AllocTag(RS, r)  otherwise }

**Provenance of Places.**

ProvPlaceJudg = {Γ; Ω ⊢ p ⇓ π}

Lookup_π(Σ_π, x) = π
────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ Identifier(x) ⇓ π

**(P-Field)**
Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ FieldAccess(p, f) ⇓ π

**(P-Tuple)**
Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ TupleAccess(p, i) ⇓ π

**(P-Index)**
Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ IndexAccess(p, i) ⇓ π

**(P-Deref)**
Γ; Ω ⊢ e ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ Deref(e) ⇓ π

**Provenance of Expressions.**

ProvExprJudg = {Γ; Ω ⊢ e ⇓ π}

**(P-Place-Expr)**
IsPlace(p)    Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ p ⇓ π

**(P-Literal)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ Literal(_) ⇓ ⊥

**(P-Move)**
Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ MoveExpr(p) ⇓ π

**(P-AddrOf)**
Γ; Ω ⊢ p ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ AddressOf(p) ⇓ π

**(P-Alloc)**
Γ; Ω ⊢ e ⇓ π_e    AllocTag(RS, r_opt) = tag
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ AllocExpr(r_opt, e) ⇓ π_Region(tag)

**(P-Region-Alloc-Method)**
name = `alloc`    (r : T_r) ∈ Γ    RegionActiveType(T_r)    AllocTag(RS, r) = tag
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ MethodCall(Identifier(r), name, args) ⇓ π_Region(tag)

**(P-If)**
Γ; Ω ⊢ b_t ⇓ π_t    Γ; Ω ⊢ b_f ⇓ π_f    JoinProv(π_t, π_f) = π
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ IfExpr(c, b_t, b_f) ⇓ π

**(P-If-No-Else)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ IfExpr(_, b_t, ⊥) ⇓ ⊥

ArmBodyProv(e, Ω) = π ⇔ Γ; Ω ⊢ e ⇓ π
ArmBodyProv(b, Ω) = π ⇔ Γ; Ω ⊢ b ⇓ π

ArmEnv(⟨Σ_π, RS⟩, pat) = ⟨Σ_π', RS⟩ ⇔ Γ ⊢ PatNames(pat) ⇓ N ∧ π_b = BindProv(⟨Σ_π, RS⟩, ⊥) ∧ Σ_π' = IntroAll_π(Σ_π, N, π_b)

ArmProv(⟨pat, _, body⟩) = π ⇔ ArmEnv(Ω, pat) = Ω' ∧ ArmBodyProv(body, Ω') = π

**(P-Match)**
∀ i, ArmProv(arm_i.body) = π_i    JoinAllProv([π_1, …, π_n]) = π
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ MatchExpr(_, arms) ⇓ π

ProvExprRules = {P-Place-Expr, P-Literal, P-Move, P-AddrOf, P-Alloc, P-Region-Alloc-Method, P-If, P-If-No-Else, P-Match, P-Block, P-Loop-Infinite, P-Loop-Conditional, P-Loop-Iter, P-Expr-Sub}

NoSpecificProvExpr(e) ⇔ ¬ ∃ r ∈ ProvExprRules \ {P-Expr-Sub}. PremisesHold(r, e)

**(P-Expr-Sub)**
NoSpecificProvExpr(e)    Children_LTR(e) = [e_1, …, e_n]    ∀ i, Γ; Ω ⊢ e_i ⇓ π_i    JoinAllProv([π_1, …, π_n]) = π
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ e ⇓ π

**Provenance of Statements.**

ProvStmtJudg = {Γ; Ω ⊢ s ⇒ Ω' ▷ ⟨Res, Brk, BrkVoid⟩, Γ; Ω ⊢ ss ⇒ Ω' ▷ ⟨Res, Brk, BrkVoid⟩}

LetOrVarStmt(binding) ∈ {LetStmt(binding), VarStmt(binding)}

**(Prov-Seq-Empty)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ [] ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-Seq-Cons)**
Γ; Ω ⊢ s ⇒ Ω_1 ▷ ⟨Res_1, Brk_1, B_1⟩    Γ; Ω_1 ⊢ ss ⇒ Ω_2 ▷ ⟨Res_2, Brk_2, B_2⟩
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ s :: ss ⇒ Ω_2 ▷ ⟨Res_1 ++ Res_2, Brk_1 ++ Brk_2, B_1 ∨ B_2⟩

**(Prov-LetVar)**
binding = ⟨pat, _, _, init, _⟩    Γ; Ω ⊢ init ⇓ π_init    Γ ⊢ PatNames(pat) ⇓ N    π_bind = BindProv(Ω, π_init)    Σ_π' = IntroAll_π(Σ_π, N, π_bind)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ LetOrVarStmt(binding) ⇒ ⟨Σ_π', RS⟩ ▷ ⟨[], [], false⟩

**(Prov-ShadowLet)**
Γ; Ω ⊢ init ⇓ π_init    π_bind = BindProv(Ω, π_init)    Σ_π' = ShadowAll_π(Σ_π, [x], π_bind)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ ShadowLetStmt(x, _, init) ⇒ ⟨Σ_π', RS⟩ ▷ ⟨[], [], false⟩

**(Prov-ShadowVar)**
Γ; Ω ⊢ init ⇓ π_init    π_bind = BindProv(Ω, π_init)    Σ_π' = ShadowAll_π(Σ_π, [x], π_bind)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ ShadowVarStmt(x, _, init) ⇒ ⟨Σ_π', RS⟩ ▷ ⟨[], [], false⟩

**(Prov-Assign)**
Γ; Ω ⊢ p ⇓ π_x    Γ; Ω ⊢ e ⇓ π_e    ¬(π_e < π_x)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ AssignStmt(p, e) ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-CompoundAssign)**
Γ; Ω ⊢ p ⇓ π_x    Γ; Ω ⊢ e ⇓ π_e    ¬(π_e < π_x)
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ CompoundAssignStmt(p, _, e) ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-Escape-Err)**
stmt ∈ {AssignStmt(p, e), CompoundAssignStmt(p, _, e)}    Γ; Ω ⊢ p ⇓ π_x    Γ; Ω ⊢ e ⇓ π_e    π_e < π_x    c = Code(Prov-Escape-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ stmt ⇑ c

**(Prov-ExprStmt)**
Γ; Ω ⊢ e ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ExprStmt(e) ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-ResultStmt)**
Γ; Ω ⊢ e ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ResultStmt(e) ⇒ Ω ▷ ⟨[π], [], false⟩

**(Prov-Return)**
Γ; Ω ⊢ e ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ReturnStmt(e) ⇒ Ω ▷ ⟨[π], [], false⟩

**(Prov-Return-Unit)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ReturnStmt(⊥) ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-Break)**
Γ; Ω ⊢ e ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ BreakStmt(e) ⇒ Ω ▷ ⟨[], [π], false⟩

**(Prov-Break-Unit)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ BreakStmt(⊥) ⇒ Ω ▷ ⟨[], [], true⟩

**(Prov-Continue)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ContinueStmt ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-UnsafeStmt)**
Γ; Ω ⊢ b ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ UnsafeBlockStmt(b) ⇒ Ω ▷ ⟨[], [], false⟩

**(Prov-DeferStmt)**
Γ; Ω ⊢ b ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ DeferStmt(b) ⇒ Ω ▷ ⟨[], [], false⟩

FrameTarget(Γ, ⊥) = r ⇔ InnermostActiveRegion(Γ) = r
FrameTarget(Γ, r) = r ⇔ Γ; R; L ⊢ Identifier(r) : T_r ∧ RegionActiveType(T_r)

**(Prov-RegionStmt)**
RegionOptsExpr(opts_opt) = opts    Γ; Ω ⊢ opts ⇓ π_opts    r = RegionBindName(Γ, alias_opt)    Σ_π^0 = PushScope_π(Σ_π)    π_r = BindProv(⟨Σ_π^0, RS⟩, ⊥)    Σ_π' = Intro_π(Σ_π^0, r, π_r)    RS' = ⟨r, r⟩ :: RS    Γ; ⟨Σ_π', RS'⟩ ⊢ b ⇓ π_b
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ RegionStmt(opts_opt, alias_opt, b) ⇒ ⟨Σ_π, RS⟩ ▷ ⟨[], [], false⟩

**(Prov-FrameStmt)**
FrameTarget(Γ, target_opt) = r    F = FreshRegion(Γ)    Σ_π^0 = PushScope_π(Σ_π)    π_F = BindProv(⟨Σ_π^0, RS⟩, ⊥)    Σ_π' = Intro_π(Σ_π^0, F, π_F)    RS' = ⟨F, r⟩ :: RS    Γ; ⟨Σ_π', RS'⟩ ⊢ b ⇓ π_b
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ FrameStmt(target_opt, b) ⇒ ⟨Σ_π, RS⟩ ▷ ⟨[], [], false⟩

**(Prov-ErrorStmt)**
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ ErrorStmt(_) ⇒ Ω ▷ ⟨[], [], false⟩

**Block Provenance.**

BlockProvJudg = {Γ; Ω ⊢ BlockProv(stmts, tail_opt) ⇓ π}

Ω_0 = ⟨PushScope_π(Σ_π), RS⟩

**(BlockProv-Res)**
Γ; Ω_0 ⊢ stmts ⇒ Ω_1 ▷ ⟨Res, Brk, BrkVoid⟩    Res ≠ []    JoinAllProv(Res) = π    (tail_opt = e ⇒ Γ; Ω_1 ⊢ e ⇓ π_t)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ BlockProv(stmts, tail_opt) ⇓ π

**(BlockProv-Tail)**
Γ; Ω_0 ⊢ stmts ⇒ Ω_1 ▷ ⟨Res, Brk, BrkVoid⟩    Res = []    tail_opt = e    Γ; Ω_1 ⊢ e ⇓ π
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ BlockProv(stmts, tail_opt) ⇓ π

**(BlockProv-Unit)**
Γ; Ω_0 ⊢ stmts ⇒ Ω_1 ▷ ⟨Res, Brk, BrkVoid⟩    Res = []    tail_opt = ⊥
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; ⟨Σ_π, RS⟩ ⊢ BlockProv(stmts, ⊥) ⇓ ⊥

**(P-Block)**
Γ; Ω ⊢ BlockProv(stmts, tail_opt) ⇓ π
────────────────────────────────────────────────────────────────
Γ; Ω ⊢ BlockExpr(stmts, tail_opt) ⇓ π

**Loop Provenance.**

BreakProv(body, Ω) = ⟨Brk, BrkVoid⟩ ⇔ body = BlockExpr(stmts, tail_opt) ∧ Ω_0 = ⟨PushScope_π(Σ_π), RS⟩ ∧ Γ; Ω_0 ⊢ stmts ⇒ Ω_1 ▷ ⟨Res, Brk, BrkVoid⟩ ∧ (tail_opt = e ⇒ Γ; Ω_1 ⊢ e ⇓ π_t)

IterElemProv(iter, Ω) = π ⇔ Γ; Ω ⊢ iter ⇓ π

LoopProvInf(Brk, BrkVoid) = ⊥ ⇔ Brk = []
LoopProvInf(Brk, BrkVoid) = π ⇔ Brk = [π_1, …, π_n] ∧ BrkVoid = false ∧ JoinAllProv([π_1, …, π_n]) = π

LoopProvFin(Brk, BrkVoid) = ⊥ ⇔ Brk = []
LoopProvFin(Brk, BrkVoid) = π ⇔ Brk = [π_1, …, π_n] ∧ BrkVoid = false ∧ JoinAllProv([π_1, …, π_n]) = π

ExtendProv(⟨Σ_π, RS⟩, pat, π) = ⟨Σ_π', RS⟩ ⇔ Γ ⊢ PatNames(pat) ⇓ N ∧ Σ_π' = IntroAll_π(Σ_π, N, π)

**(P-Loop-Infinite)**
BreakProv(body, Ω) = ⟨Brk, BrkVoid⟩    LoopProvInf(Brk, BrkVoid) = π
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ LoopInfinite(body) ⇓ π

**(P-Loop-Conditional)**
BreakProv(body, Ω) = ⟨Brk, BrkVoid⟩    LoopProvFin(Brk, BrkVoid) = π
────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ LoopConditional(cond, body) ⇓ π

**(P-Loop-Iter)**
IterElemProv(iter, Ω) = π_elem    ExtendProv(Ω, pat, π_elem) = Ω'    BreakProv(body, Ω') = ⟨Brk, BrkVoid⟩    LoopProvFin(Brk, BrkVoid) = π
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ; Ω ⊢ LoopIter(pat, ty_opt, iter, body) ⇓ π


EscapeOk(π_e, π_x) ⇔ ¬(π_e < π_x)

BindProv(⟨Σ_π, RS⟩, π_init) =
  { StackProv(Σ_π)    if π_init = ⊥
    π_init            otherwise }

StaticBindProv = π_Global

AssignProvOk(Ω, p, e) ⇔ Γ; Ω ⊢ p ⇓ π_x ∧ Γ; Ω ⊢ e ⇓ π_e ∧ EscapeOk(π_e, π_x)

### 5.3. Classes and Record Methods (Cursive0)

#### 5.3.1. Classes (Cursive0)

**Common Method-Signature Definitions.**

Distinct(xs) ⇔ ∀ i ≠ j. xs[i] ≠ xs[j]
Disjoint(xs, ys) ⇔ ∀ x ∈ xs. x ∉ ys

ReturnType(m) =
  { m.return_type_opt        if m.return_type_opt ≠ ⊥
    TypePrim("()")           if m.return_type_opt = ⊥ }

SelfVar = TypePath([`Self`])

SubstSelf(T, TypePath([`Self`])) = T
SubstSelf(T, TypePerm(p, ty)) = TypePerm(p, SubstSelf(T, ty))
SubstSelf(T, TypeTuple([t_1, …, t_n])) = TypeTuple([SubstSelf(T, t_1), …, SubstSelf(T, t_n)])
SubstSelf(T, TypeArray(ty, e)) = TypeArray(SubstSelf(T, ty), e)
SubstSelf(T, TypeSlice(ty)) = TypeSlice(SubstSelf(T, ty))
SubstSelf(T, TypeUnion([t_1, …, t_n])) = TypeUnion([SubstSelf(T, t_1), …, SubstSelf(T, t_n)])
SubstSelf(T, TypeFunc([⟨m_1, t_1⟩, …, ⟨m_n, t_n⟩], r)) = TypeFunc([⟨m_1, SubstSelf(T, t_1)⟩, …, ⟨m_n, SubstSelf(T, t_n)⟩], SubstSelf(T, r))
SubstSelf(T, TypePtr(ty, s)) = TypePtr(SubstSelf(T, ty), s)
SubstSelf(T, TypeRawPtr(q, ty)) = TypeRawPtr(q, SubstSelf(T, ty))
SubstSelf(T, TypeString(state_opt)) = TypeString(state_opt)
SubstSelf(T, TypeBytes(state_opt)) = TypeBytes(state_opt)
SubstSelf(T, TypeModalState(p, S)) = TypeModalState(p, S)
SubstSelf(T, TypeDynamic(p)) = TypeDynamic(p)
SubstSelf(T, TypePrim(n)) = TypePrim(n)
SubstSelf(T, TypePath(p)) = TypePath(p)    if p ≠ [`Self`]

RecvType(T, ReceiverShorthand(`const`)) = TypePerm(`const`, T)
RecvType(T, ReceiverShorthand(`unique`)) = TypePerm(`unique`, T)
RecvType(T, ReceiverExplicit(mode_opt, ty)) = SubstSelf(T, ty)

RecvMode(ReceiverShorthand(_)) = ⊥
RecvMode(ReceiverExplicit(mode_opt, _)) = mode_opt

PermOf(TypePerm(p, _)) = p
PermOf(ty) = `const`    otherwise

RecvPerm(T, r) = PermOf(RecvType(T, r))

ParamSig_T(T, params) = [⟨mode, SubstSelf(T, ty)⟩ | ⟨mode, name, ty⟩ ∈ params]
ParamBinds_T(T, params) = [⟨x_1, SubstSelf(T, T_1)⟩, …, ⟨x_n, SubstSelf(T, T_n)⟩]
ReturnType_T(T, m) = SubstSelf(T, ReturnType(m))

Sig_T(T, m) = ⟨RecvType(T, m.receiver), ParamSig_T(T, m.params), SubstSelf(T, ReturnType(m))⟩

SigSelf(m) = Sig_T(SelfVar, m)

**Class Declarations.**

ClassItems(Cl) = Cl.items
ClassMethods(Cl) = [ m | m ∈ ClassItems(Cl) ∧ ∃ vis, name, recv, params, ret, body, span, doc. m = ClassMethodDecl(vis, name, recv, params, ret, body, span, doc) ]
ClassFields(Cl) = [ f | f ∈ ClassItems(Cl) ∧ ∃ vis, name, ty, span, doc. f = ClassFieldDecl(vis, name, ty, span, doc) ]
MethodNames(Cl) = [ m.name | m ∈ ClassMethods(Cl) ]
FieldNames(Cl) = [ f.name | f ∈ ClassFields(Cl) ]

**Class Path Well-Formedness.**

**(WF-ClassPath)**
p ∈ dom(Σ.Classes)
──────────────────────────────────────────────
Γ ⊢ p : ClassPath

**(WF-ClassPath-Err)**
p ∉ dom(Σ.Classes)    c = Code(Superclass-Undefined)
────────────────────────────────────────────────────────────────
Γ ⊢ p : ClassPath ⇑ c

**Superclass Linearization (C3).**

Supers(Cl) = [S_1, …, S_n]

**(Lin-Base)**
Supers(Cl) = []
──────────────────────────────────────────────
Γ ⊢ Linearize(Cl) ⇓ [Cl]

Head(h :: t) = h
Tail([]) = []
Tail(h :: t) = t
HeadOk(h, Ls) ⇔ ∃ L ∈ Ls. L = h :: t ∧ ∀ L' ∈ Ls. h ∉ Tail(L')
SelectHead(Ls) = h ⇔ Ls = [L_1, …, L_n] ∧ L_i = h :: t ∧ HeadOk(h, Ls) ∧ ∀ j < i. ¬ HeadOk(Head(L_j), Ls)
SelectHead(Ls) = ⊥ ⇔ ¬ ∃ h. HeadOk(h, Ls)
PopHead(h, L) = t ⇔ L = h :: t
PopHead(h, L) = L ⇔ ¬(L = h :: t)
PopAll(h, Ls) = [PopHead(h, L) | L ∈ Ls]

**(Merge-Empty)**
∀ L ∈ Ls, L = []
──────────────────────────────────────────────
Γ ⊢ Merge(Ls) ⇓ []

**(Merge-Step)**
SelectHead(Ls) = h    Γ ⊢ Merge(PopAll(h, Ls)) ⇓ L
────────────────────────────────────────────────────────────────
Γ ⊢ Merge(Ls) ⇓ [h] ++ L

**(Merge-Fail)**
¬ ∃ h. HeadOk(h, Ls)
──────────────────────────────────────────────
Γ ⊢ Merge(Ls) ⇑

**(Lin-Ok)**
Γ ⊢ Merge([Linearize(S_1), …, Linearize(S_n), [S_1, …, S_n]]) ⇓ L
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Linearize(Cl) ⇓ [Cl] ++ L

**(Lin-Fail)**
Γ ⊢ Merge(⋯) ⇑
──────────────────────────────────────────────
Γ ⊢ Linearize(Cl) ⇑

**(Superclass-Cycle)**
Γ ⊢ Linearize(Cl) ⇑    c = Code(Superclass-Cycle)
────────────────────────────────────────────────────────────────
Γ ⊢ Cl ⇑ c

**Effective Method Set.**

Linearize(Cl) = [C_0, C_1, …, C_k] ∧ C_0 = Cl

EffMethods(Cl) = FirstByName(++_{i=0..k} ClassMethods(C_i))

FirstByName(ms) = FirstByName(ms, ∅)

FirstByName([], Seen) = []
FirstByName(m :: ms, Seen) =
  { m :: FirstByName(ms, Seen ∪ { m.name ↦ SigSelf(m) })    if m.name ∉ dom(Seen)
    FirstByName(ms, Seen)                                  if Seen[m.name] = SigSelf(m)
    ⇑                                                      otherwise }

**(EffMethods-Conflict)**
FirstByName(ms) ⇑    c = Code(EffMethods-Conflict)
────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c)

**Effective Field Set.**

FieldSig(f) = SubstSelf(SelfVar, f.type)

EffFields(Cl) = FirstFieldByName(++_{i=0..k} ClassFields(C_i))

FirstFieldByName(fs) = FirstFieldByName(fs, ∅)

FirstFieldByName([], Seen) = []
FirstFieldByName(f :: fs, Seen) =
  { f :: FirstFieldByName(fs, Seen ∪ { f.name ↦ FieldSig(f) })    if f.name ∉ dom(Seen)
    FirstFieldByName(fs, Seen)                                   if Seen[f.name] = FieldSig(f)
    ⇑                                                            otherwise }

**(EffFields-Conflict)**
FirstFieldByName(fs) ⇑    c = Code(EffFields-Conflict)
────────────────────────────────────────────────────────────────
Γ ⊢ Emit(c)

**Dispatchability.**

SelfOccurs(TypePath([`Self`])) = true
SelfOccurs(TypePerm(p, ty)) = SelfOccurs(ty)
SelfOccurs(TypeTuple([t_1, …, t_n])) = ∨_i SelfOccurs(t_i)
SelfOccurs(TypeArray(ty, e)) = SelfOccurs(ty)
SelfOccurs(TypeSlice(ty)) = SelfOccurs(ty)
SelfOccurs(TypeUnion([t_1, …, t_n])) = ∨_i SelfOccurs(t_i)
SelfOccurs(TypeFunc([⟨m_1, t_1⟩, …, ⟨m_n, t_n⟩], r)) = (∨_i SelfOccurs(t_i)) ∨ SelfOccurs(r)
SelfOccurs(TypePtr(ty, s)) = SelfOccurs(ty)
SelfOccurs(TypeRawPtr(q, ty)) = SelfOccurs(ty)
SelfOccurs(TypeString(state_opt)) = false
SelfOccurs(TypeBytes(state_opt)) = false
SelfOccurs(TypeModalState(p, S)) = false
SelfOccurs(TypeDynamic(p)) = false
SelfOccurs(TypePrim(n)) = false
SelfOccurs(TypePath(p)) = false    if p ≠ [`Self`]

SelfOccurs(m) ⇔ SelfOccurs(ReturnType(m)) ∨ ∃ ⟨_, _, ty⟩ ∈ m.params. SelfOccurs(ty)
HasReceiver(m) ⇔ m.receiver ≠ ⊥
vtable_eligible(m) ⇔ HasReceiver(m) ∧ ¬ SelfOccurs(m)

dispatchable(Cl) ⇔ ∀ m ∈ EffMethods(Cl). vtable_eligible(m)

**Class Method Well-Formedness.**

SelfTypeClass(ty) ⇔ ty = SelfVar ∨ ∃ p. ty = TypePerm(p, SelfVar)

**(WF-Class-Method)**
(r = ReceiverExplicit(mode_opt, ty) ⇒ SelfTypeClass(ty))    (r = ReceiverShorthand(_) ⇒ true)    Γ ⊢ RecvType(SelfVar, r) wf    self ∉ ParamNames(params)    Distinct(ParamNames(params))    ∀ ⟨_, _, T_i⟩ ∈ params, Γ ⊢ T_i wf    (return_type_opt = ⊥ ∨ Γ ⊢ return_type_opt wf)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ ⟨ClassMethodDecl, _, name, r, params, return_type_opt, body_opt, _, _⟩ : ClassMethodOK(Cl)

**(T-Class-Method-Body-Abstract)**
m.body_opt = ⊥
──────────────────────────────────────────────
Γ ⊢ m : ClassMethodBodyOK

**(T-Class-Method-Body)**
m.body_opt = body    T_self = RecvType(SelfVar, m.receiver)    R_m = ReturnType_T(SelfVar, m)    Γ_0 = PushScope(Γ)    IntroAll(Γ_0, [⟨`self`, T_self⟩] ++ ParamBinds_T(SelfVar, m.params)) ⇓ Γ_1    Γ_1; R_m; ⊥ ⊢ body : T_b    Γ ⊢ T_b <: R_m    (R_m ≠ TypePrim("()") ⇒ ExplicitReturn(body))
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ m : ClassMethodBodyOK

**(WF-Class)**
Distinct(MethodNames(Cl))    Distinct(FieldNames(Cl))    Disjoint(MethodNames(Cl), FieldNames(Cl))    Distinct(Supers(Cl))    ∀ S ∈ Supers(Cl), Γ ⊢ S : ClassPath    ∀ m ∈ ClassMethods(Cl), Γ ⊢ m : ClassMethodOK(Cl)    Γ ⊢ m : ClassMethodBodyOK    Γ ⊢ Linearize(Cl) ⇓ L
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ Cl : ClassOk

**(Class-Method-Dup)**
¬ Distinct(MethodNames(Cl))    c = Code(Class-Method-Dup)
────────────────────────────────────────────────────────────────
Γ ⊢ Cl ⇑ c

**(Class-AbstractField-Dup)**
¬ Distinct(FieldNames(Cl))    c = Code(Class-AbstractField-Dup)
────────────────────────────────────────────────────────────────
Γ ⊢ Cl ⇑ c

**(Class-Name-Conflict)**
¬ Disjoint(MethodNames(Cl), FieldNames(Cl))    c = Code(Class-Name-Conflict)
────────────────────────────────────────────────────────────────
Γ ⊢ Cl ⇑ c

**(Superclass-Undefined)**
S ∈ Supers(Cl)    ¬(Γ ⊢ S : ClassPath)    c = Code(Superclass-Undefined)
────────────────────────────────────────────────────────────────
Γ ⊢ Cl ⇑ c

**Class Implementation.**

Implements(T) = impls ⇔ T = RecordDecl(_, _, impls, _, _, _) ∨ T = EnumDecl(_, _, impls, _, _, _) ∨ T = ModalDecl(_, _, impls, _, _, _) ∨ T = ClassDecl(_, _, impls, _, _)

**Implements Clause Constraints.**
NoDefaultMethods(Cl) ⇔ ∀ m ∈ ClassMethods(Cl). m.body = ⊥
BitcopyImpliesClone(T) ⇔ (`Bitcopy` ∈ Implements(T)) ⇒ (Clone ∈ Implements(T))
AbstractsImplemented(T) ⇔ ∀ Cl ∈ Implements(T). ∀ m ∈ ClassMethodTable(Cl). (m.body = ⊥ ⇒ MethodByName(T, m.name) ≠ ⊥)

**(Impl-Duplicate-Class-Err)**
¬ Distinct(Implements(T))    c = Code(Impl-Duplicate-Class-Err)
────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

Fields(T) = Fields(R) ⇔ T = TypePath(p) ∧ RecordDecl(p) = R
Methods(T) = Methods(R) ⇔ T = TypePath(p) ∧ RecordDecl(p) = R
Fields(T) = [] ⇔ T = TypePath(p) ∧ (EnumDecl(p) = E ∨ Σ.Types[p] = `modal` M)
Methods(T) = [] ⇔ T = TypePath(p) ∧ (EnumDecl(p) = E ∨ Σ.Types[p] = `modal` M)
MethodByName(T, name) = m' ⇔ m' ∈ Methods(T) ∧ m'.name = name
MethodByName(T, name) = ⊥ ⇔ ¬ ∃ m' ∈ Methods(T). m'.name = name
ClassMethodTable(Cl) = EffMethods(Cl)
ClassFieldTable(Cl) = EffFields(Cl)

**(Impl-Abstract-Method)**
m ∈ ClassMethodTable(Cl)    m.body = ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') = Sig_T(T, m)    m'.override = false
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T implements abstract m

**(Impl-Missing-Method)**
m ∈ ClassMethodTable(Cl)    m.body = ⊥    MethodByName(T, m.name) = ⊥    c = Code(Impl-Missing-Method)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Impl-Sig-Err)**
m ∈ ClassMethodTable(Cl)    m.body = ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') ≠ Sig_T(T, m)    c = Code(Impl-Missing-Method)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Override-Abstract-Err)**
m ∈ ClassMethodTable(Cl)    m.body = ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') = Sig_T(T, m)    m'.override = true    c = Code(Override-Abstract-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Impl-Concrete-Default)**
m ∈ ClassMethodTable(Cl)    m.body ≠ ⊥    MethodByName(T, m.name) = ⊥
────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T uses default m

**(Impl-Concrete-Override)**
m ∈ ClassMethodTable(Cl)    m.body ≠ ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') = Sig_T(T, m)    m'.override = true
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T overrides m

**(Override-Missing-Err)**
m ∈ ClassMethodTable(Cl)    m.body ≠ ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') = Sig_T(T, m)    m'.override = false    c = Code(Override-Missing-Err)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Impl-Sig-Err-Concrete)**
m ∈ ClassMethodTable(Cl)    m.body ≠ ⊥    MethodByName(T, m.name) = m'    Sig_T(T, m') ≠ Sig_T(T, m)    c = Code(Impl-Missing-Method)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Override-NoConcrete)**
m' ∈ Methods(T)    m'.override = true    ¬ ∃ Cl ∈ Implements(T). ∃ m ∈ ClassMethodTable(Cl). m.name = m'.name ∧ m.body ≠ ⊥    c = Code(Override-NoConcrete)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
Γ ⊢ T : ImplementsOk ⇑ c

**(Impl-Field)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad f : T_i \in \text{Fields}(T) \quad T_i <: T_c}{\Gamma \vdash T \text{ satisfies field } f}$$

**(Impl-Field-Missing)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad \neg \exists T_i.\ f : T_i \in \text{Fields}(T) \quad c = \text{Code}(\text{Impl-Field-Missing})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Field-Type-Err)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad f : T_i \in \text{Fields}(T) \quad \neg(\Gamma \vdash T_i <: T_c) \quad c = \text{Code}(\text{Impl-Field-Type-Err})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(WF-Impl)**
$$\frac{\forall Cl \in \text{Implements}(T),\ \Gamma \vdash Cl : \text{ClassOk} \quad \text{Distinct}(\text{Implements}(T)) \quad \Gamma \vdash T : \text{BitcopyDropOk} \quad \forall Cl \in \text{Implements}(T),\ \forall m \in \text{ClassMethodTable}(Cl),\ (\Gamma \vdash T \text{ implements abstract } m \ \lor\ \Gamma \vdash T \text{ overrides } m \ \lor\ \Gamma \vdash T \text{ uses default } m) \quad \forall Cl \in \text{Implements}(T),\ \forall f \in \text{ClassFieldTable}(Cl),\ \Gamma \vdash T \text{ satisfies field } f}{\Gamma \vdash T : \text{ImplementsOk}}$$

**(Impl-Dup)**
$$\frac{\neg \text{Distinct}(\text{Implements}(T)) \quad c = \text{Code}(\text{Impl-Dup})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

$$\Gamma \vdash T <: Cl \iff Cl \in \text{Implements}(T) \land \Gamma \vdash T : \text{ImplementsOk}$$

**Superclass Closure.**
$$\frac{S \in \text{Supers}(Cl) \ \lor\ (S \in \text{Linearize}(Cl) \land S \ne Cl)}{\Gamma \vdash Cl <: S}$$
$$\frac{\Gamma \vdash T <: Cl \quad \Gamma \vdash Cl <: S}{\Gamma \vdash T <: S}$$

**Dynamic Class Types.**

**(T-Dynamic-Form)**
$$\frac{\Gamma; R; L \vdash e :place T \quad \text{IsPlace}(e) \quad \text{AddrOfOk}(e) \quad \Gamma \vdash Cl : \text{ClassPath} \quad \Gamma \vdash \text{StripPerm}(T) <: Cl \quad \text{dispatchable}(Cl)}{\Gamma; R; L \vdash e \ \texttt{as}\ \text{TypeDynamic}(Cl) : \text{TypeDynamic}(Cl)}$$

**(Dynamic-NonDispatchable)**
$$\frac{\Gamma; R; L \vdash e :place T \quad \text{IsPlace}(e) \quad \Gamma \vdash Cl : \text{ClassPath} \quad \Gamma \vdash \text{StripPerm}(T) <: Cl \quad \neg \text{dispatchable}(Cl) \quad c = \text{Code}(\text{Dynamic-NonDispatchable})}{\Gamma; R; L \vdash e \ \texttt{as}\ \text{TypeDynamic}(Cl) \Uparrow c}$$

**Method Lookup for Concrete Types.**

$$\text{ClassDefaults}(T,\text{name}) = \{ m \mid \exists Cl \in \text{Implements}(T).\ m \in \text{ClassMethodTable}(Cl) \land m.\text{name}=\text{name} \land m.\text{body} \ne \bot \}$$
$$\text{LookupMethod}(T,\text{name}) = m \iff \text{MethodByName}(T,\text{name}) = m$$
$$\text{LookupMethod}(T,\text{name}) = m \iff \text{MethodByName}(T,\text{name}) = \bot \land |\text{ClassDefaults}(T,\text{name})| = 1 \land m \in \text{ClassDefaults}(T,\text{name})$$
$$\text{LookupMethod}(T,\text{name}) = \bot \iff \text{MethodByName}(T,\text{name}) = \bot \land (|\text{ClassDefaults}(T,\text{name})| = 0 \lor |\text{ClassDefaults}(T,\text{name})| > 1)$$

**(LookupMethod-NotFound)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{MethodByName}(\text{StripPerm}(T_b), name) = \bot \quad \text{ClassDefaults}(\text{StripPerm}(T_b), name) = \emptyset \quad c = \text{Code}(\text{LookupMethod-NotFound})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(LookupMethod-Ambig)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{MethodByName}(\text{StripPerm}(T_b), name) = \bot \quad |\text{ClassDefaults}(\text{StripPerm}(T_b), name)| > 1 \quad c = \text{Code}(\text{LookupMethod-Ambig})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(Drop-Call-Err)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{LookupMethod}(\text{StripPerm}(T_b), name) = m \quad \text{MethodOwner}(m) = \texttt{Drop} \quad \text{MethodName}(m) = \texttt{"drop"} \quad c = \text{Code}(\text{Drop-Call-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(Drop-Call-Err-Dyn)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name) = m \quad \text{MethodOwner}(m) = \texttt{Drop} \quad \text{MethodName}(m) = \texttt{"drop"} \quad c = \text{Code}(\text{Drop-Call-Err-Dyn})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(T-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ T \quad \text{LookupMethod}(T, name) = m \quad \text{RecvPerm}(T, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

**(MethodCall-RecvPerm-Err)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ T \quad \text{LookupMethod}(T, name) = m \quad \text{RecvPerm}(T, m.\text{receiver}) = P_{\text{method}} \quad \neg \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad c = \text{Code}(\text{MethodCall-RecvPerm-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$
**(T-Dynamic-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name) = m \quad \text{RecvPerm}(\text{SelfVar}, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

**(LookupClassMethod-NotFound)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name)\ \text{undefined} \quad c = \text{Code}(\text{LookupMethod-NotFound})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$


#### 5.3.2. Record Methods (Cursive0)

**Definitions.**

$$\text{Fields}(R) = [ f \mid f \in R.\text{members} \land \exists vis,name,ty,init,span,doc.\ f=\text{FieldDecl}(vis,name,ty,init,span,doc) ]$$
$$\text{Methods}(R) = [ m \mid m \in R.\text{members} \land \exists vis,override,name,recv,params,ret,body,span,doc.\ m=\text{MethodDecl}(vis,override,name,recv,params,ret,body,span,doc) ]$$
$$\text{Self}_R = \text{TypePath}(\text{RecordPath}(R))$$
$$\text{SelfType}(R, ty) \iff ty = \text{Self}_R \lor \exists p.\ ty = \text{TypePerm}(p,\ \text{Self}_R)$$

**Static Semantics**

**(Recv-Explicit)**
$$\frac{\text{SelfType}(R, ty)}{\Gamma \vdash \text{ReceiverExplicit}(mode\_opt, ty) : \text{Recv}(R, \text{PermOf}(ty), mode\_opt)}$$

**(Record-Method-RecvSelf-Err)**
$$\frac{\neg \text{SelfType}(R, ty) \quad c = \text{Code}(\text{Record-Method-RecvSelf-Err})}{\Gamma \vdash \text{ReceiverExplicit}(mode\_opt, ty) \Uparrow c}$$

**(Recv-Const)**
$$\frac{}{\Gamma \vdash \text{ReceiverShorthand}(\texttt{const}) : \text{Recv}(R, \texttt{const}, \bot)}$$

**(Recv-Unique)**
$$\frac{}{\Gamma \vdash \text{ReceiverShorthand}(\texttt{unique}) : \text{Recv}(R, \texttt{unique}, \bot)}$$

$$\text{ParamNames}(\text{params}) = [x \mid \langle \_, x, \_ \rangle \in \text{params}]$$

**(WF-Record-Method)**
$$\frac{\Gamma \vdash r : \text{Recv}(R, P, mode) \quad \text{self} \notin \text{ParamNames}(\text{params}) \quad \text{Distinct}(\text{ParamNames}(\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in \text{params},\ \Gamma \vdash T_i\ \text{wf} \quad (\text{return\_type}\_opt = \bot \ \lor\ \Gamma \vdash \text{return\_type}\_opt\ \text{wf})}{\Gamma \vdash \langle \text{MethodDecl}, \_, \text{name}, r, \text{params}, \text{return\_type}\_opt, \text{body}, \_, \_ \rangle : \text{MethodOK}(R, P, mode)}$$

**(T-Record-Method-Body)**
$$\frac{\Gamma \vdash m : \text{MethodOK}(R, P, mode) \quad T_{\text{self}} = \text{RecvType}(\text{Self}_R, m.\text{receiver}) \quad R_m = \text{ReturnType}_T(\text{Self}_R, m) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, T_{\text{self}} \rangle] \mathbin{+\!\!+} \text{ParamBinds}_T(\text{Self}_R, m.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; R_m; \bot \vdash m.\text{body} : T_b \quad \Gamma \vdash T_b <: R_m \quad (R_m \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(m.\text{body}))}{\Gamma \vdash m : \text{MethodBodyOK}(R)}$$

$$\text{MethodNames}(R) = [ m.\text{name} \mid m \in \text{Methods}(R) ]$$

**(WF-Record-Methods)**
$$\frac{\text{Distinct}(\text{MethodNames}(R)) \quad \forall m \in \text{Methods}(R),\ \Gamma \vdash m : \text{MethodOK}(R, \_, \_) \quad \Gamma \vdash m : \text{MethodBodyOK}(R)}{\Gamma \vdash \text{Methods}(R) : \text{ok}}$$

**(Record-Method-Dup)**
$$\frac{\neg \text{Distinct}(\text{MethodNames}(R)) \quad c = \text{Code}(\text{Record-Method-Dup})}{\Gamma \vdash \text{Methods}(R) \Uparrow c}$$

**Method Lookup.**

$$\text{LookupMethodRules} = \text{RulesIn}(\{\texttt{"5.3.1"}\})$$

**Argument Compatibility.**

$$\text{ArgsOkJudg} = \{\Gamma; R; L \vdash \text{ArgsOk}(params, args)\}$$

$$\text{RecvBaseType}(base, mode) = P\ T \iff (mode = \bot \land \Gamma; R; L \vdash base :place P\ T) \lor (mode = \texttt{move} \land \Gamma; R; L \vdash base : P\ T)$$

**(Args-Empty)**
$$\frac{}{\Gamma; R; L \vdash \text{ArgsOk}([], [])}$$

**(Args-Cons)**
$$\frac{\Gamma; R; L \vdash \text{MovedArg}(moved, e) \Leftarrow T_p \dashv \emptyset \quad moved = \text{true} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

**(Args-Cons-Ref)**
$$\frac{\Gamma; R; L \vdash e \Leftarrow_{\text{place}} T_p \quad \text{AddrOfOk}(e) \quad moved = \text{false} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

$$\text{RecvArgOk}(base, mode) \iff (mode = \bot \land \text{AddrOfOk}(base)) \lor (mode = \texttt{move} \land \exists p.\ base = \text{MoveExpr}(p))$$
$$\text{ArgsOkDiagRules} = \text{RulesIn}(\{\texttt{"5.2.4"}\})$$

**(T-Record-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ R_{\text{rec}} \quad \text{LookupMethod}(R_{\text{rec}}, name) = m \quad \text{RecvPerm}(R_{\text{rec}}, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

$$\text{BindParams}(m, v_{\text{self}}, \vec{v}) = \{\texttt{self} \mapsto v_{\text{self}}\} \cup \{ x_i \mapsto v_i \mid m.\text{params} = [\langle \_, x_i, \_ \rangle],\ \vec{v} = [v_i] \}$$
$$\text{BindStmt}(x, e) = \text{LetStmt}(\langle \text{IdentifierPattern}(x),\ \bot,\ \text{Operator}(\texttt{"="}),\ e,\ \bot \rangle)$$
$$\text{BindStmts}(m, v_{\text{self}}, \vec{v}) = [\text{BindStmt}(\texttt{self}, v_{\text{self}})] \mathbin{+\!\!+} [\text{BindStmt}(x_i, v_i) \mid m.\text{params} = [\langle \_, x_i, \_ \rangle],\ \vec{v} = [v_i]]$$
$$\text{ApplyMethod}(m, v_{\text{self}}, \vec{v}) = \text{BlockExpr}(bs \mathbin{+\!\!+} ss, t) \iff \text{BindStmts}(m, v_{\text{self}}, \vec{v}) = bs \land m.\text{body} = \text{BlockExpr}(ss, t)$$

**(Step-MethodCall)**
$$\frac{\Gamma \vdash v_{\text{self}} : P_{\text{caller}}\ R \quad \text{LookupMethod}(R, name) = m}{\langle \text{MethodCall}(v_{\text{self}}, name, \vec{v}) \rangle \to \langle \text{ApplyMethod}(m, v_{\text{self}}, \vec{v}) \rangle}$$


### 5.4. Modal Types (Definitions)

$$\text{States}(M) \ne \emptyset$$
$$\text{States}(M) = \{ S \mid S \in \text{StateNames}(M) \}$$
$$\text{Payload}(M, S) = [\langle f_1, T_1 \rangle,\ \ldots,\ \langle f_k, T_k \rangle]$$
$$\mathcal{T}_M = \{M\} \cup \{ M@S \mid S \in \text{States}(M) \}$$

**Payload Map.**

$$\text{PayloadMap}(M, S) =
\begin{cases}
\{ f_i \mapsto T_i \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S) \} & \text{if } \text{Distinct}([f_i \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S)]) \\
\bot & \text{otherwise}
\end{cases}$$

**(WF-Modal-Payload)**
$$\frac{\forall i,\ \Gamma \vdash T_i\ \text{wf} \quad \forall i \ne j,\ f_i \ne f_j}{\Gamma \vdash \text{Payload}(M, S)\ \text{wf}}$$

**(Modal-Payload-DupField)**
$$\frac{\exists i \ne j.\ f_i = f_j \quad c = \text{Code}(\text{Modal-Payload-DupField})}{\Gamma \vdash \text{Payload}(M, S)\ \text{wf} \Uparrow c}$$

**Type Well-Formedness (Cursive0).**

$$\text{TypesMap} = \Sigma.\text{Types}$$
$$\text{ClassesMap} = \Sigma.\text{Classes}$$

$$\text{TypeWFJudg} = \{\Gamma \vdash T\ \text{wf}\}$$

**(WF-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad name \in \text{PrimTypes}_{C0}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Perm)**
$$\frac{T = \text{TypePerm}(p, T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Tuple)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Array)**
$$\frac{T = \text{TypeArray}(T_0, e) \quad \Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad n \ge 2 \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Union-TooFew)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad n < 2 \quad c = \text{Code}(\text{WF-Union-TooFew})}{\Gamma \vdash T\ \text{wf} \Uparrow c}$$

**(WF-Func)**
$$\frac{T = \text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad \Gamma \vdash R\ \text{wf} \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Path)**
$$\frac{T = \text{TypePath}(p) \quad p \in \text{dom}(\Sigma.\text{Types})}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Dynamic)**
$$\frac{T = \text{TypeDynamic}(p) \quad p \in \text{dom}(\Sigma.\text{Classes})}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Dynamic-Err)**
$$\frac{T = \text{TypeDynamic}(p) \quad p \notin \text{dom}(\Sigma.\text{Classes}) \quad c = \text{Code}(\text{Superclass-Undefined})}{\Gamma \vdash T\ \text{wf} \Uparrow c}$$

**(WF-String)**
$$\frac{T = \text{TypeString}(state\_opt) \quad state\_opt \in \{\bot, \texttt{View}, \texttt{Managed}\}}{\Gamma \vdash T\ \text{wf}}$$


**(WF-Bytes)**
$$\frac{T = \text{TypeBytes}(state\_opt) \quad state\_opt \in \{\bot, \texttt{View}, \texttt{Managed}\}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, state\_opt) \quad state\_opt \in \{\bot, \texttt{Valid}, \texttt{Null}, \texttt{Expired}\} \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad p \in \text{dom}(\Sigma.\text{Types}) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M)}{\Gamma \vdash T\ \text{wf}}$$

**(WF-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**Static Semantics**

**(Modal-WF)**
$$\frac{n \ge 1 \quad \forall i \in 1..n,\ S_i\ \text{unique} \quad \forall i,\ \Gamma \vdash \text{Payload}(M, S_i)\ \text{wf} \quad \forall i,\ S_i \ne M}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf}}$$

**(Modal-NoStates-Err)**
$$\frac{n = 0 \quad c = \text{Code}(\text{Modal-NoStates-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(Modal-DupState-Err)**
$$\frac{\neg \text{Distinct}([S_1,\ldots,S_n]) \quad c = \text{Code}(\text{Modal-DupState-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(Modal-StateName-Err)**
$$\frac{\exists i.\ S_i = M \quad c = \text{Code}(\text{Modal-StateName-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(State-Specific-WF)**
$$\frac{S \in \text{States}(M)}{\Gamma \vdash M@S\ \text{wf}}$$

$$\text{PayloadNames}(M, S) = [ f \mid \langle f,\_ \rangle \in \text{Payload}(M, S) ]$$
$$\text{PayloadNameSet}(M, S) = \text{Set}(\text{PayloadNames}(M, S))$$

**(T-Modal-State-Intro)**
$$\frac{\Sigma.\text{Types}[path] = \texttt{modal } M \quad S \in \text{States}(M) \quad path \notin \{[\texttt{"File"}], [\texttt{"DirIter"}]\} \quad \text{PayloadNameSet}(M, S) = \text{FieldInitSet}(fields) \quad \text{Distinct}(\text{FieldInitNames}(fields)) \quad \forall \langle f, e \rangle \in fields,\ \text{PayloadMap}(M, S)(f) = T_f \land \Gamma; R; L \vdash e \Leftarrow T_f \dashv \emptyset}{\Gamma; R; L \vdash \text{RecordExpr}(\text{ModalStateRef}(path, S), fields) : \text{TypeModalState}(path, S)}$$

**(Modal-Incomparable)**
$$\frac{S_A \ne S_B}{\Gamma \vdash M@S_A \not<: M@S_B \quad \land \quad \Gamma \vdash M@S_B \not<: M@S_A}$$

#### 5.4.1. Built-in Modal Type `Region` (Cursive0)

$$[\texttt{"Region"}] \in \text{dom}(\Sigma.\text{Types})$$
$$\text{States}(\texttt{Region}) = \{\ \texttt{@Active},\ \texttt{@Frozen},\ \texttt{@Freed}\ \}$$

$$\text{RegionPayloadFields} = [\langle \texttt{handle}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$

$$\text{Payload}(\texttt{Region}, \texttt{@Active}) = \text{RegionPayloadFields} \quad \text{Payload}(\texttt{Region}, \texttt{@Frozen}) = \text{RegionPayloadFields} \quad \text{Payload}(\texttt{Region}, \texttt{@Freed}) = \text{RegionPayloadFields}$$

$$\text{RegionProcs} = \{\texttt{Region::new\_scoped},\ \texttt{Region::alloc},\ \texttt{Region::reset\_unchecked},\ \texttt{Region::freeze},\ \texttt{Region::thaw},\ \texttt{Region::free\_unchecked}\}$$

$$\text{RegionProcSig}(\texttt{Region::new\_scoped}) = \langle [\langle \bot,\ \texttt{options},\ \text{TypePath}([\texttt{"RegionOptions"}]) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::alloc}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle,\ \langle \bot,\ \texttt{value},\ T \rangle],\ T_{\pi_{\text{Region}}(\texttt{self})} \rangle \quad (T \in \text{Type})$$
$$\text{RegionProcSig}(\texttt{Region::reset\_unchecked}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::freeze}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::thaw}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::free\_unchecked}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeUnion}([\text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}),\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen})])) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Freed}) \rangle$$

$$\text{ProvType}(T,\pi) = T_\pi$$
$$\text{BaseType}(T_\pi) = T \quad \text{ProvOf}(T_\pi) = \pi$$

$$\texttt{Bitcopy} \notin \text{Implements}(\text{TypePath}([\texttt{"Region"}]))$$

**(Region-Unchecked-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : T \quad \text{StripPerm}(T) = \text{TypeModalState}([\texttt{"Region"}], S) \quad S \in \{\texttt{Active}, \texttt{Frozen}\} \quad name \in \{\texttt{"reset\_unchecked"}, \texttt{"free\_unchecked"}\} \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, name, args))) \quad c = \text{Code}(\text{Region-Unchecked-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

### 5.5. State-Specific Fields

$$\text{ModalFieldVisible}(m, p) \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land \text{ModuleOfPath}(\text{ModalPath}(M)) = m$$

**(T-Modal-Field)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \text{ModalFieldVisible}(m, p)}{\Gamma; R; L \vdash e.f : T}$$

**(T-Modal-Field-Perm)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePerm}(p', \text{TypeModalState}(p, S)) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \text{ModalFieldVisible}(m, p)}{\Gamma; R; L \vdash e.f : \text{TypePerm}(p', T)}$$

**(Modal-Field-Missing)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f)\ \text{undefined} \quad c = \text{Code}(\text{Modal-Field-Missing})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

**(Modal-Field-General-Err)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad c = \text{Code}(\text{Modal-Field-General-Err})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

**(Modal-Field-NotVisible)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \neg \text{ModalFieldVisible}(m, p) \quad c = \text{Code}(\text{Modal-Field-NotVisible})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

### 5.6. Transitions and State-Specific Methods

$$\text{Methods}(S) = [ m \mid m \in \text{StateMembers}(S) \land \exists vis,name,params,ret,body,span,doc.\ m=\text{StateMethodDecl}(vis,name,params,ret,body,span,doc) ]$$
$$\text{Transitions}(S) = [ t \mid t \in \text{StateMembers}(S) \land \exists vis,name,params,target,body,span,doc.\ t=\text{TransitionDecl}(vis,name,params,target,body,span,doc) ]$$
$$\text{StateMethodNames}(S) = [ m.\text{name} \mid m \in \text{Methods}(S) ]$$
$$\text{TransitionNames}(S) = [ t.\text{name} \mid t \in \text{Transitions}(S) ]$$

**(StateMethod-Dup)**
$$\frac{\neg \text{Distinct}(\text{StateMethodNames}(S)) \quad c = \text{Code}(\text{StateMethod-Dup})}{\Gamma \vdash S \Uparrow c}$$

**(Transition-Dup)**
$$\frac{\neg \text{Distinct}(\text{TransitionNames}(S)) \quad c = \text{Code}(\text{Transition-Dup})}{\Gamma \vdash S \Uparrow c}$$

$$\text{LookupStateMethod}(S,\text{name}) = m \iff m \in \text{Methods}(S) \land m.\text{name}=\text{name}$$
$$\text{LookupStateMethod}(S,\text{name}) = \bot \iff \neg \exists m \in \text{Methods}(S).\ m.\text{name}=\text{name}$$
$$\text{LookupTransition}(S,\text{name}) = t \iff t \in \text{Transitions}(S) \land t.\text{name}=\text{name}$$
$$\text{LookupTransition}(S,\text{name}) = \bot \iff \neg \exists t \in \text{Transitions}(S).\ t.\text{name}=\text{name}$$
$$\text{StateMemberVisible}(\text{mod}, M, \text{vis}) \iff \text{vis} \in \{\texttt{public},\ \texttt{internal}\} \lor (\text{vis} \in \{\texttt{private},\ \texttt{protected}\} \land \text{ModuleOfPath}(\text{ModalPath}(M)) = \text{mod})$$
$$\text{MethodSig}(M,S,m).\text{recv} = \text{TypePerm}(\texttt{const},\ M@S)$$
$$\text{MethodSig}(M,S,m).\text{params} = m.\text{params}$$
$$\text{MethodSig}(M,S,m).\text{ret} = \text{ReturnType}(m)$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{recv} = \text{TypePerm}(\texttt{unique},\ M@S_{\text{src}})$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{params} = t.\text{params}$$
$$S_{\text{tgt}} = t.\text{target}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{ret} = M@S_{\text{tgt}}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{target} = S_{\text{tgt}}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{mode} = \texttt{move}$$

**State Method and Transition Well-Formedness.**

**(WF-State-Method)**
$$\frac{\text{self} \notin \text{ParamNames}(md.\text{params}) \quad \text{Distinct}(\text{ParamNames}(md.\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in md.\text{params},\ \Gamma \vdash T_i\ \text{wf} \quad (md.\text{return\_type}\_opt = \bot \ \lor\ \Gamma \vdash md.\text{return\_type}\_opt\ \text{wf})}{\Gamma \vdash md : \text{StateMethodOK}(M, S)}$$

**(WF-Transition)**
$$\frac{\text{self} \notin \text{ParamNames}(tr.\text{params}) \quad \text{Distinct}(\text{ParamNames}(tr.\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in tr.\text{params},\ \Gamma \vdash T_i\ \text{wf} \quad tr.\text{target} \in \text{States}(M)}{\Gamma \vdash tr : \text{TransitionOK}(M, S_{\text{src}})}$$

**(Transition-Target-Err)**
$$\frac{tr.\text{target} \notin \text{States}(M) \quad c = \text{Code}(\text{Transition-Target-Err})}{\Gamma \vdash tr \Uparrow c}$$

**(T-Modal-Transition)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : \texttt{unique}\ M@S_{\text{src}} \quad \text{LookupTransition}(S_{\text{src}}, t) = tr \quad \text{StateMemberVisible}(mod, M, tr.\text{vis}) \quad \text{TransitionSig}(M, S_{\text{src}}, tr).\text{params} = ps \quad \text{TransitionSig}(M, S_{\text{src}}, tr).\text{target} = S_{\text{tgt}} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, args) \quad \text{RecvArgOk}(e_{\text{self}}, \texttt{move})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) : M@S_{\text{tgt}}}$$

**(Transition-Source-Err)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : T \quad (\text{PermOf}(T) \ne \texttt{unique} \ \lor\ \text{StripPerm}(T) \ne \text{TypeModalState}(\_,\_)) \quad c = \text{Code}(\text{Transition-Source-Err})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) \Uparrow c}$$

**(Transition-NotVisible)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : \texttt{unique}\ M@S_{\text{src}} \quad \text{LookupTransition}(S_{\text{src}}, t) = tr \quad \neg \text{StateMemberVisible}(mod, M, tr.\text{vis}) \quad c = \text{Code}(\text{Transition-NotVisible})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) \Uparrow c}$$


**(T-Modal-Transition-Body)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S_{\text{src}} \in \text{States}(M) \quad tr \in \text{Transitions}(S_{\text{src}}) \quad tr.\text{body} = body \quad tr.\text{target} = S_{\text{tgt}} \quad S_{\text{tgt}} \in \text{States}(M) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(p, S_{\text{src}})) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(tr.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; \text{TypeModalState}(p, S_{\text{tgt}}); \bot \vdash body : T_b \quad \Gamma \vdash T_b <: \text{TypeModalState}(p, S_{\text{tgt}})}{\Gamma \vdash tr : \text{TransitionBodyOK}(p, S_{\text{src}})}$$

**(Transition-Body-Err)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S_{\text{src}} \in \text{States}(M) \quad tr \in \text{Transitions}(S_{\text{src}}) \quad tr.\text{body} = body \quad tr.\text{target} = S_{\text{tgt}} \quad S_{\text{tgt}} \in \text{States}(M) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(p, S_{\text{src}})) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(tr.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; \text{TypeModalState}(p, S_{\text{tgt}}); \bot \vdash body : T_b \quad \neg(\Gamma \vdash T_b <: \text{TypeModalState}(p, S_{\text{tgt}})) \quad c = \text{Code}(\text{Transition-Body-Err})}{\Gamma \vdash tr \Uparrow c}$$

**(T-Modal-Method)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{PermSub}(P_{\text{caller}}, \texttt{const}) \quad \text{LookupStateMethod}(S, m) = md \quad \text{StateMemberVisible}(mod, M, md.\text{vis}) \quad \text{MethodSig}(M,S,md).\text{params} = ps \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, args)}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) : \text{ReturnType}(md)}$$

**(Modal-Method-NotFound)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{LookupStateMethod}(S, m)\ \text{undefined} \quad c = \text{Code}(\text{Modal-Method-NotFound})}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) \Uparrow c}$$

**(Modal-Method-NotVisible)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{LookupStateMethod}(S, m) = md \quad \neg \text{StateMemberVisible}(mod, M, md.\text{vis}) \quad c = \text{Code}(\text{Modal-Method-NotVisible})}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) \Uparrow c}$$

**(T-Modal-Method-Body)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad md \in \text{Methods}(S) \quad md.\text{body} = body \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{const}, \text{TypeModalState}(p, S)) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(md.\text{params})) \Downarrow \Gamma_1 \quad R_m = \text{ReturnType}(md) \quad \Gamma_1; R_m; \bot \vdash body : T_b \quad \Gamma \vdash T_b <: R_m \quad (R_m \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(body))}{\Gamma \vdash md : \text{StateMethodBodyOK}(p, S)}$$

### 5.7. Modal Widening (`widen`)

$$\text{WIDEN\_LARGE\_PAYLOAD\_THRESHOLD\_BYTES} = 256$$

**(T-Modal-Widen)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}{\Gamma; R; L \vdash \texttt{widen } e : \text{TypePath}(p)}$$

**(T-Modal-Widen-Perm)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePerm}(p', \text{TypeModalState}(p, S)) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}{\Gamma; R; L \vdash \texttt{widen } e : \text{TypePerm}(p', \text{TypePath}(p))}$$

**(Widen-AlreadyGeneral)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad c = \text{Code}(\text{Widen-AlreadyGeneral})}{\Gamma; R; L \vdash \texttt{widen } e \Uparrow c}$$

**(Widen-NonModal)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = U \quad U \ne \text{TypeModalState}(\_,\_) \quad \neg \exists p, M.\ (U = \text{TypePath}(p) \land \Sigma.\text{Types}[p] = \texttt{modal } M) \quad c = \text{Code}(\text{Widen-NonModal})}{\Gamma; R; L \vdash \texttt{widen } e \Uparrow c}$$

**Niche-Layout-Compatible Conditions**

$$\text{NicheCompatible}(M,S) \iff \text{NicheApplies}(M) \land \text{PayloadState}(M) = S \land \text{sizeof}(M@S) = \text{sizeof}(M) \land \text{alignof}(M@S) = \text{alignof}(M)$$

$$\text{WidenWarnCond}(p,S) \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land \text{sizeof}(M@S) > \text{WIDEN\_LARGE\_PAYLOAD\_THRESHOLD\_BYTES} \land \neg \text{NicheCompatible}(M,S)$$

**(Warn-Widen-LargePayload)**
$$\frac{\text{WidenWarnCond}(p,S) \quad sp = \text{span}(\text{Unary}(\texttt{"widen"}, e)) \quad \Gamma \vdash \text{Emit}(W\text{-}SYS\text{-}4010, sp)}{\Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}$$

**(Warn-Widen-Ok)**
$$\frac{\neg \text{WidenWarnCond}(p,S)}{\Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}$$

**Size Relationship**

$$\text{sizeof}(M@S) \le \text{sizeof}(M)$$

### 5.8. String and Bytes Types and States

$$\text{States}(\texttt{string}) = \{\ \texttt{@Managed},\ \texttt{@View}\ \}$$
$$\text{States}(\texttt{bytes}) = \{\ \texttt{@Managed},\ \texttt{@View}\ \}$$

**Modal Widening.**

$$\frac{S \in \{\texttt{@Managed}, \texttt{@View}\}}{\Gamma \vdash \texttt{string@}S <: \texttt{string}}$$
$$\frac{S \in \{\texttt{@Managed}, \texttt{@View}\}}{\Gamma \vdash \texttt{bytes@}S <: \texttt{bytes}}$$

$$\text{StringBytesBuiltinTable} =
\left\{
\begin{aligned}
&\langle \texttt{string::from},\ [\langle \bot,\ \texttt{source},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::as\_view},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@Managed})) \rangle],\ \text{TypeString}(\texttt{@View}) \rangle,\\
&\langle \texttt{string::to\_managed},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::clone\_with},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::append},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeString}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::length},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"usize"}) \rangle,\\
&\langle \texttt{string::is\_empty},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle,\\
&\langle \texttt{bytes::with\_capacity},\ [\langle \bot,\ \texttt{cap},\ \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::from\_slice},\ [\langle \bot,\ \texttt{data},\ \text{TypePerm}(\texttt{const}, \text{TypeSlice}(\text{TypePrim}(\texttt{"u8"}))) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::as\_view},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@Managed})) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::to\_managed},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::view},\ [\langle \bot,\ \texttt{data},\ \text{TypePerm}(\texttt{const}, \text{TypeSlice}(\text{TypePrim}(\texttt{"u8"}))) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::view\_string},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::append},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeBytes}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::length},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"usize"}) \rangle,\\
&\langle \texttt{bytes::is\_empty},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle
\end{aligned}
\right\}$$
$$\text{StringBytesBuiltinSig}(method) = \langle params, ret \rangle \iff \langle method, params, ret \rangle \in \text{StringBytesBuiltinTable}$$

$$\text{ByteSeq} = \text{List}(\texttt{u8})$$
$$SB = \langle \text{StrBuf},\ \text{BytesBuf},\ \text{BytesCap} \rangle$$
$$\text{StrBuf} : \texttt{string@Managed} \rightharpoonup \text{ByteSeq}$$
$$\text{BytesBuf} : \texttt{bytes@Managed} \rightharpoonup \text{ByteSeq}$$
$$\text{BytesCap} : \texttt{bytes@Managed} \rightharpoonup \text{usize}$$

$$\text{ViewBytes} : (\texttt{string@View} \cup \texttt{bytes@View}) \to \text{ByteSeq}$$
$$\text{ByteSeqOf}(SB, v) = \begin{cases}
\text{StrBuf}(v) & v:\texttt{string@Managed} \\
\text{BytesBuf}(v) & v:\texttt{bytes@Managed} \\
\text{ViewBytes}(v) & v:\texttt{string@View}\ \text{or}\ v:\texttt{bytes@View}
\end{cases}$$
$$\text{ByteLen}(SB, v) = |\text{ByteSeqOf}(SB, v)|$$

$$\text{SliceBytes}(\text{data}) = [b \mid b \in \text{data}]$$

$$\text{StringBytesJudg} = \{\text{StringFrom}(SB, source, heap) \Downarrow (r, SB'),\ \text{StringAsView}(SB, self) \Downarrow v,\ \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB'),\ \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB'),\ \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB'),\ \text{StringLength}(SB, self) \Downarrow n,\ \text{StringIsEmpty}(SB, self) \Downarrow b,\ \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB'),\ \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB'),\ \text{BytesAsView}(SB, self) \Downarrow v,\ \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB'),\ \text{BytesView}(SB, data) \Downarrow v,\ \text{BytesViewString}(SB, data) \Downarrow v,\ \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB'),\ \text{BytesLength}(SB, self) \Downarrow n,\ \text{BytesIsEmpty}(SB, self) \Downarrow b\}$$


**(StringFrom-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, source)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringFrom}(SB, source, heap) \Downarrow (r, SB')}$$

**(StringFrom-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringFrom}(SB, source, heap) \Downarrow (r, SB')}$$

**(StringAsView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, self)}{\Gamma \vdash \text{StringAsView}(SB, self) \Downarrow v}$$

**(StringToManaged-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, self)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringToManaged-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringCloneWith-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, self)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringCloneWith-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringAppend-Ok)**
$$\frac{r = \texttt{()} \quad \text{StrBuf}' = \text{StrBuf}[self \mapsto \text{ByteSeqOf}(SB, self) \mathbin{+\!\!+} \text{ByteSeqOf}(SB, data)] \quad SB' = \langle \text{StrBuf}',\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(StringAppend-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(StringLength)**
$$\frac{n = \text{ByteLen}(SB, self)}{\Gamma \vdash \text{StringLength}(SB, self) \Downarrow n}$$

**(StringIsEmpty)**
$$\frac{b = (\text{ByteLen}(SB, self) = 0)}{\Gamma \vdash \text{StringIsEmpty}(SB, self) \Downarrow b}$$

**(BytesWithCapacity-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto []] \quad \text{BytesCap}' = \text{BytesCap}[v \mapsto cap'] \quad cap' \ge cap \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap}' \rangle}{\Gamma \vdash \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB')}$$

**(BytesWithCapacity-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB')}$$

**(BytesFromSlice-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto \text{SliceBytes}(data)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB')}$$

**(BytesFromSlice-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB')}$$

**(BytesAsView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, self)}{\Gamma \vdash \text{BytesAsView}(SB, self) \Downarrow v}$$

**(BytesToManaged-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto \text{ByteSeqOf}(SB, self)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(BytesToManaged-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(BytesView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{SliceBytes}(data)}{\Gamma \vdash \text{BytesView}(SB, data) \Downarrow v}$$

**(BytesViewString-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, data)}{\Gamma \vdash \text{BytesViewString}(SB, data) \Downarrow v}$$

**(BytesAppend-Ok)**
$$\frac{r = \texttt{()} \quad \text{BytesBuf}' = \text{BytesBuf}[self \mapsto \text{ByteSeqOf}(SB, self) \mathbin{+\!\!+} \text{ByteSeqOf}(SB, data)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(BytesAppend-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(BytesLength)**
$$\frac{n = \text{ByteLen}(SB, self)}{\Gamma \vdash \text{BytesLength}(SB, self) \Downarrow n}$$

**(BytesIsEmpty)**
$$\frac{b = (\text{ByteLen}(SB, self) = 0)}{\Gamma \vdash \text{BytesIsEmpty}(SB, self) \Downarrow b}$$

### 5.9. Capabilities and Context (Cursive0)


#### 5.9.1. Capability Access

$$\text{CapClass} = \{\texttt{FileSystem},\ \texttt{HeapAllocator}\}$$
$$\text{CapType}(Cl) = \text{TypeDynamic}(Cl)$$

$$\text{CapMethodSig}(\texttt{FileSystem}, name) = \langle params, ret \rangle \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}$$
$$\text{CapMethodSig}(\texttt{HeapAllocator}, name) = \langle params, ret \rangle \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}$$
$$\text{CapRecv}(\texttt{FileSystem}, name) = recv \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}$$
$$\text{CapRecv}(\texttt{HeapAllocator}, name) = recv \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}$$


#### 5.9.2. `FileSystem` Capability Class

$$\text{BuiltinTypes}_{FS} = \{\texttt{File},\ \texttt{DirIter},\ \texttt{DirEntry},\ \texttt{FileKind},\ \texttt{IoError}\}$$

$$\text{FileSystemInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"open\_read"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Read}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_write"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Write}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_append"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Append}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"create\_write"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Write}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"read\_file"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"read\_bytes"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_file"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_stdout"},\ \texttt{~},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_stderr"},\ \texttt{~},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"exists"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle,\\
&\langle \texttt{"remove"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"DirIter"}], \texttt{@Open}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"create\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"ensure\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"kind"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePath}([\texttt{"FileKind"}]),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"restrict"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeDynamic}(\texttt{FileSystem}) \rangle
\end{aligned}
\right\}$$

$$\text{Variants}(\texttt{FileKind}) = [\texttt{File},\ \texttt{Dir},\ \texttt{Other}]$$

$$\text{Implements}(\texttt{FileKind}) = [\texttt{Bitcopy}]$$

$$\text{Fields}(\texttt{DirEntry}) = [\langle \texttt{name},\ \text{TypeString}(\texttt{@Managed}) \rangle,\ \langle \texttt{path},\ \text{TypeString}(\texttt{@Managed}) \rangle,\ \langle \texttt{kind},\ \text{TypePath}([\texttt{"FileKind"}]) \rangle]$$

**DirIter Modal Type.**

$$\text{States}(\texttt{DirIter}) = \{\texttt{@Open}, \texttt{@Closed}\}$$

$$\text{Payload}(\texttt{DirIter}, \texttt{@Open}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{DirIter}, \texttt{@Closed}) = []$$

$$\text{DirIterStateMembers} =
\left\{
\begin{aligned}
&\langle \texttt{@Open},\ \texttt{"next"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePath}([\texttt{"DirEntry"}]),\ \text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Open},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"DirIter"}], \texttt{@Closed}) \rangle
\end{aligned}
\right\}$$

**File Modal Type.**

$$\text{States}(\texttt{File}) = \{\texttt{@Read}, \texttt{@Write}, \texttt{@Append}, \texttt{@Closed}\}$$

$$\text{Payload}(\texttt{File}, \texttt{@Read}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Write}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Append}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Closed}) = []$$

$$\text{FileStateMembers} =
\left\{
\begin{aligned}
&\langle \texttt{@Read},\ \texttt{"read\_all"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Read},\ \texttt{"read\_all\_bytes"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Read},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"write"},\ \texttt{method},\ [\langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"flush"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"write"},\ \texttt{method},\ [\langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"flush"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle
\end{aligned}
\right\}$$

$$\text{Variants}(\texttt{IoError}) = [\texttt{NotFound},\ \texttt{PermissionDenied},\ \texttt{AlreadyExists},\ \texttt{InvalidPath},\ \texttt{Busy},\ \texttt{IoFailure}]$$

$$\text{Implements}(\texttt{IoError}) = [\texttt{Bitcopy}]$$

**(Record-FileDir-Err)**
$$\frac{\text{path} \in \{[\texttt{"File"}], [\texttt{"DirIter"}]\} \quad c = \text{Code}(\text{Record-FileDir-Err})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{ModalStateRef}(path, S), fields) \Uparrow c}$$

#### 5.9.3. `HeapAllocator` Capability Class

$$\text{HeapAllocatorInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"with\_quota"},\ \texttt{~!},\ [\langle \bot,\ \texttt{size},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle,\\
&\langle \texttt{"alloc\_raw"},\ \texttt{~},\ [\langle \bot,\ \texttt{count},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypeRawPtr}(\texttt{mut}, \text{TypePrim}(\texttt{"u8"})) \rangle,\\
&\langle \texttt{"dealloc\_raw"},\ \texttt{~},\ [\langle \bot,\ \texttt{ptr},\ \text{TypeRawPtr}(\texttt{mut}, \text{TypePrim}(\texttt{"u8"})) \rangle,\ \langle \bot,\ \texttt{count},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle
\end{aligned}
\right\}$$

**(AllocRaw-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(\texttt{HeapAllocator}) \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, \texttt{"alloc\_raw"}, args))) \quad c = \text{Code}(\text{AllocRaw-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, \texttt{"alloc\_raw"}, args) \Uparrow c}$$

**(DeallocRaw-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(\texttt{HeapAllocator}) \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, \texttt{"dealloc\_raw"}, args))) \quad c = \text{Code}(\text{DeallocRaw-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, \texttt{"dealloc\_raw"}, args) \Uparrow c}$$

$$\text{Variants}(\texttt{AllocationError}) = [\texttt{OutOfMemory},\ \texttt{QuotaExceeded}]$$
$$\text{VariantPayload}(\texttt{AllocationError}, \texttt{OutOfMemory}) = \text{TuplePayload}([\text{TypePrim}(\texttt{"usize"})])$$
$$\text{VariantPayload}(\texttt{AllocationError}, \texttt{QuotaExceeded}) = \text{TuplePayload}([\text{TypePrim}(\texttt{"usize"})])$$
$$\text{AllocErrorVal}(r) \iff \exists s.\ r = \text{EnumValue}([\texttt{"AllocationError"},\ \texttt{"OutOfMemory"}], \text{TuplePayload}([s]))\ \lor\ r = \text{EnumValue}([\texttt{"AllocationError"},\ \texttt{"QuotaExceeded"}], \text{TuplePayload}([s]))$$

#### 5.9.4. `Context` Record (Cursive0)

$$\text{BuiltinRecord} \supseteq \{\texttt{Context},\ \texttt{System}\}$$

$$\text{Fields}(\texttt{Context}) = [\langle \texttt{fs},\ \text{TypeDynamic}(\texttt{FileSystem}) \rangle,\ \langle \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle,\ \langle \texttt{sys},\ \text{TypePath}([\texttt{"System"}]) \rangle]$$

$$\text{Implements}(\texttt{Context}) = [\texttt{Bitcopy}]$$
$$\text{Implements}(\texttt{System}) = [\texttt{Bitcopy}]$$

$$\text{SystemInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"exit"},\ [\langle \bot,\ \texttt{code},\ \text{TypePrim}(\texttt{"i32"}) \rangle],\ \text{TypePrim}(\texttt{"!"}) \rangle,\\
&\langle \texttt{"get\_env"},\ [\langle \bot,\ \texttt{key},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\bot),\ \text{TypePrim}(\texttt{"()"})]) \rangle
\end{aligned}
\right\}$$
$$\text{SystemMethodSig}(name) = \langle params, ret \rangle \iff \langle name,\ params,\ ret \rangle \in \text{SystemInterface}$$
### 5.10. Enum Discriminant Defaults

$$\text{Variants}(E) = E.\text{variants}$$
$$\text{disc\_opt}(v) = v.\text{discriminant\_opt}$$

$$\text{DiscValue}(tok) = \text{IntValue}(tok)$$

$$\text{DiscOf}(v,n) = \begin{cases}
n & \text{if } \text{disc\_opt}(v)=\bot \\
\text{DiscValue}(tok) & \text{if } \text{disc\_opt}(v)=tok
\end{cases}$$
$$\text{DiscSeq}([], n) = []$$
$$\text{DiscSeq}(v::vs, n) = [\text{DiscOf}(v,n)] \mathbin{+\!\!+} \text{DiscSeq}(vs, \text{DiscOf}(v,n)+1)$$

$$\text{EnumDiscriminants}(E) \Downarrow ds \iff ds = \text{DiscSeq}(\text{Variants}(E), 0) \land \text{Distinct}(ds) \land \forall d \in ds.\ d \ge 0$$

**(Enum-Disc-NotInt)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad tok.\text{kind} \ne \text{IntLiteral} \quad c = \text{Code}(\text{Enum-Disc-NotInt})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Invalid)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad \text{DiscValue}(tok)\ \text{undefined} \quad c = \text{Code}(\text{Enum-Disc-Invalid})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Negative)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad \text{DiscValue}(tok) = d \quad d < 0 \quad c = \text{Code}(\text{Enum-Disc-Negative})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Dup)**
$$\frac{ds = \text{DiscSeq}(\text{Variants}(E), 0) \quad \neg \text{Distinct}(ds) \quad c = \text{Code}(\text{Enum-Disc-Dup})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

$$\text{MaxDisc}(E) = \max(ds) \iff \text{EnumDiscriminants}(E) \Downarrow ds$$

$$\text{DiscType}(E) = \begin{cases}
\texttt{u8} & 0 \le \text{MaxDisc}(E) \le 255 \\
\texttt{u16} & 256 \le \text{MaxDisc}(E) \le 65{,}535 \\
\texttt{u32} & 65{,}536 \le \text{MaxDisc}(E) \le 4{,}294{,}967{,}295 \\
\texttt{u64} & \text{otherwise}
\end{cases}$$


### 5.11. Foundational Classes (Cursive0)

**Class Signatures (built-in).**

```cursive
class Drop {
    procedure drop(~!)
}

class Bitcopy { }

class Clone {
    procedure clone(~) -> Self
}
```

$$\text{BitcopyDropJudg} = \{\Gamma \vdash T : \text{BitcopyDropOk}\}$$

$$\text{ImplementsBitcopy}(T) \iff \texttt{Bitcopy} \in \text{Implements}(T)$$
$$\text{ImplementsDrop}(T) \iff \texttt{Drop} \in \text{Implements}(T)$$
$$\text{ImplementsClone}(T) \iff \texttt{Clone} \in \text{Implements}(T)$$

**(BitcopyDrop-Ok)**
$$\frac{\neg(\text{ImplementsBitcopy}(T) \land \text{ImplementsDrop}(T)) \quad (\text{ImplementsBitcopy}(T) \Rightarrow \text{ImplementsClone}(T)) \quad (\text{ImplementsBitcopy}(T) \Rightarrow \forall f : T_f \in \text{Fields}(T).\ \text{BitcopyType}(T_f))}{\Gamma \vdash T : \text{BitcopyDropOk}}$$

**(BitcopyDrop-Conflict)**
$$\frac{\text{ImplementsBitcopy}(T) \land \text{ImplementsDrop}(T) \quad c = \text{Code}(\text{BitcopyDrop-Conflict})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

**(Bitcopy-Clone-Missing)**
$$\frac{\text{ImplementsBitcopy}(T) \quad \neg \text{ImplementsClone}(T) \quad c = \text{Code}(\text{Bitcopy-Clone-Missing})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

**(Bitcopy-Field-NonBitcopy)**
$$\frac{\text{ImplementsBitcopy}(T) \quad \exists f : T_f \in \text{Fields}(T).\ \neg \text{BitcopyType}(T_f) \quad c = \text{Code}(\text{Bitcopy-Field-NonBitcopy})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

$$\text{BitcopyTypeCore}(T) \iff
\begin{cases}
\text{false} & T = \text{TypePerm}(\texttt{unique}, \_) \\
\text{BuiltinBitcopyType}(T_0) \lor \Gamma \vdash T_0 <: \texttt{Bitcopy} & T = \text{TypePerm}(p, T_0) \land p \ne \texttt{unique} \\
\text{BuiltinBitcopyType}(T) \lor \Gamma \vdash T <: \texttt{Bitcopy} & \text{otherwise}
\end{cases}$$

$$\text{BuiltinBitcopyType}(T) \iff
\begin{aligned}
&T = \text{TypePrim}(t) \land t \in \text{PrimTypes}_{C0}\ \lor \\
&T = \text{TypePtr}(U, s)\ \lor \\
&T = \text{TypeRawPtr}(q, U)\ \lor \\
&T = \text{TypeSlice}(U)\ \lor \\
&T = \text{TypeFunc}(ps, R)\ \lor \\
&T = \text{TypeDynamic}(Cl)\ \lor \\
&T = \text{TypeRange}\ \lor \\
&T = \text{TypeString}(\texttt{@View})\ \lor \\
&T = \text{TypeBytes}(\texttt{@View})
\end{aligned}$$

$$\text{BuiltinDropType}(T) \iff T = \text{TypeString}(\texttt{@Managed}) \lor T = \text{TypeBytes}(\texttt{@Managed})$$

$$\text{BuiltinCloneType}(T) \iff \text{BuiltinBitcopyType}(T)$$

### 5.12. Initialization Planning

**Module Prefix Resolution.**
$$P = \text{Project}(\Gamma)$$
$$m = \text{CurrentModule}(\Gamma)$$
$$\text{Modules} = P.\text{modules}$$
$$\text{PathPrefix}(path, pref) \iff \exists rest.\ path = pref \mathbin{+\!\!+} rest$$

**Alias Expansion.**

**(AliasExpand-None)**
$$\frac{path = a::rest \quad a \notin \text{dom}(\text{AliasMap}(m))}{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path}$$

**(AliasExpand-Yes)**
$$\frac{path = a::rest \quad a \in \text{dom}(\text{AliasMap}(m)) \quad \text{AliasMap}(m)[a] = p_a}{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow p_a \mathbin{+\!\!+} rest}$$

**(ModulePrefix-Direct)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path' \quad \exists p \in Modules,\ \text{PathPrefix}(path',p) \quad p = \arg\max_{q \in Modules,\ \text{PathPrefix}(path',q)} |q|}{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{AliasMap}(m)) \Downarrow p}$$

**(ModulePrefix-None)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path' \quad \neg \exists p \in Modules.\ \text{PathPrefix}(path',p)}{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{AliasMap}(m)) \uparrow}$$

$$env = \langle \text{self},\ \text{Modules},\ \text{AliasMap}(m),\ \text{UsingValueMap},\ \text{UsingTypeMap} \rangle$$

**(Reachable-Edge)**
$$\frac{(u,v) \in E}{\Gamma \vdash \text{Reachable}(u,v,E)}$$

**(Reachable-Step)**
$$\frac{(u,w) \in E \quad \Gamma \vdash \text{Reachable}(w,v,E)}{\Gamma \vdash \text{Reachable}(u,v,E)}$$

**Type References.**
$$\text{FullPath}(path, name) = path \mathbin{+\!\!+} [name]$$
$$\text{EnumPath}(path) = p \iff \text{SplitLast}(path) = (p, n)$$
$$\text{VariantName}(path) = n \iff \text{SplitLast}(path) = (p, n)$$

$$\text{TypeRefsJudg} = \{\text{TypeRefsTy},\ \text{TypeRefsRef},\ \text{TypeRefsExpr},\ \text{TypeRefsPat}\}$$
$$\text{Modules} = env.\text{Modules}$$
$$\text{Alias} = env.\text{Alias}$$
$$\text{UsingTypeMap} = env.\text{UsingTypeMap}$$

**(TypeRef-Path)**
$$\frac{|path| \ge 2 \quad \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self}}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \{mp\}}$$

**(TypeRef-Using)**
$$\frac{path = [name] \quad name \in \text{dom}(\text{UsingTypeMap}) \quad \text{UsingTypeMap}[name] \ne env.\text{self}}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \{\text{UsingTypeMap}[name]\}}$$

**(TypeRef-Path-Local)**
$$\frac{(|path| \ne 1 \ \lor\ (path = [name] \land name \notin \text{dom}(\text{UsingTypeMap}))) \quad (\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self})}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \emptyset}$$

**(TypeRef-Dynamic)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeDynamic}(path), env) \Downarrow T}$$

**(TypeRef-ModalState)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeModalState}(path, state), env) \Downarrow T}$$

**(TypeRef-Perm)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(base, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePerm}(perm, base), env) \Downarrow T}$$

**(TypeRef-Prim)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePrim}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeTuple}([t_1,\ldots,t_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-Array)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsExpr}(size\_expr, env) \Downarrow T_s}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeArray}(elem, size\_expr), env) \Downarrow T_e \cup T_s}$$

**(TypeRef-Slice)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeSlice}(elem), env) \Downarrow T}$$

**(TypeRef-Union)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeUnion}([t_1,\ldots,t_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-Func)**
$$\frac{\forall i,\ \text{params}_i = \langle m_i, t_i \rangle \quad \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i \quad \Gamma \vdash \text{TypeRefsTy}(ret, env) \Downarrow T_r}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeFunc}([\text{params}_1,\ldots,\text{params}_n], ret), env) \Downarrow (\bigcup_{i=1}^n T_i) \cup T_r}$$

**(TypeRef-String)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeString}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Bytes)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeBytes}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Ptr)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePtr}(elem, \_), env) \Downarrow T}$$

**(TypeRef-RawPtr)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeRawPtr}(\_, elem), env) \Downarrow T}$$

**(TypeRef-Range)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeRange}, env) \Downarrow \emptyset}$$

**(TypeRef-Ref-Path)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsRef}(\text{TypePath}(path), env) \Downarrow T}$$

**(TypeRef-Ref-ModalState)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypeModalState}(path, state), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsRef}(\text{ModalStateRef}(path, state), env) \Downarrow T}$$

**(TypeRef-RecordExpr)**
$$\frac{\Gamma \vdash \text{TypeRefsRef}(r, env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T_e}{\Gamma \vdash \text{TypeRefsExpr}(\text{RecordExpr}(r, fields), env) \Downarrow T_t \cup T_e}$$

**(TypeRef-EnumLiteral)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(\text{EnumPath}(path)), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsEnumPayload}(payload\_opt, env) \Downarrow T_p}{\Gamma \vdash \text{TypeRefsExpr}(\text{EnumLiteral}(path, payload\_opt), env) \Downarrow T_t \cup T_p}$$

**(TypeRef-QualBrace)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(\text{FullPath}(path, name)), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsExpr}(\text{QualifiedApply}(path, name, \text{Brace}(fields)), env) \Downarrow T_t \cup T_f}$$

**(TypeRef-Cast)**
$$\frac{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsTy}(ty, env) \Downarrow T_t}{\Gamma \vdash \text{TypeRefsExpr}(\text{Cast}(e, ty), env) \Downarrow T_e \cup T_t}$$

**(TypeRef-Transmute)**
$$\frac{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsTy}(t_1, env) \Downarrow T_1 \quad \Gamma \vdash \text{TypeRefsTy}(t_2, env) \Downarrow T_2}{\Gamma \vdash \text{TypeRefsExpr}(\text{TransmuteExpr}(t_1, t_2, e), env) \Downarrow T_e \cup T_1 \cup T_2}$$

$$\text{TypeRefsExprRules} = \{\text{TypeRef-RecordExpr},\ \text{TypeRef-EnumLiteral},\ \text{TypeRef-QualBrace},\ \text{TypeRef-Cast},\ \text{TypeRef-Transmute},\ \text{TypeRef-Expr-Sub}\}$$
$$\text{NoSpecificTypeRefsExpr}(e) \iff \neg \exists r \in \text{TypeRefsExprRules} \setminus \{\text{TypeRef-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(TypeRef-Expr-Sub)**
$$\frac{\text{NoSpecificTypeRefsExpr}(e) \quad \text{Children\_LTR}(e) = [e_1,\ldots,e_n] \quad \forall i,\ \Gamma \vdash \text{TypeRefsExpr}(e_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-RecordPattern)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(tp), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsPat}(\text{RecordPattern}(tp, fields), env) \Downarrow T_t \cup T_f}$$

**(TypeRef-EnumPattern)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(tp), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsPayload}(payload, env) \Downarrow T_p}{\Gamma \vdash \text{TypeRefsPat}(\text{EnumPattern}(tp, \_, payload), env) \Downarrow T_t \cup T_p}$$

**(TypeRef-LiteralPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{LiteralPattern}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-WildcardPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{WildcardPattern}, env) \Downarrow \emptyset}$$

**(TypeRef-IdentifierPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{IdentifierPattern}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-TypedPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{TypedPattern}(\_, \_), env) \Downarrow \emptyset}$$

**(TypeRef-TuplePattern)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsPat}(p_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsPat}(\text{TuplePattern}([p_1,\ldots,p_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-ModalPattern-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{ModalPattern}(\_, \bot), env) \Downarrow \emptyset}$$

**(TypeRef-ModalPattern-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPat}(\text{ModalPattern}(\_, \text{ModalRecordPayload}(fields)), env) \Downarrow T}$$

**(TypeRef-RangePattern)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(p_l, env) \Downarrow T_l \quad \Gamma \vdash \text{TypeRefsPat}(p_h, env) \Downarrow T_h}{\Gamma \vdash \text{TypeRefsPat}(\text{RangePattern}(\_, p_l, p_h), env) \Downarrow T_l \cup T_h}$$

**(TypeRef-Field-Explicit)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(p, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPat}(\langle \text{name},\ \text{pattern\_opt}=p,\ \text{span} \rangle, env) \Downarrow T}$$

**(TypeRef-Field-Implicit)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\langle \text{name},\ \text{pattern\_opt}=\bot,\ \text{span} \rangle, env) \Downarrow \emptyset}$$

**(TypeRefsExprs-Empty)**
$$\frac{}{\Gamma \vdash \text{TypeRefsExprs}([], env) \Downarrow \emptyset}$$

**(TypeRefsExprs-Cons)**
$$\frac{f = \langle \text{name}, e \rangle \quad \Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsExprs}(fs, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsExprs}(f::fs, env) \Downarrow T_e \cup T_f}$$

**(TypeRefsEnumPayload-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsEnumPayload}(\bot, env) \Downarrow \emptyset}$$

**(TypeRefsEnumPayload-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsExpr}(e_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsEnumPayload}(\text{Paren}([e_1,\ldots,e_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRefsEnumPayload-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsEnumPayload}(\text{Brace}(fields), env) \Downarrow T}$$

**(TypeRefsFields-Empty)**
$$\frac{}{\Gamma \vdash \text{TypeRefsFields}([], env) \Downarrow \emptyset}$$

**(TypeRefsFields-Cons)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(f, env) \Downarrow T_f \quad \Gamma \vdash \text{TypeRefsFields}(fs, env) \Downarrow T_s}{\Gamma \vdash \text{TypeRefsFields}(f::fs, env) \Downarrow T_f \cup T_s}$$

**(TypeRefsPayload-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPayload}(\bot, env) \Downarrow \emptyset}$$

**(TypeRefsPayload-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsPat}(p_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsPayload}(\text{TuplePayloadPattern}([p_1,\ldots,p_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRefsPayload-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPayload}(\text{RecordPayloadPattern}(fields), env) \Downarrow T}$$

**Value References.**

$$\text{UsingValueMap} = env.\text{UsingValueMap}$$
$$\text{ValueRefsJudg} = \{\text{ValueRefs},\ \text{ValueRefsArgs},\ \text{ValueRefsFields}\}$$

**(ValueRef-Ident)**
$$\frac{name \in \text{dom}(\text{UsingValueMap}) \quad \text{UsingValueMap}[name] \ne env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{Identifier}(name), env) \Downarrow \{\text{UsingValueMap}[name]\}}$$

**(ValueRef-Ident-Local)**
$$\frac{name \notin \text{dom}(\text{UsingValueMap})}{\Gamma \vdash \text{ValueRefs}(\text{Identifier}(name), env) \Downarrow \emptyset}$$

**(ValueRef-Qual)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedName}(path, \_), env) \Downarrow \{mp\}}$$

**(ValueRef-Qual-Local)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedName}(path, \_), env) \Downarrow \emptyset}$$

**(ValueRef-QualApply)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self} \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Paren}(args)), env) \Downarrow \{mp\} \cup V_a}$$

**(ValueRef-QualApply-Local)**
$$\frac{(\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self}) \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Paren}(args)), env) \Downarrow V_a}$$

**(ValueRef-QualApply-Brace)**
$$\frac{\Gamma \vdash \text{ValueRefsFields}(fields, env) \Downarrow V_f}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Brace}(fields)), env) \Downarrow V_f}$$

$$\text{ValueRefsRules} = \{\text{ValueRef-Ident},\ \text{ValueRef-Ident-Local},\ \text{ValueRef-Qual},\ \text{ValueRef-Qual-Local},\ \text{ValueRef-QualApply},\ \text{ValueRef-QualApply-Local},\ \text{ValueRef-QualApply-Brace},\ \text{ValueRef-Expr-Sub}\}$$
$$\text{NoSpecificValueRefsExpr}(e) \iff \neg \exists r \in \text{ValueRefsRules} \setminus \{\text{ValueRef-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(ValueRef-Expr-Sub)**
$$\frac{\text{NoSpecificValueRefsExpr}(e) \quad \text{Children\_LTR}(e) = [e_1,\ldots,e_n] \quad \forall i,\ \Gamma \vdash \text{ValueRefs}(e_i, env) \Downarrow V_i}{\Gamma \vdash \text{ValueRefs}(e, env) \Downarrow \bigcup_{i=1}^n V_i}$$

**(ValueRefsArgs-Empty)**
$$\frac{}{\Gamma \vdash \text{ValueRefsArgs}([], env) \Downarrow \emptyset}$$

**(ValueRefsArgs-Cons)**
$$\frac{a = \langle \text{moved}, e, \text{span} \rangle \quad \Gamma \vdash \text{ValueRefs}(e, env) \Downarrow V_e \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefsArgs}(a::args, env) \Downarrow V_e \cup V_a}$$

**(ValueRefsFields-Empty)**
$$\frac{}{\Gamma \vdash \text{ValueRefsFields}([], env) \Downarrow \emptyset}$$

**(ValueRefsFields-Cons)**
$$\frac{f = \langle \text{name}, e \rangle \quad \Gamma \vdash \text{ValueRefs}(e, env) \Downarrow V_e \quad \Gamma \vdash \text{ValueRefsFields}(fs, env) \Downarrow V_f}{\Gamma \vdash \text{ValueRefsFields}(f::fs, env) \Downarrow V_e \cup V_f}$$

**Dependency Sets.**

$$env_m = \langle \text{self}=m,\ \text{Modules}=P.\text{modules},\ \text{Alias}_m,\ \text{UsingValueMap}_m,\ \text{UsingTypeMap}_m \rangle$$
$$\text{Alias}_m = \text{AliasMap}(m)$$
$$\text{UsingValueMap}_m = \text{UsingValueMap}(m)$$
$$\text{UsingTypeMap}_m = \text{UsingTypeMap}(m)$$
$$\text{ASTModule}(P, m) = \text{ModuleMap}(P, m)$$

$$\text{TypeOptSet}(\bot) = \emptyset$$
$$\text{TypeOptSet}(T) = \{T\}$$
$$\text{ParamTypeSet}(params) = \{ t \mid \exists mode,name.\ \langle mode,name,t \rangle \in params \}$$
$$\text{RecvTypeSet}(\text{ReceiverExplicit}(\_, t)) = \{t\}$$
$$\text{RecvTypeSet}(\text{ReceiverShorthand}(\_)) = \emptyset$$
$$\text{ClassPathTypeSet}(paths) = \{ \text{TypePath}(p) \mid p \in paths \}$$

$$\text{RecordFieldTypeSet}(members) = \{ t \mid \exists vis,name,init,span,doc.\ \text{FieldDecl}(vis,name,t,init,span,doc) \in members \}$$
$$\text{RecordMethodRecvTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{RecvTypeSet}(recv) \}$$
$$\text{RecordMethodParamTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{ParamTypeSet}(params) \}$$
$$\text{RecordMethodRetTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{TypeOptSet}(ret) \}$$
$$\text{RecordMemberTypeSet}(members) = \text{RecordFieldTypeSet}(members) \cup \text{RecordMethodRecvTypes}(members) \cup \text{RecordMethodParamTypes}(members) \cup \text{RecordMethodRetTypes}(members)$$

$$\text{ClassFieldTypeSet}(items) = \{ t \mid \exists vis,name,span,doc.\ \text{ClassFieldDecl}(vis,name,t,span,doc) \in items \}$$
$$\text{ClassMethodRecvTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{RecvTypeSet}(recv) \}$$
$$\text{ClassMethodParamTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{ParamTypeSet}(params) \}$$
$$\text{ClassMethodRetTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{TypeOptSet}(ret) \}$$
$$\text{ClassItemTypeSet}(items) = \text{ClassFieldTypeSet}(items) \cup \text{ClassMethodRecvTypes}(items) \cup \text{ClassMethodParamTypes}(items) \cup \text{ClassMethodRetTypes}(items)$$

$$\text{VariantPayloadTypeSet}(\bot) = \emptyset$$
$$\text{VariantPayloadTypeSet}(\text{TuplePayload}(tys)) = \{ t \mid t \in tys \}$$
$$\text{VariantPayloadTypeSet}(\text{RecordPayload}(fields)) = \{ t \mid \exists vis,name,init,span,doc.\ \text{FieldDecl}(vis,name,t,init,span,doc) \in fields \}$$
$$\text{EnumVariantTypeSet}(variants) = \{ t \mid \exists name,payload,disc,span,doc.\ \text{VariantDecl}(name,payload,disc,span,doc) \in variants \land t \in \text{VariantPayloadTypeSet}(payload) \}$$

$$\text{TypePos}_\text{Static}(P, m) = \{ t \mid \exists vis,mut,bind,span,doc.\ \langle \text{StaticDecl}, vis, mut, bind, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land bind.\text{type\_opt} = t \land t \ne \bot \}$$
$$\text{TypePos}_\text{Proc}(P, m) = \{ t \mid \exists vis,name,params,ret,body,span,doc.\ \langle \text{ProcedureDecl}, vis, name, params, ret, body, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ParamTypeSet}(params) \cup \text{TypeOptSet}(ret)) \}$$
$$\text{TypePos}_\text{Record}(P, m) = \{ t \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(impls) \cup \text{RecordMemberTypeSet}(members)) \}$$
$$\text{TypePos}_\text{Enum}(P, m) = \{ t \mid \exists vis,name,impls,variants,span,doc.\ \langle \text{EnumDecl}, vis, name, impls, variants, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(impls) \cup \text{EnumVariantTypeSet}(variants)) \}$$
$$\text{TypePos}_\text{Modal}(P, m) = \{ t \mid \exists vis,name,impls,states,span,doc.\ \langle \text{ModalDecl}, vis, name, impls, states, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in \text{ClassPathTypeSet}(impls) \}$$
$$\text{TypePos}_\text{Class}(P, m) = \{ t \mid \exists vis,name,supers,items,span,doc.\ \langle \text{ClassDecl}, vis, name, supers, items, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(supers) \cup \text{ClassItemTypeSet}(items)) \}$$
$$\text{TypePos}_\text{Alias}(P, m) = \{ t \mid \exists vis,name,ty,span,doc.\ \langle \text{TypeAliasDecl}, vis, name, ty, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t = ty \}$$
$$\text{TypePositions}(P, m) = \text{TypePos}_\text{Static}(P, m) \cup \text{TypePos}_\text{Proc}(P, m) \cup \text{TypePos}_\text{Record}(P, m) \cup \text{TypePos}_\text{Enum}(P, m) \cup \text{TypePos}_\text{Modal}(P, m) \cup \text{TypePos}_\text{Class}(P, m) \cup \text{TypePos}_\text{Alias}(P, m)$$

$$\text{ArraySizeExprs}(P, m) = \{ e \mid \exists elem.\ \text{TypeArray}(elem, e) \in \text{TypePositions}(P, m) \}$$
$$\text{EnumDiscriminantExprs}(P, m) = \{ e \mid \exists vis,name,impls,variants,span,doc.\ \langle \text{EnumDecl}, vis, name, impls, variants, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists v.\ v = \text{VariantDecl}(\_,\_,e,\_,\_) \in variants \land e \ne \bot \}$$
$$\text{TypePosExprs}(P, m) = \text{ArraySizeExprs}(P, m) \cup \text{EnumDiscriminantExprs}(P, m)$$

$$\text{Elems}(v) =
\begin{cases}
\{v\} & v \in \text{ASTNode} \\
\{x \mid x \in v \land x \in \text{ASTNode}\} & v \in [\_] \\
\emptyset & v = \bot \\
\emptyset & \text{otherwise}
\end{cases}$$
$$\text{Child}(x,y) \iff \exists C,\ a_1,\ldots,a_k.\ x = C(a_1,\ldots,a_k) \land y \in \bigcup_{i=1}^k \text{Elems}(a_i)$$
$$E_{\text{child}} = \{ (x,y) \mid \text{Child}(x,y) \}$$
$$\text{Subnode}(x,y) \iff x = y \lor \Gamma \vdash \text{Reachable}(x,y,E_{\text{child}})$$
$$\text{ExprNodes}(P, m) = \{ e \mid e \in \text{Expr} \land \text{Subnode}(\text{ASTModule}(P, m), e) \}$$
$$\text{PatNodes}(P, m) = \{ p \mid p \in \text{Pattern} \land \text{Subnode}(\text{ASTModule}(P, m), p) \}$$
$$\text{ExprNodesOf}(x) = \{ e \mid e \in \text{Expr} \land \text{Subnode}(x, e) \}$$

$$\text{TypeDeps}(P, m) = \{ n \mid \exists t \in \text{TypePositions}(P, m).\ \Gamma \vdash \text{TypeRefsTy}(t, env_m) \Downarrow T \land n \in T \} \cup \{ n \mid \exists p \in \text{PatNodes}(P, m).\ \Gamma \vdash \text{TypeRefsPat}(p, env_m) \Downarrow T \land n \in T \} \cup \{ n \mid \exists e \in (\text{ExprNodes}(P, m) \cup \text{TypePosExprs}(P, m)).\ \Gamma \vdash \text{TypeRefsExpr}(e, env_m) \Downarrow T \land n \in T \}$$

$$\text{StaticInitExprs}(P, m) = \{ init \mid \exists vis,mut,bind,span,doc.\ \langle \text{StaticDecl}, vis, mut, bind, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land bind.\text{init} = init \}$$
$$\text{RecordFieldInitExprs}(P, m) = \{ init \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists f.\ f = \text{FieldDecl}(\_,\_,\_,init,\_,\_) \in members \land init \ne \bot \}$$
$$\text{ProcBodies}(P, m) = \{ body \mid \exists vis,name,params,ret,body,span,doc.\ \langle \text{ProcedureDecl}, vis, name, params, ret, body, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \}$$
$$\text{RecordMethodBodies}(P, m) = \{ body \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists md.\ md = \text{MethodDecl}(\_,\_,\_,\_,\_,\_,body,\_,\_) \in members \}$$
$$\text{ClassMethodBodies}(P, m) = \{ body \mid \exists vis,name,supers,items,span,doc.\ \langle \text{ClassDecl}, vis, name, supers, items, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists md.\ md = \text{ClassMethodDecl}(\_,\_,\_,\_,\_,body,\_,\_) \in items \land body \ne \bot \}$$

$$\text{ValueDepsEager}(P, m) = \{ n \mid \exists e \in \text{StaticInitExprs}(P, m).\ \Gamma \vdash \text{ValueRefs}(e, env_m) \Downarrow V \land n \in V \}$$
$$\text{ValueDepsLazy}(P, m) = \{ n \mid \exists e \in \text{RecordFieldInitExprs}(P, m) \cup \bigcup_{b \in (\text{ProcBodies}(P, m) \cup \text{RecordMethodBodies}(P, m) \cup \text{ClassMethodBodies}(P, m))} \text{ExprNodesOf}(b).\ \Gamma \vdash \text{ValueRefs}(e, env_m) \Downarrow V \land n \in V \}$$

**Dependency Graph.**

$$V = \text{Modules}$$

$$E_{type} = \{(m, n) \mid n \in \text{TypeDeps}(P, m)\}$$
$$E_{val}^{eager} = \{(m, n) \mid n \in \text{ValueDepsEager}(P, m)\}$$
$$E_{val}^{lazy} = \{(m, n) \mid n \in \text{ValueDepsLazy}(P, m)\}$$

$$G = \langle V,\ E_{type},\ E_{val}^{eager},\ E_{val}^{lazy} \rangle$$
$$G_e = \langle V,\ E_{val}^{eager} \rangle$$

**(WF-Acyclic-Eager)**
$$\frac{\forall v \in V,\ \neg \text{Reachable}(v, v, E_{val}^{eager})}{\Gamma \vdash G_e : \text{DAG}}$$

## 6. Phase 4: Code Generation

### 6.0. Codegen Model and Judgments

$$\text{ArtifactsOf}(P) = \text{Set}(Objs) \cup \text{Set}(IRs) \cup \{Exe\} \iff \Gamma \vdash \text{OutputPipeline}(P) \Downarrow (Objs, IRs, Exe)$$
$$\text{IRTarget} = \texttt{"LLVM-21.1.8"}$$
$$\text{ObjTarget} = \texttt{"COFF"}$$
$$\text{LLVMValid}_{21.1.8}(L) \iff L \in \text{LLVMIR}_{21.1.8}$$
$$\forall IR,L.\ \Gamma \vdash \text{LowerIR}(IR) \Downarrow L \Rightarrow \text{LLVMValid}_{21.1.8}(L)$$

$$\text{CodegenJudg} = \{\text{CodegenProject},\ \text{CodegenModule},\ \text{CodegenItem},\ \text{CodegenExpr},\ \text{CodegenStmt},\ \text{CodegenBlock},\ \text{CodegenPlace}\}$$

$$\text{IRDefined}(IR) \iff \forall \sigma.\ \exists out,\sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')$$

$$\text{CodegenExprValCorrect} \iff \forall e, IR, v, \sigma, v', \sigma'.\ \left(\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v'), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(v'), \sigma') \land v = v'\right)$$
$$\text{CodegenExprCtrlCorrect} \iff \forall e, IR, v, \sigma, \kappa, \sigma'.\ \left(\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right)$$
$$\text{CodegenStmtCorrect} \iff \forall s, IR, \sigma, sout, \sigma'.\ \left(\Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR \land \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (sout, \sigma')\right)$$
$$\text{CodegenBlockValCorrect} \iff \forall b, IR, v, \sigma, v', \sigma'.\ \left(\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (\text{Val}(v'), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(v'), \sigma') \land v = v'\right)$$
$$\text{CodegenBlockCtrlCorrect} \iff \forall b, IR, v, \sigma, \kappa, \sigma'.\ \left(\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right)$$

$$\text{CodegenCorrect} \iff \text{CodegenExprValCorrect} \land \text{CodegenExprCtrlCorrect} \land \text{CodegenStmtCorrect} \land \text{CodegenBlockValCorrect} \land \text{CodegenBlockCtrlCorrect}$$
$$\text{CodegenUndefined} \iff \exists e,IR,v.\ \Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \neg \text{IRDefined}(IR)\ \lor\ \exists s,IR.\ \Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR \land \neg \text{IRDefined}(IR)\ \lor\ \exists b,IR,v.\ \Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \neg \text{IRDefined}(IR)$$
$$\text{CodegenUndefined} \Rightarrow \text{OutsideConformance}$$

$$\text{IRDecls} = [\text{IRDecl}]$$
$$\text{ModuleIR} = \text{IRDecls}$$

**(CG-Project)**
$$\frac{\Gamma \vdash \text{OutputPipeline}(P) \Downarrow (Objs, IRs, Exe)}{\Gamma \vdash \text{CodegenProject}(P) \Downarrow (\text{Set}(Objs) \cup \text{Set}(IRs) \cup \{Exe\})}$$

$$\text{Items}(P, m) = \text{ASTModule}(P, m).\text{items}$$

**(CG-Module)**
$$\frac{\text{Items}(\text{Project}(\Gamma), m) = [i_1,\ldots,i_k] \quad \forall j,\ \Gamma \vdash \text{CodegenItem}(i_j) \Downarrow ds_j \quad \Gamma \vdash \text{InitFn}(m) \Downarrow sym_{\text{init}} \quad \Gamma \vdash \text{DeinitFn}(m) \Downarrow sym_{\text{deinit}} \quad \Gamma \vdash \text{Lower-StaticInit}(m) \Downarrow IR_{\text{init}} \quad \Gamma \vdash \text{Lower-StaticDeinit}(m) \Downarrow IR_{\text{deinit}}}{\Gamma \vdash \text{CodegenModule}(m) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k \mathbin{+\!\!+} [\text{ProcIR}(sym_{\text{init}}, [\text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{init}}),\ \text{ProcIR}(sym_{\text{deinit}}, [\text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{deinit}})]}$$

$$\Gamma \vdash \text{CodegenItem}(item) \Downarrow ds \Rightarrow ds \in \text{IRDecls}$$
$$\text{ProcIR} : \text{Symbol} \times [\text{Param}] \times \text{Type} \times \text{IR} \to \text{IRDecl}$$

$$\text{PanicOutParam} = \langle \texttt{move},\ \text{PanicOutName},\ \text{PanicOutType} \rangle$$
$$\text{CodegenParams}(params) = params \mathbin{+\!\!+} [\text{PanicOutParam}]$$

$$\text{MethodParams}(R, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(\text{Self}_R, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params}$$
$$\text{ClassMethodParams}(Cl, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(\text{SelfVar}, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params}$$

$$\text{ParamList}_T(T, params) = [\langle mode_i, name_i, \text{SubstSelf}(T, ty_i) \rangle \mid \langle mode_i, name_i, ty_i \rangle \in params]$$
$$\text{ClassMethodParams}_T(T, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(T, m.\text{receiver}) \rangle] \mathbin{+\!\!+} \text{ParamList}_T(T, m.\text{params})$$

$$\text{StateMethodParams}(M, S, md) = [\langle \bot, \texttt{self}, \text{TypePerm}(\texttt{const}, \text{TypeModalState}(\text{ModalPath}(M), S)) \rangle] \mathbin{+\!\!+} md.\text{params}$$
$$\text{TransitionParams}(M, S, tr) = [\langle \texttt{move}, \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(\text{ModalPath}(M), S)) \rangle] \mathbin{+\!\!+} tr.\text{params}$$

$$\text{StateList}(M) = [s \mid s \in M.\text{states}]$$
$$\text{DefaultImpl} : \text{Type} \times \text{ClassMethodDecl} \to \text{ASTItem}$$
$$\text{DefaultUserSet}(m) = \{ T \mid \Gamma \vdash T \text{ uses default } m \}$$
$$\text{DefaultUserList}(m) = \text{sort}_{\prec_{\text{type}}}(\text{DefaultUserSet}(m))$$

**(CG-Item-Using)**
$$\frac{\text{item} = \text{UsingDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-TypeAlias)**
$$\frac{\text{item} = \text{TypeAliasDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-Procedure-Main)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, \texttt{"main"}, params, ret\_opt, body, span, doc) \quad Project(\Gamma) = P \quad \text{Executable}(P) \quad \text{MainSigOk}(\text{item}) \quad R = \text{ProcReturn}(ret\_opt) \quad \Gamma \vdash \text{EmitInitPlan}(P) \Downarrow IR_{\text{init}} \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_{\text{body}}, v \rangle \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym \quad params' = \text{CodegenParams}(params)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow [\text{ProcIR}(sym, params', R, \text{SeqIR}(IR_{\text{init}}, IR_{\text{body}}))]}$$

**(CG-Item-Procedure)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc) \quad Project(\Gamma) = P \quad (name \ne \texttt{"main"} \ \lor\ \neg \text{Executable}(P)) \quad R = \text{ProcReturn}(ret\_opt) \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym \quad params' = \text{CodegenParams}(params)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow [\text{ProcIR}(sym, params', R, IR)]}$$

**(CG-Item-Static)**
$$\frac{\text{item} = \text{StaticDecl}(\_) \quad \Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow ds}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds}$$

**(CG-Item-Record)**
$$\frac{\text{item} = \text{RecordDecl}(vis, name, implements, members, span, doc) \quad R = \text{item} \quad \text{Methods}(R) = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{CodegenItem}(m_i) \Downarrow ds_i}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k}$$

**(CG-Item-Method)**
$$\frac{m \in \text{Methods}(R) \quad params' = \text{MethodParams}(R, m) \quad R_m = \text{ReturnType}(m) \quad m.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(m) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow [\text{ProcIR}(sym, params'', R_m, IR)]}$$

**(CG-Item-Modal)**
$$\frac{\text{item} = \text{ModalDecl}(vis, name, implements, states, span, doc) \quad M = \text{item} \quad \forall S \in \text{StateList}(M),\ \forall md \in \text{Methods}(S),\ \Gamma \vdash \text{CodegenItem}(md) \Downarrow ds_{S,md} \quad \forall S \in \text{StateList}(M),\ \forall tr \in \text{Transitions}(S),\ \Gamma \vdash \text{CodegenItem}(tr) \Downarrow ds_{S,tr}}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow \mathbin{+\!\!+}_{S \in \text{StateList}(M)} \left( \mathbin{+\!\!+}_{md \in \text{Methods}(S)} ds_{S,md} \mathbin{+\!\!+} \mathbin{+\!\!+}_{tr \in \text{Transitions}(S)} ds_{S,tr} \right)}$$

**(CG-Item-StateMethod)**
$$\frac{S \in \text{StateList}(M) \quad md \in \text{Methods}(S) \quad params' = \text{StateMethodParams}(M, S, md) \quad R_m = \text{ReturnType}(md) \quad md.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(md) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(md) \Downarrow [\text{ProcIR}(sym, params'', R_m, IR)]}$$

**(CG-Item-Transition)**
$$\frac{S \in \text{StateList}(M) \quad tr \in \text{Transitions}(S) \quad params' = \text{TransitionParams}(M, S, tr) \quad \text{TransitionSig}(M, S, tr).\text{target} = S_t \quad tr.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(tr) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(tr) \Downarrow [\text{ProcIR}(sym, params'', \text{TypeModalState}(\text{ModalPath}(M), S_t), IR)]}$$

**(CG-Item-Class)**
$$\frac{\text{item} = \text{ClassDecl}(vis, name, supers, items, span, doc) \quad Cl = \text{item} \quad \text{ClassMethods}(Cl) = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{CodegenItem}(m_i) \Downarrow ds_i}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k}$$

**(CG-Item-ClassMethod-Abstract)**
$$\frac{m \in \text{ClassMethods}(Cl) \quad m.\text{body\_opt} = \bot}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow []}$$

**(CG-Item-ClassMethod-Body)**
$$\frac{m \in \text{ClassMethods}(Cl) \quad m.\text{body\_opt} = body \quad \text{DefaultUserList}(m) = [T_1,\ldots,T_k] \quad \forall i,\ \Gamma_i = \Gamma[\text{SelfVar} \mapsto T_i] \quad \text{params}_i = \text{ClassMethodParams}_T(T_i, m) \quad R_i = \text{ReturnType}_T(T_i, m) \quad \Gamma_i \vdash \text{LowerBlock}(body) \Downarrow \langle IR_i, v_i \rangle \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T_i, m)) \Downarrow sym_i \quad \text{params}_i' = \text{CodegenParams}(\text{params}_i)}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow [\text{ProcIR}(sym_1, \text{params}_1', R_1, IR_1),\ldots,\text{ProcIR}(sym_k, \text{params}_k', R_k, IR_k)]}$$

**(CG-Item-Enum)**
$$\frac{\text{item} = \text{EnumDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-ErrorItem)**
$$\frac{\text{item} = \text{ErrorItem}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$
$$\exists \text{item}, ds.\ \text{item} = \text{ErrorItem}(\_) \land \Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds \Rightarrow \text{OutsideConformance}$$

**(CG-Expr)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle}$$

**(CG-Stmt)**
$$\frac{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR}{\Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR}$$

**(CG-Block)**
$$\frac{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle}$$

**(CG-Place)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{\Gamma \vdash \text{CodegenPlace}(p) \Downarrow l}$$


### 6.1. Layout and Representation

#### 6.1.1. Primitive Layout and Encoding

$$\text{PtrSize} = 8$$
$$\text{PointerSize} = \text{PtrSize}$$
$$\text{PtrAlign} = 8$$

$$\text{PrimSize}(\texttt{"i8"}) = 1$$
$$\text{PrimSize}(\texttt{"i16"}) = 2$$
$$\text{PrimSize}(\texttt{"i32"}) = 4$$
$$\text{PrimSize}(\texttt{"i64"}) = 8$$
$$\text{PrimSize}(\texttt{"i128"}) = 16$$
$$\text{PrimSize}(\texttt{"u8"}) = 1$$
$$\text{PrimSize}(\texttt{"u16"}) = 2$$
$$\text{PrimSize}(\texttt{"u32"}) = 4$$
$$\text{PrimSize}(\texttt{"u64"}) = 8$$
$$\text{PrimSize}(\texttt{"u128"}) = 16$$
$$\text{PrimSize}(\texttt{"f16"}) = 2$$
$$\text{PrimSize}(\texttt{"f32"}) = 4$$
$$\text{PrimSize}(\texttt{"f64"}) = 8$$
$$\text{PrimSize}(\texttt{"bool"}) = 1$$
$$\text{PrimSize}(\texttt{"char"}) = 4$$
$$\text{PrimSize}(\texttt{"usize"}) = \text{PtrSize}$$
$$\text{PrimSize}(\texttt{"isize"}) = \text{PtrSize}$$
$$\text{PrimSize}(\texttt{"()"}) = 0$$
$$\text{PrimSize}(\texttt{"!"}) = 0$$

$$\text{PrimAlign}(\texttt{"i8"}) = 1$$
$$\text{PrimAlign}(\texttt{"i16"}) = 2$$
$$\text{PrimAlign}(\texttt{"i32"}) = 4$$
$$\text{PrimAlign}(\texttt{"i64"}) = 8$$
$$\text{PrimAlign}(\texttt{"i128"}) = 16$$
$$\text{PrimAlign}(\texttt{"u8"}) = 1$$
$$\text{PrimAlign}(\texttt{"u16"}) = 2$$
$$\text{PrimAlign}(\texttt{"u32"}) = 4$$
$$\text{PrimAlign}(\texttt{"u64"}) = 8$$
$$\text{PrimAlign}(\texttt{"u128"}) = 16$$
$$\text{PrimAlign}(\texttt{"f16"}) = 2$$
$$\text{PrimAlign}(\texttt{"f32"}) = 4$$
$$\text{PrimAlign}(\texttt{"f64"}) = 8$$
$$\text{PrimAlign}(\texttt{"bool"}) = 1$$
$$\text{PrimAlign}(\texttt{"char"}) = 4$$
$$\text{PrimAlign}(\texttt{"usize"}) = \text{PtrAlign}$$
$$\text{PrimAlign}(\texttt{"isize"}) = \text{PtrAlign}$$
$$\text{PrimAlign}(\texttt{"()"}) = 1$$
$$\text{PrimAlign}(\texttt{"!"}) = 1$$

$$\text{LayoutJudg} = \{\text{sizeof},\ \text{alignof},\ \text{layout}\}$$

**(Size-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimSize}(name) = n}{\Gamma \vdash \text{sizeof}(T) = n}$$

**(Align-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimAlign}(name) = a}{\Gamma \vdash \text{alignof}(T) = a}$$

**(Layout-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimSize}(name) = n \quad \text{PrimAlign}(name) = a}{\Gamma \vdash \text{layout}(T) \Downarrow \langle n, a \rangle}$$

**Encoding.**

$$\text{LEBytes}(v, n) = \text{LE}(v \bmod 2^{8n}, n)$$
$$\text{FloatBits}_t(v) = \text{IEEE754Bits}(t, v)$$
$$\text{EncodeConstJudg} = \{\text{EncodeConst}\}$$
$$\text{BoolByte}(\text{false}) = \texttt{0x00}$$
$$\text{BoolByte}(\text{true}) = \texttt{0x01}$$

**(Encode-Bool)**
$$\frac{\text{LiteralValue}(lit, \text{TypePrim}(\texttt{"bool"})) = b}{\Gamma \vdash \text{EncodeConst}(\text{TypePrim}(\texttt{"bool"}), lit) \Downarrow \text{LEBytes}(\text{BoolByte}(b), 1)}$$

**(Encode-Char)**
$$\frac{\text{LiteralValue}(lit, \text{TypePrim}(\texttt{"char"})) = c}{\Gamma \vdash \text{EncodeConst}(\text{TypePrim}(\texttt{"char"}), lit) \Downarrow \text{LEBytes}(c, 4)}$$

**(Encode-Int)**
$$\frac{lit.\text{kind} = \text{IntLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad v = \text{LiteralValue}(lit, T) \quad x = \text{IntValValue}(v)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(x, \text{sizeof}(T))}$$

**(Encode-Float)**
$$\frac{lit.\text{kind} = \text{FloatLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{FloatTypes} \quad v = \text{LiteralValue}(lit, T) \quad x = \text{FloatValValue}(v)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(\text{FloatBits}_t(x), \text{sizeof}(T))}$$

**(Encode-Unit)**
$$\frac{T = \text{TypePrim}(\texttt{"()"})}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow []}$$

**(Encode-Never)**
$$\frac{T = \text{TypePrim}(\texttt{"!"})}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow []}$$

**(Encode-RawPtr-Null)**
$$\frac{lit.\text{kind} = \text{NullLiteral} \quad T = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(0, \text{sizeof}(T))}$$

**Validity.**

$$\text{ValidValueJudg} = \{\text{ValidValue}\}$$

**(Valid-Bool)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"bool"}), bits) \iff bits \in \{[\texttt{0x00}],[\texttt{0x01}]\}$$

**(Valid-Char)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"char"}), bits) \iff \exists c.\ \text{LEBytes}(c, 4) = bits \land c \in \text{UnicodeScalar}$$

**(Valid-Scalar)**
$$\text{ScalarTypes} = \{\texttt{"i8"},\texttt{"i16"},\texttt{"i32"},\texttt{"i64"},\texttt{"i128"},\texttt{"u8"},\texttt{"u16"},\texttt{"u32"},\texttt{"u64"},\texttt{"u128"},\texttt{"f16"},\texttt{"f32"},\texttt{"f64"},\texttt{"usize"},\texttt{"isize"}\}$$
$$\forall t \in \text{ScalarTypes}.\ \text{ValidValue}(\text{TypePrim}(t), bits) \iff |bits| = \text{PrimSize}(t)$$

**(Valid-Unit)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"()"}), bits) \iff bits = []$$

**(Valid-Never)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"!"}), bits) \iff \text{false}$$

#### 6.1.2. Permission, Pointer, and Function Layout

**(Layout-Perm)**
$$\frac{\Gamma \vdash \text{layout}(T) \Downarrow L}{\Gamma \vdash \text{layout}(\text{TypePerm}(p, T)) \Downarrow L}$$

**(Size-Perm)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = n}{\Gamma \vdash \text{sizeof}(\text{TypePerm}(p, T)) = n}$$

**(Align-Perm)**
$$\frac{\Gamma \vdash \text{alignof}(T) = a}{\Gamma \vdash \text{alignof}(\text{TypePerm}(p, T)) = a}$$

**(Size-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

#### 6.1.3. Record Layout Without `[[layout(C)]]`

$$\text{AlignUp}(x,a) = \lceil x/a \rceil \times a \quad \text{where } a > 0$$
$$\text{Offsets}([]) = []$$
$$\text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n] \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1 \land \text{offset}_1 = 0 \land \forall i \in \{2,\ldots,n\}.\ \text{offset}_i = \text{AlignUp}(\text{offset}_{i-1} + \text{sizeof}(T_{i-1}), \text{alignof}(T_i))$$
$$\text{RecordAlign}([]) = 1$$
$$\text{RecordAlign}(fields) = \max_{i \in \{1,\ldots,n\}}(\text{alignof}(T_i)) \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1$$
$$\text{RecordSize}([]) = 0$$
$$\text{RecordSize}(fields) = \text{AlignUp}(\text{offset}_n + \text{sizeof}(T_n), \text{RecordAlign}(fields)) \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1 \land \text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n]$$
$$\text{RecordLayoutJudg} = \{\text{RecordLayout}\}$$

**(Layout-Record-Empty)**
$$\frac{ }{\Gamma \vdash \text{RecordLayout}([]) \Downarrow \langle 0, 1, [] \rangle}$$

**(Layout-Record-Cons)**
$$\frac{n \ge 1 \quad \text{offsets} = [offset_1,\ldots,offset_n] \quad align = \text{RecordAlign}(fields) \quad size = \text{RecordSize}(fields)}{\Gamma \vdash \text{RecordLayout}(fields) \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

$$\text{FieldOffset}(fields, f_i) = \text{offset}_i \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land 1 \le i \le n \land \text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n]$$

**Type Aliases.**
$$\text{AliasBody}(p) = ty \iff \Sigma.\text{Types}[p] = \text{TypeAliasDecl}(vis, name, ty, span, doc)$$

**(Size-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{sizeof}(ty) = size}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{alignof}(ty) = align}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{layout}(ty) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.4. Union Layout and Discriminants

##### 6.1.4.1. Niche Optimization (Cursive0)

**Niche Sets.**

$$\text{NicheSet}(T) \subseteq \{ bits \mid \neg \text{ValidValue}(T, bits) \}$$
$$\text{NicheSet}(T) = \{\text{LEBytes}(0, \text{PtrSize})\} \iff \exists U.\ T = \text{TypePtr}(U, \texttt{Valid})$$
$$\text{NicheSet}(T) = \emptyset \iff \neg \exists U.\ T = \text{TypePtr}(U, \texttt{Valid})$$

$$\text{BitsToUInt}(bits) = v \iff \text{LEBytes}(v, |bits|) = bits$$
$$bits_1 \prec_u bits_2 \iff \exists v_1,v_2.\ \text{BitsToUInt}(bits_1) = v_1 \land \text{BitsToUInt}(bits_2) = v_2 \land v_1 < v_2$$
$$\text{NicheOrder}(T) = \text{sort}_{\prec_u}(\text{NicheSet}(T))$$
$$\text{NicheCount}(T) = |\text{NicheSet}(T)|$$

**Valid Pointer Non-Zero Invariant.**

$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Valid}), bits) \iff |bits| = \text{PtrSize} \land bits \ne \text{LEBytes}(0, \text{PtrSize})$$
$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Null}), bits) \iff bits = \text{LEBytes}(0, \text{PtrSize})$$
$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Expired}), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(\text{TypePtr}(T,\bot), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(\text{TypeRawPtr}(q, T), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(T, bits) \iff T \notin \{\text{TypePrim}(\_),\ \text{TypePtr}(\_,\_),\ \text{TypeRawPtr}(\_,\_)\} \land \exists v.\ \text{ValueBits}(T, v) = bits$$

**Union Niche Encoding.**

$$U = \text{TypeUnion}([T_1,\ldots,T_n])$$

**Type Ordering (Cursive0).**

$$\text{PathOrderKey}(p) = \langle \text{Fold}(p), p \rangle$$
$$\text{ArrayLen}(e) = n \iff \Gamma \vdash \text{ConstLen}(e) \Downarrow n$$

$$\text{TagKey}(\texttt{prim}) = 0$$
$$\text{TagKey}(\texttt{tuple}) = 1$$
$$\text{TagKey}(\texttt{array}) = 2$$
$$\text{TagKey}(\texttt{slice}) = 3$$
$$\text{TagKey}(\texttt{func}) = 4$$
$$\text{TagKey}(\texttt{path}) = 5$$
$$\text{TagKey}(\texttt{modal\_state}) = 6$$
$$\text{TagKey}(\texttt{string}) = 7$$
$$\text{TagKey}(\texttt{bytes}) = 8$$
$$\text{TagKey}(\texttt{dynamic}) = 9$$
$$\text{TagKey}(\texttt{ptr}) = 10$$
$$\text{TagKey}(\texttt{rawptr}) = 11$$
$$\text{TagKey}(\texttt{union}) = 12$$
$$\text{TagKey}(\texttt{perm}) = 13$$
$$\text{TagKey}(\texttt{range}) = 14$$

$$\text{PermKey}(\texttt{const}) = 0$$
$$\text{PermKey}(\texttt{unique}) = 1$$
$$\text{PtrStateKey}(\bot) = 0$$
$$\text{PtrStateKey}(\texttt{Valid}) = 1$$
$$\text{PtrStateKey}(\texttt{Null}) = 2$$
$$\text{PtrStateKey}(\texttt{Expired}) = 3$$
$$\text{QualKey}(\texttt{imm}) = 0$$
$$\text{QualKey}(\texttt{mut}) = 1$$
$$\text{ModeKey}(\bot) = 0$$
$$\text{ModeKey}(\texttt{move}) = 1$$
$$\text{StateKey}(\texttt{View}) = 0$$
$$\text{StateKey}(\texttt{Managed}) = 1$$
$$\text{StateKey}(\bot) = 2$$

$$\text{TypeKey}(\text{TypePrim}(name)) = \langle \text{TagKey}(\texttt{prim}), name \rangle$$
$$\text{TypeKey}(\text{TypeRange}) = \langle \text{TagKey}(\texttt{range}) \rangle$$
$$\text{TypeKey}(\text{TypeTuple}([T_1,\ldots,T_n])) = \langle \text{TagKey}(\texttt{tuple}), n, \text{TypeKey}(T_1),\ldots,\text{TypeKey}(T_n) \rangle$$
$$\text{TypeKey}(\text{TypeArray}(T, e)) = \langle \text{TagKey}(\texttt{array}), \text{TypeKey}(T), \text{ArrayLen}(e) \rangle$$
$$\text{TypeKey}(\text{TypeSlice}(T)) = \langle \text{TagKey}(\texttt{slice}), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R)) = \langle \text{TagKey}(\texttt{func}), n, \text{ModeKey}(m_1), \text{TypeKey}(T_1),\ldots,\text{ModeKey}(m_n), \text{TypeKey}(T_n), \text{TypeKey}(R) \rangle$$
$$\text{TypeKey}(\text{TypePath}(p)) = \langle \text{TagKey}(\texttt{path}), \text{PathOrderKey}(p) \rangle$$
$$\text{TypeKey}(\text{TypeModalState}(p, S)) = \langle \text{TagKey}(\texttt{modal\_state}), \text{PathOrderKey}(p), S \rangle$$
$$\text{TypeKey}(\text{TypeString}(st)) = \langle \text{TagKey}(\texttt{string}), \text{StateKey}(st) \rangle$$
$$\text{TypeKey}(\text{TypeBytes}(st)) = \langle \text{TagKey}(\texttt{bytes}), \text{StateKey}(st) \rangle$$
$$\text{TypeKey}(\text{TypeDynamic}(p)) = \langle \text{TagKey}(\texttt{dynamic}), \text{PathOrderKey}(p) \rangle$$
$$\text{TypeKey}(\text{TypePtr}(T, s)) = \langle \text{TagKey}(\texttt{ptr}), \text{PtrStateKey}(s), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeRawPtr}(q, T)) = \langle \text{TagKey}(\texttt{rawptr}), \text{QualKey}(q), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeUnion}([T_1,\ldots,T_n])) = \langle \text{TagKey}(\texttt{union}), \text{Sort}([\text{TypeKey}(T_1),\ldots,\text{TypeKey}(T_n)]) \rangle$$
$$\text{TypeKey}(\text{TypePerm}(p, T)) = \langle \text{TagKey}(\texttt{perm}), \text{PermKey}(p), \text{TypeKey}(T) \rangle$$

$$\text{Key} = \{ \text{TypeKey}(T) \mid T \in \text{Type} \}$$
$$\text{KeyList} = \{ [k_1,\ldots,k_n] \mid \forall i.\ k_i \in \text{Key} \}$$
$$a \prec_{\text{atom}} b \iff (a,b \in \mathbb{N} \land a<b) \lor (a,b \in \text{String} \land \text{Utf8LexLess}(a,b)) \lor (a,b \in \text{Key} \land a \prec_{\text{key}} b) \lor (a,b \in \text{KeyList} \land a \prec_{\text{keylist}} b)$$
$$\text{LexLess}_{\prec}(L_1,L_2) \iff (\exists k.\ 0 \le k < |L_1| \land 0 \le k < |L_2| \land (\forall i.\ 0 \le i < k \Rightarrow L_1[i]=L_2[i]) \land L_1[k] \prec L_2[k]) \lor (|L_1| < |L_2| \land \forall i.\ 0 \le i < |L_1| \Rightarrow L_1[i]=L_2[i])$$
$$k_1 \prec_{\text{key}} k_2 \iff \text{LexLess}_{\prec_{\text{atom}}}(k_1,k_2)$$
$$L_1 \prec_{\text{keylist}} L_2 \iff \text{LexLess}_{\prec_{\text{key}}}(L_1,L_2)$$
$$\text{Sorted}_{\prec}(L) \iff \forall i,j.\ 0 \le i < j < |L| \Rightarrow \neg (L[j] \prec L[i])$$
$$\text{Sort}(L) = L' \iff \text{Permutation}(L', L) \land \text{Sorted}_{\prec_{\text{key}}}(L')$$
$$T_1 \prec_{\text{type}} T_2 \iff \text{TypeKey}(T_1) \prec_{\text{key}} \text{TypeKey}(T_2)$$

$$\text{MemberList}(U) = \text{Sort}(\text{Members}(U))$$
$$\text{MemberIndex}(U, T) = i \iff \text{MemberList}(U)[i] \equiv T$$
$$\text{UnionDiscValue}(U, T) = i \iff \text{MemberIndex}(U, T) = i$$
$$\text{EmptyMember}(T) \iff T \equiv \text{TypePrim}(\texttt{"()"})$$
$$\text{EmptyList}(U) = [\text{MemberList}(U)[i] \mid 0 \le i < |\text{MemberList}(U)| \land \text{EmptyMember}(\text{MemberList}(U)[i])]$$
$$\text{PayloadMember}(U) = T_p \iff \exists j.\ \text{MemberList}(U)[j] \equiv T_p \land \text{NicheCount}(T_p) > 0 \land (\forall i.\ 0 \le i < |\text{MemberList}(U)| \land i \ne j \Rightarrow \text{EmptyMember}(\text{MemberList}(U)[i])) \land \text{NicheCount}(T_p) \ge |\text{MemberList}(U)| - 1$$
$$\text{NicheApplies}(U) \iff \exists T_p.\ \text{PayloadMember}(U) = T_p$$

**ValueBits.**

$$\text{FieldValueList}(fs, f) = v \iff \langle f, v \rangle \in fs$$
$$\text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], [o_1,\ldots,o_n], size) = bits \iff |bits| = size \land \forall i.\ \text{ValueBits}(T_i, v_i) = b_i \land bits[o_i..o_i+|b_i|) = b_i \land \forall j.\ (\forall i.\ j \notin [o_i, o_i+|b_i|)) \Rightarrow bits[j]=\texttt{0x00}$$
$$\text{PadBytes}(b, size) = bits \iff |bits| = size \land bits[0..|b|) = b \land \forall i.\ |b| \le i < size \Rightarrow bits[i]=\texttt{0x00}$$

$$\text{ValueBits}(\text{TypePrim}(\texttt{"bool"}), v) = bits \iff (v=\text{BoolVal}(\text{true}) \land bits=[\texttt{0x01}]) \lor (v=\text{BoolVal}(\text{false}) \land bits=[\texttt{0x00}])$$
$$\text{ValueBits}(\text{TypePrim}(\texttt{"char"}), v) = bits \iff v=\text{CharVal}(u) \land \text{LEBytes}(u, 4) = bits$$
$$\text{ValueBits}(\text{TypePrim}(\texttt{"()"}), v) = bits \iff v=\text{UnitVal} \land bits = []$$
$$\text{ValueBits}(\text{TypePrim}(t), v) = bits \iff t \in \text{IntTypes} \land v=\text{IntVal}(t, x) \land \text{LEBytes}(x, \text{sizeof}(\text{TypePrim}(t))) = bits$$
$$\text{ValueBits}(\text{TypePrim}(t), v) = bits \iff t \in \text{FloatTypes} \land v=\text{FloatVal}(t, x) \land \text{LEBytes}(\text{IEEE754Bits}(t, x), \text{sizeof}(\text{TypePrim}(t))) = bits$$
$$\text{ValueBits}(\text{TypePerm}(p, T), v) = bits \iff \text{ValueBits}(T, v) = bits$$

$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Valid}), v) = bits \iff v=\text{PtrVal}(\texttt{Valid}, addr) \land addr \ne 0x0 \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Null}), v) = bits \iff v=\text{PtrVal}(\texttt{Null}, addr) \land addr = 0x0 \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Expired}), v) = bits \iff v=\text{PtrVal}(\texttt{Expired}, addr) \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \bot), v) = bits \iff \exists s.\ s \in \text{PtrStateSet} \land \text{ValueBits}(\text{TypePtr}(T, s), v) = bits$$
$$\text{ValueBits}(\text{TypeRawPtr}(q, T), v) = bits \iff v=\text{RawPtr}(q, addr) \land bits=\text{LEBytes}(addr, \text{PtrSize})$$

$$\text{ValueBits}(\text{TypeTuple}([T_1,\ldots,T_n]), (v_1,\ldots,v_n)) = bits \iff \text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypeArray}(T, e), [v_0,\ldots,v_{n-1}]) = bits \iff \text{ArrayLen}(e)=n \land s=\text{sizeof}(T) \land |bits| = n \times s \land \forall i.\ 0 \le i < n \Rightarrow (\text{ValueBits}(T, v_i) = b_i \land bits[i \times s .. i \times s + |b_i|) = b_i)$$
$$\text{ValueBits}(\text{TypeSlice}(T), \text{SliceValue}(v, r)) = bits \iff \text{SliceBounds}(r, \text{Len}(v)) = (start, end) \land n = end - start \land \exists addr.\ \text{ValueBits}(\text{TypeRawPtr}(\texttt{imm}, T), \text{RawPtr}(\texttt{imm}, addr)) = b_{\text{ptr}} \land \text{ValueBits}(\text{TypePrim}(\texttt{"usize"}), \text{IntVal}(\texttt{"usize"}, n)) = b_{\text{len}} \land bits = b_{\text{ptr}} \mathbin{+\!\!+} b_{\text{len}}$$
$$\text{ValueBits}(\text{TypeRange}, r) = bits \iff \text{RangeValFields}(r) = [\langle \texttt{kind}, v_k \rangle,\ \langle \texttt{lo}, v_l \rangle,\ \langle \texttt{hi}, v_h \rangle] \land \text{RangeFields} = [\langle \texttt{kind}, T_k \rangle,\ \langle \texttt{lo}, T_l \rangle,\ \langle \texttt{hi}, T_h \rangle] \land \text{RecordLayout}(\text{RangeFields}) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([T_k, T_l, T_h], [v_k, v_l, v_h], offsets, size) = bits$$

$$\text{ValueBits}(\text{TypeModalState}(p, S), v) = bits \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land S \in \text{States}(M) \land v=\text{RecordValue}(\text{ModalStateRef}(p, S), fs) \land \text{Payload}(M, S) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(\text{ModalStateRef}(p, S), fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$

$$\text{EnumPayloadBits}(E, name, \bot) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\bot) \land \text{PadBytes}([], \text{PayloadSize}(E)) = bits$$
$$\text{EnumPayloadBits}(E, name, \text{TuplePayload}([v_1,\ldots,v_k])) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\text{TuplePayload}([T_1,\ldots,T_k])) \land \text{ValueBits}(\text{TypeTuple}([T_1,\ldots,T_k]), (v_1,\ldots,v_k)) = b \land \text{PadBytes}(b, \text{PayloadSize}(E)) = bits$$
$$\text{EnumPayloadBits}(E, name, \text{RecordPayload}(fs)) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\text{RecordPayload}(fields)) \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValueList}(fs, f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = b \land \text{PadBytes}(b, \text{PayloadSize}(E)) = bits$$

$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{AliasBody}(p) = ty \land \text{ValueBits}(ty, v) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{RecordDecl}(p) = R \land v=\text{RecordValue}(\text{TypePath}(p), fs) \land \text{Fields}(R) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(\text{TypePath}(p), fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{EnumDecl}(p) = E \land v=\text{EnumValue}(path, payload) \land \text{EnumPath}(path)=p \land name=\text{VariantName}(path) \land \text{EnumDisc}(E, name) = d \land \text{EnumPayloadBits}(E, name, payload) = payload\_bits \land \text{EnumDiscType}(E)=D \land D=\text{TypePrim}(t) \land \text{ValueBits}(D, \text{IntVal}(t, d)) = disc\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{PayloadSize}(E), \text{PayloadAlign}(E), \text{EnumSize}(E)) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land v=\langle S, v_s \rangle \land \text{ModalBits}(M, S, v_s) = bits$$

$$\text{ValueBits}(\text{TypeUnion}(U), v) = bits \iff \exists T.\ \text{Member}(T, \text{TypeUnion}(U)) \land \text{UnionBits}(U, T, v) = bits$$

$$\text{ValueBits}(\text{TypeDynamic}(Cl), v) = bits \iff v=\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T) \land sym=\text{ScopedSym}(\text{VTableDecl}(T, Cl)) \land addr_{vt}=\text{AddrOfSym}(sym) \land \text{RecordLayout}(\text{DynFields}(Cl)) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([\text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})), \text{TypeRawPtr}(\texttt{imm}, \text{TypePath}([\texttt{"VTable"}]))], [\text{RawPtr}(\texttt{imm}, addr), \text{RawPtr}(\texttt{imm}, addr_{vt})], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypeString}(st), v) = bits \iff \text{ValueType}(v) = \text{TypeString}(st) \land |bits| = \text{sizeof}(\text{TypeString}(st))$$
$$\text{ValueBits}(\text{TypeBytes}(st), v) = bits \iff \text{ValueType}(v) = \text{TypeBytes}(st) \land |bits| = \text{sizeof}(\text{TypeBytes}(st))$$

$$\text{ValueBits}(T, v) = bits \Rightarrow \text{ValidValue}(T, bits)$$
$$\text{UnionNicheBits}(U, T, v) = bits \iff \text{NicheApplies}(U) \land \text{PayloadMember}(U) = T_p \land ((T \equiv T_p \land \text{ValueBits}(T_p, v) = bits \land bits \notin \text{NicheSet}(T_p)) \lor (\exists i.\ \text{EmptyList}(U)[i] \equiv T \land v = () \land \text{NicheOrder}(T_p)[i] = bits))$$

**Union Layout.**

$$k = |\text{MemberList}(U)| - 1$$
$$\text{UnionDiscType}(U) = \text{DiscType}(k)$$
$$\text{PayloadSize}(U) = \max_{T \in \text{MemberList}(U)}(\text{sizeof}(T))$$
$$\text{PayloadAlign}(U) = \max_{T \in \text{MemberList}(U)}(\text{alignof}(T))$$
$$\text{UnionAlign}(U) = \max(\text{alignof}(\text{UnionDiscType}(U)), \text{PayloadAlign}(U))$$
$$\text{UnionSize}(U) = \text{AlignUp}(\text{sizeof}(\text{UnionDiscType}(U)) + \text{PayloadSize}(U), \text{UnionAlign}(U))$$
$$\text{UnionLayoutJudg} = \{\text{UnionLayout}\}$$

**(Layout-Union-Niche)**
$$\frac{\text{NicheApplies}(U) \quad \text{PayloadMember}(U) = T_p \quad \Gamma \vdash \text{layout}(T_p) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{UnionLayout}(U) \Downarrow \langle size, align, \bot, \text{layout}(T_p) \rangle}$$

**(Layout-Union-Tagged)**
$$\frac{\neg \text{NicheApplies}(U) \quad size = \text{UnionSize}(U) \quad align = \text{UnionAlign}(U)}{\Gamma \vdash \text{UnionLayout}(U) \Downarrow \langle size, align, \text{UnionDiscType}(U), \text{PayloadSize}(U) \rangle}$$

**(Size-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

$$\text{PayloadBits}(U, T, v) = bits \iff \text{ValueBits}(T, v) = b \land |bits| = \text{PayloadSize}(U) \land bits[0..|b|) = b$$
$$\text{TaggedBits}(disc\_bits, payload\_bits, disc\_size, payload\_size, payload\_align, size) = bits \iff |bits| = size \land payload\_off = \text{AlignUp}(disc\_size, payload\_align) \land bits[0..disc\_size) = disc\_bits \land bits[payload\_off..payload\_off + payload\_size) = payload\_bits$$

**Informative.** TaggedBits constrains only the discriminant and payload ranges; bytes outside those ranges are unconstrained.

$$\text{UnionTaggedBits}(U, T, v) = bits \iff \neg \text{NicheApplies}(U) \land \text{UnionDiscType}(U) = D \land \text{UnionDiscValue}(U, T) = d \land \text{ValueBits}(D, d) = disc\_bits \land \text{PayloadBits}(U, T, v) = payload\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{PayloadSize}(U), \text{PayloadAlign}(U), \text{UnionSize}(U)) = bits$$
$$\text{UnionBits}(U, T, v) = bits \iff \text{UnionNicheBits}(U, T, v) = bits \lor \text{UnionTaggedBits}(U, T, v) = bits$$

**Modal Niche Encoding.**

$$\text{SingleFieldPayload}(M, S) = T \iff \text{Payload}(M, S) = [\langle f, T \rangle]$$
$$\text{EmptyState}(M, S) \iff \text{Payload}(M, S) = []$$
$$\text{PayloadState}(M) = S_p \iff S_p \in \text{States}(M) \land \text{SingleFieldPayload}(M, S_p) = T_p \land \text{NicheCount}(T_p) > 0 \land (\forall S \in \text{States}(M).\ S \ne S_p \Rightarrow \text{EmptyState}(M, S)) \land \text{NicheCount}(T_p) \ge |\text{States}(M)| - 1$$
$$\text{NicheApplies}(M) \iff \exists S_p.\ \text{PayloadState}(M) = S_p$$
$$\text{EmptyStates}(M) = [ S \in \text{States}(M) \mid \text{EmptyState}(M, S) ]$$
$$\text{EmptyRecordVal}(v) \iff \exists tr.\ v = \text{RecordValue}(tr, [])$$
$$\text{ModalNicheBits}(M, S, v) = bits \iff \text{NicheApplies}(M) \land \text{PayloadState}(M) = S_p \land \text{SingleFieldPayload}(M, S_p) = T_p \land ((S = S_p \land \text{ValueBits}(T_p, v) = bits \land bits \notin \text{NicheSet}(T_p)) \lor (\exists i.\ \text{EmptyStates}(M)[i] = S \land (v = () \lor \text{EmptyRecordVal}(v)) \land \text{NicheOrder}(T_p)[i] = bits))$$
$$\text{ModalBits}(M, S, v) = bits \iff \text{ModalNicheBits}(M, S, v) = bits \lor \text{ModalTaggedBits}(M, S, v) = bits$$

$$\text{ModalPayloadSize}(M) = \max_{S \in \text{States}(M)}(\text{StateSize}(M, S))$$
$$\text{ModalPayloadAlign}(M) = \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S))$$
$$\text{StateRecordBits}(M, S, v) = b \iff \text{Payload}(M, S) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land ((n = 0 \land (v = () \lor \text{EmptyRecordVal}(v)) \land b = []) \lor (n > 0 \land v = \text{RecordValue}(tr, fs) \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(tr, fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = b))$$
$$\text{ModalPayloadBits}(M, S, v) = bits \iff \text{StateRecordBits}(M, S, v) = b \land \text{PadBytes}(b, \text{ModalPayloadSize}(M)) = bits$$

Modal tagged layout is fully defined; all bytes outside the discriminant and payload ranges MUST be zero.
$$\text{ModalTaggedBits}(M, S, v) = bits \iff \neg \text{NicheApplies}(M) \land \text{ModalDiscType}(M) = D \land \text{StateIndex}(M, S) = i \land \text{ValueBits}(D, i) = disc\_bits \land \text{ModalPayloadBits}(M, S, v) = payload\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{ModalPayloadSize}(M), \text{ModalPayloadAlign}(M), \text{ModalSize}(M)) = bits \land payload\_off = \text{AlignUp}(\text{sizeof}(D), \text{ModalPayloadAlign}(M)) \land \forall j.\ 0 \le j < |bits| \land j \notin [0,\text{sizeof}(D)) \land j \notin [payload\_off,\ payload\_off + \text{ModalPayloadSize}(M)) \Rightarrow bits[j]=\texttt{0x00}$$



#### 6.1.5. String and Bytes Layout

**`string@Managed` Representation**

$$\text{StringManagedFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{capacity}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{StringManagedOffsets} = [0,\ \text{PtrSize},\ 2 \times \text{PtrSize}]$$
$$\text{RecordLayout}(\text{StringManagedFields}) = \langle 3 \times \text{PtrSize},\ \text{PtrAlign},\ \text{StringManagedOffsets} \rangle$$
$$\text{sizeof}(\texttt{string@Managed}) = 3 \times \text{PtrSize}$$

**`string@View` Representation**

$$\text{StringViewFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{StringViewOffsets} = [0,\ \text{PtrSize}]$$
$$\text{RecordLayout}(\text{StringViewFields}) = \langle 2 \times \text{PtrSize},\ \text{PtrAlign},\ \text{StringViewOffsets} \rangle$$
$$\text{sizeof}(\texttt{string@View}) = 2 \times \text{PtrSize}$$

**String Layout Rules.**

**(Size-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{sizeof}(T) = 3 \times \text{PtrSize}}$$

**(Align-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 3 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**`bytes@Managed` Representation**

$$\text{BytesManagedFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{capacity}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{BytesManagedOffsets} = [0,\ \text{PtrSize},\ 2 \times \text{PtrSize}]$$
$$\text{RecordLayout}(\text{BytesManagedFields}) = \langle 3 \times \text{PtrSize},\ \text{PtrAlign},\ \text{BytesManagedOffsets} \rangle$$
$$\text{sizeof}(\texttt{bytes@Managed}) = 3 \times \text{PtrSize}$$

**`bytes@View` Representation**

$$\text{BytesViewFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{BytesViewOffsets} = [0,\ \text{PtrSize}]$$
$$\text{RecordLayout}(\text{BytesViewFields}) = \langle 2 \times \text{PtrSize},\ \text{PtrAlign},\ \text{BytesViewOffsets} \rangle$$
$$\text{sizeof}(\texttt{bytes@View}) = 2 \times \text{PtrSize}$$

**Bytes Layout Rules.**

**(Size-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{sizeof}(T) = 3 \times \text{PtrSize}}$$

**(Align-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 3 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-String-Modal)**
$$\frac{T = \text{TypeString}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{string}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-String-Modal)**
$$\frac{T = \text{TypeString}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{string}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Size-Bytes-Modal)**
$$\frac{T = \text{TypeBytes}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{bytes}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Bytes-Modal)**
$$\frac{T = \text{TypeBytes}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{bytes}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$


#### 6.1.6. Aggregate Layouts (Tuples, Arrays, Slices, Ranges, Enums)

**Tuples.**

$$\text{TupleFields}([T_1,\ldots,T_n]) = [\langle 0, T_1 \rangle,\ldots,\langle n-1, T_n \rangle]$$
$$\text{TupleLayoutJudg} = \{\text{TupleLayout}\}$$

**(Layout-Tuple-Empty)**
$$\frac{}{\Gamma \vdash \text{TupleLayout}([]) \Downarrow \langle 0, 1, [] \rangle}$$

**(Layout-Tuple-Cons)**
$$\frac{n \ge 1 \quad \text{TupleFields}([T_1,\ldots,T_n]) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, offsets \rangle}{\Gamma \vdash \text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(\text{TypeTuple}([T_1,\ldots,T_n])) = size}$$

**(Align-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(\text{TypeTuple}([T_1,\ldots,T_n])) = align}$$

**(Layout-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \langle size, align \rangle}$$

**Arrays.**

**(Size-Array)**
$$\frac{\Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash \text{sizeof}(T_0) = s}{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T_0, e)) = n \times s}$$

**(Align-Array)**
$$\frac{\Gamma \vdash \text{alignof}(T_0) = a}{\Gamma \vdash \text{alignof}(\text{TypeArray}(T_0, e)) = a}$$

**(Layout-Array)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T_0, e)) = size \quad \Gamma \vdash \text{alignof}(\text{TypeArray}(T_0, e)) = align}{\Gamma \vdash \text{layout}(\text{TypeArray}(T_0, e)) \Downarrow \langle size, align \rangle}$$

**Slices.**

**(Size-Slice)**
$$\frac{}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-Slice)**
$$\frac{}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Slice)**
$$\frac{}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**Ranges.**

$$\text{RangeTag}(\texttt{To}) = 0$$
$$\text{RangeTag}(\texttt{ToInclusive}) = 1$$
$$\text{RangeTag}(\texttt{Full}) = 2$$
$$\text{RangeTag}(\texttt{From}) = 3$$
$$\text{RangeTag}(\texttt{Exclusive}) = 4$$
$$\text{RangeTag}(\texttt{Inclusive}) = 5$$
$$\text{RangeFields} = [\langle \texttt{kind}, \text{TypePrim}(\texttt{"u8"}) \rangle,\ \langle \texttt{lo}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{hi}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{OptVal}(v_\text{opt}) = \begin{cases}\text{IntVal}(\texttt{"usize"}, 0) & v_\text{opt} = \bot \\ v_\text{opt} & \text{otherwise}\end{cases}$$
$$\text{RangeValFields}(\text{RangeVal}(kind, lo\_opt, hi\_opt)) = [\langle \texttt{kind}, \text{IntVal}(\texttt{"u8"}, \text{RangeTag}(kind)) \rangle,\ \langle \texttt{lo}, \text{OptVal}(lo\_opt) \rangle,\ \langle \texttt{hi}, \text{OptVal}(hi\_opt) \rangle]$$
$$\text{RangeLayoutJudg} = \{\text{RangeLayout}\}$$

**(Layout-Range)**
$$\frac{\text{RecordLayout}(\text{RangeFields}) \Downarrow \langle size, align, offsets \rangle}{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(\text{TypeRange}) = size}$$

**(Align-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(\text{TypeRange}) = align}$$

**(Layout-Range-SizeAlign)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(\text{TypeRange}) \Downarrow \langle size, align \rangle}$$

**Enums.**

$$\text{EnumDiscType}(E) = \text{DiscType}(E)$$
$$\text{VariantPayloadOpt}(v) = payload\_opt \iff v = \langle \text{name},\ payload\_opt,\ \text{disc}\_opt,\ \text{span},\ \text{doc}\_opt \rangle$$
$$\text{VariantSize}(v) = 0 \iff \text{VariantPayloadOpt}(v) = \bot$$
$$\text{VariantAlign}(v) = 1 \iff \text{VariantPayloadOpt}(v) = \bot$$
$$\text{VariantSize}(v) = s \iff \text{VariantPayloadOpt}(v) = \text{TuplePayload}([T_1,\ldots,T_k]) \land \text{TupleLayout}([T_1,\ldots,T_k]) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantAlign}(v) = a \iff \text{VariantPayloadOpt}(v) = \text{TuplePayload}([T_1,\ldots,T_k]) \land \text{TupleLayout}([T_1,\ldots,T_k]) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantSize}(v) = s \iff \text{VariantPayloadOpt}(v) = \text{RecordPayload}(fields) \land \text{RecordLayout}(fields) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantAlign}(v) = a \iff \text{VariantPayloadOpt}(v) = \text{RecordPayload}(fields) \land \text{RecordLayout}(fields) \Downarrow \langle s, a, \_ \rangle$$
$$\text{PayloadSize}(E) = \max_{v \in \text{Variants}(E)}(\text{VariantSize}(v))$$
$$\text{PayloadAlign}(E) = \max_{v \in \text{Variants}(E)}(\text{VariantAlign}(v))$$
$$\text{EnumAlign}(E) = \max(\text{alignof}(\text{EnumDiscType}(E)), \text{PayloadAlign}(E))$$
$$\text{EnumSize}(E) = \text{AlignUp}(\text{sizeof}(\text{EnumDiscType}(E)) + \text{PayloadSize}(E), \text{EnumAlign}(E))$$
$$\text{EnumLayoutJudg} = \{\text{EnumLayout}\}$$

**(Layout-Enum-Tagged)**
$$\frac{size = \text{EnumSize}(E) \quad align = \text{EnumAlign}(E)}{\Gamma \vdash \text{EnumLayout}(E) \Downarrow \langle size, align, \text{EnumDiscType}(E), \text{PayloadSize}(E) \rangle}$$

**(Size-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.7. Modal Layout (Codegen)

$$\text{ModalDiscType}(M) = \text{DiscType}(|\text{States}(M)| - 1)$$
$$\text{StateSize}(M, S) = s \iff \text{RecordLayout}(\text{Payload}(M, S)) \Downarrow \langle s, a, \_ \rangle$$
$$\text{StateAlign}(M, S) = a \iff \text{RecordLayout}(\text{Payload}(M, S)) \Downarrow \langle s, a, \_ \rangle$$
$$\text{ModalAlign}(M) = \max(\text{alignof}(\text{ModalDiscType}(M)), \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S)))$$
$$\text{ModalSize}(M) = \text{AlignUp}(\text{sizeof}(\text{ModalDiscType}(M)) + \max_{S \in \text{States}(M)}(\text{StateSize}(M, S)), \text{ModalAlign}(M))$$
$$\text{ModalLayoutJudg} = \{\text{ModalLayout}\}$$

**(Layout-Modal-Niche)**
$$\frac{\text{NicheApplies}(M) \quad \text{PayloadState}(M) = S_p \quad \text{SingleFieldPayload}(M, S_p) = T_p \quad \Gamma \vdash \text{layout}(T_p) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{ModalLayout}(M) \Downarrow \langle size, align, \bot, \text{layout}(T_p) \rangle}$$

**(Layout-Modal-Tagged)**
$$\frac{\neg \text{NicheApplies}(M) \quad size = \text{ModalSize}(M) \quad align = \text{ModalAlign}(M)}{\Gamma \vdash \text{ModalLayout}(M) \Downarrow \langle size, align, \text{ModalDiscType}(M), \max_{S \in States(M)}(\text{StateSize}(M, S)) \rangle}$$

**(Size-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

**(Size-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateSize}(M, S) = size}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateAlign}(M, S) = align}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateSize}(M, S) = size \quad \text{StateAlign}(M, S) = align}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.8. Dynamic Class Object Layout

$$\text{DynFields}(Cl) = [\langle \texttt{data}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})) \rangle,\ \langle \texttt{vtable}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePath}([\texttt{"VTable"}])) \rangle]$$
$$\text{DynLayoutJudg} = \{\text{DynLayout}\}$$

**(Layout-DynamicClass)**
$$\frac{}{\Gamma \vdash \text{DynLayout}(Cl) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign}, \text{DynFields}(Cl) \rangle}$$

**(Size-DynamicClass)**
$$\frac{T = \text{TypeDynamic}(Cl)}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-DynamicClass)**
$$\frac{T = \text{TypeDynamic}(Cl)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

### 6.2. ABI Lowering (Cursive0)

#### 6.2.1. Default Calling Convention

**DefaultCallingConvention.**
$$\text{CallConvDefault} = \text{Cursive0ABI}$$


#### 6.2.2. ABI Type Lowering

$$\text{ABIType} = \{ \langle size, align \rangle \mid size \in \mathbb{N} \land align \in \mathbb{N} \}$$
$$\text{ABITyJudg} = \{\text{ABITy}\}$$

**(ABI-Prim)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypePrim}(name)) = s \quad \Gamma \vdash \text{alignof}(\text{TypePrim}(name)) = a}{\Gamma \vdash \text{ABITy}(\text{TypePrim}(name)) \Downarrow \langle s, a \rangle}$$

**(ABI-Perm)**
$$\frac{\Gamma \vdash \text{ABITy}(T) \Downarrow \tau}{\Gamma \vdash \text{ABITy}(\text{TypePerm}(p, T)) \Downarrow \tau}$$

**(ABI-Ptr)**
$$\frac{T = \text{TypePtr}(U, s)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{ABITy}(ty) \Downarrow \tau}{\Gamma \vdash \text{ABITy}(T) \Downarrow \tau}$$

**(ABI-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \langle size, align \rangle}$$

**(ABI-Array)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T, e)) = size \quad \Gamma \vdash \text{alignof}(\text{TypeArray}(T, e)) = align}{\Gamma \vdash \text{ABITy}(\text{TypeArray}(T, e)) \Downarrow \langle size, align \rangle}$$

**(ABI-Slice)**
$$\frac{T = \text{TypeSlice}(U)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Range)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeRange}) = size \quad \Gamma \vdash \text{alignof}(\text{TypeRange}) = align}{\Gamma \vdash \text{ABITy}(\text{TypeRange}) \Downarrow \langle size, align \rangle}$$

**(ABI-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Dynamic)**
$$\frac{\Gamma \vdash \text{DynLayout}(Cl) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(\text{TypeDynamic}(Cl)) \Downarrow \langle size, align \rangle}$$

**(ABI-StringBytes)**
$$\frac{T \in \{\text{TypeString}(\texttt{@View}), \text{TypeString}(\texttt{@Managed}), \text{TypeBytes}(\texttt{@View}), \text{TypeBytes}(\texttt{@Managed})\} \quad \Gamma \vdash \text{sizeof}(T) = size \quad \Gamma \vdash \text{alignof}(T) = align}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

#### 6.2.3. ABI Parameter and Return Passing

$$\text{PassKind} = \{\texttt{ByValue},\ \texttt{ByRef},\ \texttt{SRet}\}$$
$$\text{ByValMax} = 2 \times \text{PtrSize}$$
$$\text{ByValAlign} = \text{PtrAlign}$$
$$\text{ByValOk}(T) \iff \Gamma \vdash \text{sizeof}(T) = n \land \Gamma \vdash \text{alignof}(T) = a \land n \le \text{ByValMax} \land a \le \text{ByValAlign}$$
$$\text{ABIParamJudg} = \{\text{ABIParam}\}$$
$$\text{ABIRetJudg} = \{\text{ABIRet}\}$$
$$\text{ABICallJudg} = \{\text{ABICall}\}$$

**(ABI-Param-ByRef-Alias)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{sizeof}(T) = n}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef}}$$

**(ABI-Param-ByValue-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{sizeof}(T) = 0 \ \lor\ \text{ByValOk}(T)}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByValue}}$$

**(ABI-Param-ByRef-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{sizeof}(T) = n \quad n > 0 \quad \neg \text{ByValOk}(T)}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef}}$$

**(ABI-Ret-ByValue)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = 0 \ \lor\ \text{ByValOk}(T)}{\Gamma \vdash \text{ABIRet}(T) \Downarrow \texttt{ByValue}}$$

**(ABI-Ret-ByRef)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = n \quad n > 0 \quad \neg \text{ByValOk}(T)}{\Gamma \vdash \text{ABIRet}(T) \Downarrow \texttt{SRet}}$$

**(ABI-Call)**
$$\frac{\forall i,\ \Gamma \vdash \text{ABIParam}(m_i, T_i) \Downarrow k_i \quad \Gamma \vdash \text{ABIRet}(R) \Downarrow k_r}{\Gamma \vdash \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \Downarrow \langle [k_1,\ldots,k_n], k_r, (k_r = \texttt{SRet}) \rangle}$$

**Panic Out-Parameter (Cursive0).**

$$\text{PanicRecordFields} = [\langle \texttt{panic}, \text{TypePrim}(\texttt{"bool"}) \rangle,\ \langle \texttt{code}, \text{TypePrim}(\texttt{"u32"}) \rangle]$$
$$\text{PanicRecordLayout} = \text{RecordLayout}(\text{PanicRecordFields})$$
$$\text{PanicRecordFieldsOf}(\text{PanicRecord}) = \text{PanicRecordFields}$$
$$\text{PanicRecordLayoutOf}(\text{PanicRecord}) = \text{PanicRecordLayout}$$

$$\text{PanicOutType} = \text{TypeRawPtr}(\texttt{mut}, \text{PanicRecord})$$
$$\text{PanicOutName} = \texttt{"__panic"}$$

$$\text{NeedsPanicOut}(callee) \iff callee \ne \text{RecordCtor}(\_) \land callee \ne \text{EntrySym} \land \text{RuntimeSig}(callee)\ \text{undefined}.$$

$$\text{PanicOutParams}(params, callee) =
\begin{cases}
params \mathbin{+\!\!+} [\langle \texttt{move},\ \text{PanicOutName},\ \text{PanicOutType} \rangle] & \text{if } \text{NeedsPanicOut}(callee)\\
params & \text{otherwise}
\end{cases}$$

#### 6.2.4. Call Lowering for Procedures and Methods

$$\text{LowerCallJudg} = \{\text{MethodSymbol},\ \text{BuiltinMethodSym},\ \text{LowerMethodCall},\ \text{LowerArgs},\ \text{LowerRecvArg}\}$$
$$\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \iff \text{StripPerm}(T) = \text{TypeModalState}(p, S)$$
$$\text{BuiltinCapClass} = \{\texttt{FileSystem},\ \texttt{HeapAllocator}\}$$

**(MethodSymbol-Record)**
$$\frac{\text{LookupMethod}(T, name) = m \quad m = \text{MethodDecl}(\_) \quad \Gamma \vdash \text{Mangle}(m) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-Default)**
$$\frac{\text{LookupMethod}(T, name) = m \quad m = \text{ClassMethodDecl}(\_) \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-ModalState-Method)**
$$\frac{\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \quad \text{LookupStateMethod}(S, name) = md \quad \Gamma \vdash \text{Mangle}(md) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-ModalState-Transition)**
$$\frac{\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \quad \text{LookupTransition}(S, name) = tr \quad \Gamma \vdash \text{Mangle}(tr) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(BuiltinMethodSym-FileSystem)**
$$\frac{\text{BuiltinSym}(\texttt{FileSystem}::name) \Downarrow sym}{\Gamma \vdash \text{BuiltinMethodSym}(\texttt{FileSystem}, name) \Downarrow sym}$$

**(BuiltinMethodSym-HeapAllocator)**
$$\frac{\text{BuiltinSym}(\texttt{HeapAllocator}::name) \Downarrow sym}{\Gamma \vdash \text{BuiltinMethodSym}(\texttt{HeapAllocator}, name) \Downarrow sym}$$

**(Lower-Args-Empty)**
$$\frac{}{\Gamma \vdash \text{LowerArgs}([], []) \Downarrow \langle \epsilon, [] \rangle}$$

**(Lower-Args-Cons-Move)**
$$\frac{\Gamma \vdash \text{LowerExpr}(\text{MovedArg}(moved, e)) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerArgs}(ps, as) \Downarrow \langle IR_a, \vec{v} \rangle}{\Gamma \vdash \text{LowerArgs}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as) \Downarrow \langle \text{SeqIR}(IR_e, IR_a), [v] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(Lower-Args-Cons-Ref)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(e) \Downarrow \langle IR_e, addr \rangle \quad \Gamma \vdash \text{LowerArgs}(ps, as) \Downarrow \langle IR_a, \vec{v} \rangle}{\Gamma \vdash \text{LowerArgs}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as) \Downarrow \langle \text{SeqIR}(IR_e, IR_a), [\text{Ptr@Valid}(addr)] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(Lower-RecvArg-Move)**
$$\frac{base = \text{MoveExpr}(p) \quad \Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle}{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle}$$

**(Lower-RecvArg-Ref)**
$$\frac{base \ne \text{MoveExpr}(\_) \quad \Gamma \vdash \text{LowerAddrOf}(base) \Downarrow \langle IR_b, addr \rangle}{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, \text{Ptr@Valid}(addr) \rangle}$$

**(Lower-MethodCall-Static-PanicOut)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad T = \text{ExprType}(base) \quad T \ne \text{TypeDynamic}(\_) \quad \text{LookupMethod}(T, name) = m \quad \text{MethodSymbol}(T, name) \Downarrow sym \quad \text{NeedsPanicOut}(sym)}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]), \text{PanicCheck}), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Static-NoPanicOut)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad T = \text{ExprType}(base) \quad T \ne \text{TypeDynamic}(\_) \quad \text{LookupMethod}(T, name) = m \quad \text{MethodSymbol}(T, name) \Downarrow sym \quad \neg \text{NeedsPanicOut}(sym)}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Capability)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{ExprType}(base) = \text{TypeDynamic}(Cl) \quad Cl \in \text{BuiltinCapClass} \quad \text{LookupClassMethod}(Cl, name) = m \quad \Gamma \vdash \text{BuiltinMethodSym}(Cl, name) \Downarrow sym}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Dynamic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{ExprType}(base) = \text{TypeDynamic}(Cl) \quad Cl \notin \text{BuiltinCapClass} \quad \text{LookupClassMethod}(Cl, name) = m \quad \Gamma \vdash \text{LowerDynCall}(v_{\text{self}}, name, \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]) \Downarrow IR_d}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, IR_d), v_{\text{call}} \rangle}$$

$$\text{SeqIR}() = \epsilon$$
$$\text{SeqIR}(IR) = IR$$
$$\text{SeqIR}(IR_1,\ldots,IR_n) = \text{SeqIR}(IR_1,\ \text{SeqIR}(IR_2,\ldots,IR_n))\quad(n \ge 2)$$

### 6.3. Symbols, Mangling, and Linkage

#### 6.3.1. Symbol Names and Mangling

$$\text{MangleJudg} = \{\text{Mangle}\}$$
$$\text{VTableDecl}(T, Cl)\ \text{constructor}$$
$$\text{LiteralData}(kind, contents)\ \text{constructor}$$
$$\text{DefaultImpl}(T, m)\ \text{constructor}$$

$$\text{Join}(sep, []) = \texttt{"\""}$$
$$\text{Join}(sep, [s]) = s$$
$$\text{Join}(sep, [s_1,\ldots,s_n]) = s_1 \mathbin{+\!\!+} sep \mathbin{+\!\!+} \text{Join}(sep, [s_2,\ldots,s_n])\quad(n \ge 2)$$
$$\text{PathSig}(p) = \text{mangle}(\text{PathString}(p))$$

$$\text{ItemPath}(it) = \text{PathOfModule}(\text{ModuleOf}(it)) \mathbin{+\!\!+} [name] \iff it = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc)$$
$$\text{ItemPath}(m) = \text{RecordPath}(R) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{Methods}(R)$$
$$\text{ItemPath}(m) = \text{ClassPath}(Cl) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{ClassMethods}(Cl)$$
$$\text{ItemPath}(m) = \text{ModalPath}(M) \mathbin{+\!\!+} [S] \mathbin{+\!\!+} [m.\text{name}] \iff S \in \text{States}(M) \land m \in \text{Methods}(S)$$
$$\text{ItemPath}(tr) = \text{ModalPath}(M) \mathbin{+\!\!+} [S] \mathbin{+\!\!+} [tr.\text{name}] \iff S \in \text{States}(M) \land tr \in \text{Transitions}(S)$$
$$\text{ItemPath}(it) = \text{PathOfModule}(\text{ModuleOf}(it)) \mathbin{+\!\!+} [\text{StaticName}(binding)] \iff it = \text{StaticDecl}(vis, mut, binding, span, doc) \land \text{StaticName}(binding) \ne \bot$$
$$\text{ItemPath}(\text{StaticBinding}(\text{StaticDecl}(vis, mut, binding, span, doc), x)) = \text{PathOfModule}(\text{ModuleOf}(\text{StaticDecl}(vis, mut, binding, span, doc))) \mathbin{+\!\!+} [x]$$
$$\text{ItemPath}(\text{VTableDecl}(T, Cl)) = [\texttt{"vtable"}] \mathbin{+\!\!+} \text{PathOfType}(T) \mathbin{+\!\!+} [\texttt{"cl"}] \mathbin{+\!\!+} \text{ClassPath}(Cl)$$
$$\text{ItemPath}(\text{DefaultImpl}(T, m)) = [\texttt{"default"}] \mathbin{+\!\!+} \text{PathOfType}(T) \mathbin{+\!\!+} [\texttt{"cl"}] \mathbin{+\!\!+} \text{ClassPath}(Cl) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{ClassMethods}(Cl)$$

$$\text{TypeStateName}(\texttt{View}) = \texttt{"view"}$$
$$\text{TypeStateName}(\texttt{Managed}) = \texttt{"managed"}$$
$$\text{PathOfType}(\text{TypePrim}(name)) = [\texttt{"prim"}, name]$$
$$\text{PathOfType}(\text{TypeString}(st)) = [\texttt{"string"}, \text{TypeStateName}(st)]$$
$$\text{PathOfType}(\text{TypeBytes}(st)) = [\texttt{"bytes"}, \text{TypeStateName}(st)]$$
$$\text{PathOfType}(\text{TypePath}(p)) = p$$
$$\text{PathOfType}(\text{TypeModalState}(p, S)) = p \mathbin{+\!\!+} [S]$$
$$\text{PathOfType}(T) = \bot \iff T \notin \{\text{TypePrim}(\_),\ \text{TypeString}(\_),\ \text{TypeBytes}(\_),\ \text{TypePath}(\_),\ \text{TypeModalState}(\_,\_)\}$$
$$\text{ClassPath}(Cl) = p \iff \Sigma.\text{Classes}[p] = Cl$$

**Literal Identity.**

$$\text{FNVOffset64} = 14695981039346656037$$
$$\text{FNVPrime64} = 1099511628211$$
$$\text{FNV1a64}([]) = \text{FNVOffset64}$$
$$\text{FNV1a64}([b_1,\ldots,b_n]) = h_n \iff h_0 = \text{FNVOffset64} \land \forall i \in 0..n{-}1.\ h_{i+1} = ((h_i \oplus b_{i+1}) \times \text{FNVPrime64}) \bmod 2^{64}$$
$$\text{Hex64}(h) = \text{Join}(\texttt{"\""}, [\text{Hex2}(b_1),\ldots,\text{Hex2}(b_8)]) \iff \text{rev}(\text{LEBytes}(h, 8)) = [b_1,\ldots,b_8]$$
$$\text{LiteralID}(kind, contents) = \text{mangle}(kind) \mathbin{+\!\!+} \texttt{"_"} \mathbin{+\!\!+} \text{Hex64}(\text{FNV1a64}(contents))$$

**Mangle Rules.**

$$\text{ScopedSym}(item) = \text{PathSig}(\text{ItemPath}(item))$$

**(Mangle-Proc)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc) \quad name \ne \texttt{"main"}}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Main)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, \texttt{"main"}, params, ret\_opt, body, span, doc) \quad \text{MainSigOk}(\text{item})}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Record-Method)**
$$\frac{\text{item} = \text{MethodDecl}(vis, override, name, receiver, params, ret\_opt, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Class-Method)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-State-Method)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Transition)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Static)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) \ne \bot}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-StaticBinding)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(_,_, binding,_,_), x)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-VTable)**
$$\frac{\text{item} = \text{VTableDecl}(T, Cl)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Literal)**
$$\frac{\text{item} = \text{LiteralData}(kind, contents) \quad \text{LiteralID}(kind, contents) = id}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"literal"}, id])}$$

**(Mangle-DefaultImpl)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

#### 6.3.4. Linkage for Generated Symbols

$$\text{LinkageKind} = \{\texttt{internal},\ \texttt{external}\}$$
$$\text{LinkageJudg} = \{\text{Linkage}\}$$

**(Linkage-UserItem)**
$$\frac{\text{item} \in \{\text{ProcedureDecl}, \text{StaticDecl}, \text{MethodDecl}\} \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-UserItem-Internal)**
$$\frac{\text{item} \in \{\text{ProcedureDecl}, \text{StaticDecl}, \text{MethodDecl}\} \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-StaticBinding)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(vis,\_,\_,\_,\_), x) \quad vis \in \{\texttt{public},\texttt{internal}\} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-StaticBinding-Internal)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(vis,\_,\_,\_,\_), x) \quad vis = \texttt{private} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-ClassMethod)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt) \quad body\_opt \ne \bot \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-ClassMethod-Internal)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt) \quad body\_opt \ne \bot \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-StateMethod)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt) \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-StateMethod-Internal)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt) \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-Transition)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt) \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-Transition-Internal)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt) \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-InitFn)**
$$\frac{\text{InitFn}(m) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DeinitFn)**
$$\frac{\text{DeinitFn}(m) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-VTable)**
$$\frac{\text{Mangle}(\text{VTableDecl}(T, Cl)) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-LiteralData)**
$$\frac{\text{Mangle}(\text{LiteralData}(kind, contents)) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DropGlue)**
$$\frac{\text{DropGlueSym}(T) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DefaultImpl)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m) \quad \text{Vis}(m) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-DefaultImpl-Internal)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m) \quad \text{Vis}(m) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-PanicSym)**
$$\frac{\text{PanicSym} \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-RegionSym)**
$$\frac{\text{RegionSym}(proc) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-BuiltinSym)**
$$\frac{\text{BuiltinSym}(method) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-EntrySym)**
$$\frac{\text{EntrySym} \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

### 6.4. Expression Lowering and Evaluation Order

$$\text{EvalOrderJudg} = \{\text{Children\_LTR}\}$$

**(ArgsExprs-Empty)**
$$\text{ArgsExprs}([]) = []$$

**(ArgsExprs-Cons)**
$$\text{ArgsExprs}([\langle moved, e, span \rangle] \mathbin{+\!\!+} rest) = [e] \mathbin{+\!\!+} \text{ArgsExprs}(rest)$$

**(FieldExprs-Empty)**
$$\text{FieldExprs}([]) = []$$

**(FieldExprs-Cons)**
$$\text{FieldExprs}([\langle f, e \rangle] \mathbin{+\!\!+} rest) = [e] \mathbin{+\!\!+} \text{FieldExprs}(rest)$$

**(OptExprs-None)**
$$\text{OptExprs}(\bot, \bot) = []$$

**(OptExprs-Lo)**
$$\text{OptExprs}(e, \bot) = [e]$$

**(OptExprs-Hi)**
$$\text{OptExprs}(\bot, e) = [e]$$

**(OptExprs-Both)**
$$\text{OptExprs}(e_1, e_2) = [e_1, e_2]$$

$$\text{LowerExprJudg} = \{\text{LowerExpr},\ \text{LowerUnOp},\ \text{LowerBinOp},\ \text{LowerCast},\ \text{LowerList},\ \text{LowerFieldInits},\ \text{LowerOpt},\ \text{LowerReadPlace},\ \text{LowerWritePlace},\ \text{LowerMovePlace},\ \text{LowerAddrOf},\ \text{LowerPlace}\}$$

**(EvalOrder-Literal)** `Children_LTR(Literal(â„“)) = []`.

**(EvalOrder-PtrNull)** `Children_LTR(PtrNullExpr) = []`.
  
**(EvalOrder-Ident)** `Children_LTR(Identifier(x)) = []`.
  
**(EvalOrder-Path)** `Children_LTR(Path(path, name)) = []`.
  
**(EvalOrder-Tuple)** `Children_LTR(TupleExpr(es)) = es`.
  
**(EvalOrder-Array)** `Children_LTR(ArrayExpr(es)) = es`.
  
**(EvalOrder-Record)** `Children_LTR(RecordExpr(tr, fields)) = FieldExprs(fields)`.
  
**(EvalOrder-Enum-Unit)** `Children_LTR(EnumLiteral(path, âŠ¥)) = []`.
  
**(EvalOrder-Enum-Tuple)** `Children_LTR(EnumLiteral(path, Paren(es))) = es`.
  
**(EvalOrder-Enum-Record)** `Children_LTR(EnumLiteral(path, Brace(fields))) = FieldExprs(fields)`.
  
**(EvalOrder-FieldAccess)** `Children_LTR(FieldAccess(base, f)) = [base]`.
  
**(EvalOrder-TupleAccess)** `Children_LTR(TupleAccess(base, i)) = [base]`.
  
**(EvalOrder-IndexAccess)** `Children_LTR(IndexAccess(base, idx)) = [base, idx]`.
  
**(EvalOrder-Call)** `Children_LTR(Call(callee, args)) = [callee] \mathbin{+\!\!+} ArgsExprs(args)`.
  
**(EvalOrder-MethodCall)** `Children_LTR(MethodCall(base, name, args)) = [base] \mathbin{+\!\!+} ArgsExprs(args)`.
  
**(EvalOrder-Unary)** `Children_LTR(Unary(op, e)) = [e]`.
  
**(EvalOrder-Binary)** `Children_LTR(Binary(op, e_1, e_2)) = [e_1, e_2]`.
  
**(EvalOrder-Cast)** `Children_LTR(Cast(e, T)) = [e]`.
  
**(EvalOrder-Transmute)** `Children_LTR(TransmuteExpr(T_1, T_2, e)) = [e]`.
  
**(EvalOrder-Propagate)** `Children_LTR(Propagate(e)) = [e]`.
  
**(EvalOrder-Range)** `Children_LTR(Range(kind, lo_opt, hi_opt)) = OptExprs(lo_opt, hi_opt)`.
  
**(EvalOrder-If)** `Children_LTR(IfExpr(cond, b1, b2)) = [cond]`.
  
**(EvalOrder-Match)** `Children_LTR(MatchExpr(scrut, arms)) = [scrut]`.
  
**(EvalOrder-Loop)** `Children_LTR(LoopInfinite(body)) = [body]`, `Children_LTR(LoopConditional(cond, body)) = [cond, body]`, `Children_LTR(LoopIter(pat, ty_opt, iter, body)) = [iter, body]`.
  
**(EvalOrder-Block)** `Children_LTR(BlockExpr(stmts, tail_opt)) = []`.
  
**(EvalOrder-UnsafeBlock)** `Children_LTR(UnsafeBlockExpr(b)) = []`.
  
**(EvalOrder-Move)** `Children_LTR(MoveExpr(p)) = []`.
  
**(EvalOrder-AddressOf)** `Children_LTR(AddressOf(p)) = []`.
  
**(EvalOrder-Deref)** `Children_LTR(Deref(e)) = [e]`.
  
**(EvalOrder-Alloc)** `Children_LTR(AllocExpr(r_opt, e)) = [e]`.

$$\text{RetType}(\Gamma) = R \iff \text{ProcRet}(\Gamma) = R$$

**(Lower-Expr-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle}$$

$$\text{ExprForms0} = \{\text{Literal}(\_),\ \text{PtrNullExpr},\ \text{Identifier}(\_),\ \text{Path}(\_,\_),\ \text{ErrorExpr}(\_),\ \text{TupleExpr}(\_),\ \text{ArrayExpr}(\_),\ \text{RecordExpr}(\_,\_),\ \text{EnumLiteral}(\_,\_),\ \text{FieldAccess}(\_,\_),\ \text{TupleAccess}(\_,\_),\ \text{IndexAccess}(\_,\_),\ \text{Call}(\_,\_),\ \text{MethodCall}(\_,\_,\_),\ \text{Unary}(\_,\_),\ \text{Binary}(\_,\_,\_),\ \text{Cast}(\_,\_),\ \text{TransmuteExpr}(\_,\_,\_),\ \text{Propagate}(\_),\ \text{Range}(\_,\_,\_),\ \text{IfExpr}(\_,\_,\_),\ \text{MatchExpr}(\_,\_),\ \text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_),\ \text{BlockExpr}(\_,\_),\ \text{UnsafeBlockExpr}(\_),\ \text{MoveExpr}(\_),\ \text{AddressOf}(\_),\ \text{Deref}(\_),\ \text{AllocExpr}(\_,\_)\}$$
$$\text{LowerExprTotal}(\Gamma) \iff \forall e.\ e \in \text{ExprForms0} \Rightarrow \exists IR, v.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle$$

$$\text{ExecIRJudg} = \{\text{ExecIRSigma},\ \text{MoveStateSigma}\}$$

**(ExecIR-ReadVar)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\text{ExecIRSigma}(\text{ReadVarIR}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ExecIR-ReadPath)**
$$\frac{\text{LookupValPath}(\sigma, path, name) = v}{\text{ExecIRSigma}(\text{ReadPathIR}(path, name), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ExecIR-StoreVar)**
$$\frac{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{StoreVarIR}(x, v), \sigma) \Downarrow (sout, \sigma')}$$

**(ExecIR-StoreVarNoDrop)**
$$\frac{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{StoreVarNoDropIR}(x, v), \sigma) \Downarrow (sout, \sigma')}$$

**(ExecIR-BindVar)**
$$\frac{\text{BindVal}(\sigma, x, v) \Downarrow (\sigma', b)}{\text{ExecIRSigma}(\text{BindVarIR}(x, v), \sigma) \Downarrow (ok, \sigma')}$$

**(ExecIR-ReadPtr)**
$$\frac{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{ReadPtrIR}(v_{ptr}), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-WritePtr)**
$$\frac{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{WritePtrIR}(v_{ptr}, v), \sigma) \Downarrow (sout, \sigma')}$$

$$\text{AllocTarget}(\sigma, \bot) = \text{ActiveTarget}(\sigma)$$
$$\text{AllocTarget}(\sigma, r) = \text{ResolveTarget}(\sigma, r)$$

**(ExecIR-Alloc)**
$$\frac{\text{AllocTarget}(\sigma, r_{opt}) = r \quad \text{RegionAlloc}(\sigma, r, v) \Downarrow (\sigma', v')}{\text{ExecIRSigma}(\text{AllocIR}(r_{opt}, v), \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(MoveState-Root)**
$$\frac{\text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = \bot \quad \text{LookupBind}(\sigma, x) = b \quad \text{SetState}(\sigma, b, \text{Moved}) \Downarrow \sigma'}{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}$$

**(MoveState-Field)**
$$\frac{\text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{LookupBind}(\sigma, x) = b \quad \text{BindState}(\sigma, b) = s \quad \text{PM}(s, f) = s' \quad \text{SetState}(\sigma, b, s') \Downarrow \sigma'}{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}$$

**(ExecIR-MoveState)**
$$\frac{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}{\text{ExecIRSigma}(\text{MoveStateIR}(p), \sigma) \Downarrow (ok, \sigma')}$$

**(ExecIR-Return)**
$$\frac{}{ \text{ExecIRSigma}(\text{ReturnIR}(v), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v)), \sigma)}$$

**(ExecIR-Result)**
$$\frac{}{ \text{ExecIRSigma}(\text{ResultIR}(v), \sigma) \Downarrow (\text{Ctrl}(\text{Result}(v)), \sigma)}$$

**(ExecIR-Break)**
$$\frac{}{ \text{ExecIRSigma}(\text{BreakIR}(v_{opt}), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{opt})), \sigma)}$$

**(ExecIR-Continue)**
$$\frac{}{ \text{ExecIRSigma}(\text{ContinueIR}, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma)}$$

**(ExecIR-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\text{ExecIRSigma}(\text{DeferIR}(b), \sigma) \Downarrow (ok, \sigma')}$$

$$\text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma) \Downarrow (out, \sigma') \iff \text{ExecIRSigma}(IR_s, \sigma) \Downarrow (sout, \sigma_1) \land \Big((sout = ok \land IR_t = \epsilon \land out = \text{Val}(()) \land \sigma' = \sigma_1)\ \lor\ (sout = ok \land \text{ExecIRSigma}(IR_t, \sigma_1) \Downarrow (out, \sigma'))\ \lor\ (sout = \text{Ctrl}(\text{Result}(v)) \land out = \text{Val}(v) \land \sigma' = \sigma_1)\ \lor\ (sout = \text{Ctrl}(\kappa) \land \kappa \ne \text{Result}(\_) \land out = \text{Ctrl}(\kappa) \land \sigma' = \sigma_1)\Big)$$
$$\Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma, scope) \Downarrow (out, \sigma') \iff \text{CurrentScopeId}(\sigma) = scope \land \text{ExecIRSigma}(IR_b, \sigma) \Downarrow (out, \sigma')$$
$$\Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (out', \sigma'') \iff \text{BindPatternVal}(pat, v) \Downarrow B \land \text{BindOrder}(pat, B) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

**(ExecIR-If-True)**
$$\frac{v_c = \text{true} \quad \text{ExecIRSigma}(IR_t, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-If-False)**
$$\frac{v_c = \text{false} \quad \text{ExecIRSigma}(IR_f, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-Block)**
$$\frac{\text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope) \quad \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{BlockIR}(IR_s, IR_t, v_t), \sigma) \Downarrow (out', \sigma_3)}$$

**(ExecIR-Match)**
$$\frac{\Gamma \vdash \text{MatchArmsSigma}(arms, v_s, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{MatchIR}(v_s, arms), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-Loop-Infinite-Step)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Infinite-Continue)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Infinite-Break)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_1) \quad v = \text{BreakVal}(v_{\text{opt}})}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(ExecIR-Loop-Infinite-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Loop-Cond-False)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(ExecIR-Loop-Cond-True-Step)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma_2) \Downarrow (out, \sigma_3)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (out, \sigma_3)}$$

**(ExecIR-Loop-Cond-Continue)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_2) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma_2) \Downarrow (out, \sigma_3)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (out, \sigma_3)}$$

**(ExecIR-Loop-Cond-Break)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_2) \quad v = \text{BreakVal}(v_{\text{opt}})}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(ExecIR-Loop-Cond-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Loop-Cond-Body-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

$$\text{LoopIterIRJudg} = \{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma')\}$$

**(ExecIR-Loop-Iter)**
$$\frac{\text{ExecIRSigma}(IR_i, \sigma) \Downarrow (\text{Val}(v_{\text{iter}}), \sigma_1) \quad \text{IterInit}(v_{\text{iter}}) \Downarrow it \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Iter-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_i, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(LoopIterIR-Done)**
$$\frac{\text{IterNext}(it) \Downarrow (\bot, it')}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Val}(()), \sigma)}$$

**(LoopIterIR-Step-Val)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIterIR-Step-Continue)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIterIR-Step-Break)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_1) \quad v' = \text{BreakVal}(v_{\text{opt}})}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(LoopIterIR-Step-Ctrl)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Region)**
$$\frac{\text{RegionNew}(\sigma, v_o) \Downarrow (\sigma_1, r, scope) \quad \text{BindRegionAlias}(\sigma_1, alias\_opt, r) \Downarrow \sigma_2 \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_2, scope) \Downarrow (out, \sigma_3) \quad \text{RegionRelease}(\sigma_3, r, scope, out) \Downarrow (out', \sigma_4)}{\text{ExecIRSigma}(\text{RegionIR}(v_o, alias\_opt, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_4)}$$

**(ExecIR-Frame-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r, scope, mark, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{FrameIR}(\bot, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**(ExecIR-Frame-Explicit)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r_t, scope, mark, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{FrameIR}(v_r, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**Lowering Helpers.**

**(LowerList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerList}([]) \Downarrow \langle \epsilon, [] \rangle }$$

**(LowerList-Cons)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR_s, \vec{v} \rangle}{\Gamma \vdash \text{LowerList}(e::es) \Downarrow \langle \text{SeqIR}(IR_e, IR_s), [v] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(LowerFieldInits-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerFieldInits}([]) \Downarrow \langle \epsilon, [] \rangle }$$

**(LowerFieldInits-Cons)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerFieldInits}(fs) \Downarrow \langle IR_s, \vec{f} \rangle}{\Gamma \vdash \text{LowerFieldInits}([\langle f, e \rangle] \mathbin{+\!\!+} fs) \Downarrow \langle \text{SeqIR}(IR_e, IR_s), [\langle f, v \rangle] \mathbin{+\!\!+} \vec{f} \rangle}$$

**(LowerOpt-None)**
$$\frac{}{ \Gamma \vdash \text{LowerOpt}(\bot) \Downarrow \langle \epsilon, \bot \rangle }$$

**(LowerOpt-Some)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerOpt}(e) \Downarrow \langle IR_e, v \rangle}$$

$$\text{IsRangeExpr}(e) \iff \text{ExprType}(e) = \text{TypeRange}$$

**Expression Lowering.** The rules below define `LowerExpr`.

**(Lower-Expr-Literal)**
$$\frac{T = \text{ExprType}(\text{Literal}(\ell)) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{LowerExpr}(\text{Literal}(\ell)) \Downarrow \langle \epsilon, v \rangle}$$

**(Lower-Expr-PtrNull)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{PtrNullExpr}) \Downarrow \langle \epsilon, \text{Ptr@Null}(0x0) \rangle }$$

**(Lower-Expr-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot \quad \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(x)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path}{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(x)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle}$$

**(Lower-Expr-Path)**
$$\frac{}{\Gamma \vdash \text{LowerExpr}(\text{Path}(path, name)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle}$$

**(Lower-Expr-Error)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{ErrorExpr}(span)) \Downarrow \langle \text{LowerPanic}(\text{ErrorExpr}(span)), v_{\text{unreach}} \rangle }$$

**(Lower-Expr-Tuple)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{TupleExpr}(es)) \Downarrow \langle IR, (v_1,\ldots,v_n) \rangle}$$

**(Lower-Expr-Array)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{ArrayExpr}(es)) \Downarrow \langle IR, [v_1,\ldots,v_n] \rangle}$$

**(Lower-Expr-Record)**
$$\frac{\Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR, \vec{f} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{RecordExpr}(tr, fields)) \Downarrow \langle IR, \text{RecordValue}(tr, \vec{f}) \rangle}$$

**(Lower-Expr-Enum-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \bot)) \Downarrow \langle \epsilon, \text{EnumValue}(path, \bot) \rangle }$$

**(Lower-Expr-Enum-Tuple)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \text{Paren}(es))) \Downarrow \langle IR, \text{EnumValue}(path, \text{TuplePayload}(\vec{v})) \rangle}$$

**(Lower-Expr-Enum-Record)**
$$\frac{\Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR, \vec{f} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \text{Brace}(fields))) \Downarrow \langle IR, \text{EnumValue}(path, \text{RecordPayload}(\vec{f})) \rangle}$$

**(Lower-Expr-FieldAccess)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \text{FieldValue}(v_b, f) = v_f}{\Gamma \vdash \text{LowerExpr}(\text{FieldAccess}(base, f)) \Downarrow \langle IR_b, v_f \rangle}$$

**(Lower-Expr-TupleAccess)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \text{TupleValue}(v_b, i) = v_i}{\Gamma \vdash \text{LowerExpr}(\text{TupleAccess}(base, i)) \Downarrow \langle IR_b, v_i \rangle}$$

**(Lower-Expr-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_b), v_i) \Downarrow ok \quad \text{IndexValue}(v_b, v_i) = v_e}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i), v_e \rangle}$$

**(Lower-Expr-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_b)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_b), v_r) \Downarrow ok \quad \text{SliceValue}(v_b, v_r) = v_s}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i), v_s \rangle}$$

**(Lower-Expr-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_b)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Call-PanicOut)**
$$\frac{\Gamma \vdash \text{LowerExpr}(callee) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerArgs}(\text{Params}(\text{Call}(callee, args)), args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{NeedsPanicOut}(callee)}{\Gamma \vdash \text{LowerExpr}(\text{Call}(callee, args)) \Downarrow \langle \text{SeqIR}(IR_c, IR_a, \text{CallIR}(v_c, \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]), \text{PanicCheck}), v_{\text{call}} \rangle}$$

**(Lower-Expr-Call-NoPanicOut)**
$$\frac{\Gamma \vdash \text{LowerExpr}(callee) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerArgs}(\text{Params}(\text{Call}(callee, args)), args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \neg \text{NeedsPanicOut}(callee)}{\Gamma \vdash \text{LowerExpr}(\text{Call}(callee, args)) \Downarrow \langle \text{SeqIR}(IR_c, IR_a, \text{CallIR}(v_c, \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-Expr-MethodCall)**
$$\frac{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle IR, v_{\text{call}} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MethodCall}(base, name, args)) \Downarrow \langle IR, v_{\text{call}} \rangle}$$

**(Lower-Expr-Unary)**
$$\frac{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Unary}(op, e)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Bin-And)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(\texttt{"&&"}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, \text{IfIR}(v_1, IR_2, v_2, \epsilon, \text{false})), v_{\text{and}} \rangle}$$

**(Lower-Expr-Bin-Or)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(\texttt{"||"}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, \text{IfIR}(v_1, \epsilon, \text{true}, IR_2, v_2)), v_{\text{or}} \rangle}$$

**(Lower-Expr-Binary)**
$$\frac{op \notin \{\texttt{"&&"},\ \texttt{"||"}\} \quad \Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(op, e_1, e_2)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Cast)**
$$\frac{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Cast}(e, T)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Transmute)**
$$\frac{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{TransmuteExpr}(T_1, T_2, e)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Propagate-Success)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_s, v_s \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Propagate}(e)) \Downarrow \langle IR_e, v_s \rangle}$$

**(Lower-Expr-Propagate-Return)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_e, v_e \rangle \quad T_e \ne T_s}{\Gamma \vdash \text{LowerExpr}(\text{Propagate}(e)) \Downarrow \langle \text{SeqIR}(IR_e, \text{ReturnIR}(v_e)), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Range)**
$$\frac{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(kind, lo\_opt, hi\_opt)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Range}(kind, lo\_opt, hi\_opt)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-If)**
$$\frac{\Gamma \vdash \text{LowerExpr}(cond) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerBlock}(b_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerBlock}(b_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{IfExpr}(cond, b_1, b_2)) \Downarrow \langle \text{SeqIR}(IR_c, \text{IfIR}(v_c, IR_1, v_1, IR_2, v_2)), v_{\text{if}} \rangle}$$

**(Lower-Expr-Match)**
$$\frac{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MatchExpr}(scrut, arms)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopInf)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopInfinite}(body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopInfinite}(body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopCond)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopConditional}(cond, body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopConditional}(cond, body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopIter)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Block)**
$$\frac{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{UnsafeBlockExpr}(b)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Move)**
$$\frac{\Gamma \vdash \text{LowerMovePlace}(p) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MoveExpr}(p)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-AddressOf)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR, addr \rangle}{\Gamma \vdash \text{LowerExpr}(\text{AddressOf}(p)) \Downarrow \langle IR, \text{Ptr@Valid}(addr) \rangle}$$

**(Lower-Expr-Deref)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v_{ptr} \rangle \quad \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_d, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Deref}(e)) \Downarrow \langle \text{SeqIR}(IR_e, IR_d), v \rangle}$$

**(Lower-Expr-Alloc)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{AllocExpr}(r\_opt, e)) \Downarrow \langle \text{SeqIR}(IR_e, \text{AllocIR}(r\_opt, v)), v_{\text{alloc}} \rangle}$$

**Operator and Cast Lowering.**

$$\text{OpPanicReason}(op, v) = r$$
$$\text{OpPanicReason}(op, v_1, v_2) = r$$
$$\text{OpPanicReason}(op, v) =
\begin{cases}
\text{Overflow} & op = \texttt{"-"}\\
\text{Other} & \text{otherwise}
\end{cases}$$
$$\text{OpPanicReason}(op, v_1, v_2) =
\begin{cases}
\text{DivZero} & op \in \{\texttt{"/"},\ \texttt{"%"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land v_2 = 0\\
\text{Overflow} & op \in \{\texttt{"/"},\ \texttt{"%"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land v_2 \ne 0\\
\text{Shift} & op \in \text{ShiftOps}\\
\text{Overflow} & op \in \{\texttt{"+"},\ \texttt{"-"},\ \texttt{"*"},\ \texttt{"**"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t)\\
\text{Other} & \text{otherwise}
\end{cases}$$

**(Lower-UnOp-Ok)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{UnOp}(op, v) \Downarrow v'}{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle IR_e, v' \rangle}$$

**(Lower-UnOp-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{UnOp}(op, v)\ \text{undefined} \quad \text{OpPanicReason}(op, v) = r \quad \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR_k}{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle \text{SeqIR}(IR_e, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-BinOp-Ok)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle \quad \text{BinOp}(op, v_1, v_2) \Downarrow v}{\Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), v \rangle}$$

**(Lower-BinOp-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle \quad \text{BinOp}(op, v_1, v_2)\ \text{undefined} \quad \text{OpPanicReason}(op, v_1, v_2) = r \quad \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR_k}{\Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle \text{SeqIR}(IR_1, IR_2, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Cast)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle IR, v' \rangle}$$

**(Lower-Cast-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v)\ \text{undefined} \quad \Gamma \vdash \text{LowerPanic}(\text{Cast}) \Downarrow IR_k}{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle \text{SeqIR}(IR, IR_k), v_{\text{unreach}} \rangle}$$

$$\text{PlaceForms0} = \{\text{Identifier}(\_),\ \text{FieldAccess}(\_,\_),\ \text{TupleAccess}(\_,\_),\ \text{IndexAccess}(\_,\_),\ \text{Deref}(\_)\}$$
$$\text{LowerPlaceTotal}(\Gamma) \iff \forall p.\ p \in \text{PlaceForms0} \Rightarrow \exists l.\ \Gamma \vdash \text{LowerPlace}(p) \Downarrow l$$
$$\text{LowerPlacePreserve}(\Gamma) \iff \forall p,l.\ \Gamma \vdash \text{LowerPlace}(p) \Downarrow l \Rightarrow (\forall \sigma, out, \sigma'.\ \Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (out, \sigma') \Rightarrow \Gamma \vdash \text{ReadPlaceSigma}(l, \sigma) \Downarrow (out, \sigma')) \land (\forall \sigma, v, sout, \sigma'.\ \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma) \Downarrow (sout, \sigma') \Rightarrow \Gamma \vdash \text{WritePlaceSigma}(l, v, \sigma) \Downarrow (sout, \sigma'))$$

**Place Lowering Rules.**

**(Lower-Place-Ident)**
$$\frac{}{ \Gamma \vdash \text{LowerPlace}(\text{Identifier}(x)) \Downarrow \text{Identifier}(x) }$$

**(Lower-Place-Field)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{FieldAccess}(p, f)) \Downarrow \text{FieldAccess}(l, f) }$$

**(Lower-Place-Tuple)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{TupleAccess}(p, i)) \Downarrow \text{TupleAccess}(l, i) }$$

**(Lower-Place-Index)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{IndexAccess}(p, idx)) \Downarrow \text{IndexAccess}(l, idx) }$$

**(Lower-Place-Deref)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{Deref}(p)) \Downarrow \text{Deref}(l) }$$

**Place Access Lowering.**

$$\text{DropOnAssignRoot}(p) \iff \text{PlaceRoot}(p) = x \land \Big((\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land ent.\text{origin\_opt} = \bot \land \text{BindInfo}(x).\text{mov} = \text{immov} \land \text{BindInfo}(x).\text{resp} = \text{resp}) \ \lor$$
$$\qquad (\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \land path = \text{PathOfModule}(mp) \land \text{StaticBindInfo}(path, name).\text{mov} = \text{immov} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp})\Big)$$

**(Lower-ReadPlace-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle \text{ReadVarIR}(x), v \rangle }$$

**(Lower-ReadPlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path}{ \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle }$$

**(Lower-ReadPlace-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldValue}(v_p, f) = v_f}{\Gamma \vdash \text{LowerReadPlace}(\text{FieldAccess}(p, f)) \Downarrow \langle IR_p, v_f \rangle}$$

**(Lower-ReadPlace-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleValue}(v_p, i) = v_i}{\Gamma \vdash \text{LowerReadPlace}(\text{TupleAccess}(p, i)) \Downarrow \langle IR_p, v_i \rangle}$$

**(Lower-ReadPlace-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexValue}(v_p, v_i) = v_e}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i), v_e \rangle}$$

**(Lower-ReadPlace-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-ReadPlace-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceValue}(v_p, v_r) = v_s}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i), v_s \rangle}$$

**(Lower-ReadPlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-ReadPlace-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_d, v \rangle}{\Gamma \vdash \text{LowerReadPlace}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_d), v \rangle}$$

**(Lower-AddrOf-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerAddrOf}(\text{Identifier}(x)) \Downarrow \langle \epsilon, \text{AddrOfBind}(x) \rangle }$$

**(Lower-AddrOf-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad \text{StaticAddr}(path, name) = addr \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerAddrOf}(\text{Identifier}(x)) \Downarrow \langle IR_p, addr \rangle }$$

**(Lower-AddrOf-Field)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad T_b = \text{ExprType}(p) \quad \text{FieldAddr}(T_b, addr, f) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{FieldAccess}(p, f)) \Downarrow \langle IR_p, addr' \rangle}$$

**(Lower-AddrOf-Tuple)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad T_b = \text{ExprType}(p) \quad \text{TupleAddr}(T_b, addr, i) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{TupleAccess}(p, i)) \Downarrow \langle IR_p, addr' \rangle}$$


**(Lower-AddrOf-Index)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_r, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad T_b = \text{ExprType}(p) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexAddr}(T_b, addr, v_i) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_r, IR_i), addr' \rangle}$$

**(Lower-AddrOf-Index-OOB)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_r, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_r, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-AddrOf-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid}) \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle IR_p, addr \rangle}$$

**(Lower-AddrOf-Deref-Null)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \text{PtrAddr}(v_{ptr}) = addr \quad \Gamma \vdash \text{LowerPanic}(\text{NullDeref}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_k), addr \rangle}$$

**(Lower-AddrOf-Deref-Expired)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \text{PtrAddr}(v_{ptr}) = addr \quad \Gamma \vdash \text{LowerPanic}(\text{ExpiredDeref}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_k), addr \rangle}$$

**(Lower-AddrOf-Deref-Raw)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T) \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle IR_p, addr \rangle}$$

**(Lower-WritePlace-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerWritePlace}(\text{Identifier}(x), v) \Downarrow \text{StoreVarIR}(x, v) }$$

**(Lower-WritePlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases} \quad IR_d = \begin{cases}\text{EmitDrop}(\text{StaticType}(path, name), \text{Load}(@sym, \text{StaticType}(path, name))) & \text{if } \text{StaticBindInfo}(path, name).\text{resp} = \text{resp} \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerWritePlace}(\text{Identifier}(x), v) \Downarrow \text{SeqIR}(IR_p, IR_d, \text{StoreGlobal}(sym, v)) }$$

**(Lower-WritePlace-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldValue}(v_p, f) = v_f \quad T_f = \text{ExprType}(\text{FieldAccess}(p, f)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_f, v_f) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{FieldAccess}(p, f), v) \Downarrow \text{SeqIR}(IR_p, IR_d, IR_w)}$$

**(Lower-WritePlace-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleValue}(v_p, i) = v_i \quad T_i = \text{ExprType}(\text{TupleAccess}(p, i)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_i, v_i) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{TupleAccess}(p, i), v) \Downarrow \text{SeqIR}(IR_p, IR_d, IR_w)}$$

**(Lower-WritePlace-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexValue}(v_p, v_i) = v_e \quad T_e = \text{ExprType}(\text{IndexAccess}(p, idx)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_e, v_e) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_d, IR_w)}$$

**(Lower-WritePlace-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(Lower-WritePlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle}{\Gamma \vdash \text{LowerWritePlace}(\text{Deref}(p), v) \Downarrow \text{SeqIR}(IR_p, \text{WritePtrIR}(v_{ptr}, v))}$$

**Write-Subplace Lowering.**

**(LowerWriteSub-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerWritePlaceSub}(\text{Identifier}(x), v) \Downarrow \text{StoreVarNoDropIR}(x, v) }$$

**(LowerWriteSub-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerWritePlaceSub}(\text{Identifier}(x), v) \Downarrow \text{SeqIR}(IR_p, \text{StoreGlobal}(sym, v)) }$$

**(LowerWriteSub-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{FieldAccess}(p, f), v) \Downarrow \text{SeqIR}(IR_p, IR_w)}$$

**(LowerWriteSub-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{TupleAccess}(p, i), v) \Downarrow \text{SeqIR}(IR_p, IR_w)}$$

**(LowerWriteSub-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(LowerWriteSub-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(LowerWriteSub-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{Deref}(p), v) \Downarrow \text{SeqIR}(IR_p, \text{WritePtrIR}(v_{ptr}, v))}$$

**(Lower-MovePlace)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v \rangle}{\Gamma \vdash \text{LowerMovePlace}(p) \Downarrow \langle \text{SeqIR}(IR_p, \text{MoveStateIR}(p)), v \rangle}$$

### 6.5. Statement and Block Lowering

$$\text{LowerStmtJudg} = \{\text{LowerStmt},\ \text{LowerStmtList},\ \text{LowerBlock},\ \text{LowerLoop}\}$$

**(Lower-Stmt-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (sout, \sigma')}{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR}$$

**(Lower-Block-Correctness)**
$$\frac{\forall \sigma,\ out,\ \sigma'.\ \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma') \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land (out=\text{Val}(v') \Rightarrow v=v')\right)}{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}$$

**(Lower-Loop-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(loop, \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{LowerLoop}(loop) \Downarrow \langle IR, v \rangle}$$

$$\text{StmtForms0} = \{\text{LetStmt}(\_),\ \text{VarStmt}(\_),\ \text{ShadowLetStmt}(\_,\_,\_),\ \text{ShadowVarStmt}(\_,\_,\_),\ \text{AssignStmt}(\_,\_),\ \text{CompoundAssignStmt}(\_,\_,\_),\ \text{ExprStmt}(\_),\ \text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_),\ \text{ReturnStmt}(\_),\ \text{ResultStmt}(\_),\ \text{BreakStmt}(\_),\ \text{ContinueStmt},\ \text{UnsafeBlockStmt}(\_),\ \text{ErrorStmt}(\_)\}$$
$$\text{LowerStmtTotal}(\Gamma) \iff \forall s.\ s \in \text{StmtForms0} \Rightarrow \exists IR.\ \Gamma \vdash \text{LowerStmt}(s) \Downarrow IR$$

**(Lower-StmtList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerStmtList}([]) \Downarrow \epsilon }$$

**(Lower-StmtList-Cons)**
$$\frac{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR_s \quad \Gamma \vdash \text{LowerStmtList}(ss) \Downarrow IR_r}{\Gamma \vdash \text{LowerStmtList}(s::ss) \Downarrow \text{SeqIR}(IR_s, IR_r)}$$

$$\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle$$

**(Lower-Stmt-Let)**
$$\frac{\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle \quad \Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR_b}{\Gamma \vdash \text{LowerStmt}(\text{LetStmt}(binding)) \Downarrow \text{SeqIR}(IR_i, IR_b)}$$

**(Lower-Stmt-Var)**
$$\frac{\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle \quad \Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR_b}{\Gamma \vdash \text{LowerStmt}(\text{VarStmt}(binding)) \Downarrow \text{SeqIR}(IR_i, IR_b)}$$

**(Lower-Stmt-ShadowLet)**
$$\frac{\Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ShadowLetStmt}(x, ty\_opt, init)) \Downarrow \text{SeqIR}(IR_i, \text{BindVarIR}(x, v))}$$

**(Lower-Stmt-ShadowVar)**
$$\frac{\Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ShadowVarStmt}(x, ty\_opt, init)) \Downarrow \text{SeqIR}(IR_i, \text{BindVarIR}(x, v))}$$

**(Lower-Stmt-Assign)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerWritePlace}(place, v) \Downarrow IR_w}{\Gamma \vdash \text{LowerStmt}(\text{AssignStmt}(place, expr)) \Downarrow \text{SeqIR}(IR_e, IR_w)}$$

**(Lower-Stmt-CompoundAssign)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(place) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v_e \rangle \quad \text{BinOp}(op, v_p, v_e) \Downarrow v \quad \Gamma \vdash \text{LowerWritePlace}(place, v) \Downarrow IR_w}{\Gamma \vdash \text{LowerStmt}(\text{CompoundAssignStmt}(place, op, expr)) \Downarrow \text{SeqIR}(IR_p, IR_e, IR_w)}$$


**(Lower-Stmt-Expr)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ExprStmt}(expr)) \Downarrow IR_e}$$

**(Lower-Stmt-Defer)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{DeferStmt}(block)) \Downarrow \text{DeferIR}(block) }$$

**(Lower-Stmt-Region)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{LowerExpr}(opts) \Downarrow \langle IR_o, v_o \rangle \quad \Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{RegionStmt}(opts\_opt, alias\_opt, block)) \Downarrow \text{SeqIR}(IR_o, \text{RegionIR}(v_o, alias\_opt, IR_b, v_b))}$$

**(Lower-Stmt-Frame-Implicit)**
$$\frac{\Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{FrameStmt}(\bot, block)) \Downarrow \text{FrameIR}(\bot, IR_b, v_b)}$$

**(Lower-Stmt-Frame-Explicit)**
$$\frac{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(r)) \Downarrow \langle IR_r, v_r \rangle \quad \Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{FrameStmt}(r, block)) \Downarrow \text{SeqIR}(IR_r, \text{FrameIR}(v_r, IR_b, v_b))}$$

**(Lower-Stmt-Return)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(e)) \Downarrow \text{SeqIR}(IR_e, \text{ReturnIR}(v))}$$

**(Lower-Stmt-Return-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(\bot)) \Downarrow \text{ReturnIR}(()) }$$

**(Lower-Stmt-Result)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ResultStmt}(expr)) \Downarrow \text{SeqIR}(IR_e, \text{ResultIR}(v))}$$

**(Lower-Stmt-Break)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(e)) \Downarrow \text{SeqIR}(IR_e, \text{BreakIR}(v))}$$

**(Lower-Stmt-Break-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(\bot)) \Downarrow \text{BreakIR}(\bot) }$$

**(Lower-Stmt-Continue)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ContinueStmt}) \Downarrow \text{ContinueIR} }$$

**(Lower-Stmt-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{UnsafeBlockStmt}(block)) \Downarrow IR_b}$$

**(Lower-Stmt-Error)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ErrorStmt}(span)) \Downarrow \text{LowerPanic}(\text{ErrorStmt}(span)) }$$

**Temporary Cleanup in Lowering.**

Let $\text{TempDropOrder}(s) = [e_1,\ldots,e_k]$. For each $i$, let
$\Gamma \vdash \text{LowerExpr}(e_i) \Downarrow \langle IR_i, v_i \rangle$
denote the unique invocation of $\text{LowerExpr}(e_i)$ in the derivation of
$\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR_s$, and let $\text{ExprType}(e_i)=T_i$.

$$\text{TempCleanupIR}(s) =
\begin{cases}
\epsilon & \text{if } k = 0\\
\text{SeqIRList}([\text{EmitDrop}(T_k, v_k),\ldots,\text{EmitDrop}(T_1, v_1)]) & \text{otherwise}
\end{cases}$$

For $s \notin \{\text{ReturnStmt}(\_),\ \text{ResultStmt}(\_),\ \text{BreakStmt}(\_),\ \text{ContinueStmt}\}$, the lowering MUST produce
$$\Gamma \vdash \text{LowerStmt}(s) \Downarrow \text{SeqIR}(IR_s,\ \text{TempCleanupIR}(s)).$$

For control-flow statements, the lowering MUST emit temporary cleanup immediately before the control transfer:

$$\Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{ReturnIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{ResultStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{ResultIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{BreakIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(\bot)) \Downarrow \text{SeqIR}(\text{TempCleanupIR}(s),\ \text{BreakIR}(\bot))$$
$$\Gamma \vdash \text{LowerStmt}(\text{ContinueStmt}) \Downarrow \text{SeqIR}(\text{TempCleanupIR}(s),\ \text{ContinueIR})$$

$$\text{BlockForms0} = \{\text{BlockExpr}(\_,\_)\}$$
$$\text{LoopForms0} = \{\text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}$$
$$\text{LowerBlockTotal}(\Gamma) \iff \forall b.\ b \in \text{BlockForms0} \Rightarrow \exists IR,v.\ \Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle$$
$$\text{LowerLoopTotal}(\Gamma) \iff \forall l.\ l \in \text{LoopForms0} \Rightarrow \exists IR,v.\ \Gamma \vdash \text{LowerLoop}(l) \Downarrow \langle IR, v \rangle$$

**(Lower-Block-Tail)**
$$\frac{tail \ne \bot \quad \Gamma \vdash \text{LowerStmtList}(stmts) \Downarrow IR_s \quad \Gamma \vdash \text{LowerExpr}(tail) \Downarrow \langle IR_t, v_t \rangle}{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, tail)) \Downarrow \langle \text{BlockIR}(IR_s, IR_t, v_t), v_{\text{block}} \rangle}$$

**(Lower-Block-Unit)**
$$\frac{\Gamma \vdash \text{LowerStmtList}(stmts) \Downarrow IR_s}{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, \bot)) \Downarrow \langle \text{BlockIR}(IR_s, \epsilon, ()), v_{\text{block}} \rangle}$$

**(Lower-Loop-Infinite)**
$$\frac{\Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopInfinite}(body)) \Downarrow \langle \text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), v_{\text{loop}} \rangle}$$

**(Lower-Loop-Cond)**
$$\frac{\Gamma \vdash \text{LowerExpr}(cond) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopConditional}(cond, body)) \Downarrow \langle \text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), v_{\text{loop}} \rangle}$$

**(Lower-Loop-Iter)**
$$\frac{\Gamma \vdash \text{LowerExpr}(iter) \Downarrow \langle IR_i, v_{\text{iter}} \rangle \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle \text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), v_{\text{loop}} \rangle}$$


### 6.6. Pattern Matching Lowering

$$\text{PatternLowerJudg} = \{\text{LowerBindPattern},\ \text{LowerBindList},\ \text{LowerMatch},\ \text{TagOf}\}$$

**(Lower-Pat-Correctness)**
$$\frac{\forall v,\ \Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (ok, \sigma')}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR}$$
$$\text{MatchValueCorrect}(\Gamma, scrut, arms, v) \iff \forall \sigma, v', \sigma'.\ \Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrut, arms), \sigma) \Downarrow (\text{Val}(v'), \sigma') \Rightarrow v = v'$$

**(Lower-Match-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrut, arms), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \quad \text{MatchValueCorrect}(\Gamma, scrut, arms, v)}{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle IR, v \rangle}$$

$$\text{EnumValuePath}(v) = path \iff v = \text{EnumValue}(path, payload)$$
$$\text{VariantIndex}(E, name) = i \iff \text{Variants}(E) = [v_0,\ldots,v_k] \land v_i.\text{name} = name$$
$$\text{EnumDisc}(E, name) = d \iff \text{EnumDiscriminants}(E) \Downarrow ds \land \text{VariantIndex}(E, name) = i \land ds[i] = d$$
$$\text{StateIndex}(M, S) = i \iff \text{States}(M) = [S_0,\ldots,S_k] \land S_i = S$$

**(TagOf-Enum)**
$$\frac{\text{EnumValuePath}(v) = path \quad \text{EnumPath}(path) = p \quad T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{VariantName}(path) = name \quad \text{EnumDisc}(E, name) = d}{\Gamma \vdash \text{TagOf}(v, T) \Downarrow d}$$

**(TagOf-Modal)**
$$\frac{v = \langle S, v_S \rangle \quad T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{StateIndex}(M, S) = i}{\Gamma \vdash \text{TagOf}(v, T) \Downarrow i}$$

$$\text{LowerBindJudg} = \{\text{LowerBindList},\ \text{LowerBindPattern},\ \text{LowerMatch}\}$$

**(Lower-BindList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerBindList}([]) \Downarrow \epsilon }$$

**(Lower-BindList-Cons)**
$$\frac{\Gamma \vdash \text{LowerBindList}(bs) \Downarrow IR_r}{\Gamma \vdash \text{LowerBindList}([\langle x, v \rangle] \mathbin{+\!\!+} bs) \Downarrow \text{SeqIR}(\text{BindVarIR}(x, v), IR_r)}$$

**(Lower-Pat-General)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \Gamma \vdash \text{LowerBindList}(binds) \Downarrow IR}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR}$$

**(Lower-Pat-Err)**
$$\frac{\text{MatchPattern}(pat, v)\ \text{undefined}}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Uparrow}$$

**(Lower-Match)**
$$\frac{\Gamma \vdash \text{LowerExpr}(scrut) \Downarrow \langle IR_s, v_s \rangle}{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle \text{SeqIR}(IR_s, \text{MatchIR}(v_s, arms)), v_{\text{match}} \rangle}$$


### 6.7. Globals and Initialization

$$\text{GlobalsJudg} = \{\text{EmitGlobal},\ \text{InitFn},\ \text{DeinitFn},\ \text{Lower-StaticInit},\ \text{Lower-StaticInitItem},\ \text{Lower-StaticInitItems},\ \text{InitCallIR},\ \text{Lower-StaticDeinit},\ \text{Lower-StaticDeinitNames},\ \text{Lower-StaticDeinitItem},\ \text{Lower-StaticDeinitItems},\ \text{DeinitCallIR},\ \text{EmitInitPlan},\ \text{EmitDeinitPlan},\ \text{EmitStringLit},\ \text{EmitBytesLit},\ \text{InitPanicHandle}\}$$

$$\text{ConstInitJudg} = \{\text{ConstInit}\}$$

$$\Gamma \vdash \text{ConstInit}(e) \Downarrow bytes \iff e = \text{Literal}(lit) \land \Gamma \vdash \text{EncodeConst}(\text{ExprType}(e), lit) \Downarrow bytes$$

$$\text{StaticName}(binding) =
\begin{cases}
name & binding = \langle \text{IdentifierPattern}(name), ty\_opt, op, init, span \rangle\\
name & binding = \langle \text{TypedPattern}(name, \_), ty\_opt, op, init, span \rangle\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{StaticBindTypes}(binding) = B \iff binding = \langle pat, ty\_opt, op, init, \_ \rangle \land \Gamma \vdash pat \Leftarrow \text{BindType}(binding) \dashv B$$

$$\text{StaticBindList}(binding) = \text{PatNames}(pat) \iff binding = \langle pat, \_, \_, \_, \_ \rangle$$

$$\text{StaticBinding} : \text{StaticDecl} \times \text{Name} \to \text{StaticDecl}$$

$$\text{StaticSym}(\text{StaticDecl}(\_,\_, binding,\_,\_), x) = \begin{cases}
\text{Mangle}(\text{StaticDecl}(\_,\_, binding,\_,\_)) & \text{if } \text{StaticName}(binding)=x \\
\text{Mangle}(\text{StaticBinding}(\text{StaticDecl}(\_,\_, binding,\_,\_), x)) & \text{otherwise}
\end{cases}$$

**(Emit-Static-Const)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = name \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{ConstInit}(init) \Downarrow bytes \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalConst}(sym, bytes)]}$$

**(Emit-Static-Init)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = name \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{ConstInit}(init) \Uparrow \quad T = \text{ExprType}(init) \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalZero}(sym, \text{sizeof}(T))]}$$

**(Emit-Static-Multi)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = \bot \quad \text{StaticBindTypes}(binding) = B \quad \text{StaticBindList}(binding) = [x_1,\ldots,x_k] \quad \forall i,\ \Gamma \vdash \text{Mangle}(\text{StaticBinding}(\text{item}, x_i)) \Downarrow sym_i}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalZero}(sym_1, \text{sizeof}(B[x_1])),\ldots,\text{GlobalZero}(sym_k, \text{sizeof}(B[x_k]))]}$$

$$\text{InitSym}(m) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"init"}] \mathbin{+\!\!+} \text{PathOfModule}(m))$$

**(InitFn)**
$$\frac{\text{InitSym}(m) = sym}{\Gamma \vdash \text{InitFn}(m) \Downarrow sym}$$

$$\text{DeinitSym}(m) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"deinit"}] \mathbin{+\!\!+} \text{PathOfModule}(m))$$

**(DeinitFn)**
$$\frac{\text{DeinitSym}(m) = sym}{\Gamma \vdash \text{DeinitFn}(m) \Downarrow sym}$$

$$\text{StaticItems}(P, m) = [\ item \mid item \in \text{ASTModule}(P, m).\text{items} \land item = \text{StaticDecl}(\_,\_,\_,\_,\_)\ ]$$

$$\text{StaticItemOf}(path, name) = item \iff m = path \land item \in \text{StaticItems}(\text{Project}(\Gamma), m) \land item = \text{StaticDecl}(\_,\_, binding,\_,\_) \land name \in \text{StaticBindList}(binding) \land \forall item'.\ (item' \in \text{StaticItems}(\text{Project}(\Gamma), m) \land item' = \text{StaticDecl}(\_,\_, binding',\_,\_) \land name \in \text{StaticBindList}(binding')) \Rightarrow item' = item$$

$$\text{StaticSymPath}(path, name) = \text{StaticSym}(item, name) \iff \text{StaticItemOf}(path, name) = item$$

$$\text{StaticAddr}(path, name) = addr \iff \exists sym.\ \text{StaticSymPath}(path, name) = sym \land \text{AddrOfSym}(sym) = addr$$

$$\text{AddrOfSym} : \text{Symbol} \to \text{Addr}$$

$$\text{StaticType}(path, name) = \text{StaticBindTypes}(binding)[name] \iff \text{StaticItemOf}(path, name) = \text{StaticDecl}(\_, mut, binding,\_,\_)$$

$$\text{StaticBindInfo}(path, name) = \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init),\ \text{StaticBindTypes}(binding),\ \text{MovOf}(op),\ mut)[name] \iff \text{StaticItemOf}(path, name) = \text{StaticDecl}(\_, mut, binding,\_,\_) \land binding = \langle \_, \_, op, init, \_ \rangle$$

$$\text{SeqIRList}([]) = \epsilon$$
$$\text{SeqIRList}([IR] \mathbin{+\!\!+} IRs) = \text{SeqIR}(IR, \text{SeqIRList}(IRs))$$

$$\text{StaticStoreIR}(item, []) = \epsilon$$
$$\text{StaticStoreIR}(item, [\langle x, v \rangle] \mathbin{+\!\!+} bs) = \text{SeqIR}(\text{StoreGlobal}(\text{StaticSym}(item, x), v), \text{StaticStoreIR}(item, bs))$$

**(Lower-StaticInit-Item)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \Gamma \vdash \text{InitPanicHandle}(m) \Downarrow IR_p}{\Gamma \vdash \text{Lower-StaticInitItem}(m, item) \Downarrow \text{SeqIR}(IR_e, \text{StaticStoreIR}(item, binds), IR_p)}$$

**(Lower-StaticInitItems-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticInitItems}(m, []) \Downarrow \epsilon}$$

**(Lower-StaticInitItems-Cons)**
$$\frac{\Gamma \vdash \text{Lower-StaticInitItem}(m, item) \Downarrow IR_i \quad \Gamma \vdash \text{Lower-StaticInitItems}(m, items) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticInitItems}(m, [item] \mathbin{+\!\!+} items) \Downarrow \text{SeqIR}(IR_i, IR_r)}$$

**(Lower-StaticInit)**
$$\frac{\text{StaticItems}(\text{Project}(\Gamma), m) = items \quad \Gamma \vdash \text{Lower-StaticInitItems}(m, items) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticInit}(m) \Downarrow IR}$$

**(InitCallIR)**
$$\frac{\Gamma \vdash \text{InitFn}(m) \Downarrow sym}{\Gamma \vdash \text{InitCallIR}(m) \Downarrow \text{SeqIR}(\text{CallIR}(sym, [\text{PanicOutName}]), \text{PanicCheck})}$$

$$\text{Rev}([]) = []$$
$$\text{Rev}([x] \mathbin{+\!\!+} xs) = \text{Rev}(xs) \mathbin{+\!\!+} [x]$$

**(Lower-StaticDeinitNames-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, []) \Downarrow \epsilon}$$

**(Lower-StaticDeinitNames-Cons-Resp)**
$$\frac{\text{StaticBindInfo}(path, x).\text{resp} = \text{resp} \quad sym = \text{StaticSym}(item, x) \quad \Gamma \vdash \text{EmitDrop}(\text{StaticType}(path, x), \text{Load}(@sym, \text{StaticType}(path, x))) \Downarrow IR_d \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, xs) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, [x] \mathbin{+\!\!+} xs) \Downarrow \text{SeqIR}(IR_d, IR_r)}$$

**(Lower-StaticDeinitNames-Cons-NoResp)**
$$\frac{\text{StaticBindInfo}(path, x).\text{resp} \ne \text{resp} \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, xs) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, [x] \mathbin{+\!\!+} xs) \Downarrow IR_r}$$

**(Lower-StaticDeinit-Item)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad binding = \langle pat, \_, \_, \_, \_ \rangle \quad xs = \text{Rev}(\text{StaticBindList}(binding)) \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(\text{PathOfModule}(m), item, xs) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticDeinitItem}(m, item) \Downarrow IR}$$

**(Lower-StaticDeinitItems-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticDeinitItems}(m, []) \Downarrow \epsilon}$$

**(Lower-StaticDeinitItems-Cons)**
$$\frac{\Gamma \vdash \text{Lower-StaticDeinitItem}(m, item) \Downarrow IR_i \quad \Gamma \vdash \text{Lower-StaticDeinitItems}(m, items) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitItems}(m, [item] \mathbin{+\!\!+} items) \Downarrow \text{SeqIR}(IR_i, IR_r)}$$

**(Lower-StaticDeinit)**
$$\frac{\text{StaticItems}(\text{Project}(\Gamma), m) = items \quad \Gamma \vdash \text{Lower-StaticDeinitItems}(m, \text{Rev}(items)) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticDeinit}(m) \Downarrow IR}$$

**(DeinitCallIR)**
$$\frac{\Gamma \vdash \text{DeinitFn}(m) \Downarrow sym}{\Gamma \vdash \text{DeinitCallIR}(m) \Downarrow \text{SeqIR}(\text{CallIR}(sym, [\text{PanicOutName}]), \text{PanicCheck})}$$

**(EmitInitPlan)**
$$\frac{\text{InitOrder} = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{InitCallIR}(m_i) \Downarrow IR_i \quad IR_{\text{init}} = \text{SeqIRList}([IR_1,\ldots,IR_k])}{\Gamma \vdash \text{EmitInitPlan}(P) \Downarrow IR_{\text{init}}}$$

**(EmitInitPlan-Err)**
$$\frac{\exists m \in \text{InitOrder}.\ \Gamma \vdash \text{InitFn}(m) \Uparrow}{\Gamma \vdash \text{EmitInitPlan}(P) \Uparrow}$$

**(EmitDeinitPlan)**
$$\frac{\text{InitOrder} = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{DeinitCallIR}(m_i) \Downarrow IR_i \quad IR_{\text{deinit}} = \text{SeqIRList}(\text{Rev}([IR_1,\ldots,IR_k]))}{\Gamma \vdash \text{EmitDeinitPlan}(P) \Downarrow IR_{\text{deinit}}}$$

**(EmitDeinitPlan-Err)**
$$\frac{\exists m \in \text{InitOrder}.\ \Gamma \vdash \text{DeinitFn}(m) \Uparrow}{\Gamma \vdash \text{EmitDeinitPlan}(P) \Uparrow}$$

### 6.8. Cleanup, Drop, and Unwinding

$$\text{CleanupJudg} = \{\text{EmitDrop},\ \text{CleanupPlan},\ \text{LowerPanic},\ \text{PanicSym},\ \text{ClearPanic},\ \text{PanicCheck}\}$$

**(CleanupPlan)**
$$\frac{cs = \text{CleanupList}(scope)}{\Gamma \vdash \text{CleanupPlan}(scope) \Downarrow cs}$$

$$\text{EmitDropSpec}(\Gamma, T, v, IR) \iff \forall \sigma,\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow \sigma'.$$
$$\Gamma \vdash \text{EmitDrop}(T, v) \Downarrow IR \iff \text{EmitDropSpec}(\Gamma, T, v, IR).$$

$$\text{PanicOutAddr}(\sigma) = addr \iff \text{LookupVal}(\sigma, \text{PanicOutName}) = \text{RawPtr}(\texttt{mut}, addr)$$

$$\text{PanicRecordOf}(\sigma) = \langle p, c \rangle \iff \text{PanicOutAddr}(\sigma) = addr \land \text{ReadAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, addr, \texttt{"panic"})) = p \land \text{ReadAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, addr, \texttt{"code"})) = c$$

$$\text{WritePanicRecord}(\sigma, p, c) \Downarrow \sigma' \iff \text{WriteAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, \text{PanicOutAddr}(\sigma), \texttt{"panic"}), p) \Downarrow \sigma_1 \land \text{WriteAddr}(\sigma_1, \text{FieldAddr}(\text{PanicRecord}, \text{PanicOutAddr}(\sigma), \texttt{"code"}), c) \Downarrow \sigma'$$

$$\Gamma \vdash \text{InitPanicHandle}(m) \Downarrow IR \iff \forall \sigma.\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{true}, c \rangle \Rightarrow \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{ExecIRSigma}(\text{SeqIR}(\text{SetPoison}(m), \text{LowerPanic}(\text{InitPanic}(m))), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')\right) \land \left(\text{PanicRecordOf}(\sigma) = \langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right)$$

**(PanicSym)**
$$\frac{}{ \Gamma \vdash \text{PanicSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"panic"}]) }$$

$$\text{PanicReason} = \{\text{ErrorExpr}(span),\ \text{ErrorStmt}(span),\ \text{DivZero},\ \text{Overflow},\ \text{Shift},\ \text{Bounds},\ \text{Cast},\ \text{NullDeref},\ \text{ExpiredDeref},\ \text{InitPanic}(m),\ \text{Other}\}.$$

$$\text{PanicCode}(\text{ErrorExpr}(\_)) = 0x0001$$
$$\text{PanicCode}(\text{ErrorStmt}(\_)) = 0x0002$$
$$\text{PanicCode}(\text{DivZero}) = 0x0003$$
$$\text{PanicCode}(\text{Overflow}) = 0x0004$$
$$\text{PanicCode}(\text{Shift}) = 0x0005$$
$$\text{PanicCode}(\text{Bounds}) = 0x0006$$
$$\text{PanicCode}(\text{Cast}) = 0x0007$$
$$\text{PanicCode}(\text{NullDeref}) = 0x0008$$
$$\text{PanicCode}(\text{ExpiredDeref}) = 0x0009$$
$$\text{PanicCode}(\text{InitPanic}(\_)) = 0x000A$$
$$\text{PanicCode}(\text{Other}) = 0x00FF.$$

$$\text{PanicSite} = \{\text{DivZeroCheck},\ \text{OverflowCheck},\ \text{ShiftCheck},\ \text{BoundsCheck},\ \text{CastCheck},\ \text{NullDerefCheck},\ \text{ExpiredDerefCheck},\ \text{ErrorExprSite}(span),\ \text{ErrorStmtSite}(span),\ \text{InitPanicSite}(m),\ \text{OtherSite}\}.$$
$$\text{PanicReasonOf}(\text{DivZeroCheck}) = \text{DivZero}$$
$$\text{PanicReasonOf}(\text{OverflowCheck}) = \text{Overflow}$$
$$\text{PanicReasonOf}(\text{ShiftCheck}) = \text{Shift}$$
$$\text{PanicReasonOf}(\text{BoundsCheck}) = \text{Bounds}$$
$$\text{PanicReasonOf}(\text{CastCheck}) = \text{Cast}$$
$$\text{PanicReasonOf}(\text{NullDerefCheck}) = \text{NullDeref}$$
$$\text{PanicReasonOf}(\text{ExpiredDerefCheck}) = \text{ExpiredDeref}$$
$$\text{PanicReasonOf}(\text{ErrorExprSite}(span)) = \text{ErrorExpr}(span)$$
$$\text{PanicReasonOf}(\text{ErrorStmtSite}(span)) = \text{ErrorStmt}(span)$$
$$\text{PanicReasonOf}(\text{InitPanicSite}(m)) = \text{InitPanic}(m)$$
$$\text{PanicReasonOf}(\text{OtherSite}) = \text{Other}$$

$$\Gamma \vdash \text{ClearPanic} \Downarrow IR \iff \forall \sigma,\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \text{WritePanicRecord}(\sigma, \text{false}, 0) \Downarrow \sigma'.$$

$$\Gamma \vdash \text{PanicCheck} \Downarrow IR \iff \forall \sigma,\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right).$$

$$\Gamma \vdash \text{LowerPanic}(reason) \Downarrow IR \iff \forall \sigma.\ \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{WritePanicRecord}(\sigma, \text{true}, \text{PanicCode}(reason)) \Downarrow \sigma'$$

### 6.9. Built-ins Runtime Interface

$$\text{RuntimeIfcJudg} = \{\text{RegionLayout},\ \text{RegionSym},\ \text{BuiltinSym}\}$$

**(RegionLayout)**
$$\frac{\text{ModalLayout}(\texttt{Region}) \Downarrow \langle size, align, disc, payload \rangle}{\Gamma \vdash \text{RegionLayout} \Downarrow \langle size, align, [\langle \texttt{disc}, disc \rangle, \langle \texttt{payload}, payload \rangle] \rangle}$$

**(RegionSym-NewScoped)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::new_scoped}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"new_scoped"}]) }$$

**(RegionSym-Alloc)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::alloc}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"alloc"}]) }$$

**(RegionSym-ResetUnchecked)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::reset_unchecked}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"reset_unchecked"}]) }$$

**(RegionSym-Freeze)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::freeze}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"freeze"}]) }$$

**(RegionSym-Thaw)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::thaw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"thaw"}]) }$$

**(RegionSym-FreeUnchecked)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::free_unchecked}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"free_unchecked"}]) }$$

**(BuiltinSym-FileSystem-OpenRead)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_read}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_read"}]) }$$

**(BuiltinSym-FileSystem-OpenWrite)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_write}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_write"}]) }$$

**(BuiltinSym-FileSystem-OpenAppend)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_append}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_append"}]) }$$

**(BuiltinSym-FileSystem-CreateWrite)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::create_write}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"create_write"}]) }$$

**(BuiltinSym-FileSystem-ReadFile)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::read_file}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"read_file"}]) }$$

**(BuiltinSym-FileSystem-ReadBytes)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::read_bytes}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"read_bytes"}]) }$$

**(BuiltinSym-FileSystem-WriteFile)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_file}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_file"}]) }$$

**(BuiltinSym-FileSystem-WriteStdout)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_stdout}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_stdout"}]) }$$

**(BuiltinSym-FileSystem-WriteStderr)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_stderr}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_stderr"}]) }$$

**(BuiltinSym-FileSystem-Exists)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::exists}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"exists"}]) }$$

**(BuiltinSym-FileSystem-Remove)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::remove}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"remove"}]) }$$

**(BuiltinSym-FileSystem-OpenDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_dir"}]) }$$

**(BuiltinSym-FileSystem-CreateDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::create_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"create_dir"}]) }$$

**(BuiltinSym-FileSystem-EnsureDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::ensure_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"ensure_dir"}]) }$$

**(BuiltinSym-FileSystem-Kind)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::kind}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"kind"}]) }$$

**(BuiltinSym-FileSystem-Restrict)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::restrict}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"restrict"}]) }$$

**(BuiltinSym-HeapAllocator-WithQuota)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::with_quota}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"with_quota"}]) }$$

**(BuiltinSym-HeapAllocator-AllocRaw)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::alloc_raw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"alloc_raw"}]) }$$

**(BuiltinSym-HeapAllocator-DeallocRaw)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::dealloc_raw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"dealloc_raw"}]) }$$

### 6.10. Dynamic Dispatch

$$\text{DynDispatchJudg} = \{\text{VTable},\ \text{VSlot},\ \text{DynPack},\ \text{LowerDynCall}\}$$

$$\text{VTableEligible}(Cl) = [\ m \in \text{EffMethods}(Cl) \mid \text{vtable\_eligible}(m)\ ].$$

**(DispatchSym-Impl)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad \Gamma \vdash \text{Mangle}(m') \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(DispatchSym-Default-None)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = \bot \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(DispatchSym-Default-Mismatch)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = m' \quad \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m) \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(VTable-Order)**
$$\frac{\text{VTableEligible}(Cl) = [m_1,\ldots,m_k] \quad \forall i,\ \text{DispatchSym}(T, Cl, m_i.\text{name}) = sym_i}{\Gamma \vdash \text{VTable}(T, Cl) \Downarrow [sym_1,\ldots,sym_k]}$$

**(VSlot-Entry)**
$$\frac{\text{VTableEligible}(Cl) = [m_0,\ldots,m_{k-1}] \quad m_i.\text{name} = method.\text{name}}{\Gamma \vdash \text{VSlot}(Cl, method) \Downarrow i}$$

**(Lower-Dynamic-Form)**
$$\frac{\text{IsPlace}(e) \quad \Gamma \vdash \text{LowerAddrOf}(e) \Downarrow \langle IR, addr \rangle \quad T_e = \text{ExprType}(e) \quad T = \text{StripPerm}(T_e) \quad \Gamma \vdash T <: Cl}{\Gamma \vdash \text{DynPack}(T, e) \Downarrow \langle \text{RawPtr}(\texttt{imm}, addr), \text{VTable}(T, Cl) \rangle}$$

**(Lower-DynCall)**
$$\frac{\text{VSlot}(Cl, name) \Downarrow i}{\Gamma \vdash \text{LowerDynCall}(base, name, args) \Downarrow \text{SeqIR}(\text{CallVTable}(base, i, args), \text{PanicCheck})}$$

### 6.11. Checks and Panic

$$\text{ChecksJudg} = \{\text{LowerRangeExpr},\ \text{CheckIndex},\ \text{CheckRange},\ \text{LowerTransmute},\ \text{LowerRawDeref}\}$$

**(Lower-Range-Full)**
$$\frac{}{ \Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Full}, \bot, \bot)) \Downarrow \langle \epsilon, \text{RangeVal}(\texttt{Full}, \bot, \bot) \rangle }$$
  
**(Lower-Range-To)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{To}, \bot, e)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{To}, \bot, v) \rangle}$$

**(Lower-Range-ToInclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{ToInclusive}, \bot, e)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{ToInclusive}, \bot, v) \rangle}$$
  
**(Lower-Range-From)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{From}, e, \bot)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{From}, v, \bot) \rangle}$$
  
**(Lower-Range-Inclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Inclusive}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), \text{RangeVal}(\texttt{Inclusive}, v_1, v_2) \rangle}$$
  
**(Lower-Range-Exclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Exclusive}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), \text{RangeVal}(\texttt{Exclusive}, v_1, v_2) \rangle}$$

**(Check-Index-Ok)**
$$\frac{\text{IndexNum}(v_i)=i \quad 0 \le i < L}{\Gamma \vdash \text{CheckIndex}(L, v_i) \Downarrow ok}$$

**(Check-Index-Err)**
$$\frac{\text{IndexNum}(v_i)=i \quad \neg(0 \le i < L)}{\Gamma \vdash \text{CheckIndex}(L, v_i) \Uparrow}$$

**(Check-Range-Ok)**
$$\frac{\text{SliceBounds}(r, L)\ \text{defined}}{\Gamma \vdash \text{CheckRange}(L, r) \Downarrow ok}$$

**(Check-Range-Err)**
$$\frac{\text{SliceBounds}(r, L)\ \text{undefined}}{\Gamma \vdash \text{CheckRange}(L, r) \Uparrow}$$

**(Lower-Transmute)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{TransmuteVal}(T_1, T_2, v) \Downarrow v'}{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Downarrow \langle IR_e, v' \rangle}$$

**(Lower-Transmute-Err)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{TransmuteVal}(T_1, T_2, v)\ \text{undefined}}{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Uparrow}$$

**Raw Dereference Lowering.**

**(Lower-RawDeref-Safe)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle \text{ReadPtrIR}(v_{ptr}), v \rangle }$$

**(Lower-RawDeref-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T)}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle \text{ReadPtrIR}(v_{ptr}), v \rangle }$$

**(Lower-RawDeref-Null)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \Gamma \vdash \text{LowerPanic}(\text{NullDeref}) \Downarrow IR_k}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_k, v_{\text{unreach}} \rangle }$$

**(Lower-RawDeref-Expired)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \Gamma \vdash \text{LowerPanic}(\text{ExpiredDeref}) \Downarrow IR_k}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_k, v_{\text{unreach}} \rangle }$$

### 6.12. LLVM 21 Backend Requirements

#### 6.12.1. LLVM Module Header

$$\text{LLVMHeader} = [\text{TargetDataLayout}(\text{LLVMDataLayout}),\ \text{TargetTriple}(\text{LLVMTriple})]$$

#### 6.12.2. Opaque Pointer Model (LLVM 21)

$$\text{AddrSpace}(T) =
\begin{cases}
0 & T = \text{TypePtr}(U, s)\\
0 & T = \text{TypeRawPtr}(q, U)\\
0 & T = \text{TypeFunc}(params, R)\\
\text{AddrSpace}(U) & T = \text{TypePerm}(p, U) \land \text{AddrSpace}(U)\ \text{defined}\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{LLVMPtrTy}(T) = \texttt{ptr addrspace(AddrSpace(T))}\ \text{when }\text{AddrSpace}(T)\ \text{defined}$$

#### 6.12.3. LLVM Attribute Mapping (Permissions and Pointer State)

$$\text{LLVMAttrJudg} = \{\text{PtrStateOf}(T) = s,\ \text{LLVMPtrAttrs}(T) \Downarrow A,\ \text{LLVMArgAttrs}(T) \Downarrow A\}$$

**(PtrStateOf-Perm)**
$$\frac{\text{PtrStateOf}(T) = s}{\text{PtrStateOf}(\text{TypePerm}(p,T)) = s}$$

**(LLVM-PtrAttrs-Valid)**
$$\frac{\text{StripPerm}(T) = \text{TypePtr}(U, \texttt{Valid})}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \{\texttt{nonnull},\ \texttt{dereferenceable}(\text{sizeof}(U)),\ \texttt{align}(\text{alignof}(U)),\ \texttt{noundef}\}}$$

**(LLVM-PtrAttrs-Other)**
$$\frac{\text{StripPerm}(T) = \text{TypePtr}(U, s) \quad s \in \{\bot,\ \texttt{Null},\ \texttt{Expired}\}}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-PtrAttrs-RawPtr)**
$$\frac{\text{StripPerm}(T) = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-ArgAttrs-Ptr)**
$$\text{LLVMArgAttrsPtr}(T) = (\text{PermOf}(T)=\texttt{unique} Sigma \{\texttt{noalias}\} : \emptyset) \cup (\text{PermOf}(T)=\texttt{const} Sigma \{\texttt{readonly}\} : \emptyset)$$
$$\frac{\text{StripPerm}(T) \in \{\text{TypePtr}(\_,\_),\ \text{TypeFunc}(\_,\_)\}}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \text{LLVMArgAttrsPtr}(T)}$$

**(LLVM-ArgAttrs-RawPtr)**
$$\frac{\text{StripPerm}(T) = \text{TypeRawPtr}(\_,\_)}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-ArgAttrs-NonPtr)**
$$\frac{\text{StripPerm}(T) \notin \{\text{TypePtr}(\_,\_),\ \text{TypeRawPtr}(\_,\_),\ \text{TypeFunc}(\_,\_)\}}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \emptyset}$$

$$\text{NoEscapeParam}(x)\ \text{predicate}$$
$$\text{NoEscapeParam}(x) \iff \text{false}$$
$$\text{OptArgAttrs}(x) \subseteq \{\texttt{nocapture}\} \land (\texttt{nocapture} \in \text{OptArgAttrs}(x) \Rightarrow \text{NoEscapeParam}(x))$$
$$\text{LLVMArgAttrsExt}(x, T) = \text{LLVMArgAttrs}(T) \cup \text{OptArgAttrs}(x)$$

#### 6.12.4. UB and Poison Avoidance (LLVM 21)

$$\text{LLVMInstrs}(LLVMIR) = [i_0,\ldots,i_n]$$
$$\text{Opcode}(i) = op$$
$$\text{UsesOpcode}(LLVMIR, op) \iff \exists i \in \text{LLVMInstrs}(LLVMIR).\ \text{Opcode}(i)=op$$
$$\text{Intrinsic}(i) = name$$
$$\text{UsesIntrinsic}(LLVMIR, name) \iff \exists i \in \text{LLVMInstrs}(LLVMIR).\ \text{Intrinsic}(i)=name$$
$$\text{NoUndefPoison}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{undef}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{poison})$$
$$\text{NoNSWNUW}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{nsw}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{nuw})$$
$$\text{CheckedOverflow}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{add}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{sub}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{mul}) \land \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.*.with.overflow})$$
$$\text{CheckedDivRem}(LLVMIR) \iff \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.sdiv.with.check}) \land \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.udiv.with.check})$$
$$\text{CheckedShifts}(LLVMIR) \iff \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.shift.with.check})$$
$$\text{FrozenPoisonUses}(LLVMIR) \iff \text{UsesOpcode}(LLVMIR, \texttt{freeze})$$
$$\text{InboundsGEP}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{getelementptr inbounds}) \lor \text{UsesOpcode}(LLVMIR, \texttt{gep.inbounds.checked})$$
$$\text{LLVMUBSafe}(LLVMIR) \iff \text{NoUndefPoison}(LLVMIR) \land \text{CheckedOverflow}(LLVMIR) \land \text{CheckedDivRem}(LLVMIR) \land \text{CheckedShifts}(LLVMIR) \land \text{FrozenPoisonUses}(LLVMIR) \land \text{InboundsGEP}(LLVMIR) \land \text{NoNSWNUW}(LLVMIR)$$

#### 6.12.5. Memory Intrinsics

$$\text{Memmove}(dst, src, n) = [\texttt{call}\ \texttt{llvm.memmove}(dst, src, n)]$$
$$\text{MemcpyOverlapUnknown}(dst, src, n)\ \text{predicate}$$
$$\text{MemcpyOverlapUnknown}(dst, src, n) \iff \text{true}$$
$$\text{MemcpyAllowed}(dst, src, n) \iff \neg \text{MemcpyOverlapUnknown}(dst, src, n)$$
$$\text{AggMemcpy}(dst, src, n) =
\begin{cases}
\text{Memcpy}(dst, src, n) & \text{MemcpyAllowed}(dst, src, n)\\
\text{Memmove}(dst, src, n) & \text{otherwise}
\end{cases}$$
$$\text{AggZero}(dst, n) = \text{Memset}(dst, 0, n)$$
$$\text{LifetimeOpt}(T) \subseteq \{\texttt{llvm.lifetime.start}(\text{sizeof}(T)),\ \texttt{llvm.lifetime.end}(\text{sizeof}(T))\}$$

#### 6.12.6. Runtime and Builtâ€‘in Declarations

$$\text{RuntimeDeclJudg} = \{\text{RuntimeSig}(sym) \Downarrow \langle params, ret \rangle,\ \text{BuiltinSig}(method) \Downarrow \langle params, ret \rangle,\ \text{RuntimeDecls}(S) \Downarrow decls\}$$

$$\text{BuiltinSig}(\texttt{FileSystem}::name) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\text{CapRecv}(\texttt{FileSystem}, name),\ \text{TypeDynamic}(\texttt{FileSystem})) \rangle] \mathbin{+\!\!+} params,\ ret \rangle \iff \text{CapMethodSig}(\texttt{FileSystem}, name) = \langle params, ret \rangle$$
$$\text{BuiltinSig}(\texttt{HeapAllocator}::name) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\text{CapRecv}(\texttt{HeapAllocator}, name),\ \text{TypeDynamic}(\texttt{HeapAllocator})) \rangle] \mathbin{+\!\!+} params,\ ret \rangle \iff \text{CapMethodSig}(\texttt{HeapAllocator}, name) = \langle params, ret \rangle$$
$$\text{BuiltinSig}(method) = \langle params, ret \rangle \iff \text{StringBytesBuiltinSig}(method) = \langle params, ret \rangle$$

$$\text{RuntimeSig}(\text{PanicSym}) = \langle [\langle \bot,\ \texttt{code},\ \text{TypePrim}(\texttt{"u32"}) \rangle],\ \text{TypePrim}(\texttt{"!"}) \rangle$$
$$\text{RuntimeSig}(\text{ContextInitSym}) = \langle [],\ \text{TypePath}([\texttt{"Context"}]) \rangle$$
$$\text{RuntimeSig}(\text{StringDropSym}) = \langle [\langle \texttt{move},\ \texttt{value},\ \text{TypeString}(\texttt{@Managed}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle$$
$$\text{RuntimeSig}(\text{BytesDropSym}) = \langle [\langle \texttt{move},\ \texttt{value},\ \text{TypeBytes}(\texttt{@Managed}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle$$
$$\text{RuntimeSig}(sym) = \langle params, ret \rangle \iff sym = \text{RegionSym}(proc) \land \text{RegionProcSig}(proc) = \langle params, ret \rangle$$
$$\text{RuntimeSig}(sym) = \langle params, ret \rangle \iff sym = \text{BuiltinSym}(method) \land \text{BuiltinSig}(method) = \langle params, ret \rangle$$

$$\text{LLVMDecl} : \text{Symbol} \times \text{Sig} \to \text{LLVMDecl}$$

**(RuntimeDecls)**
$$\frac{\forall sym \in S,\ \text{RuntimeSig}(sym) = \langle params, ret \rangle \quad \text{LLVMCallSig}(params, ret) \Downarrow sig}{\Gamma \vdash \text{RuntimeDecls}(S) \Downarrow [\text{LLVMDecl}(sym, sig) \mid sym \in S]}$$
$$\text{DeclAttrs} : \text{Symbol} \to \text{AttrSet}$$
$$\text{DeclSyms}(LLVMIR) = \{ sym \mid \text{LLVMDecl}(sym,\_) \in LLVMIR \lor \text{LLVMDefine}(sym,\_,\_) \in LLVMIR \}$$
$$\text{DeclAttrsOk}(sym) \iff (sym=\text{PanicSym} \Rightarrow \{\texttt{noreturn},\ \texttt{nounwind}\} \subseteq \text{DeclAttrs}(sym)) \land (sym\ne\text{PanicSym} \Rightarrow \texttt{nounwind} \in \text{DeclAttrs}(sym))$$
$$\text{RuntimeDeclsOk}(decls) \iff \forall sym \in \text{DeclSyms}(decls).\ \text{DeclAttrsOk}(sym)$$
$$\text{RuntimeDeclsCover}(LLVMIR, IR) \iff \text{RuntimeRefs}(IR) \subseteq \text{DeclSyms}(LLVMIR)$$

#### 6.12.7. LLVM Toolchain Version

$$\text{LLVMToolchain} = \texttt{"21.1.8"}$$

#### 6.12.8. LLVM Type Mapping

$$\text{LLVMTyJudg} = \{\text{LLVMTy}(T) \Downarrow \tau\}$$

$$\text{LLVMZST} = \{\}$$
$$\text{Pad}(n) =
\begin{cases}
[] & n = 0\\
[n \times i8] & n \ne 0
\end{cases}$$

$$\text{LLVMPrim}(name) =
\begin{cases}
i8 & name \in \{i8,\ u8\}\\
i16 & name \in \{i16,\ u16\}\\
i32 & name \in \{i32,\ u32\}\\
i64 & name \in \{i64,\ u64\}\\
i128 & name \in \{i128,\ u128\}\\
\texttt{half} & name = f16\\
\texttt{float} & name = f32\\
\texttt{double} & name = f64\\
i8 & name = \texttt{bool}\\
i32 & name = \texttt{char}\\
i64 & name \in \{\texttt{usize},\ \texttt{isize}\}\\
\text{LLVMZST} & name \in \{\texttt{()},\ \texttt{!}\}\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{LLVMStruct}([t_1,\ldots,t_k]) = \{ t_1, \ldots, t_k \}$$
$$\text{LLVMArray}(n, t) = [n \times t]$$
$$\text{LLVMArrayConst}(n, t, elems)\ \text{constructor}$$
$$\text{SlicePtrTy}(T) = \text{LLVMPtrTy}(\text{TypeRawPtr}(\texttt{imm}, T))$$

$$\text{StructElems}([], [], 0) = []$$
$$\text{StructElems}([\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle], [o_1,\ldots,o_n], size) = \text{Pad}(pad_1) \mathbin{+\!\!+} [\tau_1] \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} \text{Pad}(pad_n) \mathbin{+\!\!+} [\tau_n] \mathbin{+\!\!+} \text{Pad}(pad_{\text{tail}})$$
$$pad_1 = o_1$$
$$pad_i = o_i - (o_{i-1} + \text{sizeof}(T_{i-1}))\ \text{for } i=2..n$$
$$pad_{\text{tail}} = size - (o_n + \text{sizeof}(T_n))$$
$$\tau_i = \text{LLVMTy}(T_i)$$

$$\text{TaggedElems}(disc, payload\_size, payload\_align, size) = [\text{LLVMTy}(disc)] \mathbin{+\!\!+} \text{Pad}(pad_{\text{mid}}) \mathbin{+\!\!+} [\text{LLVMArray}(payload\_size, i8)] \mathbin{+\!\!+} \text{Pad}(pad_{\text{tail}})$$
$$disc\_size = \text{sizeof}(disc)$$
$$payload\_off = \text{AlignUp}(disc\_size, payload\_align)$$
$$pad_{\text{mid}} = payload\_off - disc\_size$$
$$pad_{\text{tail}} = size - (payload\_off + payload\_size)$$

**(LLVMTy-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{LLVMPrim}(name) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Perm)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(\text{TypePerm}(p, T)) \Downarrow \tau}$$

**(LLVMTy-Ptr)**
$$\frac{T = \text{TypePtr}(U, s) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, U) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Func)**
$$\frac{T = \text{TypeFunc}(params, R) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{LLVMTy}(ty) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(fields, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}([\langle 0,T_1\rangle,\ldots,\langle n-1,T_n\rangle], offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Array)**
$$\frac{T = \text{TypeArray}(T_0, e) \quad \Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash \text{LLVMTy}(T_0) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMArray}(n, \tau)}$$

**(LLVMTy-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{SlicePtrTy}(T_0), \tau_u])}$$

**(LLVMTy-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(\text{RangeFields}, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(\text{TypeRange}) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad payload\_align = \text{PayloadAlign}(E) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Union-Niche)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{NicheApplies}(T) \quad \text{PayloadMember}(T) = T_p \quad \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Union-Tagged)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad disc \ne \bot \quad payload\_align = \text{PayloadAlign}(T) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Modal-Niche)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{NicheApplies}(M) \quad \text{PayloadState}(M) = S_p \quad \text{SingleFieldPayload}(M, S_p) = T_p \quad \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Modal-Tagged)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad disc \ne \bot \quad payload\_align = \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S)) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Modal-StringBytes)**
$$\text{BaseModal}(\text{TypeString}(\bot)) = \texttt{string}$$
$$\text{BaseModal}(\text{TypeBytes}(\bot)) = \texttt{bytes}$$
$$\frac{T \in \{\text{TypeString}(\bot),\ \text{TypeBytes}(\bot)\} \quad \text{ModalLayout}(\text{BaseModal}(T)) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad (disc = \bot \Rightarrow \text{PayloadState}(\text{BaseModal}(T)) = S_p \land \text{SingleFieldPayload}(\text{BaseModal}(T), S_p) = T_p \land \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau) \quad (disc \ne \bot \Rightarrow payload\_align = \max_{S \in \text{States}(\text{BaseModal}(T))}(\text{StateAlign}(\text{BaseModal}(T), S)) \land \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems)}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow (\tau\ \text{if } disc=\bot\ \text{else }\text{LLVMStruct}(elems))}$$

**(LLVMTy-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{Payload}(M, S) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(fields, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Dynamic)**
$$\frac{\text{DynLayout}(Cl) \Downarrow \langle \_,\_,[\langle \texttt{data}, T_d \rangle,\langle \texttt{vtable}, T_v \rangle] \rangle \quad \Gamma \vdash \text{LLVMTy}(T_d) \Downarrow \tau_d \quad \Gamma \vdash \text{LLVMTy}(T_v) \Downarrow \tau_v}{\Gamma \vdash \text{LLVMTy}(\text{TypeDynamic}(Cl)) \Downarrow \text{LLVMStruct}([\tau_d,\tau_v])}$$

**(LLVMTy-StringView)**
$$\frac{T = \text{TypeString}(\texttt{@View}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid})), \tau_u])}$$

**(LLVMTy-StringManaged)**
$$\frac{T = \text{TypeString}(\texttt{@Managed}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid})), \tau_u, \tau_u])}$$

**(LLVMTy-BytesView)**
$$\frac{T = \text{TypeBytes}(\texttt{@View}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid})), \tau_u])}$$

**(LLVMTy-BytesManaged)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid})), \tau_u, \tau_u])}$$

**(LLVMTy-Err)**
$$\frac{\text{LLVMTy}(T)\ \text{undefined}}{\Gamma \vdash \text{LLVMTy}(T) \Uparrow}$$

#### 6.12.9. LLVM IR Emission Pipeline

$$\text{LLVMEmitJudg} = \{\text{LowerIR}(ModuleIR) \Downarrow LLVMIR,\ \text{EmitLLVM}(LLVMIR) \Downarrow bytes,\ \text{EmitObj}(LLVMIR) \Downarrow bytes\}$$

$$\text{RuntimeSyms} = \{\text{PanicSym},\ \text{StringDropSym},\ \text{BytesDropSym},\ \text{ContextInitSym}\} \cup \{\text{RegionSym}(proc) \mid proc \in \text{RegionProcs}\} \cup \{\text{BuiltinSym}(method) \mid method \in \text{BuiltinMethods}\}$$
$$\text{BuiltinMethods} = \text{StringBuiltins} \cup \text{BytesBuiltins} \cup \{\texttt{FileSystem}::name \mid \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}\} \cup \{\texttt{HeapAllocator}::name \mid \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}\}$$
$$\text{RefSyms} : IR \to \mathcal{P}(\text{Symbol})$$
$$\text{RefSyms}([]) = \emptyset$$
$$\text{RefSyms}([d] \mathbin{+\!\!+} ds) = \text{RefSyms}(d) \cup \text{RefSyms}(ds)$$
$$\text{RefSyms}(\text{ProcIR}(\_,\_,\_, IR)) = \text{RefSyms}(IR)$$
$$\text{RefSyms}(\text{GlobalConst}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{GlobalZero}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{GlobalVTable}(\_, header, slots)) = \{ s \mid s \in header \land s \in \text{Symbol} \} \cup \{ s \mid s \in slots \land s \in \text{Symbol} \}$$
$$\text{RefSyms}(\text{EmitVTable}(T, Cl)) = \text{RefSyms}(d) \iff \Gamma \vdash \text{EmitVTable}(T, Cl) \Downarrow d$$
$$\text{RefSyms}(\text{EmitDropGlue}(T)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR$$
$$\text{RefSyms}(\text{EmitLiteralData}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\epsilon) = \emptyset$$
$$\text{RefSyms}(\text{SeqIR}(IR_1, IR_2)) = \text{RefSyms}(IR_1) \cup \text{RefSyms}(IR_2)$$
$$\text{RefSyms}(\text{ReadVarIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{StoreVarIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{StoreVarNoDropIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{BindVarIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReadPtrIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{WritePtrIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{AllocIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{MoveStateIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReturnIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ResultIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{BreakIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ContinueIR}) = \emptyset$$
$$\text{RefSyms}(\text{DeferIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReadPathIR}(path, name)) = \{\text{PathSym}(path, name)\} \cup \{ sym \mid \text{StaticSymPath}(path, name) = sym \}$$
$$\text{RefSyms}(\text{StoreGlobal}(sym, \_)) = \{sym\}$$
$$\text{RefSyms}(\text{CallIR}(callee, \_)) = \{ callee \mid callee \in \text{Symbol} \}$$
$$\text{RefSyms}(\text{IfIR}(\_, IR_t,\_, IR_f,\_)) = \text{RefSyms}(IR_t) \cup \text{RefSyms}(IR_f)$$
$$\text{RefSyms}(\text{BlockIR}(IR_s, IR_t,\_)) = \text{RefSyms}(IR_s) \cup \text{RefSyms}(IR_t)$$
$$\text{RefSyms}(\text{MatchIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopInfinite}, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopConditional}, IR_c,\_, IR_b,\_)) = \text{RefSyms}(IR_c) \cup \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopIter},\_,\_, IR_i,\_, IR_b,\_)) = \text{RefSyms}(IR_i) \cup \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{RegionIR}(\_,\_, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{FrameIR}(\_, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{BranchIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{BranchIR}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{PhiIR}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{CallVTable}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{AddrOfIR}(p)) = \text{RefSyms}(IR_p) \iff \Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle$$
$$\text{RefSyms}(\text{ClearPanic}) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{ClearPanic} \Downarrow IR$$
$$\text{RefSyms}(\text{PanicCheck}) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{PanicCheck} \Downarrow IR$$
$$\text{RefSyms}(\text{CheckPoison}(m)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{CheckPoison}(m) \Downarrow IR$$
$$\text{RefSyms}(\text{LowerPanic}(r)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR$$
$$\text{RuntimeRefs}(IR) = \text{RefSyms}(IR) \cap \text{RuntimeSyms}$$
$$\text{LiteralRef}(IR, kind, bytes)\ \text{predicate}$$
$$\text{LiteralRef}(IR, kind, bytes) \iff \text{LiteralDataSym}(kind, bytes) \in \text{RefSyms}(IR)$$
$$\text{LiteralRefs}(IR) = \{\langle kind, bytes \rangle \mid \text{LiteralRef}(IR, kind, bytes)\}$$
$$\text{VTableRefs}(IR) = \{(T, Cl) \mid \text{DynPack}(T,\_) \in IR \lor \text{CallVTable}(\_,\_,\_) \in IR\}$$

$$\text{ExpandIR}(IR) = IR \mathbin{+\!\!+} \left(\mathbin{+\!\!+}_{(T,Cl) \in \text{VTableRefs}(IR)} [\text{EmitDropGlue}(T),\ \text{EmitVTable}(T,Cl)]\right) \mathbin{+\!\!+} \left(\mathbin{+\!\!+}_{\langle kind,bytes \rangle \in \text{LiteralRefs}(IR)} [\text{EmitLiteralData}(kind, bytes)]\right)$$

$$\text{EmitKey}(d) = \begin{cases}
\langle \texttt{vtable}, T, Cl \rangle & d = \text{EmitVTable}(T, Cl)\\
\langle \texttt{drop}, T \rangle & d = \text{EmitDropGlue}(T)\\
\langle \texttt{lit}, kind, bytes \rangle & d = \text{EmitLiteralData}(kind, bytes)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{EmitKeys}(IR) = [\text{EmitKey}(d) \mid d \in IR \land \text{EmitKey}(d) \ne \bot]$$
$$\text{UniqueEmits}(IR) \iff \text{NoDup}(\text{EmitKeys}(IR))$$

**(LowerIR-Module)**
$$\frac{
IR' = \text{ExpandIR}(IR) \quad
IR' = [d_1,\ldots,d_k] \quad
\forall i,\ \Gamma \vdash \text{LowerIRDecl}(d_i) \Downarrow ll_i \quad
\text{RuntimeDecls}(\text{RuntimeRefs}(IR')) = ds \quad
\text{RuntimeDeclsOk}(ds) \quad
LLVMIR = LLVMHeader \mathbin{+\!\!+} ds \mathbin{+\!\!+} ll_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ll_k \quad
\text{LLVMUBSafe}(LLVMIR) \quad
\text{RuntimeDeclsCover}(LLVMIR, IR') \quad
\text{UniqueEmits}(IR')
}{\Gamma \vdash \text{LowerIR}(IR) \Downarrow LLVMIR}$$

**(LowerIR-Err)**
$$\frac{\exists i,\ \Gamma \vdash \text{LowerIRDecl}(d_i) \Uparrow}{\Gamma \vdash \text{LowerIR}(IR) \Uparrow}$$

**(EmitLLVM-Ok)**
$$\frac{\text{RenderLLVM}(LLVMIR) = bytes}{\Gamma \vdash \text{EmitLLVM}(LLVMIR) \Downarrow bytes}$$

$$\text{LLVMText}_{21} = \{ bytes \mid \texttt{llvm-as}\_{21}\ \text{accepts}\ bytes \}$$
$$\text{RenderLLVM}(LLVMIR) = bytes \Rightarrow bytes \in \text{LLVMText}_{21}$$

**(EmitLLVM-Err)**
$$\frac{\text{RenderLLVM}(LLVMIR) \Uparrow}{\Gamma \vdash \text{EmitLLVM}(LLVMIR) \Uparrow}$$

**(EmitObj-Ok)**
$$\frac{\text{LLVMEmitObj}_{21}(LLVMIR) = bytes}{\Gamma \vdash \text{EmitObj}(LLVMIR) \Downarrow bytes}$$
$$\text{LLVMEmitObj}_{21}(LLVMIR) = bytes \iff \text{LLVMObj}_{21}(LLVMIR, \text{LLVMHeader}) = bytes$$

**(EmitObj-Err)**
$$\frac{\text{LLVMEmitObj}_{21}(LLVMIR) \Uparrow}{\Gamma \vdash \text{EmitObj}(LLVMIR) \Uparrow}$$

#### 6.12.10. IR Operation Lowering

$$\text{LowerIRJudg} = \{\text{LowerIRDecl}(d) \Downarrow ll,\ \text{LowerIRInstr}(op) \Downarrow ll\}$$

$$\text{LLVMInstrList} = [\text{LLVMInstr}]$$
$$\text{Label}(l) \in \text{LLVMInstr}$$
$$\text{Br}(l) \in \text{LLVMInstr}$$
$$\text{BrCond}(v, l_t, l_f) \in \text{LLVMInstr}$$
$$\text{Phi}(\tau, inc, v) \in \text{LLVMInstr}$$
$$\text{HasLabel}(I, l) \iff \text{Label}(l) \in I$$
$$\text{HasBrCond}(I, v) \iff \exists l_t,l_f.\ \text{BrCond}(v, l_t, l_f) \in I$$
$$\text{HasPhi}(I, v) \iff \exists \tau,inc.\ \text{Phi}(\tau, inc, v) \in I$$
$$\text{FreshLabel}(\Gamma)\ \text{predicate}$$
$$\text{FreshSSA}(\Gamma)\ \text{predicate}$$
$$\text{LLVMSSA} = \text{Name}$$
$$\text{LLVMLabel} = \text{Name}$$
$$\text{FreshLabel}(\Gamma) \in \text{LLVMLabel} \setminus \text{dom}(\Gamma)$$
$$\text{FreshSSA}(\Gamma) \in \text{LLVMSSA} \setminus \text{dom}(\Gamma)$$

$$\text{IfLabels}(\Gamma) = \langle l_t,\ l_f,\ l_m \rangle \land \text{Distinct}([l_t,l_f,l_m])$$

$$\text{LLResult} = \{\langle I, v \rangle \mid I \in \text{LLVMInstrList} \land v \in \text{LLVMSSA} \cup \{\bot\}\}$$
$$\text{SeqLL}(\langle I_1, v_1 \rangle, \langle I_2, v_2 \rangle) = \langle I_1 \mathbin{+\!\!+} I_2, v_2 \rangle$$

**(LowerIRInstr-Empty)**
$$\frac{}{\Gamma \vdash \text{LowerIRInstr}(\epsilon) \Downarrow \langle [], \bot \rangle}$$

**(LowerIRInstr-Seq)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(IR_1) \Downarrow ll_1 \quad \Gamma \vdash \text{LowerIRInstr}(IR_2) \Downarrow ll_2}{\Gamma \vdash \text{LowerIRInstr}(\text{SeqIR}(IR_1, IR_2)) \Downarrow \text{SeqLL}(ll_1, ll_2)}$$

$$\text{Load}(slot, T) = [\texttt{load}\ \text{LLVMTy}(T),\ slot : \text{LLVMPtrTy}(T)]$$
$$\text{Store}(slot, v, T) = [\texttt{store}\ \text{LLVMTy}(T)\ v,\ slot : \text{LLVMPtrTy}(T)]$$
$$\text{Memcpy}(dst, src, n) = [\texttt{call}\ \texttt{llvm.memcpy}(dst, src, n)]$$
$$\text{Memset}(dst, 0, n) = [\texttt{call}\ \texttt{llvm.memset}(dst, 0, n)]$$
$$\text{LoadVal}(slot, T) \Downarrow \langle \text{Load}(slot, T), v \rangle$$

$$\text{LEValue}(bytes) = \sum_{i=0}^{|bytes|-1} bytes[i] \cdot 256^i$$
$$\text{ByteInt}(bytes) = i\{8|bytes|\}\ \text{LEValue}(bytes)$$

$$\text{AllZero}(bytes) \iff \forall b \in bytes.\ b = 0x00$$
$$\text{ByteArray}(bytes) = \text{LLVMArrayConst}(|bytes|, i8, bytes)$$
$$\text{ConstBytes}(\tau, bytes) = c \iff \exists T.\ \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land |bytes| = \text{sizeof}(T) \land c = \text{ConstBytesCase}(\tau, bytes)$$
$$\text{ConstBytesCase}(\tau, bytes) =
\begin{cases}
\texttt{zeroinitializer} & |bytes| = 0\\
\text{ByteArray}(bytes) & \tau = \text{LLVMArray}(|bytes|, i8)\\
\text{ByteInt}(bytes) & \tau = i\{8|bytes|\}\\
\texttt{bitcast}(\text{ByteInt}(bytes) \text{ to } \tau) & \tau \in \{\texttt{half},\ \texttt{float},\ \texttt{double}\}\\
\texttt{null} & \tau = \text{LLVMPtrTy}(U) \land \text{AllZero}(bytes)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{LLVMGlobalZero}(sym, \tau, align) = \text{LLVMGlobalConst}(sym, \tau, \texttt{zeroinitializer}, align)$$

$$\text{LenLit}(n) = \text{IntLiteral}(\text{IntValue}=n)$$
$$\text{StaticType}(sym) =
\begin{cases}
\text{TypeArray}(\text{TypePrim}(\texttt{"u8"}), \text{LenLit}(|bytes|)) & sym = \text{Mangle}(\text{LiteralData}(kind, bytes))\\
\text{StaticBindTypes}(sym) & \text{otherwise}
\end{cases}$$
$$\text{ProcModule}(sym) = m \iff \exists item, p.\ item = \text{ProcedureDecl}(\_,\_,\_,\_,\_,\_,\_) \land \text{ItemPath}(item) = p \land sym = \text{ScopedSym}(item) \land \text{ModuleOfPath}(p) = m$$
$$\text{SigOf}(callee) =
\begin{cases}
\langle params, ret \rangle & callee = \text{Mangle}(d)\ \land d \in \{\text{ProcedureDecl}, \text{MethodDecl}, \text{DefaultImpl}\} \land \text{Sig}(d)=\langle params, ret \rangle\\
\text{RuntimeSig}(sym) & callee = sym \land \text{RuntimeSig}(sym)\ \text{defined}\\
\langle params, ret \rangle & \text{ExprType}(callee) = \text{TypeFunc}(params, ret)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{LoweredSigOf}(callee) = \langle params', ret \rangle \iff \langle params, ret \rangle = \text{SigOf}(callee) \land params' = ( \text{NeedsPanicOut}(callee) Sigma params \mathbin{+\!\!+} [\text{PanicOutParam}] : params )$$

$$\text{ParamInitIR}(sig, params) = \mathbin{+\!\!+}_{\langle mode, x, T \rangle \in params} \text{ParamInit}(sig, params, x, mode, T)$$
$$\text{ZeroValue}(T) = \texttt{zeroinitializer} \quad\text{if } \text{sizeof}(T)=0$$
$$\text{ParamInit}(sig, params, x, mode, T) =
\begin{cases}
\text{Store}(\text{BindSlot}(x), \text{LLVMParam}(sig, params, x), T) & \text{ABIParam}(mode, T) = \texttt{ByValue} \land \text{sizeof}(T) > 0\\
\text{Store}(\text{BindSlot}(x), \text{ZeroValue}(T), T) & \text{ABIParam}(mode, T) = \texttt{ByValue} \land \text{sizeof}(T) = 0\\
\epsilon & \text{ABIParam}(mode, T) = \texttt{ByRef}
\end{cases}$$
$$\text{ParamOrder}(params) = [x_i \mid \langle mode_i, x_i, T_i \rangle \in params \land (\text{ABIParam}(mode_i, T_i)=\texttt{ByRef} \lor \text{sizeof}(T_i) > 0)]$$
$$\text{ParamIndex}(params, x) = i \iff \text{ParamOrder}(params)[i] = x$$
$$\text{LLVMArgs}(sig) = sig.\text{llvm\_params}$$
$$\text{LLVMArg}(sig, i) = \text{LLVMArgs}(sig)[i]$$
$$i' = (\text{sig}.\text{sretSigma} Sigma \text{ParamIndex}(params, x) + 1 : \text{ParamIndex}(params, x))$$
$$\text{LLVMParam}(sig, params, x) = \text{LLVMArg}(sig, i')$$

**(LowerIRDecl-Proc-User)**
$$\frac{
\text{LLVMCallSig}(params, R) \Downarrow sig \quad
\text{ProcModule}(sym) = m \quad
IR_p = \text{ParamInitIR}(sig, params) \quad
IR_0 = (\text{NeedsPanicOut}(sym) Sigma \text{SeqIR}(\text{ClearPanic}, IR) : IR) \quad
IR' = \text{SeqIR}(IR_p, \text{CheckPoison}(m), IR_0) \quad
\Gamma \vdash \text{LowerIRInstr}(IR') \Downarrow ll
}{\Gamma \vdash \text{LowerIRDecl}(\text{ProcIR}(sym, params, R, IR)) \Downarrow \text{LLVMDefine}(sym, sig, ll)}$$

**(LowerIRDecl-Proc-Gen)**
$$\frac{
\text{LLVMCallSig}(params, R) \Downarrow sig \quad
\text{ProcModule}(sym)\ \text{undefined} \quad
IR_p = \text{ParamInitIR}(sig, params) \quad
\Gamma \vdash \text{LowerIRInstr}(\text{SeqIR}(IR_p, (\text{NeedsPanicOut}(sym) Sigma \text{SeqIR}(\text{ClearPanic}, IR) : IR))) \Downarrow ll
}{\Gamma \vdash \text{LowerIRDecl}(\text{ProcIR}(sym, params, R, IR)) \Downarrow \text{LLVMDefine}(sym, sig, ll)}$$

**(LowerIRDecl-GlobalConst)**
$$\frac{
T = \text{StaticType}(sym) \quad
\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad
\text{ConstBytes}(\tau, bytes) = c
}{\Gamma \vdash \text{LowerIRDecl}(\text{GlobalConst}(sym, bytes)) \Downarrow \text{LLVMGlobalConst}(sym, \tau, c, \text{alignof}(T))}$$

**(LowerIRDecl-GlobalZero)**
$$\frac{
T = \text{StaticType}(sym) \quad
\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad
size = \text{sizeof}(T)
}{\Gamma \vdash \text{LowerIRDecl}(\text{GlobalZero}(sym, size)) \Downarrow \text{LLVMGlobalZero}(sym, \tau, \text{alignof}(T))}$$

**(LowerIRDecl-VTable)**
$$\frac{\text{GlobalVTable}(sym, header, slots) = d}{\Gamma \vdash \text{LowerIRDecl}(d) \Downarrow \text{LLVMGlobalVTable}(sym, header, slots)}$$

**(Lower-AllocIR)**
$$\frac{
\text{RegionSym}(\texttt{Region::alloc}) \Downarrow sym \quad
r = \begin{cases}
\text{InnermostActiveRegion}(\Gamma) & r_{opt} = \bot\\
r_{opt} & \text{otherwise}
\end{cases} \quad
\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(sym, [r, v])) \Downarrow ll
}{\Gamma \vdash \text{LowerIRInstr}(\text{AllocIR}(r_{opt}, v)) \Downarrow ll}$$

**(Lower-BindVarIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x}{\Gamma \vdash \text{LowerIRInstr}(\text{BindVarIR}(x, v)) \Downarrow \langle [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-ReadVarIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x \quad \Gamma \vdash \text{BindValid}(x) \Downarrow \text{Valid}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadVarIR}(x)) \Downarrow \langle [\text{Load}(slot, T_x)], v \rangle}$$

**(Lower-ReadVarIR-Err)**
$$\frac{\Gamma \vdash \text{BindValid}(x) \Downarrow s \quad s \ne \text{Valid}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadVarIR}(x)) \Uparrow}$$

$$\text{PathSym}(path, name) = \text{PathSig}(path \mathbin{+\!\!+} [name])$$
$$\text{ProcSymbol}(sym) \iff \exists item.\ item \in \{\text{ProcedureDecl}, \text{MethodDecl}, \text{ClassMethodDecl}, \text{StateMethodDecl}, \text{TransitionDecl}, \text{DefaultImpl}\} \land \Gamma \vdash \text{Mangle}(item) \Downarrow sym$$

**(Lower-ReadPathIR-Static-User)**
$$\frac{\text{StaticSymPath}(path, name) = sym \quad \text{ProcModule}(sym) = m \quad T = \text{StaticType}(sym) \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p \mathbin{+\!\!+} [\text{Load}(@sym, T)], v \rangle}$$

**(Lower-ReadPathIR-Static-Gen)**
$$\frac{\text{StaticSymPath}(path, name) = sym \quad \text{ProcModule}(sym)\ \text{undefined} \quad T = \text{StaticType}(sym)}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle [\text{Load}(@sym, T)], v \rangle}$$

**(Lower-ReadPathIR-Proc-User)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{ProcSymbol}(sym) \quad \text{ProcModule}(sym) = m \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p, sym \rangle}$$

**(Lower-ReadPathIR-Proc-Gen)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{ProcSymbol}(sym) \quad \text{ProcModule}(sym)\ \text{undefined}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle \epsilon, sym \rangle}$$

**(Lower-ReadPathIR-Runtime)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{RuntimeSig}(sym)\ \text{defined}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle \epsilon, sym \rangle}$$

**(Lower-ReadPathIR-Record)**
$$\frac{p = path \mathbin{+\!\!+} [name] \quad \text{RecordDecl}(p) = R \quad \text{ModuleOfPath}(p) = m \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p, \text{RecordCtor}(p) \rangle}$$

**(Lower-StoreVarIR)**
$$\frac{
\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad
\text{TypeOf}(x) = T_x \quad
\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow IR_d
}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreVarIR}(x, v)) \Downarrow \langle IR_d \mathbin{+\!\!+} [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-StoreVarNoDropIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreVarNoDropIR}(x, v)) \Downarrow \langle [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-MoveStateIR)**
$$\frac{x = \text{PlaceRoot}(p) \quad \Gamma \vdash \text{UpdateValid}(x, \text{MoveStateIR}(p)) \Downarrow v'}{\Gamma \vdash \text{LowerIRInstr}(\text{MoveStateIR}(p)) \Downarrow \langle \epsilon, \bot \rangle}$$

**(Lower-StoreGlobal)**
$$\frac{T = \text{StaticType}(sym) \quad \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreGlobal}(sym, v)) \Downarrow \langle [\text{Store}(@sym, v, T)], \bot \rangle}$$

**(Lower-ReadPlaceIR)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPlaceIR}(p)) \Downarrow ll}$$

**(Lower-WritePlaceIR)**
$$\frac{\Gamma \vdash \text{LowerWritePlace}(p, v) \Downarrow IR_w \quad \Gamma \vdash \text{LowerIRInstr}(IR_w) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePlaceIR}(p, v)) \Downarrow ll}$$

$$\text{PtrType}(v) = T \iff (\exists e, IR.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \land T = \text{ExprType}(e)) \lor (\exists p, IR.\ \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR, v \rangle \land T = \text{ExprType}(p))$$
$$\text{ValueType}(v) = \text{TypePrim}(\texttt{"bool"}) \iff \exists b.\ v=\text{BoolVal}(b)$$
$$\text{ValueType}(v) = \text{TypePrim}(\texttt{"char"}) \iff \exists u.\ v=\text{CharVal}(u)$$
$$\text{ValueType}(\text{UnitVal}) = \text{TypePrim}(\texttt{"()"})$$
$$\text{ValueType}(\text{IntVal}(t, x)) = \text{TypePrim}(t)$$
$$\text{ValueType}(\text{FloatVal}(t, v)) = \text{TypePrim}(t)$$
$$\text{ValueType}(\text{PtrVal}(s, addr)) = \text{TypePtr}(T, s) \iff T \in \text{Type}$$
$$\text{ValueType}(\text{RawPtr}(q, addr)) = \text{TypeRawPtr}(q, T) \iff T \in \text{Type}$$
$$\text{ValueType}((v_1,\ldots,v_n)) = \text{TypeTuple}([T_1,\ldots,T_n]) \iff \forall i.\ \text{ValueType}(v_i) = T_i$$
$$\text{ValueType}([v_1,\ldots,v_n]) = \text{TypeArray}(T, \text{Literal}(\text{IntLiteral}(n))) \iff \forall i.\ \text{ValueType}(v_i) = T$$
$$\text{ValueType}(\text{SliceValue}(v, r)) = \text{TypeSlice}(T) \iff \text{ValueType}(v) = \text{TypeArray}(T,\_) \lor \text{ValueType}(v) = \text{TypeSlice}(T)$$
$$\text{ValueType}(\text{RecordValue}(\text{TypePath}(p), fs)) = \text{TypePath}(p)$$
$$\text{ValueType}(\text{RecordValue}(\text{ModalStateRef}(p, S), fs)) = \text{TypeModalState}(p, S)$$
$$\text{ValueType}(\text{EnumValue}(path, payload)) = \text{TypePath}(p) \iff \text{EnumPath}(path) = p$$
$$\text{ValueType}(\text{RangeVal}(k, lo, hi)) = \text{TypeRange}$$
$$\text{ValueType}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)) = \text{TypeDynamic}(Cl)$$
$$\text{ValueType}(v) = \text{TypeString}(\texttt{@View}) \iff v \in \texttt{string@View}$$
$$\text{ValueType}(v) = \text{TypeString}(\texttt{@Managed}) \iff v \in \texttt{string@Managed}$$
$$\text{ValueType}(v) = \text{TypeBytes}(\texttt{@View}) \iff v \in \texttt{bytes@View}$$
$$\text{ValueType}(v) = \text{TypeBytes}(\texttt{@Managed}) \iff v \in \texttt{bytes@Managed}$$
$$\text{ValueType}(v) = \text{TypeString}(\bot) \iff \text{ValueType}(v) = \text{TypeString}(\texttt{@View}) \lor \text{ValueType}(v) = \text{TypeString}(\texttt{@Managed})$$
$$\text{ValueType}(v) = \text{TypeBytes}(\bot) \iff \text{ValueType}(v) = \text{TypeBytes}(\texttt{@View}) \lor \text{ValueType}(v) = \text{TypeBytes}(\texttt{@Managed})$$
$$\text{ValueType}(v) = \text{TypePath}(p) \iff \exists S, M.\ \text{ValueType}(v) = \text{TypeModalState}(p, S) \land \Sigma.\text{Types}[p] = \texttt{modal } M \land S \in \text{States}(M)$$
$$\text{ValueType}(v) = U \iff \exists T.\ \text{ValueType}(v) = T \land \text{Member}(T, U)$$

**(Lower-ReadPtrIR)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPtrIR}(v_{ptr})) \Downarrow \langle [\text{Load}(\text{PtrAddr}(v_{ptr}), T)], v \rangle}$$

**(Lower-ReadPtrIR-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPtrIR}(v_{ptr})) \Downarrow \langle [\text{Load}(\text{PtrAddr}(v_{ptr}), T)], v \rangle}$$

**(Lower-WritePtrIR)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow \langle [\text{Store}(\text{PtrAddr}(v_{ptr}), v, T)], \bot \rangle}$$

**(Lower-WritePtrIR-Null)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(\text{NullDeref})) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow ll}$$

**(Lower-WritePtrIR-Expired)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(\text{ExpiredDeref})) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow ll}$$

**(Lower-WritePtrIR-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(\texttt{mut}, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow \langle [\text{Store}(\text{PtrAddr}(v_{ptr}), v, T)], \bot \rangle}$$

**(Lower-WritePtrIR-Raw-Err)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(\texttt{imm}, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Uparrow}$$

**(Lower-AddrOfIR)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{AddrOfIR}(p)) \Downarrow ll}$$

**(Lower-CallIR-RecordCtor)**
$$\frac{\text{CallTarget}(callee) = \text{RecordCtor}(p) \quad args = [] \quad \text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR_f, \vec{f} \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(callee, args)) \Downarrow \langle IR_f, \text{RecordValue}(\text{TypePath}(p), \vec{f}) \rangle}$$

$$\text{CallPoison}(f) =
\begin{cases}
\text{CheckPoison}(m) & \text{ProcModule}(f)=m\\
\epsilon & \text{ProcModule}(f)\ \text{undefined}
\end{cases}$$

$$\text{SRetAlloc}(R) \Downarrow \langle [\texttt{alloca}\ \text{LLVMTy}(R)], p \rangle$$

$$\text{CallArgs}(sig, params, args, R) \Downarrow \langle I_a, \vec{a}, p_{ret} \rangle \iff
\begin{cases}
I_a = \epsilon \land \vec{a} = args \land p_{ret} = \bot & sig.\text{sretSigma} = \text{false}\\
\exists p.\ \text{SRetAlloc}(R) \Downarrow \langle I_s, p \rangle \land I_a = I_s \land \vec{a} = [p] \mathbin{+\!\!+} args \land p_{ret} = p & sig.\text{sretSigma} = \text{true}
\end{cases}$$

$$\text{CallInstr}(sig, f, \vec{a}) \Downarrow \langle [\texttt{call}\ sig\ f(\vec{a})], v_c \rangle \iff
v_c = (\text{sig}.\text{llvm\_ret} = \texttt{void} Sigma \bot : \text{call\_result})$$

$$\text{CallResult}(sig, R, p_{ret}, v_c) \Downarrow \langle I_r, v \rangle \iff
\begin{cases}
I_r = \epsilon \land v = v_c & sig.\text{sretSigma} = \text{false}\\
\text{LoadVal}(p_{ret}, R) \Downarrow \langle I_r, v \rangle & sig.\text{sretSigma} = \text{true}
\end{cases}$$

**(Lower-CallIR-Func)**
$$\frac{
\text{CallTarget}(callee) = f \quad
\text{LoweredSigOf}(f) = \langle params, ret \rangle \quad
\text{LLVMCallSig}(params, ret) \Downarrow sig \quad
\text{CallPoison}(f) = IR_p \quad
\Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow \langle I_p, \bot \rangle \quad
\text{CallArgs}(sig, params, args, ret) \Downarrow \langle I_a, \vec{a}, p_{ret} \rangle \quad
\text{CallInstr}(sig, f, \vec{a}) \Downarrow \langle I_c, v_c \rangle \quad
\text{CallResult}(sig, ret, p_{ret}, v_c) \Downarrow \langle I_r, v_{\text{call}} \rangle
}{\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(callee, args)) \Downarrow \langle I_p \mathbin{+\!\!+} I_a \mathbin{+\!\!+} I_c \mathbin{+\!\!+} I_r, v_{\text{call}} \rangle}$$

$$\text{DynType}(v) = \text{TypeDynamic}(Cl) \iff (\exists e, IR.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \land \text{ExprType}(e)=\text{TypeDynamic}(Cl)) \lor (\exists p, IR.\ \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR, v \rangle \land \text{ExprType}(p)=\text{TypeDynamic}(Cl))$$
$$\text{DynData}(v) = \text{FieldValue}(v, \texttt{data}) \quad\text{and}\quad \text{DynVTable}(v) = \text{FieldValue}(v, \texttt{vtable})$$
$$\text{VTableSlotIndex}(i) = i + 3$$
$$\text{GEP}(ptr, [i_0,\ldots,i_k]) = v_{gep}$$
$$\text{VTableSlotAddr}(vt, i) = \text{GEP}(vt, [0,\ \text{VTableSlotIndex}(i)])$$
$$\text{VTableSlot}(vt, i) = \text{Load}(\text{VTableSlotAddr}(vt, i), \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})))$$

**(Lower-CallVTable)**
$$\frac{
\text{DynType}(base) = \text{TypeDynamic}(Cl) \quad
v_d = \text{DynData}(base) \quad
v_t = \text{DynVTable}(base) \quad
v_s = \text{VTableSlot}(v_t, i) \quad
\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(v_s, [v_d] \mathbin{+\!\!+} args)) \Downarrow ll
}{\Gamma \vdash \text{LowerIRInstr}(\text{CallVTable}(base, i, args)) \Downarrow ll}$$

**(LowerIRInstr-ClearPanic)**
$$\frac{\Gamma \vdash \text{ClearPanic} \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{ClearPanic}) \Downarrow ll}$$

**(LowerIRInstr-PanicCheck)**
$$\frac{\Gamma \vdash \text{PanicCheck} \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{PanicCheck}) \Downarrow ll}$$

**(LowerIRInstr-CheckPoison)**
$$\frac{\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow ll}$$

**(LowerIRInstr-LowerPanic)**
$$\frac{\Gamma \vdash \text{LowerPanic}(r) \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(r)) \Downarrow ll}$$

$$\text{IfPhi}(v_t, v_f, l_t, l_f) \Downarrow \langle I_\phi, v_\phi \rangle \iff
\begin{cases}
I_\phi = \epsilon \land v_\phi = \bot & v_t=\bot \lor v_f=\bot\\
\exists T,\tau,inc.\ \text{ValueType}(v_t)=T \land \text{ValueType}(v_f)=T \land \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land inc = [\langle v_t, l_t \rangle,\ \langle v_f, l_f \rangle] \land I_\phi = [\text{Phi}(\tau, inc, v_\phi)] & v_t\ne\bot \land v_f\ne\bot
\end{cases}$$

$$\text{IfLowerForm}(I, v_c, v_t, v_f, v) \iff \text{HasBrCond}(I, v_c) \land ((v_t=\bot \lor v_f=\bot) \Rightarrow v=\bot) \land ((v_t\ne\bot \land v_f\ne\bot) \Rightarrow \text{HasPhi}(I, v))$$

**(Lower-IfIR)**
$$\frac{\text{IfLabels}(\Gamma) = \langle l_t,l_f,l_m \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_t) \Downarrow \langle I_t, v_t' \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_f) \Downarrow \langle I_f, v_f' \rangle \quad v_t'=v_t \quad v_f'=v_f \quad \text{IfPhi}(v_t, v_f, l_t, l_f) \Downarrow \langle I_\phi, v \rangle \quad I = [\text{BrCond}(v_c, l_t, l_f),\ \text{Label}(l_t)] \mathbin{+\!\!+} I_t \mathbin{+\!\!+} [\text{Br}(l_m),\ \text{Label}(l_f)] \mathbin{+\!\!+} I_f \mathbin{+\!\!+} [\text{Br}(l_m),\ \text{Label}(l_m)] \mathbin{+\!\!+} I_\phi \quad \text{IfLowerForm}(I, v_c, v_t, v_f, v)}{\Gamma \vdash \text{LowerIRInstr}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f)) \Downarrow \langle I, v \rangle}$$

$$\text{BlockScope}(IR_s, IR_t) = scope$$
$$\text{BlockScope}(IR_s, IR_t) = scope \iff \left(\exists \sigma,\sigma_1,\sigma_2,out,scope_0.\ \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope_0) \land \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2)\right) \land \left(\forall \sigma,\sigma_1,\sigma_2,out,scope_0.\ \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope_0) \land \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2) \Rightarrow \text{CurrentScope}(\sigma_2) = scope\right)$$
$$\text{EmitCleanupSpec}(cs, IR) \iff \forall \sigma,\ \Gamma \vdash \text{Cleanup}(cs, \sigma) \Downarrow (c, \sigma') \Rightarrow (\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land ((c=\text{panic}) \Rightarrow out=\text{Ctrl}(\text{Panic})) \land ((c=\text{ok}) \Rightarrow out=\text{Val}(())))$$
$$\Gamma \vdash \text{EmitCleanup}(cs) \Downarrow IR \iff \text{EmitCleanupSpec}(cs, IR)$$

**(Lower-BlockIR)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(IR_s) \Downarrow \langle I_s, \bot \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_t) \Downarrow \langle I_t, v_t' \rangle \quad v_t'=v_t \quad \text{BlockScope}(IR_s, IR_t) = scope \quad \Gamma \vdash \text{CleanupPlan}(scope) \Downarrow cs \quad \Gamma \vdash \text{EmitCleanup}(cs) \Downarrow IR_c \quad \Gamma \vdash \text{LowerIRInstr}(IR_c) \Downarrow \langle I_c, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{BlockIR}(IR_s, IR_t, v_t)) \Downarrow \langle I_s \mathbin{+\!\!+} I_t \mathbin{+\!\!+} I_c, v_t \rangle}$$

$$\text{LoopLowerForm}(I, loop, v)\ \text{predicate}$$
$$\text{LoopIRForm}(loop)\ \text{predicate}$$
$$\text{MatchLowerForm}(I, match, v)\ \text{predicate}$$
$$\text{MatchIRForm}(match)\ \text{predicate}$$
$$\text{RegionLowerForm}(I, region, v)\ \text{predicate}$$
$$\text{RegionIRForm}(region)\ \text{predicate}$$
$$\text{FrameLowerForm}(I, frame, v)\ \text{predicate}$$
$$\text{FrameIRForm}(frame)\ \text{predicate}$$
$$\text{LoopLowerForm}(I, loop, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{MatchLowerForm}(I, match, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{RegionLowerForm}(I, region, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{FrameLowerForm}(I, frame, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{LoopIRForm}(loop) \iff (\exists IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopInfinite}, IR_b, v_b)) \lor (\exists IR_c, v_c, IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b)) \lor (\exists pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b))$$
$$\text{MatchIRForm}(match) \iff \exists v_s, arms.\ match = \text{MatchIR}(v_s, arms)$$
$$\text{RegionIRForm}(region) \iff \exists v_o, alias\_opt, IR_b, v_b.\ region = \text{RegionIR}(v_o, alias\_opt, IR_b, v_b)$$
$$\text{FrameIRForm}(frame) \iff \exists v_r, IR_b, v_b.\ frame = \text{FrameIR}(v_r, IR_b, v_b)$$

**(Lower-LoopIR)**
$$\frac{\text{LoopIRForm}(loop) \quad \text{LoopLowerForm}(I, loop, v)}{\Gamma \vdash \text{LowerIRInstr}(loop) \Downarrow \langle I, v \rangle}$$

**(Lower-MatchIR)**
$$\frac{\text{MatchIRForm}(match) \quad \text{MatchLowerForm}(I, match, v)}{\Gamma \vdash \text{LowerIRInstr}(match) \Downarrow \langle I, v \rangle}$$

**(Lower-RegionIR)**
$$\frac{\text{RegionIRForm}(region) \quad \text{RegionLowerForm}(I, region, v)}{\Gamma \vdash \text{LowerIRInstr}(region) \Downarrow \langle I, v \rangle}$$

**(Lower-FrameIR)**
$$\frac{\text{FrameIRForm}(frame) \quad \text{FrameLowerForm}(I, frame, v)}{\Gamma \vdash \text{LowerIRInstr}(frame) \Downarrow \langle I, v \rangle}$$

$$\text{BranchLowerForm}(I, target) \iff \text{Br}(target) \in I$$
$$\text{BranchLowerForm}(I, v_c, t, f) \iff \text{BrCond}(v_c, t, f) \in I$$

**(Lower-BranchIR)**
$$\frac{\text{BranchLowerForm}(I, target)}{\Gamma \vdash \text{LowerIRInstr}(\text{BranchIR}(target)) \Downarrow \langle I, \bot \rangle}$$
$$\frac{\text{BranchLowerForm}(I, v_c, t, f)}{\Gamma \vdash \text{LowerIRInstr}(\text{BranchIR}(v_c, t, f)) \Downarrow \langle I, \bot \rangle}$$

$$\text{PhiLowerForm}(I, T, inc, v) \iff \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land I = [\text{Phi}(\tau, inc, v)]$$

**(Lower-PhiIR)**
$$\frac{\text{PhiLowerForm}(I, T, inc, v)}{\Gamma \vdash \text{LowerIRInstr}(\text{PhiIR}(T, inc, v)) \Downarrow \langle I, v \rangle}$$

**(LowerIRDecl-Err)**
$$\frac{\Gamma \vdash \text{LowerIRDecl}(d) \Uparrow}{\Gamma \vdash \text{LowerIRDecl}(d) \Uparrow}$$

**(LowerIRInstr-Err)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(op) \Uparrow}{\Gamma \vdash \text{LowerIRInstr}(op) \Uparrow}$$

#### 6.12.11. Binding Storage and Validity

$$\text{BindStorageJudg} = \{\text{BindSlot}(x) \Downarrow slot,\ \text{BindValid}(x) \Downarrow v,\ \text{UpdateValid}(x, op) \Downarrow v',\ \text{DropOnAssign}(x, slot) \Downarrow IR\}$$
$$\text{TypeOf}(x) = T \iff \Gamma; R; L \vdash \text{Identifier}(x) : T$$
$$\text{BindInfo}(x) = info \iff \text{BindState}(\Gamma) = \mathcal{B} \land \text{Lookup}_B(\mathcal{B}, x) = info$$

$$\text{ProcParams}(\Gamma) = params \iff \Gamma\ \text{is lowering}\ \text{ProcIR}(\_, params, \_, \_)$$
$$\text{ProcRet}(\Gamma) = R \iff \Gamma\ \text{is lowering}\ \text{ProcIR}(\_, \_, R, \_)$$
$$\text{ProcSig}(\Gamma) = sig \iff \Gamma \vdash \text{LLVMCallSig}(\text{ProcParams}(\Gamma), \text{ProcRet}(\Gamma)) \Downarrow sig$$
$$\text{ParamEntry}(params, x) = \langle mode, T \rangle \iff \langle mode, x, T \rangle \in params$$
$$\text{AllocaSlot}(T) = \text{LLVMAlloca}(\text{LLVMTy}(T))$$
$$\text{BindState}(\Gamma) = \Gamma.\text{bind\_state}$$

**(BindValid-Sigma)**
$$\frac{\text{BindState}(\Gamma) = \mathcal{B} \quad \text{Lookup}_B(\mathcal{B}, x) = \langle s,\_,\_,\_ \rangle}{\Gamma \vdash \text{BindValid}(x) \Downarrow s}$$

**(BindSlot-Param-ByValue)**
$$\frac{\text{ProcParams}(\Gamma) = params \quad \text{ParamEntry}(params, x) = \langle mode, T \rangle \quad \Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByValue}}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{AllocaSlot}(T)}$$

**(BindSlot-Param-ByRef)**
$$\frac{\text{ProcParams}(\Gamma) = params \quad \text{ParamEntry}(params, x) = \langle mode, T \rangle \quad \Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef} \quad \text{ProcSig}(\Gamma) = sig}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{LLVMParam}(sig, params, x)}$$

**(BindSlot-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot \quad \text{ParamEntry}(\text{ProcParams}(\Gamma), x)\ \text{undefined}}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{AllocaSlot}(\text{TypeOf}(x))}$$

**(BindSlot-Static)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym}{\Gamma \vdash \text{BindSlot}(x) \Downarrow @sym}$$

**(UpdateValid-BindVar)**
$$\frac{}{\Gamma \vdash \text{UpdateValid}(x, \text{BindVarIR}(x, v)) \Downarrow \text{Valid}}$$

**(UpdateValid-StoreVar)**
$$\frac{}{\Gamma \vdash \text{UpdateValid}(x, \text{StoreVarIR}(x, v)) \Downarrow \text{Valid}}$$

**(UpdateValid-StoreVarNoDrop)**
$$\frac{\Gamma \vdash \text{BindValid}(x) \Downarrow s}{\Gamma \vdash \text{UpdateValid}(x, \text{StoreVarNoDropIR}(x, v)) \Downarrow s}$$

**(UpdateValid-MoveRoot)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = \bot}{\Gamma \vdash \text{UpdateValid}(x, op) \Downarrow \text{Moved}}$$

**(UpdateValid-PartialMove-Init)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{BindValid}(x) \Downarrow \text{Valid}}{\text{UpdateValid}(x, op) \Downarrow \text{PartiallyMoved}(\{f\})}$$

**(UpdateValid-PartialMove-Step)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{BindValid}(x) \Downarrow \text{PartiallyMoved}(F)}{\text{UpdateValid}(x, op) \Downarrow \text{PartiallyMoved}(F \cup \{f\})}$$

$$\text{DropOnAssignApplicable}(x) \iff \text{BindInfo}(x).\text{mov} = \text{immov} \land \text{BindInfo}(x).\text{resp} = \text{resp}$$
$$\text{AddrAdd}(addr, n) = addr + n$$
$$\text{ElemType}(T_b) = T \iff \text{StripPerm}(T_b) = \text{TypeArray}(T, \_) \lor \text{StripPerm}(T_b) = \text{TypeSlice}(T)$$
$$\text{FieldAddr}(T, addr, f) = \text{AddrAdd}(addr, \text{FieldOffset}(\text{Fields}(R), f)) \quad\text{when } \text{StripPerm}(T)=\text{TypePath}(p)\ \text{and } \text{RecordDecl}(p)=R$$
$$\text{TupleAddr}(T, addr, i) = \text{AddrAdd}(addr, \text{FieldOffset}(\text{TupleFields}([T_1,\ldots,T_n]), i)) \quad\text{when } \text{StripPerm}(T)=\text{TypeTuple}([T_1,\ldots,T_n])$$

**(DropOnAssign-NotApplicable)**
$$\frac{\neg \text{DropOnAssignApplicable}(x)}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

$$\text{FieldsRev}(R) = \text{rev}(\text{Fields}(R))$$
$$\text{FieldDropIR}(slot, p, f, T) = \text{EmitDrop}(T, \text{Load}(\text{FieldAddr}(\text{TypePath}(p), slot, f), T))$$
$$\text{FieldDropSeq}(slot, p, F) = \mathbin{+\!\!+}_{\langle f_i, T_i \rangle \in \text{FieldsRev}(\text{RecordDecl}(p)),\ f_i \notin F}\ \text{FieldDropIR}(slot, p, f_i, T_i)$$

**(DropOnAssign-Record-Valid)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{Valid}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{EmitDrop}(\text{TypePath}(p), \text{Load}(slot, \text{TypePath}(p)))}$$

**(DropOnAssign-Record-Partial)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{PartiallyMoved}(F)}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{FieldDropSeq}(slot, p, F)}$$

**(DropOnAssign-Record-Moved)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

**(DropOnAssign-Aggregate-Ok)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) \in \{\text{TypeArray}(\_,\_),\ \text{TypeTuple}(\_),\ \text{TypeUnion}(\_),\ \text{TypeModalState}(\_,\_)\} \quad \text{BindValid}(x) \Downarrow s \quad s \ne \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{EmitDrop}(\text{TypeOf}(x), \text{Load}(slot, \text{TypeOf}(x)))}$$

**(DropOnAssign-Aggregate-Moved)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) \in \{\text{TypeArray}(\_,\_),\ \text{TypeTuple}(\_),\ \text{TypeUnion}(\_),\ \text{TypeModalState}(\_,\_)\} \quad \text{BindValid}(x) \Downarrow \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

**(BindSlot-Err)**
$$\frac{\text{BindSlot}(x)\ \text{undefined}}{\Gamma \vdash \text{BindSlot}(x) \Uparrow}$$

**(BindValid-Err)**
$$\frac{\text{BindValid}(x)\ \text{undefined}}{\Gamma \vdash \text{BindValid}(x) \Uparrow}$$

**(UpdateValid-Err)**
$$\frac{\text{UpdateValid}(x, op)\ \text{undefined}}{\Gamma \vdash \text{UpdateValid}(x, op) \Uparrow}$$

**(DropOnAssign-Err)**
$$\frac{\text{DropOnAssign}(x, slot)\ \text{undefined}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Uparrow}$$

#### 6.12.12. Call ABI Mapping

$$\text{LLVMCallJudg} = \{\text{LLVMCallSig}(params, ret) \Downarrow sig,\ \text{LLVMArgLower}(x, T, k) \Downarrow ll,\ \text{LLVMRetLower}(T, k) \Downarrow ll\}$$

$$\text{SigLLVMParams}(sig) = llvm\_params$$
$$\text{SigLLVMRet}(sig) = llvm\_ret$$
$$\text{SigLLVMAttrs}(sig) = attrs$$
$$\text{SigSRet}(sig) = sretSigma$$

**(LLVMArgLower-ByValue-PtrValid)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{StripPerm}(T) = \text{TypePtr}(U, \texttt{Valid})}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByValue}) \Downarrow \langle \tau, \text{LLVMArgAttrsExt}(x, T) \cup \text{LLVMPtrAttrs}(T) \rangle}$$

**(LLVMArgLower-ByValue-Other)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{StripPerm}(T) \ne \text{TypePtr}(\_, \texttt{Valid})}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByValue}) \Downarrow \langle \tau, \text{LLVMArgAttrsExt}(x, T) \rangle}$$

**(LLVMArgLower-ByRef)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByRef}) \Downarrow \langle \text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, T), \texttt{Valid})), \text{LLVMPtrAttrs}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, T), \texttt{Valid})) \cup \text{LLVMArgAttrsExt}(x, T) \rangle}$$

**(LLVMRetLower-ByValue-ZST)**
$$\frac{\text{sizeof}(T)=0}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{ByValue}) \Downarrow \texttt{void}}$$

**(LLVMRetLower-ByValue)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{sizeof}(T)>0}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{ByValue}) \Downarrow \tau}$$

**(LLVMRetLower-SRet)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{SRet}) \Downarrow \texttt{void}}$$

$$\text{ArgInclude}(k, T) \iff (k = \texttt{ByRef}) \lor (k = \texttt{ByValue} \land \text{sizeof}(T) > 0)$$
$$\text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]) = [\tau_i \mid \text{ArgInclude}(k_i, T_i) \land \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle]$$
$$\text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]) = [A_i \mid \text{ArgInclude}(k_i, T_i) \land \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle]$$

**(LLVMCall-ByValue)**
$$\frac{\langle [k_1,\ldots,k_n], k_r, sretSigma \rangle = \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad k_r = \texttt{ByValue} \quad \forall i,\ \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle \quad \Gamma \vdash \text{LLVMRetLower}(R, \texttt{ByValue}) \Downarrow \tau_r}{\Gamma \vdash \text{LLVMCallSig}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle], R) \Downarrow \langle \text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \tau_r, \text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \text{false} \rangle}$$

**(LLVMCall-SRet)**
$$\frac{\langle [k_1,\ldots,k_n], k_r, sretSigma \rangle = \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad k_r = \texttt{SRet} \quad sret\_param = \text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{unique}, R), \texttt{Valid})) \quad A_{\text{sret}} = \{ \texttt{sret}, \texttt{noalias} \} \cup \text{LLVMPtrAttrs}(\text{TypePtr}(\text{TypePerm}(\texttt{unique}, R), \texttt{Valid})) \quad \forall i,\ \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle \quad \Gamma \vdash \text{LLVMRetLower}(R, \texttt{SRet}) \Downarrow \texttt{void}}{\Gamma \vdash \text{LLVMCallSig}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle], R) \Downarrow \langle [sret\_param] \mathbin{+\!\!+} \text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \texttt{void}, [A_{\text{sret}}] \mathbin{+\!\!+} \text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \text{true} \rangle}$$

$$\text{ByRefAccess}(T) =
\begin{cases}
\texttt{rw} & \text{PermOf}(T)=\texttt{unique}\\
\texttt{ro} & \text{otherwise}
\end{cases}$$

**(LLVMArgLower-Err)**
$$\frac{\text{LLVMArgLower}(x, T, k)\ \text{undefined}}{\Gamma \vdash \text{LLVMArgLower}(x, T, k) \Uparrow}$$

**(LLVMRetLower-Err)**
$$\frac{\text{LLVMRetLower}(T, k)\ \text{undefined}}{\Gamma \vdash \text{LLVMRetLower}(T, k) \Uparrow}$$

**(LLVMCall-Err)**
$$\frac{\text{LLVMCallSig}(params, ret)\ \text{undefined}}{\Gamma \vdash \text{LLVMCallSig}(params, ret) \Uparrow}$$

#### 6.12.13. VTable Emission

$$\text{VTableJudg} = \{\text{EmitVTable}(T, Cl) \Downarrow IRDecl,\ \text{EmitDropGlue}(T) \Downarrow IRDecl,\ \text{DropGlueSym}(T) \Downarrow sym\}$$

$$\text{DropGlueSym}(T) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"drop"}] \mathbin{+\!\!+} \text{PathOfType}(T))$$
$$\text{VTableHeader}(T) = [\text{sizeof}(T),\ \text{alignof}(T),\ \text{DropGlueSym}(T)]$$
$$\text{PtrTy} = \text{LLVMPtrTy}(\text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})))$$
$$k = |\text{VTable}(T,Cl)|$$
$$\text{VTableTy}(Cl) = \text{LLVMStruct}([\text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})),\ \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})),\ \text{PtrTy}] \mathbin{+\!\!+} [\text{PtrTy}]^k)$$
$$\text{GlobalVTable} : \text{Symbol} \times \text{Header} \times \text{Slots} \to \text{IRDecl}$$
$$\text{LLVMGlobalVTable} : \text{Symbol} \times \text{Header} \times \text{Slots} \to \text{LLVMDecl}$$

**(EmitVTable-Decl)**
$$\frac{\text{Mangle}(\text{VTableDecl}(T, Cl)) \Downarrow sym}{\Gamma \vdash \text{EmitVTable}(T, Cl) \Downarrow \text{GlobalVTable}(sym, \text{VTableHeader}(T), \text{VTable}(T, Cl))}$$

$$\text{VTableSlots}(T, Cl) = [\text{DispatchSym}(T, Cl, m.\text{name}) \mid m \in \text{VTableEligible}(Cl)]$$

$$\text{DropGlueSpec}(T, IR) \iff \forall \sigma, addr, v.\ \text{LookupVal}(\sigma, \texttt{"data"}) = \text{RawPtr}(\texttt{imm}, addr) \land \text{ReadAddr}(\sigma, addr) = v \Rightarrow (\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow \sigma')$$
$$\Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR \iff \text{DropGlueSpec}(T, IR)$$

**(EmitDropGlue-Decl)**
$$\frac{\Gamma \vdash \text{DropGlueSym}(T) \Downarrow sym \quad \Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR_{\text{drop}}}{\Gamma \vdash \text{EmitDropGlue}(T) \Downarrow \text{ProcIR}(sym, [\langle \texttt{move}, \texttt{data}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})) \rangle,\ \text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{drop}})}$$

**(EmitVTable-Err)**
$$\frac{\text{EmitVTable}(T, Cl)\ \text{undefined}}{\Gamma \vdash \text{EmitVTable}(T, Cl) \Uparrow}$$

#### 6.12.14. Literal Data Emission

$$\text{LiteralEmitJudg} = \{\text{EmitLiteralData}(kind, bytes) \Downarrow IRDecl,\ \text{EmitStringLit}(lit) \Downarrow sym,\ \text{EmitBytesLit}(lit) \Downarrow sym\}$$

$$\text{LiteralDataSym}(kind, bytes) = \text{Mangle}(\text{LiteralData}(kind, bytes))$$
$$\text{StringBytes}(lit)\ \text{function}$$
$$\text{EscapeBytes}(e) =
\begin{cases}
\text{EscapeValue}(e) & e = \texttt{"\\u\{"}h_1\ldots h_n\texttt{"\}"}\\
[\text{EscapeValue}(e)] & \text{otherwise}
\end{cases}$$
$$\text{StringBytesFrom}(T, p, q) =
\begin{cases}
[] & p = q\\
\text{EscapeBytes}(\text{Lexeme}(T,p,r)) \mathbin{+\!\!+} \text{StringBytesFrom}(T,r,q) & p < q \land T[p]=\texttt{"\\"} \land \text{EscapeMatch}(T,p,r)\\
\text{EncodeUTF8}(T[p]) \mathbin{+\!\!+} \text{StringBytesFrom}(T,p+1,q) & p < q \land T[p]\ne\texttt{"\\"}
\end{cases}$$
$$\text{StringBytes}(lit) = bytes \iff lit.\text{kind} = \text{StringLiteral} \land T=\text{Lexeme}(lit) \land \text{StringBytesFrom}(T, 1, |T|-1) = bytes$$
$$\text{RawBytes}(lit) = bytes \iff lit.\text{kind} = \text{BytesLiteral} \land lit.\text{payload} = bytes$$
$$\text{RawBytes}(lit) = \text{StringBytes}(lit) \iff lit.\text{kind} = \text{StringLiteral}$$

**(EmitLiteralData-Decl)**
$$\frac{\Gamma \vdash \text{Mangle}(\text{LiteralData}(kind, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitLiteralData}(kind, bytes) \Downarrow \text{GlobalConst}(sym, bytes)}$$

**(EmitLiteral-String)**
$$\frac{\text{StringBytes}(lit) = bytes \quad \Gamma \vdash \text{Mangle}(\text{LiteralData}(\texttt{"string"}, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitStringLit}(lit) \Downarrow sym}$$
$$\text{StringBytes}(lit) = bytes \Rightarrow \text{Utf8Valid}(bytes)$$

**(EmitLiteral-Bytes)**
$$\frac{\text{RawBytes}(lit) = bytes \quad \Gamma \vdash \text{Mangle}(\text{LiteralData}(\texttt{"bytes"}, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitBytesLit}(lit) \Downarrow sym}$$
$$\text{RawBytes}(lit)\ \text{undefined} \Rightarrow \text{EmitBytesLit}(lit)\ \text{undefined}$$

**(EmitLiteral-Char)**
$$\frac{T = \text{TypePrim}(\texttt{"char"}) \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"char"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"char"}, bytes)), bytes)}$$

**(EmitLiteral-Int)**
$$\frac{T = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"int"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"int"}, bytes)), bytes)}$$

**(EmitLiteral-Float)**
$$\frac{T = \text{TypePrim}(t) \quad t \in \text{FloatTypes} \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"float"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"float"}, bytes)), bytes)}$$

**(EmitLiteral-Err)**
$$\frac{\text{EmitLiteralData}(kind, bytes)\ \text{undefined}}{\Gamma \vdash \text{EmitLiteralData}(kind, bytes) \Uparrow}$$

#### 6.12.15. String/Bytes Built-ins

$$\text{BuiltinSymJudg} = \{\text{BuiltinSym}(method) \Downarrow sym\}$$

$$\text{StringBuiltins} = \{\texttt{string::from},\ \texttt{string::as\_view},\ \texttt{string::to\_managed},\ \texttt{string::clone\_with},\ \texttt{string::append},\ \texttt{string::length},\ \texttt{string::is\_empty}\}$$
$$\text{BytesBuiltins} = \{\texttt{bytes::with\_capacity},\ \texttt{bytes::from\_slice},\ \texttt{bytes::as\_view},\ \texttt{bytes::to\_managed},\ \texttt{bytes::view},\ \texttt{bytes::view\_string},\ \texttt{bytes::append},\ \texttt{bytes::length},\ \texttt{bytes::is\_empty}\}$$
$$\text{StringMethod}(method) \iff \exists name.\ method = \texttt{string::}name$$
$$\text{BytesMethod}(method) \iff \exists name.\ method = \texttt{bytes::}name$$

$$\text{BuiltinSym}(\texttt{string::from}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"from"}])$$
$$\text{BuiltinSym}(\texttt{string::as\_view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"as\_view"}])$$
$$\text{BuiltinSym}(\texttt{string::to\_managed}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"to\_managed"}])$$
$$\text{BuiltinSym}(\texttt{string::clone\_with}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"clone\_with"}])$$
$$\text{BuiltinSym}(\texttt{string::append}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"append"}])$$
$$\text{BuiltinSym}(\texttt{string::length}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"length"}])$$
$$\text{BuiltinSym}(\texttt{string::is\_empty}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"is\_empty"}])$$

$$\text{BuiltinSym}(\texttt{bytes::with\_capacity}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"with\_capacity"}])$$
$$\text{BuiltinSym}(\texttt{bytes::from\_slice}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"from\_slice"}])$$
$$\text{BuiltinSym}(\texttt{bytes::as\_view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"as\_view"}])$$
$$\text{BuiltinSym}(\texttt{bytes::to\_managed}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"to\_managed"}])$$
$$\text{BuiltinSym}(\texttt{bytes::view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"view"}])$$
$$\text{BuiltinSym}(\texttt{bytes::view\_string}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"view\_string"}])$$
$$\text{BuiltinSym}(\texttt{bytes::append}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"append"}])$$
$$\text{BuiltinSym}(\texttt{bytes::length}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"length"}])$$
$$\text{BuiltinSym}(\texttt{bytes::is\_empty}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"is\_empty"}])$$

**(BuiltinSym-String-Err)**
$$\frac{\text{StringMethod}(method) \quad method \notin \text{StringBuiltins}}{\Gamma \vdash \text{BuiltinSym}(\text{method}) \Uparrow}$$

**(BuiltinSym-Bytes-Err)**
$$\frac{\text{BytesMethod}(method) \quad method \notin \text{BytesBuiltins}}{\Gamma \vdash \text{BuiltinSym}(\text{method}) \Uparrow}$$

#### 6.12.16. Managed String/Bytes Drop Hooks

$$\text{DropHookJudg} = \{\text{StringDropSym} \Downarrow sym,\ \text{BytesDropSym} \Downarrow sym\}$$

**(StringDropSym-Decl)**
$$\frac{}{ \Gamma \vdash \text{StringDropSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"drop_managed"}]) }$$

**(BytesDropSym-Decl)**
$$\frac{}{ \Gamma \vdash \text{BytesDropSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"drop_managed"}]) }$$

**(StringDropSym-Err)**
$$\frac{\text{StringDropSym}\ \text{undefined}}{\Gamma \vdash \text{StringDropSym} \Uparrow}$$

**(BytesDropSym-Err)**
$$\frac{\text{BytesDropSym}\ \text{undefined}}{\Gamma \vdash \text{BytesDropSym} \Uparrow}$$

#### 6.12.17. Entrypoint and Context Construction

$$\text{EntryJudg} = \{\text{EntrySym} \Downarrow sym,\ \text{ContextInitSym} \Downarrow sym,\ \text{EntryStub}(P) \Downarrow IRDecl\}$$

**(EntrySym-Decl)**
$$\frac{}{\Gamma \vdash \text{EntrySym} \Downarrow \text{PathSig}([\texttt{"main"}])}$$

**(ContextInitSym-Decl)**
$$\frac{}{\Gamma \vdash \text{ContextInitSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"context_init"}])}$$

$$\text{PanicRecordInit}(\sigma) \iff \text{PanicRecordOf}(\sigma) = \langle \text{false}, 0 \rangle$$
$$\text{EntryStubSpec}(P, IR_{\text{entry}}) \iff \text{Executable}(P) \land \exists d,\ main\_sym.\ \text{MainDecls}(P)=[d] \land \Gamma \vdash \text{Mangle}(d) \Downarrow main\_sym \land \forall \sigma.\ \exists ctx,\ ret,\ c,\ \sigma_1,\sigma_2,\sigma_3,\sigma_4.\ \text{ExecIRSigma}(\text{CallIR}(\text{ContextInitSym}, []), \sigma) \Downarrow (\text{Val}(ctx), \sigma_1)\ \land\ \text{PanicRecordInit}(\sigma_2)\ \land\ \text{ExecIRSigma}(\text{CallIR}(main\_sym, [ctx,\ \text{PanicOutName}]), \sigma_2) \Downarrow (\text{Val}(ret), \sigma_3)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(\text{CallIR}(\text{PanicSym}, [c]), \sigma_3) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{false}, c \rangle \Rightarrow \exists IR_d.\ \Gamma \vdash \text{EmitDeinitPlan}(P) \Downarrow IR_d \land \text{ExecIRSigma}(IR_d, \sigma_3) \Downarrow (\text{Val}(()), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(IR_{\text{entry}}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR_{\text{entry}}, \sigma) \Downarrow (\text{Val}(ret), \sigma_4)\right)$$

**(EntryStub-Decl)**
$$\frac{\Gamma \vdash \text{EntrySym} \Downarrow sym \quad \text{EntryStubSpec}(P, IR_{\text{entry}})}{\Gamma \vdash \text{EntryStub}(P) \Downarrow \text{ProcIR}(sym, [], \text{TypePrim}(\texttt{"i32"}), IR_{\text{entry}})}$$

**(EntrySym-Err)**
$$\frac{\text{EntrySym}\ \text{undefined}}{\Gamma \vdash \text{EntrySym} \Uparrow}$$

**(EntryStub-Err)**
$$\frac{\text{EntryStub}(P)\ \text{undefined}}{\Gamma \vdash \text{EntryStub}(P) \Uparrow}$$

#### 6.12.18. Poisoning Instrumentation

$$\text{PoisonJudg} = \{\text{PoisonFlag}(m) \Downarrow sym,\ \text{CheckPoison}(m) \Downarrow IR,\ \text{SetPoison}(m) \Downarrow IR\}$$

$$\text{PoisonSet}(m) = \{m\} \cup \{x \mid \text{Reachable}(x, m, E_{val}^{eager})\}$$

**(PoisonFlag-Decl)**
$$\frac{}{\Gamma \vdash \text{PoisonFlag}(m) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"poison"}] \mathbin{+\!\!+} \text{PathOfModule}(m))}$$

$$\text{PoisonFlagDecl}(m) = \text{GlobalZero}(\text{PoisonFlag}(m), \text{sizeof}(\text{TypePrim}(\texttt{"bool"})))$$
$$\text{StaticType}(\text{PoisonFlag}(m)) = \text{TypePrim}(\texttt{"bool"})$$

**(CheckPoison-Use)**
$$\frac{\text{PoisonFlag}(m) \Downarrow sym}{\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR}$$
$$\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR \iff \forall \sigma.\ \left(\text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) \ne 0 \Rightarrow \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{ExecIRSigma}(\text{LowerPanic}(\text{InitPanic}(m)), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')\right)\ \land\ \left(\text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) = 0 \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right)$$

**(SetPoison-OnInitFail)**
$$\frac{\text{PoisonSet}(m) = \{m_1,\ldots,m_k\} \quad \forall i,\ \text{PoisonFlag}(m_i) \Downarrow sym_i}{\Gamma \vdash \text{SetPoison}(m) \Downarrow \text{SeqIR}(\text{StoreGlobal}(sym_1, 1),\ldots,\text{StoreGlobal}(sym_k, 1))}$$

**(PoisonFlag-Err)**
$$\frac{\text{PoisonFlag}(m)\ \text{undefined}}{\Gamma \vdash \text{PoisonFlag}(m) \Uparrow}$$

**(CheckPoison-Err)**
$$\frac{\text{CheckPoison}(m)\ \text{undefined}}{\Gamma \vdash \text{CheckPoison}(m) \Uparrow}$$

**(SetPoison-Err)**
$$\frac{\text{SetPoison}(m)\ \text{undefined}}{\Gamma \vdash \text{SetPoison}(m) \Uparrow}$$

## 7. Dynamic Semantics

### 7.1. Initialization Order and Poisoning

$$\text{Vertices}(G_e) = V \iff G_e = \langle V,\ E \rangle$$
$$\text{Edges}(G_e) = E \iff G_e = \langle V,\ E \rangle$$
$$\text{Index}(L, x) = i \iff 0 \le i < |L| \land L[i] = x$$
$$\text{TopoOrder}(G_e, L) \iff \text{Distinct}(L) \land \text{Set}(L)=\text{Vertices}(G_e) \land \forall (u,v) \in \text{Edges}(G_e).\ \text{Index}(L,u) < \text{Index}(L,v)$$
$$\text{Incomparable}_{G_e}(u,v) \iff \neg \text{Reachable}(u,v,\text{Edges}(G_e)) \land \neg \text{Reachable}(v,u,\text{Edges}(G_e))$$
$$\text{TopoTieBreak}(G_e, L, P) \iff \forall u,v \in \text{Vertices}(G_e).\ \text{Incomparable}_{G_e}(u,v) \land \text{Index}(P.\text{modules}, u) < \text{Index}(P.\text{modules}, v) \Rightarrow \text{Index}(L,u) < \text{Index}(L,v)$$
$$\text{Cycle}(G_e) \iff \exists v \in \text{Vertices}(G_e).\ \text{Reachable}(v,v,\text{Edges}(G_e))$$

**(Topo-Ok)**
$$\frac{\text{Project}(\Gamma)=P \quad \Gamma \vdash G_e : \text{DAG} \quad \text{TopoOrder}(G_e, L) \quad \text{TopoTieBreak}(G_e, L, P)}{\Gamma \vdash \text{Topo}(G_e) \Downarrow L}$$

**(Topo-Cycle)**
$$\frac{\text{Cycle}(G_e) \quad c = \text{Code}(\text{Topo-Cycle})}{\Gamma \vdash \text{Topo}(G_e) \Uparrow c}$$

$$P = \text{Project}(\Gamma)$$
$$\text{StaticInitOf}(\text{item}) = init \iff \text{item}=\text{StaticDecl}(vis,mut,binding,span,doc) \land binding=\langle pat,ty\_opt,op,init,sp \rangle$$
$$\text{StaticInitOf}(\text{item}) = \bot \iff \text{item} \notin \text{StaticDecl}(\_,\_,\_,\_,\_)$$
$$\text{InitList}(m) = [\ init \mid \text{item} \in \text{Items}(P, m) \land \text{StaticInitOf}(\text{item}) = init\ ]$$

$$\text{InitOrder}(G_e) = L \iff \Gamma \vdash \text{Topo}(G_e) \Downarrow L$$
$$\text{InitPlan}(G_e) = \mathbin{+\!\!+}_{m \in \text{InitOrder}(G_e)} \text{InitList}(m)$$

$$\text{DeinitOrder}(G_e) = \text{rev}(\text{InitOrder}(G_e))$$

$$\text{StaticBindOrder}(m) = \mathbin{+\!\!+}_{\text{item} \in \text{StaticItems}(P, m),\ \text{item}=\text{StaticDecl}(vis,mut,binding,span,doc)} [\langle \text{PathOfModule}(m), x \rangle \mid x \in \text{StaticBindList}(\text{binding})]$$

$$\text{GlobalStaticOrder} = \mathbin{+\!\!+}_{m \in \text{InitOrder}(G_e)} \text{StaticBindOrder}(m)$$

$$\text{DeinitList}(P) = \text{rev}([\ \text{DropStatic}(path, name)\ \mid\ \langle path, name \rangle \in \text{GlobalStaticOrder} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp}\ ])$$

$$\Gamma \vdash \text{Eval}(e, \sigma) \Downarrow v \iff \exists \sigma'.\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma')$$
$$\Gamma \vdash \text{Eval}(e, \sigma) \Uparrow \text{panic} \iff \exists \sigma'.\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')$$

**Initialization (Small-Step).**

$$\text{InitState} = \{\text{InitStart}(G_e, L, \sigma),\ \text{InitMod}(L, mi, ii, P, \sigma),\ \text{InitDone}(\sigma),\ \text{InitPanic}(P, \sigma)\}$$
$$\text{InitItem}(L, mi, ii) = e \iff mi < |L| \land L[mi]=m \land \text{InitList}(m)[ii]=e$$
$$\text{InitLen}(L, mi) = k \iff mi < |L| \land L[mi]=m \land |\text{InitList}(m)|=k$$

**(Init-Start)**
$$\frac{}{ \langle \text{InitStart}(G_e, L, \sigma) \rangle \to \langle \text{InitMod}(L, 0, 0, \emptyset, \sigma) \rangle }$$

**(Init-Step)**
$$\frac{\text{InitItem}(L, mi, ii) = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma')}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitMod}(L, mi, ii{+}1, P, \sigma') \rangle}$$

**(Init-Next-Module)**
$$\frac{\text{InitLen}(L, mi) = k \quad ii = k}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitMod}(L, mi{+}1, 0, P, \sigma) \rangle}$$

**(Init-Panic)**
$$\frac{\text{InitItem}(L, mi, ii) = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \quad L[mi]=m \quad P' = P \cup \{m\} \cup \{x \mid \text{Reachable}(x, m, E_{val}^{eager})\}}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitPanic}(P', \sigma') \rangle}$$

**(Init-Done)**
$$\frac{mi = |L|}{ \langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitDone}(\sigma) \rangle }$$

**Initialization (Big-Step).**

**(Init-Ok)**
$$\frac{\langle \text{InitStart}(G_e, \text{InitOrder}(G_e), \sigma) \rangle \to^* \langle \text{InitDone}(\sigma') \rangle}{\Gamma \vdash \text{Init}(G_e, \sigma) \Downarrow \sigma'}$$

**(Init-Fail)**
$$\frac{\langle \text{InitStart}(G_e, \text{InitOrder}(G_e), \sigma) \rangle \to^* \langle \text{InitPanic}(P, \sigma') \rangle}{\Gamma \vdash \text{Init}(G_e, \sigma) \Uparrow \text{panic}(P)}$$

**Deinitialization (Big-Step).**

**(Deinit-Ok)**
$$\frac{\Gamma \vdash \text{Cleanup}(\text{DeinitList}(P), \sigma) \Downarrow (\text{ok}, \sigma')}{\Gamma \vdash \text{Deinit}(P, \sigma) \Downarrow \sigma'}$$

**(Deinit-Panic)**
$$\frac{\Gamma \vdash \text{Cleanup}(\text{DeinitList}(P), \sigma) \Downarrow (\text{panic}, \sigma')}{\Gamma \vdash \text{Deinit}(P, \sigma) \Uparrow \text{panic}}$$

### 7.2. Modal Layout (Dynamic Semantics)

$$\text{layout}(M@S) = \text{layout}(\texttt{record}\ \{\text{Payload}(M, S)\})$$
$$\text{Payload}(M, S)=\emptyset \Rightarrow \text{sizeof}(M@S)=0$$
$$\text{layout}(M) =
\begin{cases}
\text{layout}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\text{layout}(\texttt{enum}\ \{S_1(\text{Payload}(M, S_1)),\ldots,S_n(\text{Payload}(M, S_n))\}) & \text{otherwise}
\end{cases}$$
$$\text{sizeof}(M) =
\begin{cases}
\text{sizeof}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\text{sizeof}(\text{Discriminant})+\max_{S \in \text{States}(M)}(\text{sizeof}(M@S))+\text{Padding} & \text{otherwise}
\end{cases}$$
$$\text{alignof}(M) =
\begin{cases}
\text{alignof}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\max(\text{alignof}(\text{Discriminant}),\ \max_{S \in \text{States}(M)}(\text{alignof}(M@S))) & \text{otherwise}
\end{cases}$$
$$\text{ValueBits}(M,\ \langle S, v \rangle) = bits \iff \text{ModalBits}(M, S, v) = bits$$

### 7.3. Modal Pattern Matching

$$\text{MatchModalJudg} = \{\text{MatchModal}(p, v) \Downarrow B\}$$

**(Match-Modal-Empty)**
$$\frac{}{ \Gamma \vdash \text{MatchModal}(\texttt{@}S,\ \langle S, v \rangle) \Downarrow \emptyset }$$

**(Match-Modal-Record)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchModal}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}$$

$$\text{BindEnv} = \text{Ident} \rightharpoonup \text{Value}$$
$$\text{Dom}(B) = \{x \mid x \in \text{Ident} \land B[x]\ \text{defined}\}$$
$$B_1 \uplus B_2 = B \iff \text{Dom}(B_1) \cap \text{Dom}(B_2) = \emptyset \land \forall x.\ (x \in \text{Dom}(B_1) \Rightarrow B[x]=B_1[x]) \land (x \in \text{Dom}(B_2) \Rightarrow B[x]=B_2[x])$$
$$\text{MatchPatJudg} = \{\text{MatchPattern}(p, v) \Downarrow B\}$$
$$\text{PatType}(\text{LiteralPattern}(lit)) =
\begin{cases}
\text{TypePrim}(t) & lit.\text{kind}=\text{IntLiteral} \land \text{IntSuffix}(lit)=t\\
\text{TypePrim}(\texttt{"i32"}) & lit.\text{kind}=\text{IntLiteral} \land \text{IntSuffix}(lit)=\bot\\
\text{TypePrim}(t) & lit.\text{kind}=\text{FloatLiteral} \land \text{FloatSuffix}(lit)=t\\
\text{TypePrim}(\texttt{"f64"}) & lit.\text{kind}=\text{FloatLiteral} \land \text{FloatSuffix}(lit)=\bot\\
\text{TypePrim}(\texttt{"bool"}) & lit.\text{kind}=\text{BoolLiteral}\\
\text{TypePrim}(\texttt{"char"}) & lit.\text{kind}=\text{CharLiteral}\\
\text{TypeString}(\texttt{@View}) & lit.\text{kind}=\text{StringLiteral}\\
\bot & lit.\text{kind}=\text{NullLiteral}
\end{cases}$$

**(Match-Wildcard)**
$$\frac{}{\Gamma \vdash \text{MatchPattern}(\_,\ v) \Downarrow \emptyset}$$

**(Match-Ident)**
$$\frac{}{\Gamma \vdash \text{MatchPattern}(x,\ v) \Downarrow \{x \mapsto v\}}$$

**(Match-Typed)**
$$\frac{\text{UnionCase}(v) = \langle T', v' \rangle}{ \Gamma \vdash \text{MatchPattern}(x : T, v) \Downarrow \{ x \mapsto v' \}\quad \text{if } \Gamma \vdash T' \equiv T \text{ else } \bot }$$

**(Match-Literal)**
$$\frac{T = \text{PatType}(\ell) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{MatchPattern}(\ell,\ v) \Downarrow \emptyset}$$

**(Match-Tuple)**
$$\frac{v = (v_1,\ldots,v_n) \quad \forall i,\ \Gamma \vdash \text{MatchPattern}(p_i, v_i) \Downarrow B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{MatchPattern}((p_1,\ldots,p_n),\ v) \Downarrow B}$$

**(Match-Record)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(R\{fs\},\ v) \Downarrow B}$$

**(Match-Enum-Unit)**
$$\frac{v = \text{EnumValue}(path', \bot) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \bot),\ v) \Downarrow \emptyset}$$

**(Match-Enum-Tuple)**
$$\frac{v = \text{EnumValue}(path', \text{TuplePayload}(\vec{v})) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name \quad \forall i,\ \Gamma \vdash \text{MatchPattern}(p_i, v_i) \Downarrow B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \text{TuplePayloadPattern}([p_1,\ldots,p_n])),\ v) \Downarrow B}$$

**(Match-Enum-Record)**
$$\frac{v = \text{EnumValue}(path', \text{RecordPayload}(\vec{f})) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name \quad \Gamma \vdash \text{MatchRecord}(fs,\ \text{RecordPayload}(\vec{f})) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \text{RecordPayloadPattern}(fs)),\ v) \Downarrow B}$$

**(Match-Modal-General)**
$$\frac{\Gamma \vdash \text{MatchModal}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}$$

**(Match-Modal-State)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\texttt{@}S\{fs\},\ v) \Downarrow B}$$

**(Match-Range)**
$$\frac{\text{ConstPat}(p_l) = v_l \quad \text{ConstPat}(p_h) = v_h \quad v_l \le v \le v_h}{\Gamma \vdash \text{MatchPattern}(p_l\ \texttt{..=}\ p_h,\ v) \Downarrow \emptyset}$$

$$\frac{\text{ConstPat}(p_l) = v_l \quad \text{ConstPat}(p_h) = v_h \quad v_l \le v < v_h}{\Gamma \vdash \text{MatchPattern}(p_l\ \texttt{..}\ p_h,\ v) \Downarrow \emptyset}$$

### 7.4. Deterministic Destruction and Unwinding (Cursive0)

$$\text{Responsible}(b) \iff \text{BindInfo}(b).\text{resp} = \text{resp}$$

$$\text{CleanupItem} ::= \text{DropBinding}(b) \mid \text{DropStatic}(path, name) \mid \text{DeferBlock}(b)$$
$$\text{DropStatus} = \{\text{ok},\ \text{panic}\}$$
$$\text{DropJudg} = \{\text{DropAction}(b) \Downarrow \sigma',\ \text{DropValue}(T, v, F) \Downarrow \sigma',\ \text{DropStaticAction}(path, name) \Downarrow \sigma',\ \text{DropActionOut}(b) \Downarrow (c, \sigma'),\ \text{DropValueOut}(T, v, F) \Downarrow (c, \sigma'),\ \text{DropStaticActionOut}(path, name) \Downarrow (c, \sigma')\}$$
$$\text{DropAction}(b) \Downarrow \sigma' \iff \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma')$$
$$\text{DropValue}(T, v, F) \Downarrow \sigma' \iff \text{DropValueOut}(T, v, F) \Downarrow (\text{ok}, \sigma')$$
$$\text{DropStaticAction}(path, name) \Downarrow \sigma' \iff \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma')$$
$$\text{RecordType}(T) \iff \exists p.\ T=\text{TypePath}(p) \land \text{RecordDecl}(p)\ \text{defined}$$
$$\text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma') \ \text{relation}$$
$$\neg \text{ImplementsDrop}(T) \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma)$$
$$\text{ImplementsDrop}(T) \land \text{BuiltinDropType}(T) \land T=\text{TypeString}(\texttt{@Managed}) \land \Gamma \vdash \text{StringDropSym} \Downarrow sym \land \text{ExecIRSigma}(\text{CallIR}(sym, [v]), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma')$$
$$\text{ImplementsDrop}(T) \land \text{BuiltinDropType}(T) \land T=\text{TypeBytes}(\texttt{@Managed}) \land \Gamma \vdash \text{BytesDropSym} \Downarrow sym \land \text{ExecIRSigma}(\text{CallIR}(sym, [v]), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma')$$
$$\text{ImplementsDrop}(T) \land \neg \text{BuiltinDropType}(T) \land \text{LookupMethod}(\text{StripPerm}(T), \texttt{"drop"}) = m \land \text{BindParams}(\text{MethodParamsDecl}(\text{StripPerm}(T), m), [v]) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \Gamma \vdash \text{EvalBlockBodySigma}(m.\text{body}, \sigma_1) \Downarrow (out_1, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out_1) \Downarrow (out_2, \sigma_3) \land \text{ReturnOut}(out_2) = out \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma_3)$$
$$\text{ReleaseValue}(T, v, \sigma) \Downarrow \sigma' \ \text{relation}$$
$$\text{ReleaseValue}(T, v, \sigma) \Downarrow \sigma' \iff \sigma' = \sigma$$
$$\text{DropChildren}(T, v, F) =
\begin{cases}
[\ \langle T_i, v_i \rangle \mid \langle f_i, T_i \rangle \in \text{FieldsRev}(R),\ f_i \notin F,\ \text{FieldValue}(v, f_i)=v_i\ ] & T=\text{TypePath}(p) \land \text{RecordDecl}(p)=R\\
[\ \langle T_i, v_i \rangle \mid T=\text{TypeTuple}([T_0,\ldots,T_{n-1}]),\ i \in \text{rev}([0,\ldots,n{-}1]),\ \text{TupleValue}(v,i)=v_i\ ] & T=\text{TypeTuple}(\_)\\
[\ \langle T_e, v_i \rangle \mid T=\text{TypeArray}(T_e, n),\ i \in \text{rev}([0,\ldots,n{-}1]),\ \text{IndexValue}(v,i)=v_i\ ] & T=\text{TypeArray}(\_,\_)\\
[\ \langle T', v' \rangle \mid \text{UnionCase}(v)=\langle T', v' \rangle\ ] & T=\text{TypeUnion}(\_)\\
[\ \langle \text{TypeModalState}(p, S), v_s \rangle \mid v=\langle S, v_s \rangle\ ] & T=\text{TypePath}(p)\ \land\ \Sigma.\text{Types}[p]=\texttt{modal }M\\
[\ \langle T_i, v_i \rangle \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S),\ \text{FieldValue}(v, f_i)=v_i\ ] & T=\text{TypeModalState}(p,S)\ \land\ \Sigma.\text{Types}[p]=\texttt{modal }M\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DropList}([], \sigma) \Downarrow (\text{ok}, \sigma)$$
$$\text{DropList}([\langle T, v \rangle] \mathbin{+\!\!+} xs,\ \sigma) \Downarrow (c, \sigma'') \iff \text{DropValueOut}(T, v, \emptyset) \Downarrow (c_1, \sigma') \land (c_1=\text{panic} \Rightarrow c=\text{panic} \land \sigma''=\sigma') \land (c_1=\text{ok} \Rightarrow \text{DropList}(xs, \sigma') \Downarrow (c, \sigma''))$$

**(DropAction-Moved)**
$$\frac{\text{BindState}(\sigma, b) = \text{Moved}}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma)}$$

**(DropAction-Partial)**
$$\frac{\text{BindState}(\sigma, b) = \text{PartiallyMoved}(F) \quad \Gamma \vdash \text{DropValueOut}(\text{TypeOf}(b), \text{BindingValue}(\sigma, b), F) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (c, \sigma')}$$

**(DropAction-Valid)**
$$\frac{\text{BindState}(\sigma, b) = \text{Valid} \quad \Gamma \vdash \text{DropValueOut}(\text{TypeOf}(b), \text{BindingValue}(\sigma, b), \emptyset) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (c, \sigma')}$$

**(DropStaticAction)**
$$\frac{\text{StaticAddr}(path, name) = addr \quad \text{ReadAddr}(\sigma, addr) = v \quad \Gamma \vdash \text{DropValueOut}(\text{StaticType}(path, name), v, \emptyset) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (c, \sigma')}$$

$$\text{NonRecordFOk}(T, F) \iff \text{RecordType}(T) \lor F=\emptyset$$

**(DropValueOut-DropPanic)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{panic}, \sigma_1)}$$

**(DropValueOut-ChildPanic)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma_1) \quad \text{DropList}(\text{DropChildren}(T, v, F), \sigma_1) \Downarrow (\text{panic}, \sigma_2)}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{panic}, \sigma_2)}$$

**(DropValueOut-Ok)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma_1) \quad \text{DropList}(\text{DropChildren}(T, v, F), \sigma_1) \Downarrow (\text{ok}, \sigma_2) \quad \text{ReleaseValue}(T, v, \sigma_2) \Downarrow \sigma_3}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{ok}, \sigma_3)}$$

**Cleanup (Small-Step).**

$$\text{CleanupFlag} = \{\text{ok},\ \text{panic}\}$$
$$\text{CleanupState} = \{\text{CleanupLoop}(scope, \sigma, c) \mid c \in \text{CleanupFlag}\} \cup \{\text{ExitDone}(c, \sigma) \mid c \in \text{CleanupFlag}\} \cup \{\text{Abort}\}$$

**(Cleanup-Start)**
$$\frac{}{\langle \text{ExitScope}(scope, \sigma) \rangle \to \langle \text{CleanupLoop}(scope, \sigma, \text{ok}) \rangle}$$

**(Cleanup-Step-Drop-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-Drop-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-Drop-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Step-DropStatic-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-DropStatic-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-DropStatic-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Step-Defer-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-Defer-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-Defer-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Done)**
$$\frac{\text{CleanupList}(scope) = []}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{ExitDone}(c, \sigma) \rangle}$$

**Destruction (Big-Step).**

**(Destroy-Empty)**
$$\frac{}{\Gamma \vdash \text{Destroy}([], \sigma) \Downarrow \sigma}$$

**(Destroy-Cons)**
$$\frac{\Gamma \vdash \text{DropAction}(b) \Downarrow \sigma_1 \quad \Gamma \vdash \text{Destroy}(bs, \sigma_1) \Downarrow \sigma_2}{\Gamma \vdash \text{Destroy}(b::bs, \sigma) \Downarrow \sigma_2}$$

**Cleanup (Big-Step).**

$$\text{CleanupJudg}_{\text{Dyn}} = \{\text{Cleanup}(cs, \sigma) \Downarrow (c, \sigma')\}$$

**(Cleanup-Empty)**
$$\frac{}{\Gamma \vdash \text{Cleanup}([], \sigma) \Downarrow (\text{ok}, \sigma)}$$

**(Cleanup-Cons-Drop)**
$$\frac{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropBinding}(b)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-Drop-Panic)**
$$\frac{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropBinding}(b)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**(Cleanup-Cons-DropStatic)**
$$\frac{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropStatic}(path, name)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-DropStatic-Panic)**
$$\frac{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropStatic}(path, name)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**(Cleanup-Cons-Defer-Ok)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DeferBlock}(b)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-Defer-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DeferBlock}(b)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**Cleanup Scope (Big-Step).**

$$\text{CleanupScopeJudg} = \{\text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma')\}$$

**(CleanupScope-From-SmallStep)**
$$\frac{\langle \text{ExitScope}(scope, \sigma) \rangle \to^* \langle \text{ExitDone}(c, \sigma') \rangle}{\Gamma \vdash \text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma')}$$

**Unwinding.**

**(Unwind-Step)**
$$\frac{\Gamma \vdash \text{CleanupScope}(f_1.\text{scope}, \sigma) \Downarrow (\text{ok}, \sigma')}{\langle \text{Unwind}(f_1::fs, \sigma) \rangle \to \langle \text{Unwind}(fs, \sigma') \rangle}$$

**(Unwind-Abort)**
$$\frac{\Gamma \vdash \text{CleanupScope}(f_1.\text{scope}, \sigma) \Downarrow (\text{panic}, \sigma')}{\langle \text{Unwind}(f_1::fs, \sigma) \rangle \to \langle \text{Abort} \rangle}$$

**Region, Frame, and Allocation Semantics (Cursive0).**

**Dynamic Scope Stack.**

$$\text{ScopeEntry} = \langle \text{scope\_id},\ \text{cleanup},\ \text{names},\ \text{vals},\ \text{states} \rangle$$
$$\text{ScopeId}(\langle sid, cleanup, names, vals, states \rangle) = sid$$
$$\text{ScopeCleanup}(\langle sid, cleanup, names, vals, states \rangle) = cleanup$$
$$\text{ScopeNames}(\langle sid, cleanup, names, vals, states \rangle) = names$$
$$\text{ScopeVals}(\langle sid, cleanup, names, vals, states \rangle) = vals$$
$$\text{ScopeStates}(\langle sid, cleanup, names, vals, states \rangle) = states$$
$$\text{ScopeStack}(\sigma) \in [\text{ScopeEntry}]$$
$$\text{CurrentScope}(\sigma) = scope \iff \text{ScopeStack}(\sigma) = scope :: ss$$
$$\text{CurrentScopeId}(\sigma) = \text{ScopeId}(\text{CurrentScope}(\sigma))$$
$$\text{ScopeEmpty}(sid) = \langle sid,\ [],\ \emptyset,\ \emptyset,\ \emptyset \rangle$$
$$\text{FreshScopeId}(\sigma) = sid \Rightarrow \forall s \in \text{ScopeStack}(\sigma).\ \text{ScopeId}(s) \ne sid$$
$$\text{UpdateScopeStack}(\sigma, ss) = \sigma' \iff \text{ScopeStack}(\sigma') = ss \land \text{AddrTags}(\sigma') = \text{AddrTags}(\sigma) \land \text{RegionStack}(\sigma') = \text{RegionStack}(\sigma) \land \text{PoisonedModules}(\sigma') = \text{PoisonedModules}(\sigma)$$
$$\text{PushScope}_\sigma(\sigma) \Downarrow (\sigma', scope) \iff scope = \text{ScopeEmpty}(sid) \land \text{FreshScopeId}(\sigma) = sid \land \text{UpdateScopeStack}(\sigma, scope :: \text{ScopeStack}(\sigma)) = \sigma'$$
$$\text{PopScope}_\sigma(\sigma) \Downarrow (\sigma', scope) \iff \text{ScopeStack}(\sigma) = scope :: ss \land \text{UpdateScopeStack}(\sigma, ss) = \sigma'$$
$$\text{AppendCleanup}(\sigma, item) \Downarrow \sigma' \iff \text{ScopeStack}(\sigma) = scope :: ss \land scope = \langle sid, cleanup, names, vals, states \rangle \land scope' = \langle sid, cleanup \mathbin{+\!\!+} [item], names, vals, states \rangle \land \text{UpdateScopeStack}(\sigma, scope' :: ss) = \sigma'$$
$$\text{CleanupList}(scope) = \text{ScopeCleanup}(scope)$$
$$\text{ScopeById}([], sid) = \bot$$
$$\text{ScopeById}(scope :: ss, sid) = \begin{cases} scope & \text{if } \text{ScopeId}(scope) = sid \\ \text{ScopeById}(ss, sid) & \text{otherwise} \end{cases}$$
$$\text{ReplaceScopeById}([], sid, scope') = \bot$$
$$\text{ReplaceScopeById}(scope :: ss, sid, scope') = \begin{cases} scope' :: ss & \text{if } \text{ScopeId}(scope) = sid \\ scope :: \text{ReplaceScopeById}(ss, sid, scope') & \text{otherwise} \end{cases}$$
$$\text{SetCleanupList}(scope, xs, \sigma) \Downarrow \sigma' \iff sid = \text{ScopeId}(scope) \land scope' = \langle sid, xs, \text{ScopeNames}(scope), \text{ScopeVals}(scope), \text{ScopeStates}(scope) \rangle \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'$$

**Poisoned Modules.**

$$\text{PoisonedModule}(\sigma, path) \iff \exists m.\ \text{PathOfModule}(m) = path \land \text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) \ne 0$$
$$\text{PoisonedModules}(\sigma) = \{ path \mid \text{PoisonedModule}(\sigma, path) \}$$

**Dynamic Value Environment.**

$$\text{Binding} = \langle \text{scope\_id},\ \text{bind\_id},\ \text{name} \rangle$$
$$\text{BindingValue} = \text{Value} \cup \{\text{Alias}(addr) \mid addr \in \text{Addr}\}$$
$$\text{FreshBindId}(\sigma) = b \Rightarrow \forall x.\ \text{ScopeNames}(\text{CurrentScope}(\sigma))[x]\ \text{defined} \Rightarrow b \notin \text{ScopeNames}(\text{CurrentScope}(\sigma))[x]$$
$$\text{Last}([a]) = a$$
$$\text{Last}(a::as) = \text{Last}(as) \quad (|as|>0)$$
$$\text{NearestScope}([], x) = \bot$$
$$\text{NearestScope}(scope :: ss, x) = \begin{cases} scope & \text{if } \text{ScopeNames}(scope)[x]\ \text{defined} \\ \text{NearestScope}(ss, x) & \text{otherwise} \end{cases}$$
$$\text{LookupBind}(\sigma, x) = \langle \text{ScopeId}(scope), b, x \rangle \iff \text{NearestScope}(\text{ScopeStack}(\sigma), x) = scope \land b = \text{Last}(\text{ScopeNames}(scope)[x])$$
$$\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) = v \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land \text{ScopeVals}(scope)[bind\_id] = v$$
$$\text{BindState}(\sigma, \langle sid, bind\_id, x \rangle) = s \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land \text{ScopeStates}(scope)[bind\_id] = s$$

**(LookupVal-Bind-Value)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{BindingValue}(\sigma, b) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-Bind-Alias)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{BindingValue}(\sigma, b) = \text{Alias}(addr) \quad \text{ReadAddr}(\sigma, addr) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-Path)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \neg \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp)) \quad \text{LookupValPath}(\sigma, \text{PathOfModule}(mp), name) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-RecordCtor)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad \Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \neg \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp)) \quad \text{RecordDecl}(\text{FullPath}(\text{PathOfModule}(mp), name)) = R}{\text{LookupVal}(\sigma, x) = \text{RecordCtor}(\text{FullPath}(\text{PathOfModule}(mp), name))}$$

**(LookupValPath-Static)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad path' = \text{PathOfModule}(mp) \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \neg \text{PoisonedModule}(\sigma, path') \quad \text{StaticAddr}(path', name') = addr \quad \text{ReadAddr}(\sigma, addr) = v}{\text{LookupValPath}(\sigma, path, name) = v}$$

**(LookupValPath-Proc)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad path' = \text{PathOfModule}(mp) \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \neg \text{PoisonedModule}(\sigma, path') \quad \text{DeclOf}(path', name') = proc}{\text{LookupValPath}(\sigma, path, name) = \text{ProcRef}(proc)}$$

**(LookupValPath-RecordCtor)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, \_) \quad \neg \text{PoisonedModule}(\sigma, mp)}{\text{LookupValPath}(\sigma, path, name) = \text{RecordCtor}(p)}$$

$$\text{LookupBind}(\sigma, x)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{LookupBind}(\sigma, x))$$
$$\text{LookupVal}(\sigma, x)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{LookupVal}(\sigma, x))$$

$$\text{ScopeValsUpdate}(\langle sid, cleanup, names, vals, states \rangle, bind\_id, v) = \langle sid, cleanup, names, vals[bind\_id \mapsto v], states \rangle$$
$$\text{ScopeStatesUpdate}(\langle sid, cleanup, names, vals, states \rangle, bind\_id, s) = \langle sid, cleanup, names, vals, states[bind\_id \mapsto s] \rangle$$

$$\text{UpdateVal}(\sigma, \langle sid, bind\_id, x \rangle, v) \Downarrow \sigma' \iff \left(\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) = \text{Alias}(addr) \land \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'\right) \lor \left(\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) \ne \text{Alias}(\_) \land \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land scope' = \text{ScopeValsUpdate}(scope, bind\_id, v) \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'\right)$$
$$\text{SetState}(\sigma, \langle sid, bind\_id, x \rangle, s) \Downarrow \sigma' \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land scope' = \text{ScopeStatesUpdate}(scope, bind\_id, s) \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'$$

$$\text{TypeOf}(\langle sid, bind\_id, x \rangle) = \text{TypeOf}(x)$$
$$\text{BindInfo}(\langle sid, bind\_id, x \rangle) = \text{BindInfo}(x)$$

$$\text{BindVal}(\sigma, x, v) \Downarrow (\sigma', b) \iff \text{ScopeStack}(\sigma) = scope :: ss \land scope = \langle sid, cleanup, names, vals, states \rangle \land bind\_id = \text{FreshBindId}(\sigma) \land names' = names[x \mapsto (names[x]\ \text{if present else}\ []) \mathbin{+\!\!+} [bind\_id]] \land vals' = vals[bind\_id \mapsto v] \land states' = states[bind\_id \mapsto \text{Valid}] \land scope' = \langle sid, cleanup, names', vals', states' \rangle \land \text{UpdateScopeStack}(\sigma, scope' :: ss) = \sigma_1 \land b = \langle sid, bind\_id, x \rangle \land \left((\text{BindInfo}(b).\text{resp} = \text{resp} \land \text{AppendCleanup}(\sigma_1, \text{DropBinding}(b)) \Downarrow \sigma') \lor (\text{BindInfo}(b).\text{resp} \ne \text{resp} \land \sigma' = \sigma_1)\right)$$

$$\text{BindPatternVal}(p, v) \Downarrow B \iff \Gamma \vdash \text{MatchPattern}(p, v) \Downarrow B$$
$$\text{BindOrder}(p, B) = [\ \langle x, B[x] \rangle \mid x \in \text{PatNames}(p)\ ]$$

**(BindList-Empty)**
$$\frac{}{\text{BindList}(\sigma, []) \Downarrow (\sigma, [])}$$

**(BindList-Cons)**
$$\frac{\text{BindVal}(\sigma, x, v) \Downarrow (\sigma_1, b) \quad \text{BindList}(\sigma_1, xs) \Downarrow (\sigma_2, bs)}{\text{BindList}(\sigma, [\langle x, v \rangle] \mathbin{+\!\!+} xs) \Downarrow (\sigma_2, b::bs)}$$

$$\text{BindPattern}(\sigma, p, v) \Downarrow (\sigma', bs) \iff \text{BindPatternVal}(p, v) \Downarrow B \land \text{BindOrder}(p, B) = binds \land \text{BindList}(\sigma, binds) \Downarrow (\sigma', bs)$$

**Runtime Region Stack.**

$$\text{RegionEntry} = \langle \text{tag},\ \text{target},\ \text{scope},\ \text{mark\_opt} \rangle$$
$$\text{RegionTagOf}(\langle tag, target, scope, mark\_opt \rangle) = tag$$
$$\text{RegionTargetOf}(\langle tag, target, scope, mark\_opt \rangle) = target$$
$$\text{RegionScopeOf}(\langle tag, target, scope, mark\_opt \rangle) = scope$$
$$\text{RegionMarkOf}(\langle tag, target, scope, mark\_opt \rangle) = mark\_opt$$
$$\text{RuntimeTag} = \{\text{RegionTag}(tag),\ \text{ScopeTag}(sid)\}$$
$$\text{RegionStack}(\sigma) \in [\text{RegionEntry}]$$
$$\text{AddrTags}(\sigma) : \text{Addr} \rightharpoonup \text{RuntimeTag}$$

**Region Values.**

$$\text{RegionValue}(S, h) = \text{RecordValue}(\text{ModalStateRef}([\texttt{Region}], S), [\langle \texttt{handle}, \text{IntVal}(\texttt{"usize"}, h) \rangle])$$
$$\text{RegionHandleOf}(v) = h \iff v = \text{RecordValue}(\text{ModalStateRef}([\texttt{Region}], S), fs) \land \langle \texttt{handle}, \text{IntVal}(\texttt{"usize"}, h) \rangle \in fs$$
$$\text{RegionHandleOf}(v)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{RegionHandleOf}(v))$$

$$\text{ResolveEntry}([], r) = \bot$$
$$\text{ResolveEntry}(e::es, r) = \begin{cases} e & \text{if } \text{RegionTargetOf}(e) = r \\ \text{ResolveEntry}(es, r) & \text{otherwise} \end{cases}$$
$$\text{ActiveEntry}(\sigma) = e \iff \text{RegionStack}(\sigma) = e :: es$$
$$\text{ActiveTarget}(\sigma) = target \iff \text{ActiveEntry}(\sigma) = e \land \text{RegionTargetOf}(e) = target$$
$$\text{ResolveTarget}(\sigma, r) = target \iff \text{ResolveEntry}(\text{RegionStack}(\sigma), r) = e \land \text{RegionTargetOf}(e) = target$$
$$\text{ResolveTag}(\sigma, r) = tag \iff \text{ResolveEntry}(\text{RegionStack}(\sigma), r) = e \land \text{RegionTagOf}(e) = tag$$
$$\text{FreshTag}(\sigma) = tag \Rightarrow \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTagOf}(e) \ne tag$$
$$\text{FreshArena}(\sigma) = r \Rightarrow \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTargetOf}(e) \ne r$$

$$\text{ActiveTarget}(\sigma)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{ActiveTarget}(\sigma))$$
$$\text{ResolveTarget}(\sigma, r)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{ResolveTarget}(\sigma, r))$$

$$\text{UpdateRegionStack}(\sigma, rs) = \sigma' \iff \text{RegionStack}(\sigma') = rs \land \text{ScopeStack}(\sigma') = \text{ScopeStack}(\sigma) \land \text{AddrTags}(\sigma') = \text{AddrTags}(\sigma) \land \text{PoisonedModules}(\sigma') = \text{PoisonedModules}(\sigma)$$

$$\text{RegionNew}(\sigma, opts) \Downarrow (\sigma', r, scope) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land \text{FreshArena}(\sigma) = r \land \text{UpdateRegionStack}(\sigma_1, \langle r, r, scope, \bot \rangle :: \text{RegionStack}(\sigma_1)) = \sigma'$$

$$\text{RegionOpen}(\sigma, opts) \Downarrow (\sigma', r) \iff \text{FreshArena}(\sigma) = r \land \text{UpdateRegionStack}(\sigma, \langle r, r, \text{CurrentScopeId}(\sigma), \bot \rangle :: \text{RegionStack}(\sigma)) = \sigma'$$

$$\text{FrameEnter}(\sigma, r) \Downarrow (\sigma', F, scope, mark) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land F = \text{FreshTag}(\sigma) \land mark = \text{FrameMark}(\sigma_1, r) \land \text{UpdateRegionStack}(\sigma_1, \langle F, r, scope, mark \rangle :: \text{RegionStack}(\sigma_1)) = \sigma'$$

$$\text{BindRegionAlias}(\sigma, \bot, r) \Downarrow \sigma$$
$$\text{BindRegionAlias}(\sigma, x, r) \Downarrow \sigma' \iff \text{BindVal}(\sigma, x, \text{RegionValue}(\texttt{@Active}, r)) \Downarrow (\sigma', b)$$

$$\text{DynPayloadAddr}(v, addr) \iff v = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)$$
$$\text{RegionAlloc}(\sigma, r, v) \Downarrow (\sigma', v') \Rightarrow \left(\text{ResolveTag}(\sigma, r) = tag \land \forall addr.\ \text{DynPayloadAddr}(v', addr) \Rightarrow \text{AddrTags}(\sigma')(addr) = \text{RegionTag}(tag)\right)$$

$$\text{FreshTags}(\sigma, tags) \iff \text{Distinct}(tags) \land \forall tag \in \text{Set}(tags).\ \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTagOf}(e) \ne tag$$

$$\text{RetagRegions}([], r, tags) = [] \iff tags = []$$
$$\text{RetagRegions}(e::es, r, tags) = \begin{cases} e' :: \text{RetagRegions}(es, r, tags') & \text{if } \text{RegionTargetOf}(e) = r \land tags = tag :: tags' \land e' = \langle tag, \text{RegionTargetOf}(e), \text{RegionScopeOf}(e), \text{RegionMarkOf}(e) \rangle \\ e :: \text{RetagRegions}(es, r, tags) & \text{otherwise} \end{cases}$$

$$\text{RegionReset}(\sigma, r) \Downarrow \sigma' \iff \text{FreshTags}(\sigma, tags) \land \text{RetagRegions}(\text{RegionStack}(\sigma), r, tags) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

$$\text{PopRegions}([], r) = []$$
$$\text{PopRegions}(e::es, r) = \begin{cases} \text{PopRegions}(es, r) & \text{if } \text{RegionTargetOf}(e) = r \\ e :: \text{PopRegions}(es, r) & \text{otherwise} \end{cases}$$
$$\text{RegionFree}(\sigma, r) \Downarrow \sigma' \iff \text{PopRegions}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

**Region Procedures.**

$$\text{RegionProcJudg} = \{\text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v),\ \text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v'),\ \text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')\}$$

**(Region-New-Scoped)**
$$\frac{\text{RegionOpen}(\sigma, opts) \Downarrow (\sigma', r) \quad v = \text{RegionValue}(\texttt{@Active}, r)}{\text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v)}$$

**(Region-Alloc-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{RegionAlloc}(\sigma, r_t, v) \Downarrow (\sigma', v')}{\text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v')}$$

**(Region-Reset-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{RegionReset}(\sigma, h) \Downarrow \sigma' \quad v' = \text{RegionValue}(\texttt{@Active}, h)}{\text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v')}$$

**(Region-Freeze-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad v' = \text{RegionValue}(\texttt{@Frozen}, h)}{\text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma, v')}$$

**(Region-Thaw-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad v' = \text{RegionValue}(\texttt{@Active}, h)}{\text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma, v')}$$

**(Region-Free-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{RegionFree}(\sigma, h) \Downarrow \sigma' \quad v' = \text{RegionValue}(\texttt{@Freed}, h)}{\text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')}$$

$$\text{PopRegion}([], r) = \bot$$
$$\text{PopRegion}(e::es, r) = \begin{cases} es & \text{if } \text{RegionTargetOf}(e) = r \\ e :: \text{PopRegion}(es, r) & \text{otherwise} \end{cases}$$
$$\text{ReleaseArena}(\sigma, r) \Downarrow \sigma' \iff \text{PopRegion}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$
$$\text{ResetArena}(\sigma, r, mark) \Downarrow \sigma' \iff \text{PopRegion}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

$$\text{FrameMark}(\sigma, r) = |\text{RegionStack}(\sigma)|$$

**Control Outcomes.**

$$\text{Ctrl} = \{\text{Return}(v),\ \text{Result}(v),\ \text{Break}(v_{opt}),\ \text{Continue},\ \text{Panic},\ \text{Abort}\}$$
$$\text{StmtOut} = \{\text{ok}\} \cup \{\text{Ctrl}(\kappa) \mid \kappa \in \text{Ctrl}\}$$
$$\text{Outcome} = \{\text{Val}(v)\} \cup \{\text{Ctrl}(\kappa) \mid \kappa \in \text{Ctrl}\}$$
$$\text{StmtOutOf}(\text{Val}(v)) = \text{ok}$$
$$\text{StmtOutOf}(\text{Ctrl}(\kappa)) = \text{Ctrl}(\kappa)$$
$$\text{BreakVal}(\bot) = ()$$
$$\text{BreakVal}(v) = v$$

**Block Evaluation Helpers.**

$$\text{BlockEnter}(\sigma, binds) \Downarrow (\sigma', scope) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land \exists bs.\ \text{BindList}(\sigma_1, binds) \Downarrow (\sigma', bs)$$

$$\text{ExitOutcome}(out, \text{ok}) = out$$
$$\text{ExitOutcome}(\text{Ctrl}(\text{Abort}), c) = \text{Ctrl}(\text{Abort})$$
$$\text{ExitOutcome}(\text{Ctrl}(\text{Panic}), \text{panic}) = \text{Ctrl}(\text{Abort})$$
$$\text{ExitOutcome}(out, \text{panic}) = \text{Ctrl}(\text{Panic}) \quad (out \ne \text{Ctrl}(\text{Panic}) \land out \ne \text{Ctrl}(\text{Abort}))$$

$$\text{BlockExit}(\sigma, scope, out) \Downarrow (out', \sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land \sigma' = \sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{PopScope}_\sigma(\sigma_1) \Downarrow (\sigma', scope)))$$

$$\text{EvalBlockBodySigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma') \iff \Gamma \vdash \text{ExecSeqSigma}(stmts, \sigma) \Downarrow (sout, \sigma_1) \land \Big((sout = ok \land tail\_opt = e \land \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (out, \sigma')) \ \lor$$
$$\qquad (sout = ok \land tail\_opt = \bot \land out = \text{Val}(()) \land \sigma' = \sigma_1) \ \lor\ (sout = \text{Ctrl}(\text{Result}(v)) \land out = \text{Val}(v) \land \sigma' = \sigma_1) \ \lor$$
$$\qquad (sout = \text{Ctrl}(\kappa) \land \kappa \ne \text{Result}(\_) \land out = \text{Ctrl}(\kappa) \land \sigma' = \sigma_1)\Big)$$

$$\text{EvalBlockSigma}(b, \sigma) \Downarrow (out', \sigma'') \iff \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope) \land \text{EvalBlockBodySigma}(b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

$$\text{EvalBlockBindSigma}(p, v, b, \sigma) \Downarrow (out', \sigma'') \iff \text{BindPatternVal}(p, v) \Downarrow B \land \text{BindOrder}(p, B) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \text{EvalBlockBodySigma}(b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

$$\text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma') \iff \text{CurrentScopeId}(\sigma) = scope \land \text{EvalBlockBodySigma}(b, \sigma) \Downarrow (out, \sigma')$$

**Place Evaluation Helpers.**

**PlaceJudg.**
$$\text{PlaceJudg} = \{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{WritePlaceSubSigma}(p, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (out, \sigma')\}$$

$$\text{DropOnAssign}(b) \iff \text{BindInfo}(b).\text{mov} = \text{immov} \land \text{BindInfo}(b).\text{resp} = \text{resp}$$

$$\text{DropOnAssignStatic}(path, name) \iff \text{StaticBindInfo}(path, name).\text{mov} = \text{immov} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp}$$

$$\text{RootBinding}(Sigma, p) = \begin{cases}
\text{Local}(b) & \text{if } \text{LookupBind}(Sigma, \text{PlaceRoot}(p)) = b \\
\text{Static}(path, name) & \text{if } \text{LookupBind}(Sigma, \text{PlaceRoot}(p))\ \text{undefined} \land \Gamma \vdash \text{ResolveValueName}(\text{PlaceRoot}(p)) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ \text{PlaceRoot}(p)) \land path = \text{PathOfModule}(mp)
\end{cases}$$

$$\text{DropOnAssignRoot}(Sigma, p) \iff (\text{RootBinding}(Sigma, p) = \text{Local}(b) \land \text{DropOnAssign}(b)) \lor (\text{RootBinding}(Sigma, p) = \text{Static}(path, name) \land \text{DropOnAssignStatic}(path, name))$$

$$\text{RootMoved}(Sigma, p) \iff \text{RootBinding}(Sigma, p) = \text{Local}(b) \land \text{BindState}(Sigma, b) = \text{Moved}$$

**DropSubvalueJudg.**
$$\text{DropSubvalueJudg} = \{\Gamma \vdash \text{DropSubvalue}(p, T, v, \sigma) \Downarrow \sigma'\}$$

**(DropSubvalue-Do)**
$$\frac{\text{DropOnAssignRoot}(Sigma, p) \quad \neg \text{RootMoved}(Sigma, p) \quad \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow Sigma'}{\Gamma \vdash \text{DropSubvalue}(p, T, v, Sigma) \Downarrow Sigma'}$$

**(DropSubvalue-Skip)**
$$\frac{\neg \text{DropOnAssignRoot}(Sigma, p) \ \lor\ \text{RootMoved}(Sigma, p)}{\Gamma \vdash \text{DropSubvalue}(p, T, v, Sigma) \Downarrow Sigma}$$


**(ReadPlace-Ident)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ReadPlace-Ident-Poison)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePlace-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad (\text{DropOnAssign}(b) \Rightarrow \Gamma \vdash \text{DropAction}(b) \Downarrow \sigma_1) \quad (\neg \text{DropOnAssign}(b) \Rightarrow \sigma_1 = \sigma) \quad \text{UpdateVal}(\sigma_1, b, v) \Downarrow \sigma_2 \quad \text{SetState}(\sigma_2, b, \text{Valid}) \Downarrow \sigma_3}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma_3)}$$

**(WritePlace-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr \quad (\text{DropOnAssignStatic}(path, name) \Rightarrow \Gamma \vdash \text{DropStaticAction}(path, name) \Downarrow \sigma_1) \quad (\neg \text{DropOnAssignStatic}(path, name) \Rightarrow \sigma_1 = \sigma) \quad \text{WriteAddr}(\sigma_1, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

$$\text{TupleValue}((v_0,\ldots,v_{n-1}), i) = v_i \quad (0 \le i < n)$$
$$\text{TupleUpdate}((v_0,\ldots,v_{n-1}), i, v') = (v_0,\ldots,v_{i-1}, v', v_{i+1},\ldots,v_{n-1}) \quad (0 \le i < n)$$
$$\text{FieldValue}(\text{RecordValue}(tr, fs), f) = v \iff \langle f, v \rangle \in fs$$
$$\text{FieldUpdate}(\text{RecordValue}(tr, fs), f, v') = \text{RecordValue}(tr, fs') \quad \text{where } fs' = [\langle f_i, v_i' \rangle \mid \langle f_i, v_i \rangle \in fs \land v_i' = \begin{cases}v' & f_i = f \\ v_i & f_i \ne f \end{cases}]$$

$$\text{Len}([v_0,\ldots,v_{n-1}]) = n$$
$$\text{Len}(\text{SliceValue}(v, r)) = end - start \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end))$$
$$\text{IndexNum}(v) = i \iff v=\text{IntVal}(\texttt{"usize"}, i)$$
$$\text{IndexValue}([v_0,\ldots,v_{n-1}], i) = v_i \quad (0 \le i < n)$$
$$\text{IndexValue}(\text{SliceValue}(v, r), i) = \text{IndexValue}(v, start+i) \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end) \land 0 \le i < end-start)$$
$$\text{IndexValue}(v, v_i) = v_e \iff \text{IndexNum}(v_i)=i \land \text{IndexValue}(v, i) = v_e$$
$$\text{IndexUpdate}([v_0,\ldots,v_{n-1}], i, v_e) = [v_0,\ldots,v_{i-1}, v_e, v_{i+1},\ldots,v_{n-1}] \quad (0 \le i < n)$$
$$\text{IndexUpdate}(\text{SliceValue}(v_b, r), i, v_e) = \text{SliceValue}(v_b', r) \quad (\text{SliceBounds}(r, \text{Len}(v_b)) = (start, end) \land 0 \le i < end-start \land \text{IndexUpdate}(v_b, start+i, v_e) = v_b')$$
$$\text{IndexUpdate}(v, v_i, v_e) = v' \iff \text{IndexNum}(v_i)=i \land \text{IndexUpdate}(v, i, v_e)=v'$$
$$\text{SliceValue}(v, r)\ \text{defined} \iff \text{SliceBounds}(r, \text{Len}(v))\ \text{defined}$$
$$\text{SliceLen}([v_0,\ldots,v_{n-1}]) = n$$
$$\text{SliceLen}(\text{SliceValue}(v, r)) = end - start \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end))$$
$$\text{SliceElem}(v, i) = \text{IndexValue}(v, i) \quad (\text{IndexValue}(v, i)\ \text{defined})$$
$$\text{SliceUpdate}(v, start, v_{rhs}) \Downarrow v' \iff n = \text{SliceLen}(v_{rhs}) \land \exists v_0,\ldots,v_n.\ v_0 = v \land \forall i \in [0,n{-}1].\ v_{i+1} = \text{IndexUpdate}(v_i, start+i, \text{SliceElem}(v_{rhs}, i)) \land v' = v_n$$

**PtrAddrJudg.**
$$\text{PtrAddrJudg} = \{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (out, \sigma')\}$$

$$\text{AddrPrimJudg} = \{\text{ReadAddr}(\sigma, addr) = v,\ \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma',\ \text{FieldAddr}(T, addr, f) = addr',\ \text{TupleAddr}(T, addr, i) = addr',\ \text{IndexAddr}(T_b, addr, i) = addr'\}$$
$$\text{IndexLen}(Sigma, addr) = \text{Len}(v) \quad (\text{ReadAddr}(Sigma, addr) = v \land \text{Len}(v)\ \text{defined})$$
$$\text{IndexAddr}(T_b, addr, i) = \text{AddrAdd}(addr, i \times \text{sizeof}(\text{ElemType}(T_b))) \quad (\text{ElemType}(T_b)\ \text{defined})$$
$$\text{IndexAddr}(T_b, addr, v_i) = addr' \iff \text{IndexNum}(v_i)=i \land \text{IndexAddr}(T_b, addr, i) = addr'$$
$$\text{SliceLenFromAddr}(\sigma, addr) = n \iff \text{ReadAddr}(\sigma, addr) = v \land \text{SliceLen}(v) = n$$

$$\text{PtrStateSet} = \{\texttt{Valid}, \texttt{Null}, \texttt{Expired}\}$$
$$\text{RawQual} = \{\texttt{imm}, \texttt{mut}\}$$
$$\text{PtrAddr}(\text{Ptr@Valid}(addr)) = addr$$
$$\text{PtrAddr}(\text{Ptr@Null}(addr)) = addr$$
$$\text{PtrAddr}(\text{Ptr@Expired}(addr)) = addr$$
$$\text{PtrAddr}(\text{RawPtr}(q, addr)) = addr$$

$$\text{AddrTag}(Sigma, addr) = \begin{cases}
\text{ScopeTag}(sid) & addr = \text{BindAddr}(\langle sid, bind\_id, x \rangle) \\
\text{RegionTag}(tag) & \text{AddrTags}(Sigma)(addr) = \text{RegionTag}(tag) \\
\bot & \text{otherwise}
\end{cases}$$
$$\text{TagActive}(Sigma, \text{RegionTag}(tag)) \iff \exists e \in \text{RegionStack}(Sigma).\ \text{RegionTagOf}(e) = tag$$
$$\text{TagActive}(Sigma, \text{ScopeTag}(sid)) \iff \exists e \in \text{ScopeStack}(Sigma).\ \text{ScopeId}(e) = sid$$
$$\text{PtrState}(Sigma, \text{Ptr@Null}(\_)) = \texttt{Null}$$
$$\text{PtrState}(Sigma, \text{Ptr@Expired}(\_)) = \texttt{Expired}$$
$$\text{PtrState}(Sigma, \text{Ptr@Valid}(addr)) = \texttt{Valid}$$
$$\text{DynAddrState}(Sigma, addr) = \begin{cases}
\texttt{Valid} & \text{AddrTag}(Sigma, addr) = \bot \\
\texttt{Valid} & \text{AddrTag}(Sigma, addr) = tag \ne \bot \land \text{TagActive}(Sigma, tag) \\
\texttt{Expired} & \text{AddrTag}(Sigma, addr) = tag \ne \bot \land \neg \text{TagActive}(Sigma, tag)
\end{cases}$$
$$\text{BindAddr}(\langle sid, bind\_id, x \rangle) \in \text{Addr}$$
$$\text{AddrOfBind}(b) = \begin{cases}
addr & \text{BindingValue}(Sigma, b) = \text{Alias}(addr) \\
\text{BindAddr}(b) & \text{BindingValue}(Sigma, b) \ne \text{Alias}(\_)
\end{cases}$$
$$\text{AddrOfBind}(x) = addr \iff \exists b.\ \text{LookupBind}(\sigma, x) = b \land \text{AddrOfBind}(b) = addr$$

**(ReadPtr-Safe)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr \quad \text{ReadAddr}(\sigma, addr) = v}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(WritePtr-Safe)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (ok, \sigma')}$$

**(ReadPtr-Null)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(ReadPtr-Expired)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePtr-Null)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePtr-Expired)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(ReadPtr-Raw)**
$$\frac{v_{ptr} = \text{RawPtr}(q, addr) \quad \text{ReadAddr}(\sigma, addr) = v}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(WritePtr-Raw)**
$$\frac{v_{ptr} = \text{RawPtr}(\texttt{mut}, addr) \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (ok, \sigma')}$$

$$\text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)\ \text{undefined} \iff \text{ReadAddr}(\sigma, addr)\ \text{undefined}$$
$$\text{WritePtrSigma}(\text{RawPtr}(\texttt{imm}, addr), v, \sigma)\ \text{undefined}$$
$$\text{DynamicUndefined}(\text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)) \iff \text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)\ \text{undefined}$$
$$\text{DynamicUndefined}(\text{WritePtrSigma}(\text{RawPtr}(\texttt{imm}, addr), v, \sigma))$$


**(AddrOf-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{AddrOfBind}(b) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(addr), \sigma)}$$

**(AddrOf-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(AddrOf-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(addr), \sigma)}$$

**(AddrOf-Field)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_b = \text{ExprType}(p) \quad \text{FieldAddr}(T_b, addr, f) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Val}(addr'), \sigma_1)}$$

**(AddrOf-Field-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Tuple)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_b = \text{ExprType}(p) \quad \text{TupleAddr}(T_b, addr, i) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Val}(addr'), \sigma_1)}$$

**(AddrOf-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Index)**
**(AddrOfSigma-Index-Ok)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexLen}(\sigma_2, addr) = L \quad \Gamma \vdash \text{CheckIndex}(L, v_i) \Downarrow ok \quad T_b = \text{ExprType}(p) \quad \text{IndexAddr}(T_b, addr, v_i) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(addr'), \sigma_2)}$$

**(AddrOfSigma-Index-OOB)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{IndexLen}(\sigma_2, addr))}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(AddrOf-Index-Ctrl-Base)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Index-Ctrl-Idx)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(AddrOf-Deref-Safe)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}$$

**(AddrOf-Deref-Null)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(AddrOf-Deref-Expired)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(AddrOf-Deref-Raw)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(\text{RawPtr}(q, addr)), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}$$

**(AddrOf-Deref-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ReadPlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldValue}(v_p, f) = v_f}{\Gamma \vdash \text{ReadPlaceSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Val}(v_f), \sigma_1)}$$

**(ReadPlace-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleValue}(v_p, i) = v_i}{\Gamma \vdash \text{ReadPlaceSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_i), \sigma_1)}$$

**(ReadPlace-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_p, v_i) = v_e}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_e), \sigma_2)}$$

**(ReadPlace-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(ReadPlace-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceValue}(v_p, v_r) = v_s}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_s), \sigma_2)}$$

**(ReadPlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(ReadPlace-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Deref}(p), \sigma) \Downarrow (out, \sigma_2)}$$

**(WritePlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldValue}(v_p, f) = v_f \quad T_f = \text{ExprType}(\text{FieldAccess}(p, f)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_f, v_f, \sigma_1) \Downarrow \sigma_1' \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1') \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{FieldAccess}(p, f), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WritePlace-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleValue}(v_p, i) = v_i \quad T_i = \text{ExprType}(\text{TupleAccess}(p, i)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_i, v_i, \sigma_1) \Downarrow \sigma_1' \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1') \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{TupleAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WritePlace-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_p, v_i) = v_e \quad T_e = \text{ExprType}(\text{IndexAccess}(p, i)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_e, v_e, \sigma_2) \Downarrow \sigma_2' \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2') \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WritePlace-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WritePlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{Deref}(p), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{UpdateVal}(\sigma, b, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

**(WriteSub-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WriteSub-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

**(WriteSub-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{FieldAccess}(p, f), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{TupleAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WriteSub-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WriteSub-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Deref}(p), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(MovePlace-Whole)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{FieldHead}(p) = \bot \quad \text{LookupBind}(\sigma_1, \text{PlaceRoot}(p)) = b \quad \text{BindInfo}(b).\text{mov} = \text{mov} \quad \text{SetState}(\sigma_1, b, \text{Moved}) \Downarrow \sigma_2}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(MovePlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{FieldHead}(p) = f \quad \text{LookupBind}(\sigma_1, \text{PlaceRoot}(p)) = b \quad \text{BindInfo}(b).\text{mov} = \text{mov} \quad \text{BindState}(\sigma_1, b) = s \quad \text{PM}(s, f) = s' \quad \text{SetState}(\sigma_1, b, s') \Downarrow \sigma_2}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(MovePlace-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$


**Stateful Expression Evaluation.**

**EvalJudg.**
$$\text{EvalJudg} = \{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma')\}$$

**Range Helpers.**

$$\text{RangeVal} = \{\text{RangeVal}(k, lo\_opt, hi\_opt) \mid k \in \text{RangeKind}\}$$
$$\text{Inc}(v) = v' \iff v=\text{IntVal}(t, x) \land x'=x+1 \land \text{InRange}(x', t) \land v'=\text{IntVal}(t, x')$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Exclusive}, s, e), L) = (start, end) \iff \text{IndexNum}(s)=start \land \text{IndexNum}(e)=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Inclusive}, s, e), L) = (start, end) \iff \text{IndexNum}(s)=start \land \text{Inc}(e)=e' \land \text{IndexNum}(e')=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{From}, s, \bot), L) = (start, L) \iff \text{IndexNum}(s)=start$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{To}, \bot, e), L) = (0, end) \iff \text{IndexNum}(e)=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{ToInclusive}, \bot, e), L) = (0, end) \iff \text{Inc}(e)=e' \land \text{IndexNum}(e')=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Full}, \bot, \bot), L) = (0, L)$$
$$\text{SliceBounds}(r, L) = (start, end) \iff \text{SliceBoundsRaw}(r, L) = (start, end) \land 0 \le start \le end \le L$$
$$\text{SliceBounds}(r, L) = \bot \iff \text{SliceBoundsRaw}(r, L) = \bot \lor (\exists start,end.\ \text{SliceBoundsRaw}(r, L) = (start, end) \land \neg(0 \le start \le end \le L))$$

**EvalOptJudg.**
$$\text{EvalOptJudg} = \{\Gamma \vdash \text{EvalOptSigma}(e\_opt, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalOptSigma-None)**
$$\frac{}{\Gamma \vdash \text{EvalOptSigma}(\bot, \sigma) \Downarrow (\text{Val}(\bot), \sigma)}$$

**(EvalOptSigma-Some)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{EvalOptSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(EvalOptSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalOptSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Range)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Val}(v_{lo}), \sigma_1) \quad \Gamma \vdash \text{EvalOptSigma}(hi\_opt, \sigma_1) \Downarrow (\text{Val}(v_{hi}), \sigma_2) \quad r = \text{RangeVal}(kind, v_{lo}, v_{hi})}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Val}(r), \sigma_2)}$$

**(EvalSigma-Range-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Range-Ctrl-Hi)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Val}(v_{lo}), \sigma_1) \quad \Gamma \vdash \text{EvalOptSigma}(hi\_opt, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**Value Constructors and Accessors.**

**Values.**
$$\text{BoolVal}(b) = b \iff b \in \{\text{true},\ \text{false}\}$$
$$\text{CharVal}(u) = u \iff u \in \text{UnicodeScalar}$$
$$\text{UnitVal} = ()$$
$$\text{IntVal}(t, x)\ \text{defined} \iff t \in \text{IntTypes} \land \text{InRange}(x, t)$$
$$\text{IntValType}(\text{IntVal}(t, x)) = t$$
$$\text{IntValValue}(\text{IntVal}(t, x)) = x$$
$$\text{FloatVal}(t, v)\ \text{defined} \iff t \in \text{FloatTypes} \land v \in \text{FloatValueSet}(t)$$
$$\text{FloatValType}(\text{FloatVal}(t, v)) = t$$
$$\text{FloatValValue}(\text{FloatVal}(t, v)) = v$$
$$\text{PtrVal}(s, addr)\ \text{defined} \iff s \in \text{PtrStateSet}$$
$$\text{Ptr@Valid}(addr) = \text{PtrVal}(\texttt{Valid}, addr)$$
$$\text{Ptr@Null}(addr) = \text{PtrVal}(\texttt{Null}, addr)$$
$$\text{Ptr@Expired}(addr) = \text{PtrVal}(\texttt{Expired}, addr)$$
$$\text{TupleVal} = \{(v_1,\ldots,v_n) \mid n \ge 0\}$$
$$\text{ArrayVal} = \{[v_1,\ldots,v_n] \mid n \ge 0\}$$
$$\text{ModalVal}(S, v) = \langle S, v \rangle$$
$$\text{Value} = \{\text{BoolVal}(b) \mid b \in \{\text{true},\ \text{false}\}\} \cup \{\text{CharVal}(u) \mid u \in \text{UnicodeScalar}\} \cup \{\text{UnitVal}\} \cup \{\text{IntVal}(t, x) \mid \text{IntVal}(t, x)\ \text{defined}\} \cup \{\text{FloatVal}(t, v) \mid \text{FloatVal}(t, v)\ \text{defined}\} \cup \{\text{PtrVal}(s, addr) \mid \text{PtrVal}(s, addr)\ \text{defined}\} \cup \{\text{RawPtr}(q, addr)\} \cup \text{TupleVal} \cup \text{ArrayVal} \cup \{\text{RecordValue}(tr, fs)\} \cup \{\text{EnumValue}(path, payload)\} \cup \text{RangeVal} \cup \{\text{SliceValue}(v, r) \mid \text{SliceValue}(v, r)\ \text{defined}\} \cup \{\text{ModalVal}(S, v)\} \cup \{\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)\} \cup \texttt{string@Managed} \cup \texttt{string@View} \cup \texttt{bytes@Managed} \cup \texttt{bytes@View}$$

**EvalListJudg.**
$$\text{EvalListJudg} = \{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalListSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalListSigma}([], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalListSigma-Cons)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalListSigma}(es, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalListSigma}(e::es, \sigma) \Downarrow (\text{Val}([v] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalListSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalListSigma}(e::es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalFieldInitsSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalFieldInitsSigma}([], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalFieldInitsSigma-Cons)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fs, \sigma_1) \Downarrow (\text{Val}(\vec{f}), \sigma_2)}{\Gamma \vdash \text{EvalFieldInitsSigma}([\langle f, e \rangle] \mathbin{+\!\!+} fs, \sigma) \Downarrow (\text{Val}([\langle f, v \rangle] \mathbin{+\!\!+} \vec{f}), \sigma_2)}$$

**(EvalFieldInitsSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalFieldInitsSigma}([\langle f, e \rangle] \mathbin{+\!\!+} fs, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{BoolValue}(lit) = \text{true} \iff lit.\text{kind}=\text{BoolLiteral} \land \text{Lexeme}(lit)=\texttt{"true"}$$
$$\text{BoolValue}(lit) = \text{false} \iff lit.\text{kind}=\text{BoolLiteral} \land \text{Lexeme}(lit)=\texttt{"false"}$$
$$\text{CharValue}(lit) = u \iff lit.\text{kind}=\text{CharLiteral} \land T=\text{Lexeme}(lit) \land \text{StringBytesFrom}(T,1,|T|-1)=bytes \land \text{DecodeUTF8}(bytes)=[u]$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(\texttt{"bool"})) = \text{BoolVal}(b) \iff \ell.\text{kind} = \text{BoolLiteral} \land \text{BoolValue}(\ell) = b$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(\texttt{"char"})) = \text{CharVal}(c) \iff \ell.\text{kind} = \text{CharLiteral} \land \text{CharValue}(\ell) = c$$
$$\text{LiteralValue}(\ell, \text{TypeString}(\texttt{@View})) = v \iff \ell.\text{kind} = \text{StringLiteral} \land \text{ViewBytes}(v) = \text{StringBytes}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(t)) = \text{IntVal}(t, x) \iff \ell.\text{kind} = \text{IntLiteral} \land t \in \text{IntTypes} \land x = \text{IntValue}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(t)) = \text{FloatVal}(t, v) \iff \ell.\text{kind} = \text{FloatLiteral} \land t \in \text{FloatTypes} \land v = \text{FloatValue}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypeRawPtr}(q, U)) = \text{RawPtr}(q, 0x0) \iff \ell.\text{kind} = \text{NullLiteral}$$
$$\text{EnumPayloadVal} = \{\bot,\ \text{TuplePayload}(\vec{v}),\ \text{RecordPayload}(\vec{f})\}$$
$$\text{RecordValue}(tr, fs)\ \text{defined}$$
$$\text{EnumValue}(path, payload)\ \text{defined} \iff payload \in \text{EnumPayloadVal}$$

**(EvalSigma-Literal)**
$$\frac{T = \text{ExprType}(\text{Literal}(\ell)) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{EvalSigma}(\text{Literal}(\ell), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-Ident-Poison)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Ident-Poison-RecordCtor)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad \Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Ident)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Path-Poison-RecordCtor)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, \_) \quad \text{PoisonedModule}(\sigma, mp)}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Path)**
$$\frac{\text{LookupValPath}(\sigma, path, name) = v}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-ErrorExpr)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{ErrorExpr}(\_), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Tuple)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleExpr}(es), \sigma) \Downarrow (\text{Val}((v_1,\ldots,v_n)), \sigma_1)}$$

**(EvalSigma-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleExpr}(es), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Array)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{ArrayExpr}(es), \sigma) \Downarrow (\text{Val}([v_1,\ldots,v_n]), \sigma_1)}$$

**(EvalSigma-Array-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{ArrayExpr}(es), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Record)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{RecordExpr}(tr, fields), \sigma) \Downarrow (\text{Val}(\text{RecordValue}(tr, \vec{f})), \sigma_1)}$$

**(EvalSigma-Record-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{RecordExpr}(tr, fields), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Enum-Unit)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \bot), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \bot)), \sigma)}$$

**(EvalSigma-Enum-Tuple)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Paren}(es)), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \text{TuplePayload}(\vec{v}))), \sigma_1)}$$

**(EvalSigma-Enum-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Paren}(es)), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Enum-Record)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Brace}(fields)), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \text{RecordPayload}(\vec{f}))), \sigma_1)}$$

**(EvalSigma-Enum-Record-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Brace}(fields)), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-FieldAccess)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \text{FieldValue}(v_b, f) = v_f}{\Gamma \vdash \text{EvalSigma}(\text{FieldAccess}(base, f), \sigma) \Downarrow (\text{Val}(v_f), \sigma_1)}$$

**(EvalSigma-FieldAccess-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{FieldAccess}(base, f), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-TupleAccess)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \text{TupleValue}(v_b, i) = v_i}{\Gamma \vdash \text{EvalSigma}(\text{TupleAccess}(base, i), \sigma) \Downarrow (\text{Val}(v_i), \sigma_1)}$$

**(EvalSigma-TupleAccess-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleAccess}(base, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Index)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_b, v_i) = v_e}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Val}(v_e), \sigma_2)}$$

**(EvalSigma-Index-OOB)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexNum}(v_i)=i \quad \neg(0 \le i < \text{Len}(v_b))}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Index-Range)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceValue}(v_b, v_r) = v_s}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Val}(v_s), \sigma_2)}$$

**(EvalSigma-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_b)) = \bot}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Index-Ctrl-Base)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Index-Ctrl-Idx)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**Unary, Binary, Cast, Transmute, Propagate.**

$$\text{RetType}(\Gamma) \in \text{Type}$$
$$\text{OpJudg} = \{\text{UnOp}(op, v) \Downarrow v',\ \text{BinOp}(op, v_1, v_2) \Downarrow v\}$$
$$\text{NumericValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{NumericTypes}$$
$$\text{IntValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{IntTypes}$$
$$\text{FloatValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{FloatTypes}$$
$$\text{SignedIntValue}(v) \iff \exists t.\ t \in \text{SignedIntTypes} \land \text{ValueType}(v) = \text{TypePrim}(t)$$
$$\text{SignedTypeOf}(v) = t \iff t \in \text{SignedIntTypes} \land \text{ValueType}(v) = \text{TypePrim}(t)$$
$$\text{U32Value}(v) \iff \text{ValueType}(v) = \text{TypePrim}(\texttt{"u32"})$$
$$\text{EqValue}(v_1, v_2) \iff \exists T.\ \text{ValueType}(v_1) = T \land \text{ValueType}(v_2) = T \land \text{EqType}(T)$$
$$\text{OrdValue}(v_1, v_2) \iff \exists T.\ \text{ValueType}(v_1) = T \land \text{ValueType}(v_2) = T \land \text{OrdType}(T)$$
$$\text{IsNaN}(t, v) \iff t \in \text{FloatTypes} \land v=\text{FloatVal}(t, x) \land \text{IEEE754Encode}(t, x) = \text{CanonicalNaNBits}(t)$$
$$\text{OrdScalar}(v) = x \iff (\exists t.\ v=\text{IntVal}(t, x) \land t \in \text{IntTypes}) \lor (\exists u.\ v=\text{CharVal}(u) \land x=u)$$
$$\text{Cmp}(\texttt{"=="}, v_1, v_2) = b \iff \text{EqValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg \exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=(v_1=v_2)))$$
$$\text{Cmp}(\texttt{"!="}, v_1, v_2) = b \iff \text{EqValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{true}) \lor (\neg \exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=(v_1\ne v_2)))$$
$$\text{Cmp}(\texttt{"<"}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 < x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 < x_2)))$$
$$\text{Cmp}(\texttt{"<="}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 \le x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 \le x_2)))$$
$$\text{Cmp}(\texttt{">"}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 > x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 > x_2)))$$
$$\text{Cmp}(\texttt{">="}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 \ge x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 \ge x_2)))$$
$$\text{BitAt}(u, i) = b \iff b \in \{0,1\} \land \exists q,r.\ u = q\cdot 2^{i+1} + b\cdot 2^i + r \land 0 \le r < 2^i$$
$$\text{BitNot}(v) = v' \iff \exists t,x,w,u,u'.\ v=\text{IntVal}(t, x) \land w=\text{IntWidth}(t) \land u=\text{ToUnsigned}(w, x) \land u' = (2^w-1)-u \land ((t \in \text{SignedIntTypes} \land v'=\text{IntVal}(t, \text{ToSigned}(w, u'))) \lor (t \in \text{UnsignedIntTypes} \land v'=\text{IntVal}(t, u')) )$$
$$\text{BitOp}(op, t, v_1, v_2) = v \iff v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(t, x_2) \land w=\text{IntWidth}(t) \land u_1=\text{ToUnsigned}(w, x_1) \land u_2=\text{ToUnsigned}(w, x_2) \land u=\sum_{i=0}^{w-1} b_i 2^i \land \forall i.\ 0 \le i < w \Rightarrow ((op=\texttt{"&"} \land b_i=\text{BitAt}(u_1,i)\cdot \text{BitAt}(u_2,i)) \lor (op=\texttt{"|"} \land b_i=\max(\text{BitAt}(u_1,i),\text{BitAt}(u_2,i))) \lor (op=\texttt{"^"} \land b_i=(\text{BitAt}(u_1,i)+\text{BitAt}(u_2,i)) \bmod 2)) \land ((t \in \text{SignedIntTypes} \land v=\text{IntVal}(t, \text{ToSigned}(w, u))) \lor (t \in \text{UnsignedIntTypes} \land v=\text{IntVal}(t, u)))$$
$$\text{ShiftOp}(op, t, v_1, v_2) = v \iff v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(\texttt{"u32"}, n) \land w=\text{IntWidth}(t) \land 0 \le n < w \land u_1=\text{ToUnsigned}(w, x_1) \land ((op=\texttt{"<<"} \land u=(u_1 \cdot 2^n) \bmod 2^w) \lor (op=\texttt{">>"} \land u=\lfloor u_1 / 2^n \rfloor)) \land ((t \in \text{SignedIntTypes} \land v=\text{IntVal}(t, \text{ToSigned}(w, u))) \lor (t \in \text{UnsignedIntTypes} \land v=\text{IntVal}(t, u)))$$
$$\text{PowInt}(x, n) = y \iff n \in \mathbb{N} \land ((n=0 \land y=1) \lor (n>0 \land y = x \cdot \text{PowInt}(x, n-1)))$$
$$\text{PowFloat}(t, x_1, x_2) = x \iff t \in \text{FloatTypes} \land x_1 \in \text{FloatValueSet}(t) \land x_2 \in \text{FloatValueSet}(t) \land x\ \text{is the IEEE 754-2019 pow result of}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)$$
$$\text{IEEEArith}(op, t, v_1, v_2) = v \iff v_1=\text{FloatVal}(t, x_1) \land v_2=\text{FloatVal}(t, x_2) \land op \in \text{ArithOps} \land ((op \in \{\texttt{"+"},\texttt{"-"},\texttt{"*"},\texttt{"/"}\} \land x\ \text{is the IEEE 754-2019 result of applying}\ op\ \text{to}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)) \lor (op=\texttt{"%"} \land x\ \text{is the IEEE 754-2019 remainder of}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)) \lor (op=\texttt{"**"} \land \text{PowFloat}(t, x_1, x_2)=x)) \land v=\text{FloatVal}(t, x)$$
$$\forall t \in \text{FloatTypes}, v_1, v_2, op \in \text{ArithOps}.\ \exists v.\ \text{IEEEArith}(op, t, v_1, v_2) = v$$
$$\text{UnOp}(\texttt{"!"}, \text{false}) \Downarrow \text{true}$$
$$\text{UnOp}(\texttt{"!"}, \text{true}) \Downarrow \text{false}$$
$$\text{UnOp}(\texttt{"!"}, v) \Downarrow v' \iff \text{IntValue}(v, t) \land v' = \text{BitNot}(v)$$
$$\text{UnOp}(\texttt{"-"}, v) \Downarrow v' \iff v=\text{IntVal}(t, x) \land t \in \text{SignedIntTypes} \land x'=-x \land \text{InRange}(x', t) \land v'=\text{IntVal}(t, x')$$
$$\text{UnOp}(\texttt{"-"}, v) \Downarrow v' \iff v=\text{FloatVal}(t, x) \land v'=\text{FloatVal}(t, -x)$$
$$\text{UnOp}(\texttt{"widen"}, v) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{ArithOps} \land \text{NumericValue}(v_1, t) \land \text{NumericValue}(v_2, t) \land \text{ArithEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{BitOps} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land \text{BitEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{ShiftOps} \land \text{IntValue}(v_1, t) \land \text{U32Value}(v_2) \land \text{ShiftEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \{\texttt{"=="},\texttt{"!="}\} \land \text{EqValue}(v_1, v_2) \land v = \text{Cmp}(op, v_1, v_2)$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \{\texttt{"<"},\texttt{"<="},\texttt{">"},\texttt{">="}\} \land \text{OrdValue}(v_1, v_2) \land v = \text{Cmp}(op, v_1, v_2)$$
$$\text{ArithEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(t, x_2) \land ((op \in \{\texttt{"+"},\texttt{"-"},\texttt{"*"}\} \land x = x_1\ \text{op}\ x_2) \lor (op \in \{\texttt{"/"},\texttt{"%"}\} \land x_2 \ne 0 \land x = x_1\ \text{op}\ x_2) \lor (op=\texttt{"**"} \land x_2 \ge 0 \land \text{PowInt}(x_1, x_2)=x)) \land \text{InRange}(x, t) \land v=\text{IntVal}(t, x)$$
$$\text{ArithEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{FloatTypes} \land v = \text{IEEEArith}(op, t, v_1, v_2)$$
$$\text{BitEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v = \text{BitOp}(op, t, v_1, v_2)$$
$$\text{ShiftEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v = \text{ShiftOp}(op, t, v_1, v_2)$$

**(EvalSigma-Unary)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{UnOp}(op, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Unary-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{UnOp}(op, v)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalSigma-Unary-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Bin-And-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"&&"}, e_1, e_2), \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}$$

**(EvalSigma-Bin-And-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"&&"}, e_1, e_2), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Bin-Or-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"||"}, e_1, e_2), \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1)}$$

**(EvalSigma-Bin-Or-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"||"}, e_1, e_2), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Binary)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Val}(v_2), \sigma_2) \quad \text{BinOp}(op, v_1, v_2) \Downarrow v}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(EvalSigma-Binary-Panic)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Val}(v_2), \sigma_2) \quad \text{BinOp}(op, v_1, v_2)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Bin-Ctrl-L)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Bin-Ctrl-R)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

$$\text{ExprType} : \text{Expr} \to \text{Type}$$
$$R = \text{RetType}(\Gamma)$$

$$\text{CastValJudg} = \{\text{CastVal}(S, T, v) \Downarrow v'\}$$
$$\text{UnsignedIntTypes} = \{\texttt{u8},\ \texttt{u16},\ \texttt{u32},\ \texttt{u64},\ \texttt{u128},\ \texttt{usize}\}$$
$$\text{IntWidth}(\texttt{i8})=8 \quad \text{IntWidth}(\texttt{i16})=16 \quad \text{IntWidth}(\texttt{i32})=32 \quad \text{IntWidth}(\texttt{i64})=64 \quad \text{IntWidth}(\texttt{i128})=128$$
$$\text{IntWidth}(\texttt{u8})=8 \quad \text{IntWidth}(\texttt{u16})=16 \quad \text{IntWidth}(\texttt{u32})=32 \quad \text{IntWidth}(\texttt{u64})=64 \quad \text{IntWidth}(\texttt{u128})=128$$
$$\text{IntWidth}(\texttt{isize})=8 \times \text{PointerSize} \quad \text{IntWidth}(\texttt{usize})=8 \times \text{PointerSize}$$
$$\text{Mod}_w(x) = x \bmod 2^w$$
$$\text{ToSigned}(w, x) = y \iff y \in [-2^{w-1}, 2^{w-1}-1] \land y \equiv x \pmod{2^w}$$
$$\text{ToUnsigned}(w, x) = y \iff y \in [0, 2^w-1] \land y \equiv x \pmod{2^w}$$
$$\text{CodePoint} : \texttt{char} \to \mathbb{N}$$
$$\text{IsScalar}(u) \iff u \in \text{CharValueRange}$$
$$\text{IntToFloat}(t, x)\ \text{function}$$
$$\text{FloatToFloat}(s, t, v)\ \text{function}$$
$$\text{Trunc}(v)\ \text{function}$$
$$\text{CharOf}(u) = u \iff \text{IsScalar}(u)$$
$$\text{CodePoint}(\text{CharOf}(u)) = u \quad (\text{IsScalar}(u))$$
$$\text{IEEE754Bits}(t, v) = bits \iff v \in \text{FloatValueSet}(t) \land \text{IEEE754Encode}(t, v) = bits$$
$$\text{IntToFloat}(t, x) = v \iff v \in \text{NonNaNValueSet}(t) \land \forall v' \in \text{NonNaNValueSet}(t).\ |v-x| < |v'-x| \lor (|v-x|=|v'-x| \land \text{EvenSignificandLSB}(t, v))$$
$$\text{FloatToFloat}(s, t, v) = v' \iff \text{IEEE754Encode}(s, v) = \text{CanonicalNaNBits}(s) \land v' = \text{CanonicalNaN}(t)$$
$$\text{FloatToFloat}(s, t, v) = v' \iff \text{IEEE754Encode}(s, v) \ne \text{CanonicalNaNBits}(s) \land v' \in \text{NonNaNValueSet}(t) \land \forall u \in \text{NonNaNValueSet}(t).\ |v'-v| < |u-v| \lor (|v'-v|=|u-v| \land \text{EvenSignificandLSB}(t, v'))$$
$$\text{Trunc}(v) = \begin{cases}
\lfloor v \rfloor & v \ge 0\\
\lceil v \rceil & v < 0
\end{cases}$$

**(CastVal-Id)**
$$\frac{\text{StripPerm}(S) = \text{StripPerm}(T)}{\text{CastVal}(S, T, v) \Downarrow v}$$

**(CastVal-Int-Int-Signed)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{SignedIntTypes} \quad v=\text{IntVal}(s, x) \quad w=\text{IntWidth}(t) \quad x'=\text{ToSigned}(w, x) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Int-Unsigned)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{UnsignedIntTypes} \quad v=\text{IntVal}(s, x) \quad w=\text{IntWidth}(t) \quad x'=\text{ToUnsigned}(w, x) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Float)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{FloatTypes} \quad v=\text{IntVal}(s, x) \quad v'=\text{FloatVal}(t, \text{IntToFloat}(t, x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Float-Float)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{FloatTypes} \quad t \in \text{FloatTypes} \quad v=\text{FloatVal}(s, x) \quad v'=\text{FloatVal}(t, \text{FloatToFloat}(s, t, x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Float-Int)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{FloatTypes} \quad t \in \text{IntTypes} \quad v=\text{FloatVal}(s, x) \quad x'=\text{Trunc}(x) \quad \text{InRange}(x', t) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Bool-Int)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"bool"}) \quad T'=\text{TypePrim}(t) \quad t \in \text{IntTypes} \quad v'=\begin{cases}\text{IntVal}(t, 0) & v=\text{false} \\ \text{IntVal}(t, 1) & v=\text{true}\end{cases}}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Bool)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(t) \quad t \in \text{IntTypes} \quad T'=\text{TypePrim}(\texttt{"bool"}) \quad v=\text{IntVal}(t, x) \quad v'=\begin{cases}\text{false} & x=0 \\ \text{true} & x\ne 0\end{cases}}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Char-U32)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"char"}) \quad T'=\text{TypePrim}(\texttt{"u32"}) \quad v'=\text{IntVal}(\texttt{"u32"}, \text{CodePoint}(v))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-U32-Char)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"u32"}) \quad T'=\text{TypePrim}(\texttt{"char"}) \quad v=\text{IntVal}(\texttt{"u32"}, x) \quad \text{IsScalar}(x) \quad v'=\text{CharVal}(\text{CharOf}(x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(EvalSigma-Cast)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Cast-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalSigma-Cast-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{TransmuteVal}(S, T, v) \Downarrow v' \iff \text{ValueBits}(S, v) = bits \land \text{ValueBits}(T, v') = bits$$

**(EvalSigma-Transmute)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = t_1 \quad T = t_2 \quad \text{TransmuteVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{TransmuteExpr}(t_1, t_2, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Transmute-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TransmuteExpr}(t_1, t_2, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{UnionCaseJudg} = \{\text{UnionCase}(v) = \langle T, v_T \rangle\}$$
$$\text{UnionCase}(v) = \langle T, v_T \rangle \iff \exists U,\ bits.\ \text{ValueBits}(\text{TypeUnion}(U), v) = bits \land \text{UnionBits}(U, T, v_T) = bits$$

**(EvalSigma-Propagate-Success)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_s, v_s \rangle}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Val}(v_s), \sigma_1)}$$

**(EvalSigma-Propagate-Error)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_e, v_e \rangle \quad T_e \ne T_s}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v_e)), \sigma_1)}$$

**(EvalSigma-Propagate-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Conditionals and Match.**

**(EvalSigma-If-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(then\_block, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-If-False-None)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad else\_opt = \bot}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(EvalSigma-If-False-Some)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad else\_opt = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-If-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{ArmResult} = \{\text{Match}(out),\ \text{NoMatch}\}$$
$$\text{MatchArmJudg} = \{\Gamma \vdash \text{MatchArmSigma}(arm, v, \sigma) \Downarrow (res, \sigma')\}$$

**(EvalArmBody-Block)**
$$\frac{body = b \quad \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalArmBodySigma}(body, \sigma) \Downarrow (out, \sigma')}$$

**(EvalArmBody-Expr)**
$$\frac{body = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalArmBodySigma}(body, \sigma) \Downarrow (out, \sigma')}$$

**(MatchArm-Fail)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v)\ \text{undefined}}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{NoMatch}, \sigma)}$$

**(MatchArm-Guard-False)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Val}(\text{false}), \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, \text{Val}(())) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{NoMatch}, \sigma_3)}$$

**(MatchArm-Guard-True)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Val}(\text{true}), \sigma_2) \quad \Gamma \vdash \text{EvalArmBodySigma}(body, \sigma_2) \Downarrow (out, \sigma_3) \quad \text{BlockExit}(\sigma_3, scope, out) \Downarrow (out', \sigma_4)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_4)}$$

**(MatchArm-NoGuard)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = \bot \quad \Gamma \vdash \text{EvalArmBodySigma}(body, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_3)}$$

**(MatchArm-Ctrl)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, \text{Ctrl}(\kappa)) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_3)}$$

**(MatchArms-Head)**
$$\frac{\Gamma \vdash \text{MatchArmSigma}(a, v, \sigma) \Downarrow (\text{Match}(out), \sigma_1)}{\Gamma \vdash \text{MatchArmsSigma}(a::as, v, \sigma) \Downarrow (out, \sigma_1)}$$

**(MatchArms-Tail)**
$$\frac{\Gamma \vdash \text{MatchArmSigma}(a, v, \sigma) \Downarrow (\text{NoMatch}, \sigma_1) \quad \Gamma \vdash \text{MatchArmsSigma}(as, v, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{MatchArmsSigma}(a::as, v, \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Match)**
$$\frac{\Gamma \vdash \text{EvalSigma}(scrutinee, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{MatchArmsSigma}(arms, v, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrutinee, arms), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Match-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(scrutinee, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrutinee, arms), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Pointer and Move Expressions.**

**(EvalSigma-PtrNull)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{PtrNullExpr}, \sigma) \Downarrow (\text{Val}(\text{Ptr@Null}(0x0)), \sigma)}$$

**(EvalSigma-AddressOf)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AddressOf}(p), \sigma) \Downarrow (\text{Val}(\text{Ptr@Valid}(addr)), \sigma_1)}$$

**(EvalSigma-AddressOf-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AddressOf}(p), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Deref)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Deref}(e), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Deref-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Deref}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Move)**
$$\frac{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MoveExpr}(p), \sigma) \Downarrow (out, \sigma_1)}$$

**Call and Method Application.**

$$\text{CallJudg} = \{\Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (out, \sigma')\}$$
$$\text{CallTarget}(\text{ProcRef}(proc)) = proc$$
$$\text{CallTarget}(\text{RecordCtor}(p)) = \text{RecordCtor}(p)$$
$$\text{MethodTarget}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T), name) = \text{Dispatch}(T, Cl, name)$$
$$\text{MethodTarget}(v_{\text{self}}, name) = m \land m.\text{body} = \bot \land \neg \exists \vec{v}, v.\ \Gamma \vdash \text{PrimCall}(\text{MethodOwner}(m), \text{MethodName}(m), v_{\text{self}}, \vec{v}) \Downarrow v \Rightarrow \text{IllFormed}(\text{MethodTarget}(v_{\text{self}}, name))$$
$$\text{ArgVal} = \{v,\ \text{Alias}(addr)\}$$
$$\text{BindParams}([\langle mode_1, x_1, T_1 \rangle,\ldots,\langle mode_n, x_n, T_n \rangle], [v_1,\ldots,v_n]) = [\langle x_1, v_1 \rangle,\ldots,\langle x_n, v_n \rangle]$$
$$\text{RecordDefaultInits}(p) = [\langle f_1, e_1 \rangle,\ldots,\langle f_n, e_n \rangle] \iff \text{RecordDecl}(p) = R \land \text{Fields}(R) = [\langle vis_1, f_1, T_1, e_1, span_1, doc_1 \rangle,\ldots,\langle vis_n, f_n, T_n, e_n, span_n, doc_n \rangle] \land \forall i.\ e_i \ne \bot$$
$$\text{ReturnOut}(\text{Val}(v)) = \text{Val}(v)$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Return}(v))) = \text{Val}(v)$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Panic})) = \text{Ctrl}(\text{Panic})$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Abort})) = \text{Ctrl}(\text{Abort})$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Break}(v\_opt))) = \bot$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Continue})) = \bot$$
$$\text{ReturnOut}(out)=\bot \Rightarrow \text{IllFormed}(\text{ReturnOut}(out))$$
$$\text{RecvArgMode}(base) = \texttt{move} \iff \exists p.\ base = \text{MoveExpr}(p)$$
$$\text{RecvArgMode}(base) = \bot \iff \neg \exists p.\ base = \text{MoveExpr}(p)$$

**(EvalArgsSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalArgsSigma}([], [], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalArgsSigma-Cons-Move)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\text{MovedArg}(moved, e), \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}(ps, as, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Val}([v] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalArgsSigma-Cons-Ref)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}(ps, as, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Val}([\text{Alias}(addr)] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalArgsSigma-Ctrl-Move)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\text{MovedArg}(moved, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalArgsSigma-Ctrl-Ref)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalRecvSigma-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_{\text{self}}), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{self}} \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ref-Dyn)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T) \quad \text{DynAddrState}(\sigma_1, addr_d) = \texttt{Valid}}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T), \text{Alias}(addr_d) \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ref-Dyn-Expired)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T) \quad \text{DynAddrState}(\sigma_1, addr_d) = \texttt{Expired}}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalRecvSigma-Ref)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = v_{\text{self}} \quad \neg(\exists Cl, addr_d, T.\ v_{\text{self}} = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T))}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, \text{Alias}(addr) \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ctrl-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalRecvSigma-Ctrl-Ref)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{RegionProcParams}(name) = params \iff \text{RegionProcSig}(\texttt{Region::}name) = \langle params, ret \rangle$$

**(ApplyRegionProc-NewScoped)**
$$\frac{name = \texttt{new\_scoped} \quad \vec{v} = [opts] \quad \text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v)}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v), \sigma')}$$

**(ApplyRegionProc-Alloc)**
$$\frac{name = \texttt{alloc} \quad \vec{v} = [v_r, v] \quad \text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Reset)**
$$\frac{name = \texttt{reset\_unchecked} \quad \vec{v} = [v_r] \quad \text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Freeze)**
$$\frac{name = \texttt{freeze} \quad \vec{v} = [v_r] \quad \text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Thaw)**
$$\frac{name = \texttt{thaw} \quad \vec{v} = [v_r] \quad \text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Free)**
$$\frac{name = \texttt{free\_unchecked} \quad \vec{v} = [v_r] \quad \text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyProcSigma)**
$$\frac{\text{BindParams}(proc.\text{params}, \vec{v}) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad \Gamma \vdash \text{EvalBlockBodySigma}(proc.\text{body}, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma) \Downarrow (\text{ReturnOut}(out'), \sigma_3)}$$

**(ApplyRecordCtorSigma)**
$$\frac{\text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (\text{Val}(\text{RecordValue}(\text{TypePath}(p), \vec{f})), \sigma_1)}$$

**(ApplyRecordCtorSigma-Ctrl)**
$$\frac{\text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ApplyMethodSigma-Prim)**
$$\frac{m = \text{MethodTarget}(v_{\text{self}}, name) \quad \text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{\text{self}}, \vec{v}) \Downarrow v}{\Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ApplyMethodSigma)**
$$\frac{m = \text{MethodTarget}(v_{\text{self}}, name) \quad \text{BindParams}(\text{RecvParams}(base, name), [v_{\text{arg}}] \mathbin{+\!\!+} \vec{v}) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad \Gamma \vdash \text{EvalBlockBodySigma}(m.\text{body}, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (\text{ReturnOut}(out'), \sigma_3)}$$

**(EvalSigma-Call-RegionProc)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(\text{ProcRef}([\texttt{Region}], name)), \sigma_1) \quad \text{RegionProcParams}(name) = params \quad \Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-RegionProc-Ctrl-Args)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(\text{ProcRef}([\texttt{Region}], name)), \sigma_1) \quad \text{RegionProcParams}(name) = params \quad \Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Call-Proc)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad proc = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{EvalArgsSigma}(proc.\text{params}, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-Record)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}([], args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \vec{v} = [] \quad \text{RecordCtor}(p) = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Call-Ctrl-Args)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad proc = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{EvalArgsSigma}(proc.\text{params}, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-MethodCall)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{arg}} \rangle), \sigma_1) \quad m = \text{MethodTarget}(v_{\text{self}}, name) \quad \Gamma \vdash \text{EvalArgsSigma}(m.\text{params}, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-MethodCall-Ctrl)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-MethodCall-Ctrl-Args)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{arg}} \rangle), \sigma_1) \quad m = \text{MethodTarget}(v_{\text{self}}, name) \quad \Gamma \vdash \text{EvalArgsSigma}(m.\text{params}, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Alloc-Implicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ActiveTarget}(\sigma_1) = r \quad \text{RegionAlloc}(\sigma_1, r, v) \Downarrow (\sigma_2, v')}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(\bot, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_2)}$$

**(EvalSigma-Alloc-Implicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(\bot, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Alloc-Explicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{LookupVal}(\sigma_1, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma_1, h) = r_t \quad \text{RegionAlloc}(\sigma_1, r_t, v) \Downarrow (\sigma_2, v')}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(r, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_2)}$$

**(EvalSigma-Alloc-Explicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(r, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Block)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}$$

**(EvalSigma-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalSigma}(\text{UnsafeBlockExpr}(b), \sigma) \Downarrow (out, \sigma')}$$

**Loop Iteration Helpers.**

$$\text{IterJudg} = \{\text{IterInit}(v) \Downarrow it,\ \text{IterNext}(it) \Downarrow (opt(v), it')\}$$
$$\text{Iter} = \{\langle v, i \rangle \mid \text{Len}(v)\ \text{defined} \land i \in \mathbb{N}\}$$
$$\text{IterInit}(v) \Downarrow \langle v, 0 \rangle \iff \text{Len}(v)\ \text{defined}$$
$$\text{IterNext}(\langle v, i \rangle) \Downarrow (\bot, \langle v, i \rangle) \iff \neg(0 \le i < \text{Len}(v))$$
$$\text{IterNext}(\langle v, i \rangle) \Downarrow (v_i, \langle v, i+1 \rangle) \iff 0 \le i < \text{Len}(v) \land \text{IndexValue}(v, i) = v_i$$

$$\text{LoopIterJudg} = \{\Gamma \vdash \text{LoopIterExec}(p, b, it, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalSigma-Loop-Infinite-Step)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Infinite-Continue)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Infinite-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_1) \quad v = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(EvalSigma-Loop-Infinite-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Loop-Cond-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(EvalSigma-Loop-Cond-True-Step)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Loop-Cond-Continue)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_2) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Loop-Cond-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_2) \quad v = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(EvalSigma-Loop-Cond-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Loop-Cond-Body-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Loop-Iter)**
$$\frac{\Gamma \vdash \text{EvalSigma}(iter, \sigma) \Downarrow (\text{Val}(v\_{\text{iter}}), \sigma_1) \quad \text{IterInit}(v\_{\text{iter}}) \Downarrow it \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopIter}(pat, ty\_opt, iter, body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Iter-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(iter, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopIter}(pat, ty\_opt, iter, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(LoopIter-Done)**
$$\frac{\text{IterNext}(it) \Downarrow (\bot, it')}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Val}(()), \sigma)}$$

**(LoopIter-Step-Val)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIter-Step-Continue)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIter-Step-Break)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_1) \quad v' = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(LoopIter-Step-Ctrl)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Stateful Small-Step (Expressions).**

$$\text{ExprState} = \{\langle e, \sigma \rangle,\ \langle \text{Val}(v), \sigma \rangle,\ \langle \text{Ctrl}(\kappa), \sigma \rangle\}$$
$$\text{TerminalExpr}(\langle \text{Val}(v), \sigma \rangle)$$
$$\text{TerminalExpr}(\langle \text{Ctrl}(\kappa), \sigma \rangle)$$

**(StepSigma-Pure)**
$$\frac{\langle e \rangle \to \langle e' \rangle}{\langle e, \sigma \rangle \to \langle e', \sigma \rangle}$$

**(StepSigma-Alloc-Implicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ActiveTarget}(\sigma_1) = r \quad \text{RegionAlloc}(\sigma_1, r, v) \Downarrow (\sigma_2, v')}{\langle \text{AllocExpr}(\bot, e), \sigma \rangle \to \langle \text{Val}(v'), \sigma_2 \rangle}$$

**(StepSigma-Alloc-Implicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{AllocExpr}(\bot, e), \sigma \rangle \to \langle \text{Ctrl}(\kappa), \sigma_1 \rangle}$$

**(StepSigma-Alloc-Explicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{LookupVal}(\sigma_1, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma_1, h) = r_t \quad \text{RegionAlloc}(\sigma_1, r_t, v) \Downarrow (\sigma_2, v')}{\langle \text{AllocExpr}(r, e), \sigma \rangle \to \langle \text{Val}(v'), \sigma_2 \rangle}$$

**(StepSigma-Alloc-Explicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{AllocExpr}(r, e), \sigma \rangle \to \langle \text{Ctrl}(\kappa), \sigma_1 \rangle}$$

**(StepSigma-Block)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}{\langle \text{BlockExpr}(stmts, tail\_opt), \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\langle \text{UnsafeBlockExpr}(b), \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-Loop)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\ell, \sigma) \Downarrow (out, \sigma') \quad \ell \in \{\text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}}{\langle \ell, \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-Stateful-Other)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma') \quad e \notin \{\text{AllocExpr}(\_,\_),\ \text{BlockExpr}(\_,\_),\ \text{UnsafeBlockExpr}(\_),\ \text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}}{\langle e, \sigma \rangle \to \langle out, \sigma' \rangle}$$

**Statement Execution (Cursive0).**

$$\text{ExecJudg} = \{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (sout, \sigma')\}$$

**(ExecSeq-Empty)**
$$\frac{}{\Gamma \vdash \text{ExecSeqSigma}([], \sigma) \Downarrow (ok, \sigma)}$$

**(ExecSeq-Cons-Ok)**
$$\frac{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (ok, \sigma_1) \quad \Gamma \vdash \text{ExecSeqSigma}(ss, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{ExecSeqSigma}(s::ss, \sigma) \Downarrow (sout, \sigma_2)}$$

**(ExecSeq-Cons-Ctrl)**
$$\frac{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSeqSigma}(s::ss, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle$$

**(ExecSigma-Let)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindPattern}(\sigma_1, pat, v) \Downarrow (\sigma_2, bs)}{\Gamma \vdash \text{ExecSigma}(\text{LetStmt}(binding), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-Let-Ctrl)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{LetStmt}(binding), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Var)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindPattern}(\sigma_1, pat, v) \Downarrow (\sigma_2, bs)}{\Gamma \vdash \text{ExecSigma}(\text{VarStmt}(binding), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-Var-Ctrl)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{VarStmt}(binding), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-ShadowLet)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindVal}(\sigma_1, x, v) \Downarrow (\sigma_2, b)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowLetStmt}(x, ty\_opt, init), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-ShadowLet-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowLetStmt}(x, ty\_opt, init), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-ShadowVar)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindVal}(\sigma_1, x, v) \Downarrow (\sigma_2, b)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowVarStmt}(x, ty\_opt, init), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-ShadowVar-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowVarStmt}(x, ty\_opt, init), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Assign)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{ExecSigma}(\text{AssignStmt}(p, e), \sigma) \Downarrow (sout, \sigma_2)}$$

**(ExecSigma-Assign-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{AssignStmt}(p, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$


**(ExecSigma-CompoundAssign)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (\text{Val}(v_e), \sigma_2) \quad \text{BinOp}(op, v_p, v_e) \Downarrow v \quad \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (sout, \sigma_3)}$$

**(ExecSigma-CompoundAssign-Left-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-CompoundAssign-Right-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(ExecSigma-ExprStmt)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ExprStmt}(e), \sigma) \Downarrow (\text{StmtOutOf}(out), \sigma_1)}$$

**(ExecSigma-UnsafeStmt)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{UnsafeBlockStmt}(b), \sigma) \Downarrow (\text{StmtOutOf}(out), \sigma_1)}$$

**(ExecSigma-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\Gamma \vdash \text{ExecSigma}(\text{DeferStmt}(b), \sigma) \Downarrow (ok, \sigma')}$$

$$opts = \text{RegionOptsExpr}(opts\_opt)$$

**(ExecSigma-Region)**
$$\frac{\Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Val}(v_o), \sigma_1) \quad \text{RegionNew}(\sigma_1, v_o) \Downarrow (\sigma_2, r, scope) \quad \text{BindRegionAlias}(\sigma_2, alias\_opt, r) \Downarrow \sigma_3 \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_3, scope) \Downarrow (out, \sigma_4) \quad \text{RegionRelease}(\sigma_4, r, scope, out) \Downarrow (out', \sigma_5)}{\Gamma \vdash \text{ExecSigma}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_5)}$$

**(ExecSigma-Region-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{RegionRelease}(Sigma, r, scope, out) \Downarrow (out', Sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, Sigma) \Downarrow (c, Sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land Sigma' = Sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{ReleaseArena}(Sigma_1, r) \Downarrow Sigma_2 \land \text{PopScope}_\sigma(Sigma_2) \Downarrow (Sigma', scope)))$$

**(ExecSigma-Frame-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r, scope, mark, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{FrameStmt}(\bot, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**(ExecSigma-Frame-Explicit)**
$$\frac{\text{LookupVal}(\sigma, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r_t, scope, mark, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{FrameStmt}(r, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

$$\text{FrameReset}(Sigma, r, scope, mark, out) \Downarrow (out', Sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, Sigma) \Downarrow (c, Sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land Sigma' = Sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{ResetArena}(Sigma_1, r, mark) \Downarrow Sigma_2 \land \text{PopScope}_\sigma(Sigma_2) \Downarrow (Sigma', scope)))$$

**(ExecSigma-Return)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v)), \sigma_1)}$$

**(ExecSigma-Return-Unit)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(\bot), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(())), \sigma)}$$

**(ExecSigma-Return-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Result)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ResultStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Result}(v)), \sigma_1)}$$

**(ExecSigma-Result-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ResultStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v)), \sigma_1)}$$

**(ExecSigma-Break-Unit)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(\bot), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(\bot)), \sigma)}$$

**(ExecSigma-Break-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Continue)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ContinueStmt}, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma)}$$

**(ExecSigma-Error)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ErrorStmt}(\_), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**Stateful Small-Step (Statements).**

$$\text{ExecState} = \{\text{Exec}(s, \sigma),\ \text{ExecSeq}(ss, \sigma),\ \text{ExecCtrl}(\kappa, \sigma),\ \text{ExecDone}(\sigma),\ \text{RegionBody}(r, scope, b, \sigma),\ \text{RegionExit}(r, scope, out, \sigma),\ \text{FrameBody}(r, scope, mark, b, \sigma),\ \text{FrameExit}(r, scope, mark, out, \sigma)\}$$

**(Step-Exec-Other-Ok)**
$$\frac{s \notin \{\text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_)\} \quad \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (ok, \sigma')}{\langle \text{Exec}(s, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Other-Ctrl)**
$$\frac{s \notin \{\text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_)\} \quad \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')}{\langle \text{Exec}(s, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-ExecSeq-Ok)**
$$\frac{\Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (ok, \sigma')}{\langle \text{ExecSeq}(ss, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-ExecSeq-Ctrl)**
$$\frac{\Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')}{\langle \text{ExecSeq}(ss, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-Exec-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\langle \text{Exec}(\text{DeferStmt}(b), \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Region-Enter)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Val}(v_o), \sigma_1) \quad \text{RegionNew}(\sigma_1, v_o) \Downarrow (\sigma_2, r, scope) \quad \text{BindRegionAlias}(\sigma_2, alias\_opt, r) \Downarrow \sigma_3}{\langle \text{Exec}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \rangle \to \langle \text{RegionBody}(r, scope, b, \sigma_3) \rangle}$$

**(Step-Exec-Region-Enter-Ctrl)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{Exec}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma_1) \rangle}$$

**(Step-Exec-Region-Body)**
$$\frac{\Gamma \vdash \text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma_1)}{\langle \text{RegionBody}(r, scope, b, \sigma) \rangle \to \langle \text{RegionExit}(r, scope, out, \sigma_1) \rangle}$$

**(Step-Exec-Region-Exit-Ok)**
$$\frac{\text{RegionRelease}(\sigma, r, scope, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = ok}{\langle \text{RegionExit}(r, scope, out, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Region-Exit-Ctrl)**
$$\frac{\text{RegionRelease}(\sigma, r, scope, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = \text{Ctrl}(\kappa)}{\langle \text{RegionExit}(r, scope, out, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-Exec-Frame-Enter-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark)}{\langle \text{Exec}(\text{FrameStmt}(\bot, b), \sigma) \rangle \to \langle \text{FrameBody}(r, scope, mark, b, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Enter-Explicit)**
$$\frac{\text{LookupVal}(\sigma, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark)}{\langle \text{Exec}(\text{FrameStmt}(r, b), \sigma) \rangle \to \langle \text{FrameBody}(r_t, scope, mark, b, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Body)**
$$\frac{\Gamma \vdash \text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma_1)}{\langle \text{FrameBody}(r, scope, mark, b, \sigma) \rangle \to \langle \text{FrameExit}(r, scope, mark, out, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Exit-Ok)**
$$\frac{\text{FrameReset}(\sigma, r, scope, mark, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = ok}{\langle \text{FrameExit}(r, scope, mark, out, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Frame-Exit-Ctrl)**
$$\frac{\text{FrameReset}(\sigma, r, scope, mark, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = \text{Ctrl}(\kappa)}{\langle \text{FrameExit}(r, scope, mark, out, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

$$\text{ConstPat}(p) = v \iff p = \text{LiteralPattern}(\ell) \land v = \text{LiteralValue}(\ell, \text{PatType}(p))$$

**MatchRecord.**
$$\text{MatchRecordJudg} = \{\Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B\}$$

**(MatchRecord-Empty)**
$$\frac{}{\Gamma \vdash \text{MatchRecord}([], v) \Downarrow \emptyset}$$

**(MatchRecord-Cons-Implicit)**
$$\frac{\text{FieldValue}(v, f) = v_f \quad \Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B}{\Gamma \vdash \text{MatchRecord}([f] \mathbin{+\!\!+} fs,\ v) \Downarrow (B \uplus \{f \mapsto v_f\})}$$

**(MatchRecord-Cons-Explicit)**
$$\frac{\text{FieldValue}(v, f) = v_f \quad \Gamma \vdash \text{MatchPattern}(p, v_f) \Downarrow B_1 \quad \Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B_2}{\Gamma \vdash \text{MatchRecord}([\langle f, p \rangle] \mathbin{+\!\!+} fs,\ v) \Downarrow (B_1 \uplus B_2)}$$

### 7.5. String Literal Semantics

$$\text{StringLiteralVal}(lit) = v \iff \text{LiteralValue}(lit, \text{TypeString}(\texttt{@View})) = v$$

**String Literal Storage.**
For any string literal `lit`, evaluation MUST allocate `StringBytes(lit)` in static, read-only storage. The resulting `string@View` value MUST reference that storage and MUST have length `|StringBytes(lit)|`. The backing storage MUST have static duration and MUST NOT be deallocated. See Â§6.1.5 for the `string@View` layout.
<!-- Source: "Literal content is allocated in static, read-only memory at compilation ... A string@View value is constructed with pointer to static memory and byte length ... String literals have static storage duration; backing memory is never deallocated." -->

### 7.6. Dynamic Class Objects

$$\text{DynValue}(Cl, addr, T) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)$$
$$\text{DynLayout}(Cl, addr, T) = \langle \text{RawPtr}(\texttt{imm}, addr), \text{VTable}(T, Cl) \rangle$$

**(Eval-Dynamic-Form)**
$$\frac{\text{IsPlace}(e) \quad \Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_e = \text{ExprType}(e) \quad T = \text{StripPerm}(T_e) \quad \Gamma \vdash T <: Cl}{\Gamma \vdash \text{EvalSigma}(e\ \texttt{as}\ \text{TypeDynamic}(Cl), \sigma) \Downarrow (\text{Val}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)), \sigma_1)}$$

**(Eval-Dynamic-Form-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(e\ \texttt{as}\ \text{TypeDynamic}(Cl), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Dynamic Dispatch.**

$$\text{Dispatch}(T, Cl, name) = m' \iff m = \text{LookupClassMethod}(Cl, name) \land \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') = \text{Sig}_T(T, m)$$
$$\text{Dispatch}(T, Cl, name) = m \iff m = \text{LookupClassMethod}(Cl, name) \land (\text{MethodByName}(T, name) = \bot \lor (\exists m'.\ \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m))) \land m.\text{body} \ne \bot$$
$$\text{Dispatch}(T, Cl, name) = \bot \iff m = \text{LookupClassMethod}(Cl, name) \land (\text{MethodByName}(T, name) = \bot \lor (\exists m'.\ \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m))) \land m.\text{body} = \bot$$


### 7.7. FileSystem and File Operations

**Primitive Relations.**

$$\text{FSJudg} = \{\text{FSOpenRead}(fs, path) \Downarrow r,\ \text{FSOpenWrite}(fs, path) \Downarrow r,\ \text{FSOpenAppend}(fs, path) \Downarrow r,\ \text{FSCreateWrite}(fs, path) \Downarrow r,\ \text{FSReadFile}(fs, path) \Downarrow r,\ \text{FSReadBytes}(fs, path) \Downarrow r,\ \text{FSWriteFile}(fs, path, data) \Downarrow r,\ \text{FSWriteStdout}(fs, data) \Downarrow r,\ \text{FSWriteStderr}(fs, data) \Downarrow r,\ \text{FSExists}(fs, path) \Downarrow b,\ \text{FSRemove}(fs, path) \Downarrow r,\ \text{FSOpenDir}(fs, path) \Downarrow r,\ \text{FSCreateDir}(fs, path) \Downarrow r,\ \text{FSEnsureDir}(fs, path) \Downarrow r,\ \text{FSKind}(fs, path) \Downarrow r,\ \text{FSRestrict}(fs, path) \Downarrow fs',\ \text{FileReadAll}(handle) \Downarrow r,\ \text{FileReadAllBytes}(handle) \Downarrow r,\ \text{FileWrite}(handle, data) \Downarrow r,\ \text{FileFlush}(handle) \Downarrow r,\ \text{FileClose}(handle) \Downarrow ok,\ \text{DirNext}(handle) \Downarrow r,\ \text{DirClose}(handle) \Downarrow ok\}$$
$$\text{FSResType}(\text{FSOpenRead}) = \texttt{File@Read} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenWrite}) = \texttt{File@Write} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenAppend}) = \texttt{File@Append} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSCreateWrite}) = \texttt{File@Write} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSReadFile}) = \texttt{string@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSReadBytes}) = \texttt{bytes@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteFile}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteStdout}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteStderr}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSExists}) = \texttt{bool}$$
$$\text{FSResType}(\text{FSRemove}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenDir}) = \texttt{DirIter@Open} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSCreateDir}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSEnsureDir}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSKind}) = \texttt{FileKind} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSRestrict}) = \texttt{$FileSystem}$$
$$\text{FSResType}(\text{FileReadAll}) = \texttt{string@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileReadAllBytes}) = \texttt{bytes@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileWrite}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileFlush}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileClose}) = \texttt{ok}$$
$$\text{FSResType}(\text{DirNext}) = \texttt{DirEntry} \mid \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{DirClose}) = \texttt{ok}$$

$$\text{Handle} = \mathbb{N}$$
$$\text{Entry} ::= \text{FileEntry}(bytes) \mid \text{DirEntry}(names) \mid \text{OtherEntry}$$
$$\text{FSState} = \langle \text{entries},\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle$$
$$\text{Entries}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = entries$$
$$\text{Handles}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = handles$$
$$\text{DirIters}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = diriters$$
$$\text{FlushedSet}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = flushed$$
$$\text{FailMap}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = failmap$$
$$\text{EntryKind}(\omega, path) =
\begin{cases}
\texttt{File} & \text{if }\text{Entries}(\omega)[path]=\text{FileEntry}(\_)\\
\texttt{Dir} & \text{if }\text{Entries}(\omega)[path]=\text{DirEntry}(\_)\\
\texttt{Other} & \text{if }\text{Entries}(\omega)[path]=\text{OtherEntry}\\
\texttt{Other} & \text{if }\text{Entries}(\omega)[path]\ \text{undefined}
\end{cases}$$
$$\text{FileBytes}(\omega, path) = bytes \iff \text{Entries}(\omega)[path]=\text{FileEntry}(bytes)$$
$$\text{DirNames}(\omega, path) = names \iff \text{Entries}(\omega)[path]=\text{DirEntry}(names)$$
$$\text{HandleStateOf}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{state} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
\texttt{Closed} & \text{otherwise}
\end{cases}$$
$$\text{HandlePos}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{pos} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{HandleLen}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{len} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{HandlePath}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{path} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
\texttt{"\""} & \text{otherwise}
\end{cases}$$
$$\text{DirIterFS}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{fs} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{DirIterPath}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{path} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
\texttt{"\""} & \text{otherwise}
\end{cases}$$
$$\text{DirIterEntries}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{entries} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DirIterPos}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{pos} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{DirIterOpen}(\omega, h) \iff \text{DirIters}(\omega)[h]\ \text{defined}$$
$$\text{Flushed}(\omega, h) \iff h \in \text{FlushedSet}(\omega)$$
$$\text{FSJudg}_\omega = \{\text{FSOpenRead}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenWrite}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenAppend}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSCreateWrite}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSWriteFile}(fs, path, data, \omega) \Downarrow (r, \omega'),\ \text{FSWriteStdout}(fs, data, \omega) \Downarrow (r, \omega'),\ \text{FSWriteStderr}(fs, data, \omega) \Downarrow (r, \omega'),\ \text{FSExists}(fs, path, \omega) \Downarrow (b, \omega'),\ \text{FSRemove}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSCreateDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSEnsureDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSKind}(fs, path, \omega) \Downarrow (r, \omega')\}$$
$$\text{FileJudg}_\omega = \{\text{FileReadAll}(h, \omega) \Downarrow (r, \omega'),\ \text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega'),\ \text{FileWrite}(h, data, \omega) \Downarrow (r, \omega'),\ \text{FileFlush}(h, \omega) \Downarrow (r, \omega'),\ \text{FileClose}(h, \omega) \Downarrow (ok, \omega')\}$$
$$\text{DirJudg}_\omega = \{\text{DirNext}(h, \omega) \Downarrow (r, \omega'),\ \text{DirClose}(h, \omega) \Downarrow (ok, \omega')\}$$

$$\text{FSOpenRead}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenWrite}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenWrite}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenAppend}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenAppend}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSCreateWrite}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSCreateWrite}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSReadFile}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSReadBytes}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteFile}(fs, path, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteFile}(fs, path, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteStdout}(fs, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteStdout}(fs, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteStderr}(fs, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteStderr}(fs, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSExists}(fs, path) \Downarrow b \iff \exists \omega,\omega'.\ \text{FSExists}(fs, path, \omega) \Downarrow (b, \omega')$$
$$\text{FSRemove}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSRemove}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSCreateDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSCreateDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSEnsureDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSEnsureDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSKind}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSKind}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FileReadAll}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileReadAll}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileReadAllBytes}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileWrite}(h, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileWrite}(h, data, \omega) \Downarrow (r, \omega')$$
$$\text{FileFlush}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileFlush}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileClose}(h) \Downarrow ok \iff \exists \omega,\omega'.\ \text{FileClose}(h, \omega) \Downarrow (ok, \omega')$$
$$\text{DirNext}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{DirNext}(h, \omega) \Downarrow (r, \omega')$$
$$\text{DirClose}(h) \Downarrow ok \iff \exists \omega,\omega'.\ \text{DirClose}(h, \omega) \Downarrow (ok, \omega')$$

**Restriction Semantics.**

$$\text{RestrictPath}(base, path) = p \iff \neg \text{AbsPath}(path) \land b = \text{Canon}(\text{Normalize}(base)) \land b \ne \bot \land p = \text{Canon}(\text{Normalize}(\text{Join}(b, path))) \land p \ne \bot \land \text{prefix}(p, b)$$
$$\text{RestrictPath}(base, path) = \bot \iff \text{AbsPath}(path) \lor \text{Canon}(\text{Normalize}(base)) = \bot \lor \text{Canon}(\text{Normalize}(\text{Join}(\text{Canon}(\text{Normalize}(base)), path))) = \bot \lor \neg \text{prefix}(\text{Canon}(\text{Normalize}(\text{Join}(\text{Canon}(\text{Normalize}(base)), path))), \text{Canon}(\text{Normalize}(base)))$$
$$\text{FSOp} = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSCreateWrite},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSWriteFile},\ \text{FSWriteStdout},\ \text{FSWriteStderr},\ \text{FSExists},\ \text{FSRemove},\ \text{FSOpenDir},\ \text{FSCreateDir},\ \text{FSEnsureDir},\ \text{FSKind}\}$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land Op \in \text{FSOp} \land \text{RestrictPath}(base, p) = q \Rightarrow Op(fs', p) = Op(fs, q)$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land Op \in \text{FSOp} \land \text{RestrictPath}(base, p) = \bot \land Op \ne \text{FSExists} \Rightarrow Op(fs', p) = \text{IoError::InvalidPath}$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land \text{RestrictPath}(base, p) = \bot \Rightarrow \text{FSExists}(fs', p) = \text{false}$$

**IoError Mapping.**

$$\text{FSPathOp}_0 = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSCreateWrite},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSExists},\ \text{FSRemove},\ \text{FSOpenDir},\ \text{FSCreateDir},\ \text{FSEnsureDir},\ \text{FSKind}\}$$
$$\text{FSPathOp}_1 = \{\text{FSWriteFile}\}$$
$$\text{FSRequiresExisting} = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSOpenDir},\ \text{FSKind},\ \text{FSRemove}\}$$
$$\text{PathInvalid}(fs, path, \omega) \iff \text{Canon}(\text{Normalize}(path)) = \bot$$
$$\text{EntryExists}(\omega, path) \iff \text{Entries}(\omega)[path]\ \text{defined}$$
$$\text{EntryKind}(\omega, path) \in \{\texttt{File},\ \texttt{Dir},\ \texttt{Other}\}$$
$$\text{PermissionDenied}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::PermissionDenied}$$
$$\text{Busy}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::Busy}$$
$$\text{OtherFailure}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::IoFailure}$$

$$Op \in \text{FSPathOp}_0 \land \text{PathInvalid}(fs, path, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$Op \in \text{FSPathOp}_1 \land \text{PathInvalid}(fs, path, \omega) \Rightarrow Op(fs, path, data, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$Op \in \text{FSRequiresExisting} \land \neg \text{EntryExists}(\omega, path) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::NotFound}, \omega)$$
$$\text{PermissionDenied}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::PermissionDenied}, \omega)$$
$$Op = \text{FSCreateWrite} \land \text{EntryExists}(\omega, path) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::AlreadyExists}, \omega)$$
$$Op \in \{\text{FSCreateDir},\ \text{FSEnsureDir}\} \land \text{EntryExists}(\omega, path) \land \text{EntryKind}(\omega, path) \ne \texttt{Dir} \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::AlreadyExists}, \omega)$$
$$Op = \text{FSOpenDir} \land \text{EntryExists}(\omega, path) \land \text{EntryKind}(\omega, path) \ne \texttt{Dir} \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$\text{Busy}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::Busy}, \omega)$$
$$\text{OtherFailure}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$

$$\text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega') \land \text{FSReadBytes}(fs, path, \omega) \Downarrow (bytes, \omega'') \land \neg \text{Utf8Valid}(bytes) \Rightarrow r = \text{IoError::IoFailure}$$
$$\text{FileReadAll}(h, \omega) \Downarrow (r, \omega') \land \text{FileReadAllBytes}(h, \omega) \Downarrow (bytes, \omega'') \land \neg \text{Utf8Valid}(bytes) \Rightarrow r = \text{IoError::IoFailure}$$

$$\text{FSExists}(fs, path, \omega) \Downarrow (\text{true}, \omega') \Rightarrow \text{EntryExists}(\omega, path) \land \neg \text{PathInvalid}(fs, path, \omega)$$
$$\text{FSExists}(fs, path, \omega) \Downarrow (\text{false}, \omega') \Rightarrow \text{PathInvalid}(fs, path, \omega)\ \lor\ \neg \text{EntryExists}(\omega, path)$$

**File and Directory Operation Semantics.**

$$\text{HandleState} = \{\texttt{OpenRead},\ \texttt{OpenWrite},\ \texttt{OpenAppend},\ \texttt{Closed}\}$$
$$\text{HandleOpen}(\omega, h) \iff \text{HandleStateOf}(\omega, h) \ne \texttt{Closed}$$
$$\text{HandleMode}(\omega, h) = \begin{cases}
\texttt{Read} & \text{HandleStateOf}(\omega, h) = \texttt{OpenRead} \\
\texttt{Write} & \text{HandleStateOf}(\omega, h) = \texttt{OpenWrite} \\
\texttt{Append} & \text{HandleStateOf}(\omega, h) = \texttt{OpenAppend}
\end{cases}$$
$$\text{FileLenAt}(\omega, path) = \begin{cases}
\text{ByteLen}(bytes) & \text{if }\text{Entries}(\omega)[path]=\text{FileEntry}(bytes)\\
0 & \text{otherwise}
\end{cases}$$
$$\text{ByteLen}(data) = \begin{cases}
|data| & data \in \text{Bytes}\\
|\text{Utf8}(data)| & data \in \text{String}\\
0 & \text{otherwise}
\end{cases}$$

$$\text{LexBytes}(b_1, b_2) \iff (\exists k.\ 0 \le k < \min(|b_1|,|b_2|) \land (\forall i<k.\ b_1[i]=b_2[i]) \land b_1[k] < b_2[k]) \lor (|b_1| < |b_2| \land \forall i<|b_1|.\ b_1[i]=b_2[i])$$
$$\text{EntryKey}(name) = \text{CaseFold}(\text{NFC}(name))$$
$$\text{EntryOrder}(a, b) \iff \text{LexBytes}(\text{Utf8}(\text{EntryKey}(a)), \text{Utf8}(\text{EntryKey}(b))) \lor (\text{EntryKey}(a) = \text{EntryKey}(b) \land \text{LexBytes}(\text{Utf8}(a), \text{Utf8}(b)))$$
$$\text{DirSnapshot}(fs, path, \omega) = \begin{cases}
\text{DirNames}(\omega, path) & \text{Entries}(\omega)[path]=\text{DirEntry}(\_)\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DirEntries}(fs, path, \omega) = \text{sort}_{\text{EntryOrder}}(\text{DirSnapshot}(fs, path, \omega))$$
$$\forall name \in \text{DirSnapshot}(fs, path, \omega).\ name \ne \texttt{"."} \land name \ne \texttt{".."}$$

$$\text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenRead} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSOpenWrite}(fs, path, \omega) \Downarrow (\texttt{File@Write}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenWrite} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSOpenAppend}(fs, path, \omega) \Downarrow (\texttt{File@Append}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenAppend} \land \text{HandlePos}(\omega', h) = \text{FileLenAt}(\omega, path) \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSCreateWrite}(fs, path, \omega) \Downarrow (\texttt{File@Write}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenWrite} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = 0$$

$$\text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega') \iff \exists h,\omega_1,\omega_2.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega_1) \land \text{FileReadAll}(h, \omega_1) \Downarrow (r, \omega_2) \land \text{FileClose}(h, \omega_2) \Downarrow (ok, \omega')$$
$$\text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega') \iff \exists h,\omega_1,\omega_2.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega_1) \land \text{FileReadAllBytes}(h, \omega_1) \Downarrow (r, \omega_2) \land \text{FileClose}(h, \omega_2) \Downarrow (ok, \omega')$$

$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileReadAll}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileReadAllBytes}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileWrite}(h, data, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileFlush}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$

$$\text{FileReadAll}(h, \omega) \Downarrow (r, \omega') \land r \ne \text{IoError::IoFailure} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h)$$
$$\text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega') \land r \ne \text{IoError::IoFailure} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h)$$

$$\text{FileWrite}(h, data, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleOpen}(\omega, h) \land (\text{HandleMode}(\omega, h) = \texttt{Append} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h) + \text{ByteLen}(data)) \land (\text{HandleMode}(\omega, h) \ne \texttt{Append} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandlePos}(\omega, h) + \text{ByteLen}(data))$$
$$\text{FileWrite}(h, data, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleLen}(\omega', h) = \max(\text{HandleLen}(\omega, h),\ \text{HandlePos}(\omega', h))$$

$$\text{FileFlush}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \text{Flushed}(\omega', h)$$
$$\text{FileClose}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{Closed}$$

$$\text{FSOpenDir}(fs, path, \omega) \Downarrow (\texttt{DirIter@Open}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{DirIterOpen}(\omega', h) \land \text{DirIterFS}(\omega', h) = fs \land \text{DirIterPath}(\omega', h) = path \land \text{DirIterEntries}(\omega', h) = \text{DirEntries}(fs, path, \omega) \land \text{DirIterPos}(\omega', h) = 0$$

$$\neg \text{DirIterOpen}(\omega, h) \Rightarrow \text{DirNext}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\text{DirIterOpen}(\omega, h) \land \text{DirIterPos}(\omega, h) = i \land i \ge |\text{DirIterEntries}(\omega, h)| \Rightarrow \text{DirNext}(h, \omega) \Downarrow ((), \omega)$$
$$\text{DirIterOpen}(\omega, h) \land \text{DirIterPos}(\omega, h) = i \land i < |\text{DirIterEntries}(\omega, h)| \land name = \text{DirIterEntries}(\omega, h)[i] \land path = \text{Join}(\text{DirIterPath}(\omega, h), name) \land \text{FSKind}(\text{DirIterFS}(\omega, h), path, \omega) \Downarrow (k, \omega_1) \Rightarrow \text{DirNext}(h, \omega) \Downarrow (\texttt{DirEntry}\{\texttt{path}: path,\ \texttt{name}: name,\ \texttt{kind}: k\}, \omega_2) \land \text{DirIterPos}(\omega_2, h) = i+1$$

$$\text{DirClose}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \neg \text{DirIterOpen}(\omega', h)$$

**Handle Extraction.**

$$\text{HandleOf}(v) = h \iff v = \texttt{File@Read}\{\texttt{handle}: h\} \lor v = \texttt{File@Write}\{\texttt{handle}: h\} \lor v = \texttt{File@Append}\{\texttt{handle}: h\}$$
$$\text{DirHandleOf}(v) = h \iff v = \texttt{DirIter@Open}\{\texttt{handle}: h\}$$

**Primitive Method Application.**

$$\text{MethodName}(\text{MethodDecl}(\_,\_,name,\_,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{ClassMethodDecl}(\_,name,\_,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{StateMethodDecl}(\_,name,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{TransitionDecl}(\_,name,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodOwner}(m) = owner \iff \exists T.\ \text{MethodByName}(T, \text{MethodName}(m)) = m \land owner = T$$
$$\text{PrimCallJudg} = \{\text{PrimCall}(Owner, name, v_{\text{self}}, args) \Downarrow v\}$$

**(Prim-FS-OpenRead)**
$$\frac{\Gamma \vdash \text{FSOpenRead}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_read}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenWrite)**
$$\frac{\Gamma \vdash \text{FSOpenWrite}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_write}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenAppend)**
$$\frac{\Gamma \vdash \text{FSOpenAppend}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_append}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-CreateWrite)**
$$\frac{\Gamma \vdash \text{FSCreateWrite}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{create_write}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-ReadFile)**
$$\frac{\Gamma \vdash \text{FSReadFile}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{read_file}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-ReadBytes)**
$$\frac{\Gamma \vdash \text{FSReadBytes}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{read_bytes}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-WriteFile)**
$$\frac{\Gamma \vdash \text{FSWriteFile}(v_{fs}, p, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_file}, v_{fs}, [p, d]) \Downarrow r}$$

**(Prim-FS-WriteStdout)**
$$\frac{\Gamma \vdash \text{FSWriteStdout}(v_{fs}, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_stdout}, v_{fs}, [d]) \Downarrow r}$$

**(Prim-FS-WriteStderr)**
$$\frac{\Gamma \vdash \text{FSWriteStderr}(v_{fs}, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_stderr}, v_{fs}, [d]) \Downarrow r}$$

**(Prim-FS-Exists)**
$$\frac{\Gamma \vdash \text{FSExists}(v_{fs}, p) \Downarrow b}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{exists}, v_{fs}, [p]) \Downarrow b}$$

**(Prim-FS-Remove)**
$$\frac{\Gamma \vdash \text{FSRemove}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{remove}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenDir)**
$$\frac{\Gamma \vdash \text{FSOpenDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-CreateDir)**
$$\frac{\Gamma \vdash \text{FSCreateDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{create_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-EnsureDir)**
$$\frac{\Gamma \vdash \text{FSEnsureDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{ensure_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-Kind)**
$$\frac{\Gamma \vdash \text{FSKind}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{kind}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-Restrict)**
$$\frac{\Gamma \vdash \text{FSRestrict}(v_{fs}, p) \Downarrow v_{fs}'}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{restrict}, v_{fs}, [p]) \Downarrow v_{fs}'}$$

**(Prim-File-ReadAll)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileReadAll}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{read_all}, v, []) \Downarrow r}$$

**(Prim-File-ReadAllBytes)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileReadAllBytes}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{read_all_bytes}, v, []) \Downarrow r}$$

**(Prim-File-Write)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileWrite}(h, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{write}, v, [d]) \Downarrow r}$$

**(Prim-File-Flush)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileFlush}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{flush}, v, []) \Downarrow r}$$

**(Prim-File-Write-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileWrite}(h, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{write}, v, [d]) \Downarrow r}$$

**(Prim-File-Flush-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileFlush}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{flush}, v, []) \Downarrow r}$$

**(Prim-File-Close-Read)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-File-Close-Write)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-File-Close-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-Dir-Next)**
$$\frac{\text{DirHandleOf}(v) = h \quad \Gamma \vdash \text{DirNext}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{DirIter@Open}, \texttt{next}, v, []) \Downarrow r}$$

**(Prim-Dir-Close)**
$$\frac{\text{DirHandleOf}(v) = h \quad \Gamma \vdash \text{DirClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{DirIter@Open}, \texttt{close}, v, []) \Downarrow \texttt{DirIter@Closed}\{\}}$$

**(ApplyMethod-Prim)**
$$\frac{\text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{self}, \vec{v}) \Downarrow v}{\Gamma \vdash \text{ApplyMethod}(m, v_{self}, \vec{v}) \Downarrow v}$$

**(ApplyMethod-Prim-Step)**
$$\frac{\text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{self}, \vec{v}) \Downarrow v}{\langle \text{ApplyMethod}(m, v_{self}, \vec{v}) \rangle \to \langle v \rangle}$$

### 7.8. Interpreter Entrypoint (Project-Level)

**Interpreter Judgments.**

$$\text{InterpJudg} = \{ \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma'),\ \Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}(P_s) \}$$
$$\text{ContextValue}(v) \iff \exists bits.\ \text{ValueBits}(\text{TypePath}([\texttt{"Context"}]), v) = bits$$

**(ContextInitSigma)**
$$\frac{\text{ContextValue}(v_{ctx})}{\Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma)}$$

**(Interpret-Project-Ok)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{Deinit}(P, \sigma_2) \Downarrow \sigma_3}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (\text{Val}(v), \sigma_3)}$$

**(Interpret-Project-Init-Panic)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Uparrow \text{panic}(P_s)}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}(P_s)}$$

**(Interpret-Project-Main-Ctrl)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(Interpret-Project-Deinit-Panic)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{Deinit}(P, \sigma_2) \Uparrow \text{panic}}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}}$$
## 8. Appendix A - Diagnostic Codes

### 8.0. DiagIdâ€“Code Map

$$\text{DiagTable} = \{\texttt{E-PRJ},\ \texttt{E-MOD},\ \texttt{E-OUT},\ \texttt{E-SRC},\ \texttt{E-CNF},\ \texttt{E-UNS},\ \texttt{E-MEM},\ \texttt{W-MOD},\ \texttt{W-SRC},\ \texttt{E-TYP},\ \texttt{W-SYS},\ \texttt{E-SEM},\ \texttt{W-SEM}\}$$
$$\text{DiagRow} = \langle \text{code},\ \text{sev},\ \text{det},\ \text{cond},\ \text{ids} \rangle$$
$$\text{RowCode}(\langle code, sev, det, cond, ids \rangle) = code$$
$$\text{RowSev}(\langle code, sev, det, cond, ids \rangle) = sev$$
$$\text{RowDet}(\langle code, sev, det, cond, ids \rangle) = det$$
$$\text{RowCond}(\langle code, sev, det, cond, ids \rangle) = cond$$
$$\text{RowIds}(\langle code, sev, det, cond, ids \rangle) = ids$$
$$\text{SeverityColumn}(c) = sev \iff \exists row \in \text{DiagRows}.\ \text{RowCode}(row)=c \land \text{RowSev}(row)=sev$$
$$\text{ConditionColumn}(c) = cond \iff \exists row \in \text{DiagRows}.\ \text{RowCode}(row)=c \land \text{RowCond}(row)=cond$$
$$\text{TableRows}(t) = \{ row \mid row\ \text{appears in table}\ t \}$$
$$\text{DiagRows} = \bigcup_{t \in \text{DiagTable}} \text{TableRows}(t)$$
$$\text{C0Code}(id) = c \iff \exists row \in \text{DiagRows}.\ id \in \text{RowIds}(row) \land \text{RowCode}(row)=c$$
$$\text{C0Code}(id) = \bot \iff \neg \exists row \in \text{DiagRows}.\ id \in \text{RowIds}(row)$$

### 8.1. E-PRJ (Project)

| Code         | Severity | Detection    | Condition                                                                            | DiagId                                                                                             |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `E-PRJ-0101` | Error    | Compile-time | `Cursive.toml` not found at project root                                             | Parse-Manifest-Missing                                                                             |
| `E-PRJ-0102` | Error    | Compile-time | `Cursive.toml` is not valid TOML                                                     | Parse-Manifest-Err                                                                                 |
| `E-PRJ-0103` | Error    | Compile-time | Missing required `assembly` table, empty assembly list, required keys, or required key type | WF-Assembly-Table-Err, WF-Assembly-Count-Err, WF-Assembly-Required-Types-Err                       |
| `E-PRJ-0104` | Error    | Compile-time | Unknown key in `assembly` table or unknown top-level key                             | WF-Assembly-Keys-Err, WF-TopKeys-Err                                                               |
| `E-PRJ-0201` | Error    | Compile-time | `assembly.kind` is not in `{ "executable", "library" }`                              | WF-Assembly-Kind-Err                                                                               |
| `E-PRJ-0202` | Error    | Compile-time | Duplicate `assembly.name` values                                                     | WF-Assembly-Name-Dup                                                                               |
| `E-PRJ-0203` | Error    | Compile-time | `assembly.name` is not a valid identifier                                            | WF-Assembly-Name-Err                                                                               |
| `E-PRJ-0204` | Error    | Compile-time | `emit_ir` has invalid value or type                                                  | WF-Assembly-EmitIR-Err, WF-Assembly-EmitIRType-Err                                                 |
| `E-PRJ-0205` | Error    | Compile-time | Assembly selection failed (missing target or target not found)                       | Assembly-Select-Err                                                                                |
| `E-PRJ-0301` | Error    | Compile-time | `assembly.root` or `out_dir` has invalid type, is absolute, or resolves outside root | WF-Assembly-Root-Path-Err, WF-Assembly-OutDir-Path-Err, WF-Assembly-OutDirType-Err, WF-RelPath-Err |
| `E-PRJ-0302` | Error    | Compile-time | `assembly.root` does not exist or is not a directory                                 | WF-Source-Root-Err                                                                                 |
| `E-PRJ-0303` | Error    | Compile-time | Relative path derivation failed during deterministic ordering (file or directory)    | FileOrder-Rel-Fail, DirSeq-Rel-Fail                                                                |
| `E-PRJ-0304` | Error    | Compile-time | Path canonicalization or module path derivation failed due to filesystem error       | Disc-Rel-Fail, Resolve-Canonical-Err                                                               |
| `E-PRJ-0305` | Error    | Compile-time | Directory enumeration failed during module discovery                                 | DirSeq-Read-Err                                                                                    |

### 8.2. E-MOD (Module)

| Code         | Severity | Detection    | Condition                                                       | DiagId                                                                                                                                 |
| ------------ | -------- | ------------ | --------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `E-MOD-1104` | Error    | Compile-time | Module path collision after NFC + case folding                  | WF-Module-Path-Collision, Disc-Collision                                                                                               |
| `E-MOD-1105` | Error    | Compile-time | Module path component is a reserved keyword                     | WF-Module-Path-Reserved                                                                                                                |
| `E-MOD-1106` | Error    | Compile-time | Module path component is not a valid identifier                 | WF-Module-Path-Ident-Err                                                                                                               |
| `E-MOD-1204` | Error    | Compile-time | Using path does not resolve to a module or item                 | Resolve-Using-None                                                                                                                     |
| `E-MOD-1205` | Error    | Compile-time | Attempt to `public using` a non-public item                     | Using-Path-Item-Public-Err, Using-List-Public-Err                                                                                      |
| `E-MOD-1206` | Error    | Compile-time | Duplicate item in a `using` list                                | Using-List-Dup                                                                                                                         |
| `E-MOD-1207` | Error    | Compile-time | Cannot access a non-public item from this scope                 | Access-Err                                                                                                                             |
| `E-MOD-1208` | Error    | Compile-time | Using path is ambiguous between module and item                 | Resolve-Using-Ambig                                                                                                                    |
| `E-MOD-1301` | Error    | Compile-time | Unresolved name: identifier not found in any accessible scope   | ResolveExpr-Ident-Err, ResolveQual-Name-Err, ResolveQual-Apply-Err, ResolveQual-Apply-Brace-Err, Expr-Unresolved-Err                   |
| `E-MOD-1302` | Error    | Compile-time | Duplicate declaration in module scope                           | Collect-Dup, Names-Step-Dup                                                                                                            |
| `E-MOD-1303` | Error    | Compile-time | Shadowing without `shadow` keyword                              | Intro-Shadow-Required                                                                                                                  |
| `E-MOD-1304` | Error    | Compile-time | Unresolved module: path prefix did not resolve to a module      | ResolveModulePath-Err                                                                                                                  |
| `E-MOD-1306` | Error    | Compile-time | Unnecessary `shadow` keyword: no binding is being shadowed      | Shadow-Unnecessary                                                                                                                     |
| `E-MOD-1307` | Error    | Compile-time | Ambiguous method resolution; disambiguation required            | LookupMethod-Ambig                                                                                                                     |
| `E-MOD-1401` | Error    | Compile-time | Cyclic module dependency detected in eager initializers         | Topo-Cycle                                                                                                                             |
| `E-MOD-2401` | Error    | Compile-time | Reassignment of immutable `let` binding                         | Assign-Immutable-Err                                                                                                                   |
| `E-MOD-2402` | Error    | Compile-time | Type annotation incompatible with inferred type                 | WF-StaticDecl-Ann-Mismatch, T-LetStmt-Ann-Mismatch, T-VarStmt-Ann-Mismatch, T-ShadowLetStmt-Ann-Mismatch, T-ShadowVarStmt-Ann-Mismatch |
| `E-MOD-2411` | Error    | Compile-time | Missing move expression at call site for transferring parameter | B-ArgPass-Move-Missing                                                                                                                 |
| `E-MOD-2430` | Error    | Compile-time | Multiple `main` procedures defined                              | Main-Multiple                                                                                                                          |
| `E-MOD-2431` | Error    | Compile-time | Invalid `main` signature                                        | Main-Signature-Err                                                                                                                     |
| `E-MOD-2432` | Error    | Compile-time | `main` is generic (has type parameters)                         | Main-Generic-Err                                                                                                                       |
| `E-MOD-2433` | Error    | Compile-time | Module-scope `var` declaration with `public` visibility         | StaticVisOk-Err                                                                                                                        |
| `E-MOD-2434` | Error    | Compile-time | Missing `main` procedure                                        | Main-Missing                                                                                                                           |
| `E-MOD-2440` | Error    | Compile-time | `protected` used on top-level declaration                       | Protected-TopLevel-Err                                                                                                                 |

### 8.3. E-OUT (Output and Linking)

| Code         | Severity | Detection    | Condition                                                                | DiagId                                                                           |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| `E-OUT-0401` | Error    | Compile-time | Failed to create output directory                                        | Out-Dirs-Err                                                                     |
| `E-OUT-0402` | Error    | Compile-time | Failed to emit object file (codegen or write)                            | Out-Obj-Err, EmitObj-Err                                                         |
| `E-OUT-0403` | Error    | Compile-time | Failed to emit IR/bitcode (codegen, assemble, tool resolution, or write) | Out-IR-Err, EmitLLVM-Err                                                         |
| `E-OUT-0404` | Error    | Compile-time | Linker invocation failed                                                 | Out-Link-Fail                                                                    |
| `E-OUT-0405` | Error    | Compile-time | Required linker tool not found                                           | Out-Link-NotFound                                                                |
| `E-OUT-0406` | Error    | Compile-time | Output path collision detected                                           | Out-Obj-Collision, Out-IR-Collision                                              |
| `E-OUT-0407` | Error    | Compile-time | Runtime library missing or unreadable                                    | Out-Link-Runtime-Missing                                                         |
| `E-OUT-0408` | Error    | Compile-time | Runtime library missing required symbol(s)                               | Out-Link-Runtime-Incompatible                                                    |
| `E-OUT-0410` | Error    | Compile-time | LLVM type mapping failed                                                 | LLVMTy-Err                                                                       |
| `E-OUT-0411` | Error    | Compile-time | LLVM IR lowering failed                                                  | LowerIR-Err, LowerIRDecl-Err, LowerIRInstr-Err                                   |
| `E-OUT-0412` | Error    | Compile-time | Binding storage/validity lowering failed                                 | BindSlot-Err, BindValid-Err, UpdateValid-Err, DropOnAssign-Err                   |
| `E-OUT-0413` | Error    | Compile-time | LLVM call ABI lowering failed                                            | LLVMCall-Err, LLVMArgLower-Err, LLVMRetLower-Err                                 |
| `E-OUT-0414` | Error    | Compile-time | VTable emission failed                                                   | EmitVTable-Err                                                                   |
| `E-OUT-0415` | Error    | Compile-time | Literal data emission failed                                             | EmitLiteral-Err                                                                  |
| `E-OUT-0416` | Error    | Compile-time | Runtime built-in symbol resolution failed                                | BuiltinSym-String-Err, BuiltinSym-Bytes-Err, StringDropSym-Err, BytesDropSym-Err |
| `E-OUT-0417` | Error    | Compile-time | Entrypoint or context construction lowering failed                       | EntrySym-Err, EntryStub-Err, EmitInitPlan-Err, EmitDeinitPlan-Err                |
| `E-OUT-0418` | Error    | Compile-time | Poisoning instrumentation failed                                         | PoisonFlag-Err, CheckPoison-Err, SetPoison-Err                                   |

### 8.4. E-SRC (Source)

| Code         | Severity | Detection    | Condition                                                    | DiagId                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------ | ---------------------------------------- |
| `E-SRC-0101` | Error    | Compile-time | Invalid UTF-8 byte sequence                                  | Step-Decode-Err                          |
| `E-SRC-0102` | Error    | Compile-time | Failed to read source file                                   | ReadBytes-Err                            |
| `E-SRC-0103` | Error    | Compile-time | Embedded BOM found after the first position                  | Step-EmbeddedBOM-Err                     |
| `E-SRC-0104` | Error    | Compile-time | Forbidden control character or null byte                     | Step-Prohibited-Err                      |
| `E-SRC-0301` | Error    | Compile-time | Unterminated string literal                                  | Lex-String-Unterminated                  |
| `E-SRC-0302` | Error    | Compile-time | Invalid escape sequence                                      | Lex-String-BadEscape, Lex-Char-BadEscape |
| `E-SRC-0303` | Error    | Compile-time | Invalid character literal                                    | Lex-Char-Invalid, Lex-Char-Unterminated  |
| `E-SRC-0304` | Error    | Compile-time | Malformed numeric literal                                    | Lex-Numeric-Err                          |
| `E-SRC-0306` | Error    | Compile-time | Unterminated block comment                                   | Block-Comment-Unterminated               |
| `E-SRC-0307` | Error    | Compile-time | Invalid Unicode in identifier                                | Lex-Ident-InvalidUnicode                 |
| `E-SRC-0308` | Error    | Compile-time | Lexically sensitive Unicode character outside `unsafe` block | LexSecure-Err                            |
| `E-SRC-0309` | Error    | Compile-time | Tokenization failed to classify a character sequence         | Max-Munch-Err                            |
| `E-SRC-0510` | Error    | Compile-time | Missing statement terminator                                 | Missing-Terminator-Err                   |
| `E-SRC-0520` | Error    | Compile-time | Generic syntax error (unexpected token)                      | Parse-Syntax-Err                         |

### 8.5. E-CNF (Conformance / Limits)

| Code         | Severity | Detection    | Condition                                                                                   | DiagId                                                                                    |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `E-CNF-0401` | Error    | Compile-time | Reserved keyword used as identifier                                                         | Validate-Module-Keyword-Err                                                               |
| `E-CNF-0402` | Error    | Compile-time | Reserved namespace `cursive.*` used by user code                                            | Validate-ModulePath-Reserved-Err, Intro-Reserved-Cursive-Err, Shadow-Reserved-Cursive-Err |
| `E-CNF-0403` | Error    | Compile-time | Primitive type name shadowed at module scope                                                | Validate-Module-Prim-Shadow-Err                                                           |
| `E-CNF-0404` | Error    | Compile-time | Shadowing of `Self`, `Drop`, `Bitcopy`, `Clone`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, or `Context`    | Validate-Module-Special-Shadow-Err                                                        |
| `E-CNF-0405` | Error    | Compile-time | Shadowing of async type alias (`Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`) | Validate-Module-Async-Shadow-Err                                                          |
| `E-CNF-0406` | Error    | Compile-time | User declaration uses `gen_` prefix                                                         | Intro-Reserved-Gen-Err, Shadow-Reserved-Gen-Err                                           |

### 8.6. E-UNS (Unsupported Constructs)

| Code         | Severity | Detection    | Condition                                              | DiagId                   |
| ------------ | -------- | ------------ | ------------------------------------------------------ | ------------------------ |
| `E-UNS-0101` | Error    | Compile-time | Unsupported construct in Cursive0 subset               | Unsupported-Construct    |
| `E-UNS-0102` | Error    | Compile-time | Array index must be a compile-time constant            | Index-Array-NonConst-Err |
| `E-UNS-0103` | Error    | Compile-time | Array index out of bounds                              | Index-Array-OOB-Err      |
| `E-UNS-0104` | Error    | Compile-time | `transmute` source and target alignments differ        | T-Transmute-AlignEq      |
| `E-UNS-0105` | Error    | Compile-time | `override` used with no concrete procedure to override | Override-NoConcrete      |
| `E-UNS-0106` | Error    | Compile-time | Conflicting procedure signatures from multiple classes | EffMethods-Conflict      |
| `E-UNS-0107` | Error    | Compile-time | Non-`Bitcopy` place expression used as value           | ValueUse-NonBitcopyPlace |
| `E-UNS-0108` | Error    | Compile-time | Range expression used as index in Cursive0 subset      | Range-NonIndex-Err       |
| `E-UNS-0110` | Error    | Compile-time | `import` declaration used                              | WF-Import-Unsupported    |
| `E-UNS-0111` | Error    | Compile-time | `[[unwind]]` attribute used                            | WF-Unwind-Unsupported    |
| `E-UNS-0112` | Error    | Compile-time | `extern` block or foreign declaration used             | Parse-Extern-Unsupported |
| `E-UNS-0113` | Error    | Compile-time | Attribute syntax used                                  | WF-Attr-Unsupported      |

### 8.7. E-MEM (Memory)

| Code         | Severity | Detection    | Condition                                                            | DiagId                                                                                   |
| ------------ | -------- | ------------ | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| `E-MEM-1206` | Error    | Compile-time | Named region not found for allocation                                | Alloc-Region-NotFound-Err                                                                |
| `E-MEM-1207` | Error    | Compile-time | `frame` used with no active region in scope                          | Frame-NoActiveRegion-Err                                                                 |
| `E-MEM-1208` | Error    | Compile-time | `r.frame` target is not in `Region@Active` state                     | Frame-Target-NotActive-Err                                                               |
| `E-MEM-3001` | Error    | Compile-time | Read or move of a binding in Moved or PartiallyMoved state           | B-Place-Moved-Err, B-Move-Whole-Moved-Err, B-Move-Field-Moved-Err                        |
| `E-MEM-3003` | Error    | Compile-time | Reassignment of immutable binding                                    | B-Assign-Immutable-Err                                                                   |
| `E-MEM-3004` | Error    | Compile-time | Partial move from binding without `unique` permission                | B-Move-Field-NonUnique-Err                                                               |
| `E-MEM-3005` | Error    | Compile-time | Explicit call to `Drop::drop` method                                 | Drop-Call-Err, Drop-Call-Err-Dyn                                                         |
| `E-MEM-3006` | Error    | Compile-time | Attempt to move from immovable binding (`:=`)                        | B-Move-Whole-Immovable-Err, B-Move-Field-Immovable-Err                                   |
| `E-MEM-3007` | Error    | Compile-time | `unique` binding from place expression requires explicit `move`      | B-LetVar-UniqueNonMove-Err, B-ShadowLet-UniqueNonMove-Err, B-ShadowVar-UniqueNonMove-Err |
| `E-MEM-3020` | Error    | Compile-time | Value with shorter-lived provenance escapes to longer-lived location | Prov-Escape-Err                                                                          |
| `E-MEM-3021` | Error    | Compile-time | Region allocation `^` outside region scope                           | Alloc-Implicit-NoRegion-Err                                                              |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Transmute-Unsafe-Err                                                                     |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | AllocRaw-Unsafe-Err                                                                      |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | DeallocRaw-Unsafe-Err                                                                    |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Region-Unchecked-Unsafe-Err                                                              |

### 8.8. W-MOD (Module Warnings)

| Code         | Severity | Detection    | Condition                                                      |
| ------------ | -------- | ------------ | -------------------------------------------------------------- |
| `W-MOD-1101` | Warning  | Compile-time | Potential module path collision on case-insensitive filesystem |

### 8.9. W-SRC (Source Warnings)

| Code         | Severity | Detection    | Condition                                                   |
| ------------ | -------- | ------------ | ----------------------------------------------------------- |
| `W-SRC-0101` | Warning  | Compile-time | UTF-8 BOM present at the start of the file                  |
| `W-SRC-0301` | Warning  | Compile-time | Leading zeros in decimal literal                            |
| `W-SRC-0308` | Warning  | Compile-time | Lexically sensitive Unicode character within `unsafe` block |

### 8.10. E-TYP (Types)

| Code         | Severity | Detection    | Condition                                                                                              | DiagId                                                                                                                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `E-TYP-1101` | Error    | Compile-time | `shared` permission not supported in Cursive0                                                          | Perm-Shared-Unsupported                                                                                                                  |
| `E-TYP-1505` | Error    | Compile-time | Missing required type annotation at module scope                                                       | WF-StaticDecl-MissingType, WF-ProcedureDecl-MissingReturnType                                                                            |
| `E-TYP-1530` | Error    | Compile-time | Type inference failed; unable to determine type                                                        | T-LetStmt-Infer-Err, T-VarStmt-Infer-Err, T-ShadowLetStmt-Infer-Err, T-ShadowVarStmt-Infer-Err, PtrNull-Infer-Err, NullLiteral-Infer-Err |
| `E-TYP-1506` | Error    | Compile-time | Type alias cycle detected                                                                              | TypeAlias-Recursive-Err                                                                                                                  |
| `E-TYP-1507` | Error    | Compile-time | Procedure with non-unit return type requires explicit return statement                                 | WF-ProcBody-ExplicitReturn-Err                                                                                                           |
| `E-TYP-1601` | Error    | Compile-time | Mutation through `const` path                                                                          | B-Assign-Const-Err                                                                                                                       |
| `E-TYP-1602` | Error    | Compile-time | `unique` exclusion violation (aliasing or inactive use)                                                | B-Place-Unique-Err                                                                                                                       |
| `E-TYP-1603` | Error    | Compile-time | Non-`move` argument must be a place expression                                                         | Call-Arg-NotPlace                                                                                                                        |
| `E-TYP-1605` | Error    | Compile-time | Receiver permission incompatible with caller                                                           | MethodCall-RecvPerm-Err                                                                                                                  |
| `E-TYP-1801` | Error    | Compile-time | Tuple index out of bounds                                                                              | TupleIndex-OOB                                                                                                                           |
| `E-TYP-1802` | Error    | Compile-time | Tuple index is not a compile-time constant integer literal                                             | TupleIndex-NonConst                                                                                                                      |
| `E-TYP-1803` | Error    | Compile-time | Tuple arity mismatch in assignment or pattern                                                          | Pat-Tuple-Arity-Err, Pat-Tuple-R-Arity-Err                                                                                               |
| `E-TYP-1810` | Error    | Compile-time | Array length is not a compile-time constant                                                            | ConstLen-Err                                                                                                                             |
| `E-TYP-1812` | Error    | Compile-time | Array index expression has non-`usize` type                                                            | Index-Array-NonUsize, AddrOf-Index-Array-NonUsize                                                                                        |
| `E-TYP-1820` | Error    | Compile-time | Slice index expression has non-`usize` type                                                            | Index-Slice-NonUsize, AddrOf-Index-Slice-NonUsize                                                                                        |
| `E-TYP-1821` | Error    | Compile-time | Direct slice indexing not permitted in Cursive0 subset                                                 | Index-Slice-Direct-Err                                                                                                                   |
| `E-TYP-1901` | Error    | Compile-time | Duplicate field name in record declaration                                                             | WF-Record-DupField                                                                                                                       |
| `E-TYP-1902` | Error    | Compile-time | Missing field initializer in record literal                                                            | Record-FieldInit-Missing                                                                                                                 |
| `E-TYP-1903` | Error    | Compile-time | Duplicate field initializer in record literal                                                          | Record-FieldInit-Dup                                                                                                                     |
| `E-TYP-1904` | Error    | Compile-time | Access to nonexistent field                                                                            | FieldAccess-Unknown, Record-Field-Unknown                                                                                                |
| `E-TYP-1905` | Error    | Compile-time | Access to field not visible in current scope                                                           | FieldAccess-NotVisible, Record-Field-NotVisible                                                                                          |
| `E-TYP-1906` | Error    | Compile-time | Field visibility exceeds record visibility                                                             | FieldVisOk-Err                                                                                                                           |
| `E-TYP-1907` | Error    | Compile-time | Non-`Bitcopy` field requires move source expression                                                    | Record-Field-NonBitcopy-Move                                                                                                             |
| `E-TYP-1911` | Error    | Compile-time | Default record construction requires default initializer for every field                               | Record-Default-Init-Err                                                                                                                  |
| `E-TYP-1912` | Error    | Compile-time | Explicit receiver type must be `Self` for record methods                                               | Record-Method-RecvSelf-Err                                                                                                               |
| `E-TYP-1920` | Error    | Compile-time | Enum discriminant is not an integer literal                                                            | Enum-Disc-NotInt                                                                                                                         |
| `E-TYP-1921` | Error    | Compile-time | Enum discriminant literal is invalid                                                                   | Enum-Disc-Invalid                                                                                                                        |
| `E-TYP-1922` | Error    | Compile-time | Enum discriminant must be non-negative                                                                 | Enum-Disc-Negative                                                                                                                       |
| `E-TYP-1923` | Error    | Compile-time | Duplicate enum discriminant value                                                                      | Enum-Disc-Dup                                                                                                                            |
| `E-TYP-2050` | Error    | Compile-time | Modal type declares zero states                                                                        | Modal-NoStates-Err                                                                                                                       |
| `E-TYP-2051` | Error    | Compile-time | Duplicate state name within modal type                                                                 | Modal-DupState-Err                                                                                                                       |
| `E-TYP-2052` | Error    | Compile-time | Field access for field not present in current state's payload                                          | Modal-Field-Missing                                                                                                                      |
| `E-TYP-2053` | Error    | Compile-time | Method invocation for method not available in current state                                            | Modal-Method-NotFound                                                                                                                    |
| `E-TYP-2054` | Error    | Compile-time | State name collides with modal type name                                                               | Modal-StateName-Err                                                                                                                      |
| `E-TYP-2055` | Error    | Compile-time | Transition body returns value not matching declared target state                                       | Transition-Body-Err                                                                                                                      |
| `E-TYP-2056` | Error    | Compile-time | Transition invoked on value not of declared source state                                               | Transition-Source-Err                                                                                                                    |
| `E-TYP-2057` | Error    | Compile-time | Direct field access on general modal type without pattern matching                                     | Modal-Field-General-Err                                                                                                                  |
| `E-TYP-2058` | Error    | Compile-time | Duplicate field name in modal state payload                                                            | Modal-Payload-DupField                                                                                                                   |
| `E-TYP-2059` | Error    | Compile-time | Transition target state not declared in modal type                                                     | Transition-Target-Err                                                                                                                    |
| `E-TYP-2060` | Error    | Compile-time | Non-exhaustive match on general modal type                                                             | Match-Modal-NonExhaustive                                                                                                                |
| `E-TYP-2061` | Error    | Compile-time | Duplicate method name in modal state                                                                   | StateMethod-Dup                                                                                                                          |
| `E-TYP-2062` | Error    | Compile-time | Duplicate transition name in modal state                                                               | Transition-Dup                                                                                                                           |
| `E-TYP-2063` | Error    | Compile-time | State member visibility exceeds modal visibility                                                       | StateMemberVisOk-Err                                                                                                                     |
| `E-TYP-2064` | Error    | Compile-time | State member not visible in current scope                                                              | Modal-Field-NotVisible, Transition-NotVisible, Modal-Method-NotVisible                                                                   |
| `E-TYP-2070` | Error    | Compile-time | Implicit widening on non-niche-layout-compatible type                                                  | Chk-Subsumption-Modal-NonNiche                                                                                                           |
| `E-TYP-2071` | Error    | Compile-time | `widen` applied to non-modal type                                                                      | Widen-NonModal                                                                                                                           |
| `E-TYP-2072` | Error    | Compile-time | `widen` applied to already-general modal type                                                          | Widen-AlreadyGeneral                                                                                                                     |
| `E-TYP-2073` | Error    | Compile-time | Record literal whose type is `File@S` or `DirIter@S` for any state `S` in the corresponding modal type | Record-FileDir-Err                                                                                                                       |
| `E-TYP-2101` | Error    | Compile-time | Dereference of pointer in `@Null` state                                                                | Deref-Null                                                                                                                               |
| `E-TYP-2102` | Error    | Compile-time | Dereference of pointer in `@Expired` state                                                             | Deref-Expired                                                                                                                            |
| `E-TYP-2103` | Error    | Compile-time | Dereference of raw pointer outside `unsafe`                                                            | Deref-Raw-Unsafe                                                                                                                         |
| `E-TYP-2104` | Error    | Compile-time | Address-of applied to non-place expression                                                             | AddrOf-NonPlace                                                                                                                          |
| `E-MEM-3031` | Error    | Compile-time | `transmute` source and target sizes differ                                                             | T-Transmute-SizeEq                                                                                                                       |
| `E-TYP-2201` | Error    | Compile-time | Union type has fewer than two member types                                                             | WF-Union-TooFew                                                                                                                          |
| `E-TYP-2202` | Error    | Compile-time | Direct access on union value without pattern matching                                                  | Union-DirectAccess-Err                                                                                                                   |
| `E-TYP-2402` | Error    | Compile-time | Implementing type missing required field                                                               | Impl-Field-Missing                                                                                                                       |
| `E-TYP-2404` | Error    | Compile-time | Implementing field has incompatible type                                                               | Impl-Field-Type-Err                                                                                                                      |
| `E-TYP-2406` | Error    | Compile-time | Conflicting field names from multiple classes                                                          | EffFields-Conflict                                                                                                                       |
| `E-TYP-2408` | Error    | Compile-time | Duplicate abstract field name in class                                                                 | Class-AbstractField-Dup                                                                                                                  |
| `E-TYP-2500` | Error    | Compile-time | Duplicate procedure name in class                                                                      | Class-Method-Dup                                                                                                                         |
| `E-TYP-2501` | Error    | Compile-time | `override` used on abstract procedure implementation                                                   | Override-Abstract-Err                                                                                                                    |
| `E-TYP-2502` | Error    | Compile-time | Missing `override` on concrete procedure replacement                                                   | Override-Missing-Err                                                                                                                     |
| `E-TYP-2503` | Error    | Compile-time | Type does not implement required procedure from class or has incompatible signature                    | Impl-Missing-Method, Impl-Sig-Err, Impl-Sig-Err-Concrete                                                                                 |
| `E-TYP-2505` | Error    | Compile-time | Name conflict among class members                                                                      | Class-Name-Conflict                                                                                                                      |
| `E-TYP-2506` | Error    | Compile-time | Coherence violation: duplicate class implementation                                                    | Impl-Dup, Impl-Duplicate-Class-Err                                                                                                       |
| `E-TYP-2508` | Error    | Compile-time | Cyclic superclass dependency detected                                                                  | Superclass-Cycle                                                                                                                         |
| `E-TYP-2509` | Error    | Compile-time | Superclass bound refers to undefined class                                                             | Superclass-Undefined                                                                                                                     |
| `E-TYP-2541` | Error    | Compile-time | Dynamic class type created from non-dispatchable class                                                 | Dynamic-NonDispatchable                                                                                                                  |
| `E-TYP-2621` | Error    | Compile-time | Type implements both `Bitcopy` and `Drop`                                                              | BitcopyDrop-Conflict                                                                                                                     |
| `E-TYP-2622` | Error    | Compile-time | `Bitcopy` type has non-`Bitcopy` field                                                                 | Bitcopy-Field-NonBitcopy                                                                                                                 |
| `E-TYP-2623` | Error    | Compile-time | Type implementing `Bitcopy` does not implement `Clone`                                                              | Bitcopy-Clone-Missing                                                                                                                    |

### 8.11. W-SYS (System Warnings)

| Code         | Severity | Detection    | Condition                                               |
| ------------ | -------- | ------------ | ------------------------------------------------------- |
| `W-SYS-4010` | Warning  | Compile-time | Modal widening involves large payload copy (>256 bytes) |

### 8.12. E-SEM (Semantics)

| Code         | Severity | Detection    | Condition                                            | DiagId                                            |
| ------------ | -------- | ------------ | ---------------------------------------------------- | ------------------------------------------------- |
| `E-SEM-2524` | Error    | Compile-time | Tuple access on non-tuple                            | TupleAccess-NotTuple                              |
| `E-SEM-2527` | Error    | Compile-time | Indexing applied to non-indexable type               | Index-NonIndexable                                |
| `E-SEM-2531` | Error    | Compile-time | Callee expression is not of FUNCTION type            | Call-Callee-NotFunc                               |
| `E-SEM-2532` | Error    | Compile-time | Argument count mismatch                              | Call-ArgCount-Err                                 |
| `E-SEM-2533` | Error    | Compile-time | Argument type incompatible with parameter type       | Call-ArgType-Err                                  |
| `E-SEM-2534` | Error    | Compile-time | `move` argument required but not provided            | Call-Move-Missing                                 |
| `E-SEM-2535` | Error    | Compile-time | `move` argument provided but parameter is not `move` | Call-Move-Unexpected                              |
| `E-SEM-2536` | Error    | Compile-time | Method not found for receiver type                   | LookupMethod-NotFound, LookupClassMethod-NotFound |
| `E-SEM-2705` | Error    | Compile-time | `match` expression is not exhaustive for union type  | Match-Union-NonExhaustive                         |
| `E-SEM-2711` | Error    | Compile-time | Refutable pattern in irrefutable context (`let`)     | Let-Refutable-Pattern-Err                         |
| `E-SEM-2713` | Error    | Compile-time | Duplicate binding identifier within single pattern   | Pat-Dup-Err, Pat-Dup-R-Err                        |
| `E-SEM-2721` | Error    | Compile-time | Range pattern bounds are not compile-time constants  | RangePattern-NonConst                             |
| `E-SEM-2722` | Error    | Compile-time | Range pattern start exceeds end (empty range)        | RangePattern-Empty                                |
| `E-SEM-2731` | Error    | Compile-time | Record pattern references non-existent field         | RecordPattern-UnknownField                        |
| `E-SEM-3011` | Error    | Compile-time | Method defined outside of type context               | Method-Context-Err                                |
| `E-SEM-3012` | Error    | Compile-time | Duplicate method name in type                        | Record-Method-Dup                                 |
| `E-SEM-3131` | Error    | Compile-time | Assignment target is not a place expression          | Assign-NotPlace                                   |
| `E-SEM-3132` | Error    | Compile-time | Assignment through `const` permission                | Assign-Const-Err                                  |
| `E-SEM-3133` | Error    | Compile-time | Assignment type mismatch                             | Assign-Type-Err                                   |
| `E-SEM-3151` | Error    | Compile-time | Defer block has non-unit type                        | Defer-NonUnit-Err                                 |
| `E-SEM-3152` | Error    | Compile-time | Non-local control flow in defer block                | Defer-NonLocal-Err                                |
| `E-SEM-3161` | Error    | Compile-time | `return` type mismatch with procedure                | Return-Type-Err                                   |
| `E-SEM-3162` | Error    | Compile-time | `break` outside `loop`                               | Break-Outside-Loop                                |
| `E-SEM-3163` | Error    | Compile-time | `continue` outside `loop`                            | Continue-Outside-Loop                             |
| `E-SEM-3164` | Error    | Compile-time | `result` type mismatch with block                    | BlockInfo-Res-Err                                 |
| `E-SEM-3165` | Error    | Compile-time | `return` at module scope                             | Return-At-Module-Err                              |

### 8.13. W-SEM (Semantic Warnings)

| Code         | Severity | Detection    | Condition                               | DiagId                  |
| ------------ | -------- | ------------ | --------------------------------------- | ----------------------- |
| `W-SEM-1001` | Warning  | Compile-time | Unreachable code after result statement | Warn-Result-Unreachable |

## 9. Appendix B - Notation and Glossary

### 9.1. Notation Conventions
$$F(x_1,\ldots,x_n) = F^{(n)}(x_1,\ldots,x_n)$$
$$n \ne m \Rightarrow F^{(n)} \ne F^{(m)}$$

### 9.2. Helper Functions and Relations
$$\text{UnicodeNFC}_{15.0.0}\ \text{and}\ \text{UnicodeCaseFold}_{15.0.0}\ \text{are defined by the Unicode Standard 15.0.0 and are normative for this document}$$
$$\text{LLVMText}_{21}\ \text{and}\ \text{LLVMObj}_{21}\ \text{are defined by LLVM 21 tool acceptance for textual IR and object emission respectively}$$

**HelperRef.**
$$\text{HelperRef}(\text{Fold}) = \texttt{"2.3.2"}$$
$$\text{HelperRef}(\text{DirSeq}) = \texttt{"2.3.3"}$$
$$\text{HelperRef}(\text{Modules}) = \texttt{"2.4"}$$
$$\text{HelperRef}(\text{ModuleList}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{OutputRoot}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{OutputPaths}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{SearchDirs}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{ResolveTool}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{AssembleIR}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{IdKey}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{IdEq}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{CaseFold}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{Span}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{SpanOf}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{ClampSpan}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{AliasExpand}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ModulePrefix}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{Reachable}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsTy}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsRef}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsExpr}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsPat}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefs}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefsArgs}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefsFields}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{Topo}) = \texttt{"7.1"}$$
$$\text{HelperRef}(\text{EntryKey}) = \texttt{"7.7"}$$
$$\text{HelperRef}(\text{PathOrderKey}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{TypeKey}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\prec_{\text{type}}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{Members}) = \texttt{"5.2.7"}$$
$$\text{HelperRef}(\text{MemberList}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{DistinctMembers}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{SingleFieldPayload}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{PayloadState}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{EmptyState}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheSet}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheCount}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheOrder}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheApplies}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{StaticJudgments}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{PremisesHold}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{PermSyntax}) = \texttt{"5.2.2"}$$
$$\text{HelperRef}(\text{Behavior}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{ResourceExhaustion}) = \texttt{"1.3"}$$
$$\text{HelperRef}(\text{OutsideConformance}) = \texttt{"1.3"}$$
$$\text{HelperRef}(\text{SpanRange}) = \texttt{"1.6.1"}$$
$$\text{HelperRef}(\text{SeverityColumn}) = \texttt{"8"}$$
$$\text{HelperRef}(\text{ConditionColumn}) = \texttt{"8"}$$
$$\text{HelperRef}(\text{HasError}) = \texttt{"1.6.3"}$$
$$\text{HelperRef}(\text{CompileStatus}) = \texttt{"1.6.3"}$$
$$\text{HelperRef}(\text{NoDiag}) = \texttt{"1.6.4"}$$
$$\text{HelperRef}(\text{HostPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{FSPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{FilePrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{DirPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{MapsToDiagOrRuntime}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{WinSep}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{AbsPath}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{DriveRooted}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{UNC}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{RootRelative}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{FoldPath}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{FileKey}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{DirKey}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{Basename}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{FileExt}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{Utf8LexLess}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{BMap}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Hex2}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Concat}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Overwrites}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{IsDir}) = \texttt{"2.5"}$$
$$\text{Overwrites}(p,b) \iff \exists fs,\omega,\omega'.\ \text{FSWriteFile}(fs,p,b,\omega) \Downarrow (ok,\omega')$$
$$\text{IsDir}(p) \iff \exists fs,\omega,\omega'.\ \text{FSKind}(fs,p,\omega) \Downarrow (\texttt{Dir},\omega')$$

**Auxiliary String/Sequence Operators.**
$$\text{At}(s,i) = s[i]$$
$$\text{StartsWith}(s,p) \iff s[0..|p|) = p$$
$$\text{EndsWith}(s,p) \iff s[|s|-|p|..|s|) = p$$
$$\text{Remove}(s,c) = [\ s[i]\ \mid\ 0 \le i < |s|\ \land\ s[i] \ne c\ ]$$
$$\text{Concat}([]) = \texttt{"\""}$$
$$\text{Concat}([s]) = s$$
$$\text{Concat}(s::ss) = s \mathbin{+\!\!+} \text{Concat}(ss) \quad (|ss|>0)$$
$$\text{HexDigit}(0)=\texttt{"0"}\ \ldots\ \text{HexDigit}(9)=\texttt{"9"}\ \ldots\ \text{HexDigit}(15)=\texttt{"f"}$$
$$\text{Hex2}(b) = \text{HexDigit}(\lfloor b/16 \rfloor) \mathbin{+\!\!+} \text{HexDigit}(b \bmod 16)$$


**Hex Values.**
$$\text{HexDigitValue}(\texttt{'0'})=0 \quad \text{HexDigitValue}(\texttt{'1'})=1 \quad \text{HexDigitValue}(\texttt{'2'})=2 \quad \text{HexDigitValue}(\texttt{'3'})=3 \quad \text{HexDigitValue}(\texttt{'4'})=4 \quad \text{HexDigitValue}(\texttt{'5'})=5 \quad \text{HexDigitValue}(\texttt{'6'})=6 \quad \text{HexDigitValue}(\texttt{'7'})=7 \quad \text{HexDigitValue}(\texttt{'8'})=8 \quad \text{HexDigitValue}(\texttt{'9'})=9$$
$$\text{HexDigitValue}(\texttt{'a'})=10 \quad \text{HexDigitValue}(\texttt{'b'})=11 \quad \text{HexDigitValue}(\texttt{'c'})=12 \quad \text{HexDigitValue}(\texttt{'d'})=13 \quad \text{HexDigitValue}(\texttt{'e'})=14 \quad \text{HexDigitValue}(\texttt{'f'})=15$$
$$\text{HexDigitValue}(\texttt{'A'})=10 \quad \text{HexDigitValue}(\texttt{'B'})=11 \quad \text{HexDigitValue}(\texttt{'C'})=12 \quad \text{HexDigitValue}(\texttt{'D'})=13 \quad \text{HexDigitValue}(\texttt{'E'})=14 \quad \text{HexDigitValue}(\texttt{'F'})=15$$
$$\text{HexValue}(h_1\ldots h_n) = \sum_{k=1}^{n} \text{HexDigitValue}(h_k) \cdot 16^{n-k}$$
$$\text{DecDigitValue}(\texttt{'0'})=0 \quad \text{DecDigitValue}(\texttt{'1'})=1 \quad \text{DecDigitValue}(\texttt{'2'})=2 \quad \text{DecDigitValue}(\texttt{'3'})=3 \quad \text{DecDigitValue}(\texttt{'4'})=4 \quad \text{DecDigitValue}(\texttt{'5'})=5 \quad \text{DecDigitValue}(\texttt{'6'})=6 \quad \text{DecDigitValue}(\texttt{'7'})=7 \quad \text{DecDigitValue}(\texttt{'8'})=8 \quad \text{DecDigitValue}(\texttt{'9'})=9$$
$$\text{OctDigitValue}(\texttt{'0'})=0 \quad \text{OctDigitValue}(\texttt{'1'})=1 \quad \text{OctDigitValue}(\texttt{'2'})=2 \quad \text{OctDigitValue}(\texttt{'3'})=3 \quad \text{OctDigitValue}(\texttt{'4'})=4 \quad \text{OctDigitValue}(\texttt{'5'})=5 \quad \text{OctDigitValue}(\texttt{'6'})=6 \quad \text{OctDigitValue}(\texttt{'7'})=7$$
$$\text{BinDigitValue}(\texttt{'0'})=0 \quad \text{BinDigitValue}(\texttt{'1'})=1$$
$$\text{DecValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{DecDigitValue}(d_k) \cdot 10^{n-k}$$
$$\text{OctValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{OctDigitValue}(d_k) \cdot 8^{n-k}$$
$$\text{BinValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{BinDigitValue}(d_k) \cdot 2^{n-k}$$

**Rule-Section Map.**
$$\text{SectionId}(r) \in \text{String}$$
$$\text{RulesIn}(\Sigma) = \{ r \mid \text{SectionId}(r) \in \Sigma \}$$

**EmitList.**
$$\text{EmitList}([]) = \text{ok}$$
$$\text{EmitList}([d] \mathbin{+\!\!+} ds) = (\Gamma \vdash \text{Emit}(d)) \land \text{EmitList}(ds)$$

**ArgMax.**
$$\arg\max_{x \in C} g(x) = x^\ast \iff x^\ast \in C \land \forall y \in C.\ g(x^\ast) \ge g(y) \land (\forall z \in C.\ g(z)=g(x^\ast) \Rightarrow z=x^\ast)$$








