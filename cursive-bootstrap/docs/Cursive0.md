# Cursive 0

- [Cursive 0](#cursive-0)
  - [0. Front Matter](#0-front-matter)
    - [0.1. Status and Scope (Bootstrap, Informative)](#01-status-and-scope-bootstrap-informative)
    - [0.2. Deviations from the Root Specification (Cursive0)](#02-deviations-from-the-root-specification-cursive0)
    - [0.3. Bootstrap Milestones and Equivalence](#03-bootstrap-milestones-and-equivalence)
    - [0.4. Document Conventions](#04-document-conventions)
  - [1. Foundations](#1-foundations)
    - [1.1. Conformance](#11-conformance)
    - [1.2. Behavior Types](#12-behavior-types)
    - [1.4. Unsupported Constructs Policy](#14-unsupported-constructs-policy)
    - [1.5. Target and ABI Assumptions](#15-target-and-abi-assumptions)
    - [1.6. Diagnostics Infrastructure](#16-diagnostics-infrastructure)
    - [1.7. Host Primitives](#17-host-primitives)
  - [2. Phase 0: Build/Project Model](#2-phase-0-buildproject-model)
    - [2.1. Project Root and Manifest](#21-project-root-and-manifest)
    - [2.2. Assemblies](#22-assemblies)
    - [2.3. Deterministic Ordering and Case Folding](#23-deterministic-ordering-and-case-folding)
    - [2.4. Module Discovery](#24-module-discovery)
    - [2.5. Output Artifacts and Linking](#25-output-artifacts-and-linking)
    - [2.6. Tool Resolution and IR Assembly Inputs](#26-tool-resolution-and-ir-assembly-inputs)
    - [2.7. Unwind and FFI Surface](#27-unwind-and-ffi-surface)
  - [3. Phase 1: Source Loading, Lexing, Parsing](#3-phase-1-source-loading-lexing-parsing)
    - [3.1. Source Loading and Normalization](#31-source-loading-and-normalization)
    - [3.2. Lexical Analysis](#32-lexical-analysis)
    - [3.3. Grammar, Parsing, and AST Construction](#33-grammar-parsing-and-ast-construction)
    - [3.4. Module Aggregation](#34-module-aggregation)
  - [4. Phase 2: Compile-Time Execution (Deferred in Cursive0)](#4-phase-2-compile-time-execution-deferred-in-cursive0)
  - [5. Phase 3: Name Resolution + Type Checking](#5-phase-3-name-resolution--type-checking)
    - [5.1. Name Resolution and Scopes (Cursive0)](#51-name-resolution-and-scopes-cursive0)
    - [5.2. Type System Core (Cursive0)](#52-type-system-core-cursive0)
    - [5.3. Classes and Record Methods (Cursive0)](#53-classes-and-record-methods-cursive0)
    - [5.4. Modal Types (Definitions)](#54-modal-types-definitions)
    - [5.5. State-Specific Fields](#55-state-specific-fields)
    - [5.6. Transitions and State-Specific Methods](#56-transitions-and-state-specific-methods)
    - [5.7. Modal Widening (`widen`)](#57-modal-widening-widen)
    - [5.8. String and Bytes Types and States](#58-string-and-bytes-types-and-states)
    - [5.9. Capabilities and Context (Cursive0)](#59-capabilities-and-context-cursive0)
    - [5.10. Enum Discriminant Defaults](#510-enum-discriminant-defaults)
    - [5.11. Foundational Classes (Cursive0)](#511-foundational-classes-cursive0)
    - [5.12. Initialization Planning](#512-initialization-planning)
  - [6. Phase 4: Code Generation](#6-phase-4-code-generation)
    - [6.0. Codegen Model and Judgments](#60-codegen-model-and-judgments)
    - [6.1. Layout and Representation](#61-layout-and-representation)
    - [6.2. ABI Lowering (Cursive0)](#62-abi-lowering-cursive0)
    - [6.3. Symbols, Mangling, and Linkage](#63-symbols-mangling-and-linkage)
    - [6.4. Expression Lowering and Evaluation Order](#64-expression-lowering-and-evaluation-order)
    - [6.5. Statement and Block Lowering](#65-statement-and-block-lowering)
    - [6.6. Pattern Matching Lowering](#66-pattern-matching-lowering)
    - [6.7. Globals and Initialization](#67-globals-and-initialization)
    - [6.8. Cleanup, Drop, and Unwinding](#68-cleanup-drop-and-unwinding)
    - [6.9. Built-ins Runtime Interface](#69-built-ins-runtime-interface)
    - [6.10. Dynamic Dispatch](#610-dynamic-dispatch)
    - [6.11. Checks and Panic](#611-checks-and-panic)
    - [6.12. LLVM 21 Backend Requirements](#612-llvm-21-backend-requirements)
  - [7. Dynamic Semantics](#7-dynamic-semantics)
    - [7.1. Initialization Order and Poisoning](#71-initialization-order-and-poisoning)
    - [7.2. Modal Layout (Dynamic Semantics)](#72-modal-layout-dynamic-semantics)
    - [7.3. Modal Pattern Matching](#73-modal-pattern-matching)
    - [7.4. Deterministic Destruction and Unwinding (Cursive0)](#74-deterministic-destruction-and-unwinding-cursive0)
    - [7.5. String Literal Semantics](#75-string-literal-semantics)
    - [7.6. Dynamic Class Objects](#76-dynamic-class-objects)
    - [7.7. FileSystem and File Operations](#77-filesystem-and-file-operations)
  - [8. Appendix A - Diagnostic Codes](#8-appendix-a---diagnostic-codes)
    - [8.0. DiagIdâ€“Code Map](#80-diagidcode-map)
    - [8.1. E-PRJ (Project)](#81-e-prj-project)
    - [8.2. E-MOD (Module)](#82-e-mod-module)
    - [8.3. E-OUT (Output and Linking)](#83-e-out-output-and-linking)
    - [8.4. E-SRC (Source)](#84-e-src-source)
    - [8.5. E-CNF (Conformance / Limits)](#85-e-cnf-conformance--limits)
    - [8.6. E-UNS (Unsupported Constructs)](#86-e-uns-unsupported-constructs)
    - [8.7. E-MEM (Memory)](#87-e-mem-memory)
    - [8.8. W-MOD (Module Warnings)](#88-w-mod-module-warnings)
    - [8.9. W-SRC (Source Warnings)](#89-w-src-source-warnings)
    - [8.10. E-TYP (Types)](#810-e-typ-types)
    - [8.11. W-SYS (System Warnings)](#811-w-sys-system-warnings)
    - [8.12. E-SEM (Semantics)](#812-e-sem-semantics)
    - [8.13. W-SEM (Semantic Warnings)](#813-w-sem-semantic-warnings)
  - [9. Appendix B - Notation and Glossary](#9-appendix-b---notation-and-glossary)
    - [9.1. Notation Conventions](#91-notation-conventions)
    - [9.2. Helper Functions and Relations](#92-helper-functions-and-relations)

## 0. Front Matter

### 0.1. Status and Scope (Bootstrap, Informative)

**Phase.**
$$\text{Phase} = \{\text{Phase0},\ \text{Phase1},\ \text{Phase2},\ \text{Phase3},\ \text{Phase4}\}$$

**PhaseStatus.**
$$\text{PhaseStatus} = \{\text{Implemented},\ \text{Deferred},\ \text{InProgress}\}$$

**PhaseStatusMap.**
$$\text{PhaseStatus}(\text{Phase0}) = \text{Implemented}$$
$$\text{PhaseStatus}(\text{Phase1}) = \text{Implemented}$$
$$\text{PhaseStatus}(\text{Phase2}) = \text{Deferred}$$
$$\text{PhaseStatus}(\text{Phase3}) = \text{InProgress}$$
$$\text{PhaseStatus}(\text{Phase4}) = \text{InProgress}$$

**PhaseSection.**
$$\text{PhaseSection}(\text{Phase0}) = 2$$
$$\text{PhaseSection}(\text{Phase1}) = 3$$
$$\text{PhaseSection}(\text{Phase2}) = 4$$
$$\text{PhaseSection}(\text{Phase3}) = 5$$
$$\text{PhaseSection}(\text{Phase4}) = 6$$

### 0.2. Deviations from the Root Specification (Cursive0)

**DeviationId.**
$$\text{DeviationId} = \{\text{D\_BootstrapEquivalence},\ \text{D\_SourceNormalization},\ \text{D\_ModuleOrdering},\ \text{D\_KeywordReservation},\ \text{D\_GenericTokenization},\ \text{D\_UnsafeSpanClassification},\ \text{D\_GroupingTrailingCommas},\ \text{D\_UnsupportedGrammarFamilies},\ \text{D\_SingleAssemblyVisibility},\ \text{D\_OverloadingScope},\ \text{D\_Permissions},\ \text{D\_ParamPassing},\ \text{D\_PointerAddressOf},\ \text{D\_RegionOptionsSyntax},\ \text{D\_TypeInference},\ \text{D\_RecordUpdate},\ \text{D\_RangeExpressions},\ \text{D\_RangePatterns},\ \text{D\_FieldVisibilityDefault},\ \text{D\_EnumDiscriminantControls},\ \text{D\_UnionLayout},\ \text{D\_LayoutAttributes},\ \text{D\_CallingConventionToolchain},\ \text{D\_SymbolVisibilityMechanism},\ \text{D\_FileSystemSemantics}\}$$

- `System` in Cursive0 omits `time()` and `get_env` returns `string | ()`; this is a bootstrap restriction.

**DeviationRef.**
$$\text{DeviationRef}(\text{D\_BootstrapEquivalence}) = \{\texttt{"0.3.2"}\}$$
$$\text{DeviationRef}(\text{D\_SourceNormalization}) = \{\texttt{"3.1.1"}\}$$
$$\text{DeviationRef}(\text{D\_ModuleOrdering}) = \{\texttt{"2.3.1"},\ \texttt{"2.3.2"},\ \texttt{"2.3.3"}\}$$
$$\text{DeviationRef}(\text{D\_KeywordReservation}) = \{\texttt{"3.2.3"}\}$$
$$\text{DeviationRef}(\text{D\_GenericTokenization}) = \{\texttt{"3.2.9"}\}$$
$$\text{DeviationRef}(\text{D\_UnsafeSpanClassification}) = \{\texttt{"3.2.12"}\}$$
$$\text{DeviationRef}(\text{D\_GroupingTrailingCommas}) = \{\texttt{"3.3.4"}\}$$
$$\text{DeviationRef}(\text{D\_UnsupportedGrammarFamilies}) = \{\texttt{"3.3.2.7"}\}$$
$$\text{DeviationRef}(\text{D\_SingleAssemblyVisibility}) = \{\texttt{"5.1.4"}\}$$
$$\text{DeviationRef}(\text{D\_OverloadingScope}) = \{\texttt{"5.1.5"},\ \texttt{"5.3"}\}$$
$$\text{DeviationRef}(\text{D\_Permissions}) = \{\texttt{"1.1.1"},\ \texttt{"5.2.2"}\}$$
$$\text{DeviationRef}(\text{D\_ParamPassing}) = \{\texttt{"5.2.4"},\ \texttt{"5.3.2"},\ \texttt{"5.2.15"}\}$$
$$\text{DeviationRef}(\text{D\_PointerAddressOf}) = \{\texttt{"1.1.1"},\ \texttt{"5.2.12"},\ \texttt{"5.2.16"}\}$$
$$\text{DeviationRef}(\text{D\_RegionOptionsSyntax}) = \{\texttt{"3.3.4"},\ \texttt{"5.2.17"}\}$$
$$\text{DeviationRef}(\text{D\_TypeInference}) = \{\texttt{"5.2.9"}\}$$
$$\text{DeviationRef}(\text{D\_RecordUpdate}) = \{\texttt{"3.3.4"}\}$$
$$\text{DeviationRef}(\text{D\_RangeExpressions}) = \{\texttt{"5.2.12"}\}$$
$$\text{DeviationRef}(\text{D\_RangePatterns}) = \{\texttt{"5.2.13"}\}$$
$$\text{DeviationRef}(\text{D\_FieldVisibilityDefault}) = \{\texttt{"5.2.2"},\ \texttt{"5.3.2"}\}$$
$$\text{DeviationRef}(\text{D\_EnumDiscriminantControls}) = \{\texttt{"5.10"},\ \texttt{"6.1.4"}\}$$
$$\text{DeviationRef}(\text{D\_UnionLayout}) = \{\texttt{"6.1.4"},\ \texttt{"6.1.4.1"}\}$$
$$\text{DeviationRef}(\text{D\_LayoutAttributes}) = \{\texttt{"6.1.3"}\}$$
$$\text{DeviationRef}(\text{D\_CallingConventionToolchain}) = \{\texttt{"6.2.1"},\ \texttt{"6.2.3"}\}$$
$$\text{DeviationRef}(\text{D\_SymbolVisibilityMechanism}) = \{\texttt{"6.3.4"}\}$$
$$\text{DeviationRef}(\text{D\_FileSystemSemantics}) = \{\texttt{"7.7"}\}$$

### 0.3. Bootstrap Milestones and Equivalence

#### 0.3.1. Bootstrap Milestones and Invariants

**BootstrapCompiler.**
$$\text{BootstrapCompiler} = \{\text{cursivec0},\ \text{cursivec1},\ \text{cursivec2}\}$$

**BootstrapName.**
$$\text{BootstrapName}(\text{cursivec0}) = \texttt{"cursivec0"}$$
$$\text{BootstrapName}(\text{cursivec1}) = \texttt{"cursivec1"}$$
$$\text{BootstrapName}(\text{cursivec2}) = \texttt{"cursivec2"}$$

**BootstrapImpl.**
$$\text{BootstrapImpl}(\text{cursivec0}) = \{\texttt{"C++"},\ \texttt{"LLVM"}\}$$
$$\text{BootstrapImpl}(\text{cursivec1}) = \{\texttt{"Cursive"}\}$$
$$\text{BootstrapImpl}(\text{cursivec2}) = \{\texttt{"Cursive"}\}$$

**CompilerSourceProject.**
$$\text{CompilerSource} \in \text{Project}$$

**ProducesCompiler.**
$$\text{ProducesCompiler} : \text{BootstrapCompiler} \times \text{Project} \rightharpoonup \text{BootstrapCompiler}$$

**Milestone Invariants.**
$$\text{M0} \iff \text{Status}(\text{cursivec0},\ \text{CompilerSource}) = \text{ok} \land \text{Subset}(\text{CompilerSource}, S0)$$
$$\text{M1} \iff \text{Status}(\text{cursivec1},\ \text{CompilerSource}) = \text{ok} \land \text{ProducesCompiler}(\text{cursivec1},\ \text{CompilerSource}) = \text{cursivec2}$$
$$\text{M2} \iff \forall P \in \text{Project}.\ \text{BootstrapEq}(\text{cursivec1},\ \text{cursivec2},\ P)$$

#### 0.3.2. Observable Behavior Equivalence for Bootstrap

**Compiler Observable Behavior.**

$$\text{Under}(p,O) \iff \text{prefix}(\text{Normalize}(p),\ \text{Normalize}(O))$$
$$\text{IsFile}(p) \iff \text{FSKind}(p) = \text{File}$$

$$\text{DiagObs}(d) = \langle d.\text{code},\ d.\text{severity},\ d.\text{message},\ d.\text{span} \rangle$$
$$\text{DiagStream}(C,P) = [\text{DiagObs}(d_1),\ \ldots,\ \text{DiagObs}(d_k)]$$
$$\text{Status}(C,P) = \text{ok} \iff \forall d \in \text{DiagStream}(C,P).\ d.\text{severity} \ne \text{Error}$$
$$\text{Status}(C,P) = \text{fail} \iff \exists d \in \text{DiagStream}(C,P).\ d.\text{severity} = \text{Error}$$
$$\text{ExitCode}(C,P) = 0 \iff \text{Status}(C,P) = \text{ok}$$
$$\text{ExitCode}(C,P) = 1 \iff \text{Status}(C,P) = \text{fail}$$
$$\text{Executable}(P) \iff P.\text{assembly.kind} = \texttt{executable}$$
$$\text{IRSet}(P) = \{\text{IRPath}(P,m,e) \mid m \in \text{ModuleList}(P)\} \ \text{if}\ P.\text{assembly.emit\_ir} = e \in \{\texttt{"ll"},\ \texttt{"bc"}\}$$
$$\text{IRSet}(P) = \emptyset \ \text{if}\ P.\text{assembly.emit\_ir} \notin \{\texttt{"ll"},\ \texttt{"bc"}\}$$
$$\text{ExeSet}(P) = \begin{cases}
\{\text{ExePath}(P)\} & \text{if }\text{Executable}(P)\\
\emptyset & \text{otherwise}
\end{cases}$$
$$\text{RequiredOutputs}(P) = \{\text{ObjPath}(P,m) \mid m \in \text{ModuleList}(P)\} \cup \text{IRSet}(P) \cup \text{ExeSet}(P)$$
$$\text{Artifacts}(C,P) = \text{RequiredOutputs}(P) \iff \text{Status}(C,P) = \text{ok}$$
$$\text{Artifacts}(C,P) = \emptyset \iff \text{Status}(C,P) = \text{fail}$$

$$\text{ObsComp}(C,P) = \langle \text{Status}(C,P),\ \text{ExitCode}(C,P),\ \text{DiagStream}(C,P),\ \text{Artifacts}(C,P) \rangle$$

**Bootstrap Equivalence.**
$$\text{BootstrapEq}(C_a, C_b, P) \iff \text{ObsComp}(C_a,P) = \text{ObsComp}(C_b,P) \land (\text{Status}(C_a,P)=\text{ok} \Rightarrow \text{Artifacts}(C_a,P)=\text{RequiredOutputs}(P))$$

### 0.4. Document Conventions

**NormativeKeywords.**
$$\text{NormativeKeywords} = \{\texttt{MUST}, \texttt{MUST NOT}, \texttt{SHOULD}, \texttt{SHOULD NOT}, \texttt{MAY}\}$$

**DocScope.**
$$\text{DocScope} = \{\text{ConformanceTarget}, \text{SupportedSubset}, \text{RequiredBehavior}(\texttt{cursivec0})\}$$

**DiagnosticCodeFormat.**
$$\text{DiagPrefix} = \{E,\ W,\ I\}$$
$$\text{DiagCategory} = [A\text{-}Z]^{3}$$
$$\text{DiagDigits} = [0\text{-}9]^{4}$$
$$\text{DiagCode} = \text{DiagPrefix} \mathbin{+\!\!+} \texttt{"-"} \mathbin{+\!\!+} \text{DiagCategory} \mathbin{+\!\!+} \texttt{"-"} \mathbin{+\!\!+} \text{DiagDigits}$$
$$\text{Bucket}(\text{Digits}) = \text{Digits}[0..1]$$
$$\text{Seq}(\text{Digits}) = \text{Digits}[2..3]$$

## 1. Foundations

### 1.1. Conformance

**C0Conforming.**
$$\text{C0Conforming}(P) \iff \text{WF}(P) \land \text{Subset}(P,S0)$$

**WF.**
$$\text{WF}(P) \iff \exists \Gamma.\ \text{Project}(\Gamma)=P \land \forall j \in \text{ReqJudgments}(P).\ \Gamma \vdash j \Downarrow ok$$

**ReqJudgments.**
$$\text{ReqJudgments}(P) = [\text{Phase1Order}(P),\ \text{Phase3Order}(P),\ \text{Phase4Order}(P)]$$

**Phase1Order.**
$$\Gamma \vdash \text{Phase1Order}(P) \Downarrow ok \iff \exists Ms.\ \Gamma \vdash \text{ParseModules}(P) \Downarrow Ms$$

**Phase4Order.**
$$\Gamma \vdash \text{Phase4Order}(P) \Downarrow ok \iff \exists \text{Objs},\ \text{IRs},\ \text{Exe}.\ \Gamma \vdash \text{OutputPipeline}(P) \Downarrow (\text{Objs},\ \text{IRs},\ \text{Exe})$$

**Constructs.**
$$\text{TypeNodes}(P,m) = \{ t \mid t \in \text{Type} \land \text{Subnode}(\text{ASTModule}(P,m), t) \}$$
$$\text{StmtNodes}(P,m) = \{ s \mid s \in \text{Stmt} \land \text{Subnode}(\text{ASTModule}(P,m), s) \}$$

$$\text{ItemKind}(\text{UsingDecl}(\_)) = \texttt{using\_decl}$$
$$\text{ItemKind}(\text{ProcedureDecl}(\_,\_,\_,\_,\_,\_,\_)) = \texttt{procedure}$$
$$\text{ItemKind}(\text{RecordDecl}(\_,\_,\_,\_,\_,\_)) = \texttt{record}$$
$$\text{ItemKind}(\text{EnumDecl}(\_,\_,\_,\_,\_,\_)) = \texttt{enum}$$
$$\text{ItemKind}(\text{ModalDecl}(\_,\_,\_,\_,\_,\_)) = \texttt{modal}$$
$$\text{ItemKind}(\text{ClassDecl}(\_,\_,\_,\_,\_)) = \texttt{class}$$
$$\text{ItemKind}(\text{TypeAliasDecl}(\_,\_,\_,\_,\_)) = \texttt{type\_alias}$$
$$\text{ItemKind}(\text{StaticDecl}(\_,\_,\_,\_,\_)) = \texttt{static\_decl}$$
$$\text{ItemKind}(\_) = \bot$$

$$\text{TopDeclConstructs}(P) = \{ \text{ItemKind}(it) \mid m \in P.\text{modules} \land it \in \text{ASTModule}(P,m).\text{items} \land \text{ItemKind}(it) \ne \bot \}$$

$$\text{TypeCtor}(\text{TypePerm}(\_, base)) = \text{TypeCtor}(base)$$
$$\text{TypeCtor}(\text{TypePrim}(name)) = \{name\}$$
$$\text{TypeCtor}(\text{TypeTuple}(elems)) = \{\texttt{tuple}\} \cup \bigcup_{t \in elems} \text{TypeCtor}(t)$$
$$\text{TypeCtor}(\text{TypeArray}(elem, \_)) = \{\texttt{array}\} \cup \text{TypeCtor}(elem)$$
$$\text{TypeCtor}(\text{TypeSlice}(elem)) = \{\texttt{slice}\} \cup \text{TypeCtor}(elem)$$
$$\text{TypeCtor}(\text{TypeUnion}(members)) = \{\texttt{union}\} \cup \bigcup_{t \in members} \text{TypeCtor}(t)$$
$$\text{TypeCtor}(\text{TypeFunc}(params, ret)) = \{\texttt{function}\} \cup \bigcup_{\langle \_, t \rangle \in params} \text{TypeCtor}(t) \cup \text{TypeCtor}(ret)$$
$$\text{TypeCtor}(\text{TypePtr}(elem, \_)) = \{\texttt{ptr}\} \cup \text{TypeCtor}(elem)$$
$$\text{TypeCtor}(\text{TypeRawPtr}(\_, elem)) = \{\texttt{rawptr}\} \cup \text{TypeCtor}(elem)$$
$$\text{TypeCtor}(\text{TypeString}(\_)) = \{\texttt{string}\}$$
$$\text{TypeCtor}(\text{TypeBytes}(\_)) = \{\texttt{bytes}\}$$
$$\text{TypeCtor}(\text{TypeDynamic}(\_)) = \{\texttt{dyn\_class}\}$$
$$\text{TypeCtor}(\text{TypeModalState}(\_,\_)) = \{\texttt{modal}\}$$
$$\text{TypeCtor}(\text{TypePath}([\texttt{"Region"}])) = \{\texttt{region}\}$$
$$\text{TypeCtor}(\text{TypePath}([\texttt{"RegionOptions"}])) = \{\texttt{region\_options}\}$$
$$\text{TypeCtor}(\text{TypePath}(p)) = \{\texttt{record}\} \ \text{if } \text{RecordDecl}(p)\ \text{defined}$$
$$\text{TypeCtor}(\text{TypePath}(p)) = \{\texttt{enum}\} \ \text{if } \text{EnumDecl}(p)\ \text{defined}$$
$$\text{TypeCtor}(\_) = \emptyset$$

$$\text{TypeConstructs}(P) = \bigcup_{m \in P.\text{modules}} \bigcup_{t \in \text{TypeNodes}(P,m)} \text{TypeCtor}(t)$$

$$\text{PermOfType}(\text{TypePerm}(p,\_)) = \{p\}$$
$$\text{PermOfType}(\_) = \emptyset$$
$$\text{RecvPerms}(members) = \{ p \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land recv = \text{ReceiverShorthand}(p) \}$$
$$\text{ClassRecvPerms}(items) = \{ p \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land recv = \text{ReceiverShorthand}(p) \}$$
$$\text{PermConstructs}(P) = \bigcup_{m \in P.\text{modules}} \bigcup_{t \in \text{TypeNodes}(P,m)} \text{PermOfType}(t) \cup \bigcup_{m \in P.\text{modules}} \bigcup_{\text{RecordDecl}(\_,\_,\_,members,\_,\_) \in \text{ASTModule}(P,m).\text{items}} \text{RecvPerms}(members) \cup \bigcup_{m \in P.\text{modules}} \bigcup_{\text{ClassDecl}(\_,\_,\_,items,\_) \in \text{ASTModule}(P,m).\text{items}} \text{ClassRecvPerms}(items)$$

$$\text{ExprKind}(\text{Literal}(\_)) = \texttt{literal}$$
$$\text{ExprKind}(\text{Identifier}(\_)) = \texttt{identifier}$$
$$\text{ExprKind}(\text{FieldAccess}(\_,\_)) = \texttt{field\_access}$$
$$\text{ExprKind}(\text{TupleAccess}(\_,\_)) = \texttt{tuple\_index}$$
$$\text{ExprKind}(\text{IndexAccess}(\_,\_)) = \texttt{index}$$
$$\text{ExprKind}(\text{IfExpr}(\_,\_,\_)) = \texttt{if}$$
$$\text{ExprKind}(\text{MatchExpr}(\_,\_)) = \texttt{match}$$
$$\text{ExprKind}(\text{LoopInfinite}(\_)) = \texttt{loop}$$
$$\text{ExprKind}(\text{LoopConditional}(\_,\_)) = \texttt{loop}$$
$$\text{ExprKind}(\text{LoopIter}(\_,\_,\_,\_)) = \texttt{loop}$$
$$\text{ExprKind}(\text{MoveExpr}(\_)) = \texttt{move}$$
$$\text{ExprKind}(\text{Unary}(\texttt{"widen"},\_)) = \texttt{widen}$$
$$\text{ExprKind}(\text{TransmuteExpr}(\_,\_,\_)) = \texttt{transmute}$$
$$\text{ExprKind}(\text{UnsafeBlockExpr}(\_)) = \texttt{unsafe}$$
$$\text{ExprKind}(\text{AllocExpr}(\_,\_)) = \texttt{region\_alloc}$$
$$\text{ExprKind}(\text{MethodCall}(\_,\_,\_)) = \texttt{method\_call}$$
$$\text{ExprKind}(\text{Propagate}(\_)) = \texttt{union\_propagate}$$
$$\text{ExprKind}(\_) = \bot$$

$$\text{StmtKind}(\text{LetStmt}(\_)) = \texttt{let}$$
$$\text{StmtKind}(\text{VarStmt}(\_)) = \texttt{var}$$
$$\text{StmtKind}(\text{ShadowLetStmt}(\_,\_,\_)) = \texttt{shadow}$$
$$\text{StmtKind}(\text{ShadowVarStmt}(\_,\_,\_)) = \texttt{shadow}$$
$$\text{StmtKind}(\text{AssignStmt}(\_,\_)) = \texttt{assign}$$
$$\text{StmtKind}(\text{CompoundAssignStmt}(\_,\_,\_)) = \texttt{compound\_assign}$$
$$\text{StmtKind}(\text{DeferStmt}(\_)) = \texttt{defer}$$
$$\text{StmtKind}(\text{RegionStmt}(\_,\_,\_)) = \texttt{region}$$
$$\text{StmtKind}(\text{FrameStmt}(\_,\_)) = \texttt{frame}$$
$$\text{StmtKind}(\text{ReturnStmt}(\_)) = \texttt{return}$$
$$\text{StmtKind}(\text{ResultStmt}(\_)) = \texttt{result}$$
$$\text{StmtKind}(\text{BreakStmt}(\_)) = \texttt{break}$$
$$\text{StmtKind}(\text{ContinueStmt}) = \texttt{continue}$$
$$\text{StmtKind}(\text{UnsafeBlockStmt}(\_)) = \texttt{unsafe}$$
$$\text{StmtKind}(\_) = \bot$$

$$\text{ExprStmtConstructs}(P) = \{ \text{ExprKind}(e) \mid m \in P.\text{modules} \land e \in \text{ExprNodes}(P,m) \land \text{ExprKind}(e) \ne \bot \} \cup \{ \text{StmtKind}(s) \mid m \in P.\text{modules} \land s \in \text{StmtNodes}(P,m) \land \text{StmtKind}(s) \ne \bot \}$$

$$\text{CapConstructs}(P) = \{ c \mid c \in \{\texttt{Context},\ \texttt{FileSystem},\ \texttt{HeapAllocator}\} \land \exists m,t.\ m \in P.\text{modules} \land t \in \text{TypeNodes}(P,m) \land t = \text{TypePath}([c]) \}$$

$$\text{Constructs}(P) = \text{TopDeclConstructs}(P) \cup \text{TypeConstructs}(P) \cup \text{PermConstructs}(P) \cup \text{ExprStmtConstructs}(P) \cup \text{CapConstructs}(P)$$

**Subset.**
$$\text{Subset}(P,S0) \iff \text{Constructs}(P) \subseteq S0$$

**(Reject-IllFormed)**
$$\frac{\neg \text{C0Conforming}(P)}{\Gamma \vdash \text{Reject}(P)}$$

**TranslationPhases.**

$$\text{TranslationPhases} = [\text{Phase1},\ \text{Phase2},\ \text{Phase3},\ \text{Phase4}]$$

#### 1.1.1. Cursive0 Subset (S0)

$$S0 = S_{\text{Lex}} \cup S_{\text{Modules}} \cup S_{\text{TopDecl}} \cup S_{\text{Types}} \cup S_{\text{Perms}} \cup S_{\text{ExprStmt}} \cup S_{\text{Caps}}$$

**S_Lex.**
$$S_{\text{Lex}} = \text{RulesIn}(\{\texttt{"3.1"},\ \texttt{"3.2"},\ \texttt{"3.3"}\})$$

**S_Modules.**
$$S_{\text{Modules}} = \text{RulesIn}(\{\texttt{"2"},\ \texttt{"3.3.6.3"},\ \texttt{"5.1"}\})$$

**S_TopDecl.**
$$S_{\text{TopDecl}} = \{\texttt{using\_decl},\ \texttt{procedure},\ \texttt{record},\ \texttt{enum},\ \texttt{modal},\ \texttt{class},\ \texttt{type\_alias},\ \texttt{static\_decl}\}$$

**S_Types.**
$$\text{PrimTypes}_{C0} = \text{IntTypes} \cup \text{FloatTypes} \cup \{\texttt{bool},\ \texttt{char},\ \texttt{()},\ \texttt{!}\}$$
$$\text{TypeCtors}_{C0} = \{\texttt{tuple},\ \texttt{array},\ \texttt{slice},\ \texttt{record},\ \texttt{enum},\ \texttt{union},\ \texttt{function},\ \texttt{ptr},\ \texttt{rawptr},\ \texttt{string},\ \texttt{bytes},\ \texttt{region\_options},\ \texttt{region},\ \texttt{dyn\_class}\}$$
$$S_{\text{Types}} = \text{PrimTypes}_{C0} \cup \text{TypeCtors}_{C0}$$

**S_Perms.**
$$S_{\text{Perms}} = \text{PermSet}_{C0}$$

**S_ExprStmt.**
$$S_{\text{ExprStmt}} = \{\texttt{literal},\ \texttt{identifier},\ \texttt{field\_access},\ \texttt{tuple\_index},\ \texttt{index},\ \texttt{if},\ \texttt{loop},\ \texttt{match},\ \texttt{break},\ \texttt{continue},\ \texttt{return},\ \texttt{result},\ \texttt{defer},\ \texttt{region},\ \texttt{frame},\ \texttt{union\_propagate},\ \texttt{let},\ \texttt{var},\ \texttt{shadow},\ \texttt{assign},\ \texttt{compound\_assign},\ \texttt{move},\ \texttt{widen},\ \texttt{transmute},\ \texttt{unsafe},\ \texttt{region\_alloc},\ \texttt{method\_call}\}$$

**S_Caps.**
$$S_{\text{Caps}} = \{\texttt{Context},\ \texttt{FileSystem},\ \texttt{HeapAllocator}\}$$
  
**PermSet (Cursive0).**
$$\text{PermSet}_{C0} = \{\texttt{const}, \texttt{unique}\}$$

**(Perm-Shared-Unsupported)**
$$\frac{\text{PermSyntax} \in \{\texttt{shared},\ \texttt{~%}\} \quad c = \text{Code}(\text{Perm-Shared-Unsupported})}{\Gamma \vdash \text{Emit}(c)}$$

**Subset Lexeme Basis.**
Let $S$ be a source file and let $K$ satisfy $\Gamma \vdash \text{Tokenize}(S) \Downarrow (K,\ \_)$.
Any use of $\text{PermSyntax}$ or $\text{UnsupportedForm}$ MUST be based on token lexemes in $K$ (and, where specified elsewhere, the AST produced by $\text{ParseFile}(S)$); implementations MUST NOT match substrings inside identifiers.
See Â§3.2.2 and Â§3.2.7.

$$\text{S0Unsupported} = \{\texttt{derive},\ \texttt{extern},\ \texttt{attribute},\ \texttt{import},\ \texttt{opaque\_type},\ \texttt{refinement\_type},\ \texttt{closure},\ \texttt{pipeline},\ \texttt{async},\ \texttt{parallel},\ \texttt{dispatch},\ \texttt{spawn},\ \texttt{metaprogramming},\ \texttt{Network},\ \texttt{Reactor},\ \texttt{GPUFactory},\ \texttt{CPUFactory},\ \texttt{AsyncRuntime}\}$$

### 1.2. Behavior Types

**BehaviorClass.**
$$\text{BehaviorClass} = \{\text{Specified}, \text{UVB}\}$$

$$\text{UVBRel} = \{\text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma),\ \text{WritePtrSigma}(\text{RawPtr}(q, addr), v, \sigma)\}$$

**IllFormed.**
$$\text{StaticJudgSet} = \text{WFModulePathJudg} \cup \text{LinkJudg} \cup \text{ParseJudgment} \cup \text{ResolvePathJudg} \cup \text{ResolveExprListJudg} \cup \text{ResolveEnumPayloadJudg} \cup \text{ResolveCalleeJudg} \cup \text{ResolveArmJudg} \cup \text{ResolveStmtSeqJudg} \cup \text{TypeEqJudg} \cup \text{ConstLenJudg} \cup \text{SubtypingJudg} \cup \text{PermSubJudg} \cup \text{ArgsOkTJudg} \cup \text{TypeInfJudg} \cup \text{StmtJudg} \cup \text{PatJudg} \cup \text{ExprJudg} \cup \text{MatchJudg} \cup \text{DeclJudg} \cup \text{BJudgment} \cup \text{ArgPassJudg} \cup \text{ProvPlaceJudg} \cup \text{ProvExprJudg} \cup \text{ProvStmtJudg} \cup \text{BlockProvJudg} \cup \text{ArgsOkJudg} \cup \text{TypeWFJudg} \cup \text{StringBytesJudg} \cup \text{BitcopyDropJudg} \cup \text{TypeRefsJudg} \cup \text{ValueRefsJudg} \cup \text{CodegenJudg} \cup \text{LayoutJudg} \cup \text{EncodeConstJudg} \cup \text{ValidValueJudg} \cup \text{RecordLayoutJudg} \cup \text{UnionLayoutJudg} \cup \text{TupleLayoutJudg} \cup \text{RangeLayoutJudg} \cup \text{EnumLayoutJudg} \cup \text{ModalLayoutJudg} \cup \text{DynLayoutJudg} \cup \text{ABITyJudg} \cup \text{ABIParamJudg} \cup \text{ABIRetJudg} \cup \text{ABICallJudg} \cup \text{LowerCallJudg} \cup \text{MangleJudg} \cup \text{LinkageJudg} \cup \text{EvalOrderJudg} \cup \text{LowerExprJudg} \cup \text{LowerStmtJudg} \cup \text{PatternLowerJudg} \cup \text{LowerBindJudg} \cup \text{GlobalsJudg} \cup \text{ConstInitJudg} \cup \text{CleanupJudg} \cup \text{RuntimeIfcJudg} \cup \text{DynDispatchJudg} \cup \text{ChecksJudg} \cup \text{LLVMAttrJudg} \cup \text{RuntimeDeclJudg} \cup \text{LLVMTyJudg} \cup \text{LLVMEmitJudg} \cup \text{LowerIRJudg} \cup \text{BindStorageJudg} \cup \text{LLVMCallJudg} \cup \text{VTableJudg} \cup \text{LiteralEmitJudg} \cup \text{BuiltinSymJudg} \cup \text{DropHookJudg} \cup \text{EntryJudg} \cup \text{PoisonJudg}$$
$$\text{StaticRuleSet} = \{ r \mid \text{Conclusion}(r) \in \text{StaticJudgSet} \}$$
$$\text{Conclusion}(r) = J \quad (r\ \text{is written}\ \frac{\pi_1\ \ldots\ \pi_k}{J})$$
$$\text{Premises}(r) = [\pi_1,\ldots,\pi_k] \quad (r\ \text{is written}\ \frac{\pi_1\ \ldots\ \pi_k}{\_})$$
$$\text{Subject}(\Gamma \vdash j) = j_0\ \text{where } j_0\ \text{is the leftmost term to the right of }\vdash$$
$$\text{EnvOf}(\Gamma \vdash j) = \Gamma$$
$$\theta\ \text{ranges over substitutions of metavariables in }r$$
$$\text{Applies}(r,x) \iff \exists \theta.\ \text{Subject}(\text{Conclusion}(r)[\theta]) = x$$
$$\text{PremisesHold}(r, x) \iff \exists \theta.\ \text{Subject}(\text{Conclusion}(r)[\theta]) = x \land \Gamma_r = \text{EnvOf}(\text{Conclusion}(r)[\theta]) \land \forall \pi \in \text{Premises}(r)[\theta].\ \pi \ne \bot \land (\pi\ \text{is a judgment} \Rightarrow \Gamma_r \vdash \pi)$$
$$\text{IllFormed}(x) \iff \exists r \in \text{StaticRuleSet}.\ \text{Applies}(r,x) \land \neg \text{PremisesHold}(r,x)$$

**Undefinedness Policy.**
$$\text{StaticUndefined}(J) \iff \exists r.\ \text{Conclusion}(r)=J \land \exists \pi \in \text{Premises}(r).\ \pi = \bot$$
$$\text{DynamicUndefined}(R) \iff R \in \text{UVBRel} \land R\ \text{undefined}$$
$$\text{Behavior}(R) = \text{Specified} \iff \neg \text{DynamicUndefined}(R)$$
$$\text{Behavior}(R) = \text{UVB} \iff \text{DynamicUndefined}(R)$$

$$\text{RuleId}(r) = id \iff r\ \text{is labeled}\ \textbf{(}id\textbf{)}$$
$$\text{DiagIdOf}(J) = id \iff \exists r.\ \text{Conclusion}(r)=J \land \text{RuleId}(r)=id$$
$$\text{DiagIdOf}(J) = \bot \iff \neg \exists r.\ \text{Conclusion}(r)=J \land \text{RuleId}(r)\ \text{defined}$$

**(Static-Undefined)**
$$\frac{\text{StaticUndefined}(J) \quad \text{Code}(\text{DiagIdOf}(J)) = c}{\Gamma \vdash J \Uparrow c}$$

**(Static-Undefined-NoCode)**
$$\frac{\text{StaticUndefined}(J) \quad \text{Code}(\text{DiagIdOf}(J)) = \bot}{\Gamma \vdash J \Uparrow}$$

**(Dynamic-Undefined-UVB)**
$$\frac{\text{DynamicUndefined}(R)}{\Gamma \vdash \text{Behavior}(R) = \text{UVB}}$$

**Static vs. Runtime Checks.**

$$\text{CheckKind} = \{\text{PatternExhaustiveness},\ \text{TypeCompatibility},\ \text{PermissionViolations},\ \text{ProvenanceEscape},\ \text{ArrayBounds},\ \text{SafePointerValidity},\ \text{IntegerOverflow},\ \text{SliceBounds},\ \text{IntDivisionByZero}\}$$

$$\text{StaticCheck} = \{\text{PatternExhaustiveness},\ \text{TypeCompatibility},\ \text{PermissionViolations},\ \text{ProvenanceEscape},\ \text{ArrayBounds},\ \text{SafePointerValidity}\}$$
$$\text{RuntimeCheck} = \{\text{IntegerOverflow},\ \text{SliceBounds},\ \text{IntDivisionByZero}\}$$

$$\text{RuntimeBehavior}(\text{IntegerOverflow}) = \text{Panic}$$
$$\text{RuntimeBehavior}(\text{SliceBounds}) = \text{Panic}$$
$$\text{RuntimeBehavior}(\text{IntDivisionByZero}) = \text{Panic}$$

$$\text{ResourceExhaustion} \Rightarrow \text{OutsideConformance}$$

**Error Recovery (Cursive0).**
$$\text{LexRecovery} = \text{SkipToNextTokenStart}$$
$$\text{ParseRecovery} = \text{SyncSet}(\{\texttt{;},\ \texttt{\}},\ \texttt{EOF}\})$$
$$\text{TypeRecovery} = \text{ContinueDecls}$$
$$\text{MaxErrorCount} \in \mathbb{N} \cup \{\infty\}$$
$$\text{SuggestedMaxErrorCount} = 100$$
$$\text{AbortOnErrorCount}(n) \iff n \ge \text{MaxErrorCount}$$

### 1.4. Unsupported Constructs Policy

**UnsupportedConstruct.**
$$\text{UnsupportedConstruct} = \{\texttt{key\_system},\ \texttt{attribute\_syntax},\ \texttt{extern\_block},\ \texttt{foreign\_decl},\ \texttt{class\_generics},\ \texttt{class\_where\_clause},\ \texttt{associated\_type},\ \texttt{modal\_class},\ \texttt{class\_contract}\}$$

**(WF-Attr-Unsupported)**
$$\frac{\texttt{[[...]]} \in M}{\Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Attr-Unsupported}))}$$

$$\text{UnsupportedForm} = \text{UnsupportedConstruct} \cup \text{S0Unsupported} \cup \text{UnsupportedGrammarFamily} \cup \text{UnsupportedClassItem} \cup \text{UnsupportedWhereClause} \cup \text{ComptimeForm}$$

**(Unsupported-Construct)**
$$\frac{f \in \text{UnsupportedForm}}{\Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}$$

### 1.5. Target and ABI Assumptions

$$\text{TargetArch} = \text{Win64}$$
$$\text{Endianness} = \text{Little}$$
$$\text{PtrSizeBytes} = \text{PtrSize}$$
$$\text{LayoutSpec} = \text{RulesIn}(\{\texttt{"6.1.1"},\ \texttt{"6.1.2"},\ \texttt{"6.1.3"},\ \texttt{"6.1.4"},\ \texttt{"6.1.5"},\ \texttt{"6.1.6"}\})$$

$$\text{Target} = \texttt{"x86_64-pc-windows-msvc"}$$
$$\text{Win64} = \text{Target}$$

### 1.6. Diagnostics Infrastructure

#### 1.6.1. Source Locations and Spans

**SourceLocation.**

$$\text{SourceLocation} = \langle \text{file},\ \text{offset},\ \text{line},\ \text{column} \rangle$$

**Span.**

$$\text{Span} = \langle \text{file},\ \text{start\_offset},\ \text{end\_offset},\ \text{start\_line},\ \text{start\_col},\ \text{end\_line},\ \text{end\_col} \rangle$$

$$\text{SpanRange}(\text{sp}) = [\text{sp.start\_offset},\ \text{sp.end\_offset})$$

**(WF-Location)**
$$\frac{0 \le o \quad \Gamma \vdash \text{Locate}(S,o) \Downarrow \elloc}{\Gamma \vdash \elloc : \text{LocationOk}}$$

**(WF-Span)**
$$\frac{0 \le s \le e \le S.\text{byte\_len} \quad \Gamma \vdash \text{Locate}(S,s) \Downarrow \ell_s \quad \Gamma \vdash \text{Locate}(S,e) \Downarrow \ell_e}{\Gamma \vdash \langle S.\text{path}, s, e, \ell_s.\text{line}, \ell_s.\text{column}, \ell_e.\text{line}, \ell_e.\text{column} \rangle : \text{SpanOk}}$$

**Span Construction**

$$\text{ClampSpan}(S,s,e) = (s',e')$$
$$s' = \min(s,\ S.\text{byte\_len})$$
$$e' = \min(\max(e,\ s'),\ S.\text{byte\_len})$$

**(Span-Of)**
$$\frac{\Gamma \vdash \text{ClampSpan}(S,s,e) \Downarrow (s',e') \quad \Gamma \vdash \langle S.\text{path}, s', e', \text{line}_s, \text{col}_s, \text{line}_e, \text{col}_e \rangle : \text{SpanOk}}{\Gamma \vdash \text{SpanOf}(S,s,e) \Downarrow \langle S.\text{path}, s', e', \text{line}_s, \text{col}_s, \text{line}_e, \text{col}_e \rangle}$$

#### 1.6.2. Token Spans

**TokenKind.**

$$\text{TokenKind}_{C0} = \text{TokenKind}_{\S 3.2.4} \cup \{\text{Unknown}\}$$

**(No-Unknown-Ok)**
$$\frac{\forall t \in K.\ t.\text{kind} \ne \text{Unknown}}{\Gamma \vdash K : \text{TokenStreamOk}}$$

**RawToken.**

$$\text{RawToken} = \langle \text{kind},\ \text{lexeme},\ s,\ e \rangle$$

**Token.**

$$\text{Token} = \langle \text{kind},\ \text{lexeme},\ \text{span} \rangle$$

**(Attach-Token-Ok)**
$$\frac{\Gamma \vdash \text{SpanOf}(S,s,e) \Downarrow \text{sp}}{\Gamma \vdash \text{AttachSpan}(S,\langle k,\ell,s,e \rangle) \Downarrow \langle k,\ell,\text{sp} \rangle}$$

**Token Stream Attachment (Bigâ€‘Step)**

**(Attach-Tokens-Ok)**
$$\frac{\forall r \in rs,\ \Gamma \vdash \text{AttachSpan}(S,r) \Downarrow t \quad ts = [t \mid r \in rs]}{\Gamma \vdash \text{AttachSpans}(S, rs) \Downarrow ts}$$

#### 1.6.3. Diagnostics: Records and Emission

**Diagnostic.**

$$\text{Severity} = \{\text{Error},\ \text{Warning}\}$$

**Diagnostic Stream.**
$$\Delta = [d_1,\ldots,d_n]$$

**(Emit-Append)**
$$\frac{}{ \Gamma \vdash \text{Emit}(\Delta, d) \Downarrow (\Delta \mathbin{+\!\!+} [d]) }$$

**Emit (Implicit).**
$$\text{Emit}(c) = \text{Emit}(\Delta,\ \langle c,\ \text{Severity}(c),\ \text{Message}(c),\ \bot \rangle)$$
$$\text{Emit}(c,\ sp) = \text{Emit}(\Delta,\ \langle c,\ \text{Severity}(c),\ \text{Message}(c),\ sp \rangle)$$

$$\text{Severity}(c) = \text{SeverityColumn}(c)$$
$$\text{Message}(c) = \text{ConditionColumn}(c)$$

$$\text{CompileStatus}(\Delta) = \begin{cases}
\text{fail} & \text{if } \text{HasError}(\Delta) \\
\text{ok} & \text{otherwise}
\end{cases}$$

#### 1.6.4. Diagnostic Code Selection

$$\text{SpecCode} : \text{DiagId} \rightharpoonup \text{DiagCode}$$
$$\text{SpecCode}(id) = \bot$$
$$\text{C0Code} : \text{DiagId} \rightharpoonup \text{DiagCode}$$

**(Code-Spec)**
$$\frac{\text{SpecCode}(id) = c}{\Gamma \vdash \text{Code}(id) \Downarrow c}$$

**(Code-C0)**
$$\frac{\text{SpecCode}(id) = \bot \quad \text{C0Code}(id) = c}{\Gamma \vdash \text{Code}(id) \Downarrow c}$$

**DiagIdâ€“Code Mapping.**
$$\frac{id \text{ emits a diagnostic}}{\Gamma \vdash \text{Emit}(\text{Code}(id))}$$
$$\Uparrow \equiv \Uparrow \text{Code}(id)$$

**Resolution Failure.**
$$\text{NoDiag}(\uparrow)$$

#### 1.6.5. Diagnostic Ordering

**(Order)**
$$\frac{\Delta = [d_1, d_2, \ldots, d_n]}{\Gamma \vdash \text{Order}(\Delta) \Downarrow [d_1, d_2, \ldots, d_n]}$$

#### 1.6.6. Diagnostic Rendering

$$\text{Render}(d) = \begin{cases}
\text{code} \mathbin{+\!\!+} \texttt{" ("} \mathbin{+\!\!+} \text{sev} \mathbin{+\!\!+} \texttt{")"} \mathbin{+\!\!+} \text{msg} \mathbin{+\!\!+} \texttt{" @"} \mathbin{+\!\!+} \text{loc} & \text{if } d.\text{span} \ne \bot \\
\text{code} \mathbin{+\!\!+} \texttt{" ("} \mathbin{+\!\!+} \text{sev} \mathbin{+\!\!+} \texttt{")"} \mathbin{+\!\!+} \text{msg} & \text{if } d.\text{span} = \bot
\end{cases}$$

$$\text{code} = d.\text{code}$$
$$\text{sev} = \begin{cases}\texttt{"error"} & d.\text{severity}=\text{Error} \\ \texttt{"warning"} & d.\text{severity}=\text{Warning}\end{cases}$$
$$\text{msg} = \begin{cases}\texttt{"\""} & d.\text{message}=\texttt{"\""} \\ \texttt{": "} \mathbin{+\!\!+} d.\text{message} & \text{otherwise}\end{cases}$$
$$\text{loc} = d.\text{span.file} \mathbin{+\!\!+} \texttt{":"} \mathbin{+\!\!+} d.\text{span.start\_line} \mathbin{+\!\!+} \texttt{":"} \mathbin{+\!\!+} d.\text{span.start\_col}$$
$$\text{PermLexeme}(\texttt{const}) = \texttt{"const"}$$
$$\text{PermLexeme}(\texttt{unique}) = \texttt{"unique"}$$
$$\text{PermLexeme}(\texttt{shared}) = \texttt{"shared"}$$
$$\text{QualLexeme}(\texttt{imm}) = \texttt{"imm"}$$
$$\text{QualLexeme}(\texttt{mut}) = \texttt{"mut"}$$
$$\text{PtrStateSuffix}(\bot) = \texttt{""}$$
$$\text{PtrStateSuffix}(\texttt{Valid}) = \texttt{"@Valid"}$$
$$\text{PtrStateSuffix}(\texttt{Null}) = \texttt{"@Null"}$$
$$\text{PtrStateSuffix}(\texttt{Expired}) = \texttt{"@Expired"}$$
$$\text{StringStateSuffix}(\bot) = \texttt{""}$$
$$\text{StringStateSuffix}(\texttt{View}) = \texttt{"@View"}$$
$$\text{StringStateSuffix}(\texttt{Managed}) = \texttt{"@Managed"}$$
$$\text{BytesStateSuffix}(\bot) = \texttt{""}$$
$$\text{BytesStateSuffix}(\texttt{View}) = \texttt{"@View"}$$
$$\text{BytesStateSuffix}(\texttt{Managed}) = \texttt{"@Managed"}$$
$$\text{ParamRender}(\langle \bot, T \rangle) = \text{TypeRender}(T)$$
$$\text{ParamRender}(\langle \texttt{move}, T \rangle) = \texttt{"move "} \mathbin{+\!\!+} \text{TypeRender}(T)$$
$$\text{TypeRender}(\text{TypePrim}(name)) = name$$
$$\text{TypeRender}(\text{TypeRange}) = \texttt{"TypeRange"}$$
$$\text{TypeRender}(\text{TypePerm}(p, T)) = \text{PermLexeme}(p) \mathbin{+\!\!+} \texttt{" "} \mathbin{+\!\!+} \text{TypeRender}(T)$$
$$\text{TypeRender}(\text{TypeUnion}([T_1,\ldots,T_n])) = \text{Join}(\texttt{" | "}, [\text{TypeRender}(T_1),\ldots,\text{TypeRender}(T_n)])$$
$$\text{TypeRender}(\text{TypeFunc}([\langle m_1,T_1\rangle,\ldots,\langle m_n,T_n\rangle], R)) = \texttt{"("} \mathbin{+\!\!+} \text{Join}(\texttt{", "}, [\text{ParamRender}(\langle m_1,T_1\rangle),\ldots,\text{ParamRender}(\langle m_n,T_n\rangle)]) \mathbin{+\!\!+} \texttt{") -> "} \mathbin{+\!\!+} \text{TypeRender}(R)$$
$$\text{TypeRender}(\text{TypeTuple}([])) = \texttt{"()"}$$
$$\text{TypeRender}(\text{TypeTuple}([T])) = \texttt{"("} \mathbin{+\!\!+} \text{TypeRender}(T) \mathbin{+\!\!+} \texttt{";)"}$$
$$\text{TypeRender}(\text{TypeTuple}([T_1,\ldots,T_n])) = \texttt{"("} \mathbin{+\!\!+} \text{Join}(\texttt{", "}, [\text{TypeRender}(T_1),\ldots,\text{TypeRender}(T_n)]) \mathbin{+\!\!+} \texttt{")"}$$
$$\text{TypeRender}(\text{TypeArray}(T, e)) = \texttt{"["} \mathbin{+\!\!+} \text{TypeRender}(T) \mathbin{+\!\!+} \texttt{"; "} \mathbin{+\!\!+} \text{ArrayLen}(e) \mathbin{+\!\!+} \texttt{"]"}$$
$$\text{TypeRender}(\text{TypeSlice}(T)) = \texttt{"["} \mathbin{+\!\!+} \text{TypeRender}(T) \mathbin{+\!\!+} \texttt{"]"}$$
$$\text{TypeRender}(\text{TypePtr}(T, s)) = \texttt{"Ptr<"} \mathbin{+\!\!+} \text{TypeRender}(T) \mathbin{+\!\!+} \texttt{">"} \mathbin{+\!\!+} \text{PtrStateSuffix}(s)$$
$$\text{TypeRender}(\text{TypeRawPtr}(q, T)) = \texttt{"* "} \mathbin{+\!\!+} \text{QualLexeme}(q) \mathbin{+\!\!+} \texttt{" "} \mathbin{+\!\!+} \text{TypeRender}(T)$$
$$\text{TypeRender}(\text{TypeString}(st)) = \texttt{"string"} \mathbin{+\!\!+} \text{StringStateSuffix}(st)$$
$$\text{TypeRender}(\text{TypeBytes}(st)) = \texttt{"bytes"} \mathbin{+\!\!+} \text{BytesStateSuffix}(st)$$
$$\text{TypeRender}(\text{TypeDynamic}(p)) = \texttt{"$"} \mathbin{+\!\!+} \text{StringOfPath}(p)$$
$$\text{TypeRender}(\text{TypeModalState}(p, S)) = \text{StringOfPath}(p) \mathbin{+\!\!+} \texttt{"@"} \mathbin{+\!\!+} S$$
$$\text{TypeRender}(\text{TypePath}(p)) = \text{StringOfPath}(p)$$

#### 1.6.7. Diagnostics without Source Spans

**(NoSpan-External)**
$$\frac{\text{Origin}(d)=\text{External}}{\Gamma \vdash d.\text{span} = \bot}$$

### 1.7. Host Primitives

$$\text{FSPrim} = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSCreateWrite},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSWriteFile},\ \text{FSWriteStdout},\ \text{FSWriteStderr},\ \text{FSExists},\ \text{FSRemove},\ \text{FSOpenDir},\ \text{FSCreateDir},\ \text{FSEnsureDir},\ \text{FSKind},\ \text{FSRestrict}\}$$
$$\text{FilePrim} = \{\text{FileReadAll},\ \text{FileReadAllBytes},\ \text{FileWrite},\ \text{FileFlush},\ \text{FileClose}\}$$
$$\text{DirPrim} = \{\text{DirNext},\ \text{DirClose}\}$$

$$\text{HostPrim} = \{\text{ParseTOML},\ \text{ReadBytes},\ \text{WriteFile},\ \text{ResolveTool},\ \text{ResolveRuntimeLib},\ \text{Invoke},\ \text{AssembleIR},\ \text{InvokeLinker}\} \cup \text{FSPrim} \cup \text{FilePrim} \cup \text{DirPrim}$$
$$\text{HostPrimDiag} = \{\text{ParseTOML},\ \text{ReadBytes},\ \text{WriteFile},\ \text{ResolveTool},\ \text{ResolveRuntimeLib},\ \text{Invoke},\ \text{AssembleIR},\ \text{InvokeLinker}\}$$
$$\text{HostPrimRuntime} = \text{FSPrim} \cup \text{FilePrim} \cup \text{DirPrim}$$
$$\text{MapsToDiagOrRuntime}(p) \iff p \in \text{HostPrimDiag} \cup \text{HostPrimRuntime}$$
$$\text{HostPrimFail}(p) \iff p \in \text{HostPrim} \land \exists args.\ \Gamma \vdash p(args) \Uparrow$$

$$\text{HostPrimFail}(p) \land \neg \text{MapsToDiagOrRuntime}(p) \Rightarrow \text{IllFormed}(p)$$

## 2. Phase 0: Build/Project Model

**Assembly Kind.**
$$\text{AssemblyKind} = \{\texttt{executable},\ \texttt{library}\}$$

**Assembly Record.**
$$\text{Assembly} = \langle \text{name},\ \text{kind},\ \text{root},\ \text{out\_dir},\ \text{emit\_ir},\ \text{source\_root},\ \text{outputs},\ \text{modules} \rangle$$

**Project Record.**
$$\text{Project} = \langle \text{root},\ \text{assemblies},\ \text{assembly},\ \text{source\_root},\ \text{outputs},\ \text{modules} \rangle$$
$$\text{Assemblies}(P) = P.\text{assemblies}$$
$$\text{Assembly}(P) = P.\text{assembly}$$
$$\text{AsmNames}(P) = [A.\text{name} \mid A \in \text{Assemblies}(P)]$$
$$\text{AsmByName}(P,n) = A \iff A \in \text{Assemblies}(P) \land A.\text{name}=n \land (\forall B \in \text{Assemblies}(P).\ B.\text{name}=n \Rightarrow B=A)$$

**Build/Project Validation Scope.**
$$\text{Phase0Checks} = \text{RulesIn}(\{\texttt{"2"}\})$$
$$\text{SourceChecks} = \text{RulesIn}(\{\texttt{"3"},\ \texttt{"4"},\ \texttt{"5"},\ \texttt{"6"}\})$$
$$\text{Phase0Checks} \cap \text{SourceChecks} = \emptyset$$

**Command-Line Output.**
$$\text{DumpProject}(P,\text{dump}) = \begin{cases}
\text{ProjectSummary}(P) \mathbin{+\!\!+} \text{OutputSummary}(P) & \text{if } \text{dump} = \text{false} \\
\text{ProjectSummary}(P) \mathbin{+\!\!+} \text{OutputSummary}(P) \mathbin{+\!\!+} [\texttt{"file:"} \mathbin{+\!\!+} f \mid d \in \text{Modules}(P.\text{source\_root}),\ f \in \text{CompilationUnit}(d)] & \text{if } \text{dump} = \text{true}
\end{cases}$$

$$\text{ProjectSummary}(P) = [\langle \texttt{project\_root}, P.\text{root} \rangle,\ \langle \texttt{assemblies}, \text{AsmNames}(P) \rangle,\ \langle \texttt{assembly\_name}, P.\text{assembly.name} \rangle,\ \langle \texttt{source\_root}, P.\text{source\_root} \rangle,\ \langle \texttt{output\_root}, \text{OutputRoot}(P) \rangle,\ \langle \texttt{module\_list}, \text{ModuleList}(P) \rangle]$$

$$\text{OutputSummary}(P) = [\langle \texttt{module}, m,\ \texttt{obj}, \text{ObjPath}(P,m),\ \texttt{ir}, \text{IROpt}(P,m)\rangle \mid m \in \text{ModuleList}(P)]$$

$$\text{IROpt}(P,m) = \begin{cases}
\text{IRPath}(P,m,P.\text{assembly.emit\_ir}) & \text{if } P.\text{assembly.emit\_ir} \ne \texttt{none} \\
\bot & \text{if } P.\text{assembly.emit\_ir} = \texttt{none}
\end{cases}$$

### 2.1. Project Root and Manifest

**Manifest Parsing (Big-Step)**

$$\text{ParseTOML} : \text{Path} \rightharpoonup \text{TOMLTable}$$

**(Parse-Manifest-Ok)**
$$\frac{\text{ParseTOML}(R/\texttt{Cursive.toml}) \Downarrow T}{\Gamma \vdash \text{ParseManifest}(R) \Downarrow T}$$

**(Parse-Manifest-Missing)**
$$\frac{\neg \text{exists}(R/\texttt{Cursive.toml}) \quad c = \text{Code}(\text{Parse-Manifest-Missing})}{\Gamma \vdash \text{ParseManifest}(R) \Uparrow c}$$

**(Parse-Manifest-Err)**
$$\frac{\text{ParseTOML}(R/\texttt{Cursive.toml}) \Uparrow \quad c = \text{Code}(\text{Parse-Manifest-Err})}{\Gamma \vdash \text{ParseManifest}(R) \Uparrow c}$$

**Manifest Required (No Single-File Fallback).**
If $\Gamma \vdash \text{ParseManifest}(R) \Uparrow c$, then $\Gamma \vdash \text{LoadProject}(R,\text{target}) \Uparrow c$ and the implementation MUST NOT attempt any single-file or heuristic fallback project construction.

**Manifest Path Resolution.**
Manifest lookup MUST use host filesystem path resolution semantics for $R/\texttt{Cursive.toml}$ and MUST NOT perform additional case verification.

**Manifest Schema (Cursive0)**

$$n = t.\text{name}$$
$$k = t.\text{kind}$$
$$r = t.\text{root}$$
$$o = t.\text{out\_dir}$$
$$e = t.\text{emit\_ir}$$

**(WF-Assembly-Name)**
$$\frac{\Gamma \vdash n : \text{Identifier} \quad \Gamma \vdash n : \text{NotKeyword}}{\Gamma \vdash n : \text{Name}}$$

**(WF-Assembly-Name-Err)**
$$\frac{\neg(\Gamma \vdash n : \text{Identifier} \land \Gamma \vdash n : \text{NotKeyword}) \quad c = \text{Code}(\text{WF-Assembly-Name-Err})}{\Gamma \vdash n : \text{Name} \Uparrow c}$$

**(WF-Assembly-Kind)**
$$\frac{k \in \text{AssemblyKind}}{\Gamma \vdash k : \text{Kind}}$$

**(WF-Assembly-Kind-Err)**
$$\frac{k \notin \text{AssemblyKind} \quad c = \text{Code}(\text{WF-Assembly-Kind-Err})}{\Gamma \vdash k : \text{Kind} \Uparrow c}$$

**(WF-Assembly-Root-Path)**
$$\frac{\Gamma \vdash r : \text{RelPath}}{\Gamma \vdash r : \text{RootPath}}$$

**(WF-Assembly-Root-Path-Err)**
$$\frac{\neg(\Gamma \vdash r : \text{RelPath}) \quad c = \text{Code}(\text{WF-Assembly-Root-Path-Err})}{\Gamma \vdash r : \text{RootPath} \Uparrow c}$$

**(WF-Assembly-OutDir-Path)**
$$\frac{o = \bot \ \lor\ \Gamma \vdash o : \text{RelPath}}{\Gamma \vdash o : \text{OutDirPath}}$$

**(WF-Assembly-OutDir-Path-Err)**
$$\frac{o \ne \bot \quad \neg(\Gamma \vdash o : \text{RelPath}) \quad c = \text{Code}(\text{WF-Assembly-OutDir-Path-Err})}{\Gamma \vdash o : \text{OutDirPath} \Uparrow c}$$

**(WF-Assembly-EmitIR)**
$$\frac{e \in \{\bot,\ \texttt{none},\ \texttt{ll},\ \texttt{bc}\}}{\Gamma \vdash e : \text{EmitIR}}$$

**(WF-Assembly-EmitIR-Err)**
$$\frac{e \notin \{\bot,\ \texttt{none},\ \texttt{ll},\ \texttt{bc}\} \quad c = \text{Code}(\text{WF-Assembly-EmitIR-Err})}{\Gamma \vdash e : \text{EmitIR} \Uparrow c}$$

**Manifest Validation (Big-Step)**

$$\text{Keys}(T) = \text{Dom}(T)$$
$$\text{AsmField}(T) = T[\texttt{assembly}]$$
$$\text{AsmTables}(T) = \begin{cases}
[\text{AsmField}(T)] & \text{if }\text{IsTable}(\text{AsmField}(T))\\
\text{AsmField}(T) & \text{if }\text{IsArrayTable}(\text{AsmField}(T))\\
\bot & \text{otherwise}
\end{cases}$$

**(WF-TopKeys)**
$$\frac{\text{Keys}(T) \subseteq \{\texttt{assembly}\}}{\Gamma \vdash T : \text{TopKeys}}$$

**(WF-TopKeys-Err)**
$$\frac{\neg(\text{Keys}(T) \subseteq \{\texttt{assembly}\}) \quad c = \text{Code}(\text{WF-TopKeys-Err})}{\Gamma \vdash T : \text{TopKeys} \Uparrow c}$$

**(WF-Assembly-Table)**
$$\frac{\text{AsmTables}(T) \ne \bot}{\Gamma \vdash T : \text{AssemblyTable}}$$

**(WF-Assembly-Table-Err)**
$$\frac{\text{AsmTables}(T) = \bot \quad c = \text{Code}(\text{WF-Assembly-Table-Err})}{\Gamma \vdash T : \text{AssemblyTable} \Uparrow c}$$

**(WF-Assembly-Count)**
$$\frac{\text{AsmTables}(T) = Ts \quad |Ts| \ge 1}{\Gamma \vdash T : \text{AssemblyCount}}$$

**(WF-Assembly-Count-Err)**
$$\frac{\text{AsmTables}(T) = Ts \quad |Ts| = 0 \quad c = \text{Code}(\text{WF-Assembly-Count-Err})}{\Gamma \vdash T : \text{AssemblyCount} \Uparrow c}$$

**(WF-Assembly-Name-Dup)**
$$\frac{\text{AsmTables}(T) = Ts \quad \text{Distinct}([t.\text{name} \mid t \in Ts])}{\Gamma \vdash T : \text{AssemblyNames}}$$

**(WF-Assembly-Name-Dup-Err)**
$$\frac{\text{AsmTables}(T) = Ts \quad \neg \text{Distinct}([t.\text{name} \mid t \in Ts]) \quad c = \text{Code}(\text{WF-Assembly-Name-Dup})}{\Gamma \vdash T : \text{AssemblyNames} \Uparrow c}$$

$$\text{Req} = \{\texttt{name},\ \texttt{kind},\ \texttt{root}\}$$
$$\text{Opt} = \{\texttt{out\_dir},\ \texttt{emit\_ir}\}$$

**(WF-Assembly-Keys)**
$$\frac{\text{Keys}(t) \subseteq (\text{Req} \cup \text{Opt})}{\Gamma \vdash t : \text{KnownKeys}}$$

**(WF-Assembly-Keys-Err)**
$$\frac{\neg(\text{Keys}(t) \subseteq (\text{Req} \cup \text{Opt})) \quad c = \text{Code}(\text{WF-Assembly-Keys-Err})}{\Gamma \vdash t : \text{KnownKeys} \Uparrow c}$$

**(WF-Assembly-Required-Types)**
$$\frac{\forall k \in \text{Req}.\ \text{IsString}(t[k])}{\Gamma \vdash t : \text{ReqTypes}}$$

**(WF-Assembly-Required-Types-Err)**
$$\frac{\exists k \in \text{Req}.\ t[k]=\bot \ \lor\ \neg \text{IsString}(t[k]) \quad c = \text{Code}(\text{WF-Assembly-Required-Types-Err})}{\Gamma \vdash t : \text{ReqTypes} \Uparrow c}$$

**(WF-Assembly-Optional-Types)**
$$\frac{t[\texttt{out\_dir}] \in \{\text{string}, \bot\}}{\Gamma \vdash t : \text{OutDirType}}$$

**(WF-Assembly-OutDirType-Err)**
$$\frac{t[\texttt{out\_dir}] \notin \{\text{string}, \bot\} \quad c = \text{Code}(\text{WF-Assembly-OutDirType-Err})}{\Gamma \vdash t : \text{OutDirType} \Uparrow c}$$

$$\frac{t[\texttt{emit\_ir}] \in \{\text{string}, \bot\}}{\Gamma \vdash t : \text{EmitIRType}}$$

**(WF-Assembly-EmitIRType-Err)**
$$\frac{t[\texttt{emit\_ir}] \notin \{\text{string}, \bot\} \quad c = \text{Code}(\text{WF-Assembly-EmitIRType-Err})}{\Gamma \vdash t : \text{EmitIRType} \Uparrow c}$$

**Path Resolution**
$$\text{WinSep} = \{\texttt{"\\"},\ \texttt{"/"}\}$$
$$\text{AsciiLetter}(c) \iff (c \in \{\texttt{"A"},\ldots,\texttt{"Z"}\} \lor c \in \{\texttt{"a"},\ldots,\texttt{"z"}\})$$
$$\text{DriveRooted}(p) \iff |p|\ge 3 \land \text{AsciiLetter}(\text{At}(p,0)) \land \text{At}(p,1)=\texttt{":"} \land \text{At}(p,2)\in \text{WinSep}$$
$$\text{UNC}(p) \iff \text{StartsWith}(p,\texttt{"//"}) \lor \text{StartsWith}(p,\texttt{"\\\\"})$$
$$\text{RootRelative}(p) \iff (\text{StartsWith}(p,\texttt{"/"}) \lor \text{StartsWith}(p,\texttt{"\\"})) \land \neg \text{UNC}(p) \land \neg \text{DriveRooted}(p)$$
$$\text{RootTag}(p) =
\begin{cases}
p[0..2) & \text{if }\text{DriveRooted}(p)\\
\texttt{"//"} & \text{if }\text{UNC}(p)\\
\texttt{"/"} & \text{if }\text{RootRelative}(p)\\
\texttt{"\""} & \text{otherwise}
\end{cases}$$
$$\text{Tail}(p) =
\begin{cases}
p[3..|p|) & \text{if }\text{DriveRooted}(p)\\
p[2..|p|) & \text{if }\text{UNC}(p)\\
p[1..|p|) & \text{if }\text{RootRelative}(p)\\
p & \text{otherwise}
\end{cases}$$
$$\text{Segs}(p) = [\ p[i..j)\ \mid\ 0 \le i < j \le |p| \land (\forall k\in[i,j).\ \text{At}(p,k)\notin\text{WinSep}) \land (i=0 \lor \text{At}(p,i-1)\in\text{WinSep}) \land (j=|p| \lor \text{At}(p,j)\in\text{WinSep})\ ]$$
$$\text{PathComps}(p) = \begin{cases}
\text{Segs}(p) & \text{RootTag}(p)=\texttt{"\""}\\
[\text{RootTag}(p)] \mathbin{+\!\!+} \text{Segs}(\text{Tail}(p)) & \text{otherwise}
\end{cases}$$
$$\text{JoinComp}([]) = \texttt{"\""}$$
$$\text{JoinComp}([c]) = c$$
$$\text{JoinComp}(c::cs) = \begin{cases}
c \mathbin{+\!\!+} \text{JoinComp}(cs) & c \in \{\texttt{"/"},\texttt{"//"}\}\\
c \mathbin{+\!\!+} \texttt{"/"} \mathbin{+\!\!+} \text{JoinComp}(cs) & \text{DriveRooted}(c \mathbin{+\!\!+} \texttt{"/"})\\
c \mathbin{+\!\!+} \texttt{"/"} \mathbin{+\!\!+} \text{JoinComp}(cs) & \text{otherwise}
\end{cases}$$
$$\text{Join}(a,b) = \begin{cases}
b & \text{if }\text{AbsPath}(b)\\
\text{JoinComp}(\text{PathComps}(a) \mathbin{+\!\!+} \text{PathComps}(b)) & \text{otherwise}
\end{cases}$$

$$\text{AbsPath}(p) \iff \text{DriveRooted}(p) \lor \text{UNC}(p) \lor \text{RootRelative}(p)$$
$$\text{is\_relative}(p) \iff \neg \text{AbsPath}(p)$$
$$\text{Join} : \text{Path} \times \text{Path} \to \text{Path}$$
$$\text{Normalize} : \text{Path} \to \text{Path}$$
$$\text{Canon} : \text{Path} \rightharpoonup \text{Path}$$
$$\text{prefix}(p,q) \iff \text{PathPrefix}(\text{PathComps}(q),\ \text{PathComps}(p))$$
$$\text{Normalize}(p) = \text{JoinComp}([\ c \mid c \in \text{PathComps}(p) \land c \ne \texttt{"."}\ ])$$
$$\text{Canon}(p) = \bot \iff \exists c \in \text{PathComps}(\text{Normalize}(p)).\ c=\texttt{".."}$$
$$\text{Canon}(p) = \text{Normalize}(p) \iff \neg \exists c \in \text{PathComps}(\text{Normalize}(p)).\ c=\texttt{".."}$$
$$\text{Drop}(0, xs) = xs \quad \text{Drop}(n, []) = [] \quad \text{Drop}(n, x::xs) = \text{Drop}(n-1, xs)\ (n>0)$$
$$\text{relative}(p, base) = rel \iff \text{Canon}(p)=p' \land \text{Canon}(base)=b' \land \text{PathPrefix}(\text{PathComps}(b'), \text{PathComps}(p')) \land rel = \text{JoinComp}(\text{Drop}(|\text{PathComps}(b')|, \text{PathComps}(p')))$$
$$\text{Basename}(p) = \begin{cases}
\texttt{"\""} & |\text{PathComps}(p)|=0\\
\text{last}(\text{PathComps}(p)) & \text{otherwise}
\end{cases}$$
$$\text{last}([x])=x \quad \text{last}(x::xs)=\text{last}(xs)\ (|xs|>0)$$

$$b = \text{Basename}(p)$$
$$D = \{ j \mid 0 \le j < |b| \land b[j] = \texttt{"."} \}$$
$$\text{FileExt}(p) = \begin{cases}
\texttt{"\""} & D = \emptyset\\
\texttt{"\""} & D \ne \emptyset \land \max(D) = 0\\
b[\max(D)..|b|) & D \ne \emptyset \land \max(D) > 0
\end{cases}$$

**(Resolve-Canonical)**
$$\frac{p' = \text{Normalize}(\text{Join}(R,p)) \quad \text{Canon}(R) = R' \quad \text{Canon}(p') = p''}{\Gamma \vdash \text{Resolve}(R,p) \Downarrow (R', p'')}$$

**(Resolve-Canonical-Err)**
$$\frac{p' = \text{Normalize}(\text{Join}(R,p)) \quad (\text{Canon}(R)=\bot \ \lor\ \text{Canon}(p')=\bot) \quad c = \text{Code}(\text{Resolve-Canonical-Err})}{\Gamma \vdash \text{Resolve}(R,p) \Uparrow c}$$

**(WF-RelPath)**
$$\frac{\text{is\_relative}(p) \quad \Gamma \vdash \text{Resolve}(R,p) \Downarrow (R',p'') \quad \text{prefix}(p'', R')}{\Gamma \vdash p : \text{RelPath}}$$

**(WF-RelPath-Err)**
$$\frac{\neg \text{is\_relative}(p) \ \lor\ (\Gamma \vdash \text{Resolve}(R,p) \Downarrow (R',p'') \land \neg \text{prefix}(p'', R')) \quad c = \text{Code}(\text{WF-RelPath-Err})}{\Gamma \vdash p : \text{RelPath} \Uparrow c}$$

$$\text{Project}(\Gamma) = P \iff \Gamma.\text{project} = P$$

**Project Load (Small-Step)**

$$\text{AssemblyTarget} = \text{Name} \cup \{\bot\}$$
$$\text{ProjLoadState} = \{\text{Start}(R,\text{target}),\ \text{Parsed}(R,\text{target},T),\ \text{Validated}(R,\text{target},T),\ \text{ProjAsmScan}(R,\text{target},T,Ts,As),\ \text{Discovered}(P),\ \text{Error}(code)\}$$

**(Step-Parse)**
$$\frac{\Gamma \vdash \text{ParseManifest}(R) \Downarrow T}{\langle \text{Start}(R,\text{target}) \rangle \to \langle \text{Parsed}(R,\text{target},T) \rangle}$$

**(Step-Parse-Err)**
$$\frac{\Gamma \vdash \text{ParseManifest}(R) \Uparrow c}{\langle \text{Start}(R,\text{target}) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Step-Validate)**
$$\frac{\Gamma \vdash \text{ValidateManifest}(T) \Downarrow \text{ok}}{\langle \text{Parsed}(R,\text{target},T) \rangle \to \langle \text{Validated}(R,\text{target},T) \rangle}$$

**(Step-Validate-Err)**
$$\frac{\Gamma \vdash \text{ValidateManifest}(T) \Uparrow c}{\langle \text{Parsed}(R,\text{target},T) \rangle \to \langle \text{Error}(c) \rangle}$$

**Manifest Validation (Deterministic).**

$$\text{ChecksAsm}(t) = [\Gamma \vdash t : \text{KnownKeys},\ \Gamma \vdash t : \text{ReqTypes},\ \Gamma \vdash t : \text{OutDirType},\ \Gamma \vdash t : \text{EmitIRType},\ \Gamma \vdash t.\text{name} : \text{Name},\ \Gamma \vdash t.\text{kind} : \text{Kind},\ \Gamma \vdash t.\text{emit\_ir} : \text{EmitIR},\ \Gamma \vdash t.\text{root} : \text{RootPath},\ \Gamma \vdash t.\text{out\_dir} : \text{OutDirPath}]$$
$$\text{BaseChecks}(T) = [\Gamma \vdash T : \text{TopKeys},\ \Gamma \vdash T : \text{AssemblyTable},\ \Gamma \vdash T : \text{AssemblyCount},\ \Gamma \vdash T : \text{AssemblyNames}]$$
$$\text{AsmChecks}(T) = \begin{cases}
[] & \text{if }\text{AsmTables}(T)=\bot\\
\mathbin{+\!\!+}_{t \in \text{AsmTables}(T)} \text{ChecksAsm}(t) & \text{otherwise}
\end{cases}$$
$$\text{Checks}(T) = \text{BaseChecks}(T) \mathbin{+\!\!+} \text{AsmChecks}(T)$$

$$\text{FirstFail}([]) = \bot$$
$$\text{FirstFail}(J::Js) = c \iff \Gamma \vdash J \Uparrow c$$
$$\text{FirstFail}(J::Js) = \text{FirstFail}(Js) \iff \Gamma \vdash J \Downarrow ok$$

**(ValidateManifest-Ok)**
$$\frac{\text{FirstFail}(\text{Checks}(T)) = \bot}{\Gamma \vdash \text{ValidateManifest}(T) \Downarrow \text{ok}}$$

**(ValidateManifest-Err)**
$$\frac{\text{FirstFail}(\text{Checks}(T)) = c}{\Gamma \vdash \text{ValidateManifest}(T) \Uparrow c}$$

**(Step-Asm-Init)**
$$\frac{Ts = \text{AsmTables}(T)}{\langle \text{Validated}(R,\text{target},T) \rangle \to \langle \text{ProjAsmScan}(R,\text{target},T,Ts,[]) \rangle}$$

**(Step-Asm-Cons)**
$$\frac{\Gamma \vdash \text{BuildAssembly}(R,t_0) \Downarrow A}{\langle \text{ProjAsmScan}(R,\text{target},T,t_0::ts,As) \rangle \to \langle \text{ProjAsmScan}(R,\text{target},T,ts,As \mathbin{+\!\!+} [A]) \rangle}$$

**(Step-Asm-Err)**
$$\frac{\Gamma \vdash \text{BuildAssembly}(R,t_0) \Uparrow c}{\langle \text{ProjAsmScan}(R,\text{target},T,t_0::ts,As) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Step-Asm-Done)**
$$\frac{\Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Downarrow A_0 \quad P = \langle \text{root}=R,\ \text{assemblies}=As,\ \text{assembly}=A_0,\ \text{source\_root}=A_0.\text{source\_root},\ \text{outputs}=A_0.\text{outputs},\ \text{modules}=A_0.\text{modules} \rangle}{\langle \text{ProjAsmScan}(R,\text{target},T,[],As) \rangle \to \langle \text{Discovered}(P) \rangle}$$

**(Step-Asm-Done-Err)**
$$\frac{\Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Uparrow c}{\langle \text{ProjAsmScan}(R,\text{target},T,[],As) \rangle \to \langle \text{Error}(c) \rangle}$$

**Assembly Selection**

**(Select-Only)**
$$\frac{|As|=1 \quad \text{target}=\bot \quad As=[A_0]}{\Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Downarrow A_0}$$

**(Select-By-Name)**
$$\frac{\text{target} \ne \bot \quad A \in As \quad A.\text{name}=\text{target}}{\Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Downarrow A}$$

**(Select-Err)**
$$\frac{(\text{target}=\bot \land |As| \ne 1) \ \lor\ (\text{target} \ne \bot \land \neg \exists A \in As.\ A.\text{name}=\text{target}) \quad c = \text{Code}(\text{Assembly-Select-Err})}{\Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Uparrow c}$$

**Assembly Build (Big-Step)**

**(BuildAssembly-Ok)**
$$\frac{\Gamma \vdash \text{Resolve}(R,t.\texttt{root}) \Downarrow (R',S) \quad \Gamma \vdash S : \text{SourceRoot} \quad \Gamma \vdash \text{Modules}(S, t.\text{name}) \Downarrow M \quad L = \text{sort}_{\prec_{mod}}(M) \quad A = \langle \text{name}=t.\text{name},\ \text{kind}=t.\text{kind},\ \text{root}=t.\text{root},\ \text{out\_dir}=t.\text{out\_dir},\ \text{emit\_ir}=t.\text{emit\_ir},\ \text{source\_root}=S,\ \text{outputs}=\text{OutputPaths}(R,t),\ \text{modules}=L \rangle}{\Gamma \vdash \text{BuildAssembly}(R,t) \Downarrow A}$$

**(BuildAssembly-Err-Resolve)**
$$\frac{\Gamma \vdash \text{Resolve}(R,t.\texttt{root}) \Uparrow c}{\Gamma \vdash \text{BuildAssembly}(R,t) \Uparrow c}$$

**(BuildAssembly-Err-Root)**
$$\frac{\Gamma \vdash \text{Resolve}(R,t.\texttt{root}) \Downarrow (R',S) \quad \Gamma \vdash S : \text{SourceRoot} \Uparrow c}{\Gamma \vdash \text{BuildAssembly}(R,t) \Uparrow c}$$

**(BuildAssembly-Err-Modules)**
$$\frac{\Gamma \vdash \text{Resolve}(R,t.\texttt{root}) \Downarrow (R',S) \quad \Gamma \vdash S : \text{SourceRoot} \quad \Gamma \vdash \text{Modules}(S, t.\text{name}) \Uparrow c}{\Gamma \vdash \text{BuildAssembly}(R,t) \Uparrow c}$$

**Project Load (Big-Step)**

**(LoadProject-Ok)**
$$\frac{\Gamma \vdash \text{ParseManifest}(R) \Downarrow T \quad \Gamma \vdash \text{ValidateManifest}(T) \Downarrow ok \quad \text{AsmTables}(T) = [t_1,\ldots,t_n] \quad \forall i,\ \Gamma \vdash \text{BuildAssembly}(R,t_i) \Downarrow A_i \quad As = [A_1,\ldots,A_n] \quad \Gamma \vdash \text{SelectAssembly}(As, \text{target}) \Downarrow A_0 \quad P = \langle \text{root}=R,\ \text{assemblies}=As,\ \text{assembly}=A_0,\ \text{source\_root}=A_0.\text{source\_root},\ \text{outputs}=A_0.\text{outputs},\ \text{modules}=A_0.\text{modules} \rangle}{\Gamma \vdash \text{LoadProject}(R, \text{target}) \Downarrow P}$$

**(LoadProject-Err)**
$$\frac{\Gamma \vdash \text{LoadProject}(R, \text{target}) \to^* \langle \text{Error}(c) \rangle}{\Gamma \vdash \text{LoadProject}(R, \text{target}) \Uparrow c}$$

**Well-Formed Project Root**

**(WF-Project-Root)**
$$\frac{\text{exists}(\texttt{Cursive.toml} \text{ at } R)}{\vdash R : \text{ProjectRoot}}$$

### 2.2. Assemblies

$$\frac{A_0.\text{kind} \in \text{AssemblyKind}}{\Gamma \vdash A_0 : \text{Assembly}}$$


### 2.3. Deterministic Ordering and Case Folding

#### 2.3.1. Module File Processing Order
$$\text{FoldPath}(r) = \text{JoinComp}([\text{CaseFold}(\text{NFC}(c)) \mid c \in \text{PathComps}(r)])$$

$$\text{FileKey}(f,d) = \begin{cases}
\langle \text{FoldPath}(rel),\ rel \rangle & \text{if } \text{relative}(f,d) \Downarrow rel \\
\langle \bot,\ \text{Basename}(f) \rangle & \text{if } \text{relative}(f,d) \Uparrow
\end{cases}$$

$$f_1 \prec_{\text{file}} f_2 \iff \text{Utf8LexLess}(\text{FileKey}(f_1,d),\ \text{FileKey}(f_2,d))$$

**(FileOrder-Rel-Fail)**
$$\frac{\text{relative}(f,d) \Uparrow \quad c = \text{Code}(\text{FileOrder-Rel-Fail})}{\Gamma \vdash \text{Emit}(c)}$$

#### 2.3.2. Module Path Case-Folding Algorithm

**Fold.**
$$\text{Fold}(p) = [\text{CaseFold}(\text{NFC}(c)) \mid c \in p]$$

#### 2.3.3. Directory Enumeration Order

$$\text{DirKey}(d,S) = \begin{cases}
\langle \text{FoldPath}(rel),\ rel \rangle & \text{if } \text{relative}(d,S) \Downarrow rel \\
\langle \bot,\ \text{Basename}(d) \rangle & \text{if } \text{relative}(d,S) \Uparrow
\end{cases}$$

$$d_1 \prec_{\text{dir}} d_2 \iff \text{Utf8LexLess}(\text{DirKey}(d_1,S),\ \text{DirKey}(d_2,S))$$

$$\text{DirSeq}(S) = \text{sort}_{\prec_{\text{dir}}}(\text{Dirs}(S))$$

**(DirSeq-Read-Err)**
$$\frac{\text{Dirs}(S) \Uparrow \quad c = \text{Code}(\text{DirSeq-Read-Err})}{\Gamma \vdash \text{Emit}(c)}$$

**(DirSeq-Rel-Fail)**
$$\frac{\text{relative}(d,S) \Uparrow \quad c = \text{Code}(\text{DirSeq-Rel-Fail})}{\Gamma \vdash \text{Emit}(c)}$$

### 2.4. Module Discovery

**Dirs.**
$$\text{Dirs}(S) = \{ d \mid \text{is\_dir}(d) \land \text{relative}(d,S) \Downarrow r \}$$
$$S \in \text{Dirs}(S)$$

**(WF-Source-Root)**
$$\frac{\text{is\_dir}(S)}{\Gamma \vdash S : \text{SourceRoot}}$$

**(WF-Source-Root-Err)**
$$\frac{\neg \text{is\_dir}(S) \quad c = \text{Code}(\text{WF-Source-Root-Err})}{\Gamma \vdash S : \text{SourceRoot} \Uparrow c}$$

**(Module-Dir)**
$$\frac{\exists f \in \text{Files}(d) : \text{FileExt}(f) = \texttt{.cursive}}{\Gamma \vdash d : \text{ModuleDir}}$$

$$\text{Modules}(S) = \{ d \in \text{Dirs}(S) \mid \Gamma \vdash d : \text{ModuleDir} \}$$

**Module Discovery (Big-Step)**

**(Modules-Ok)**
$$\frac{\langle \text{DiscStart}(S, A) \rangle \to^* \langle \text{DiscDone}(M) \rangle}{\Gamma \vdash \text{Modules}(S, A) \Downarrow M}$$

**(Modules-Err)**
$$\frac{\langle \text{DiscStart}(S, A) \rangle \to^* \langle \text{Error}(c) \rangle}{\Gamma \vdash \text{Modules}(S, A) \Uparrow c}$$

$$\text{Files}(d) = \{ f \mid f \in d \land \text{FileExt}(f) = \texttt{.cursive} \}$$

$$\text{CompilationUnit}(d) = \text{sort}_{\prec_{\text{file}}}(\text{Files}(d))$$

**(CompilationUnit-Rel-Fail)**
$$\frac{\exists f \in \text{Files}(d).\ \text{relative}(f,d) \Uparrow \quad c = \text{Code}(\text{FileOrder-Rel-Fail})}{\Gamma \vdash \text{CompilationUnit}(d) \Uparrow c}$$


**Module Path.**

**(Module-Path-Root)**
$$\frac{\text{relative}(d,S) = \epsilon}{\Gamma \vdash \text{ModulePath}(d,S,A) = A}$$

**(Module-Path-Rel)**
$$\frac{\text{relative}(d,S) = c_1 / \cdots / c_n}{\Gamma \vdash \text{ModulePath}(d,S,A) = c_1 \mathbin{::} \cdots \mathbin{::} c_n}$$

**(Module-Path-Rel-Fail)**
$$\frac{\text{relative}(d,S) \Uparrow}{\Gamma \vdash \text{ModulePath}(d,S,A) \Uparrow}$$

$$\text{WFModulePathJudg} = \{\text{WF-Module-Path}\}$$

**(WF-Module-Path-Ok)**
$$\frac{\forall comp \in p,\ (\Gamma \vdash comp : \text{Identifier}) \land \neg \text{Keyword}(comp)}{\Gamma \vdash \text{WF-Module-Path}(p) \Downarrow ok}$$

**(WF-Module-Path-Reserved)**
$$\frac{\exists comp \in p.\ \text{Keyword}(comp) \quad c = \text{Code}(\text{WF-Module-Path-Reserved})}{\Gamma \vdash \text{WF-Module-Path}(p) \Uparrow c}$$

**(WF-Module-Path-Ident-Err)**
$$\frac{\exists comp \in p.\ \neg(\Gamma \vdash comp : \text{Identifier}) \quad c = \text{Code}(\text{WF-Module-Path-Ident-Err})}{\Gamma \vdash \text{WF-Module-Path}(p) \Uparrow c}$$

**(WF-Module-Path-Collision)**
$$\frac{p_1 \neq p_2 \quad \text{Fold}(p_1) = \text{Fold}(p_2)}{\Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Module-Path-Collision})) \quad \Gamma \vdash \text{Emit}(W\text{-}MOD\text{-}1101,\ \bot)}$$

**Module Discovery (Small-Step)**
$$\text{DiscState} = \{\text{DiscStart}(S,A),\ \text{DiscScan}(S,A,Pending,M,Seen),\ \text{DiscDone}(M),\ \text{Error}(code)\}$$

**(Disc-Start)**
$$\frac{}{\langle \text{DiscStart}(S, A) \rangle \to \langle \text{DiscScan}(S, A, \text{DirSeq}(S), [], \emptyset) \rangle}$$

**(Disc-Skip)**
$$\frac{\Gamma \nvdash d : \text{ModuleDir}}{\langle \text{DiscScan}(S, A, d::ds, M, Seen) \rangle \to \langle \text{DiscScan}(S, A, ds, M, Seen) \rangle}$$

**(Disc-Add)**
$$\frac{\Gamma \vdash d : \text{ModuleDir} \quad \Gamma \vdash \text{ModulePath}(d,S,A) = p \quad \Gamma \vdash \text{WF-Module-Path}(p) \Downarrow ok \quad \text{Fold}(p) \notin \text{dom}(Seen)}{\langle \text{DiscScan}(S, A, d::ds, M, Seen) \rangle \to \langle \text{DiscScan}(S, A, ds, M \mathbin{+\!\!+} [p], Seen \cup \{\text{Fold}(p) \mapsto p\}) \rangle}$$

**(Disc-Collision)**
$$\frac{\Gamma \vdash d : \text{ModuleDir} \quad \Gamma \vdash \text{ModulePath}(d,S,A) = p \quad \Gamma \vdash \text{WF-Module-Path}(p) \Downarrow ok \quad \text{Fold}(p) \in \text{dom}(Seen) \quad Seen[\text{Fold}(p)] \neq p}{\langle \text{DiscScan}(S, A, d::ds, M, Seen) \rangle \to \langle \text{Error}(\text{Code}(\text{Disc-Collision})) \rangle}$$

**(Disc-Invalid-Component)**
$$\frac{\Gamma \vdash d : \text{ModuleDir} \quad \Gamma \vdash \text{ModulePath}(d,S,A) = p \quad \Gamma \vdash \text{WF-Module-Path}(p) \Uparrow c}{\langle \text{DiscScan}(S, A, d::ds, M, Seen) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Disc-Rel-Fail)**
$$\frac{\Gamma \vdash d : \text{ModuleDir} \quad \text{relative}(d,S) \Uparrow}{\langle \text{DiscScan}(S, A, d::ds, M, Seen) \rangle \to \langle \text{Error}(\text{Code}(\text{Disc-Rel-Fail})) \rangle}$$

**(Disc-Done)**
$$\frac{}{\langle \text{DiscScan}(S, A, [], M, Seen) \rangle \to \langle \text{DiscDone}(M) \rangle}$$

**(WF-Import-Unsupported)**
$$\frac{\text{import\_decl} \in M}{\Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Import-Unsupported}))}$$

### 2.5. Output Artifacts and Linking

**Output Root.**

$$O = \text{OutputRoot}(P) = \begin{cases}
P.\text{root}/P.\text{assembly.out\_dir} & \text{if provided} \\
P.\text{root}/\texttt{build} & \text{otherwise}
\end{cases}$$

**Output Hygiene (Cursive0).**
$$\text{OutputHygiene}(P) \iff \forall p \in \text{RequiredOutputs}(P).\ \text{Under}(p,\ \text{OutputRoot}(P))$$

$$\text{OutputPaths}(R,A).\text{root} = \begin{cases}
R/A.\text{out\_dir} & \text{if provided} \\
R/\texttt{build} & \text{otherwise}
\end{cases}$$
$$\text{OutputPaths}(R,A).\text{obj\_dir} = \text{OutputPaths}(R,A).\text{root}/\texttt{obj}$$
$$\text{OutputPaths}(R,A).\text{ir\_dir} = \text{OutputPaths}(R,A).\text{root}/\texttt{ir}$$
$$\text{OutputPaths}(R,A).\text{bin\_dir} = \text{OutputPaths}(R,A).\text{root}/\texttt{bin}$$

$$P.\text{outputs} = P.\text{assembly.outputs}$$

**Object File Naming**

$$\text{PathToPrefix}(s) = \text{Concat}([\text{BMap}(b) \mid b \in \text{Utf8}(\text{NFC}(s))])$$
$$\text{BMap}(b) = \begin{cases}
\text{chr}(b) & \text{if } b \in [0\text{-}9A\text{-}Za\text{-}z] \\
\texttt{\"_x\"} \mathbin{+\!\!+} \text{Hex2}(b) & \text{otherwise}
\end{cases}$$

$$\text{mangle}(s) = \text{PathToPrefix}(s)$$
$$\text{MangleModulePath}(p) = \text{mangle}(\text{PathString}(\text{PathKey}(p)))$$

$$\text{obj}(m) = O / \texttt{obj} / (\text{MangleModulePath}(p) \mathbin{+\!\!+} \texttt{".obj"})$$

**Executable Naming**

$$\text{exe} = O / \texttt{bin} / (\text{assembly\_name} \mathbin{+\!\!+} \texttt{".exe"})$$

**Output and Linking Semantics (Formal Rules)**

$$\text{path}(m) = m.\text{path}$$
$$S = P.\text{source\_root}$$

**Module Emission Order.**

$$m_1 \prec_{mod} m_2 \iff \text{Utf8LexLess}(\text{Fold}(\text{path}(m_1)),\ \text{Fold}(\text{path}(m_2))) \ \lor\ (\text{Fold}(\text{path}(m_1)) = \text{Fold}(\text{path}(m_2)) \land \text{Utf8LexLess}(\text{path}(m_1),\ \text{path}(m_2)))$$

$$\text{Utf8LexLess}(a,b) \iff \text{LexBytes}(\text{Utf8}(a),\ \text{Utf8}(b))$$

**(ModuleList-Ok)**
$$\frac{\Gamma \vdash \text{Modules}(S, P.\text{assembly.name}) \Downarrow M \quad L = \text{sort}_{\prec_{mod}}(M)}{\Gamma \vdash \text{ModuleList}(P) \Downarrow L}$$

**(ModuleList-Err)**
$$\frac{\Gamma \vdash \text{Modules}(S, P.\text{assembly.name}) \Uparrow c}{\Gamma \vdash \text{ModuleList}(P) \Uparrow c}$$

**Output Paths.**
$$O = \text{OutputRoot}(P)$$
$$\text{assembly\_name} = P.\text{assembly.name}$$
$$\text{ext}(e) = \begin{cases}
\texttt{".ll"} & \text{if } e=\texttt{ll} \\
\texttt{".bc"} & \text{if } e=\texttt{bc}
\end{cases}$$

$$\text{ObjPath}(P,m) = O / \texttt{obj} / (\text{MangleModulePath}(\text{path}(m)) \mathbin{+\!\!+} \texttt{".obj"})$$
$$\text{IRPath}(P,m,e) = O / \texttt{ir} / (\text{MangleModulePath}(\text{path}(m)) \mathbin{+\!\!+} \text{ext}(e))$$
$$\text{ExePath}(P) = \begin{cases}
O / \texttt{bin} / (\text{assembly\_name} \mathbin{+\!\!+} \texttt{".exe"}) & \text{if }\text{Executable}(P)\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{ObjPaths}(P, ms) = [\text{ObjPath}(P,m) \mid m \in ms]$$
$$\text{IRPaths}(P, ms, e) = [\text{IRPath}(P,m,e) \mid m \in ms]$$

**Module Index and Symbol Name.**
$$\text{ModuleList}(P) = [m_1, \ldots, m_n]$$
$$\text{Index}(P, m_i) = i$$
$$\text{pad4}(i) = \text{PadLeft}(\text{Decimal}(i),\ \texttt{'0'},\ 4)$$
$$\text{SymbolName}(P, m) = \begin{cases}
\texttt{main} & \text{if } \text{path}(m) = P.\text{assembly.name} \\
\texttt{mod} \mathbin{+\!\!+} \text{pad4}(\text{Index}(P,m)) & \text{otherwise}
\end{cases}$$

$$\text{trunc8}(s) = \text{PadRight}(\text{Take}(\text{Utf8}(s), 8),\ 8,\ 0x00)$$

**LLVM Target Constants.**
$$\text{LLVMTriple} = \texttt{"x86_64-pc-windows-msvc"}$$
$$\text{LLVMDataLayout} = \texttt{"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"}$$

$$\text{IsRootModule}(P, m) \iff \text{path}(m) = P.\text{assembly.name}$$

$$\text{WithEntry}(P,m,IR) = \begin{cases}
IR \mathbin{+\!\!+} [\text{EntryStub}(P)] & \text{if } \text{Executable}(P) \land \text{IsRootModule}(P,m)\\
IR & \text{otherwise}
\end{cases}$$

**(CodegenObj-LLVM)**
$$\frac{Project(\Gamma) = P \quad \Gamma \vdash \text{CodegenModule}(m) \Downarrow IR \quad IR' = \text{WithEntry}(P,m,IR) \quad \Gamma \vdash \text{LowerIR}(IR') \Downarrow L \quad \Gamma \vdash \text{EmitObj}(L) \Downarrow b}{\Gamma \vdash \text{CodegenObj}(m) \Downarrow b}$$

**(CodegenIR-LLVM)**
$$\frac{Project(\Gamma) = P \quad e \in \{\texttt{ll},\texttt{bc}\} \quad \Gamma \vdash \text{CodegenModule}(m) \Downarrow IR \quad IR' = \text{WithEntry}(P,m,IR) \quad \Gamma \vdash \text{LowerIR}(IR') \Downarrow L \quad \Gamma \vdash \text{EmitLLVM}(L) \Downarrow b}{\Gamma \vdash \text{CodegenIR}(m, e) \Downarrow b}$$

**File Emission.**
$$\text{WriteFileOk}(p,b) \Rightarrow \text{Overwrites}(p,b)$$

**Directory Creation.**
$$\text{EnsureDir}(p) \Downarrow ok \Rightarrow \text{IsDir}(p)$$

**Emit Objects**

**(Emit-Objects-Empty)**
$$\frac{}{ \Gamma \vdash \text{EmitObjects}([], P) \Downarrow [] }$$

**(Emit-Objects-Cons)**
$$\frac{
    \Gamma \vdash \text{CodegenObj}(m) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{ObjPath}(P,m), b) \Downarrow ok \quad
    \Gamma \vdash \text{EmitObjects}(ms, P) \Downarrow L
}{
    \Gamma \vdash \text{EmitObjects}(m::ms, P) \Downarrow \text{ObjPath}(P,m)::L
}$$

**Emit IR**

**(Emit-IR-None)**
$$\frac{e = \texttt{none}}{\Gamma \vdash \text{EmitIR}(ms, P, e) \Downarrow []}$$

**(Emit-IR-Cons-LL)**
$$\frac{
    e = \texttt{ll} \quad
    \Gamma \vdash \text{CodegenIR}(m, e) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Downarrow ok \quad
    \Gamma \vdash \text{EmitIR}(ms, P, e) \Downarrow L
}{
    \Gamma \vdash \text{EmitIR}(m::ms, P, e) \Downarrow \text{IRPath}(P,m,e)::L
}$$

**(Emit-IR-Cons-BC)**
$$\frac{
    e = \texttt{bc} \quad
    \Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Downarrow t \quad
    \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \quad
    \Gamma \vdash \text{AssembleIR}(a, t) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Downarrow ok \quad
    \Gamma \vdash \text{EmitIR}(ms, P, e) \Downarrow L
}{
    \Gamma \vdash \text{EmitIR}(m::ms, P, e) \Downarrow \text{IRPath}(P,m,e)::L
}$$

$$\text{EmitIRFail}(m,P,\texttt{ll}) \iff \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Uparrow \ \lor\ (\exists b.\ \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Downarrow b \land \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,\texttt{ll}), b) \Uparrow)$$
$$\text{EmitIRFail}(m,P,\texttt{bc}) \iff \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Uparrow \ \lor\ (\exists t.\ \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Uparrow) \ \lor\ (\exists t,a.\ \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \land \Gamma \vdash \text{AssembleIR}(a, t) \Uparrow) \ \lor\ (\exists t,a,b.\ \Gamma \vdash \text{CodegenIR}(m,\texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \land \Gamma \vdash \text{AssembleIR}(a,t) \Downarrow b \land \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,\texttt{bc}), b) \Uparrow)$$

**(Emit-IR-Err)**
$$\frac{\text{EmitIRFail}(m,P,e) \quad c = \text{Code}(\text{Out-IR-Err})}{\Gamma \vdash \text{EmitIR}(m::ms, P, e) \Uparrow c}$$

$$\text{LinkJudg} = \{\text{ResolveRuntimeLib},\ \text{Link}\}$$
$$\text{RuntimeLibName} = \texttt{"cursive0\_rt.lib"}$$
$$\text{RuntimeLibPath}(P) = P.\text{root} / \texttt{runtime} / \text{RuntimeLibName}$$

**(ResolveRuntimeLib-Ok)**
$$\frac{\Gamma \vdash \text{ReadBytes}(\text{RuntimeLibPath}(P)) \Downarrow \_}{\Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow \text{RuntimeLibPath}(P)}$$

**(ResolveRuntimeLib-Err)**
$$\frac{\Gamma \vdash \text{ReadBytes}(\text{RuntimeLibPath}(P)) \Uparrow}{\Gamma \vdash \text{ResolveRuntimeLib}(P) \Uparrow}$$

$$\text{LinkerSyms} : \text{Path} \times \text{List}(\text{Path}) \times \text{Path} \rightharpoonup \mathcal{P}(\text{Symbol})$$
$$\text{RuntimeRequiredSyms} = \text{RuntimeSyms}$$
$$\text{MissingRuntimeSym}(t, L, exe) \iff \text{RuntimeRequiredSyms} \nsubseteq \text{LinkerSyms}(t, L, exe)$$

$$\text{LinkObjs}(P) = \text{ObjPaths}(P, \text{ModuleList}(P))$$
$$\text{LinkInputs}(P) = \text{LinkObjs}(P) \mathbin{+\!\!+} [\text{RuntimeLibPath}(P)]$$
$$\text{LinkFlags}(P) = [\texttt{"/OUT:"} \mathbin{+\!\!+} \text{ExePath}(P),\ \texttt{"/ENTRY:main"},\ \texttt{"/SUBSYSTEM:CONSOLE"},\ \texttt{"/NODEFAULTLIB"}]$$
$$\text{LinkArgsOk}(P, L, exe) \iff L = \text{LinkInputs}(P) \land exe = \text{ExePath}(P) \land \text{LinkFlags}(P) = [\texttt{"/OUT:"} \mathbin{+\!\!+} \text{ExePath}(P),\ \texttt{"/ENTRY:main"},\ \texttt{"/SUBSYSTEM:CONSOLE"},\ \texttt{"/NODEFAULTLIB"}]$$

**(Link-Ok)**
$$\frac{
    \text{Executable}(P) \quad
    \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad
    \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad
    \text{LinkArgsOk}(P, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad
    \Gamma \vdash \text{InvokeLinker}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \Downarrow ok
}{
    \Gamma \vdash \text{Link}(\text{Objs}, P) \Downarrow ok
}$$

**(Link-NotFound)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Uparrow \quad c = \text{Code}(\text{Out-Link-NotFound})}{\Gamma \vdash \text{Link}(\text{Objs}, P) \Uparrow c}$$

**(Link-Runtime-Missing)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Uparrow \quad c = \text{Code}(\text{Out-Link-Runtime-Missing})}{\Gamma \vdash \text{Link}(\text{Objs}, P) \Uparrow c}$$

**(Link-Runtime-Incompatible)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad \text{LinkArgsOk}(P, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad \text{MissingRuntimeSym}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad c = \text{Code}(\text{Out-Link-Runtime-Incompatible})}{\Gamma \vdash \text{Link}(\text{Objs}, P) \Uparrow c}$$

**(Link-Fail)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad \text{LinkArgsOk}(P, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad \neg \text{MissingRuntimeSym}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad \Gamma \vdash \text{InvokeLinker}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \Uparrow \quad c = \text{Code}(\text{Out-Link-Fail})}{\Gamma \vdash \text{Link}(\text{Objs}, P) \Uparrow c}$$

**Output Pipeline (Bigâ€‘Step)**
$$O = \text{OutputRoot}(P)$$
$$ms = \text{ModuleList}(P)$$
$$e = P.\text{assembly.emit\_ir}$$

**(Output-Pipeline)**
$$\frac{
    \text{Executable}(P) \quad
    \Gamma \vdash \text{EnsureDir}(O) \Downarrow ok \quad
    \Gamma \vdash \text{EnsureDir}(O / \texttt{obj}) \Downarrow ok \quad
    \Gamma \vdash \text{EnsureDir}(O / \texttt{bin}) \Downarrow ok \quad
    (e = \texttt{none} \lor \Gamma \vdash \text{EnsureDir}(O / \texttt{ir}) \Downarrow ok) \quad
    \Gamma \vdash \text{EmitObjects}(ms, P) \Downarrow \text{Objs} \quad
    \Gamma \vdash \text{EmitIR}(ms, P, e) \Downarrow \text{IRs} \quad
    \Gamma \vdash \text{Link}(\text{Objs}, P) \Downarrow ok
}{
    \Gamma \vdash \text{OutputPipeline}(P) \Downarrow (\text{Objs}, \text{IRs}, \text{ExePath}(P))
}$$

**(Output-Pipeline-Lib)**
$$\frac{
    \neg \text{Executable}(P) \quad
    \Gamma \vdash \text{EnsureDir}(O) \Downarrow ok \quad
    \Gamma \vdash \text{EnsureDir}(O / \texttt{obj}) \Downarrow ok \quad
    (e = \texttt{none} \lor \Gamma \vdash \text{EnsureDir}(O / \texttt{ir}) \Downarrow ok) \quad
    \Gamma \vdash \text{EmitObjects}(ms, P) \Downarrow \text{Objs} \quad
    \Gamma \vdash \text{EmitIR}(ms, P, e) \Downarrow \text{IRs}
}{
    \Gamma \vdash \text{OutputPipeline}(P) \Downarrow (\text{Objs}, \text{IRs}, \bot)
}$$

**(Output-Pipeline-Err)**
$$\frac{\langle \text{OutStart}(P) \rangle \to^* \langle \text{Error}(c) \rangle}{\Gamma \vdash \text{OutputPipeline}(P) \Uparrow c}$$

**Output Pipeline (Small-Step)**
$$\text{OutState} = \{\text{OutStart}(P),\ \text{OutDirs}(P),\ \text{OutObjs}(P,ms,Objs),\ \text{OutIR}(P,ms,Objs,IRs,e),\ \text{OutLink}(P,Objs,IRs),\ \text{OutDone}(Objs,IRs,Exe),\ \text{Error}(code)\}$$
$$O = \text{OutputRoot}(P)$$
$$ms = \text{ModuleList}(P)$$
$$e = P.\text{assembly.emit\_ir}$$

**(Out-Start)**
$$\frac{}{\langle \text{OutStart}(P) \rangle \to \langle \text{OutDirs}(P) \rangle}$$

**(Out-Dirs-Ok)**
$$\frac{
    \Gamma \vdash \text{EnsureDir}(O) \Downarrow ok \quad
    \Gamma \vdash \text{EnsureDir}(O / \texttt{obj}) \Downarrow ok \quad
    (\neg \text{Executable}(P) \ \lor\ \Gamma \vdash \text{EnsureDir}(O / \texttt{bin}) \Downarrow ok) \quad
    (e = \texttt{none} \lor \Gamma \vdash \text{EnsureDir}(O / \texttt{ir}) \Downarrow ok)
}{
    \langle \text{OutDirs}(P) \rangle \to \langle \text{OutObjs}(P, ms, []) \rangle
}$$

**(Out-Dirs-Err)**
$$\frac{\Gamma \vdash \text{EnsureDir}(O) \Uparrow \ \lor\ \Gamma \vdash \text{EnsureDir}(O / \texttt{obj}) \Uparrow \ \lor\ (\text{Executable}(P) \land \Gamma \vdash \text{EnsureDir}(O / \texttt{bin}) \Uparrow) \ \lor\ (e \in \{\texttt{ll},\ \texttt{bc}\} \land \Gamma \vdash \text{EnsureDir}(O / \texttt{ir}) \Uparrow)}{\langle \text{OutDirs}(P) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Dirs-Err})) \rangle}$$

**(Out-Obj-Collision)**
$$\frac{\neg \text{Distinct}(L \mathbin{+\!\!+} \text{ObjPaths}(P, ms))}{\langle \text{OutObjs}(P, ms, L) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Obj-Collision})) \rangle}$$

**(Out-Obj-Cons)**
$$\frac{
    \Gamma \vdash \text{CodegenObj}(m) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{ObjPath}(P,m), b) \Downarrow ok
}{
    \langle \text{OutObjs}(P, m::ms, L) \rangle \to \langle \text{OutObjs}(P, ms, L \mathbin{+\!\!+} [\text{ObjPath}(P,m)]) \rangle
}$$

**(Out-Obj-Err)**
$$\frac{\Gamma \vdash \text{CodegenObj}(m) \Uparrow \ \lor\ (\Gamma \vdash \text{CodegenObj}(m) \Downarrow b \land \Gamma \vdash \text{WriteFile}(\text{ObjPath}(P,m), b) \Uparrow)}{\langle \text{OutObjs}(P, m::ms, L) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Obj-Err})) \rangle}$$

**(Out-Obj-Done)**
$$\frac{}{\langle \text{OutObjs}(P, [], L) \rangle \to \langle \text{OutIR}(P, \text{ModuleList}(P), L, [], e) \rangle}$$

**(Out-IR-None)**
$$\frac{e = \texttt{none} \quad \text{Executable}(P)}{\langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle}$$

**(Out-IR-None-NoLink)**
$$\frac{e = \texttt{none} \quad \neg \text{Executable}(P)}{\langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutDone}(\text{Objs}, \text{IRs}, \bot) \rangle}$$

**(Out-IR-Collision)**
$$\frac{e \in \{\texttt{ll}, \texttt{bc}\} \quad \neg \text{Distinct}(\text{IRs} \mathbin{+\!\!+} \text{IRPaths}(P, ms, e))}{\langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-IR-Collision})) \rangle}$$

**(Out-IR-Cons-LL)**
$$\frac{
    e = \texttt{ll} \quad
    \Gamma \vdash \text{CodegenIR}(m, e) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Downarrow ok
}{
    \langle \text{OutIR}(P, m::ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs} \mathbin{+\!\!+} [\text{IRPath}(P,m,e)], e) \rangle
}$$

**(Out-IR-Cons-BC)**
$$\frac{
    e = \texttt{bc} \quad
    \Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Downarrow t \quad
    \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \quad
    \Gamma \vdash \text{AssembleIR}(a, t) \Downarrow b \quad
    \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Downarrow ok
}{
    \langle \text{OutIR}(P, m::ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs} \mathbin{+\!\!+} [\text{IRPath}(P,m,e)], e) \rangle
}$$

**(Out-IR-Err)**
$$\frac{(e = \texttt{ll} \land (\Gamma \vdash \text{CodegenIR}(m, e) \Uparrow \ \lor\ (\Gamma \vdash \text{CodegenIR}(m, e) \Downarrow b \land \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Uparrow))) \ \lor\ (e = \texttt{bc} \land (\Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Uparrow \ \lor\ (\Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Uparrow) \ \lor\ (\Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \land \Gamma \vdash \text{AssembleIR}(a, t) \Uparrow) \ \lor\ (\Gamma \vdash \text{CodegenIR}(m, \texttt{ll}) \Downarrow t \land \Gamma \vdash \text{ResolveTool}(\texttt{llvm-as}) \Downarrow a \land \Gamma \vdash \text{AssembleIR}(a, t) \Downarrow b \land \Gamma \vdash \text{WriteFile}(\text{IRPath}(P,m,e), b) \Uparrow)))}{\langle \text{OutIR}(P, m::ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-IR-Err})) \rangle}$$

**(Out-IR-Done)**
$$\frac{e \in \{\texttt{ll}, \texttt{bc}\} \quad ms = [] \quad \text{Executable}(P)}{\langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle}$$

**(Out-IR-Done-NoLink)**
$$\frac{e \in \{\texttt{ll}, \texttt{bc}\} \quad ms = [] \quad \neg \text{Executable}(P)}{\langle \text{OutIR}(P, ms, \text{Objs}, \text{IRs}, e) \rangle \to \langle \text{OutDone}(\text{Objs}, \text{IRs}, \bot) \rangle}$$

**(Out-Link-Ok)**
$$\frac{
    \text{Executable}(P) \quad
    \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad
    \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad
    \Gamma \vdash \text{InvokeLinker}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \Downarrow ok
}{
    \langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle \to \langle \text{OutDone}(\text{Objs}, \text{IRs}, \text{ExePath}(P)) \rangle
}$$

**(Out-Link-NotFound)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Uparrow}{\langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Link-NotFound})) \rangle}$$

**(Out-Link-Runtime-Missing)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Uparrow}{\langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Link-Runtime-Missing})) \rangle}$$

**(Out-Link-Runtime-Incompatible)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad \text{MissingRuntimeSym}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P))}{\langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Link-Runtime-Incompatible})) \rangle}$$

**(Out-Link-Fail)**
$$\frac{\text{Executable}(P) \quad \Gamma \vdash \text{ResolveTool}(\texttt{lld-link}) \Downarrow t \quad \Gamma \vdash \text{ResolveRuntimeLib}(P) \Downarrow lib \quad \neg \text{MissingRuntimeSym}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \quad \Gamma \vdash \text{InvokeLinker}(t, \text{Objs} \mathbin{+\!\!+} [lib], \text{ExePath}(P)) \Uparrow}{\langle \text{OutLink}(P, \text{Objs}, \text{IRs}) \rangle \to \langle \text{Error}(\text{Code}(\text{Out-Link-Fail})) \rangle}$$

### 2.6. Tool Resolution and IR Assembly Inputs

$$\text{SearchDirs}(P) = \begin{cases}
[\text{Env}(\texttt{C0\_LLVM\_BIN})] & \text{if } \text{Env}(\texttt{C0\_LLVM\_BIN}) \ne \bot \land \text{Env}(\texttt{C0\_LLVM\_BIN}) \ne \texttt{"\""} \\
[P.\text{root}/\texttt{llvm/llvm-21.1.8-x86_64/bin}] & \text{if } \text{RepoLLVM}(P) \\
\text{PATHDirs} & \text{otherwise}
\end{cases}$$

**(ResolveTool-Ok)**
$$\frac{\text{Project}(\Gamma) = P \quad \text{SearchDirs}(P) \text{ contains }x \text{ at }t}{\Gamma \vdash \text{ResolveTool}(x) \Downarrow t}$$

**(ResolveTool-Err-Linker)**
$$\frac{\text{Project}(\Gamma) = P \quad x = \texttt{lld-link} \quad \text{SearchDirs}(P) \text{ does not contain }x}{\Gamma \vdash \text{ResolveTool}(x) \Uparrow}$$

**(ResolveTool-Err-IR)**
$$\frac{\text{Project}(\Gamma) = P \quad x = \texttt{llvm-as} \quad \text{SearchDirs}(P) \text{ does not contain }x}{\Gamma \vdash \text{ResolveTool}(x) \Uparrow}$$

**(AssembleIR-Ok)**
$$\frac{\text{Invoke}(a, t) \Downarrow b}{\Gamma \vdash \text{AssembleIR}(a, t) \Downarrow b}$$

**(AssembleIR-Err)**
$$\frac{\text{Invoke}(a, t) \Uparrow}{\Gamma \vdash \text{AssembleIR}(a, t) \Uparrow}$$

### 2.7. Unwind and FFI Surface

**(WF-Unwind-Unsupported)**
$$\frac{\texttt{[[unwind]]} \in M}{\Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Unwind-Unsupported}))}$$

## 3. Phase 1: Source Loading, Lexing, Parsing

### 3.1. Source Loading and Normalization

**Source File Record.**

$$\text{SourceFile} = \langle \text{path},\ \text{bytes},\ \text{scalars},\ \text{text},\ \text{byte\_len},\ \text{line\_starts},\ \text{line\_count} \rangle$$

$$S.\text{text} = \text{EncodeUTF8}(S.\text{scalars})$$
$$S.\text{byte\_len} = \text{ByteLen}(S.\text{text})$$
$$S.\text{line\_count} = |S.\text{line\_starts}|$$

**Unicode Scalars and UTF-8.**
$$\text{Byte} = \{ n \in \mathbb{N} \mid 0 \le n \le 255 \}$$
$$\text{Bytes} = [\text{Byte}]$$
$$\text{UnicodeScalar} = \{ u \in \mathbb{N} \mid 0 \le u \le \texttt{0x10FFFF} \land u \notin [\texttt{0xD800},\texttt{0xDFFF}] \}$$
$$\text{Scalars} = [\text{UnicodeScalar}]$$
$$\text{String} = \text{Scalars}$$
$$\text{Utf8Len}(u) =
\begin{cases}
1 & 0 \le u \le \texttt{0x7F}\\
2 & \texttt{0x80} \le u \le \texttt{0x7FF}\\
3 & \texttt{0x800} \le u \le \texttt{0xFFFF}\\
4 & \texttt{0x10000} \le u \le \texttt{0x10FFFF}
\end{cases}$$
$$\text{EncodeUTF8}(u) =
\begin{cases}
[u] & 0 \le u \le \texttt{0x7F}\\
[\texttt{0xC0} \lor (u \gg 6),\ \texttt{0x80} \lor (u \mathbin{\&} \texttt{0x3F})] & \texttt{0x80} \le u \le \texttt{0x7FF}\\
[\texttt{0xE0} \lor (u \gg 12),\ \texttt{0x80} \lor ((u \gg 6) \mathbin{\&} \texttt{0x3F}),\ \texttt{0x80} \lor (u \mathbin{\&} \texttt{0x3F})] & \texttt{0x800} \le u \le \texttt{0xFFFF}\\
[\texttt{0xF0} \lor (u \gg 18),\ \texttt{0x80} \lor ((u \gg 12) \mathbin{\&} \texttt{0x3F}),\ \texttt{0x80} \lor ((u \gg 6) \mathbin{\&} \texttt{0x3F}),\ \texttt{0x80} \lor (u \mathbin{\&} \texttt{0x3F})] & \texttt{0x10000} \le u \le \texttt{0x10FFFF}
\end{cases}$$
$$\text{EncodeUTF8}([]) = []$$
$$\text{EncodeUTF8}(u::U) = \text{EncodeUTF8}(u) \mathbin{+\!\!+} \text{EncodeUTF8}(U)$$
$$\text{DecodeUTF8}(B) = U \iff \text{EncodeUTF8}(U) = B$$
$$\text{Utf8Valid}(B) \iff \exists U.\ \text{DecodeUTF8}(B) = U$$
$$\text{Utf8}(s) = \text{EncodeUTF8}(s)$$


#### 3.1.1. Unicode Normalization Outside Identifiers

$$\text{NormalizeOutsideIdentifiers} : \text{Scalars} \to \text{Scalars}$$
$$\text{NormalizeOutsideIdentifiers}(T) = T$$

#### 3.1.2. Lexically Sensitive Unicode Enforcement
$$T = S.\text{scalars}$$
$$\text{LexSensitivePos}(S) = [\ p\ \mid\ 0 \le p < |T| \land \text{Sensitive}(T[p]) \land \neg \text{InsideLiteralOrComment}(p)\ ]$$
$$\Gamma \vdash \text{LexSecure}(S,K,\text{LexSensitivePos}(S)) \Downarrow ok$$
#### 3.1.3. UTF-8 Decoding and BOM Handling


**(Decode-Ok)**
$$\frac{\text{DecodeUTF8}(B) \Downarrow U}{\Gamma \vdash \text{Decode}(B) \Downarrow U}$$

**(Decode-Err)**
$$\frac{\text{DecodeUTF8}(B) \Uparrow}{\Gamma \vdash \text{Decode}(B) \Uparrow}$$

$$\text{StripLeadBOM}([]) = []$$
$$\text{StripLeadBOM}(\text{U+FEFF}::U) = U$$
$$\text{StripLeadBOM}(u::U) = u::U \ \text{if } u \ne \text{U+FEFF}$$

**(StripBOM-Empty)**
$$\frac{}{\Gamma \vdash \text{StripBOM}([]) \Downarrow ([], false, \bot)}$$

**(StripBOM-None)**
$$\frac{U = u_0::u_1::\ldots \quad u_0 \ne \text{U+FEFF} \quad \forall i>0,\ u_i \ne \text{U+FEFF}}{\Gamma \vdash \text{StripBOM}(U) \Downarrow (U, false, \bot)}$$

**(StripBOM-Start)**
$$\frac{U = \text{U+FEFF}::U_1 \quad \forall i,\ U_1[i] \ne \text{U+FEFF}}{\Gamma \vdash \text{StripBOM}(U) \Downarrow (U_1, true, \bot)}$$

**(StripBOM-Embedded)**
$$\frac{U' = \text{StripLeadBOM}(U) \quad b = (U \ne [] \land U[0] = \text{U+FEFF}) \quad i = \min\{ p \mid 0 \le p < |U'| \land U'[p] = \text{U+FEFF} \}}{\Gamma \vdash \text{StripBOM}(U) \Downarrow (U', b, i)}$$

#### 3.1.4. Line Ending Normalization and Logical Lines

$$\text{CR} = \text{U+000D}$$
$$\text{LF} = \text{U+000A}$$

**(Norm-Empty)**
$$\frac{}{ \Gamma \vdash \text{NormalizeLF}([]) \Downarrow [] }$$

**(Norm-CRLF)**
$$\frac{\Gamma \vdash \text{NormalizeLF}(U) \Downarrow V}{\Gamma \vdash \text{NormalizeLF}([\text{CR},\text{LF}] \mathbin{+\!\!+} U) \Downarrow [\text{LF}] \mathbin{+\!\!+} V}$$

**(Norm-CR)**
$$\frac{U = [] \ \lor\ U[0] \ne \text{LF} \quad \Gamma \vdash \text{NormalizeLF}(U) \Downarrow V}{\Gamma \vdash \text{NormalizeLF}([\text{CR}] \mathbin{+\!\!+} U) \Downarrow [\text{LF}] \mathbin{+\!\!+} V}$$

**(Norm-LF)**
$$\frac{\Gamma \vdash \text{NormalizeLF}(U) \Downarrow V}{\Gamma \vdash \text{NormalizeLF}([\text{LF}] \mathbin{+\!\!+} U) \Downarrow [\text{LF}] \mathbin{+\!\!+} V}$$

**(Norm-Other)**
$$\frac{c \ne \text{CR} \quad c \ne \text{LF} \quad \Gamma \vdash \text{NormalizeLF}(U) \Downarrow V}{\Gamma \vdash \text{NormalizeLF}([c] \mathbin{+\!\!+} U) \Downarrow [c] \mathbin{+\!\!+} V}$$

**Logical Line Map.**

$$\text{Utf8Offsets}([]) = [0]$$
$$\text{Utf8Offsets}(c::cs) = [0] \mathbin{+\!\!+} [o + \text{Utf8Len}(c) \mid o \in \text{Utf8Offsets}(cs)]$$

$$\text{LineStarts}(T) = [0] \mathbin{+\!\!+} [\text{Utf8Offsets}(T)[i] + 1 \mid 0 \le i < |T| \land T[i] = \text{LF}]$$
$$\text{LineCount}(T) = |\text{LineStarts}(T)|$$

**Locate (Line/Column).**
$$L = S.\text{line\_starts}$$
$$o' = \min(o,\ S.\text{byte\_len})$$
$$k = \max\{ j \mid L[j] \le o' \}$$

$$\Gamma \vdash \text{Locate}(S,o) \Downarrow \langle \text{file}=S.\text{path},\ \text{offset}=o',\ \text{line}=k+1,\ \text{col}=o' - L[k] + 1 \rangle$$

#### 3.1.5. Prohibited Code Points

$$\text{Prohibited}(c) \iff \text{General\_Category}(c) = \text{Cc} \land c \notin \{\text{U+0009}, \text{U+000A}, \text{U+000C}, \text{U+000D}\}$$

$$\text{LiteralSpan}(T) = \bigcup \{ [\text{ByteOf}(T,i),\ \text{ByteOf}(T,j)) \mid \text{StringRange}(T,i,j) \lor \text{CharRange}(T,i,j) \}$$

**(WF-Prohibited)**
$$\frac{\forall i,\ \text{Prohibited}(T[i]) \Rightarrow \text{ByteOf}(T,i) \in \text{LiteralSpan}(T)}{\Gamma \vdash T : \text{NoProhibited}}$$

#### 3.1.6. NFC Normalization for Identifiers and Module Paths

$$\text{NFC}(s) = \text{UnicodeNFC}_{15.0.0}(s)$$

$$\text{CaseFold}(s) = \text{UnicodeCaseFold}_{15.0.0}(s)$$

**Totality.**
The functions $\text{NFC}$ and $\text{CaseFold}$ are total on sequences of Unicode scalar values. All inputs to $\text{IdKey}$ and $\text{PathKey}$ MUST be Unicode scalar sequences; inputs are produced by $\text{LoadSource}$, which rejects invalid UTF-8.

$$\text{IdKey}(s) = \text{NFC}(s)$$
$$\text{IdEq}(s_1,s_2) \iff \text{IdKey}(s_1) = \text{IdKey}(s_2)$$

$$\text{PathKey}(p) = [\text{NFC}(c_1), \ldots, \text{NFC}(c_n)]$$
$$\text{PathEq}(p,q) \iff \text{PathKey}(p) = \text{PathKey}(q)$$

#### 3.1.7. Newline Tokens and Statement Termination

$$\text{Tokenize} : \text{SourceFile} \rightharpoonup (\text{Token}^\ast \times \text{DocComment}^\ast)$$
$$\text{Tokenize}(S) = (K,D) \Rightarrow \text{LexNewline}(K,S) \land \text{LexNoComments}(K,S)$$

$$\text{Depth}(K,0) = 0$$
$$\text{Depth}(K,i+1) = \text{Depth}(K,i) + \delta(K[i])$$
$$\delta(t) = \begin{cases}
1 & \text{if } t \in \{\text{Punctuator}(\texttt{"("}),\ \text{Punctuator}(\texttt{"["}),\ \text{Punctuator}(\texttt{"{"})\} \\
-1 & \text{if } t \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"}),\ \text{Punctuator}(\texttt{"}"})\} \\
0 & \text{otherwise}
\end{cases}$$

$$\text{Prev}(K,i) = \bot \iff \{ j \mid j < i \land K[j].\text{kind} \ne \text{newline} \land \forall k.\ j < k < i \Rightarrow K[k].\text{kind} \ne \text{newline} \} = \emptyset$$
$$\text{Prev}(K,i) = K[j] \iff j = \max\{ j \mid j < i \land K[j].\text{kind} \ne \text{newline} \land \forall k.\ j < k < i \Rightarrow K[k].\text{kind} \ne \text{newline} \}$$
$$\text{Next}(K,i) = \bot \iff \{ j \mid j > i \land K[j].\text{kind} \ne \text{newline} \} = \emptyset$$
$$\text{Next}(K,i) = K[j] \iff j = \min\{ j \mid j > i \land K[j].\text{kind} \ne \text{newline} \}$$

$$\text{Ambig} = \{ \texttt{"+"},\ \texttt{"-"},\ \texttt{"*"},\ \texttt{"&"},\ \texttt{"|"} \}$$
$$\text{BeginsOperand}(t) \iff t.\text{kind} \in \{\text{Identifier},\ \text{IntLiteral},\ \text{FloatLiteral},\ \text{StringLiteral},\ \text{CharLiteral},\ \text{BoolLiteral},\ \text{NullLiteral}\} \ \lor\ (t.\text{kind}=\text{Punctuator} \land t.\text{lexeme} \in \{\texttt{"("},\ \texttt{"["},\ \texttt{"{"}\}) \ \lor\ (t.\text{kind}=\text{Operator} \land t.\text{lexeme} \in \{\texttt{"!"},\ \texttt{"-"},\ \texttt{"&"},\ \texttt{"*"},\ \texttt{"^"}\}) \ \lor\ (t.\text{kind}=\text{Keyword} \land t.\text{lexeme} \in \{\texttt{"if"},\ \texttt{"match"},\ \texttt{"loop"},\ \texttt{"unsafe"},\ \texttt{"move"},\ \texttt{"transmute"},\ \texttt{"widen"}\})$$
$$\text{UnaryOnly} = \{\texttt{"!"},\ \texttt{"~"},\ \texttt{"?"}\}$$

$$\text{Continue}(K,i) \iff \text{Depth}(K,i) > 0 \ \lor\ (\exists t.\ \text{Prev}(K,i)=t \land (t.\text{lexeme}=\texttt{","} \lor (t.\text{kind}=\text{Operator} \land ((t.\text{lexeme} \in \text{Ambig} \land \exists u.\ \text{Next}(K,i)=u \land \text{BeginsOperand}(u)) \lor t.\text{lexeme} \notin \text{UnaryOnly})))) \ \lor\ (\exists u.\ \text{Next}(K,i)=u \land u.\text{lexeme} \in \{\texttt{"."},\ \texttt{"::"},\ \texttt{"~>"}\})$$

$$\text{Filter}(K) = [\, K[i] \mid K[i].\text{kind} \ne \text{newline} \ \lor\ \neg \text{Continue}(K,i) \,]$$

$$\text{IsTerminator}(t) \iff t = \text{Punctuator}(\texttt{";"}) \ \lor\ t.\text{kind} = \text{newline}$$
$$\text{BoundaryTokens}(K,i) = \{ t \mid t = K[i] \lor t = \text{Prev}(K,i) \lor t = \text{Next}(K,i) \} \setminus \{\bot\}$$
$$\text{HasTerminator}(F,i) \iff \exists t \in \text{BoundaryTokens}(F,i).\ \text{IsTerminator}(t)$$
$$\text{RequiredTerminator} : \text{Token}^\ast \times \mathbb{N} \to \text{Bool}$$
$$\text{ContinuesLine} : \text{Token}^\ast \times \mathbb{N} \to \text{Bool}$$
$$\text{ContinuesLine}(K,i) \iff K[i].\text{kind}=\text{newline} \land \text{Continue}(K,i)$$
$$\text{RequiredTerminator}(K,i) \iff K[i].\text{kind}=\text{newline} \land \neg \text{ContinuesLine}(K,i)$$

**(Missing-Terminator-Err)**
$$\frac{\text{RequiredTerminator}(K,i) \quad \neg \text{HasTerminator}(\text{Filter}(K), i) \quad c = \text{Code}(\text{Missing-Terminator-Err})}{\Gamma \vdash \text{Emit}(c)}$$


#### 3.1.8. Source Loading Pipeline (Small-Step and Big-Step)

$$\text{SourceLoadState} = \{\text{Start}(f,B),\ \text{Sized}(f,B),\ \text{Decoded}(f,B,U),\ \text{BomStripped}(f,B,U,b,j),\ \text{Normalized}(f,B,T,j),\ \text{LineMapped}(f,B,T,L),\ \text{Validated}(S),\ \text{Error}(code)\}$$
$$B \in \text{Bytes}$$
$$U \in \text{Scalars}$$
$$T \in \text{Scalars}$$
$$L = \text{LineStarts}(T)$$
$$j \in \mathbb{N} \cup \{\bot\}$$

**(Step-Size)**
$$\frac{}{\langle \text{Start}(f,B) \rangle \to \langle \text{Sized}(f,B) \rangle}$$

**(Step-Decode)**
$$\frac{\Gamma \vdash \text{Decode}(B) \Downarrow U}{\langle \text{Sized}(f,B) \rangle \to \langle \text{Decoded}(f,B,U) \rangle}$$

**(Step-Decode-Err)**
$$\frac{\Gamma \vdash \text{Decode}(B) \Uparrow}{\langle \text{Sized}(f,B) \rangle \to \langle \text{Error}(\text{Code}(\text{Step-Decode-Err})) \rangle}$$

**(Step-BOM)**
$$\frac{\Gamma \vdash \text{StripBOM}(U) \Downarrow (U', b, j)}{\langle \text{Decoded}(f,B,U) \rangle \to \langle \text{BomStripped}(f,B,U',b,j) \rangle}$$

**(Step-Norm)**
$$\frac{T = \text{NormalizeOutsideIdentifiers}(U) \quad \Gamma \vdash \text{NormalizeLF}(T) \Downarrow V}{\langle \text{BomStripped}(f,B,U,b,j) \rangle \to \langle \text{Normalized}(f,B,V,j) \rangle}$$

**(Step-EmbeddedBOM-Err)**
$$\frac{j \ne \bot}{\langle \text{Normalized}(f,B,T,j) \rangle \to \langle \text{Error}(\text{Code}(\text{Step-EmbeddedBOM-Err})) \rangle}$$

**(Step-LineMap)**
$$\frac{j = \bot \quad L = \text{LineStarts}(T)}{\langle \text{Normalized}(f,B,T,j) \rangle \to \langle \text{LineMapped}(f,B,T,L) \rangle}$$

**(Step-Prohibited)**
$$\frac{\Gamma \vdash T : \text{NoProhibited} \quad S = \langle \text{path}=f,\ \text{bytes}=B,\ \text{scalars}=T,\ \text{text}=\text{EncodeUTF8}(T),\ \text{byte\_len}=\text{ByteLen}(T),\ \text{line\_starts}=L,\ \text{line\_count}=|L| \rangle}{\langle \text{LineMapped}(f,B,T,L) \rangle \to \langle \text{Validated}(S) \rangle}$$

**(Step-Prohibited-Err)**
$$\frac{\Gamma \vdash T \not: \text{NoProhibited}}{\langle \text{LineMapped}(f,B,T,L) \rangle \to \langle \text{Error}(\text{Code}(\text{Step-Prohibited-Err})) \rangle}$$

**Source Load (Big-Step)**

**(LoadSource-Ok)**
$$\frac{\Gamma \vdash \text{Decode}(B) \Downarrow U \quad \Gamma \vdash \text{StripBOM}(U) \Downarrow (U', b, \bot) \quad \Gamma \vdash \text{NormalizeLF}(\text{NormalizeOutsideIdentifiers}(U')) \Downarrow T \quad L = \text{LineStarts}(T) \quad \Gamma \vdash T : \text{NoProhibited} \quad S = \langle \text{path}=f,\ \text{bytes}=B,\ \text{scalars}=T,\ \text{text}=\text{EncodeUTF8}(T),\ \text{byte\_len}=\text{ByteLen}(T),\ \text{line\_starts}=L,\ \text{line\_count}=|L| \rangle}{\Gamma \vdash \text{LoadSource}(f,B) \Downarrow S}$$

**(LoadSource-Err)**
$$\frac{\Gamma \vdash \text{LoadSource}(f,B) \to^* \langle \text{Error}(c) \rangle}{\Gamma \vdash \text{LoadSource}(f,B) \Uparrow c}$$

#### 3.1.9. Diagnostic Spans for Source Loading

$$S_{\text{tmp}} = \langle \text{path}=f,\ \text{bytes}=B,\ \text{text}=\text{EncodeUTF8}(T),\ \text{byte\_len}=\text{ByteLen}(T),\ \text{line\_starts}=\text{LineStarts}(T),\ \text{line\_count}=|\text{LineStarts}(T)| \rangle$$

$$O = \text{Utf8Offsets}(T)$$
$$O[|T|] = \text{ByteLen}(T)$$

$$\text{SpanAtIndex}(T,i) = \text{SpanOf}(S_{\text{tmp}},\ O[i],\ O[i+1])$$

$$\text{SpanAtLineStart}(T,k) = \text{SpanOf}(S_{\text{tmp}},\ s,\ e)$$
$$s = \begin{cases}
\text{LineStarts}(T)[k] & \text{if } k < |\text{LineStarts}(T)| \\
\text{ByteLen}(T) & \text{otherwise}
\end{cases}$$
$$e = \min(s+1,\ \text{ByteLen}(T))$$

If $b = \text{true}$, the warning $W\text{-}SRC\text{-}0101$ MUST be emitted even if $\text{LoadSource}$ ultimately fails.


**(Span-BOM-Warn)**
$$\frac{b = \text{true} \quad e = \min(1,\ \text{ByteLen}(T))}{\Gamma \vdash \text{Emit}(W\text{-}SRC\text{-}0101,\ \text{SpanOf}(S_{\text{tmp}}, 0, e))}$$

**(Span-BOM-Embedded)**
$$\frac{j \ne \bot \quad i = \min\{ p \mid 0 \le p < |T| \land T[p] = \text{U+FEFF} \}}{\Gamma \vdash \text{Emit}(E\text{-}SRC\text{-}0103,\ \text{SpanAtIndex}(T,i))}$$

**(Span-Prohibited)**
$$\frac{i = \min\{ p \mid 0 \le p < |T| \land \text{Prohibited}(T[p]) \land O[p] \notin \text{LiteralSpan}(T) \}}{\Gamma \vdash \text{Emit}(E\text{-}SRC\text{-}0104,\ \text{SpanAtIndex}(T,i))}$$

**(NoSpan-Decode)**
$$\frac{}{\Gamma \vdash \text{Emit}(E\text{-}SRC\text{-}0101,\ \bot)}$$

### 3.2. Lexical Analysis

#### 3.2.1. Inputs, Outputs, and Records

**LexerInput.**
$$T = S.\text{scalars}$$
$$B = S.\text{text}$$
$$n = S.\text{byte\_len}$$
$$\text{LexerInput}(S) = \langle T,\ B,\ n \rangle$$

**LexerOutput.**
$$\text{LexerOutput}(S) = \langle K,\ D \rangle$$
$$K \in \text{Token}^\ast \quad D \in \text{DocComment}^\ast$$

**EOF Token.**
$$\text{EOFSpan}(S) = \text{SpanOfText}(S,\ |T|,\ |T|)$$
$$\text{TokenEOF}(S) = \langle \text{EOF},\ \epsilon,\ \text{EOFSpan}(S) \rangle$$

**LexemeBinding.**
$$\text{TokenRange}(S,t) = (i,j) \iff t.\text{span} = \text{SpanOfText}(S,i,j)$$
$$\text{LexemeBinding}(S,T,K) \iff \forall t \in K.\ \exists i,j.\ \text{TokenRange}(S,t)=(i,j) \land t.\text{lexeme} = \text{Lexeme}(T,i,j)$$

**DocComment.**

$$\text{DocComment} = \langle \text{kind},\ \text{text},\ \text{span} \rangle$$

$$\text{DocKind} = \{\text{LineDoc},\ \text{ModuleDoc}\}$$
$$\text{StripLeadingSpace}(s) = \begin{cases}
s[1..|s|) & |s|>0 \land \text{At}(s,0)=\text{U+0020} \\
s & \text{otherwise}
\end{cases}$$
$$\text{DocBody}(T,i,j) = \text{StripLeadingSpace}(T[i+3..j))$$
$$\text{DocMarker}(T,i) = \begin{cases}\text{LineDoc} & T[i..i+3]=\texttt{"///"} \\ \text{ModuleDoc} & T[i..i+3]=\texttt{"//!"} \\ \bot & \text{otherwise}\end{cases}$$

**Newline Tokens.**
$$\text{NewlineTokenAt}(S,T,i) \iff T[i]=\text{LF} \land \neg \text{InsideLiteralOrComment}(i)$$
$$\text{LexNewline}(K,S) \iff \forall i.\ \text{NewlineTokenAt}(S,T,i) \Rightarrow \exists t \in K.\ t.\text{kind}=\text{Newline} \land \text{TokenRange}(S,t)=(i,i+1)$$
$$\text{TokenInComment}(S,t) \iff \exists i,j,a,b.\ \text{TokenRange}(S,t)=(i,j) \land (\text{LineCommentRange}(T,a,b) \lor \text{BlockCommentRange}(T,a,b)) \land a \le i \land j \le b$$
$$\text{LexNoComments}(K,S) \iff \forall t \in K.\ \neg \text{TokenInComment}(S,t)$$

**Indices and Lexemes.**
$$T = S.\text{scalars}$$
$$O = \text{Utf8Offsets}(T)$$
$$\text{ScalarIndex}(T) = \{i \mid 0 \le i \le |T|\}$$

$$\text{ByteOf}(T,i) = O[i]$$

$$\text{SpanOfText}(S,i,j) = \text{SpanOf}(S,\ \text{ByteOf}(T,i),\ \text{ByteOf}(T,j))$$

$$\text{Lexeme}(T,i,j) = T[i..j)$$

#### 3.2.2. Character Classes

$$c \in \text{UnicodeScalar}$$

**Whitespace.**

$$\text{Whitespace}(c) \iff c \in \{\text{U+0020},\ \text{U+0009},\ \text{U+000C}\}$$

**Line Feed.**

$$\text{LineFeed}(c) \iff c = \text{U+000A}$$

**Identifier Characters.**
$$\text{XID\_Start} : \text{UnicodeScalar} \to \text{Bool}$$
$$\text{XID\_Continue} : \text{UnicodeScalar} \to \text{Bool}$$

$$\text{IdentStart}(c) \iff c = \texttt{'_'} \lor \text{XID\_Start}(c)$$
$$\text{IdentContinue}(c) \iff c = \texttt{'_'} \lor \text{XID\_Continue}(c)$$

$$\text{XIDVersion} = \texttt{"15.0.0"}$$
$$\text{XID\_Start}(c) \iff c \in \text{UAX31\_XID\_Start}_{15.0.0}$$
$$\text{XID\_Continue}(c) \iff c \in \text{UAX31\_XID\_Continue}_{15.0.0}$$

**Non-Characters.**

$$\text{NonCharacter}(c) \iff c \in [\text{U+FDD0},\text{U+FDEF}] \lor (c \mathbin{\&} \texttt{0xFFFF}) \in \{\texttt{0xFFFE},\ \texttt{0xFFFF}\}$$

**Digits.**

$$\text{DecDigit}(c) \iff c \in \{\texttt{'0'} \ldots \texttt{'9'}\}$$
$$\text{HexDigit}(c) \iff \text{DecDigit}(c) \lor c \in \{\texttt{'a'}\ldots\texttt{'f'},\ \texttt{'A'}\ldots\texttt{'F'}\}$$
$$\text{OctDigit}(c) \iff c \in \{\texttt{'0'}\ldots\texttt{'7'}\}$$
$$\text{BinDigit}(c) \iff c \in \{\texttt{'0'},\ \texttt{'1'}\}$$

**Lexically Sensitive Characters.**

$$\text{Sensitive}(c) \iff c \in \{\text{U+202A} \ldots \text{U+202E},\ \text{U+2066} \ldots \text{U+2069},\ \text{U+200C},\ \text{U+200D}\}$$

#### 3.2.3. Reserved Lexemes

**Reserved.**
$$\text{Reserved} = \{\texttt{"as"},\ \texttt{"break"},\ \texttt{"class"},\ \texttt{"continue"},\ \texttt{"else"},\ \texttt{"enum"},\ \texttt{"false"},\ \texttt{"defer"},\ \texttt{"frame"},\ \texttt{"if"},\ \texttt{"imm"},\ \texttt{"import"},\ \texttt{"internal"},\ \texttt{"let"},\ \texttt{"loop"},\ \texttt{"match"},\ \texttt{"modal"},\ \texttt{"move"},\ \texttt{"mut"},\ \texttt{"null"},\ \texttt{"private"},\ \texttt{"procedure"},\ \texttt{"protected"},\ \texttt{"public"},\ \texttt{"record"},\ \texttt{"region"},\ \texttt{"result"},\ \texttt{"return"},\ \texttt{"shadow"},\ \texttt{"shared"},\ \texttt{"transition"},\ \texttt{"transmute"},\ \texttt{"true"},\ \texttt{"type"},\ \texttt{"unique"},\ \texttt{"unsafe"},\ \texttt{"var"},\ \texttt{"widen"},\ \texttt{"using"},\ \texttt{"const"},\ \texttt{"override"}\}$$

$$\text{FutureReserved} = \emptyset$$

**Keyword Predicate.**
$$\text{Keyword}(s) \iff s \in \text{Reserved}$$

**Reserved Namespaces.**
$$\text{ReservedNamespacePrefix} = \{\texttt{"cursive."}\}$$
$$\text{ReservedIdentPrefix} = \{\texttt{"gen\_"}\}$$
$$\text{ReservedNamespacePhase} = \text{Phase3}$$

**Universe-Protected Bindings.**
$$\text{UniverseProtected} = \{\texttt{"i8"},\ \texttt{"i16"},\ \texttt{"i32"},\ \texttt{"i64"},\ \texttt{"i128"},\ \texttt{"u8"},\ \texttt{"u16"},\ \texttt{"u32"},\ \texttt{"u64"},\ \texttt{"u128"},\ \texttt{"f16"},\ \texttt{"f32"},\ \texttt{"f64"},\ \texttt{"bool"},\ \texttt{"char"},\ \texttt{"usize"},\ \texttt{"isize"},\ \texttt{"Self"},\ \texttt{"Drop"},\ \texttt{"Bitcopy"},\ \texttt{"Clone"},\ \texttt{"string"},\ \texttt{"bytes"},\ \texttt{"Modal"},\ \texttt{"Region"},\ \texttt{"RegionOptions"},\ \texttt{"Context"},\ \texttt{"System"},\ \texttt{"Async"},\ \texttt{"Future"},\ \texttt{"Sequence"},\ \texttt{"Stream"},\ \texttt{"Pipe"},\ \texttt{"Exchange"}\}$$
$$\text{UniverseProtectedPhase} = \text{Phase3}$$

#### 3.2.4. Token Kinds

$$\text{TokenKind} \in \{\text{Identifier},\ \text{Keyword}(k),\ \text{IntLiteral},\ \text{FloatLiteral},\ \text{StringLiteral},\ \text{CharLiteral},\ \text{BoolLiteral},\ \text{NullLiteral},\ \text{Operator}(o),\ \text{Punctuator}(p),\ \text{Newline},\ \text{Unknown}\}$$

**Operator Set.**
$$\text{OperatorSet} = \{\texttt{"+"},\ \texttt{"-"},\ \texttt{"*"},\ \texttt{"/"},\ \texttt{"%"},\ \texttt{"**"},\ \texttt{"=="},\ \texttt{"!="},\ \texttt{"<"},\ \texttt{"<="},\ \texttt{">"},\ \texttt{">="},\ \texttt{"&&"},\ \texttt{"||"},\ \texttt{"!"},\ \texttt{"&"},\ \texttt{"|"},\ \texttt{"^"},\ \texttt{"<<"},\ \texttt{">>"},\ \texttt{"="},\ \texttt{"+="},\ \texttt{"-="},\ \texttt{"*="},\ \texttt{"/="},\ \texttt{"%="},\ \texttt{"&="},\ \texttt{"|="},\ \texttt{"^="},\ \texttt{"<<="},\ \texttt{">>="},\ \texttt{":="},\ \texttt{"<:"},\ \texttt{".."},\ \texttt{"..="},\ \texttt{"=>"},\ \texttt{"->"},\ \texttt{"::"},\ \texttt{"~"},\ \texttt{"~>"},\ \texttt{"~!"},\ \texttt{"?"},\ \texttt{"#"},\ \texttt{"@"},\ \texttt{"$"}\}$$

**Punctuator Set.**
$$\text{PunctuatorSet} = \{\texttt{"("},\ \texttt{")"},\ \texttt{"["},\ \texttt{"]"},\ \texttt{"{"},\ \texttt{"}"},\ \texttt{","},\ \texttt{":"},\ \texttt{";"},\ \texttt{"."}\}$$

$$\text{OperatorSet} \cap \text{PunctuatorSet} = \emptyset$$

#### 3.2.5. Comment and Whitespace Scanning

$$T = S.\text{scalars}$$

**Line Comment Scan.**

**(Scan-Line-Comment)**
$$\frac{T[i]=\texttt{'/'} \quad T[i+1]=\texttt{'/'} \quad j = \min\{p \mid i \le p \land (p = |T| \lor T[p]=\text{LF})\}}{\Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j}$$

**Doc Comment Classification.**
$$\text{kind} = \text{DocMarker}(T,i)$$
$$\text{body} = \text{DocBody}(T,i,j)$$

**(Doc-Comment)**
$$\frac{\Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j \quad \text{kind} \ne \bot}{\Gamma \vdash \text{DocComment}(T,i) \Downarrow \langle \text{kind},\ \text{body},\ \text{SpanOfText}(S,i,j) \rangle}$$

$$\text{LineCommentTokens}(T,i) = []$$
$$\text{LineCommentNext}(T,i) = j \ \text{where}\ \Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j$$

**Block Comment Scan (Nested).**
$$\text{BlockState} = \{ \text{BlockScan}(T,i,d,i_0) \mid 0 \le i_0 \le i \le |T| \land d \in \mathbb{N} \} \cup \{ \text{BlockDone}(j) \mid 0 \le j \le |T| \}$$

**(Block-Start)**
$$\frac{T[i]=\texttt{'/'} \quad T[i+1]=\texttt{'*'}}{\langle \text{BlockScan}(T,i,d,i_0) \rangle \to \langle \text{BlockScan}(T,i+2,d+1,i_0) \rangle}$$

**(Block-End)**
$$\frac{T[i]=\texttt{'*'} \quad T[i+1]=\texttt{'/'} \quad d>1}{\langle \text{BlockScan}(T,i,d,i_0) \rangle \to \langle \text{BlockScan}(T,i+2,d-1,i_0) \rangle}$$

**(Block-Done)**
$$\frac{T[i]=\texttt{'*'} \quad T[i+1]=\texttt{'/'} \quad d=1}{\langle \text{BlockScan}(T,i,d,i_0) \rangle \to \langle \text{BlockDone}(i+2) \rangle}$$

**(Block-Step)**
$$\frac{T[i..i+2] \ne "/*" \quad T[i..i+2] \ne "*/"}{\langle \text{BlockScan}(T,i,d,i_0) \rangle \to \langle \text{BlockScan}(T,i+1,d,i_0) \rangle}$$

**(Block-Comment-Unterminated)**
$$\frac{\langle \text{BlockScan}(T,i,d,i_0) \rangle \to^\ast \langle \text{BlockScan}(T,|T|,d,i_0) \rangle \quad d > 0 \quad c = \text{Code}(\text{Block-Comment-Unterminated})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i_0,i_0+2))}$$

#### 3.2.6. Literal Lexing

$$T = S.\text{scalars}$$

**Syntax.**

```ebnf
integer_literal  ::= (decimal_integer | hex_integer | octal_integer | binary_integer) int_suffix?
decimal_integer  ::= dec_digit ("_"* dec_digit)*
hex_integer      ::= "0x" hex_digit ("_"* hex_digit)*
octal_integer    ::= "0o" oct_digit ("_"* oct_digit)*
binary_integer   ::= "0b" bin_digit ("_"* bin_digit)*
int_suffix       ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"

float_literal ::= decimal_integer "." decimal_integer? exponent? float_suffix?
exponent      ::= ("e" | "E") ("+" | "-")? decimal_integer
float_suffix  ::= "f16" | "f32" | "f64"

string_literal   ::= '"' (string_char | escape_sequence)* '"'
string_char      ::= string_char_unit
escape_sequence  ::= "\n" | "\r" | "\t" | "\\" | "\"" | "\'" | "\0" | "\x" hex_digit hex_digit | "\u{" hex_digit+ "}"

char_literal ::= "'" (char_content | escape_sequence) "'"
char_content ::= char_content_unit

bool_literal ::= "true" | "false"
null_literal ::= "null"
```

**Escape Validity.**
$$\text{SimpleEscape} = \{\texttt{"\\\\"},\ \texttt{"\\\""},\ \texttt{"\\'"},\ \texttt{"\\n"},\ \texttt{"\\r"},\ \texttt{"\\t"},\ \texttt{"\\0"}\}$$
$$\text{EscapeOk}(\texttt{"\\\\"}) \land \text{EscapeOk}(\texttt{"\\\""}) \land \text{EscapeOk}(\texttt{"\\'"}) \land \text{EscapeOk}(\texttt{"\\n"}) \land \text{EscapeOk}(\texttt{"\\r"}) \land \text{EscapeOk}(\texttt{"\\t"}) \land \text{EscapeOk}(\texttt{"\\0"})$$
$$\text{EscapeOk}(\texttt{"\\x"}h_1h_2) \iff \text{HexDigit}(h_1) \land \text{HexDigit}(h_2)$$
$$\text{EscapeOk}(\texttt{"\\u\{"}h_1\ldots h_n\texttt{"\}"}) \iff 1 \le n \le 6 \land \text{UnicodeScalar}(\text{HexValue}(h_1\ldots h_n))$$

$$\text{StringChar}(c) \iff \text{UnicodeScalar}(c) \land c \ne \texttt{"\""} \land c \ne \texttt{"\\"} \land c \ne \text{U+000A}$$
$$\text{CharContent}(c) \iff \text{UnicodeScalar}(c) \land c \ne \texttt{"'"} \land c \ne \texttt{"\\"} \land c \ne \text{U+000A}$$
$$\text{string\_char\_unit} = \{ c \mid \text{StringChar}(c) \}$$
$$\text{char\_content\_unit} = \{ c \mid \text{CharContent}(c) \}$$

**Underscore Constraints.**
$$\text{BasePrefix} = \{\texttt{"0x"},\ \texttt{"0o"},\ \texttt{"0b"}\}$$
$$\text{IntSuffixSet} = \{\texttt{"i8"},\ \texttt{"i16"},\ \texttt{"i32"},\ \texttt{"i64"},\ \texttt{"i128"},\ \texttt{"u8"},\ \texttt{"u16"},\ \texttt{"u32"},\ \texttt{"u64"},\ \texttt{"u128"},\ \texttt{"isize"},\ \texttt{"usize"}\}$$
$$\text{FloatSuffixSet} = \{\texttt{"f16"},\ \texttt{"f32"},\ \texttt{"f64"}\}$$
$$\text{NumSuffix} = \text{IntSuffixSet} \cup \text{FloatSuffixSet}$$
$$\text{StartsWithUnderscore}(s) \iff \text{At}(s,0)=\texttt{"\_"}$$
$$\text{EndsWithUnderscore}(s) \iff \text{At}(s,|s|-1)=\texttt{"\_"}$$
$$\text{AfterBasePrefixUnderscore}(s) \iff \exists p \in \text{BasePrefix}.\ \text{StartsWith}(s,\ \text{Concat}(p,\ \texttt{"\_"}))$$
$$\text{AdjacentExponentUnderscore}(s) \iff \exists i.\ \text{At}(s,i)=\texttt{"\_"} \land ((i>0 \land \text{At}(s,i-1)\in\{\texttt{"e"},\texttt{"E"}\}) \lor (i+1<|s| \land \text{At}(s,i+1)\in\{\texttt{"e"},\texttt{"E"}\}))$$
$$\text{BeforeSuffixUnderscore}(s) \iff \exists suf \in \text{NumSuffix}.\ \text{EndsWith}(s,\ \text{Concat}(\texttt{"\_"},\ suf))$$
$$\text{NumericUnderscoreOk}(s) \iff \neg \text{StartsWithUnderscore}(s) \land \neg \text{EndsWithUnderscore}(s) \land \neg \text{AfterBasePrefixUnderscore}(s) \land \neg \text{AdjacentExponentUnderscore}(s) \land \neg \text{BeforeSuffixUnderscore}(s)$$

**Numeric Scan (Maximal Prefix).**

$$\text{DecRun}(T,i) = \max(\{i\} \cup \{ j \mid i < j \le |T| \land \forall k \in [i,j).\ (\text{DecDigit}(T[k]) \lor T[k]=\texttt{"_"}) \})$$
$$\text{HexRun}(T,i) = \max(\{i\} \cup \{ j \mid i < j \le |T| \land \forall k \in [i,j).\ (\text{HexDigit}(T[k]) \lor T[k]=\texttt{"_"}) \})$$
$$\text{OctRun}(T,i) = \max(\{i\} \cup \{ j \mid i < j \le |T| \land \forall k \in [i,j).\ (\text{OctDigit}(T[k]) \lor T[k]=\texttt{"_"}) \})$$
$$\text{BinRun}(T,i) = \max(\{i\} \cup \{ j \mid i < j \le |T| \land \forall k \in [i,j).\ (\text{BinDigit}(T[k]) \lor T[k]=\texttt{"_"}) \})$$

$$\text{SuffixMatch}(T,i,U) = \max(\{i\} \cup \{ j \mid i < j \le |T| \land \text{Lexeme}(T,i,j) \in U \})$$

$$\text{ExpSignEnd}(T,i) = \begin{cases}
 i+1 & i<|T| \land T[i] \in \{\texttt{"+"},\texttt{"-"}\} \\
 i & \text{otherwise}
\end{cases}$$

$$\text{ExpEnd}(T,i) = \begin{cases}
\text{DecRun}(T,\text{ExpSignEnd}(T,i+1)) & i<|T| \land T[i] \in \{\texttt{"e"},\texttt{"E"}\} \\
 i & \text{otherwise}
\end{cases}$$

$$\text{DecCoreEnd}(T,i) = \begin{cases}
\text{ExpEnd}(T,q) & p=\text{DecRun}(T,i) \land p<|T| \land T[p]=\texttt{"."} \land q=\text{DecRun}(T,p+1) \\
\text{ExpEnd}(T,p) & p=\text{DecRun}(T,i) \land (p \ge |T| \lor T[p] \ne \texttt{"."})
\end{cases}$$

$$\text{NumericCoreEnd}(T,i) = \begin{cases}
\text{HexRun}(T,i+2) & T[i..i+2]=\texttt{"0x"} \\
\text{OctRun}(T,i+2) & T[i..i+2]=\texttt{"0o"} \\
\text{BinRun}(T,i+2) & T[i..i+2]=\texttt{"0b"} \\
\text{DecCoreEnd}(T,i) & \text{otherwise}
\end{cases}$$

$$\text{NumericScanEnd}(T,i) = \text{SuffixMatch}(T,\text{NumericCoreEnd}(T,i),\text{NumSuffix})$$

$$\text{HasDot}(T,i,j) \iff \exists p.\ i \le p < j \land T[p]=\texttt{"."}$$
$$\text{HasExp}(T,i,j) \iff \exists p.\ i \le p < j \land T[p] \in \{\texttt{"e"},\texttt{"E"}\}$$

$$\text{NumericKind}(T,i) = \begin{cases}
\text{FloatLiteral} & \text{SuffixMatch}(T,\text{NumericCoreEnd}(T,i),\text{FloatSuffixSet}) > \text{NumericCoreEnd}(T,i) \\
\text{FloatLiteral} & \text{HasDot}(T,i,\text{NumericCoreEnd}(T,i)) \lor \text{HasExp}(T,i,\text{NumericCoreEnd}(T,i)) \\
\text{IntLiteral} & \text{otherwise}
\end{cases}$$

**(Lex-Int)**
$$\frac{\text{DecDigit}(T[i]) \quad j=\text{NumericScanEnd}(T,i) \quad \text{NumericKind}(T,i)=\text{IntLiteral}}{\Gamma \vdash \text{IntLiteral}(T,i) \Downarrow j}$$

**(Lex-Float)**
$$\frac{\text{DecDigit}(T[i]) \quad j=\text{NumericScanEnd}(T,i) \quad \text{NumericKind}(T,i)=\text{FloatLiteral}}{\Gamma \vdash \text{FloatLiteral}(T,i) \Downarrow j}$$

$$\text{NumericLexemeOk}(T,i,j) \iff (\text{Lexeme}(T,i,j)\ \text{matches}\ \text{integer\_literal} \lor \text{Lexeme}(T,i,j)\ \text{matches}\ \text{float\_literal}) \land \text{NumericUnderscoreOk}(\text{Lexeme}(T,i,j))$$
$$\text{NumericLexemeBad}(T,i,j) \iff \neg \text{NumericLexemeOk}(T,i,j)$$

**(Lex-Numeric-Err)**
$$\frac{\text{DecDigit}(T[i]) \quad j=\text{NumericScanEnd}(T,i) \quad \text{NumericLexemeBad}(T,i,j) \quad c = \text{Code}(\text{Lex-Numeric-Err})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,j))}$$

**Leading Zeros.**
$$\text{Digits}(s) = \text{Remove}(s,\ \texttt{"\_"})$$
$$\text{DecimalLeadingZero}(T,i,j) \iff \text{Lexeme}(T,i,j)\ \text{matches}\ \text{decimal\_integer} \land |\text{Digits}(\text{Lexeme}(T,i,j))| > 1 \land \text{At}(\text{Digits}(\text{Lexeme}(T,i,j)),0)=\texttt{'0'}$$

$$\frac{\text{DecimalLeadingZero}(T,i,j)}{\Gamma \vdash \text{Emit}(W\text{-}SRC\text{-}0301,\ \text{SpanOfText}(S,i,j))}$$

**EscapeSequences.**
$$\text{EscapeValue}(\texttt{"\\\\"}) = \texttt{0x5C}$$
$$\text{EscapeValue}(\texttt{"\\\""}) = \texttt{0x22}$$
$$\text{EscapeValue}(\texttt{"\\'"}) = \texttt{0x27}$$
$$\text{EscapeValue}(\texttt{"\\n"}) = \texttt{0x0A}$$
$$\text{EscapeValue}(\texttt{"\\r"}) = \texttt{0x0D}$$
$$\text{EscapeValue}(\texttt{"\\t"}) = \texttt{0x09}$$
$$\text{EscapeValue}(\texttt{"\\0"}) = \texttt{0x00}$$
$$\text{EscapeValue}(\texttt{"\\x"}h_1h_2) = \text{HexValue}(h_1h_2)$$
$$\text{EscapeValue}(\texttt{"\\u\{"}h_1\ldots h_n\texttt{"\}"}) = \text{EncodeUTF8}(\text{HexValue}(h_1\ldots h_n))$$

**(Lex-String)**
$$\frac{\text{Lexeme}(T,i,j) \text{ matches } \text{string\_literal}}{\Gamma \vdash \text{StringLiteral}(T,i) \Downarrow j}$$

$$\text{BackslashCount}(T,p) = \max\{k \mid 0 \le k \le p \land \forall r \in [p-k,p).\ T[r]=\texttt{"\\"}\}$$
$$\text{UnescapedQuote}(T,p) \iff T[p]=\texttt{"\""} \land \text{BackslashCount}(T,p)\bmod 2 = 0$$
$$\text{StringTerminator}(T,i) = \min\{q \mid q>i \land (\text{UnescapedQuote}(T,q) \lor T[q]=\text{LF} \lor q=|T|)\}$$
$$\text{LineFeedOrEOFBeforeClose}(T,i) \iff \text{StringTerminator}(T,i)=|T| \lor T[\text{StringTerminator}(T,i)]=\text{LF}$$
$$\text{EscapeMatch}(T,p,q) \iff \text{Lexeme}(T,p,q)\ \text{matches}\ \text{escape\_sequence} \land \text{EscapeOk}(\text{Lexeme}(T,p,q))$$
$$\text{BadEscapeAt}(T,p) \iff T[p]=\texttt{"\\"} \land \neg \exists q.\ \text{EscapeMatch}(T,p,q)$$
$$\text{FirstBadEscape}(T,i) = \min\{p \mid i < p < \text{StringTerminator}(T,i) \land \text{BadEscapeAt}(T,p)\}$$

**(Lex-String-Unterminated)**
$$\frac{\text{LineFeedOrEOFBeforeClose}(T,i) \quad c = \text{Code}(\text{Lex-String-Unterminated})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,i+1))}$$

**(Lex-String-BadEscape)**
$$\frac{\text{FirstBadEscape}(T,i) = p \quad c = \text{Code}(\text{Lex-String-BadEscape})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,p,p+1))}$$

**(Lex-Char)**
$$\frac{\text{Lexeme}(T,i,j) \text{ matches } \text{char\_literal}}{\Gamma \vdash \text{CharLiteral}(T,i) \Downarrow j}$$

**Character Literal Encoding.**
$$\text{CharValueRange} = \{x \mid 0 \le x \le \texttt{0x10FFFF} \land x \notin [\texttt{0xD800},\ \texttt{0xDFFF}]\}$$
$$\text{CharRepr} = \texttt{u32}$$
$$\text{SizeOf}(\texttt{char}) = 4$$
$$\text{AlignOf}(\texttt{char}) = 4$$

$$\text{UnescapedApostrophe}(T,p) \iff T[p]=\texttt{"'"} \land \text{BackslashCount}(T,p)\bmod 2 = 0$$
$$\text{CharTerminator}(T,i) = \min\{q \mid q>i \land (\text{UnescapedApostrophe}(T,q) \lor T[q]=\text{LF} \lor q=|T|)\}$$
$$\text{CharLiteralInvalid}(T,i) \iff \text{CharScalarCount}(T,i) \ne 1$$
$$\text{CharScalarCountFrom}(T,p,q) = 0 \iff p \ge q$$
$$\text{CharScalarCountFrom}(T,p,q) = 1 + \text{CharScalarCountFrom}(T,p+1,q) \iff p < q \land T[p] \ne \texttt{"\\"}$$
$$\text{CharScalarCountFrom}(T,p,q) = 1 + \text{CharScalarCountFrom}(T,r,q) \iff p < q \land T[p]=\texttt{"\\"} \land \text{EscapeMatch}(T,p,r)$$
$$\text{CharScalarCountFrom}(T,p,q) = 1 + \text{CharScalarCountFrom}(T,p+1,q) \iff p < q \land T[p]=\texttt{"\\"} \land \neg \exists r.\ \text{EscapeMatch}(T,p,r)$$
$$\text{CharScalarCount}(T,i) = \text{CharScalarCountFrom}(T,i+1,\text{CharTerminator}(T,i))$$

**(Lex-Char-Unterminated)**
$$\frac{\text{LineFeedOrEOFBeforeClose}(T,i) \quad c = \text{Code}(\text{Lex-Char-Unterminated})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,i+1))}$$

**(Lex-Char-BadEscape)**
$$\frac{\text{FirstBadEscape}(T,i) = p \quad c = \text{Code}(\text{Lex-Char-BadEscape})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,p,p+1))}$$

**(Lex-Char-Invalid)**
$$\frac{\text{CharLiteralInvalid}(T,i) \quad c = \text{Code}(\text{Lex-Char-Invalid})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,i+1))}$$

**Literal Tokenization Helpers.**

$$\text{StringTok}(T,i) = \{ (\text{StringLiteral},j) \mid \text{StringLiteral}(T,i) \Downarrow j \}$$
$$\text{CharTok}(T,i) = \{ (\text{CharLiteral},j) \mid \text{CharLiteral}(T,i) \Downarrow j \}$$
$$\text{IntTok}(T,i) = \{ (\text{IntLiteral},j) \mid \text{IntLiteral}(T,i) \Downarrow j \}$$
$$\text{FloatTok}(T,i) = \{ (\text{FloatLiteral},j) \mid \text{FloatLiteral}(T,i) \Downarrow j \}$$

#### 3.2.7. Identifier and Keyword Lexing

$$T = S.\text{scalars}$$

**Identifier Scan.**
$$\text{IdentScanEnd}(T,i) = \min\{j \mid j>i \land (\neg \text{IdentContinue}(T[j]) \lor j=|T|) \land \forall k \in (i,j).\ \text{IdentContinue}(T[k])\}$$

**(Lex-Identifier)**
$$\frac{\text{IdentStart}(T[i]) \quad j=\text{IdentScanEnd}(T,i) \quad s=\text{Lexeme}(T,i,j)}{\Gamma \vdash \text{Ident}(T,i) \Downarrow (s,j)}$$

**(Lex-Ident-InvalidUnicode)**
$$\frac{k = \min\{p \mid i \le p < j \land \text{NonCharacter}(T[p])\} \quad c = \text{Code}(\text{Lex-Ident-InvalidUnicode})}{\Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,k,k+1))}$$

**(Lex-Ident-Token)**
$$\frac{\Gamma \vdash \text{Ident}(T,i) \Downarrow (s,j) \quad \Gamma \vdash \text{ClassifyIdent}(s) \Downarrow k}{\Gamma \vdash \text{IdentToken}(T,i) \Downarrow (k,j)}$$

**Keyword Classification.**
$$\text{ClassifyIdent}(s) = \begin{cases}
\text{BoolLiteral} & s \in \{\texttt{"true"},\ \texttt{"false"}\} \\
\text{NullLiteral} & s = \texttt{"null"} \\
\text{Keyword}(s) & \text{Keyword}(s) \\
\text{Identifier} & \text{otherwise}
\end{cases}$$

#### 3.2.8. Operator and Punctuator Lexing

$$\text{OpSet} = \text{OperatorSet}$$
$$\text{PuncSet} = \text{PunctuatorSet}$$

$$\text{OpMatch}(T,i) = \{ (o,j) \mid o \in \text{OpSet} \land \text{Lexeme}(T,i,j) = o \}$$
$$\text{PuncMatch}(T,i) = \{ (p,j) \mid p \in \text{PuncSet} \land \text{Lexeme}(T,i,j) = p \}$$

$$\text{OpTok}(T,i) = \{ (\text{Operator}(o),j) \mid (o,j) \in \text{OpMatch}(T,i) \}$$
$$\text{PuncTok}(T,i) = \{ (\text{Punctuator}(p),j) \mid (p,j) \in \text{PuncMatch}(T,i) \}$$

#### 3.2.9. Maximal-Munch Rule

$$T = S.\text{scalars}$$

$$\text{IsQuote}(c) \iff c \in \{\texttt{"\""},\ \texttt{"'"}\}$$
$$\text{Candidates}(T,i) = \begin{cases}
\text{StringTok}(T,i) \cup \text{CharTok}(T,i) & \text{IsQuote}(T[i]) \\
\text{FloatTok}(T,i) \cup \text{IntTok}(T,i) & \text{DecDigit}(T[i]) \\
\text{IdentToken}(T,i) & \text{IdentStart}(T[i]) \\
\text{OpTok}(T,i) \cup \text{PuncTok}(T,i) & \text{OpTok}(T,i)\ne \varnothing \lor \text{PuncTok}(T,i)\ne \varnothing \\
\varnothing & \text{otherwise}
\end{cases}$$

$$\text{Longest}(C) = \{ (k,j) \in C \mid \forall (k',j') \in C,\ j \ge j' \}$$

$$\text{KindPriority}(\text{IntLiteral}) = 3$$
$$\text{KindPriority}(\text{FloatLiteral}) = 3$$
$$\text{KindPriority}(\text{StringLiteral}) = 3$$
$$\text{KindPriority}(\text{CharLiteral}) = 3$$
$$\text{KindPriority}(\text{BoolLiteral}) = 3$$
$$\text{KindPriority}(\text{NullLiteral}) = 3$$
$$\text{KindPriority}(\text{Identifier}) = 2$$
$$\text{KindPriority}(\text{Keyword}(\_)) = 2$$
$$\text{KindPriority}(\text{Operator}(\_)) = 1$$
$$\text{KindPriority}(\text{Punctuator}(\_)) = 0$$

$$\text{PickLongest}(C) = \arg\max_{(k,j)\in C}\ \langle j,\ \text{KindPriority}(k)\rangle$$

**(Max-Munch)**
$$\frac{\text{PickLongest}(C) = (k,j)}{\Gamma \vdash \text{NextToken}(T,i) \Downarrow (k,j)}$$

**(Max-Munch-Err)**
$$\frac{\text{Candidates}(T,i)=\varnothing \quad c = \text{Code}(\text{Max-Munch-Err})}{\Gamma \vdash \text{NextToken}(T,i) \Uparrow c}$$

$$\text{SpanOfErr}(\text{Max-Munch-Err},S,i) = \text{SpanOfText}(S,i,i+1)$$

$$\text{GenericCloseException} = \text{false}$$

#### 3.2.10. Lexical Security

$$T = S.\text{scalars}$$
$$O = \text{Utf8Offsets}(T)$$

**Literal/Comment Ranges.**
$$\text{LineCommentRange}(T,i,j) \iff \Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j$$
$$\text{BlockCommentRange}(T,i,j) \iff T[i..i+2]=\texttt{"/*"} \land \langle \text{BlockScan}(T,i,0,i) \rangle \to^\ast \langle \text{BlockDone}(j) \rangle$$
$$\text{StringRange}(T,i,j) \iff \Gamma \vdash \text{StringLiteral}(T,i) \Downarrow j$$
$$\text{CharRange}(T,i,j) \iff \Gamma \vdash \text{CharLiteral}(T,i) \Downarrow j$$
$$\text{InsideLiteralOrComment}(i) \iff \exists a,b.\ a \le i < b \land (\text{LineCommentRange}(T,a,b) \lor \text{BlockCommentRange}(T,a,b) \lor \text{StringRange}(T,a,b) \lor \text{CharRange}(T,a,b))$$

**Sensitive Positions in a Span.**

$$\text{SensitiveInSpan}(T,i,j) = [\ p\ \mid\ i \le p < j \land \text{Sensitive}(T[p])\ ]$$

**Unsafe Spans (Token-Only).**

$$\text{IsLBrace}(t) \iff t.\text{kind} = \text{Punctuator}(\texttt{"{"})$$
$$\text{IsRBrace}(t) \iff t.\text{kind} = \text{Punctuator}(\texttt{"}"})$$

$$\text{NextNonNewline}(K,i) = \bot \iff \{ j \mid j \ge i \land K[j].\text{kind} \ne \text{Newline} \} = \emptyset$$
$$\text{NextNonNewline}(K,i) = j \iff j = \min\{ j \mid j \ge i \land K[j].\text{kind} \ne \text{Newline} \}$$

$$\text{MatchBrace}(K,j) = \min\{k \mid k>j \land \text{Balance}(j,k)=0 \land \forall m \in (j,k),\ \text{Balance}(j,m) > 0\}$$

$$\text{Balance}(K,j,m) = |\{x \mid j \le x \le m \land \text{IsLBrace}(K[x])\}| - |\{x \mid j \le x \le m \land \text{IsRBrace}(K[x])\}|$$
$$\text{MatchBrace}(K,j) = \bot \iff \{k \mid k>j \land \text{Balance}(K,j,k)=0 \land \forall m \in (j,k).\ \text{Balance}(K,j,m) > 0\} = \emptyset$$

$$\text{SpanFrom}(t_a,t_b) = \langle t_a.\text{span.file},\ t_a.\text{span.start\_offset},\ t_b.\text{span.end\_offset},\ t_a.\text{span.start\_line},\ t_a.\text{span.start\_col},\ t_b.\text{span.end\_line},\ t_b.\text{span.end\_col} \rangle$$

$$\text{UnsafeSpans}(K) = \{\ \text{SpanFrom}(K[j],K[k])\ \mid\ K[i].\text{kind}=\text{Keyword}(\texttt{"unsafe"}),\ j=\text{NextNonNewline}(K,i+1),\ K[j].\text{kind}=\text{Punctuator}(\texttt{"{"}),\ k=\text{MatchBrace}(K,j),\ k \ne \bot\ \}$$

$$\text{UnsafeAtByte}(b) \iff \exists sp \in \text{UnsafeSpans}(K).\ b \in \text{SpanRange}(sp)$$

$$\text{UnsafeSpanMode} = \text{TokenOnly}$$

**Lexical Security Check.**
$$\text{Sens} = [\ p\ \mid\ \text{Sensitive}(T[p]) \land \neg \text{InsideLiteralOrComment}(p)\ ]$$

**(LexSecure-Err)**
$$\frac{i = \min\{p \mid p \in \text{Sens} \land \neg \text{UnsafeAtByte}(\text{ByteOf}(T,p))\} \quad c = \text{Code}(\text{LexSecure-Err})}{\Gamma \vdash \text{LexSecure}(S,K,\text{Sens}) \Uparrow c}$$

**(LexSecure-Warn)**
$$\frac{\forall p \in \text{Sens},\ \text{UnsafeAtByte}(\text{ByteOf}(T,p)) \quad \Gamma \vdash \text{EmitList}(\text{LexSecureWarns}(S,\text{Sens}))}{\Gamma \vdash \text{LexSecure}(S,K,\text{Sens}) \Downarrow ok}$$

$$\text{LexSecureWarns}(S,\text{Sens}) = [\ \langle W\text{-}SRC\text{-}0308,\ \text{SpanOfText}(S,p,p+1)\rangle\ \mid\ p \in \text{Sens}\ ]$$
$$\text{LexSecureErrSpan}(S,i) = \text{SpanOfText}(S,i,i+1)$$

#### 3.2.11. Tokenization (Small-Step)

$$\text{LexState} = \{\text{LexStart}(S),\ \text{LexScan}(S,i,K,D,Sens),\ \text{LexDone}(K,D,Sens),\ \text{LexError}(code)\}$$
$$T = S.\text{scalars}$$
$$|T| = \text{len}(T)$$

**(Lex-Start)**
$$\frac{}{ \langle \text{LexStart}(S) \rangle \to \langle \text{LexScan}(S,0,[],[],[]) \rangle }$$

**(Lex-End)**
$$\frac{i \ge |T|}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexDone}(K,D,\text{Sens}) \rangle}$$

**(Lex-Whitespace)**
$$\frac{\text{Whitespace}(T[i])}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,i+1,K,D,\text{Sens}) \rangle}$$

**(Lex-Newline)**
$$\frac{T[i]=\text{LF}}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,i+1,K\mathbin{+\!\!+}[\langle\text{newline},\text{Lexeme}(T,i,i+1),\text{SpanOfText}(S,i,i+1)\rangle],D,\text{Sens}) \rangle}$$

**(Lex-Line-Comment)**
$$\frac{T[i..i+2]="//" \quad T[i..i+3]\notin\{"///","//!"\} \quad \Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K,D,\text{Sens}) \rangle}$$

**(Lex-Doc-Comment)**
$$\frac{T[i..i+3]\in\{"///","//!"\} \quad \Gamma \vdash \text{ScanLineComment}(T,i) \Downarrow j \quad \Gamma \vdash \text{DocComment}(T,i) \Downarrow d}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K,D \mathbin{+\!\!+}[d],\text{Sens}) \rangle}$$

**(Lex-Block-Comment)**
$$\frac{T[i..i+2]="/*" \quad \langle \text{BlockScan}(T,i,0,i) \rangle \to^* \langle \text{BlockDone}(j) \rangle}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K,D,\text{Sens}) \rangle}$$

**(Lex-String-Unterminated-Recover)**
$$\frac{T[i]=\texttt{"\""} \quad \text{LineFeedOrEOFBeforeClose}(T,i) \quad c = \text{Code}(\text{Lex-String-Unterminated}) \quad \Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,i+1)) \quad j = \text{StringTerminator}(T,i)}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K,D,\text{Sens}) \rangle}$$

**(Lex-Char-Unterminated-Recover)**
$$\frac{T[i]=\texttt{"'"} \quad \text{LineFeedOrEOFBeforeClose}(T,i) \quad c = \text{Code}(\text{Lex-Char-Unterminated}) \quad \Gamma \vdash \text{Emit}(c,\ \text{SpanOfText}(S,i,i+1)) \quad j = \text{CharTerminator}(T,i)}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K,D,\text{Sens}) \rangle}$$

**(Lex-Sensitive)**
$$\frac{\text{Sensitive}(T[i])}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,i+1,K,D,\text{Sens}\mathbin{+\!\!+}[i]) \rangle}$$

$$\text{SensitiveTok}(T,i,j,k) = \begin{cases}
[] & \text{if } k \in \{\text{StringLiteral},\ \text{CharLiteral}\} \\
\text{SensitiveInSpan}(T,i,j) & \text{otherwise}
\end{cases}$$

**(Lex-Token)**
$$\frac{\neg \text{Whitespace}(T[i]) \quad T[i] \ne \text{LF} \quad T[i..i+2]\notin\{"//","/*"\} \quad \neg \text{Sensitive}(T[i]) \quad \Gamma \vdash \text{NextToken}(T,i) \Downarrow (k,j)}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexScan}(S,j,K \mathbin{+\!\!+} [\langle k,\ \text{Lexeme}(T,i,j),\ \text{SpanOfText}(S,i,j)\rangle],D,\text{Sens}\mathbin{+\!\!+}\text{SensitiveTok}(T,i,j,k)) \rangle}$$

**(Lex-Token-Err)**
$$\frac{\neg \text{Whitespace}(T[i]) \quad T[i] \ne \text{LF} \quad T[i..i+2]\notin\{"//","/*"\} \quad \neg (T[i]=\texttt{"\""} \land \text{LineFeedOrEOFBeforeClose}(T,i)) \quad \neg (T[i]=\texttt{"'"} \land \text{LineFeedOrEOFBeforeClose}(T,i)) \quad \neg \text{Sensitive}(T[i]) \quad \Gamma \vdash \text{NextToken}(T,i) \Uparrow c}{\langle \text{LexScan}(S,i,K,D,\text{Sens}) \rangle \to \langle \text{LexError}(c) \rangle}$$

#### 3.2.12. Tokenize (Big-Step)

**(Tokenize-Ok)**
$$\frac{\langle \text{LexStart}(S) \rangle \to^* \langle \text{LexDone}(K,D,\text{Sens}) \rangle \quad \Gamma \vdash \text{LexSecure}(S,K,\text{Sens}) \Downarrow ok}{\Gamma \vdash \text{Tokenize}(S) \Downarrow (K,D)}$$

**(Tokenize-Secure-Err)**
$$\frac{\langle \text{LexStart}(S) \rangle \to^* \langle \text{LexDone}(K,D,\text{Sens}) \rangle \quad \Gamma \vdash \text{LexSecure}(S,K,\text{Sens}) \Uparrow c}{\Gamma \vdash \text{Tokenize}(S) \Uparrow c}$$

**(Tokenize-Err)**
$$\frac{\langle \text{LexStart}(S) \rangle \to^* \langle \text{LexError}(c) \rangle}{\Gamma \vdash \text{Tokenize}(S) \Uparrow c}$$

$$\text{Phase1LexDiagRefs} = \{\texttt{"8.4"},\ \texttt{"8.5"},\ \texttt{"8.8"}\}$$

### 3.3. Grammar, Parsing, and AST Construction

#### 3.3.1. Inputs, Outputs, and Invariants

**Inputs.**
$$\text{ParseInputs}(U,K,D,K') \iff U = [S_1,\ldots,S_n] \land K = [K_1,\ldots,K_n] \land D = [D_1,\ldots,D_n] \land (\forall i.\ \Gamma \vdash \text{Tokenize}(S_i) \Downarrow (K_i,D_i)) \land K' = [\text{Filter}(K_i) \mid 1 \le i \le n]$$
$$\text{ParseUnitSources}(U) \iff \exists d,\ f_1,\ldots,f_n,\ B_1,\ldots,B_n.\ \text{CompilationUnit}(d) = [f_1,\ldots,f_n] \land U = [S_1,\ldots,S_n] \land \bigwedge_{i=1}^n (\Gamma \vdash \text{ReadBytes}(f_i) \Downarrow B_i \land \Gamma \vdash \text{LoadSource}(f_i,B_i) \Downarrow S_i)$$

**Outputs.**
$$\text{ParseOutputs}(U,F) \iff \Gamma \vdash \text{ParseUnit}(U) \Downarrow F$$
$$F = [F_1,\ldots,F_n]$$

$$\text{ModuleAggregationRef} = \{\texttt{"3.4.1"},\ \texttt{"3.4.2"}\}$$

**Parsing Phase Invariants.**

**(Phase1-Complete)**
$$\frac{\forall i,\ \Gamma \vdash \text{ParseFile}(S_i) \Downarrow F_i}{\Gamma \vdash \text{ParseUnit}(U) \Downarrow [F_1,\ldots,F_n]}$$

$$\text{PhaseExec}(\text{Phase1},U) \iff \Gamma \vdash \text{ParseUnit}(U) \Downarrow F$$
$$\forall p \in \{\text{Phase2},\text{Phase3},\text{Phase4}\}.\ \text{PhaseExec}(p,U) \Rightarrow \text{PhaseExec}(\text{Phase1},U)$$

**(Phase1-Declarations)**
$$\frac{\Gamma \vdash \text{ParseUnit}(U) \Downarrow [F_1,\ldots,F_n] \quad \forall i,\ F_i.\text{items} = I_i}{\Gamma \vdash \text{AllDecls}(U) = I_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} I_n}$$

**(Phase1-Forward-Refs)**
$$\frac{}{\Gamma \vdash \text{ParsePhase}(U) \Downarrow \text{NoResolutionConstraints}}$$

#### 3.3.2. AST Node Catalog (Cursive0 Subset)

$$\text{ASTNode} = \text{ASTItem} \cup \text{ASTExpr} \cup \text{ASTPattern} \cup \text{ASTType} \cup \text{ASTStmt}$$
$$\text{SpanOfNode} : \text{ASTNode} \to \text{Span}$$
$$\text{DocOf} : \text{ASTNode} \to (\text{DocList} \cup \{\bot\})$$

$$\text{SpanDefault}(P,P') = \text{SpanBetween}(P,P')$$
$$\text{DocDefault} = []$$
$$\text{DocOptDefault} = \bot$$
$$\text{FillSpan}(n,P,P') = \begin{cases}
n[\text{span} := \text{SpanDefault}(P,P')] & \text{if } \text{SpanMissing}(n)\\
n & \text{otherwise}
\end{cases}$$
$$\text{FillDoc}(n) = \begin{cases}
n[\text{doc} := \text{DocDefault}] & \text{if } \text{DocMissing}(n)\\
n & \text{otherwise}
\end{cases}$$
$$\text{FillDocOpt}(n) = \begin{cases}
n[\text{doc\_opt} := \text{DocOptDefault}] & \text{if } \text{DocOptMissing}(n)\\
n & \text{otherwise}
\end{cases}$$
$$\text{ParseCtor}(n,P,P') = \text{FillDocOpt}(\text{FillDoc}(\text{FillSpan}(n,P,P')))$$
$$\text{DocAssociationRef} = \{\texttt{"3.3.11"}\}$$

**Doc Lists.**

$$\text{DocList} = [\text{DocComment}]$$
$$\text{DocCommentRef} = \{\texttt{"3.2.1"}\}$$

**Paths.**

$$\text{Path} = [\text{identifier}]$$
$$\text{ModulePath} = \text{Path}$$
$$\text{TypePath} = \text{Path}$$
$$\text{ClassPath} = \text{Path}$$
$$\text{PathString}(p) = \text{StringOfPath}(p)$$
$$\text{StringOfPathRef} = \{\texttt{"3.4.1"}\}$$

##### 3.3.2.1. Module and Files

**ASTModule.**

$$\text{ASTModule} = \langle \text{path},\ \text{items},\ \text{module\_doc} \rangle$$
$$\text{ASTModule}.\text{path} \in \text{Path}$$
$$\text{ASTModule}.\text{items} \in [\text{ASTItem}]$$
$$\text{ASTModule}.\text{module\_doc} \in \text{DocList}$$

**ASTFile.**

$$\text{ASTFile} = \langle \text{path},\ \text{items},\ \text{module\_doc} \rangle$$
$$\text{ASTFile}.\text{path} \in \text{Path}$$
$$\text{ASTFile}.\text{items} \in [\text{ASTItem}]$$
$$\text{ASTFile}.\text{module\_doc} \in \text{DocList}$$

##### 3.3.2.2. Items

$$\text{ASTItem} \in \{\text{UsingDecl},\ \text{StaticDecl},\ \text{ProcedureDecl},\ \text{RecordDecl},\ \text{EnumDecl},\ \text{ModalDecl},\ \text{ClassDecl},\ \text{TypeAliasDecl},\ \text{ErrorItem}\}$$

**UsingDecl.**

$$\text{UsingDecl} = \langle \text{vis},\ \text{clause},\ \text{span},\ \text{doc} \rangle$$

**UsingClause.**

$$\text{UsingClause} \in \{\text{UsingPath} = \langle \text{path},\ \text{alias}\_opt \rangle,\ \text{UsingList} = \langle \text{module\_path},\ \text{specs} \rangle\}$$

$$\text{UsingSpec} = \langle \text{name},\ \text{alias}\_opt \rangle$$

**StaticDecl.**

$$\text{StaticDecl} = \langle \text{vis},\ \text{mut},\ \text{binding},\ \text{span},\ \text{doc} \rangle$$

$$\text{mut} \in \{\texttt{let},\ \texttt{var}\}$$

**ProcedureDecl.**

$$\text{ProcedureDecl} = \langle \text{vis},\ \text{name},\ \text{params},\ \text{return\_type}\_opt,\ \text{body},\ \text{span},\ \text{doc} \rangle$$

**RecordDecl.**

$$\text{RecordDecl} = \langle \text{vis},\ \text{name},\ \text{implements},\ \text{members},\ \text{span},\ \text{doc} \rangle$$

$$\text{RecordDecl}.\text{implements} \in [\text{ClassPath}]$$

$$\text{RecordMember} \in \{\text{FieldDecl} = \langle \text{vis},\ \text{name},\ \text{type},\ \text{init}\_opt,\ \text{span},\ \text{doc}\_opt \rangle,\ \text{MethodDecl} = \langle \text{vis},\ \text{override},\ \text{name},\ \text{receiver},\ \text{params},\ \text{return\_type}\_opt,\ \text{body},\ \text{span},\ \text{doc}\_opt \rangle\}$$
$$\text{Receiver} \in \{\text{ReceiverShorthand}(\text{perm}),\ \text{ReceiverExplicit}(\text{mode\_opt},\ \text{type})\}$$
$$\text{perm} \in \{\texttt{const},\ \texttt{unique},\ \texttt{shared}\}$$
$$\text{mode\_opt} \in \{\texttt{move},\ \bot\}$$

**EnumDecl.**

$$\text{EnumDecl} = \langle \text{vis},\ \text{name},\ \text{implements},\ \text{variants},\ \text{span},\ \text{doc} \rangle$$

$$\text{EnumDecl}.\text{implements} \in [\text{ClassPath}]$$

$$\text{VariantDecl} = \langle \text{name},\ \text{payload}\_opt,\ \text{discriminant}\_opt,\ \text{span},\ \text{doc}\_opt \rangle$$

$$\text{VariantPayload} \in \{\text{TuplePayload} = [\text{Type}],\ \text{RecordPayload} = [\text{FieldDecl}]\}$$
$$\forall f \in \text{RecordPayload}.\ f.\text{init}\_opt = \bot$$

**ModalDecl.**

$$\text{ModalDecl} = \langle \text{vis},\ \text{name},\ \text{implements},\ \text{states},\ \text{span},\ \text{doc} \rangle$$

$$\text{ModalDecl}.\text{implements} \in [\text{ClassPath}]$$

$$\text{StateBlock} = \langle \text{name},\ \text{members},\ \text{span},\ \text{doc}\_opt \rangle$$

$$\text{StateMember} \in \{\text{StateFieldDecl} = \langle \text{vis},\ \text{name},\ \text{type},\ \text{span},\ \text{doc}\_opt \rangle,\ \text{StateMethodDecl} = \langle \text{vis},\ \text{name},\ \text{params},\ \text{return\_type}\_opt,\ \text{body},\ \text{span},\ \text{doc}\_opt \rangle,\ \text{TransitionDecl} = \langle \text{vis},\ \text{name},\ \text{params},\ \text{target\_state},\ \text{body},\ \text{span},\ \text{doc}\_opt \rangle\}$$

**ClassDecl.**

$$\text{ClassDecl} = \langle \text{vis},\ \text{name},\ \text{supers},\ \text{items},\ \text{span},\ \text{doc} \rangle$$

$$\text{ClassDecl}.\text{supers} \in [\text{ClassPath}]$$

$$\text{ClassItem} \in \{\text{ClassFieldDecl} = \langle \text{vis},\ \text{name},\ \text{type},\ \text{span},\ \text{doc}\_opt \rangle,\ \text{ClassMethodDecl} = \langle \text{vis},\ \text{name},\ \text{receiver},\ \text{params},\ \text{return\_type}\_opt,\ \text{body}\_opt,\ \text{span},\ \text{doc}\_opt \rangle\}$$
$$\text{AbstractClassMethod}(m) \iff \exists vis,name,recv,params,ret,span,doc.\ m = \text{ClassMethodDecl}(vis,name,recv,params,ret,\bot,span,doc)$$
$$\text{ConcreteClassMethod}(m) \iff \exists vis,name,recv,params,ret,body,span,doc.\ m = \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \land body \ne \bot$$

**TypeAliasDecl.**

$$\text{TypeAliasDecl} = \langle \text{vis},\ \text{name},\ \text{type},\ \text{span},\ \text{doc} \rangle$$
$$\text{AliasBodyRef} = \{\texttt{"6.1.4"}\}$$
$$\text{AliasStep}(\text{TypePath}(p)) = \text{AliasBody}(p)\ \text{if defined; otherwise }\text{TypePath}(p)$$
$$\text{AliasStep}(T) = T\ \text{if } T \notin \{\text{TypePath}(p)\}$$
$$\text{AliasNorm}(T) = \begin{cases}
\text{TypePerm}(\text{perm}, \text{AliasNorm}(base)) & T = \text{TypePerm}(\text{perm}, base) \\
\text{TypeTuple}([\text{AliasNorm}(t)\mid t \in \text{elems}]) & T = \text{TypeTuple}(\text{elems}) \\
\text{TypeArray}(\text{AliasNorm}(elem), size\_expr) & T = \text{TypeArray}(elem, size\_expr) \\
\text{TypeSlice}(\text{AliasNorm}(elem)) & T = \text{TypeSlice}(elem) \\
\text{TypeUnion}([\text{AliasNorm}(t)\mid t \in \text{members}]) & T = \text{TypeUnion}(\text{members}) \\
\text{TypeFunc}([\langle m,\ \text{AliasNorm}(t)\rangle \mid \langle m,t\rangle \in \text{params}],\ \text{AliasNorm}(ret)) & T = \text{TypeFunc}(\text{params}, ret) \\
\text{TypeDynamic}(\text{AliasPath}(path)) & T = \text{TypeDynamic}(path) \\
\text{TypeModalState}(\text{AliasPath}(path), state) & T = \text{TypeModalState}(path, state) \\
\text{TypePtr}(\text{AliasNorm}(elem), ptr\_state\_opt) & T = \text{TypePtr}(elem, ptr\_state\_opt) \\
\text{TypeRawPtr}(qual, \text{AliasNorm}(elem)) & T = \text{TypeRawPtr}(qual, elem) \\
\text{AliasNorm}(\text{AliasStep}(T)) & T = \text{TypePath}(p) \\
T & \text{otherwise}
\end{cases}$$
$$\text{AliasPath}(p) = p\ \text{if } \text{AliasBody}(p)\ \text{undefined}$$
$$\text{AliasPath}(p) = \text{AliasPath}(p')\ \text{if } \text{AliasBody}(p) = \text{TypePath}(p')$$
$$\text{AliasTransparent}(T,U) \iff \text{AliasNorm}(T) = \text{AliasNorm}(U)$$
$$\text{AliasGraph} = \{ \langle p,q \rangle \mid \text{AliasBody}(p) = T \land q \in \text{TypePaths}(T) \}$$
$$\text{TypePaths}(\text{TypePrim}(\_)) = \emptyset$$
$$\text{TypePaths}(\text{TypeRange}) = \emptyset$$
$$\text{TypePaths}(\text{TypePerm}(\_, T)) = \text{TypePaths}(T)$$
$$\text{TypePaths}(\text{TypeTuple}([T_1,\ldots,T_n])) = \bigcup_{i=1}^{n} \text{TypePaths}(T_i)$$
$$\text{TypePaths}(\text{TypeArray}(T,\_)) = \text{TypePaths}(T)$$
$$\text{TypePaths}(\text{TypeSlice}(T)) = \text{TypePaths}(T)$$
$$\text{TypePaths}(\text{TypeUnion}([T_1,\ldots,T_n])) = \bigcup_{i=1}^{n} \text{TypePaths}(T_i)$$
$$\text{TypePaths}(\text{TypeFunc}([\langle \_,T_1\rangle,\ldots,\langle \_,T_n\rangle], R)) = \left(\bigcup_{i=1}^{n} \text{TypePaths}(T_i)\right) \cup \text{TypePaths}(R)$$
$$\text{TypePaths}(\text{TypePtr}(T,\_)) = \text{TypePaths}(T)$$
$$\text{TypePaths}(\text{TypeRawPtr}(\_,T)) = \text{TypePaths}(T)$$
$$\text{TypePaths}(\text{TypeString}(\_)) = \emptyset$$
$$\text{TypePaths}(\text{TypeBytes}(\_)) = \emptyset$$
$$\text{TypePaths}(\text{TypeDynamic}(p)) = \{p\}$$
$$\text{TypePaths}(\text{TypeModalState}(p,\_)) = \{p\}$$
$$\text{TypePaths}(\text{TypePath}(p)) = \{p\}$$
$$\text{AliasCycle}(p) \iff p \in \text{Reach}^+(\text{AliasGraph}, p)$$
**(TypeAlias-Recursive-Err)**
$$\frac{\text{AliasCycle}(p) \quad c = \text{Code}(\text{TypeAlias-Recursive-Err})}{\Gamma \vdash p : \text{TypeAliasOk} \Uparrow c}$$
**(TypeAlias-Ok)**
$$\frac{\neg \text{AliasCycle}(p)}{\Gamma \vdash p : \text{TypeAliasOk}}$$

**ErrorItem.**

$$\text{ErrorItem} = \langle \text{span} \rangle$$
$$\text{IsDecl}(\text{ErrorItem}(\_)) = \text{false}$$

##### 3.3.2.3. Types

**Type.**
$$\text{Type} = \{\text{TypePerm}(perm, base),\ \text{TypePrim}(name),\ \text{TypeTuple}(elems),\ \text{TypeArray}(elem, size\_expr),\ \text{TypeSlice}(elem),\ \text{TypeUnion}(members),\ \text{TypeFunc}(params, ret),\ \text{TypePath}(path),\ \text{TypeDynamic}(path),\ \text{TypeString}(string\_state\_opt),\ \text{TypeBytes}(bytes\_state\_opt),\ \text{TypeModalState}(path, state),\ \text{TypePtr}(elem, ptr\_state\_opt),\ \text{TypeRawPtr}(qual, elem),\ \text{TypeRange}\}$$

$$\text{Perm} = \{\texttt{const},\ \texttt{unique},\ \texttt{shared}\}$$
$$\text{Qual} = \{\texttt{imm},\ \texttt{mut}\}$$
$$\text{PtrStateOpt} = \{\bot,\ \texttt{Valid},\ \texttt{Null},\ \texttt{Expired}\}$$
$$\text{StringStateOpt} = \{\bot,\ \texttt{@Managed},\ \texttt{@View}\}$$
$$\text{BytesStateOpt} = \{\bot,\ \texttt{@Managed},\ \texttt{@View}\}$$
$$\text{Name} \in \text{PrimTypes}_{C0}$$

$$\text{ParamMode} = \{\texttt{move},\ \bot\}$$
$$\text{ParamType} = \langle \text{mode},\ \text{type} \rangle \ \text{where}\ \text{mode} \in \text{ParamMode} \land \text{type} \in \text{Type}$$

$$\text{TypeRangeSyntax} = \bot$$

**Range Record.**
$$\text{RangeFieldType}(\texttt{kind}) = \texttt{u8}$$
$$\text{RangeFieldType}(\texttt{lo}) = \texttt{usize}$$
$$\text{RangeFieldType}(\texttt{hi}) = \texttt{usize}$$

##### 3.3.2.4. Expressions

**Literal Tokens.**
$$\text{LiteralKind} = \{\text{IntLiteral},\ \text{FloatLiteral},\ \text{StringLiteral},\ \text{CharLiteral},\ \text{BoolLiteral},\ \text{NullLiteral}\}$$
$$\text{LiteralToken} = \{ t \in \text{Token} \mid t.\text{kind} \in \text{LiteralKind} \}$$

**Expr.**
$$\text{RangeKind} = \{\texttt{To},\ \texttt{ToInclusive},\ \texttt{Full},\ \texttt{From},\ \texttt{Exclusive},\ \texttt{Inclusive}\}$$
$$\text{Expr} = \{\text{Literal}(lit),\ \text{PtrNullExpr},\ \text{Identifier}(name),\ \text{QualifiedName}(path, name),\ \text{QualifiedApply}(path, name, form),\ \text{Path}(path, name),\ \text{ErrorExpr}(span),\ \text{TupleExpr}(elems),\ \text{ArrayExpr}(elems),\ \text{RecordExpr}(type\_ref, fields),\ \text{EnumLiteral}(path, payload\_opt),\ \text{FieldAccess}(base, name),\ \text{TupleAccess}(base, index),\ \text{IndexAccess}(base, index\_expr),\ \text{Call}(callee, args),\ \text{MethodCall}(base, name, args),\ \text{Unary}(op, expr),\ \text{Binary}(op, left, right),\ \text{Cast}(expr, type),\ \text{Range}(kind, lo\_opt, hi\_opt),\ \text{IfExpr}(cond, then\_block, else\_opt),\ \text{MatchExpr}(scrutinee, arms),\ \text{LoopInfinite}(body),\ \text{LoopConditional}(cond, body),\ \text{LoopIter}(pattern, type\_opt, iter, body),\ \text{BlockExpr}(stmts, tail\_opt),\ \text{UnsafeBlockExpr}(body),\ \text{MoveExpr}(place),\ \text{TransmuteExpr}(src\_type, dst\_type, expr),\ \text{AllocExpr}(region\_opt, expr),\ \text{Propagate}(expr),\ \text{AddressOf}(place),\ \text{Deref}(expr)\}$$
$$\text{ExprSpan} : \text{Expr} \to \text{Span}$$

$$\text{TypeRef} = \{\text{TypePath}(path),\ \text{ModalStateRef}(path, state)\}$$

**Qualified Expressions.**
$$\text{ParenForm} = \{\text{Paren}(args) \mid args \in \text{Arg}^\ast\}$$
$$\text{BraceForm} = \{\text{Brace}(fields) \mid fields \in \text{FieldInit}^\ast\}$$
$$\text{QualForm} = \text{ParenForm} \cup \text{BraceForm}$$
$$\forall P, P', e.\ (\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P', e)) \Rightarrow e \notin \{\text{Path}(\_,\_),\ \text{EnumLiteral}(\_,\_)\}$$

**Argument.**
$$\text{Arg} = \langle \text{moved},\ \text{expr},\ \text{span} \rangle \ \text{where}\ \text{moved} \in \{\text{true},\text{false}\}$$

$$\text{MovedArg}(moved, e) =
\begin{cases}
\text{MoveExpr}(e) & \text{if } moved = \text{true} \land \text{IsPlace}(e) \\
e & \text{otherwise}
\end{cases}$$

**Field Initializer.**
$$\text{FieldInit} = \langle \text{name},\ \text{expr} \rangle$$

##### 3.3.2.5. Patterns

$$\text{Pattern} = \{\text{LiteralPattern}(lit),\ \text{WildcardPattern},\ \text{IdentifierPattern}(name),\ \text{TypedPattern}(name, type),\ \text{TuplePattern}(elems),\ \text{RecordPattern}(type\_path, fields),\ \text{EnumPattern}(type\_path, name, payload\_opt),\ \text{ModalPattern}(state\_name, fields\_opt),\ \text{RangePattern}(kind, lo, hi)\}$$
$$\text{PatternSpan} : \text{Pattern} \to \text{Span}$$

$$\text{FieldPattern} = \langle \text{name},\ \text{pattern}\_opt,\ \text{span} \rangle$$

$$\text{EnumPayloadPattern} = \{\text{TuplePayloadPattern}([Pattern]),\ \text{RecordPayloadPattern}([FieldPattern])\}$$

$$\text{ModalPayloadPattern} = \{\text{ModalRecordPayload}([FieldPattern])\}$$

##### 3.3.2.6. Statements

$$\text{Stmt} = \{\text{LetStmt}(binding),\ \text{VarStmt}(binding),\ \text{ErrorStmt}(span),\ \text{ShadowLetStmt}(name, type\_opt, init),\ \text{ShadowVarStmt}(name, type\_opt, init),\ \text{AssignStmt}(place, expr),\ \text{CompoundAssignStmt}(place, op, expr),\ \text{ExprStmt}(expr),\ \text{DeferStmt}(block),\ \text{RegionStmt}(opts\_opt, alias\_opt, block),\ \text{FrameStmt}(target\_opt, block),\ \text{ReturnStmt}(expr\_opt),\ \text{ResultStmt}(expr),\ \text{BreakStmt}(expr\_opt),\ \text{ContinueStmt},\ \text{UnsafeBlockStmt}(block)\}$$

$$\text{binding} = \langle \text{pattern},\ \text{type}\_opt,\ \text{op},\ \text{init},\ \text{span} \rangle$$
$$\text{opts\_opt} \in \{\bot\} \cup \text{Expr} \quad \text{alias\_opt} \in \{\bot\} \cup \text{Identifier}$$
$$\text{target\_opt} \in \{\bot\} \cup \text{Identifier}$$

##### 3.3.2.7. Unsupported Grammar Families (Cursive0 Decision)

$$\text{UnsupportedGrammarFamily} = \{\texttt{attributes},\ \texttt{extern\_ffi},\ \texttt{generics},\ \texttt{contracts},\ \texttt{keys},\ \texttt{concurrency},\ \texttt{async},\ \texttt{metaprogramming}\}$$
$$\text{UnsupportedGrammarFamily} \subseteq \text{UnsupportedForm}$$

#### 3.3.3. Parser State and Judgments

**Parser State.**

$$\text{PState} = \langle K,\ i,\ D,\ j,\ d,\ \Delta \rangle$$

$$\text{TokStream}(P) = K$$
$$\text{TokIndex}(P) = i$$
$$\text{DocStream}(P) = D$$
$$\text{DocIndex}(P) = j$$
$$\text{Depth}(P) = d$$
$$\text{DiagStream}(P) = \Delta$$

**Helper Functions.**

$$\text{Tok}(P) = \begin{cases}
K[i] & i < |K| \\
\langle \text{EOF},\ \epsilon,\ \text{EOFSpan}(K) \rangle & i = |K|
\end{cases}$$

$$\text{SourceOf}(K) = S \iff \Gamma \vdash \text{Tokenize}(S) \Downarrow (K_{\text{raw}}, D) \land K = \text{Filter}(K_{\text{raw}})$$
$$\text{EOFSpan}(K) = \text{EOFSpan}(\text{SourceOf}(K))$$

$$\text{Advance}(P) = \langle K,\ i+1,\ D,\ j,\ d,\ \Delta \rangle$$
$$\text{Clone}(P) = \langle K,\ i,\ D,\ j,\ d,\ [] \rangle$$
$$\text{MergeDiag}(P_b, P_d, P_s) = \langle \text{TokStream}(P_s),\ \text{TokIndex}(P_s),\ \text{DocStream}(P_s),\ \text{DocIndex}(P_s),\ \text{Depth}(P_s),\ \text{DiagStream}(P_b) \mathbin{+\!\!+} \text{DiagStream}(P_d) \rangle$$

**Parser Index Invariant.**
$$\text{PStateOk}(P) \iff 0 \le i \le |K|$$

$$\text{AdvanceOrEOF}(P) = \begin{cases}
\text{Advance}(P) & i < |K| \\
P & i = |K|
\end{cases}$$

$$\text{LastConsumed}(P,P') = \begin{cases}
K[i'-1] & i' > i \\
\text{Tok}(P) & i' = i
\end{cases}$$
$$\text{SpanBetween}(P,P') = \text{SpanFrom}(\text{Tok}(P),\ \text{LastConsumed}(P,P'))$$

$$\text{SplitSpan2}(\text{sp}) = (\text{sp}_L,\ \text{sp}_R) \ \text{where}$$
$$\text{sp}_L.\text{file}=\text{sp.file}\ \land\ \text{sp}_R.\text{file}=\text{sp.file}$$
$$\text{sp}_L.\text{start\_offset}=\text{sp.start\_offset}\ \land\ \text{sp}_L.\text{end\_offset}=\text{sp.start\_offset}+1$$
$$\text{sp}_R.\text{start\_offset}=\text{sp.start\_offset}+1\ \land\ \text{sp}_R.\text{end\_offset}=\text{sp.start\_offset}+2$$
$$\text{sp}_L.\text{start\_line}=\text{sp.start\_line}\ \land\ \text{sp}_L.\text{end\_line}=\text{sp.start\_line}$$
$$\text{sp}_R.\text{start\_line}=\text{sp.start\_line}\ \land\ \text{sp}_R.\text{end\_line}=\text{sp.start\_line}$$
$$\text{sp}_L.\text{start\_col}=\text{sp.start\_col}\ \land\ \text{sp}_L.\text{end\_col}=\text{sp.start\_col}+1$$
$$\text{sp}_R.\text{start\_col}=\text{sp.start\_col}+1\ \land\ \text{sp}_R.\text{end\_col}=\text{sp.start\_col}+2$$

$$\text{SplitShiftR}(P) = \langle K',\ i,\ D,\ j,\ d,\ \Delta \rangle$$
$$\text{where } \text{Tok}(P)=\langle \text{Operator}(\texttt{">>"}),\ \texttt{">>"},\ \text{sp} \rangle \land (\text{sp}_L,\text{sp}_R)=\text{SplitSpan2}(\text{sp})$$
$$K' = K[0..i) \mathbin{+\!\!+} [\langle \text{Operator}(\texttt{">"}),\ \texttt{">"},\ \text{sp}_L \rangle,\ \langle \text{Operator}(\texttt{">"}),\ \texttt{">"},\ \text{sp}_R \rangle] \mathbin{+\!\!+} K[i+1..]$$

**Judgments (Big-Step).**
$$\text{ParseJudgment} = \{\text{ParseFile},\ \text{ParseModule},\ \text{ParseItem},\ \text{ParseStmt},\ \text{ParseExpr},\ \text{ParsePattern},\ \text{ParseType}\}$$

#### 3.3.4. Grammar Subset and Cursive0 Lexeme Policy

**Lexeme Predicates.**
$$\text{IsIdent}(t) \iff t.\text{kind}=\text{Identifier}$$
$$\text{IsKw}(t,s) \iff t.\text{kind}=\text{Keyword}(s)$$
$$\text{IsOp}(t,s) \iff t.\text{kind}=\text{Operator}(s)$$
$$\text{IsPunc}(t,s) \iff t.\text{kind}=\text{Punctuator}(s)$$
$$\text{Lexeme}(t) = t.\text{lexeme}$$

**Contextual Keywords.**
$$\text{CtxKeyword} = \{\texttt{"in"}\}$$
$$\text{Ctx}(t,s) \iff \text{IsIdent}(t) \land \text{Lexeme}(t)=s \land s \in \text{CtxKeyword}$$
$$\neg \text{Ctx}(t,\texttt{"as"}) \land \neg \text{Ctx}(t,\texttt{"move"})$$

**Cursive0 Declaration Keywords.**
$$\text{UsingKeyword} = \texttt{"using"}$$
$$\text{Keyword}(\texttt{"use"}) = \text{false}$$

**Union Propagation.**
$$\text{UnionPropTok}(t) \iff \text{IsOp}(t,\texttt{"?"})$$
$$\text{UnionPropForm}(e) \iff \exists e_0.\ e=\text{Propagate}(e_0)$$

**Cursive0 Type Restrictions.**
$$\text{TypeWhereTok}(t) \iff \text{IsIdent}(t) \land \text{Lexeme}(t)=\texttt{"where"}$$
$$\text{OpaqueTypeTok}(t) \iff \text{IsIdent}(t) \land \text{Lexeme}(t)=\texttt{"opaque"}$$
$$\text{TypeArgsUnsupported}(P) \iff \Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \land \text{IsOp}(\text{Tok}(P_1), \texttt{"<"}) \land path \ne [\texttt{Ptr}]$$
$$\text{C0TypeRestricted}(P) \iff \text{TypeArgsUnsupported}(P) \lor \text{TypeWhereTok}(\text{Tok}(P)) \lor \text{OpaqueTypeTok}(\text{Tok}(P))$$

**Syntax (Cursive0 Subset).**

```ebnf
module            ::= item*
item              ::= using_decl | static_decl | procedure_decl | record_decl | enum_decl | modal_decl | class_decl | type_alias_decl
using_decl         ::= visibility? "using" using_clause
using_clause       ::= using_path ("as" identifier)? | using_list
path               ::= identifier ("::" identifier)*
module_path        ::= path
using_path         ::= path
type_path          ::= path
using_list         ::= module_path "{" using_specifier ("," using_specifier)* "}"
using_specifier    ::= identifier ("as" identifier)?

static_decl        ::= visibility? ("let" | "var") binding_decl
binding_decl       ::= pattern (":" type)? binding_op expression
procedure_decl     ::= visibility? "procedure" identifier signature block_expr
signature          ::= "(" param_list? ")" ("->" type)?
param_list         ::= param ("," param)*
param              ::= param_mode? identifier ":" type
param_mode         ::= "move"
record_decl        ::= visibility? "record" identifier implements_clause? "{" record_body? "}"
enum_decl          ::= visibility? "enum" identifier implements_clause? "{" variant_list? "}"
modal_decl         ::= visibility? "modal" identifier implements_clause? "{" state_block+ "}"
class_decl         ::= visibility? "class" identifier ("<:" superclass_bounds)? "{" class_body? "}"
type_alias_decl    ::= visibility? "type" identifier "=" type

record_body        ::= record_member ("," record_member)*
record_member      ::= record_field_decl | method_def
method_def         ::= visibility? "override"? "procedure" identifier "(" receiver ("," param_list)? ")" ("->" type)? block_expr
receiver           ::= receiver_shorthand | explicit_receiver
receiver_shorthand ::= "~" | "~!"
explicit_receiver  ::= param_mode? "self" ":" type

implements_clause  ::= "<:" class_list
class_list         ::= class_path ("," class_path)*
class_path         ::= type_path

state_block        ::= "@" state_name "{" state_member* "}"
state_name         ::= identifier
state_member       ::= state_field_decl | state_method_def | transition_def
state_field_decl   ::= visibility? identifier ":" type
state_method_def   ::= visibility? "procedure" identifier "(" param_list ")" ("->" type)? block_expr
transition_def     ::= visibility? "transition" identifier "(" param_list ")" "->" "@" target_state block_expr
target_state       ::= identifier

superclass_bounds  ::= class_path ("+" class_path)*
class_body         ::= class_item*
class_item         ::= class_method_decl | class_field_decl
class_method_decl  ::= visibility? "procedure" identifier "(" receiver ("," param_list)? ")" ("->" type)? class_method_body
class_method_body  ::= block_expr | terminator
class_field_decl   ::= visibility? identifier ":" type terminator

visibility         ::= "public" | "internal" | "private" | "protected"

record_field_decl_list ::= record_field_decl ("," record_field_decl)*
record_field_decl  ::= visibility? identifier ":" type record_field_init_opt?
record_field_init_opt ::= "=" expression
field_decl_list    ::= field_decl ("," field_decl)*
field_decl         ::= visibility? identifier ":" type
variant_list       ::= variant ("," variant)*
variant            ::= identifier variant_payload? ("=" integer_literal)?
variant_payload    ::= "(" type_list? ")" | "{" field_decl_list? "}"
type_list          ::= type ("," type)*

statement          ::= binding_stmt | shadow_binding | assignment_stmt | expr_stmt | defer_stmt | region_stmt | frame_stmt | return_stmt | result_stmt | break_stmt | continue_stmt | unsafe_block
binding_stmt       ::= ("let" | "var") pattern (":" type)? binding_op expression terminator
shadow_binding     ::= "shadow" ("let" | "var") identifier (":" type)? "=" expression terminator
assignment_stmt    ::= place_expr "=" expression terminator
compound_assign    ::= place_expr compound_op expression terminator
expr_stmt          ::= expression terminator
defer_stmt         ::= "defer" block_expr
region_stmt        ::= "region" region_opts? region_alias? block_expr
region_opts        ::= "(" expression ")"
region_alias       ::= "as" identifier
frame_stmt         ::= "frame" block_expr | identifier "." "frame" block_expr
return_stmt        ::= "return" expression? terminator?
result_stmt        ::= "result" expression terminator?
break_stmt         ::= "break" expression? terminator?
continue_stmt      ::= "continue" terminator?
unsafe_block       ::= "unsafe" block_expr

binding_op         ::= "=" | ":="
compound_op        ::= "+=" | "-=" | "*=" | "/=" | "%="
terminator         ::= ";" | newline
newline            ::= "\n"

expression         ::= range_expression | logical_or_expr
range_expression   ::= exclusive_range | inclusive_range | from_range | to_range | to_inclusive_range | full_range
exclusive_range    ::= logical_or_expr ".." logical_or_expr
inclusive_range    ::= logical_or_expr "..=" logical_or_expr
from_range         ::= logical_or_expr ".."
to_range           ::= ".." logical_or_expr
to_inclusive_range ::= "..=" logical_or_expr
full_range         ::= ".."
logical_or_expr    ::= logical_and_expr ("||" logical_and_expr)*
logical_and_expr   ::= comparison_expr ("&&" comparison_expr)*
comparison_expr    ::= bitwise_or_expr (("==" | "!=" | "<" | "<=" | ">" | ">=") bitwise_or_expr)*
bitwise_or_expr    ::= bitwise_xor_expr ("|" bitwise_xor_expr)*
bitwise_xor_expr   ::= bitwise_and_expr ("^" bitwise_and_expr)*
bitwise_and_expr   ::= shift_expr ("&" shift_expr)*
shift_expr         ::= additive_expr (("<<" | ">>") additive_expr)*
additive_expr      ::= multiplicative_expr (("+" | "-") multiplicative_expr)*
multiplicative_expr ::= power_expr (("*" | "/" | "%") power_expr)*
power_expr         ::= cast_expr ("**" power_expr)?
cast_expr          ::= unary_expr ("as" type)?

unary_expr          ::= unary_operator unary_expr | address_of_expr | move_expr | postfix_expr
unary_operator      ::= "!" | "-" | "*" | "widen"
address_of_expr     ::= "&" place_expr
move_expr           ::= "move" place_expr

postfix_expr        ::= primary_expr postfix_suffix*
postfix_suffix      ::= "." identifier | "." decimal_literal | "[" expression "]" | "~>" identifier "(" argument_list? ")" | "(" argument_list? ")" | "?"

primary_expr        ::= literal | null_ptr_expr | identifier_expr | qualified_expr | tuple_literal | array_literal | record_literal | if_expr | match_expr | loop_expr | block_expr | unsafe_expr | transmute_expr
                   | alloc_expr
unsafe_expr         ::= "unsafe" block_expr
transmute_expr      ::= "transmute" "::" "<" type "," type ">" "(" expression ")"
identifier_expr     ::= identifier
qualified_expr      ::= type_path "::" identifier qualified_suffix?
qualified_suffix    ::= "(" argument_list? ")" | "{" field_init_list "}"
null_ptr_expr       ::= "Ptr" "::" "null" "(" ")"
alloc_expr          ::= "^" expression

parenthesized_expr  ::= "(" expression ")"

tuple_literal       ::= "(" tuple_expr_elements? ")"
tuple_expr_elements ::= expression ";" | expression ("," expression)+
array_literal       ::= "[" expression_list "]"
expression_list     ::= expression ("," expression)*
record_literal      ::= (type_path | state_specific_type) "{" field_init_list "}"
field_init_list     ::= field_init ("," field_init)*
field_init          ::= identifier ":" expression | identifier


argument_list       ::= argument ("," argument)*
argument            ::= "move"? expression

if_expr             ::= "if" expression block_expr ("else" (block_expr | if_expr))?
match_expr          ::= "match" expression "{" match_arm ("," match_arm)* "}"
match_arm           ::= pattern ("if" expression)? "=>" arm_body
arm_body            ::= expression | block_expr

loop_expr           ::= "loop" block_expr | "loop" expression block_expr | "loop" pattern (":" type)? "in" expression block_expr

block_expr          ::= "{" statement* expression? "}"

place_expr          ::= "*" place_expr | postfix_expr

pattern             ::= literal_pattern | wildcard_pattern | identifier_pattern | typed_pattern | tuple_pattern | record_pattern | enum_pattern | modal_pattern | range_pattern
literal_pattern     ::= literal
wildcard_pattern    ::= "_"
identifier_pattern  ::= identifier
typed_pattern       ::= identifier ":" type

tuple_pattern       ::= "(" tuple_pattern_elements? ")"
tuple_pattern_elements ::= pattern ";" | pattern ("," pattern)+
record_pattern      ::= type_path "{" field_pattern_list? "}"
field_pattern_list  ::= field_pattern ("," field_pattern)*
field_pattern       ::= identifier (":" pattern)?

enum_pattern        ::= type_path "::" identifier enum_payload_pattern?
enum_payload_pattern ::= "(" tuple_pattern_elements? ")" | "{" field_pattern_list? "}"

modal_pattern       ::= "@" identifier ("{" field_pattern_list? "}")?

range_pattern       ::= pattern (".." | "..=") pattern

type                ::= permission? non_permission_type
permission          ::= "const" | "unique" | "shared"
non_permission_type ::= union_type | non_union_type
union_type          ::= non_union_type ("|" non_union_type)+
non_union_type      ::= primitive_type | tuple_type | function_type | array_type | slice_type | safe_pointer_type | raw_pointer_type | string_type | bytes_type | dynamic_type | state_specific_type | type_path

primitive_type      ::= integer_type | float_type | bool_type | char_type | unit_type | never_type
integer_type        ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"
float_type          ::= "f16" | "f32" | "f64"
bool_type           ::= "bool"
char_type           ::= "char"
unit_type           ::= "(" ")"
never_type          ::= "!"

tuple_type          ::= "(" tuple_type_elements? ")"
tuple_type_elements ::= type ";" | type ("," type)+
function_type       ::= "(" param_type_list? ")" "->" type
param_type_list     ::= param_type ("," param_type)*
param_type          ::= "move"? type
array_type          ::= "[" type ";" const_expression "]"
slice_type          ::= "[" type "]"

string_type         ::= "string" ("@" ("Managed" | "View"))?
bytes_type          ::= "bytes" ("@" ("Managed" | "View"))?

state_specific_type ::= type_path "@" state_name

safe_pointer_type   ::= "Ptr" "<" type ">" ("@" pointer_state)?
pointer_state       ::= "Valid" | "Null" | "Expired"
raw_pointer_type    ::= "*" ("imm" | "mut") type

dynamic_type        ::= "$" type_path

const_expression    ::= expression
```

**Method Context (Cursive0).**

$$\text{RecordMembers}(M) = \{\ m \mid m\ \text{occurs as RecordMember in}\ M\ \}$$
$$\text{ClassItems}(M) = \{\ m \mid m\ \text{occurs as ClassItem in}\ M\ \}$$
$$\text{MethodDecls}(M) = \{\ m \mid m=\text{MethodDecl}(\ldots)\ \land\ m\ \text{occurs in}\ M\ \}$$
$$\text{ClassMethodDecls}(M) = \{\ m \mid m=\text{ClassMethodDecl}(\ldots)\ \land\ m\ \text{occurs in}\ M\ \}$$
$$\text{MethodContextOk}(M) \iff \text{MethodDecls}(M) \subseteq \text{RecordMembers}(M) \land \text{ClassMethodDecls}(M) \subseteq \text{ClassItems}(M)$$

**(Method-Context-Err)**
$$\frac{\neg \text{MethodContextOk}(M) \quad c = \text{Code}(\text{Method-Context-Err})}{\Gamma \vdash \text{Emit}(c)}$$

#### 3.3.5. Token Consumption (Small-Step, Success-Only)

$$\text{ConsumeState} = \{\text{Consume}(P,k),\ \text{ConsumeDone}(P)\}$$
$$\text{ParseRejectRules} = \emptyset$$

**(Tok-Consume-Kind)**
$$\frac{\text{Tok}(P).\text{kind} = k}{\langle \text{Consume}(P,k) \rangle \to \langle \text{ConsumeDone}(\text{Advance}(P)) \rangle}$$

**(Tok-Consume-Keyword)**
$$\frac{\text{IsKw}(\text{Tok}(P), s)}{\langle \text{Consume}(P, \text{Keyword}(s)) \rangle \to \langle \text{ConsumeDone}(\text{Advance}(P)) \rangle}$$

**(Tok-Consume-Operator)**
$$\frac{\text{IsOp}(\text{Tok}(P), s)}{\langle \text{Consume}(P, \text{Operator}(s)) \rangle \to \langle \text{ConsumeDone}(\text{Advance}(P)) \rangle}$$

**(Tok-Consume-Punct)**
$$\frac{\text{IsPunc}(\text{Tok}(P), s)}{\langle \text{Consume}(P, \text{Punctuator}(s)) \rangle \to \langle \text{ConsumeDone}(\text{Advance}(P)) \rangle}$$

**List Parsing (Small-Step)**

$$\text{ListState} = \{\text{ListStart}(P),\ \text{ListScan}(P,xs),\ \text{ListDone}(P,xs)\}$$

**(List-Start)**
$$\frac{}{\langle \text{ListStart}(P) \rangle \to \langle \text{ListScan}(P, []) \rangle}$$

**(List-Cons)**
$$\frac{\Gamma \vdash \text{ParseElem}(P) \Downarrow (P', x)}{\langle \text{ListScan}(P, xs) \rangle \to \langle \text{ListScan}(P', xs \mathbin{+\!\!+} [x]) \rangle}$$

**(List-Done)**
$$\frac{\text{Tok}(P) \in \text{EndSet}}{\langle \text{ListScan}(P, xs) \rangle \to \langle \text{ListDone}(P, xs) \rangle}$$

$$\text{EndSet} \subseteq \text{TokenKind}$$
$$\text{TrailingComma}(P,\text{EndSet}) \iff \text{IsPunc}(\text{Tok}(P),\texttt{","}) \land \text{Tok}(\text{Advance}(P)) \in \text{EndSet}$$

**(Trailing-Comma-Err)**
$$\frac{\text{TrailingComma}(P,\text{EndSet}) \quad c = \text{Code}(\text{Unsupported-Construct})}{\Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span})}$$

#### 3.3.6. Module and Item Parsing

**ParseFile (Big-Step).**
$$\Gamma \vdash \text{Tokenize}(S) \Downarrow (K_{\text{raw}}, D)$$
$$K = \text{Filter}(K_{\text{raw}})$$
$$P_0 = \langle K,\ 0,\ D,\ 0,\ 0,\ [] \rangle$$

**(ParseFile-Ok)**
$$\frac{\Gamma \vdash \text{ParseItems}(P_0) \Downarrow (P_1, I, MDoc)}{\Gamma \vdash \text{ParseFile}(S) \Downarrow \langle S.\text{path}, I, MDoc \rangle}$$

$$\text{ParseModule} \in \text{RulesIn}(\{\texttt{"3.4.1"},\ \texttt{"3.4.2"}\})$$

**Item Sequence (Big-Step).**

**(ParseItems-Empty)**
$$\frac{\text{Tok}(P) = \text{EOF}}{\Gamma \vdash \text{ParseItems}(P) \Downarrow (P, [], [])}$$

**(ParseItems-Cons)**
$$\frac{\text{Tok}(P) \neq \text{EOF} \quad \Gamma \vdash \text{ParseItem}(P) \Downarrow (P_1, it) \quad \Gamma \vdash \text{ParseItems}(P_1) \Downarrow (P_2, I, M)}{\Gamma \vdash \text{ParseItems}(P) \Downarrow (P_2, [it] \mathbin{+\!\!+} I, M)}$$

$$\text{TopLevelItem} \subseteq \texttt{item}$$

##### 3.3.6.1. Identifiers and Paths

**(Parse-Ident)**
$$\frac{\text{IsIdent}(\text{Tok}(P))}{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (\text{Advance}(P), \text{Lexeme}(\text{Tok}(P)))}$$

**(Parse-Ident-Err)**
$$\frac{\neg \text{IsIdent}(\text{Tok}(P)) \quad c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span})}{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P,\ \texttt{"_"})}$$

**(Parse-ModulePath)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, id) \quad \Gamma \vdash \text{ParseModulePathTail}(P_1, [id]) \Downarrow (P_2, path)}{\Gamma \vdash \text{ParseModulePath}(P) \Downarrow (P_2, path)}$$

**(Parse-ModulePathTail-End)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"::"})}{\Gamma \vdash \text{ParseModulePathTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-ModulePathTail-Cons)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"::"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, id) \quad \Gamma \vdash \text{ParseModulePathTail}(P_1, xs \mathbin{+\!\!+} [id]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseModulePathTail}(P, xs) \Downarrow (P_2, ys)}$$

##### 3.3.6.2. Visibility Parsing

**(Parse-Vis-Opt)**
$$\frac{\text{IsKw}(\text{Tok}(P), v) \quad v \in \{\texttt{public},\texttt{internal},\texttt{private},\texttt{protected}\}}{\Gamma \vdash \text{ParseVis}(P) \Downarrow (\text{Advance}(P), v)}$$

**(Parse-Vis-Default)**
$$\frac{\neg(\text{IsKw}(\text{Tok}(P), v))}{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P, \texttt{internal})}$$

##### 3.3.6.3. Using Declarations

**(Parse-Using-Path)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{using}) \quad \Gamma \vdash \text{ParseModulePath}(\text{Advance}(P_1)) \Downarrow (P_2, path) \quad \Gamma \vdash \text{ParseAliasOpt}(P_2) \Downarrow (P_3, alias\_opt)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_3, \langle \text{UsingDecl}, vis, \langle \text{UsingPath}, path, alias\_opt \rangle, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-Using-List)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{using}) \quad \Gamma \vdash \text{ParseModulePath}(\text{Advance}(P_1)) \Downarrow (P_2, mp) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"{"}) \quad \Gamma \vdash \text{ParseUsingList}(\text{Advance}(P_2)) \Downarrow (P_3, specs)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_3, \langle \text{UsingDecl}, vis, \langle \text{UsingList}, mp, specs \rangle, \text{SpanBetween}(P,P_3), [] \rangle)}$$

##### 3.3.6.4. Static Declarations

**(Parse-Static-Decl)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{Tok}(P_1) = \text{Keyword}(kw) \quad kw \in \{\texttt{let},\ \texttt{var}\} \quad \text{mut} = kw \quad \Gamma \vdash \text{ParseBindingAfterLetVar}(P_1) \Downarrow (P_2, bind)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_2, \langle \text{StaticDecl}, vis, mut, bind, \text{SpanBetween}(P,P_2), [] \rangle)}$$

##### 3.3.6.5. Procedure Declarations

**(Parse-Procedure)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{procedure}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseSignature}(P_2) \Downarrow (P_3, params, ret\_opt) \quad \Gamma \vdash \text{ParseBlock}(P_3) \Downarrow (P_4, body)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_4, \langle \text{ProcedureDecl}, vis, name, params, ret\_opt, body, \text{SpanBetween}(P,P_4), [] \rangle)}$$

##### 3.3.6.6. Record Declarations

**(Parse-Record)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{record}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseImplementsOpt}(P_2) \Downarrow (P_3, impls) \quad \Gamma \vdash \text{ParseRecordBody}(P_3) \Downarrow (P_4, members)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_4, \langle \text{RecordDecl}, vis, name, impls, members, \text{SpanBetween}(P,P_4), [] \rangle)}$$

##### 3.3.6.7. Enum Declarations

**(Parse-Enum)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{enum}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseImplementsOpt}(P_2) \Downarrow (P_3, impls) \quad \Gamma \vdash \text{ParseEnumBody}(P_3) \Downarrow (P_4, variants)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_4, \langle \text{EnumDecl}, vis, name, impls, variants, \text{SpanBetween}(P,P_4), [] \rangle)}$$

##### 3.3.6.8. Modal Declarations

**(Parse-Modal)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{modal}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseImplementsOpt}(P_2) \Downarrow (P_3, impls) \quad \Gamma \vdash \text{ParseModalBody}(P_3) \Downarrow (P_4, states)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_4, \langle \text{ModalDecl}, vis, name, impls, states, \text{SpanBetween}(P,P_4), [] \rangle)}$$

**(Parse-Class)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{class}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseSuperclassOpt}(P_2) \Downarrow (P_3, supers) \quad \Gamma \vdash \text{ParseClassBody}(P_3) \Downarrow (P_4, items)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_4, \langle \text{ClassDecl}, vis, name, supers, items, \text{SpanBetween}(P,P_4), [] \rangle)}$$

**(Parse-ModalBody)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseStateBlockList}(\text{Advance}(P)) \Downarrow (P_1, states) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseModalBody}(P) \Downarrow (\text{Advance}(P_1), states)}$$

**(Parse-StateBlock)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"{"}) \quad \Gamma \vdash \text{ParseStateMemberList}(\text{Advance}(P_1)) \Downarrow (P_2, members) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParseStateBlock}(P) \Downarrow (\text{Advance}(P_2), \langle name, members, \text{SpanBetween}(P,P_2), [] \rangle)}$$

**(Parse-StateMember-Field)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \Gamma \vdash \text{ParseIdent}(P_1) \Downarrow (P_2, name) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_2)) \Downarrow (P_3, ty)}{\Gamma \vdash \text{ParseStateMember}(P) \Downarrow (P_3, \langle \text{StateFieldDecl}, vis, name, ty, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-StateMember-Method)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_0, vis) \quad \text{IsKw}(\text{Tok}(P_0), \texttt{procedure}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_0)) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseSignature}(P_1) \Downarrow (P_2, params, ret\_opt) \quad \Gamma \vdash \text{ParseBlock}(P_2) \Downarrow (P_3, body)}{\Gamma \vdash \text{ParseStateMember}(P) \Downarrow (P_3, \langle \text{StateMethodDecl}, vis, name, params, ret\_opt, body, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-StateMember-Transition)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_0, vis) \quad \text{IsKw}(\text{Tok}(P_0), \texttt{transition}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_0)) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"("}) \quad \Gamma \vdash \text{ParseParamList}(\text{Advance}(P_1)) \Downarrow (P_2, params) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{")"}) \quad P_2' = \text{Advance}(P_2) \quad \text{IsOp}(\text{Tok}(P_2'), \texttt{"->"}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(P_2')), \texttt{"@"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(\text{Advance}(P_2'))) \Downarrow (P_3, target) \quad \Gamma \vdash \text{ParseBlock}(P_3) \Downarrow (P_4, body)}{\Gamma \vdash \text{ParseStateMember}(P) \Downarrow (P_4, \langle \text{TransitionDecl}, vis, name, params, target, body, \text{SpanBetween}(P,P_4), [] \rangle)}$$

##### 3.3.6.9. Implements Clauses

**(Parse-Implements-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"<:"})}{\Gamma \vdash \text{ParseImplementsOpt}(P) \Downarrow (P, [])}$$

**(Parse-Implements-Yes)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"<:"}) \quad \Gamma \vdash \text{ParseClassList}(\text{Advance}(P)) \Downarrow (P_1, cls)}{\Gamma \vdash \text{ParseImplementsOpt}(P) \Downarrow (P_1, cls)}$$

**(Parse-ClassList-Cons)**
$$\frac{\Gamma \vdash \text{ParseClassPath}(P) \Downarrow (P_1, c_0) \quad \Gamma \vdash \text{ParseClassListTail}(P_1, [c_0]) \Downarrow (P_2, cs)}{\Gamma \vdash \text{ParseClassList}(P) \Downarrow (P_2, cs)}$$

**(Parse-ClassListTail-End)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{","})}{\Gamma \vdash \text{ParseClassListTail}(P, cs) \Downarrow (P, cs)}$$

**(Parse-ClassListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseClassPath}(\text{Advance}(P)) \Downarrow (P_1, c) \quad \Gamma \vdash \text{ParseClassListTail}(P_1, cs \mathbin{+\!\!+} [c]) \Downarrow (P_2, cs')}{\Gamma \vdash \text{ParseClassListTail}(P, cs) \Downarrow (P_2, cs')}$$


##### 3.3.6.10. Class Declarations

**(Parse-Superclass-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"<:"})}{\Gamma \vdash \text{ParseSuperclassOpt}(P) \Downarrow (P, [])}$$

**(Parse-Superclass-Yes)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"<:"}) \quad \Gamma \vdash \text{ParseSuperclassBounds}(\text{Advance}(P)) \Downarrow (P_1, supers)}{\Gamma \vdash \text{ParseSuperclassOpt}(P) \Downarrow (P_1, supers)}$$

**(Parse-SuperclassBounds-Cons)**
$$\frac{\Gamma \vdash \text{ParseClassPath}(P) \Downarrow (P_1, c_0) \quad \Gamma \vdash \text{ParseSuperclassBoundsTail}(P_1, [c_0]) \Downarrow (P_2, cs)}{\Gamma \vdash \text{ParseSuperclassBounds}(P) \Downarrow (P_2, cs)}$$

**(Parse-SuperclassBoundsTail-End)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"+"})}{\Gamma \vdash \text{ParseSuperclassBoundsTail}(P, cs) \Downarrow (P, cs)}$$

**(Parse-SuperclassBoundsTail-Plus)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"+"}) \quad \Gamma \vdash \text{ParseClassPath}(\text{Advance}(P)) \Downarrow (P_1, c) \quad \Gamma \vdash \text{ParseSuperclassBoundsTail}(P_1, cs \mathbin{+\!\!+} [c]) \Downarrow (P_2, cs')}{\Gamma \vdash \text{ParseSuperclassBoundsTail}(P, cs) \Downarrow (P_2, cs')}$$

**(Parse-ClassBody)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseClassItemList}(\text{Advance}(P)) \Downarrow (P_1, items) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseClassBody}(P) \Downarrow (\text{Advance}(P_1), items)}$$

**(Parse-ClassItemList-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseClassItemList}(P) \Downarrow (P, [])}$$

**(Parse-ClassItemList-Cons)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{"}"}) \quad \Gamma \vdash \text{ParseClassItem}(P) \Downarrow (P_1, it) \quad \Gamma \vdash \text{ParseClassItemList}(P_1) \Downarrow (P_2, rest)}{\Gamma \vdash \text{ParseClassItemList}(P) \Downarrow (P_2, [it] \mathbin{+\!\!+} rest)}$$

**(Parse-ClassItem-Method)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_0, vis) \quad \text{IsKw}(\text{Tok}(P_0), \texttt{procedure}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_0)) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseMethodSignature}(P_1) \Downarrow (P_2, receiver, params, ret\_opt) \quad \Gamma \vdash \text{ParseClassMethodBody}(P_2) \Downarrow (P_3, body\_opt)}{\Gamma \vdash \text{ParseClassItem}(P) \Downarrow (P_3, \langle \text{ClassMethodDecl}, vis, name, receiver, params, ret\_opt, body\_opt, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-ClassItem-Field)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_0, vis) \quad \Gamma \vdash \text{ParseIdent}(P_0) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_1)) \Downarrow (P_2, ty) \quad \Gamma \vdash \text{ConsumeTerminatorReq}(P_2) \Downarrow P_3}{\Gamma \vdash \text{ParseClassItem}(P) \Downarrow (P_3, \langle \text{ClassFieldDecl}, vis, name, ty, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-ClassMethodBody-Concrete)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseBlock}(P) \Downarrow (P_1, body)}{\Gamma \vdash \text{ParseClassMethodBody}(P) \Downarrow (P_1, body)}$$

**(Parse-ClassMethodBody-Abstract)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ConsumeTerminatorReq}(P) \Downarrow P_1}{\Gamma \vdash \text{ParseClassMethodBody}(P) \Downarrow (P_1, \bot)}$$

$$\text{UnsupportedClassItem} = \{\texttt{modal\_class},\ \texttt{type\_item},\ \texttt{abstract\_state},\ \texttt{override\_in\_class}\}$$
$$\text{UnsupportedClassItem} \subseteq \text{UnsupportedForm}$$

##### 3.3.6.11. Type Alias Declarations

**(Parse-Type-Alias)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{type}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{"="}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_2)) \Downarrow (P_3, ty)}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_3, \langle \text{TypeAliasDecl}, vis, name, ty, \text{SpanBetween}(P,P_3), [] \rangle)}$$

$$\text{UnsupportedWhereClause} = \{\texttt{where\_clause}\}$$
$$\text{UnsupportedWhereClause} \subseteq \text{UnsupportedForm}$$

##### 3.3.6.13. Item Helper Parsing Rules

**Type Paths.**

**(Parse-TypePath)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, id) \quad \Gamma \vdash \text{ParseTypePathTail}(P_1, [id]) \Downarrow (P_2, path)}{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_2, path)}$$


**(Parse-ClassPath)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path)}{\Gamma \vdash \text{ParseClassPath}(P) \Downarrow (P_1, path)}$$

**(Parse-TypePathTail-End)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"::"})}{\Gamma \vdash \text{ParseTypePathTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-TypePathTail-Cons)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"::"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, id) \quad \Gamma \vdash \text{ParseTypePathTail}(P_1, xs \mathbin{+\!\!+} [id]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseTypePathTail}(P, xs) \Downarrow (P_2, ys)}$$

**Qualified Head.**


**(Parse-QualifiedHead)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, id_0) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"::"}) \quad \Gamma \vdash \text{ParseModulePathTail}(P_1, [id_0]) \Downarrow (P_2, xs) \quad xs = ys \mathbin{+\!\!+} [name] \quad |xs| \ge 2}{\Gamma \vdash \text{ParseQualifiedHead}(P) \Downarrow (P_2, ys, name)}$$

**Using Lists.**


**(Parse-UsingSpec)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseAliasOpt}(P_1) \Downarrow (P_2, alias\_opt)}{\Gamma \vdash \text{ParseUsingSpec}(P) \Downarrow (P_2, \langle name, alias\_opt \rangle)}$$

**Bindings.**

**(Parse-BindingAfterLetVar)**
$$\frac{\text{Tok}(P) = kw \in \{\text{Keyword}(\texttt{let}),\ \text{Keyword}(\texttt{var})\} \quad \Gamma \vdash \text{ParsePattern}(\text{Advance}(P)) \Downarrow (P_1, pat) \quad \Gamma \vdash \text{ParseTypeAnnotOpt}(P_1) \Downarrow (P_2, ty\_opt) \quad \text{Tok}(P_2) \in \{\text{Operator}(\texttt{"="}),\ \text{Operator}(\texttt{":="})\} \quad op = \text{Tok}(P_2) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_2)) \Downarrow (P_3, init)}{\Gamma \vdash \text{ParseBindingAfterLetVar}(P) \Downarrow (P_3, \langle pat, ty\_opt, op, init, \text{SpanBetween}(P,P_3) \rangle)}$$

**(Parse-ShadowBinding)**
$$\frac{\text{Tok}(P) = kw \in \{\text{Keyword}(\texttt{let}),\ \text{Keyword}(\texttt{var})\} \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseTypeAnnotOpt}(P_1) \Downarrow (P_2, ty\_opt) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{"="}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_2)) \Downarrow (P_3, init) \quad s = (\text{ShadowLetStmt}(name, ty\_opt, init)\ \text{if}\ kw = \text{Keyword}(\texttt{let})\ \text{else}\ \text{ShadowVarStmt}(name, ty\_opt, init))}{\Gamma \vdash \text{ParseShadowBinding}(P) \Downarrow (P_3, s)}$$

**Record Bodies.**

**(Parse-RecordBody)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseRecordMemberList}(\text{Advance}(P)) \Downarrow (P_1, members) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseRecordBody}(P) \Downarrow (\text{Advance}(P_1), members)}$$

**Record Member Lists.**

**(Parse-RecordMemberList-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseRecordMemberList}(P) \Downarrow (P, [])}$$

**(Parse-RecordMemberList-Cons)**
$$\frac{\Gamma \vdash \text{ParseRecordMember}(P) \Downarrow (P_1, m) \quad \Gamma \vdash \text{ParseRecordMemberTail}(P_1, [m]) \Downarrow (P_2, ms)}{\Gamma \vdash \text{ParseRecordMemberList}(P) \Downarrow (P_2, ms)}$$

**(Parse-RecordMemberTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseRecordMemberTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-RecordMemberTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseRecordMemberTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-RecordMemberTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseRecordMember}(\text{Advance}(P)) \Downarrow (P_1, m) \quad \Gamma \vdash \text{ParseRecordMemberTail}(P_1, xs \mathbin{+\!\!+} [m]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseRecordMemberTail}(P, xs) \Downarrow (P_2, ys)}$$

**Record Members.**

**(Parse-RecordMember-Method)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{IsKw}(\text{Tok}(P_1), \texttt{procedure}) \quad \Gamma \vdash \text{ParseMethodDefAfterVis}(P_1, vis) \Downarrow (P_2, m)}{\Gamma \vdash \text{ParseRecordMember}(P) \Downarrow (P_2, m)}$$

**(Parse-RecordMember-Field)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \neg \text{IsKw}(\text{Tok}(P_1), \texttt{procedure}) \quad \Gamma \vdash \text{ParseRecordFieldDeclAfterVis}(P_1, vis) \Downarrow (P_2, f)}{\Gamma \vdash \text{ParseRecordMember}(P) \Downarrow (P_2, f)}$$

**Record Method Definitions.**

**(Parse-MethodDefAfterVis)**
$$\frac{\Gamma \vdash \text{ParseOverrideOpt}(P) \Downarrow (P_0, ov) \quad \text{IsKw}(\text{Tok}(P_0), \texttt{procedure}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_0)) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseMethodSignature}(P_1) \Downarrow (P_2, receiver, params, ret\_opt) \quad \Gamma \vdash \text{ParseBlock}(P_2) \Downarrow (P_3, body)}{\Gamma \vdash \text{ParseMethodDefAfterVis}(P, vis) \Downarrow (P_3, \langle \text{MethodDecl}, vis, ov, name, receiver, params, ret\_opt, body, \text{SpanBetween}(P,P_3), [] \rangle)}$$

**(Parse-Override-Yes)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{override})}{\Gamma \vdash \text{ParseOverrideOpt}(P) \Downarrow (\text{Advance}(P), \text{true})}$$

**(Parse-Override-No)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{override})}{\Gamma \vdash \text{ParseOverrideOpt}(P) \Downarrow (P, \text{false})}$$


**(Parse-MethodSignature)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseReceiver}(\text{Advance}(P)) \Downarrow (P_1, r) \quad \Gamma \vdash \text{ParseMethodParams}(P_1) \Downarrow (P_2, params) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{")"}) \quad \Gamma \vdash \text{ParseReturnOpt}(\text{Advance}(P_2)) \Downarrow (P_3, ret\_opt)}{\Gamma \vdash \text{ParseMethodSignature}(P) \Downarrow (P_3, r, params, ret\_opt)}$$

**(Parse-MethodParams-None)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseMethodParams}(P) \Downarrow (P, [])}$$

**(Parse-MethodParams-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseParamList}(\text{Advance}(P)) \Downarrow (P_1, params)}{\Gamma \vdash \text{ParseMethodParams}(P) \Downarrow (P_1, params)}$$

**Receiver Parsing.**

**(Parse-Receiver-Short-Const)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"~"})}{\Gamma \vdash \text{ParseReceiver}(P) \Downarrow (\text{Advance}(P), \text{ReceiverShorthand}(\texttt{const}))}$$

**(Parse-Receiver-Short-Unique)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"~!"})}{\Gamma \vdash \text{ParseReceiver}(P) \Downarrow (\text{Advance}(P), \text{ReceiverShorthand}(\texttt{unique}))}$$

**(Parse-Receiver-Explicit)**
$$\frac{\Gamma \vdash \text{ParseParamModeOpt}(P) \Downarrow (P_1, mode) \quad \text{IsIdent}(\text{Tok}(P_1)) \quad \text{Lexeme}(\text{Tok}(P_1)) = \texttt{self} \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_1)), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P_1))) \Downarrow (P_2, ty)}{\Gamma \vdash \text{ParseReceiver}(P) \Downarrow (P_2, \text{ReceiverExplicit}(mode, ty))}$$

**State Block Lists.**

**(Parse-StateBlockList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseStateBlockList}(P) \Downarrow (P, [])}$$

**(Parse-StateBlockList-Cons)**
$$\frac{\Gamma \vdash \text{ParseStateBlock}(P) \Downarrow (P_1, st) \quad \Gamma \vdash \text{ParseStateBlockList}(P_1) \Downarrow (P_2, sts)}{\Gamma \vdash \text{ParseStateBlockList}(P) \Downarrow (P_2, [st] \mathbin{+\!\!+} sts)}$$

**State Member Lists.**

**(Parse-StateMemberList-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseStateMemberList}(P) \Downarrow (P, [])}$$

**(Parse-StateMemberList-Cons)**
$$\frac{\Gamma \vdash \text{ParseStateMember}(P) \Downarrow (P_1, m) \quad \Gamma \vdash \text{ParseStateMemberList}(P_1) \Downarrow (P_2, ms)}{\Gamma \vdash \text{ParseStateMemberList}(P) \Downarrow (P_2, [m] \mathbin{+\!\!+} ms)}$$


**Enum Bodies.**

**(Parse-EnumBody)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseVariantList}(\text{Advance}(P)) \Downarrow (P_1, vars) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseEnumBody}(P) \Downarrow (\text{Advance}(P_1), vars)}$$

**Parameters and Returns.**

**(Parse-ParamList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseParamList}(P) \Downarrow (P, [])}$$

**(Parse-ParamList-Cons)**
$$\frac{\Gamma \vdash \text{ParseParam}(P) \Downarrow (P_1, param) \quad \Gamma \vdash \text{ParseParamTail}(P_1, [param]) \Downarrow (P_2, params)}{\Gamma \vdash \text{ParseParamList}(P) \Downarrow (P_2, params)}$$

**(Parse-ReturnOpt-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"->"})}{\Gamma \vdash \text{ParseReturnOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-ReturnOpt-Arrow)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"->"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, ty)}{\Gamma \vdash \text{ParseReturnOpt}(P) \Downarrow (P_1, ty)}$$

**(Parse-AliasOpt-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{as})}{\Gamma \vdash \text{ParseAliasOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-AliasOpt-Yes)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{as}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, id)}{\Gamma \vdash \text{ParseAliasOpt}(P) \Downarrow (P_1, id)}$$

**(Parse-TypeAnnotOpt-None)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{":"})}{\Gamma \vdash \text{ParseTypeAnnotOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-TypeAnnotOpt-Yes)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, ty)}{\Gamma \vdash \text{ParseTypeAnnotOpt}(P) \Downarrow (P_1, ty)}$$

**(Parse-UsingList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseUsingList}(P) \Downarrow (\text{Advance}(P), [])}$$

**(Parse-UsingList-Cons)**
$$\frac{\Gamma \vdash \text{ParseUsingSpec}(P) \Downarrow (P_1, s) \quad \Gamma \vdash \text{ParseUsingListTail}(P_1, [s]) \Downarrow (P_2, specs) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParseUsingList}(P) \Downarrow (\text{Advance}(P_2), specs)}$$

**(Parse-UsingListTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseUsingListTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-UsingListTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseUsingListTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-UsingListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseUsingSpec}(\text{Advance}(P)) \Downarrow (P_1, s) \quad \Gamma \vdash \text{ParseUsingListTail}(P_1, xs \mathbin{+\!\!+} [s]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseUsingListTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-RecordFieldDeclList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseRecordFieldDeclList}(P) \Downarrow (P, [])}$$

**(Parse-RecordFieldDeclList-Cons)**
$$\frac{\Gamma \vdash \text{ParseRecordFieldDecl}(P) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseRecordFieldDeclTail}(P_1, [f]) \Downarrow (P_2, fields)}{\Gamma \vdash \text{ParseRecordFieldDeclList}(P) \Downarrow (P_2, fields)}$$

**(Parse-RecordFieldDecl)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \Gamma \vdash \text{ParseRecordFieldDeclAfterVis}(P_1, vis) \Downarrow (P_2, f)}{\Gamma \vdash \text{ParseRecordFieldDecl}(P) \Downarrow (P_2, f)}$$

**(Parse-RecordFieldDeclAfterVis)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_1)) \Downarrow (P_2, ty) \quad \Gamma \vdash \text{ParseRecordFieldInitOpt}(P_2) \Downarrow (P_3, init\_opt)}{\Gamma \vdash \text{ParseRecordFieldDeclAfterVis}(P, vis) \Downarrow (P_3, \langle vis, name, ty, init\_opt \rangle)}$$

**(Parse-RecordFieldInitOpt-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"="})}{\Gamma \vdash \text{ParseRecordFieldInitOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-RecordFieldInitOpt-Yes)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"="}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseRecordFieldInitOpt}(P) \Downarrow (P_1, e)}$$

**(Parse-RecordFieldDeclTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseRecordFieldDeclTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-RecordFieldDeclTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseRecordFieldDeclTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-RecordFieldDeclTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseRecordFieldDecl}(\text{Advance}(P)) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseRecordFieldDeclTail}(P_1, xs \mathbin{+\!\!+} [f]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseRecordFieldDeclTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-FieldDeclList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseFieldDeclList}(P) \Downarrow (P, [])}$$

**(Parse-FieldDeclList-Cons)**
$$\frac{\Gamma \vdash \text{ParseFieldDecl}(P) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldDeclTail}(P_1, [f]) \Downarrow (P_2, fields)}{\Gamma \vdash \text{ParseFieldDeclList}(P) \Downarrow (P_2, fields)}$$

**(Parse-FieldDecl)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \Gamma \vdash \text{ParseIdent}(P_1) \Downarrow (P_2, name) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_2)) \Downarrow (P_3, ty)}{\Gamma \vdash \text{ParseFieldDecl}(P) \Downarrow (P_3, \langle vis, name, ty, \bot \rangle)}$$

**(Parse-FieldDeclTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseFieldDeclTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-FieldDeclTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseFieldDeclTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-FieldDeclTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseFieldDecl}(\text{Advance}(P)) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldDeclTail}(P_1, xs \mathbin{+\!\!+} [f]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseFieldDeclTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-VariantList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseVariantList}(P) \Downarrow (P, [])}$$

**(Parse-VariantList-Cons)**
$$\frac{\Gamma \vdash \text{ParseVariant}(P) \Downarrow (P_1, v) \quad \Gamma \vdash \text{ParseVariantTail}(P_1, [v]) \Downarrow (P_2, vs)}{\Gamma \vdash \text{ParseVariantList}(P) \Downarrow (P_2, vs)}$$

**(Parse-Variant)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseVariantPayloadOpt}(P_1) \Downarrow (P_2, payload\_opt) \quad \Gamma \vdash \text{ParseVariantDiscriminantOpt}(P_2) \Downarrow (P_3, disc\_opt)}{\Gamma \vdash \text{ParseVariant}(P) \Downarrow (P_3, \langle name, payload\_opt, disc\_opt \rangle)}$$

**(Parse-VariantPayloadOpt-None)**
$$\frac{\text{Tok}(P) \notin \{\text{Punctuator}(\texttt{"("}),\ \text{Punctuator}(\texttt{"{"})\}}{\Gamma \vdash \text{ParseVariantPayloadOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-VariantPayloadOpt-Tuple)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseTypeList}(\text{Advance}(P)) \Downarrow (P_1, ts) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParseVariantPayloadOpt}(P) \Downarrow (\text{Advance}(P_1), \text{TuplePayload}(ts))}$$

**(Parse-VariantPayloadOpt-Record)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldDeclList}(\text{Advance}(P)) \Downarrow (P_1, fs) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseVariantPayloadOpt}(P) \Downarrow (\text{Advance}(P_1), \text{RecordPayload}(fs))}$$

**(Parse-VariantDiscriminantOpt-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"="})}{\Gamma \vdash \text{ParseVariantDiscriminantOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-VariantDiscriminantOpt-Yes)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"="}) \quad t = \text{Tok}(\text{Advance}(P)) \quad t.\text{kind} = \text{IntLiteral}}{\Gamma \vdash \text{ParseVariantDiscriminantOpt}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), t)}$$
**(Parse-VariantTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseVariantTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-VariantTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseVariantTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-VariantTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseVariant}(\text{Advance}(P)) \Downarrow (P_1, v) \quad \Gamma \vdash \text{ParseVariantTail}(P_1, xs \mathbin{+\!\!+} [v]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseVariantTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-Param)**
$$\frac{\Gamma \vdash \text{ParseParamModeOpt}(P) \Downarrow (P_1, mode) \quad \Gamma \vdash \text{ParseIdent}(P_1) \Downarrow (P_2, name) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_2)) \Downarrow (P_3, ty)}{\Gamma \vdash \text{ParseParam}(P) \Downarrow (P_3, \langle mode, name, ty \rangle)}$$

**(Parse-ParamMode-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{move})}{\Gamma \vdash \text{ParseParamModeOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-ParamMode-Move)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{move})}{\Gamma \vdash \text{ParseParamModeOpt}(P) \Downarrow (\text{Advance}(P), \texttt{move})}$$

**(Parse-ParamTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseParamTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-ParamTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseParamTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-ParamTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseParam}(\text{Advance}(P)) \Downarrow (P_1, p) \quad \Gamma \vdash \text{ParseParamTail}(P_1, xs \mathbin{+\!\!+} [p]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseParamTail}(P, xs) \Downarrow (P_2, ys)}$$
**(Parse-Signature)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseParamList}(\text{Advance}(P)) \Downarrow (P_1, params) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"}) \quad \Gamma \vdash \text{ParseReturnOpt}(\text{Advance}(P_1)) \Downarrow (P_2, ret\_opt)}{\Gamma \vdash \text{ParseSignature}(P) \Downarrow (P_2, params, ret\_opt)}$$



##### 3.3.6.14. Unsupported Constructs (Parsing)

**(Parse-Import-Unsupported)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{import}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Import-Unsupported}))}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (\text{SyncItem}(\text{Advance}(P)), \text{ErrorItem}(\text{SpanBetween}(P,\text{Advance}(P))))}$$

**(Parse-Attribute-Unsupported)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"["}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"["}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{WF-Attr-Unsupported})) \quad \Gamma \vdash \text{SyncItem}(P) \Downarrow P_1}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_1, \text{ErrorItem}(\text{SpanBetween}(P,P_1)))}$$

**(Parse-Modal-Class-Unsupported)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{modal}) \quad \text{IsKw}(\text{Tok}(\text{Advance}(P)), \texttt{class}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (\text{SyncItem}(\text{Advance}(\text{Advance}(P))), \text{ErrorItem}(\text{SpanBetween}(P,\text{Advance}(\text{Advance}(P)))))}
$$

**(Parse-Extern-Unsupported)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{extern} \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Parse-Extern-Unsupported}))}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (\text{SyncItem}(\text{Advance}(P)), \text{ErrorItem}(\text{SpanBetween}(P,\text{Advance}(P))))}$$

**(Parse-Use-Unsupported)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{use} \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (\text{SyncItem}(\text{Advance}(P)), \text{ErrorItem}(\text{SpanBetween}(P,\text{Advance}(P))))}$$

**(Return-At-Module-Err)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{return}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Return-At-Module-Err}))}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (\text{SyncItem}(\text{Advance}(P)), \text{ErrorItem}(\text{SpanBetween}(P,\text{Advance}(P))))}$$

**Generic Syntax Rejection.**
$$\text{AngleDelta}(\text{Operator}(\texttt{"<"})) = 1$$
$$\text{AngleDelta}(\text{Operator}(\texttt{">"})) = -1$$
$$\text{AngleDelta}(\text{Operator}(\texttt{">>"})) = -2$$
$$\text{AngleDelta}(t) = 0 \ \text{if } t.\text{kind} \notin \{\text{Operator}(\texttt{"<"}),\text{Operator}(\texttt{">"}),\text{Operator}(\texttt{">>"})\}$$

$$\text{AngleStep}(P,d) = \langle \text{Advance}(P),\ d + \text{AngleDelta}(\text{Tok}(P)) \rangle$$
$$\text{AngleScan}(P_0,P,d) \Downarrow P'$$
$$\frac{\text{Tok}(P)=\text{EOF}}{\text{AngleScan}(P_0,P,d) \Downarrow P_0}$$
$$\frac{\text{Tok}(P)\ne \text{EOF} \quad \text{AngleStep}(P,d) = \langle P_1, d_1 \rangle \quad d_1 \ne 0 \quad \text{AngleScan}(P_0,P_1,d_1) \Downarrow P'}{\text{AngleScan}(P_0,P,d) \Downarrow P'}$$
$$\frac{\text{Tok}(P)\ne \text{EOF} \quad \text{AngleStep}(P,d) = \langle P_1, d_1 \rangle \quad d_1 = 0}{\text{AngleScan}(P_0,P,d) \Downarrow P_1}$$

$$\text{SkipAngles}(P_0) \Downarrow P' \iff \text{AngleScan}(P_0,P_0,0) \Downarrow P'$$

**(Parse-Generic-Header-Unsupported)**
$$\frac{\Gamma \vdash \text{ParseVis}(P) \Downarrow (P_1, vis) \quad \text{Tok}(P_1) = \text{Keyword}(kw) \quad kw \in \{\texttt{procedure},\texttt{record},\texttt{enum},\texttt{class},\texttt{modal},\texttt{type}\} \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{"<"}) \quad P_2' = \text{SkipAngles}(P_2) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct})) \quad \Gamma \vdash \text{SyncItem}(P_2') \Downarrow P_3}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_3, \text{ErrorItem}(\text{SpanBetween}(P,P_3)))}$$


**(Parse-Item-Err)**
$$\frac{c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span}) \quad P_1 = \text{AdvanceOrEOF}(P) \quad \Gamma \vdash \text{SyncItem}(P_1) \Downarrow P_2}{\Gamma \vdash \text{ParseItem}(P) \Downarrow (P_2,\ \text{ErrorItem}(\text{SpanBetween}(P,P_2)))}$$

#### 3.3.7. Type Parsing (C0 Subset)

**Type Start Predicate.**
$$\text{TypeStart}(t) \iff \text{IsKw}(t,\texttt{const}) \lor \text{IsKw}(t,\texttt{unique}) \lor \text{IsKw}(t,\texttt{shared}) \lor \text{Lexeme}(t) \in \text{PrimTypes}_{C0} \lor \text{IsPunc}(t,\texttt{"("}) \lor \text{IsPunc}(t,\texttt{"["}) \lor \text{IsOp}(t,\texttt{"*"}) \lor \text{IsOp}(t,\texttt{"$"}) \lor \text{Lexeme}(t) \in \{\texttt{string},\ \texttt{Ptr}\} \lor \text{IsIdent}(t)$$

**(Parse-Type)**
$$\frac{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (P_1, perm\_opt) \quad \Gamma \vdash \text{ParseNonPermType}(P_1) \Downarrow (P_2, base) \quad \Gamma \vdash \text{ParseUnionTail}(P_2) \Downarrow (P_3, ts) \quad base' = (base\ \text{if}\ ts = []\ \text{else}\ \text{TypeUnion}([base] \mathbin{+\!\!+} ts)) \quad ty = (base'\ \text{if}\ perm\_opt = \bot\ \text{else}\ \text{TypePerm}(perm\_opt, base'))}{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_3, ty)}$$

**(Parse-Type-Err)**
$$\frac{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (P_1, perm\_opt) \quad c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P_1).\text{span}) \quad base = \text{TypePrim}(\texttt{"!"}) \quad ty = (base\ \text{if}\ perm\_opt = \bot\ \text{else}\ \text{TypePerm}(perm\_opt, base))}{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, ty)}$$


**(Parse-Perm-Const)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{const})}{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (\text{Advance}(P), \texttt{const})}$$

**(Parse-Perm-Unique)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{unique})}{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (\text{Advance}(P), \texttt{unique})}$$

**(Parse-Perm-Shared)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{shared})}{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (\text{Advance}(P), \texttt{shared})}$$

**(Parse-Perm-None)**
$$\frac{\neg(\text{IsKw}(\text{Tok}(P), \texttt{const}) \lor \text{IsKw}(\text{Tok}(P), \texttt{unique}) \lor \text{IsKw}(\text{Tok}(P), \texttt{shared}))}{\Gamma \vdash \text{ParsePermOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-UnionTail-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"|"})}{\Gamma \vdash \text{ParseUnionTail}(P) \Downarrow (P, [])}$$

**(Parse-UnionTail-Cons)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"|"}) \quad \Gamma \vdash \text{ParseNonPermType}(\text{Advance}(P)) \Downarrow (P_1, t_1) \quad \Gamma \vdash \text{ParseUnionTail}(P_1) \Downarrow (P_2, ts)} {\Gamma \vdash \text{ParseUnionTail}(P) \Downarrow (P_2, [t_1] \mathbin{+\!\!+} ts)}$$


**Non-Permission Types.**

$$\text{PrimLexemeSet} = \text{PrimTypes}_{C0} \setminus \{\texttt{"()"},\ \texttt{"!"}\}$$
$$\text{BuiltinTypePath}(path) \iff (|path|=1 \land path[0] \in \text{PrimLexemeSet}) \lor path=[\texttt{"string"}] \lor path=[\texttt{"bytes"}]$$

**(Parse-Prim-Type)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) \in \text{PrimLexemeSet}}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(P), \text{TypePrim}(\text{Lexeme}(\text{Tok}(P))))}$$

**(Parse-Unit-Type)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{")"})}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \text{TypePrim}(\texttt{"()"}))}$$

**(Parse-Never-Type)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"!"})}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(P), \text{TypePrim}(\texttt{"!"}))}$$

**(Parse-Func-Type)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseParamTypeList}(\text{Advance}(P)) \Downarrow (P_1, params) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(P_1)), \texttt{"->"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P_1))) \Downarrow (P_2, ret)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_2, \text{TypeFunc}(params, ret))}$$

**(Parse-Tuple-Type)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseTupleTypeElems}(\text{Advance}(P)) \Downarrow (P_1, elems) \quad elems \ne [] \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(P_1), \text{TypeTuple}(elems))}$$

**(Parse-Array-Type)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"["}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, t) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{";"}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_1)) \Downarrow (P_2, e) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"]"})}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(P_2), \text{TypeArray}(t,e))}$$

**(Parse-Slice-Type)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"["}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, t) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"]"})}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (\text{Advance}(P_1), \text{TypeSlice}(t))}$$

**(Parse-Safe-Pointer-Type-ShiftSplit)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{Ptr} \quad \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"<"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P))) \Downarrow (P_1, t) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{">>"}) \quad P_1' = \text{SplitShiftR}(P_1) \quad \Gamma \vdash \text{ParsePtrState}(\text{Advance}(P_1')) \Downarrow (P_2, st\_opt)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_2, \text{TypePtr}(t, st\_opt))}$$

**(Parse-Safe-Pointer-Type)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{Ptr} \quad \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"<"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P))) \Downarrow (P_1, t) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{">"}) \quad \Gamma \vdash \text{ParsePtrState}(\text{Advance}(P_1)) \Downarrow (P_2, st\_opt)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_2, \text{TypePtr}(t, st\_opt))}$$

**(Parse-Raw-Pointer-Type)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"*"}) \quad \text{IsKw}(\text{Tok}(\text{Advance}(P)), q) \quad q \in \{\texttt{imm},\texttt{mut}\} \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P))) \Downarrow (P_1, t)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_1, \text{TypeRawPtr}(q, t))}$$

**(Parse-String-Type)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{string} \quad \Gamma \vdash \text{ParseStringState}(\text{Advance}(P)) \Downarrow (P_1, st\_opt)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_1, \text{TypeString}(st\_opt))}$$

**(Parse-Bytes-Type)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{bytes} \quad \Gamma \vdash \text{ParseBytesState}(\text{Advance}(P)) \Downarrow (P_1, st\_opt)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_1, \text{TypeBytes}(st\_opt))}$$

**(Parse-Dynamic-Type)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"$"}) \quad \Gamma \vdash \text{ParseTypePath}(\text{Advance}(P)) \Downarrow (P_1, path)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_1, \text{TypeDynamic}(path))}$$

**(Parse-Modal-State-Type)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"@"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, state)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_2, \text{TypeModalState}(path, state))}$$

**(Parse-Type-Generic-Unsupported)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"<"}) \quad path \ne [\texttt{Ptr}] \quad P_1' = \text{SkipAngles}(P_1) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct})) \quad \Gamma \vdash \text{SyncType}(P_1') \Downarrow P_2}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_2, \text{TypePath}(path))}$$

**(Parse-Type-Path)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \neg \text{IsOp}(\text{Tok}(P_1), \texttt{"@"}) \quad \neg \text{IsOp}(\text{Tok}(P_1), \texttt{"<"} ) \quad \neg \text{BuiltinTypePath}(path)}{\Gamma \vdash \text{ParseNonPermType}(P) \Downarrow (P_1, \text{TypePath}(path))}$$

##### 3.3.7.1. Type Helper Parsing Rules

**Tuple Type Elements.**

**(Parse-TupleTypeElems-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseTupleTypeElems}(P) \Downarrow (P, [])}$$

**(Parse-TupleTypeElems-One)**
$$\frac{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, t) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{";"})}{\Gamma \vdash \text{ParseTupleTypeElems}(P) \Downarrow (\text{Advance}(P_1), [t])}$$

**(Parse-TupleTypeElems-TrailingComma)**
$$\frac{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, t) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_1)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseTupleTypeElems}(P) \Downarrow (\text{Advance}(P_1), [t])}$$

**(Parse-TupleTypeElems-Many)**
$$\frac{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, t_1) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_1)) \Downarrow (P_2, t_2) \quad \Gamma \vdash \text{ParseTypeListTail}(P_2, [t_2]) \Downarrow (P_3, ts)}{\Gamma \vdash \text{ParseTupleTypeElems}(P) \Downarrow (P_3, [t_1] \mathbin{+\!\!+} ts)}$$

**Param Type Lists.**

**(Parse-ParamTypeList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseParamTypeList}(P) \Downarrow (P, [])}$$

**(Parse-ParamTypeList-Cons)**
$$\frac{\Gamma \vdash \text{ParseParamType}(P) \Downarrow (P_1, pt) \quad \Gamma \vdash \text{ParseParamTypeListTail}(P_1, [pt]) \Downarrow (P_2, pts)}{\Gamma \vdash \text{ParseParamTypeList}(P) \Downarrow (P_2, pts)}$$

**(Parse-ParamTypeListTail-End)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{","})}{\Gamma \vdash \text{ParseParamTypeListTail}(P, ps) \Downarrow (P, ps)}$$

**(Parse-ParamTypeListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseParamType}(\text{Advance}(P)) \Downarrow (P_1, pt) \quad \Gamma \vdash \text{ParseParamTypeListTail}(P_1, ps \mathbin{+\!\!+} [pt]) \Downarrow (P_2, ps')}{\Gamma \vdash \text{ParseParamTypeListTail}(P, ps) \Downarrow (P_2, ps')}$$

**Param Types.**

**(Parse-ParamType-Move)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{move}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, ty)}{\Gamma \vdash \text{ParseParamType}(P) \Downarrow (P_1, \langle \texttt{move}, ty \rangle)}$$

**(Parse-ParamType-Plain)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{move}) \quad \Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, ty)}{\Gamma \vdash \text{ParseParamType}(P) \Downarrow (P_1, \langle \bot, ty \rangle)}$$

**String State.**

**(Parse-StringState-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"@"})}{\Gamma \vdash \text{ParseStringState}(P) \Downarrow (P, \bot)}$$

**(Parse-StringState-Managed)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{Managed}}{\Gamma \vdash \text{ParseStringState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{Managed})}$$

**(Parse-StringState-View)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{View}}{\Gamma \vdash \text{ParseStringState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{View})}$$

**Bytes State.**

**(Parse-BytesState-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"@"})}{\Gamma \vdash \text{ParseBytesState}(P) \Downarrow (P, \bot)}$$

**(Parse-BytesState-Managed)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{Managed}}{\Gamma \vdash \text{ParseBytesState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{Managed})}$$

**(Parse-BytesState-View)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{View}}{\Gamma \vdash \text{ParseBytesState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{View})}$$

**Pointer State.**

**(Parse-PtrState-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"@"})}{\Gamma \vdash \text{ParsePtrState}(P) \Downarrow (P, \bot)}$$

**(Parse-PtrState-Valid)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{Valid}}{\Gamma \vdash \text{ParsePtrState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{Valid})}$$

**(Parse-PtrState-Null)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{Null}}{\Gamma \vdash \text{ParsePtrState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{Null})}$$

**(Parse-PtrState-Expired)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad \text{Lexeme}(\text{Tok}(\text{Advance}(P))) = \texttt{Expired}}{\Gamma \vdash \text{ParsePtrState}(P) \Downarrow (\text{Advance}(\text{Advance}(P)), \texttt{Expired})}$$

**Type Lists.**

**(Parse-TypeList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseTypeList}(P) \Downarrow (P, [])}$$

**(Parse-TypeList-Cons)**
$$\frac{\Gamma \vdash \text{ParseType}(P) \Downarrow (P_1, t) \quad \Gamma \vdash \text{ParseTypeListTail}(P_1, [t]) \Downarrow (P_2, ts)}{\Gamma \vdash \text{ParseTypeList}(P) \Downarrow (P_2, ts)}$$

**(Parse-TypeListTail-End)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"}"})\}}{\Gamma \vdash \text{ParseTypeListTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-TypeListTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{Tok}(\text{Advance}(P)) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"}"})\} \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseTypeListTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-TypeListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, t) \quad \Gamma \vdash \text{ParseTypeListTail}(P_1, xs \mathbin{+\!\!+} [t]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseTypeListTail}(P, xs) \Downarrow (P_2, ys)}$$

#### 3.3.8. Expression Parsing and Precedence

**Operator Sets.**
$$\text{LogicalOrOps} = \{\texttt{"||"}\}$$
$$\text{LogicalAndOps} = \{\texttt{"&&"}\}$$
$$\text{ComparisonOps} = \{\texttt{"=="},\ \texttt{"!="},\ \texttt{"<"},\ \texttt{"<="},\ \texttt{">"},\ \texttt{">="}\}$$
$$\text{BitOrOps} = \{\texttt{"|"}\}$$
$$\text{BitXorOps} = \{\texttt{"^"}\}$$
$$\text{BitAndOps} = \{\texttt{"&"}\}$$
$$\text{AddOps} = \{\texttt{"+"},\ \texttt{"-"}\}$$
$$\text{MulOps} = \{\texttt{"*"},\ \texttt{"/"},\ \texttt{"%"}\}$$

**(Parse-Expr)**
$$\frac{\Gamma \vdash \text{ParseRange}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e)}$$

##### 3.3.8.1. Range Expressions

$$\text{ExprStart}(t) \iff \text{IsIdent}(t)\ \lor\ (t \in \text{LiteralToken})\ \lor\ \text{IsPunc}(t,\texttt{"("})\ \lor\ \text{IsPunc}(t,\texttt{"["})\ \lor\ \text{IsPunc}(t,\texttt{"{"})$$
$$\phantom{\text{ExprStart}(t) \iff}\ \lor\ \text{IsOp}(t,\texttt{"!"})\ \lor\ \text{IsOp}(t,\texttt{"-"})\ \lor\ \text{IsOp}(t,\texttt{"&"})\ \lor\ \text{IsOp}(t,\texttt{"*"})\ \lor\ \text{IsOp}(t,\texttt{"^"})$$
$$\phantom{\text{ExprStart}(t) \iff}\ \lor\ \text{IsKw}(t,\texttt{if})\ \lor\ \text{IsKw}(t,\texttt{match})\ \lor\ \text{IsKw}(t,\texttt{loop})\ \lor\ \text{IsKw}(t,\texttt{unsafe})\ \lor\ \text{IsKw}(t,\texttt{move})\ \lor\ \text{IsKw}(t,\texttt{transmute})\ \lor\ \text{IsKw}(t,\texttt{widen})$$

**(Parse-Range-To)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{".."}) \quad \Gamma \vdash \text{ParseLogicalOr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseRange}(P) \Downarrow (P_1, \text{Range}({\tt To}, \bot, e))}$$

**(Parse-Range-ToInc)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"..="}) \quad \Gamma \vdash \text{ParseLogicalOr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseRange}(P) \Downarrow (P_1, \text{Range}({\tt ToInclusive}, \bot, e))}$$

**(Parse-Range-Full)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{".."}) \quad \text{Tok}(\text{Advance}(P)) \notin \text{ExprStart}}{\Gamma \vdash \text{ParseRange}(P) \Downarrow (\text{Advance}(P), \text{Range}({\tt Full}, \bot, \bot))}$$

**(Parse-Range-Lhs)**
$$\frac{\Gamma \vdash \text{ParseLogicalOr}(P) \Downarrow (P_1, e_0) \quad \Gamma \vdash \text{ParseRangeTail}(P_1, e_0) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParseRange}(P) \Downarrow (P_2, e)}$$

**(Parse-RangeTail-None)**
$$\frac{\neg(\text{IsOp}(\text{Tok}(P), \texttt{".."}) \lor \text{IsOp}(\text{Tok}(P), \texttt{"..="}))}{\Gamma \vdash \text{ParseRangeTail}(P, e) \Downarrow (P, e)}$$

**(Parse-RangeTail-From)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{".."}) \quad \text{Tok}(\text{Advance}(P)) \notin \text{ExprStart}}{\Gamma \vdash \text{ParseRangeTail}(P, e_0) \Downarrow (\text{Advance}(P), \text{Range}({\tt From}, e_0, \bot))}$$

**(Parse-RangeTail-Excl)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{".."}) \quad \text{Tok}(\text{Advance}(P)) \in \text{ExprStart} \quad \Gamma \vdash \text{ParseLogicalOr}(\text{Advance}(P)) \Downarrow (P_1, e_1)}{\Gamma \vdash \text{ParseRangeTail}(P, e_0) \Downarrow (P_1, \text{Range}({\tt Exclusive}, e_0, e_1))}$$

**(Parse-RangeTail-Incl)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"..="}) \quad \Gamma \vdash \text{ParseLogicalOr}(\text{Advance}(P)) \Downarrow (P_1, e_1)}{\Gamma \vdash \text{ParseRangeTail}(P, e_0) \Downarrow (P_1, \text{Range}({\tt Inclusive}, e_0, e_1))}$$

##### 3.3.8.2. Binary Operator Chains

$$\Gamma \vdash \text{ParseLogicalOr}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{LogicalOrOps}, \text{ParseLogicalAnd}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseLogicalAnd}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{LogicalAndOps}, \text{ParseComparison}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseComparison}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{ComparisonOps}, \text{ParseBitOr}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseBitOr}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{BitOrOps}, \text{ParseBitXor}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseBitXor}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{BitXorOps}, \text{ParseBitAnd}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseBitAnd}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{BitAndOps}, \text{ParseShift}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseShift}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{ShiftOps}, \text{ParseAdd}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseAdd}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{AddOps}, \text{ParseMul}) \Downarrow (P', e)$$
$$\Gamma \vdash \text{ParseMul}(P) \Downarrow (P', e) \iff \Gamma \vdash \text{ParseLeftChain}(P, \text{MulOps}, \text{ParsePower}) \Downarrow (P', e)$$

**(Parse-LeftChain)**
$$\frac{\Gamma \vdash \text{ParseHigher}(P) \Downarrow (P_1, e_0) \quad \Gamma \vdash \text{ParseLeftChainTail}(P_1, e_0, OpSet, ParseHigher) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParseLeftChain}(P, OpSet, ParseHigher) \Downarrow (P_2, e)}$$

**(Parse-LeftChain-Stop)**
$$\frac{\text{Tok}(P) \notin OpSet}{\Gamma \vdash \text{ParseLeftChainTail}(P, e, OpSet, ParseHigher) \Downarrow (P, e)}$$

**(Parse-LeftChain-Cons)**
$$\frac{\text{Tok}(P) = op \in OpSet \quad \Gamma \vdash \text{ParseHigher}(\text{Advance}(P)) \Downarrow (P_1, e_1) \quad e' = \text{Binary}(op, e, e_1) \quad \Gamma \vdash \text{ParseLeftChainTail}(P_1, e', OpSet, ParseHigher) \Downarrow (P_2, e'')}{\Gamma \vdash \text{ParseLeftChainTail}(P, e, OpSet, ParseHigher) \Downarrow (P_2, e'')}$$


##### 3.3.8.3. Power (Right-Associative)

**(Parse-Power)**
$$\frac{\Gamma \vdash \text{ParseCast}(P) \Downarrow (P_1, e_0) \quad \Gamma \vdash \text{ParsePowerTail}(P_1, e_0) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParsePower}(P) \Downarrow (P_2, e)}$$

**(Parse-PowerTail-None)**
$$\frac{\neg \text{IsOp}(\text{Tok}(P), \texttt{"**"})}{\Gamma \vdash \text{ParsePowerTail}(P, e) \Downarrow (P, e)}$$

**(Parse-PowerTail-Cons)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"**"}) \quad \Gamma \vdash \text{ParsePower}(\text{Advance}(P)) \Downarrow (P_1, e_1)}{\Gamma \vdash \text{ParsePowerTail}(P, e_0) \Downarrow (P_1, \text{Binary}(\texttt{"**"}, e_0, e_1))}$$

##### 3.3.8.4. Cast Expressions

**(Parse-Cast)**
$$\frac{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, e) \quad \Gamma \vdash \text{ParseCastTail}(P_1, e) \Downarrow (P_2, e')} {\Gamma \vdash \text{ParseCast}(P) \Downarrow (P_2, e')}$$

**(Parse-CastTail-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{as})}{\Gamma \vdash \text{ParseCastTail}(P, e) \Downarrow (P, e)}$$

**(Parse-CastTail-As)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{as}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P)) \Downarrow (P_1, t)}{\Gamma \vdash \text{ParseCastTail}(P, e) \Downarrow (P_1, \text{Cast}(e,t))}$$

##### 3.3.8.5. Unary and Postfix

**(Parse-Unary-Prefix)**
$$\frac{\text{Tok}(P) = op \in \{\texttt{"!"}, \texttt{"-"}\} \quad \Gamma \vdash \text{ParseUnary}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, \text{Unary}(op,e))}$$

**(Parse-Unary-Deref)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"*"}) \quad \Gamma \vdash \text{ParseUnary}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, \text{Deref}(e))}$$

**(Parse-Unary-AddressOf)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"&"}) \quad \Gamma \vdash \text{ParsePlace}(\text{Advance}(P)) \Downarrow (P_1, p)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, \text{AddressOf}(p))}$$

**(Parse-Unary-Move)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{move}) \quad \Gamma \vdash \text{ParsePlace}(\text{Advance}(P)) \Downarrow (P_1, p)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, \text{MoveExpr}(p))}$$

**(Parse-Unary-Widen)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{widen}) \quad \Gamma \vdash \text{ParseUnary}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, \text{Unary}(\texttt{"widen"}, e))}$$

**(Parse-Unary-Postfix)**
$$\frac{\Gamma \vdash \text{ParsePostfix}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseUnary}(P) \Downarrow (P_1, e)}$$

**(Parse-Postfix)**
$$\frac{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, e_0) \quad \Gamma \vdash \text{ParsePostfixTail}(P_1, e_0) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParsePostfix}(P) \Downarrow (P_2, e)}$$

##### 3.3.8.6. Primary Expressions

**(Parse-Comptime-Unsupported)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{comptime} \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"{"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct})) \quad \Gamma \vdash \text{SyncStmt}(P) \Downarrow P_1}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, \text{ErrorExpr}(\text{SpanBetween}(P,P_1)))}$$

**(Parse-Literal-Expr)**
$$\frac{\text{Tok}(P).\text{kind} \in \{\text{IntLiteral},\text{FloatLiteral},\text{StringLiteral},\text{CharLiteral},\text{BoolLiteral},\text{NullLiteral}\}}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P), \text{Literal}(\text{Tok}(P)))}$$

**(Parse-Null-Ptr)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{Ptr} \quad \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"::"}) \quad \text{Tok}(\text{Advance}(\text{Advance}(P))).\text{kind} = \text{NullLiteral} \quad \text{IsPunc}(\text{Tok}(\text{Advance}(\text{Advance}(\text{Advance}(P)))), \texttt{"("}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(\text{Advance}(\text{Advance}(\text{Advance}(P))))), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(\text{Advance}(\text{Advance}(\text{Advance}(\text{Advance}(P))))), \text{PtrNullExpr})}$$

**(Parse-Alloc-Implicit)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"^"}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, \text{AllocExpr}(\bot, e))}$$


**(Parse-Identifier-Expr)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \neg \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"::"}) \quad \neg \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"@"}) \quad \neg \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"{"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P), \text{Identifier}(\text{Lexeme}(\text{Tok}(P))))}$$

**(Parse-Qualified-Generic-Unsupported)**
$$\frac{\Gamma \vdash \text{ParseQualifiedHead}(P) \Downarrow (P_1, path, name) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"<"}) \quad P_1' = \text{SkipAngles}(P_1) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct})) \quad \Gamma \vdash \text{SyncStmt}(P_1') \Downarrow P_2}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_2, \text{ErrorExpr}(\text{SpanBetween}(P,P_2)))}$$

**(Parse-Qualified-Name)**
$$\frac{\Gamma \vdash \text{ParseQualifiedHead}(P) \Downarrow (P_1, path, name) \quad \text{Tok}(P_1) \notin \{\text{Punctuator}(\texttt{"("}),\ \text{Punctuator}(\texttt{"{"})\} \quad \neg \text{IsOp}(\text{Tok}(P_1), \texttt{"@"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, \text{QualifiedName}(path, name))}$$

**(Parse-Qualified-Apply-Paren)**
$$\frac{\Gamma \vdash \text{ParseQualifiedHead}(P) \Downarrow (P_1, path, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"("}) \quad \Gamma \vdash \text{ParseArgList}(\text{Advance}(P_1)) \Downarrow (P_2, args) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_2), \text{QualifiedApply}(path, name, \text{Paren}(args)))}$$

**(Parse-Qualified-Apply-Brace)**
$$\frac{\Gamma \vdash \text{ParseQualifiedHead}(P) \Downarrow (P_1, path, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldInitList}(\text{Advance}(P_1)) \Downarrow (P_2, fields) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_2), \text{QualifiedApply}(path, name, \text{Brace}(fields)))}$$

**(Parse-Parenthesized-Expr)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \neg \text{TupleParen}(P) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_1), e)}$$

**(Parse-Tuple-Literal)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \text{TupleParen}(P) \quad \Gamma \vdash \text{ParseTupleExprElems}(\text{Advance}(P)) \Downarrow (P_1, elems) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_1), \text{TupleExpr}(elems))}$$

**(Parse-Array-Literal)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"["}) \quad \Gamma \vdash \text{ParseExprList}(\text{Advance}(P)) \Downarrow (P_1, elems) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"]"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_1), \text{ArrayExpr}(elems))}$$

**(Parse-Record-Literal-ModalState)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"@"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, state) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldInitList}(\text{Advance}(P_2)) \Downarrow (P_3, fields) \quad \text{IsPunc}(\text{Tok}(P_3), \texttt{"}"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_3), \text{RecordExpr}(\text{ModalStateRef}(path, state), fields))}$$

**(Parse-Record-Literal)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad |path| = 1 \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldInitList}(\text{Advance}(P_1)) \Downarrow (P_2, fields) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_2), \text{RecordExpr}(\text{TypePath}(path), fields))}$$


$$\text{RuleSet}(\text{ParsePrimary\_NoBrace}) = \text{RuleSet}(\text{ParsePrimary}) \setminus \{\text{Parse-Record-Literal},\ \text{Parse-Record-Literal-ModalState},\ \text{Parse-Qualified-Apply-Brace}\}$$
$$\text{RuleSet}(\text{ParsePostfix\_NoBrace}) = \text{RuleSet}(\text{ParsePostfix})\ \text{with}\ \text{ParsePrimary}\ \text{replaced by}\ \text{ParsePrimary\_NoBrace}$$
$$\text{RuleSet}(\text{ParseUnary\_NoBrace}) = \text{RuleSet}(\text{ParseUnary})\ \text{with}\ \text{ParsePostfix}\ \text{replaced by}\ \text{ParsePostfix\_NoBrace}$$
$$\text{RuleSet}(\text{ParseLogicalOr\_NoBrace}) = \text{RuleSet}(\text{ParseLogicalOr})\ \text{with}\ \text{ParseLogicalAnd}\ \text{replaced by}\ \text{ParseLogicalAnd\_NoBrace}$$
$$\text{RuleSet}(\text{ParseLogicalAnd\_NoBrace}) = \text{RuleSet}(\text{ParseLogicalAnd})\ \text{with}\ \text{ParseComparison}\ \text{replaced by}\ \text{ParseComparison\_NoBrace}$$
$$\text{RuleSet}(\text{ParseComparison\_NoBrace}) = \text{RuleSet}(\text{ParseComparison})\ \text{with}\ \text{ParseBitOr}\ \text{replaced by}\ \text{ParseBitOr\_NoBrace}$$
$$\text{RuleSet}(\text{ParseBitOr\_NoBrace}) = \text{RuleSet}(\text{ParseBitOr})\ \text{with}\ \text{ParseBitXor}\ \text{replaced by}\ \text{ParseBitXor\_NoBrace}$$
$$\text{RuleSet}(\text{ParseBitXor\_NoBrace}) = \text{RuleSet}(\text{ParseBitXor})\ \text{with}\ \text{ParseBitAnd}\ \text{replaced by}\ \text{ParseBitAnd\_NoBrace}$$
$$\text{RuleSet}(\text{ParseBitAnd\_NoBrace}) = \text{RuleSet}(\text{ParseBitAnd})\ \text{with}\ \text{ParseShift}\ \text{replaced by}\ \text{ParseShift\_NoBrace}$$
$$\text{RuleSet}(\text{ParseShift\_NoBrace}) = \text{RuleSet}(\text{ParseShift})\ \text{with}\ \text{ParseAdd}\ \text{replaced by}\ \text{ParseAdd\_NoBrace}$$
$$\text{RuleSet}(\text{ParseAdd\_NoBrace}) = \text{RuleSet}(\text{ParseAdd})\ \text{with}\ \text{ParseMul}\ \text{replaced by}\ \text{ParseMul\_NoBrace}$$
$$\text{RuleSet}(\text{ParseMul\_NoBrace}) = \text{RuleSet}(\text{ParseMul})\ \text{with}\ \text{ParsePower}\ \text{replaced by}\ \text{ParsePower\_NoBrace}$$
$$\text{RuleSet}(\text{ParseRange\_NoBrace}) = \text{RuleSet}(\text{ParseRange})\ \text{with}\ \text{ParseLogicalOr}\ \text{replaced by}\ \text{ParseLogicalOr\_NoBrace}$$
$$\text{RuleSet}(\text{ParseExpr\_NoBrace}) = \text{RuleSet}(\text{ParseExpr})\ \text{with}\ \text{ParseRange}\ \text{replaced by}\ \text{ParseRange\_NoBrace}$$

$$\frac{\Gamma \vdash \text{ParseRange\_NoBrace}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseExpr\_NoBrace}(P) \Downarrow (P_1, e)}$$

**(Parse-If-Expr)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{if}) \quad \Gamma \vdash \text{ParseExpr\_NoBrace}(\text{Advance}(P)) \Downarrow (P_1, c) \quad \Gamma \vdash \text{ParseBlock}(P_1) \Downarrow (P_2, b1) \quad \Gamma \vdash \text{ParseElseOpt}(P_2) \Downarrow (P_3, b2)}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_3, \text{IfExpr}(c,b1,b2))}$$

**(Parse-Match-Expr)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{match}) \quad \Gamma \vdash \text{ParseExpr\_NoBrace}(\text{Advance}(P)) \Downarrow (P_1, e) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"{"}) \quad \Gamma \vdash \text{ParseMatchArms}(\text{Advance}(P_1)) \Downarrow (P_2, arms) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_2), \text{MatchExpr}(e, arms))}$$

**(Parse-Loop-Expr)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{loop}) \quad \Gamma \vdash \text{ParseLoopTail}(\text{Advance}(P)) \Downarrow (P_1, loop)}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, loop)}$$

**(Parse-Block-Expr)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseBlock}(P) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, b)}$$

**(Parse-Unsafe-Expr)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{unsafe}) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(P)) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_1, \text{UnsafeBlockExpr}(b))}$$

**(Parse-Transmute-Expr-ShiftSplit)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{transmute}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"::"}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(\text{Advance}(P))), \texttt{"<"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(\text{Advance}(P)))) \Downarrow (P_1, t1) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_1)) \Downarrow (P_2, t2) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{">>"}) \quad P_2' = \text{SplitShiftR}(P_2) \quad \text{IsOp}(\text{Tok}(P_2'), \texttt{">"}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_2')), \texttt{"("}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(\text{Advance}(P_2'))) \Downarrow (P_3, e) \quad \text{IsPunc}(\text{Tok}(P_3), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_3), \text{TransmuteExpr}(t1, t2, e))}$$

**(Parse-Transmute-Expr)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{transmute}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(P)), \texttt{"::"}) \quad \text{IsOp}(\text{Tok}(\text{Advance}(\text{Advance}(P))), \texttt{"<"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(\text{Advance}(P)))) \Downarrow (P_1, t1) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(P_1)) \Downarrow (P_2, t2) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{">"}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_2)), \texttt{"("}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(\text{Advance}(P_2))) \Downarrow (P_3, e) \quad \text{IsPunc}(\text{Tok}(P_3), \texttt{")"})}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (\text{Advance}(P_3), \text{TransmuteExpr}(t1, t2, e))}$$


**(Parse-Primary-Err)**
$$\frac{c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span}) \quad P_1 = \text{AdvanceOrEOF}(P) \quad \Gamma \vdash \text{SyncStmt}(P_1) \Downarrow P_2}{\Gamma \vdash \text{ParsePrimary}(P) \Downarrow (P_2,\ \text{ErrorExpr}(\text{SpanBetween}(P, P_2)))}$$

##### 3.3.8.7. Expression Helper Parsing Rules

**Postfix Tail.**

**(Parse-PostfixTail-Stop)**
$$\frac{\text{Tok}(P) \notin \text{PostfixStart}}{\Gamma \vdash \text{ParsePostfixTail}(P, e) \Downarrow (P, e)}$$

**(Parse-PostfixTail-Cons)**
$$\frac{\text{Tok}(P) \in \text{PostfixStart} \quad \Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (P_1, e_1) \quad \Gamma \vdash \text{ParsePostfixTail}(P_1, e_1) \Downarrow (P_2, e_2)}{\Gamma \vdash \text{ParsePostfixTail}(P, e) \Downarrow (P_2, e_2)}$$

$$\text{PostfixStart} = \{\text{Punctuator}(\texttt{"."}),\ \text{Punctuator}(\texttt{"["}),\ \text{Punctuator}(\texttt{"("}),\ \text{Operator}(\texttt{"~>"}),\ \text{Operator}(\texttt{"?"})\}$$

**(Postfix-Field)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"."}) \quad \text{IsIdent}(\text{Tok}(\text{Advance}(P))) \quad name = \text{Lexeme}(\text{Tok}(\text{Advance}(P)))}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(\text{Advance}(P)), \text{FieldAccess}(e,name))}$$

**(Postfix-TupleIndex)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"."}) \quad t = \text{Tok}(\text{Advance}(P)) \quad t.\text{kind} = \text{IntLiteral} \quad idx = \text{IntValue}(t)}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(\text{Advance}(P)), \text{TupleAccess}(e, idx))}$$

**(Postfix-Index)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"["}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, idx) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"]"})}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(P_1), \text{IndexAccess}(e, idx))}$$

**(Postfix-Call)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseArgList}(\text{Advance}(P)) \Downarrow (P_1, args) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(P_1), \text{Call}(e, args))}$$

**(Postfix-MethodCall)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"~>"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"("}) \quad \Gamma \vdash \text{ParseArgList}(\text{Advance}(P_1)) \Downarrow (P_2, args) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{")"})}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(P_2), \text{MethodCall}(e, name, args))}$$

**(Postfix-Propagate)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"?"})}{\Gamma \vdash \text{PostfixStep}(P, e) \Downarrow (\text{Advance}(P), \text{Propagate}(e))}$$

**Argument Lists.**

**(Parse-ArgList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseArgList}(P) \Downarrow (P, [])}$$

**(Parse-ArgList-Cons)**
$$\frac{\Gamma \vdash \text{ParseArg}(P) \Downarrow (P_1, a) \quad \Gamma \vdash \text{ParseArgTail}(P_1, [a]) \Downarrow (P_2, args)}{\Gamma \vdash \text{ParseArgList}(P) \Downarrow (P_2, args)}$$

**(Parse-Arg)**
$$\frac{\Gamma \vdash \text{ParseArgMoveOpt}(P) \Downarrow (P_1, moved) \quad \Gamma \vdash \text{ParseExpr}(P_1) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParseArg}(P) \Downarrow (P_2, \langle moved, e, \text{SpanBetween}(P,P_2) \rangle)}$$

**(Parse-ArgMoveOpt-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{move})}{\Gamma \vdash \text{ParseArgMoveOpt}(P) \Downarrow (P, \text{false})}$$

**(Parse-ArgMoveOpt-Yes)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{move})}{\Gamma \vdash \text{ParseArgMoveOpt}(P) \Downarrow (\text{Advance}(P), \text{true})}$$

**Expression Lists.**

**(Parse-ExprList-Cons)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e) \quad \Gamma \vdash \text{ParseExprListTail}(P_1, [e]) \Downarrow (P_2, es)}{\Gamma \vdash \text{ParseExprList}(P) \Downarrow (P_2, es)}$$

**(Parse-ExprList-Empty)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"})\} \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseExprList}(P) \Downarrow (P, [])}$$

**Tuple Expression Elements.**

**(Parse-TupleExprElems-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseTupleExprElems}(P) \Downarrow (P, [])}$$

**(Parse-TupleExprElems-Single)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{";"})}{\Gamma \vdash \text{ParseTupleExprElems}(P) \Downarrow (\text{Advance}(P_1), [e])}$$

**(Parse-TupleExprElems-TrailingComma)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_1)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseTupleExprElems}(P) \Downarrow (\text{Advance}(P_1), [e])}$$

**(Parse-TupleExprElems-Many)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e_1) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_1)) \Downarrow (P_2, e_2) \quad \Gamma \vdash \text{ParseExprListTail}(P_2, [e_2]) \Downarrow (P_3, es)}{\Gamma \vdash \text{ParseTupleExprElems}(P) \Downarrow (P_3, [e_1] \mathbin{+\!\!+} es)}$$

**Tuple vs Parenthesized Disambiguation.**
$$\text{ParenDelta}(\text{Punctuator}(\texttt{"("})) = 1$$
$$\text{ParenDelta}(\text{Punctuator}(\texttt{")"})) = -1$$
$$\text{ParenDelta}(t) = 0 \ \text{if } t.\text{kind} \notin \{\text{Punctuator}(\texttt{"("}),\ \text{Punctuator}(\texttt{")"})\}$$

$$\text{TupleScan}(P,d) \Downarrow b$$
$$\frac{\text{Tok}(P)=\text{EOF}}{\text{TupleScan}(P,d) \Downarrow \text{false}}$$
$$\frac{\text{Tok}(P)=\text{Punctuator}(\texttt{")"}) \land d=1}{\text{TupleScan}(P,d) \Downarrow \text{false}}$$
$$\frac{\text{Tok}(P)\in\{\text{Punctuator}(\texttt{","}),\ \text{Punctuator}(\texttt{";"})\} \land d=1}{\text{TupleScan}(P,d) \Downarrow \text{true}}$$
$$\frac{\text{Tok}(P)\notin\{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{","}),\ \text{Punctuator}(\texttt{";"})\} \quad \text{TupleScan}(\text{Advance}(P), d+\text{ParenDelta}(\text{Tok}(P))) \Downarrow b}{\text{TupleScan}(P,d) \Downarrow b}$$

$$\text{TupleParen}(P) \iff \text{IsPunc}(\text{Tok}(P),\texttt{"("}) \land \left(\text{IsPunc}(\text{Tok}(\text{Advance}(P)),\texttt{")"}) \lor \text{TupleScan}(\text{Advance}(P),1)\Downarrow \text{true}\right)$$
**Field Initializers.**

**(Parse-FieldInitList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseFieldInitList}(P) \Downarrow (P, [])}$$

**(Parse-FieldInitList-Cons)**
$$\frac{\Gamma \vdash \text{ParseFieldInit}(P) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldInitTail}(P_1, [f]) \Downarrow (P_2, fs)}{\Gamma \vdash \text{ParseFieldInitList}(P) \Downarrow (P_2, fs)}$$


**(Parse-FieldInit-Explicit)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{":"}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_1)) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParseFieldInit}(P) \Downarrow (P_2, \langle name, e \rangle)}$$

**(Parse-FieldInit-Shorthand)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \neg \text{IsPunc}(\text{Tok}(P_1), \texttt{":"})}{\Gamma \vdash \text{ParseFieldInit}(P) \Downarrow (P_1, \langle name, \text{Identifier}(name) \rangle)}$$

**Match Arms.**

**(Parse-MatchArms-Cons)**
$$\frac{\Gamma \vdash \text{ParseMatchArm}(P) \Downarrow (P_1, a) \quad \Gamma \vdash \text{ParseMatchArmsTail}(P_1, [a]) \Downarrow (P_2, arms)}{\Gamma \vdash \text{ParseMatchArms}(P) \Downarrow (P_2, arms)}$$

**(Parse-MatchArm)**
$$\frac{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, pat) \quad \Gamma \vdash \text{ParseGuardOpt}(P_1) \Downarrow (P_2, guard\_opt) \quad \text{IsOp}(\text{Tok}(P_2), \texttt{"=>"}) \quad \Gamma \vdash \text{ParseArmBody}(\text{Advance}(P_2)) \Downarrow (P_3, body)}{\Gamma \vdash \text{ParseMatchArm}(P) \Downarrow (P_3, \langle pat, guard\_opt, body \rangle)}$$

**(Parse-MatchArmsTail-End)**
$$\frac{\text{Tok}(P) = \text{Punctuator}(\texttt{"}"})}{\Gamma \vdash \text{ParseMatchArmsTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-MatchArmsTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseMatchArm}(\text{Advance}(P)) \Downarrow (P_1, a) \quad \Gamma \vdash \text{ParseMatchArmsTail}(P_1, xs \mathbin{+\!\!+} [a]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseMatchArmsTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-GuardOpt-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{if})}{\Gamma \vdash \text{ParseGuardOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-GuardOpt-Yes)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{if}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseGuardOpt}(P) \Downarrow (P_1, e)}$$

**(Parse-ArmBody-Block)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseBlock}(P) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseArmBody}(P) \Downarrow (P_1, b)}$$

**(Parse-ArmBody-Expr)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseArmBody}(P) \Downarrow (P_1, e)}$$

**Argument and Expression Tail Lists.**

**(Parse-ArgTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseArgTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-ArgTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseArgTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-ArgTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseArg}(\text{Advance}(P)) \Downarrow (P_1, a) \quad \Gamma \vdash \text{ParseArgTail}(P_1, xs \mathbin{+\!\!+} [a]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseArgTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-ExprListTail-End)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"}),\ \text{Punctuator}(\texttt{"}"})\}}{\Gamma \vdash \text{ParseExprListTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-ExprListTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{Tok}(\text{Advance}(P)) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"}),\ \text{Punctuator}(\texttt{"}"})\} \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseExprListTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-ExprListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e) \quad \Gamma \vdash \text{ParseExprListTail}(P_1, xs \mathbin{+\!\!+} [e]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseExprListTail}(P, xs) \Downarrow (P_2, ys)}$$

**(Parse-FieldInitTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseFieldInitTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-FieldInitTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseFieldInitTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-FieldInitTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseFieldInit}(\text{Advance}(P)) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldInitTail}(P_1, xs \mathbin{+\!\!+} [f]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseFieldInitTail}(P, xs) \Downarrow (P_2, ys)}$$
**Loop Tail.**

**(Parse-LoopTail-Infinite)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseBlock}(P) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseLoopTail}(P) \Downarrow (P_1, \text{LoopInfinite}(b))}$$

**(Parse-LoopTail-Iter)**
$$\frac{\Gamma \vdash \text{TryParsePatternIn}(P) \Downarrow (P_1, pat) \quad \Gamma \vdash \text{ParseTypeAnnotOpt}(P_1) \Downarrow (P_2, ty\_opt) \quad \text{IsIdent}(\text{Tok}(P_2)) \quad \text{Lexeme}(\text{Tok}(P_2)) = \texttt{in} \quad \Gamma \vdash \text{ParseExpr\_NoBrace}(\text{Advance}(P_2)) \Downarrow (P_3, iter) \quad \Gamma \vdash \text{ParseBlock}(P_3) \Downarrow (P_4, body)}{\Gamma \vdash \text{ParseLoopTail}(P) \Downarrow (P_4, \text{LoopIter}(pat, ty\_opt, iter, body))}$$

**(Parse-LoopTail-Cond)**
$$\frac{\Gamma \vdash \text{ParseExpr\_NoBrace}(P) \Downarrow (P_1, cond) \quad \Gamma \vdash \text{ParseBlock}(P_1) \Downarrow (P_2, body)}{\Gamma \vdash \text{ParseLoopTail}(P) \Downarrow (P_2, \text{LoopConditional}(cond, body))}$$

**(TryParsePatternIn-Ok)**
$$\frac{P_c = \text{Clone}(P) \quad \Gamma \vdash \text{ParsePattern}(P_c) \Downarrow (P_1, pat) \quad \Gamma \vdash \text{ParseTypeAnnotOpt}(P_1) \Downarrow (P_2, ty\_opt) \quad \text{IsIdent}(\text{Tok}(P_2)) \quad \text{Lexeme}(\text{Tok}(P_2)) = \texttt{in} \quad P' = \text{MergeDiag}(P, P_2, P_1)}{\Gamma \vdash \text{TryParsePatternIn}(P) \Downarrow (P', pat)}$$

**(TryParsePatternIn-Fail)**
$$\frac{P_c = \text{Clone}(P) \quad \neg(\Gamma \vdash \text{ParsePattern}(P_c) \Downarrow (P_1, pat) \land \Gamma \vdash \text{ParseTypeAnnotOpt}(P_1) \Downarrow (P_2, ty\_opt) \land \text{IsIdent}(\text{Tok}(P_2)) \land \text{Lexeme}(\text{Tok}(P_2)) = \texttt{in})}{\Gamma \vdash \text{TryParsePatternIn}(P) \uparrow}$$

**Else Clause.**

**(Parse-ElseOpt-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{else})}{\Gamma \vdash \text{ParseElseOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-ElseOpt-If)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{else}) \quad \text{IsKw}(\text{Tok}(\text{Advance}(P)), \texttt{if}) \quad \Gamma \vdash \text{ParsePrimary}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseElseOpt}(P) \Downarrow (P_1, e)}$$

**(Parse-ElseOpt-Block)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{else}) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(P)) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseElseOpt}(P) \Downarrow (P_1, b)}$$

**Optional Expression.**

**(Parse-ExprOpt-None)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{";"}),\ \text{Punctuator}(\texttt{"}"}),\ \text{Newline},\ \text{EOF}\}}{\Gamma \vdash \text{ParseExprOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-ExprOpt-Yes)**
$$\frac{\text{Tok}(P) \notin \{\text{Punctuator}(\texttt{";"}),\ \text{Punctuator}(\texttt{"}"}),\ \text{Newline},\ \text{EOF}\} \quad \Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseExprOpt}(P) \Downarrow (P_1, e)}$$

**Place Expressions.**

$$\text{IsPlace}(e) \iff e \in \{\text{Identifier}(\_),\ \text{FieldAccess}(\_,\_),\ \text{TupleAccess}(\_,\_),\ \text{IndexAccess}(\_,\_)\} \ \lor\ (\exists p.\ e = \text{Deref}(p) \land \text{IsPlace}(p))$$
$$\text{PlaceExprParseErr} = \text{Parse-Syntax-Err}$$

**(Parse-Place-Deref)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"*"}) \quad \Gamma \vdash \text{ParsePlace}(\text{Advance}(P)) \Downarrow (P_1, p)}{\Gamma \vdash \text{ParsePlace}(P) \Downarrow (P_1, \text{Deref}(p))}$$

**(Parse-Place-Postfix)**
$$\frac{\Gamma \vdash \text{ParsePostfix}(P) \Downarrow (P_1, e) \quad \text{IsPlace}(e)}{\Gamma \vdash \text{ParsePlace}(P) \Downarrow (P_1, e)}$$

**(Parse-Place-Err)**
$$\frac{\Gamma \vdash \text{ParsePostfix}(P) \Downarrow (P_1, e) \quad \neg \text{IsPlace}(e) \quad c = \text{Code}(\text{PlaceExprParseErr}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span}) \quad \Gamma \vdash \text{SyncStmt}(P_1) \Downarrow P_2}{\Gamma \vdash \text{ParsePlace}(P) \Downarrow (P_2, \text{ErrorExpr}(\text{SpanBetween}(P,P_2)))}$$

#### 3.3.9. Pattern Parsing

**(Parse-Pattern)**
$$\frac{\Gamma \vdash \text{ParsePatternRange}(P) \Downarrow (P_1, pat)}{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, pat)}$$

**(Parse-Pattern-Err)**
$$\frac{c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span})}{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P,\ \text{WildcardPattern})}$$

**(Parse-Pattern-Range-None)**
$$\frac{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (P_1, p) \quad \neg(\text{IsOp}(\text{Tok}(P_1), \texttt{".."}) \lor \text{IsOp}(\text{Tok}(P_1), \texttt{"..="}))}{\Gamma \vdash \text{ParsePatternRange}(P) \Downarrow (P_1, p)}$$

**(Parse-Pattern-Range)**
$$\frac{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (P_1, p_0) \quad \text{Tok}(P_1) = op \in \{\texttt{".."}, \texttt{"..="}\} \quad \Gamma \vdash \text{ParsePatternAtom}(\text{Advance}(P_1)) \Downarrow (P_2, p_1) \quad kind = (\texttt{Exclusive}\ \text{if}\ op=\texttt{".."}\ \text{else}\ \texttt{Inclusive})}{\Gamma \vdash \text{ParsePatternRange}(P) \Downarrow (P_2, \text{RangePattern}(kind, p_0, p_1))}$$

**(Parse-Pattern-Literal)**
$$\frac{\text{Tok}(P).\text{kind} \in \{\text{IntLiteral},\text{FloatLiteral},\text{StringLiteral},\text{CharLiteral},\text{BoolLiteral},\text{NullLiteral}\}}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (\text{Advance}(P), \text{LiteralPattern}(\text{Tok}(P)))}$$

**(Parse-Pattern-Wildcard)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{Lexeme}(\text{Tok}(P)) = \texttt{"_"}}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (\text{Advance}(P), \text{WildcardPattern})}$$

**(Parse-Pattern-Typed)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{":"}) \quad \Gamma \vdash \text{ParseType}(\text{Advance}(\text{Advance}(P))) \Downarrow (P_1, ty)}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (P_1, \text{TypedPattern}(\text{Lexeme}(\text{Tok}(P)), ty))}$$

**(Parse-Pattern-Identifier)**
$$\frac{\text{IsIdent}(\text{Tok}(P))}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (\text{Advance}(P), \text{IdentifierPattern}(\text{Lexeme}(\text{Tok}(P))))}$$

**(Parse-Pattern-Tuple)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseTuplePatternElems}(\text{Advance}(P)) \Downarrow (P_1, elems) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (\text{Advance}(P_1), \text{TuplePattern}(elems))}$$

**(Parse-Pattern-Record)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldPatternList}(\text{Advance}(P_1)) \Downarrow (P_2, fields) \quad \text{IsPunc}(\text{Tok}(P_2), \texttt{"}"})}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (\text{Advance}(P_2), \text{RecordPattern}(path, fields))}$$

**(Parse-Pattern-Enum)**
$$\frac{\Gamma \vdash \text{ParseTypePath}(P) \Downarrow (P_1, path) \quad \text{IsOp}(\text{Tok}(P_1), \texttt{"::"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P_1)) \Downarrow (P_2, name) \quad \Gamma \vdash \text{ParseEnumPatternPayloadOpt}(P_2) \Downarrow (P_3, payload\_opt)}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (P_3, \text{EnumPattern}(path, name, payload\_opt))}$$

**(Parse-Pattern-Modal)**
$$\frac{\text{IsOp}(\text{Tok}(P), \texttt{"@"}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseModalPatternPayloadOpt}(P_1) \Downarrow (P_2, fields\_opt)}{\Gamma \vdash \text{ParsePatternAtom}(P) \Downarrow (P_2, \text{ModalPattern}(name, fields\_opt))}$$

##### 3.3.9.1. Pattern Helper Parsing Rules

**Pattern Lists.**

**(Parse-PatternList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParsePatternList}(P) \Downarrow (P, [])}$$

**(Parse-PatternList-Cons)**
$$\frac{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, p) \quad \Gamma \vdash \text{ParsePatternListTail}(P_1, [p]) \Downarrow (P_2, ps)}{\Gamma \vdash \text{ParsePatternList}(P) \Downarrow (P_2, ps)}$$

**(Parse-PatternListTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParsePatternListTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-PatternListTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParsePatternListTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-PatternListTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParsePattern}(\text{Advance}(P)) \Downarrow (P_1, p) \quad \Gamma \vdash \text{ParsePatternListTail}(P_1, xs \mathbin{+\!\!+} [p]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParsePatternListTail}(P, xs) \Downarrow (P_2, ys)}$$

**Tuple Pattern Elements.**

**(Parse-TuplePatternElems-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{")"})}{\Gamma \vdash \text{ParseTuplePatternElems}(P) \Downarrow (P, [])}$$

**(Parse-TuplePatternElems-Single)**
$$\frac{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, p) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{";"})}{\Gamma \vdash \text{ParseTuplePatternElems}(P) \Downarrow (\text{Advance}(P_1), [p])}$$

**(Parse-TuplePatternElems-TrailingComma)**
$$\frac{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, p) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P_1)), \texttt{")"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseTuplePatternElems}(P) \Downarrow (\text{Advance}(P_1), [p])}$$

**(Parse-TuplePatternElems-Many)**
$$\frac{\Gamma \vdash \text{ParsePattern}(P) \Downarrow (P_1, p_1) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{","}) \quad \Gamma \vdash \text{ParsePattern}(\text{Advance}(P_1)) \Downarrow (P_2, p_2) \quad \Gamma \vdash \text{ParsePatternListTail}(P_2, [p_2]) \Downarrow (P_3, ps)}{\Gamma \vdash \text{ParseTuplePatternElems}(P) \Downarrow (P_3, [p_1] \mathbin{+\!\!+} ps)}$$

**Field Pattern Lists.**

**(Parse-FieldPatternList-Empty)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseFieldPatternList}(P) \Downarrow (P, [])}$$

**(Parse-FieldPatternList-Cons)**
$$\frac{\Gamma \vdash \text{ParseFieldPattern}(P) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldPatternTail}(P_1, [f]) \Downarrow (P_2, fs)}{\Gamma \vdash \text{ParseFieldPatternList}(P) \Downarrow (P_2, fs)}$$

**(Parse-FieldPattern)**
$$\frac{\Gamma \vdash \text{ParseIdent}(P) \Downarrow (P_1, name) \quad \Gamma \vdash \text{ParseFieldPatternTailOpt}(P_1, name) \Downarrow (P_2, pat\_opt)}{\Gamma \vdash \text{ParseFieldPattern}(P) \Downarrow (P_2, \langle name, pat\_opt, \text{SpanBetween}(P,P_2) \rangle)}$$

**(Parse-FieldPatternTailOpt-None)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{":"})}{\Gamma \vdash \text{ParseFieldPatternTailOpt}(P, name) \Downarrow (P, \bot)}$$

**(Parse-FieldPatternTailOpt-Yes)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{":"}) \quad \Gamma \vdash \text{ParsePattern}(\text{Advance}(P)) \Downarrow (P_1, pat)}{\Gamma \vdash \text{ParseFieldPatternTailOpt}(P, name) \Downarrow (P_1, pat)}$$

**(Parse-FieldPatternTail-End)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"}"})}{\Gamma \vdash \text{ParseFieldPatternTail}(P, xs) \Downarrow (P, xs)}$$

**(Parse-FieldPatternTail-TrailingComma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"}"}) \quad \Gamma \vdash \text{Emit}(\text{Code}(\text{Unsupported-Construct}))}{\Gamma \vdash \text{ParseFieldPatternTail}(P, xs) \Downarrow (\text{Advance}(P), xs)}$$

**(Parse-FieldPatternTail-Comma)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{","}) \quad \Gamma \vdash \text{ParseFieldPattern}(\text{Advance}(P)) \Downarrow (P_1, f) \quad \Gamma \vdash \text{ParseFieldPatternTail}(P_1, xs \mathbin{+\!\!+} [f]) \Downarrow (P_2, ys)}{\Gamma \vdash \text{ParseFieldPatternTail}(P, xs) \Downarrow (P_2, ys)}$$
**Enum Pattern Payload.**

**(Parse-EnumPatternPayloadOpt-None)**
$$\frac{\text{Tok}(P) \notin \{\text{Punctuator}(\texttt{"("}),\ \text{Punctuator}(\texttt{"{"})\}}{\Gamma \vdash \text{ParseEnumPatternPayloadOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-EnumPatternPayloadOpt-Tuple)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseTuplePatternElems}(\text{Advance}(P)) \Downarrow (P_1, ps) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParseEnumPatternPayloadOpt}(P) \Downarrow (\text{Advance}(P_1), \text{TuplePayloadPattern}(ps))}$$

**(Parse-EnumPatternPayloadOpt-Record)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldPatternList}(\text{Advance}(P)) \Downarrow (P_1, fs) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseEnumPatternPayloadOpt}(P) \Downarrow (\text{Advance}(P_1), \text{RecordPayloadPattern}(fs))}$$

**Modal Pattern Payload.**

**(Parse-ModalPatternPayloadOpt-None)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{"{"})}{\Gamma \vdash \text{ParseModalPatternPayloadOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-ModalPatternPayloadOpt-Record)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseFieldPatternList}(\text{Advance}(P)) \Downarrow (P_1, fs) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseModalPatternPayloadOpt}(P) \Downarrow (\text{Advance}(P_1), \text{ModalRecordPayload}(fs))}$$

#### 3.3.10. Statement and Block Parsing

**Statement Terminators.**
$$\text{StmtTerm} = \{\text{Punctuator}(\texttt{";"}),\ \text{Newline}\}$$
$$\text{Terminates}(t) \iff t \in \text{StmtTerm}$$

**(Parse-Statement)**
$$\frac{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, s) \quad \Gamma \vdash \text{ConsumeTerminatorOpt}(P_1, s) \Downarrow P_2}{\Gamma \vdash \text{ParseStmt}(P) \Downarrow (P_2, s)}$$

**(Parse-Statement-Err)**
$$\frac{c = \text{Code}(\text{Parse-Syntax-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span}) \quad P_1 = \text{AdvanceOrEOF}(P) \quad \Gamma \vdash \text{SyncStmt}(P_1) \Downarrow P_2}{\Gamma \vdash \text{ParseStmt}(P) \Downarrow (P_2,\ \text{ErrorStmt}(\text{SpanBetween}(P,P_2)))}$$


**(Parse-Binding-Stmt)**
$$\frac{\text{Tok}(P) \in \{\text{Keyword}(\texttt{let}),\ \text{Keyword}(\texttt{var})\} \quad \Gamma \vdash \text{ParseBindingAfterLetVar}(P) \Downarrow (P_1, bind)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{LetOrVarStmt}(P, bind))}$$

**(Parse-Shadow-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{shadow}) \quad \text{Tok}(\text{Advance}(P)) \in \{\text{Keyword}(\texttt{let}),\ \text{Keyword}(\texttt{var})\} \quad \Gamma \vdash \text{ParseShadowBinding}(\text{Advance}(P)) \Downarrow (P_1, s)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, s)}$$

**(Parse-Assign-Stmt)**
$$\frac{\Gamma \vdash \text{ParsePlace}(P) \Downarrow (P_1, p) \quad \text{Tok}(P_1) \in \{\text{Operator}(\texttt{"="}),\ \text{Operator}(\texttt{"+="}),\ \text{Operator}(\texttt{"-="}),\ \text{Operator}(\texttt{"*="}),\ \text{Operator}(\texttt{"/="}),\ \text{Operator}(\texttt{"%="})\} \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P_1)) \Downarrow (P_2, e)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_2, \text{AssignOrCompound}(P_1, p, e))}$$

**(Parse-Return-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{return}) \quad \Gamma \vdash \text{ParseExprOpt}(\text{Advance}(P)) \Downarrow (P_1, e\_opt)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{ReturnStmt}(e\_opt))}$$

**(Parse-Result-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{result}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{ResultStmt}(e))}$$

**(Parse-Break-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{break}) \quad \Gamma \vdash \text{ParseExprOpt}(\text{Advance}(P)) \Downarrow (P_1, e\_opt)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{BreakStmt}(e\_opt))}$$

**(Parse-Continue-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{continue})}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (\text{Advance}(P), \text{ContinueStmt})}$$

**(Parse-Unsafe-Block)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{unsafe}) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(P)) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{UnsafeBlockStmt}(b))}$$

**(Parse-Defer-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{defer}) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(P)) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{DeferStmt}(b))}$$

**(Parse-Region-Opts-None)**
$$\frac{\neg \text{IsPunc}(\text{Tok}(P), \texttt{"("})}{\Gamma \vdash \text{ParseRegionOptsOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-Region-Opts-Some)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"("}) \quad \Gamma \vdash \text{ParseExpr}(\text{Advance}(P)) \Downarrow (P_1, e) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{")"})}{\Gamma \vdash \text{ParseRegionOptsOpt}(P) \Downarrow (\text{Advance}(P_1), e)}$$

**(Parse-Region-Alias-None)**
$$\frac{\neg \text{IsKw}(\text{Tok}(P), \texttt{as})}{\Gamma \vdash \text{ParseRegionAliasOpt}(P) \Downarrow (P, \bot)}$$

**(Parse-Region-Alias-Some)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{as}) \quad \Gamma \vdash \text{ParseIdent}(\text{Advance}(P)) \Downarrow (P_1, name)}{\Gamma \vdash \text{ParseRegionAliasOpt}(P) \Downarrow (P_1, name)}$$

**(Parse-Region-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{region}) \quad \Gamma \vdash \text{ParseRegionOptsOpt}(\text{Advance}(P)) \Downarrow (P_1, opts\_opt) \quad \Gamma \vdash \text{ParseRegionAliasOpt}(P_1) \Downarrow (P_2, alias\_opt) \quad \Gamma \vdash \text{ParseBlock}(P_2) \Downarrow (P_3, b)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_3, \text{RegionStmt}(opts\_opt, alias\_opt, b))}$$

**(Parse-Frame-Stmt)**
$$\frac{\text{IsKw}(\text{Tok}(P), \texttt{frame}) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(P)) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{FrameStmt}(\bot, b))}$$

**(Parse-Frame-Explicit)**
$$\frac{\text{IsIdent}(\text{Tok}(P)) \quad \text{IsPunc}(\text{Tok}(\text{Advance}(P)), \texttt{"."}) \quad \text{IsKw}(\text{Tok}(\text{Advance}(\text{Advance}(P))), \texttt{frame}) \quad name = \text{Lexeme}(\text{Tok}(P)) \quad \Gamma \vdash \text{ParseBlock}(\text{Advance}(\text{Advance}(\text{Advance}(P)))) \Downarrow (P_1, b)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{FrameStmt}(name, b))}$$

**(Parse-Expr-Stmt)**
$$\frac{\Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e)}{\Gamma \vdash \text{ParseStmtCore}(P) \Downarrow (P_1, \text{ExprStmt}(e))}$$

**Block Parsing.**

**(Parse-Block)**
$$\frac{\text{IsPunc}(\text{Tok}(P), \texttt{"{"}) \quad \Gamma \vdash \text{ParseStmtSeq}(\text{Advance}(P)) \Downarrow (P_1, stmts, tail) \quad \text{IsPunc}(\text{Tok}(P_1), \texttt{"}"})}{\Gamma \vdash \text{ParseBlock}(P) \Downarrow (\text{Advance}(P_1), \text{BlockExpr}(stmts, tail))}$$

##### 3.3.10.1. Statement Helper Parsing Rules
**Terminator Consumption.**

$$\text{ReqTerm}(s) \iff s \in \{\text{LetStmt}(\_),\ \text{VarStmt}(\_),\ \text{ShadowLetStmt}(\_),\ \text{ShadowVarStmt}(\_),\ \text{AssignStmt}(\_,\_),\ \text{CompoundAssignStmt}(\_,\_,\_),\ \text{ExprStmt}(\_)\}$$

**(ConsumeTerminatorOpt-Req-Yes)**
$$\frac{\text{ReqTerm}(s) \quad \text{IsTerm}(\text{Tok}(P))}{\Gamma \vdash \text{ConsumeTerminatorOpt}(P, s) \Downarrow \text{Advance}(P)}$$

**(ConsumeTerminatorOpt-Req-No)**
$$\frac{\text{ReqTerm}(s) \quad \neg \text{IsTerm}(\text{Tok}(P)) \quad \text{Emit}(\text{Code}(\text{Missing-Terminator-Err}),\ \text{Span}=\text{Tok}(P).\text{span}) \quad \Gamma \vdash \text{SyncStmt}(P) \Downarrow P_1}{\Gamma \vdash \text{ConsumeTerminatorOpt}(P, s) \Downarrow P_1}$$

**(ConsumeTerminatorOpt-Opt-Yes)**
$$\frac{\neg \text{ReqTerm}(s) \quad \text{IsTerm}(\text{Tok}(P))}{\Gamma \vdash \text{ConsumeTerminatorOpt}(P, s) \Downarrow \text{Advance}(P)}$$

**(ConsumeTerminatorOpt-Opt-No)**
$$\frac{\neg \text{ReqTerm}(s) \quad \neg \text{IsTerm}(\text{Tok}(P))}{\Gamma \vdash \text{ConsumeTerminatorOpt}(P, s) \Downarrow P}$$

**(ConsumeTerminatorReq-Yes)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{";"}),\ \text{Newline}\}}{\Gamma \vdash \text{ConsumeTerminatorReq}(P) \Downarrow \text{Advance}(P)}$$

**(ConsumeTerminatorReq-No)**
$$\frac{\text{Tok}(P) \notin \{\text{Punctuator}(\texttt{";"}),\ \text{Newline}\} \quad c = \text{Code}(\text{Missing-Terminator-Err}) \quad \Gamma \vdash \text{Emit}(c,\ \text{Tok}(P).\text{span}) \quad \Gamma \vdash \text{SyncStmt}(P) \Downarrow P_1}{\Gamma \vdash \text{ConsumeTerminatorReq}(P) \Downarrow P_1}$$

**Let/Var Statements.**

**(LetOrVarStmt-Let)**
$$\frac{\text{Tok}(P) = \text{Keyword}(\texttt{let})}{\Gamma \vdash \text{LetOrVarStmt}(P, bind) \Downarrow \text{LetStmt}(bind)}$$

**(LetOrVarStmt-Var)**
$$\frac{\text{Tok}(P) = \text{Keyword}(\texttt{var})}{\Gamma \vdash \text{LetOrVarStmt}(P, bind) \Downarrow \text{VarStmt}(bind)}$$

**Assignments.**

**(AssignOrCompound-Assign)**
$$\frac{\text{Tok}(P_1) = \text{Operator}(\texttt{"="})}{\Gamma \vdash \text{AssignOrCompound}(P_1, p, e) \Downarrow \text{AssignStmt}(p, e)}$$

**(AssignOrCompound-Compound)**
$$\frac{\text{Tok}(P_1) = \text{Operator}(op) \quad op \in \{\texttt{"+="},\texttt{"-="},\texttt{"*="},\texttt{"/="},\texttt{"%="}\}}{\Gamma \vdash \text{AssignOrCompound}(P_1, p, e) \Downarrow \text{CompoundAssignStmt}(p, op, e)}$$

**Statement Sequences.**

**(ParseStmtSeq-End)**
$$\frac{\text{Tok}(P) = \text{Punctuator}(\texttt{"}"})}{\Gamma \vdash \text{ParseStmtSeq}(P) \Downarrow (P, [], \bot)}$$

**(ParseStmtSeq-TailExpr)**
$$\frac{\text{Tok}(P) \notin \{\text{Punctuator}(\texttt{"}"})\} \quad \Gamma \vdash \text{ParseExpr}(P) \Downarrow (P_1, e) \quad \text{Tok}(P_1) = \text{Punctuator}(\texttt{"}"})}{\Gamma \vdash \text{ParseStmtSeq}(P) \Downarrow (P_1, [], e)}$$

**(ParseStmtSeq-Cons)**
$$\frac{\Gamma \vdash \text{ParseStmt}(P) \Downarrow (P_1, s) \quad \Gamma \vdash \text{ParseStmtSeq}(P_1) \Downarrow (P_2, ss, tail)}{\Gamma \vdash \text{ParseStmtSeq}(P) \Downarrow (P_2, [s] \mathbin{+\!\!+} ss, tail)}$$

#### 3.3.11. Doc Comment Association (Phase 1)

$$\text{DocSeq}(D) = D$$
$$\text{ItemSeq}(Items) = Items$$

**(Attach-Doc-Line)**
$$\frac{d.\text{kind} = \text{LineDoc} \quad Items = [i_1,\ldots,i_k] \quad j = \min\{ t \mid d.\text{span}.\text{end\_offset} \le i_t.\text{span}.\text{start\_offset} \}}{\Gamma \vdash \text{AttachDoc}(d, i_j)}$$
$$\text{LineDocTarget}(d, Items) = i_j \iff \Gamma \vdash \text{AttachDoc}(d,i_j)$$
$$\text{LineDocsFor}(i, D, Items) = [d \in D \mid d.\text{kind}=\text{LineDoc} \land \text{LineDocTarget}(d,Items)=i]$$

**(Attach-Doc-Module)**
$$\frac{d.\text{kind} = \text{ModuleDoc}}{\Gamma \vdash \text{AttachModuleDoc}(d)}$$

$$\text{ModuleDocs}(D) = [d \in D \mid d.\text{kind}=\text{ModuleDoc}]$$

#### 3.3.12. Error Recovery and Synchronization

**Statement Synchronization Set.**

$$\text{SyncStmt} = \{\text{Punctuator}(\texttt{";"}),\ \text{Newline},\ \text{Punctuator}(\texttt{"}"}),\ \text{EOF}\}$$

**Item Synchronization Set.**

$$\text{SyncItem} = \{\text{Keyword}(\texttt{procedure}),\ \text{Keyword}(\texttt{record}),\ \text{Keyword}(\texttt{enum}),\ \text{Keyword}(\texttt{modal}),\ \text{Keyword}(\texttt{class}),\ \text{Keyword}(\texttt{type}),\ \text{Keyword}(\texttt{using}),\ \text{Keyword}(\texttt{let}),\ \text{Keyword}(\texttt{var}),\ \text{Punctuator}(\texttt{"}"}),\ \text{EOF}\}$$

**Type Synchronization Set.**

$$\text{SyncType} = \{\text{Punctuator}(\texttt{","}),\ \text{Punctuator}(\texttt{";"}),\ \text{Newline},\ \text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"}),\ \text{Punctuator}(\texttt{"}"}),\ \text{EOF}\}$$

**(Sync-Stmt-Stop)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{"}"}),\ \text{EOF}\}}{\Gamma \vdash \text{SyncStmt}(P) \Downarrow P}$$

**(Sync-Stmt-Consume)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{";"}),\ \text{Newline}\}}{\Gamma \vdash \text{SyncStmt}(P) \Downarrow \text{Advance}(P)}$$

**(Sync-Stmt-Advance)**
$$\frac{\text{Tok}(P) \notin \text{SyncStmt}}{\Gamma \vdash \text{SyncStmt}(P) \Downarrow \text{SyncStmt}(\text{Advance}(P))}$$

**(Sync-Item-Stop)**
$$\frac{\text{Tok}(P) \in \text{SyncItem}}{\Gamma \vdash \text{SyncItem}(P) \Downarrow P}$$

**(Sync-Item-Advance)**
$$\frac{\text{Tok}(P) \notin \text{SyncItem}}{\Gamma \vdash \text{SyncItem}(P) \Downarrow \text{SyncItem}(\text{Advance}(P))}$$

**(Sync-Type-Stop)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{")"}),\ \text{Punctuator}(\texttt{"]"}),\ \text{Punctuator}(\texttt{"}"}),\ \text{EOF}\}}{\Gamma \vdash \text{SyncType}(P) \Downarrow P}$$

**(Sync-Type-Consume)**
$$\frac{\text{Tok}(P) \in \{\text{Punctuator}(\texttt{","}),\ \text{Punctuator}(\texttt{";"}),\ \text{Newline}\}}{\Gamma \vdash \text{SyncType}(P) \Downarrow \text{Advance}(P)}$$

**(Sync-Type-Advance)**
$$\frac{\text{Tok}(P) \notin \text{SyncType}}{\Gamma \vdash \text{SyncType}(P) \Downarrow \text{SyncType}(\text{Advance}(P))}$$

$$\text{StmtParseErrRule} = \text{Parse-Statement-Err}$$
$$\text{ItemParseErrRule} = \text{Parse-Item-Err}$$

#### 3.3.13. Diagnostics (Phase 1)

$$\text{Phase1DiagRules} = \{\text{Unsupported-Construct},\ \text{Missing-Terminator-Err},\ \text{Parse-Syntax-Err}\}$$

**(Parse-Syntax-Err)**
$$\text{GenericParseRules} = \{\text{Parse-Ident-Err},\ \text{Parse-Type-Err},\ \text{Parse-Pattern-Err},\ \text{Parse-Primary-Err},\ \text{Parse-Statement-Err},\ \text{Parse-Item-Err}\}$$

$$\frac{r \in \text{GenericParseRules} \quad \text{PremisesHold}(r, P)}{\Gamma \vdash \text{Emit}(\text{Code}(\text{Parse-Syntax-Err}))}$$

### 3.4. Module Aggregation

#### 3.4.1. Inputs, Outputs, and Invariants

$$\text{ModuleAggInputs}(P) = \langle P.\text{modules},\ P.\text{source\_root},\ \{ \text{CompilationUnit}(\text{DirOf}(p,P.\text{source\_root})) \mid p \in P.\text{modules} \} \rangle$$
$$\text{ModuleAggOutputs}(P) = \langle \{ \text{ParseModule}(p,P.\text{source\_root}) \mid p \in P.\text{modules} \},\ \{ \text{NameMap}(P, p) \mid p \in P.\text{modules} \},\ G,\ \text{InitOrder},\ \text{InitPlan} \rangle$$
$$\text{ModuleMap}(P, p) = M \iff \Gamma \vdash \text{ParseModules}(P) \Downarrow Ms \land M \in Ms \land M.\text{path} = p$$
$$\text{PathOfModule}(p) = [c_1,\ldots,c_n] \iff p = c_1 \mathbin{::} \cdots \mathbin{::} c_n$$
$$\text{StringOfPath}([c_1,\ldots,c_n]) = \text{Join}(\texttt{"::"}, [c_1,\ldots,c_n])$$
$$\text{NameCollectAfterParse}(P) \iff \Gamma \vdash \text{ParseModules}(P) \Downarrow Ms \land \forall M \in Ms.\ \exists N.\ \Gamma \vdash \text{CollectNames}(M) \Downarrow N$$
$$\text{NameCollectOrderIndepRef} = \{\texttt{"5.1.5"}\}$$
$$\text{ForwardRefOrderRef} = \{\texttt{"5.12"}\}$$

#### 3.4.2. Module Aggregation (`ParseModule`)

**Module Directory of a Module Path.**

**(DirOf-Root)**
$$\frac{p = A}{\Gamma \vdash \text{DirOf}(p,S) = S}$$

**(DirOf-Rel)**
$$\frac{p = c_1 :: \cdots :: c_n \quad n \ge 1}{\Gamma \vdash \text{DirOf}(p,S) = S / c_1 / \cdots / c_n}$$

$$A = P.\text{assembly.name}$$

**ParseModule (Big-Step).**
$$U = \text{CompilationUnit}(\text{DirOf}(p,S))$$
$$U = [f_1,\ldots,f_n]$$
$$\text{ReadBytes} : \text{Path} \rightharpoonup \text{Bytes}$$

**(ReadBytes-Ok)**
$$\frac{\text{read\_ok}(f) = B}{\Gamma \vdash \text{ReadBytes}(f) \Downarrow B}$$

**(ReadBytes-Err)**
$$\frac{\text{read\_ok}(f) \Uparrow \quad c = \text{Code}(\text{ReadBytes-Err})}{\Gamma \vdash \text{ReadBytes}(f) \Uparrow c}$$

$$\text{Bytes}(f) = B \iff \Gamma \vdash \text{ReadBytes}(f) \Downarrow B$$

**(ParseModule-Ok)**
$$\frac{
    \forall i,\ \Gamma \vdash \text{ReadBytes}(f_i) \Downarrow B_i \quad
    \Gamma \vdash \text{LoadSource}(f_i, B_i) \Downarrow S_i \quad
    \Gamma \vdash \text{ParseFile}(S_i) \Downarrow F_i
}{
    \Gamma \vdash \text{ParseModule}(p,S) \Downarrow
    \langle p,\ F_1.\text{items} \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} F_n.\text{items},\ F_1.\text{module\_doc} \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} F_n.\text{module\_doc} \rangle
}$$

**(ParseModule-Err-Read)**
$$\frac{\exists i,\ \Gamma \vdash \text{ReadBytes}(f_i) \Uparrow c}{\Gamma \vdash \text{ParseModule}(p,S) \Uparrow c}$$

**(ParseModule-Err-Load)**
$$\frac{\exists i,\ \Gamma \vdash \text{ReadBytes}(f_i) \Downarrow B_i \quad \Gamma \vdash \text{LoadSource}(f_i, B_i) \Uparrow c}{\Gamma \vdash \text{ParseModule}(p,S) \Uparrow c}$$

**LoadSource Short-Circuit.**
If $\Gamma \vdash \text{LoadSource}(f,B) \Uparrow c$ for any file in a compilation unit, $\text{ParseModule}$ MUST NOT invoke $\text{Tokenize}$, $\text{ParseFile}$, or subset checks for that file.

**(ParseModule-Err-Unit)**
$$\frac{\Gamma \vdash \text{CompilationUnit}(\text{DirOf}(p,S)) \Uparrow c}{\Gamma \vdash \text{ParseModule}(p,S) \Uparrow c}$$

**(ParseModule-Err-Parse)**
$$\frac{\exists i,\ \Gamma \vdash \text{ReadBytes}(f_i) \Downarrow B_i \quad \Gamma \vdash \text{LoadSource}(f_i, B_i) \Downarrow S_i \quad \Gamma \vdash \text{ParseFile}(S_i) \Uparrow c}{\Gamma \vdash \text{ParseModule}(p,S) \Uparrow c}$$

$$\text{ParseFileBestEffort}(S) \iff \exists F.\ \Gamma \vdash \text{ParseFile}(S) \Downarrow F$$
$$\text{ParseFileOk}(S) \iff \text{ParseFileBestEffort}(S) \land \neg \text{HasError}(\text{ParseFileDiag}(S))$$
$$\text{ParseFileDiag}(S) = \Delta \iff \Gamma \vdash \text{Tokenize}(S) \Downarrow (K_{\text{raw}}, D) \land K = \text{Filter}(K_{\text{raw}}) \land P_0 = \langle K, 0, D, 0, 0, [] \rangle \land \Gamma \vdash \text{ParseItems}(P_0) \Downarrow (P_1, I, MDoc) \land \text{DiagStream}(P_1)=\Delta$$
$$\text{HasError}(\Delta) \iff \exists d \in \Delta.\ d.\text{severity} = \text{Error}$$

**ParseModule (Small-Step).**
$$\text{ModState} = \{\text{ModStart}(p,S),\ \text{ModScan}(p,S,U,items,docs),\ \text{ModDone}(M),\ \text{Error}(code)\}$$

**(Mod-Start)**
$$\frac{U = \text{CompilationUnit}(\text{DirOf}(p,S))}{\langle \text{ModStart}(p,S) \rangle \to \langle \text{ModScan}(p,S,U,[],[]) \rangle}$$

**(Mod-Start-Err-Unit)**
$$\frac{\Gamma \vdash \text{CompilationUnit}(\text{DirOf}(p,S)) \Uparrow c}{\langle \text{ModStart}(p,S) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Mod-Scan)**
$$\frac{U = f::fs \quad \Gamma \vdash \text{ReadBytes}(f) \Downarrow B \quad \Gamma \vdash \text{LoadSource}(f,B) \Downarrow S_f \quad \Gamma \vdash \text{ParseFile}(S_f) \Downarrow F}{\langle \text{ModScan}(p,S,f::fs,items,docs) \rangle \to \langle \text{ModScan}(p,S,fs,items \mathbin{+\!\!+} F.\text{items},docs \mathbin{+\!\!+} F.\text{module\_doc}) \rangle}$$

**(Mod-Scan-Err-Read)**
$$\frac{U = f::fs \quad \Gamma \vdash \text{ReadBytes}(f) \Uparrow c}{\langle \text{ModScan}(p,S,f::fs,items,docs) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Mod-Scan-Err-Load)**
$$\frac{U = f::fs \quad \Gamma \vdash \text{ReadBytes}(f) \Downarrow B \quad \Gamma \vdash \text{LoadSource}(f,B) \Uparrow c}{\langle \text{ModScan}(p,S,f::fs,items,docs) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Mod-Scan-Err-Parse)**
$$\frac{U = f::fs \quad \Gamma \vdash \text{ReadBytes}(f) \Downarrow B \quad \Gamma \vdash \text{LoadSource}(f,B) \Downarrow S_f \quad \Gamma \vdash \text{ParseFile}(S_f) \Uparrow c}{\langle \text{ModScan}(p,S,f::fs,items,docs) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Mod-Done)**
$$\frac{}{ \langle \text{ModScan}(p,S,[],items,docs) \rangle \to \langle \text{ModDone}(\langle p, items, docs \rangle) \rangle }$$

**ParseModules (Big-Step).**

$$P.\text{modules} = [p_1,\ldots,p_k]$$

**(ParseModules-Ok)**
$$\frac{\forall i,\ \Gamma \vdash \text{ParseModule}(p_i, P.\text{source\_root}) \Downarrow M_i}{\Gamma \vdash \text{ParseModules}(P) \Downarrow [M_1,\ldots,M_k]}$$

**(ParseModules-Err)**
$$\frac{\exists i,\ \Gamma \vdash \text{ParseModule}(p_i, P.\text{source\_root}) \Uparrow c}{\Gamma \vdash \text{ParseModules}(P) \Uparrow c}$$

## 4. Phase 2: Compile-Time Execution (Deferred in Cursive0)

$$\text{ComptimeForm} = \{\texttt{comptime}\}$$
$$\text{ComptimeForm} \subseteq \text{UnsupportedForm}$$

## 5. Phase 3: Name Resolution + Type Checking

### 5.1. Name Resolution and Scopes (Cursive0)

#### 5.1.1. Scope Context and Identifiers

$$\text{IdKeyRef} = \{\texttt{"3.1.6"}\}$$
$$\text{ScopeKey}(S) \iff \text{dom}(S) \subseteq \{\text{IdKey}(x) \mid x \in \text{Identifier}\}$$

$$\Sigma = \langle \Sigma.\text{Mods},\ \Sigma.\text{Types},\ \Sigma.\text{Classes} \rangle$$
$$\Sigma.\text{Mods} \in [\text{ASTModule}]$$
$$\Sigma.\text{Types} : \text{Path} \rightharpoonup \text{TypeDecl}$$
$$\Sigma.\text{Classes} : \text{Path} \rightharpoonup \text{ClassDecl}$$

$$\Gamma = \langle P,\ \Sigma,\ m,\ S \rangle$$
$$\text{Project}(\Gamma) = P$$
$$\text{ResCtx}(\Gamma) = \langle \Sigma,\ m \rangle$$
$$\text{CurrentModule}(\Gamma) = m$$
$$\text{Scopes}(\Gamma) = S$$

$$\text{EntityKind} = \{\text{Value},\ \text{Type},\ \text{Class},\ \text{ModuleAlias}\}$$
$$\text{EntitySource} = \{\text{Decl},\ \text{Using},\ \text{RegionAlias}\}$$
$$\text{Entity} = \langle \text{kind},\ \text{origin\_opt},\ \text{target\_opt},\ \text{source} \rangle$$
$$\text{origin\_opt} \in \text{ModulePath} \cup \{\bot\} \quad \text{target\_opt} \in \text{Identifier} \cup \{\bot\}$$

**Unified Namespace.**

$$S : \text{IdKey} \rightharpoonup \text{Entity}$$

$$\text{Scopes}(\Gamma) = [S_1,\ldots,S_k,S_\text{proc},S_\text{module},S_\text{universe}] \quad (k \ge 0)$$

$$\text{LocalScopes}(\Gamma) = [S_1,\ldots,S_k]$$
$$\text{ProcScope}(\Gamma) = S_\text{proc}$$
$$\text{ModuleScope}(\Gamma) = S_\text{module}$$
$$\text{UniverseScope}(\Gamma) = S_\text{universe}$$

$$\text{UniverseProtectedRef} = \{\texttt{"3.2.3"}\}$$

$$\text{UniverseBindings} = \{ \text{IdKey}(x) \mapsto \langle \text{Type}, \bot, \bot, \text{Decl} \rangle \mid x \in \text{UniverseProtected} \} \cup \{ \text{IdKey}(\texttt{"cursive"}) \mapsto \langle \text{ModuleAlias}, \texttt{"cursive"}, \bot, \text{Decl} \rangle \}$$
$$S_\text{universe} = \text{UniverseBindings}$$

$$\text{BytePrefix}(p,s) \iff \exists r.\ s = p \mathbin{+\!\!+} r$$
$$\text{Prefix}(s,p) \iff \text{BytePrefix}(p,s)$$

$$\text{ReservedGen}(x) \iff \text{Prefix}(\text{IdKey}(x), \text{IdKey}(\texttt{"gen\_"}))$$
$$\text{ReservedCursive}(x) \iff \text{IdEq}(x,\texttt{"cursive"})$$
$$\text{ReservedId}(x) \iff \text{ReservedGen}(x) \lor \text{ReservedCursive}(x)$$
$$\text{ReservedModulePath}(path) \iff (|path| \ge 1 \land \text{IdEq}(path[0],\texttt{"cursive"})) \lor (\exists i.\ \text{ReservedGen}(path[i]))$$

<!-- Source: "The `cursive.*` namespace prefix is reserved for specification-defined features. User programs and vendor extensions MUST NOT use this namespace." -->

$$\text{PrimTypeNames} = \{\texttt{"i8"},\texttt{"i16"},\texttt{"i32"},\texttt{"i64"},\texttt{"i128"},\texttt{"u8"},\texttt{"u16"},\texttt{"u32"},\texttt{"u64"},\texttt{"u128"},\texttt{"f16"},\texttt{"f32"},\texttt{"f64"},\texttt{"bool"},\texttt{"char"},\texttt{"usize"},\texttt{"isize"}\}$$
$$\text{SpecialTypeNames} = \{\texttt{"Self"},\texttt{"Drop"},\texttt{"Bitcopy"},\texttt{"Clone"},\texttt{"string"},\texttt{"bytes"},\texttt{"Modal"},\texttt{"Region"},\texttt{"RegionOptions"},\texttt{"Context"},\texttt{"System"}\}$$
$$\text{AsyncTypeNames} = \{\texttt{"Async"},\texttt{"Future"},\texttt{"Sequence"},\texttt{"Stream"},\texttt{"Pipe"},\texttt{"Exchange"}\}$$

$$\text{PrimTypeKeys} = \{\text{IdKey}(x) \mid x \in \text{PrimTypeNames}\}$$
$$\text{SpecialTypeKeys} = \{\text{IdKey}(x) \mid x \in \text{SpecialTypeNames}\}$$
$$\text{AsyncTypeKeys} = \{\text{IdKey}(x) \mid x \in \text{AsyncTypeNames}\}$$

$$\text{KeywordKey}(n) \iff \exists s.\ n = \text{IdKey}(s) \land \text{Keyword}(s)$$

#### 5.1.2. Name Introduction and Shadowing

$$\text{dom}(S) = \text{keys}(S)$$
$$\text{Scopes}(\Gamma) = [S_{cur}] \mathbin{+\!\!+} \Gamma_{out}$$
$$\text{InScope}(S,x) \iff \text{IdKey}(x) \in \text{dom}(S)$$
$$\text{InOuter}(\Gamma,x) \iff \exists S \in Î“_{out}.\ \text{InScope}(S,x)$$

**(Intro-Ok)**
$$\frac{\neg \text{InScope}(S_{cur},x) \quad \neg \text{InOuter}(\Gamma,x) \quad \neg \text{ReservedId}(x) \quad (S_{cur} \ne S_{module} \lor x \notin \text{UniverseProtected}) \quad \text{Scopes}(\Gamma') = [S_{cur}[\text{IdKey}(x) \mapsto ent]] \mathbin{+\!+} \Gamma_{out} \quad \text{Project}(\Gamma') = \text{Project}(\Gamma) \quad \text{ResCtx}(\Gamma') = \text{ResCtx}(\Gamma)}{\Gamma \vdash \text{Intro}(x, ent) \Downarrow \Gamma'}$$

**(Intro-Dup)**
$$\frac{\text{InScope}(S_{cur},x)}{\Gamma \vdash \text{Intro}(x, ent) \Uparrow}$$

**(Intro-Shadow-Required)**
$$\frac{\neg \text{InScope}(S_{cur},x) \quad \text{InOuter}(\Gamma,x) \quad c = \text{Code}(\text{Intro-Shadow-Required})}{\Gamma \vdash \text{Intro}(x, ent) \Uparrow c}$$

**(Shadow-Ok)**
$$\frac{\neg \text{InScope}(S_{cur},x) \quad \text{InOuter}(\Gamma,x) \quad \neg \text{ReservedId}(x) \quad (S_{cur} \ne S_{module} \lor x \notin \text{UniverseProtected}) \quad \text{Scopes}(\Gamma') = [S_{cur}[\text{IdKey}(x) \mapsto ent]] \mathbin{+\!+} \Gamma_{out} \quad \text{Project}(\Gamma') = \text{Project}(\Gamma) \quad \text{ResCtx}(\Gamma') = \text{ResCtx}(\Gamma)}{\Gamma \vdash \text{ShadowIntro}(x, ent) \Downarrow \Gamma'}$$

**(Shadow-Unnecessary)**
$$\frac{\neg \text{InScope}(S_{cur},x) \quad \neg \text{InOuter}(\Gamma,x) \quad c = \text{Code}(\text{Shadow-Unnecessary})}{\Gamma \vdash \text{ShadowIntro}(x, ent) \Uparrow c}$$

**(Intro-Reserved-Gen-Err)**
$$\frac{\text{ReservedGen}(x) \quad c = \text{Code}(\text{Intro-Reserved-Gen-Err})}{\Gamma \vdash \text{Intro}(x, ent) \Uparrow c}$$

**(Intro-Reserved-Cursive-Err)**
$$\frac{\text{ReservedCursive}(x) \quad c = \text{Code}(\text{Intro-Reserved-Cursive-Err})}{\Gamma \vdash \text{Intro}(x, ent) \Uparrow c}$$

**(Shadow-Reserved-Gen-Err)**
$$\frac{\text{ReservedGen}(x) \quad c = \text{Code}(\text{Shadow-Reserved-Gen-Err})}{\Gamma \vdash \text{ShadowIntro}(x, ent) \Uparrow c}$$

**(Shadow-Reserved-Cursive-Err)**
$$\frac{\text{ReservedCursive}(x) \quad c = \text{Code}(\text{Shadow-Reserved-Cursive-Err})}{\Gamma \vdash \text{ShadowIntro}(x, ent) \Uparrow c}$$

**Deterministic Rule Priority (Intro / ShadowIntro).**

When multiple Intro/ShadowIntro rules are simultaneously applicable, an implementation MUST apply the first matching clause in the following ordered checks.

**Intro Priority.**
1. If $\text{ReservedGen}(x)$ then apply **(Intro-Reserved-Gen-Err)**.
2. Else if $\text{ReservedCursive}(x)$ then apply **(Intro-Reserved-Cursive-Err)**.
3. Else if $\text{InScope}(S_{cur}, x)$ then apply **(Intro-Dup)**.
4. Else if $\text{InOuter}(\Gamma, x)$ then apply **(Intro-Shadow-Required)**.
5. Else if the premises of **(Intro-Ok)** hold then apply **(Intro-Ok)**.
6. Otherwise, $\Gamma \vdash \text{Intro}(x, ent) \Uparrow$ with no diagnostic code.

**ShadowIntro Priority.**
1. If $\text{ReservedGen}(x)$ then apply **(Shadow-Reserved-Gen-Err)**.
2. Else if $\text{ReservedCursive}(x)$ then apply **(Shadow-Reserved-Cursive-Err)**.
3. Else if $\text{InScope}(S_{cur}, x)$ then $\Gamma \vdash \text{ShadowIntro}(x, ent) \Uparrow$ with no diagnostic code.
4. Else if $\neg \text{InOuter}(\Gamma, x)$ then apply **(Shadow-Unnecessary)**.
5. Else if the premises of **(Shadow-Ok)** hold then apply **(Shadow-Ok)**.
6. Otherwise, $\Gamma \vdash \text{ShadowIntro}(x, ent) \Uparrow$ with no diagnostic code.

**Binding Introduction Selection.**
If a binding is introduced by a syntactic form without the `shadow` keyword, the implementation MUST invoke $\text{Intro}$ for that binding. If a binding is introduced by a `shadow` form (e.g., `ShadowLetStmt`/`ShadowVarStmt`), the implementation MUST invoke $\text{ShadowIntro}$ for that binding. The implementation MUST NOT substitute the other judgment.

**Module-Scope Name Validation.**

$$\text{Names}(N) = \text{dom}(N)$$

**(Validate-Module-Ok)**
$$\frac{\forall n \in \text{Names}(N).\ \neg \text{KeywordKey}(n) \land n \notin \text{PrimTypeKeys} \land n \notin \text{SpecialTypeKeys} \land n \notin \text{AsyncTypeKeys}}{\Gamma \vdash \text{ValidateModuleNames}(N) \Downarrow ok}$$

**(Validate-Module-Keyword-Err)**
$$\frac{\exists n \in \text{Names}(N).\ \text{KeywordKey}(n) \quad c = \text{Code}(\text{Validate-Module-Keyword-Err})}{\Gamma \vdash \text{ValidateModuleNames}(N) \Uparrow c}$$

**(Validate-Module-Prim-Shadow-Err)**
$$\frac{\exists n \in \text{Names}(N).\ n \in \text{PrimTypeKeys} \quad c = \text{Code}(\text{Validate-Module-Prim-Shadow-Err})}{\Gamma \vdash \text{ValidateModuleNames}(N) \Uparrow c}$$

**(Validate-Module-Special-Shadow-Err)**
$$\frac{\exists n \in \text{Names}(N).\ n \in \text{SpecialTypeKeys} \quad c = \text{Code}(\text{Validate-Module-Special-Shadow-Err})}{\Gamma \vdash \text{ValidateModuleNames}(N) \Uparrow c}$$

**(Validate-Module-Async-Shadow-Err)**
$$\frac{\exists n \in \text{Names}(N).\ n \in \text{AsyncTypeKeys} \quad c = \text{Code}(\text{Validate-Module-Async-Shadow-Err})}{\Gamma \vdash \text{ValidateModuleNames}(N) \Uparrow c}$$

#### 5.1.3. Lookup

**Unqualified Lookup.**

$$\text{Scopes}(\Gamma) = [S_1,\ldots,S_n]$$
$$i = \min\{j \mid \text{IdKey}(x) \in \text{dom}(S_j)\}$$

**(Lookup-Unqualified)**
$$\frac{i\ \text{defined}}{\Gamma \vdash \text{Lookup}(x) \Downarrow S_i[\text{IdKey}(x)]}$$

**(Lookup-Unqualified-None)**
$$\frac{i\ \text{undefined}}{\Gamma \vdash \text{Lookup}(x) \uparrow}$$

**Kind Filtering.**
$$\text{ValueKind}(ent) \iff ent.\text{kind} = \text{Value}$$
$$\text{TypeKind}(ent) \iff ent.\text{kind} = \text{Type}$$
$$\text{ClassKind}(ent) \iff ent.\text{kind} = \text{Class}$$
$$\text{ModuleKind}(ent) \iff ent.\text{kind} = \text{ModuleAlias}$$
$$\text{RegionAlias}(ent) \iff ent.\text{source} = \text{RegionAlias}$$

$$\text{RegionAliasName}(\Gamma, x) \iff \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land \text{RegionAlias}(ent)$$

**(Resolve-Value-Name)**
$$\frac{\Gamma \vdash \text{Lookup}(x) \Downarrow ent \quad \text{ValueKind}(ent)}{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent}$$

**(Resolve-Type-Name)**
$$\frac{\Gamma \vdash \text{Lookup}(x) \Downarrow ent \quad \text{TypeKind}(ent)}{\Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent}$$

**(Resolve-Class-Name)**
$$\frac{\Gamma \vdash \text{Lookup}(x) \Downarrow ent \quad \text{ClassKind}(ent)}{\Gamma \vdash \text{ResolveClassName}(x) \Downarrow ent}$$

**(Resolve-Module-Name)**
$$\frac{\Gamma \vdash \text{Lookup}(x) \Downarrow ent \quad \text{ModuleKind}(ent)}{\Gamma \vdash \text{ResolveModuleName}(x) \Downarrow ent}$$

**Qualified Lookup.**
$$P = Project(\Gamma)$$
$$m = \text{CurrentModule}(\Gamma)$$
$$\text{ModulePaths} = \{ p \mid p \in P.\text{modules} \}$$
$$\text{Alias} = \text{AliasMap}(m)$$

**(Resolve-ModulePath)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, Alias) \Downarrow path' \quad \text{StringOfPath}(path') \in \text{ModuleNames}}{\Gamma \vdash \text{ResolveModulePath}(path, Alias, \text{ModuleNames}) \Downarrow path'}$$

**(ResolveModulePath-Err)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, Alias) \Downarrow path' \quad \text{StringOfPath}(path') \notin \text{ModuleNames} \quad c = \text{Code}(\text{ResolveModulePath-Err})}{\Gamma \vdash \text{ResolveModulePath}(path, Alias, \text{ModuleNames}) \Uparrow c}$$

**(Resolve-Qualified)**
$$\frac{\Gamma \vdash \text{ResolveModulePath}(path, Alias, \text{ModuleNames}) \Downarrow mp \quad \text{NameMap}(P, mp)[\text{IdKey}(name)] = ent \quad \Gamma \vdash \text{CanAccess}(m, \text{DeclOf}(mp,name)) \Downarrow ok \quad K(ent)}{\Gamma \vdash \text{ResolveQualified}(path,name,K) \Downarrow ent}$$

$$K \in \{\text{ValueKind},\ \text{TypeKind},\ \text{ClassKind},\ \text{ModuleKind}\}$$

#### 5.1.4. Visibility and Accessibility

$$\text{DeclOf}(mp,name) = it \iff \text{ModuleOf}(it)=mp \land \text{IdKey}(name) \in \text{dom}(\text{ItemBindings}(it, mp))$$
$$\text{ModuleOf}(it) = p \iff it \in \text{ASTModule}(P, p).\text{items}$$
$$\text{ModuleOfPath}(\text{path}) = mp \iff \text{SplitLast}(\text{path}) = (mp,\ name)$$
$$\text{Vis}(it) = it.\text{vis}$$

**(Access-Public)**
$$\frac{\text{Vis}(it) = \texttt{public}}{\Gamma \vdash \text{CanAccess}(m, it) \Downarrow ok}$$

**(Access-Internal)**
$$\frac{\text{Vis}(it) = \texttt{internal}}{\Gamma \vdash \text{CanAccess}(m, it) \Downarrow ok}$$

**(Access-Private)**
$$\frac{\text{Vis}(it) = \texttt{private} \quad \text{ModuleOf}(it) = m}{\Gamma \vdash \text{CanAccess}(m, it) \Downarrow ok}$$

**(Access-Protected)**
$$\frac{\text{Vis}(it) = \texttt{protected} \quad \text{ModuleOf}(it) = m}{\Gamma \vdash \text{CanAccess}(m, it) \Downarrow ok}$$

**(Access-Err)**
$$\frac{\text{Vis}(it) \in \{\texttt{private},\texttt{protected}\} \quad \text{ModuleOf}(it) \ne m \quad c = \text{Code}(\text{Access-Err})}{\Gamma \vdash \text{CanAccess}(m, it) \Uparrow c}$$

**Top-Level `protected`.**

$$\text{TopLevelDecl}(it) \iff it \in \text{ASTModule}(P, \text{ModuleOf}(it)).\text{items}$$

**(Protected-TopLevel-Ok)**
$$\frac{\text{Vis}(it) \ne \texttt{protected}}{\Gamma \vdash \text{TopLevelVis}(it) \Downarrow ok}$$

**(Protected-TopLevel-Err)**
$$\frac{\text{Vis}(it) = \texttt{protected} \quad \text{TopLevelDecl}(it) \quad c = \text{Code}(\text{Protected-TopLevel-Err})}{\Gamma \vdash \text{TopLevelVis}(it) \Uparrow c}$$

#### 5.1.5. Top-Level Name Collection (Order Independence)

**Order Independence.**
$$\forall items'.\ \text{Permutation}(items', items) \land \Gamma \vdash \text{CollectNames}(items, p, \emptyset) \Downarrow N \Rightarrow \Gamma \vdash \text{CollectNames}(items', p, \emptyset) \Downarrow N$$

**Binding Kinds.**

$$\text{BindKind} = \{\text{Value},\ \text{Type},\ \text{Class},\ \text{ModuleAlias}\}$$
$$\text{BindSource} = \{\text{Decl},\ \text{Using}\}$$
$$\text{NameInfo} = \langle \text{kind},\ \text{origin},\ \text{target\_opt},\ \text{source} \rangle$$
$$P = \text{Project}(\Gamma)$$
$$\text{NameMap}(P, mp) = N \iff \text{ModuleMap}(P, mp) = M \land \Gamma \vdash \text{CollectNames}(M) \Downarrow N$$
$$\text{AliasMap}(m) = \{ n \mapsto \text{origin} \mid \text{NameMap}(P, m)[n].\text{kind} = \text{ModuleAlias} \}$$
$$\text{UsingMap}(m) = \{ n \mapsto \langle k,\ \text{origin},\ \text{target\_opt} \rangle \mid \text{NameMap}(P, m)[n].\text{source} = \text{Using} \land \text{NameMap}(P, m)[n].\text{kind} = k \land k \in \{\text{Value},\text{Type},\text{Class}\} \}$$
$$\text{UsingValueMap}(m) = \{ n \mapsto \text{origin} \mid \text{NameMap}(P, m)[n].\text{source} = \text{Using} \land \text{NameMap}(P, m)[n].\text{kind} = \text{Value} \}$$
$$\text{UsingTypeMap}(m) = \{ n \mapsto \text{origin} \mid \text{NameMap}(P, m)[n].\text{source} = \text{Using} \land \text{NameMap}(P, m)[n].\text{kind} \in \{\text{Type},\text{Class}\} \}$$
$$\text{TypeMap}(m) = \{ n \mapsto \text{origin} \mid \text{NameMap}(P, m)[n].\text{kind} = \text{Type} \}$$
$$\text{ClassMap}(m) = \{ n \mapsto \text{origin} \mid \text{NameMap}(P, m)[n].\text{kind} = \text{Class} \}$$

**Pattern Name Extraction.**

$$\frac{}{\Gamma \vdash \text{PatNames}(\text{IdentifierPattern}(x)) \Downarrow [x]}$$

**(Pat-Typed)**
$$\frac{}{\Gamma \vdash \text{PatNames}(\text{TypedPattern}(x, \_)) \Downarrow [x]}$$

**(Pat-Wild)**
$$\frac{}{\Gamma \vdash \text{PatNames}(\text{WildcardPattern}) \Downarrow []}$$

**(Pat-Lit)**
$$\frac{}{\Gamma \vdash \text{PatNames}(\text{LiteralPattern}(lit)) \Downarrow []}$$

$$\frac{\forall i,\ \Gamma \vdash \text{PatNames}(p_i) \Downarrow N_i}{\Gamma \vdash \text{PatNames}(\text{TuplePattern}([p_1,\ldots,p_n])) \Downarrow N_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} N_n}$$

**(Pat-Record-Field-Explicit)**
$$\frac{\Gamma \vdash \text{PatNames}(p) \Downarrow N}{\Gamma \vdash \text{PatNames}(\langle \text{name},\ \text{pattern\_opt}=p,\ \text{span} \rangle) \Downarrow N}$$

**(Pat-Record-Field-Implicit)**
$$\frac{}{\Gamma \vdash \text{PatNames}(\langle \text{name},\ \text{pattern\_opt}=\bot,\ \text{span} \rangle) \Downarrow [\text{name}]}$$

$$\frac{\forall i,\ \Gamma \vdash \text{PatNames}(f_i) \Downarrow N_i}{\Gamma \vdash \text{PatNames}(\text{RecordPattern}(\_, [f_1,\ldots,f_n])) \Downarrow N_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} N_n}$$

**(Pat-Enum-None)**
$$\frac{}{\Gamma \vdash \text{PatNames}(\text{EnumPattern}(\_, \_, \bot)) \Downarrow []}$$

**(Pat-Enum-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{PatNames}(p_i) \Downarrow N_i}{\Gamma \vdash \text{PatNames}(\text{EnumPattern}(\_, \_, \text{TuplePayloadPattern}([p_1,\ldots,p_n]))) \Downarrow N_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} N_n}$$

**(Pat-Enum-Record)**
$$\frac{\forall i,\ \Gamma \vdash \text{PatNames}(f_i) \Downarrow N_i}{\Gamma \vdash \text{PatNames}(\text{EnumPattern}(\_, \_, \text{RecordPayloadPattern}([f_1,\ldots,f_n]))) \Downarrow N_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} N_n}$$

**(Pat-Range)**
$$\frac{\Gamma \vdash \text{PatNames}(p_l) \Downarrow N_l \quad \Gamma \vdash \text{PatNames}(p_h) \Downarrow N_h}{\Gamma \vdash \text{PatNames}(\text{RangePattern}(\_, p_l, p_h)) \Downarrow N_l \mathbin{+\!\!+} N_h}$$

**Using Bindings.**
$$\text{ModuleNames} = \{ \text{StringOfPath}(p) \mid p \in \text{ModulePaths} \}$$
$$\text{Last}([c_1,\ldots,c_n]) = c_n \ \text{if } n \ge 1$$
$$\text{IsModulePath}(\text{path}) \iff \text{StringOfPath}(\text{path}) \in \text{ModuleNames}$$
$$\text{SplitLast}(\text{path}) = (mp, name) \iff \text{path} = mp \mathbin{+\!\!+} [name] \land |\text{path}| \ge 2$$
$$\text{ModuleByPath}(P,p) = m \iff \text{ASTModule}(P,p) = m$$

**Item Names.**
$$\text{ItemNames}(mp) = \{ n \mid \text{NameMap}(P, mp)[n].\text{kind} \in \{\text{Value},\ \text{Type},\ \text{Class}\} \}$$

**Using Spec Names.**
$$\text{UsingSpecName}(\langle name,\ \text{alias\_opt} \rangle) = name$$
$$\text{UsingSpecNames}([s_1,\ldots,s_n]) = [\text{UsingSpecName}(s_1),\ldots,\text{UsingSpecName}(s_n)]$$

**Declared Names (Non-Using).**

**(DeclNames-Empty)**
$$\frac{}{\Gamma \vdash \text{DeclNames}([], p) \Downarrow \emptyset}$$

**(DeclNames-Using)**
$$\frac{\Gamma \vdash \text{DeclNames}(rest, p) \Downarrow D}{\Gamma \vdash \text{DeclNames}(\langle \text{UsingDecl},\ \_,\ \_,\ \_,\ \_ \rangle :: rest, p) \Downarrow D}$$

**(DeclNames-Item)**
$$\frac{it \ne \langle \text{UsingDecl},\ \_,\ \_,\ \_,\ \_ \rangle \quad \Gamma \vdash \text{ItemBindings}(it, p) \Downarrow B \quad \Gamma \vdash \text{DeclNames}(rest, p) \Downarrow D}{\Gamma \vdash \text{DeclNames}(it :: rest, p) \Downarrow \text{Names}(B) \cup D}$$

$$\text{DeclNames}(m) = \text{DeclNames}(m.\text{items},\ m.\text{path})$$

**Item-Path Resolution.**

**(ItemOfPath)**
$$\frac{|path| \ge 2 \quad \text{SplitLast}(path) = (mp, name) \quad \text{IsModulePath}(mp) \quad m = \text{ModuleByPath}(P, mp) \quad \text{IdKey}(name) \in \text{ItemNames}(mp)}{\Gamma \vdash \text{ItemOfPath}(path) \Downarrow (mp, name)}$$

**(ItemOfPath-None)**
$$\frac{\neg(|path| \ge 2 \land \text{SplitLast}(path) = (mp, name) \land \text{IsModulePath}(mp) \land m = \text{ModuleByPath}(P, mp) \land \text{IdKey}(name) \in \text{ItemNames}(mp))}{\Gamma \vdash \text{ItemOfPath}(path) \uparrow}$$

**Using Path Resolution.**

**(Resolve-Using-Item)**
$$\frac{\Gamma \vdash \text{ItemOfPath}(path) \Downarrow (mp, name) \quad \neg \text{IsModulePath}(path)}{\Gamma \vdash \text{ResolveUsingPath}(path) \Downarrow \langle \text{Item}, mp, name \rangle}$$

**(Resolve-Using-Module)**
$$\frac{\text{IsModulePath}(path) \quad \Gamma \vdash \text{ItemOfPath}(path) \uparrow}{\Gamma \vdash \text{ResolveUsingPath}(path) \Downarrow \langle \text{Module}, path \rangle}$$

**(Resolve-Using-Ambig)**
$$\frac{\text{IsModulePath}(path) \quad \Gamma \vdash \text{ItemOfPath}(path) \Downarrow (mp, name) \quad c = \text{Code}(\text{Resolve-Using-Ambig})}{\Gamma \vdash \text{ResolveUsingPath}(path) \Uparrow c}$$

**(Resolve-Using-None)**
$$\frac{\neg \text{IsModulePath}(path) \quad \Gamma \vdash \text{ItemOfPath}(path) \uparrow \quad c = \text{Code}(\text{Resolve-Using-None})}{\Gamma \vdash \text{ResolveUsingPath}(path) \Uparrow c}$$

**(Using-Path-Item)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ vis,\ \langle \text{UsingPath}, path, alias\_opt \rangle,\ \_,\ \_ \rangle \quad \Gamma \vdash \text{ResolveUsingPath}(path) \Downarrow \langle \text{Item}, mp, item \rangle \quad \Gamma \vdash \text{CanAccess}(m, \text{DeclOf}(mp,item)) \Downarrow ok \quad (vis = \texttt{public} \Rightarrow \text{Vis}(\text{DeclOf}(mp,item)) = \texttt{public}) \quad \text{NameMap}(P, mp)[\text{IdKey}(item)] = \langle k,\ \_,\ \_,\ \_ \rangle \quad k \in \{\text{Value},\text{Type},\text{Class}\} \quad name = \text{alias\_opt} \ \text{if present, else}\ item}{\Gamma \vdash \text{UsingNames}(u) \Downarrow [(name, \langle k,\ mp,\ item,\ \text{Using} \rangle)]}$$

**(Using-Path-Item-Public-Err)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ \texttt{public},\ \langle \text{UsingPath}, path, \_ \rangle,\ \_,\ \_ \rangle \quad \Gamma \vdash \text{ResolveUsingPath}(path) \Downarrow \langle \text{Item}, mp, item \rangle \quad \text{Vis}(\text{DeclOf}(mp,item)) \ne \texttt{public} \quad c = \text{Code}(\text{Using-Path-Item-Public-Err})}{\Gamma \vdash \text{UsingNames}(u) \Uparrow c}$$

**(Using-Path-Module)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ \_,\ \langle \text{UsingPath}, path, alias\_opt \rangle,\ \_,\ \_ \rangle \quad \Gamma \vdash \text{ResolveUsingPath}(path) \Downarrow \langle \text{Module}, path \rangle \quad name = \text{alias\_opt} \ \text{if present, else}\ \text{Last}(path)}{\Gamma \vdash \text{UsingNames}(u) \Downarrow [(name, \langle \text{ModuleAlias}, path,\ \bot,\ \text{Using} \rangle)]}$$

**(Using-List)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ vis,\ \langle \text{UsingList}, mp, [s_1,\ldots,s_n] \rangle,\ \_,\ \_ \rangle \quad \text{Distinct}(\text{UsingSpecNames}([s_1,\ldots,s_n])) \quad \forall i,\ s_i = \langle name_i, alias_i \rangle \quad \text{NameMap}(P, mp)[\text{IdKey}(name_i)] = \langle k_i,\ \_,\ \_,\ \_ \rangle \quad k_i \in \{\text{Value},\text{Type},\text{Class}\} \quad \Gamma \vdash \text{CanAccess}(m, \text{DeclOf}(mp,name_i)) \Downarrow ok \quad (vis = \texttt{public} \Rightarrow \text{Vis}(\text{DeclOf}(mp,name_i)) = \texttt{public}) \quad bind_i = \langle (\text{alias}_i\ \text{if present else}\ name_i),\ \langle k_i,\ mp,\ name_i,\ \text{Using} \rangle \rangle}{\Gamma \vdash \text{UsingNames}(u) \Downarrow [bind_1,\ldots,bind_n]}$$

**(Using-List-Dup)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ \_,\ \langle \text{UsingList},\ \_,\ specs \rangle,\ \_,\ \_ \rangle \quad \neg \text{Distinct}(\text{UsingSpecNames}(specs)) \quad c = \text{Code}(\text{Using-List-Dup})}{\Gamma \vdash \text{UsingNames}(u) \Uparrow c}$$

**(Using-List-Public-Err)**
$$\frac{\text{u} = \langle \text{UsingDecl},\ \texttt{public},\ \langle \text{UsingList}, mp, [s_1,\ldots,s_n] \rangle,\ \_,\ \_ \rangle \quad \exists i.\ s_i = \langle name_i,\ \_ \rangle \land \text{Vis}(\text{DeclOf}(mp,name_i)) \ne \texttt{public} \quad c = \text{Code}(\text{Using-List-Public-Err})}{\Gamma \vdash \text{UsingNames}(u) \Uparrow c}$$

**Item Bindings.**

**(Bind-Procedure)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\langle \text{ProcedureDecl},\ \_,\ name,\ \_,\ \_,\ \_,\ \_,\ \_ \rangle, p) \Downarrow [(name, \langle \text{Value}, p, \bot, \text{Decl} \rangle)]}$$

**(Bind-Record)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\langle \text{RecordDecl},\ \_,\ name,\ \_,\ \_,\ \_,\ \_ \rangle, p) \Downarrow [(name, \langle \text{Type}, p, \bot, \text{Decl} \rangle)]}$$

**(Bind-Enum)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\langle \text{EnumDecl},\ \_,\ name,\ \_,\ \_,\ \_,\ \_ \rangle, p) \Downarrow [(name, \langle \text{Type}, p, \bot, \text{Decl} \rangle)]}$$

**(Bind-Class)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\langle \text{ClassDecl},\ \_,\ name,\ \_,\ \_,\ \_,\ \_ \rangle, p) \Downarrow [(name, \langle \text{Class}, p, \bot, \text{Decl} \rangle)]}$$

**(Bind-TypeAlias)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\langle \text{TypeAliasDecl},\ \_,\ name,\ \_,\ \_,\ \_ \rangle, p) \Downarrow [(name, \langle \text{Type}, p, \bot, \text{Decl} \rangle)]}$$

**(Bind-Static)**
$$\frac{\Gamma \vdash \text{PatNames}(pat) \Downarrow N}{\Gamma \vdash \text{ItemBindings}(\langle \text{StaticDecl},\ \_,\ \_,\ \langle pat,\ \_,\ \_,\ \_,\ \_ \rangle,\ \_,\ \_ \rangle, p) \Downarrow [ (n, \langle \text{Value}, p, \bot, \text{Decl} \rangle) \mid n \in N ]}$$

**(Bind-Using)**
$$\frac{\Gamma \vdash \text{UsingNames}(u) \Downarrow B}{\Gamma \vdash \text{ItemBindings}(u, p) \Downarrow B}$$

**(Bind-Using-Err)**
$$\frac{\Gamma \vdash \text{UsingNames}(u) \Uparrow c}{\Gamma \vdash \text{ItemBindings}(u, p) \Uparrow c}$$

**(Bind-ErrorItem)**
$$\frac{}{\Gamma \vdash \text{ItemBindings}(\text{ErrorItem}(\_), p) \Downarrow []}$$

**CollectNames (Big-Step).**

**(Collect-Ok)**
$$\frac{\Gamma \vdash \text{CollectNames}(items, p, \emptyset) \Downarrow N}{\Gamma \vdash \text{CollectNames}(M) \Downarrow N}$$

**(Collect-Scan)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Downarrow B \quad \text{DisjointNames}(B, N) \quad \text{NoDup}(B) \quad \Gamma \vdash \text{CollectNames}(rest, p, N \cup B) \Downarrow N'}{\Gamma \vdash \text{CollectNames}(it::rest, p, N) \Downarrow N'}$$

**(Collect-Dup)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Downarrow B \quad (\neg \text{DisjointNames}(B, N) \ \lor\ \neg \text{NoDup}(B)) \quad c = \text{Code}(\text{Collect-Dup})}{\Gamma \vdash \text{CollectNames}(it::rest, p, N) \Uparrow c}$$

**(Collect-Err)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Uparrow c}{\Gamma \vdash \text{CollectNames}(it::rest, p, N) \Uparrow c}$$

$$\text{Names}(B) = \{ n \mid (n,\_) \in B \}$$
$$\text{NoDup}(B) \iff \text{Distinct}(\text{Names}(B))$$
$$\text{DisjointNames}(B,N) \iff \text{Names}(B) \cap \text{dom}(N) = \emptyset$$
$$N \cup B = \{ (n,v) \mid (n,v) \in N \lor (n,v) \in B \}$$

**CollectNames (Small-Step).**
$$\text{NamesState} = \{\text{NamesStart}(M),\ \text{NamesScan}(items,p,N),\ \text{NamesDone}(N),\ \text{Error}(code)\}$$

**(Names-Start)**
$$\frac{}{\langle \text{NamesStart}(M) \rangle \to \langle \text{NamesScan}(M.\text{items}, M.\text{path}, \emptyset) \rangle}$$

**(Names-Step)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Downarrow B \quad \text{DisjointNames}(B,N) \quad \text{NoDup}(B)}{\langle \text{NamesScan}(it::rest, p, N) \rangle \to \langle \text{NamesScan}(rest, p, N \cup B) \rangle}$$

**(Names-Step-Dup)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Downarrow B \quad (\neg \text{DisjointNames}(B,N) \ \lor\ \neg \text{NoDup}(B))}{\langle \text{NamesScan}(it::rest, p, N) \rangle \to \langle \text{Error}(\text{Code}(\text{Names-Step-Dup})) \rangle}$$

**(Names-Step-Err)**
$$\frac{\Gamma \vdash \text{ItemBindings}(it, p) \Uparrow c}{\langle \text{NamesScan}(it::rest, p, N) \rangle \to \langle \text{Error}(c) \rangle}$$

**(Names-Done)**
$$\frac{}{\langle \text{NamesScan}([], p, N) \rangle \to \langle \text{NamesDone}(N) \rangle}$$


#### 5.1.6. Qualified Disambiguation (Resolution-Time)

$$\text{ResolveQualifiedForm} : \text{Expr} \rightharpoonup \text{Expr}$$

$$\text{ResolveArgs} : [\text{Arg}] \rightharpoonup [\text{Arg}]$$
$$\text{ResolveFieldInits} : [\text{FieldInit}] \rightharpoonup [\text{FieldInit}]$$
$$\text{ResolveRecordPath} : \text{Path} \times \text{Identifier} \rightharpoonup \text{Path}$$
$$\text{ResolveEnumUnit} : \text{Path} \times \text{Identifier} \rightharpoonup \text{Path}$$
$$\text{ResolveEnumTuple} : \text{Path} \times \text{Identifier} \rightharpoonup \text{Path}$$
$$\text{ResolveEnumRecord} : \text{Path} \times \text{Identifier} \rightharpoonup \text{Path}$$

**(ResolveArgs-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveArgs}([]) \Downarrow []}$$

**(ResolveArgs-Cons)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e' \quad \Gamma \vdash \text{ResolveArgs}(rest) \Downarrow rest'}{\Gamma \vdash \text{ResolveArgs}([\langle moved, e, span \rangle] \mathbin{+\!\!+} rest) \Downarrow [\langle moved, e', span \rangle] \mathbin{+\!\!+} rest'}$$

**(ResolveFieldInits-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveFieldInits}([]) \Downarrow []}$$

**(ResolveFieldInits-Cons)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e' \quad \Gamma \vdash \text{ResolveFieldInits}(rest) \Downarrow rest'}{\Gamma \vdash \text{ResolveFieldInits}([\langle f, e \rangle] \mathbin{+\!\!+} rest) \Downarrow [\langle f, e' \rangle] \mathbin{+\!\!+} rest'}$$

$$\text{ResolvePathJudg} = \{\text{ResolveRecordPath},\ \text{ResolveEnumUnit},\ \text{ResolveEnumTuple},\ \text{ResolveEnumRecord}\}$$

**(Resolve-RecordPath)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path \mathbin{+\!\!+} [name]) \Downarrow p \quad \text{RecordDecl}(p) = R}{\Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p}$$

**(Resolve-EnumUnit)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow p \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, name) = \bot}{\Gamma \vdash \text{ResolveEnumUnit}(path, name) \Downarrow p}$$

**(Resolve-EnumTuple)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow p \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, name) = \text{TuplePayload}(\_)}{\Gamma \vdash \text{ResolveEnumTuple}(path, name) \Downarrow p}$$

**(Resolve-EnumRecord)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow p \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, name) = \text{RecordPayload}(\_)}{\Gamma \vdash \text{ResolveEnumRecord}(path, name) \Downarrow p}$$

**(ResolveQual-Name-Value)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \text{PathOfModule}(mp) = path'}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedName}(path, name)) \Downarrow \text{Path}(path', name')}$$

**(ResolveQual-Name-Record)**
$$\frac{\Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, name')}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedName}(path, name)) \Downarrow \text{Path}(mp, name')}$$

**(ResolveQual-Name-Enum)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumUnit}(path, name) \Downarrow p}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedName}(path, name)) \Downarrow \text{EnumLiteral}(\text{FullPath}(p, name), \bot)}$$

**(ResolveQual-Name-Err)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumUnit}(path, name) \uparrow \quad c = \text{Code}(\text{ResolveExpr-Ident-Err})}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedName}(path, name)) \Uparrow c}$$

**(ResolveQual-Apply-Value)**
$$\frac{\Gamma \vdash \text{ResolveArgs}(args) \Downarrow args' \quad \Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \text{PathOfModule}(mp) = path'}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Paren}(args))) \Downarrow \text{Call}(\text{Path}(path', name'), args')}$$

**(ResolveQual-Apply-Record)**
$$\frac{\Gamma \vdash \text{ResolveArgs}(args) \Downarrow args' \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, name')}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Paren}(args))) \Downarrow \text{Call}(\text{Path}(mp, name'), args')}$$

**(ResolveQual-Apply-Enum-Tuple)**
$$\frac{\Gamma \vdash \text{ResolveArgs}(args) \Downarrow args' \quad \Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumTuple}(path, name) \Downarrow p}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Paren}(args))) \Downarrow \text{EnumLiteral}(\text{FullPath}(p, name), \text{Paren}(\text{ArgsExprs}(args')))}$$

**(ResolveQual-Apply-Err)**
$$\frac{\Gamma \vdash \text{ResolveArgs}(args) \Downarrow args' \quad \Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumTuple}(path, name) \uparrow \quad c = \text{Code}(\text{ResolveExpr-Ident-Err})}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Paren}(args))) \Uparrow c}$$

**Qualified Apply (Brace).**

**(ResolveQual-Apply-RecordLit)**
$$\frac{\Gamma \vdash \text{ResolveFieldInits}(fields) \Downarrow fields' \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Brace}(fields))) \Downarrow \text{RecordExpr}(\text{TypePath}(p), fields')}$$

**(ResolveQual-Apply-Enum-Record)**
$$\frac{\Gamma \vdash \text{ResolveFieldInits}(fields) \Downarrow fields' \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumRecord}(path, name) \Downarrow p}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Brace}(fields))) \Downarrow \text{EnumLiteral}(\text{FullPath}(p, name), \text{Brace}(fields'))}$$

**(ResolveQual-Apply-Brace-Err)**
$$\frac{\Gamma \vdash \text{ResolveFieldInits}(fields) \Downarrow fields' \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \uparrow \quad \Gamma \vdash \text{ResolveEnumRecord}(path, name) \uparrow \quad c = \text{Code}(\text{ResolveExpr-Ident-Err})}{\Gamma \vdash \text{ResolveQualifiedForm}(\text{QualifiedApply}(path, name, \text{Brace}(fields))) \Uparrow c}$$

#### 5.1.7. Resolution Pass (Big-Step and Small-Step)

$$P = \text{Project}(\Gamma)$$
$$m = \text{CurrentModule}(\Gamma)$$
$$M = \text{ASTModule}(P, m)$$
$$\text{ResolveInputs} = \langle M,\ \text{ModulePaths},\ \{ \text{NameMap}(P, p) \mid p \in \text{ModulePaths} \} \rangle$$
$$\text{ResolveOutputs} = \langle M' \rangle$$
$$\text{PathOfModuleRef} = \{\texttt{"3.4.1"}\}$$

**(Validate-ModulePath-Ok)**
$$\frac{\neg \text{ReservedModulePath}(\text{PathOfModule}(p))}{\Gamma \vdash \text{ValidateModulePath}(p) \Downarrow ok}$$

**(Validate-ModulePath-Reserved-Err)**
$$\frac{\text{ReservedModulePath}(\text{PathOfModule}(p)) \quad c = \text{Code}(\text{Validate-ModulePath-Reserved-Err})}{\Gamma \vdash \text{ValidateModulePath}(p) \Uparrow c}$$

**(ResolveModule-Ok)**
$$\frac{\Gamma \vdash \text{CollectNames}(M) \Downarrow N \quad \Gamma \vdash \text{ValidateModulePath}(M.\text{path}) \Downarrow ok \quad \Gamma \vdash \text{ValidateModuleNames}(N) \Downarrow ok \quad S_{module} = N \quad \Gamma_N = [S_{module}, S_{universe}] \quad \Gamma_N \vdash \text{ResolveItems}(M.\text{items}) \Downarrow items'}{\Gamma \vdash \text{ResolveModule}(M) \Downarrow \langle M.\text{path}, items', M.\text{module\_doc} \rangle}$$

**(ResolveItems-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveItems}([]) \Downarrow []}$$

**(ResolveItems-Cons)**
$$\frac{\Gamma \vdash \text{TopLevelVis}(it) \Downarrow ok \quad \Gamma \vdash \text{ResolveItem}(it) \Downarrow it' \quad \Gamma \vdash \text{ResolveItems}(rest) \Downarrow rest'}{\Gamma \vdash \text{ResolveItems}(it::rest) \Downarrow it'::rest'}$$

**(ResolveItem-Static)**
$$\frac{\Gamma \vdash \text{ResolvePattern}(pat) \Downarrow pat' \quad \Gamma \vdash \text{ResolveExpr}(init) \Downarrow init' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt'}{\Gamma \vdash \text{ResolveItem}(\text{StaticDecl}(vis, mut, \langle pat, ty\_opt, op, init, span \rangle, span', doc)) \Downarrow \text{StaticDecl}(vis, mut, \langle pat', ty\_opt', op, init', span \rangle, span', doc)}$$

**(ResolveItem-Procedure)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma_p = [S_{proc}, S_{module}, S_{universe}] \quad \Gamma_p \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_p \vdash \text{ResolveTypeOpt}(ret\_opt) \Downarrow ret\_opt' \quad \Gamma_p \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveItem}(\text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc)) \Downarrow \text{ProcedureDecl}(vis, name, params', ret\_opt', body', span, doc)}$$

**(ResolveItem-Using)**
$$\frac{}{\Gamma \vdash \text{ResolveItem}(\text{UsingDecl}(vis, clause, span, doc)) \Downarrow \text{UsingDecl}(vis, clause, span, doc)}$$

**(ResolveItem-TypeAlias)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolveItem}(\text{TypeAliasDecl}(vis, name, ty, span, doc)) \Downarrow \text{TypeAliasDecl}(vis, name, ty', span, doc)}$$

**(ResolveItem-Record)**
$$\frac{R = \text{RecordDecl}(vis, name, impls, members, span, doc) \quad \Gamma \vdash \text{ResolveClassPathList}(impls) \Downarrow impls' \quad \Gamma \vdash \text{ResolveRecordMemberList}(R, members) \Downarrow members'}{\Gamma \vdash \text{ResolveItem}(R) \Downarrow \text{RecordDecl}(vis, name, impls', members', span, doc)}$$

**(ResolveItem-Enum)**
$$\frac{\Gamma \vdash \text{ResolveClassPathList}(impls) \Downarrow impls' \quad \Gamma \vdash \text{ResolveVariantList}(vars) \Downarrow vars'}{\Gamma \vdash \text{ResolveItem}(\text{EnumDecl}(vis, name, impls, vars, span, doc)) \Downarrow \text{EnumDecl}(vis, name, impls', vars', span, doc)}$$

**(ResolveItem-Modal)**
$$\frac{\Gamma \vdash \text{ResolveClassPathList}(impls) \Downarrow impls' \quad \Gamma \vdash \text{ResolveStateBlockList}(states) \Downarrow states'}{\Gamma \vdash \text{ResolveItem}(\text{ModalDecl}(vis, name, impls, states, span, doc)) \Downarrow \text{ModalDecl}(vis, name, impls', states', span, doc)}$$

**(ResolveItem-Class)**
$$\frac{\Gamma \vdash \text{ResolveClassPathList}(supers) \Downarrow supers' \quad \Gamma \vdash \text{ResolveClassItemList}(items) \Downarrow items'}{\Gamma \vdash \text{ResolveItem}(\text{ClassDecl}(vis, name, supers, items, span, doc)) \Downarrow \text{ClassDecl}(vis, name, supers', items', span, doc)}$$

**Self Binding for Methods.**

**(BindSelf-Record)**
$$\frac{\text{RecordPath}(R) = p \quad \text{SplitLast}(p) = (mp, name) \quad S_{proc}' = S_{proc}[\text{IdKey}(\texttt{"Self"}) \mapsto \langle \text{Type}, mp, name, \text{Decl} \rangle]}{\Gamma \vdash \text{BindSelfRecord}(R, S_{proc}) \Downarrow S_{proc}'}$$

**(BindSelf-Class)**
$$\frac{S_{proc}' = S_{proc}[\text{IdKey}(\texttt{"Self"}) \mapsto \langle \text{Type}, \bot, \bot, \text{Decl} \rangle]}{\Gamma \vdash \text{BindSelfClass}(S_{proc}) \Downarrow S_{proc}'}$$

**(ResolveReceiver-Shorthand)**
$$\frac{}{\Gamma \vdash \text{ResolveReceiver}(\text{ReceiverShorthand}(\text{perm})) \Downarrow \text{ReceiverShorthand}(\text{perm})}$$

**(ResolveReceiver-Explicit)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolveReceiver}(\text{ReceiverExplicit}(mode\_opt, ty)) \Downarrow \text{ReceiverExplicit}(mode\_opt, ty')}$$

**(ResolveClassPathList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveClassPathList}([]) \Downarrow []}$$

**(ResolveClassPathList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveClassPath}(p) \Downarrow p' \quad \Gamma \vdash \text{ResolveClassPathList}(ps) \Downarrow ps'}{\Gamma \vdash \text{ResolveClassPathList}(p::ps) \Downarrow p'::ps'}$$

**(ResolveTypeList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveTypeList}([]) \Downarrow []}$$

**(ResolveTypeList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveType}(t) \Downarrow t' \quad \Gamma \vdash \text{ResolveTypeList}(ts) \Downarrow ts'}{\Gamma \vdash \text{ResolveTypeList}(t::ts) \Downarrow t'::ts'}$$

**(ResolveFieldDecl)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty' \quad \Gamma \vdash \text{ResolveExprOpt}(init\_opt) \Downarrow init\_opt'}{\Gamma \vdash \text{ResolveFieldDecl}(\text{FieldDecl}(vis,name,ty,init\_opt,span,doc\_opt)) \Downarrow \text{FieldDecl}(vis,name,ty',init\_opt',span,doc\_opt)}$$

**(ResolveFieldDeclList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveFieldDeclList}([]) \Downarrow []}$$

**(ResolveFieldDeclList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveFieldDecl}(f) \Downarrow f' \quad \Gamma \vdash \text{ResolveFieldDeclList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolveFieldDeclList}(f::fs) \Downarrow f'::fs'}$$

**(ResolveRecordMember-Field)**
$$\frac{\Gamma \vdash \text{ResolveFieldDecl}(f) \Downarrow f'}{\Gamma \vdash \text{ResolveRecordMember}(R, f) \Downarrow f'}$$

**(ResolveRecordMember-Method)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma \vdash \text{BindSelfRecord}(R, S_{proc}) \Downarrow S_{proc}' \quad \Gamma_m = [S_{proc}', S_{module}, S_{universe}] \quad \Gamma_m \vdash \text{ResolveReceiver}(recv) \Downarrow recv' \quad \Gamma_m \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_m \vdash \text{ResolveTypeOpt}(ret\_opt) \Downarrow ret\_opt' \quad \Gamma_m \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveRecordMember}(R, \text{MethodDecl}(vis, override, name, recv, params, ret\_opt, body, span, doc\_opt)) \Downarrow \text{MethodDecl}(vis, override, name, recv', params', ret\_opt', body', span, doc\_opt)}$$

**(ResolveRecordMemberList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveRecordMemberList}(R, []) \Downarrow []}$$

**(ResolveRecordMemberList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveRecordMember}(R, m) \Downarrow m' \quad \Gamma \vdash \text{ResolveRecordMemberList}(R, ms) \Downarrow ms'}{\Gamma \vdash \text{ResolveRecordMemberList}(R, m::ms) \Downarrow m'::ms'}$$

**(ResolveClassItem-Field)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolveClassItem}(\text{ClassFieldDecl}(vis,name,ty,span,doc\_opt)) \Downarrow \text{ClassFieldDecl}(vis,name,ty',span,doc\_opt)}$$

**(ResolveClassItem-Method-Abstract)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma \vdash \text{BindSelfClass}(S_{proc}) \Downarrow S_{proc}' \quad \Gamma_m = [S_{proc}', S_{module}, S_{universe}] \quad \Gamma_m \vdash \text{ResolveReceiver}(recv) \Downarrow recv' \quad \Gamma_m \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_m \vdash \text{ResolveTypeOpt}(ret\_opt) \Downarrow ret\_opt'}{\Gamma \vdash \text{ResolveClassItem}(\text{ClassMethodDecl}(vis,name,recv,params,ret\_opt,\bot,span,doc\_opt)) \Downarrow \text{ClassMethodDecl}(vis,name,recv',params',ret\_opt',\bot,span,doc\_opt)}$$

**(ResolveClassItem-Method-Concrete)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma \vdash \text{BindSelfClass}(S_{proc}) \Downarrow S_{proc}' \quad \Gamma_m = [S_{proc}', S_{module}, S_{universe}] \quad \Gamma_m \vdash \text{ResolveReceiver}(recv) \Downarrow recv' \quad \Gamma_m \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_m \vdash \text{ResolveTypeOpt}(ret\_opt) \Downarrow ret\_opt' \quad \Gamma_m \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveClassItem}(\text{ClassMethodDecl}(vis,name,recv,params,ret\_opt,body,span,doc\_opt)) \Downarrow \text{ClassMethodDecl}(vis,name,recv',params',ret\_opt',body',span,doc\_opt)}$$

**(ResolveClassItemList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveClassItemList}([]) \Downarrow []}$$

**(ResolveClassItemList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveClassItem}(it) \Downarrow it' \quad \Gamma \vdash \text{ResolveClassItemList}(its) \Downarrow its'}{\Gamma \vdash \text{ResolveClassItemList}(it::its) \Downarrow it'::its'}$$

**(ResolveVariantPayloadOpt-None)**
$$\frac{}{\Gamma \vdash \text{ResolveVariantPayloadOpt}(\bot) \Downarrow \bot}$$

**(ResolveVariantPayloadOpt-Tuple)**
$$\frac{\Gamma \vdash \text{ResolveTypeList}(ts) \Downarrow ts'}{\Gamma \vdash \text{ResolveVariantPayloadOpt}(\text{TuplePayload}(ts)) \Downarrow \text{TuplePayload}(ts')}$$

**(ResolveVariantPayloadOpt-Record)**
$$\frac{\Gamma \vdash \text{ResolveFieldDeclList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolveVariantPayloadOpt}(\text{RecordPayload}(fs)) \Downarrow \text{RecordPayload}(fs')}$$

**(ResolveVariant)**
$$\frac{\Gamma \vdash \text{ResolveVariantPayloadOpt}(payload\_opt) \Downarrow payload\_opt' \quad \Gamma \vdash \text{ResolveExprOpt}(disc\_opt) \Downarrow disc\_opt'}{\Gamma \vdash \text{ResolveVariant}(\text{VariantDecl}(name,payload\_opt,disc\_opt,span,doc\_opt)) \Downarrow \text{VariantDecl}(name,payload\_opt',disc\_opt',span,doc\_opt)}$$

**(ResolveVariantList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveVariantList}([]) \Downarrow []}$$

**(ResolveVariantList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveVariant}(v) \Downarrow v' \quad \Gamma \vdash \text{ResolveVariantList}(vs) \Downarrow vs'}{\Gamma \vdash \text{ResolveVariantList}(v::vs) \Downarrow v'::vs'}$$

**(ResolveStateMember-Field)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolveStateMember}(\text{StateFieldDecl}(vis,name,ty,span,doc\_opt)) \Downarrow \text{StateFieldDecl}(vis,name,ty',span,doc\_opt)}$$

**(ResolveStateMember-Method)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma_m = [S_{proc}, S_{module}, S_{universe}] \quad \Gamma_m \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_m \vdash \text{ResolveTypeOpt}(ret\_opt) \Downarrow ret\_opt' \quad \Gamma_m \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveStateMember}(\text{StateMethodDecl}(vis,name,params,ret\_opt,body,span,doc\_opt)) \Downarrow \text{StateMethodDecl}(vis,name,params',ret\_opt',body',span,doc\_opt)}$$

**(ResolveStateMember-Transition)**
$$\frac{S_{proc} = \{ \text{IdKey}(p.\text{name}) \mapsto \langle \text{Value}, \bot, \bot, \text{Decl} \rangle \mid p \in params \} \quad \Gamma_m = [S_{proc}, S_{module}, S_{universe}] \quad \Gamma_m \vdash \text{ResolveParams}(params) \Downarrow params' \quad \Gamma_m \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveStateMember}(\text{TransitionDecl}(vis,name,params,target\_state,body,span,doc\_opt)) \Downarrow \text{TransitionDecl}(vis,name,params',target\_state,body',span,doc\_opt)}$$

**(ResolveStateMemberList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveStateMemberList}([]) \Downarrow []}$$

**(ResolveStateMemberList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveStateMember}(m) \Downarrow m' \quad \Gamma \vdash \text{ResolveStateMemberList}(ms) \Downarrow ms'}{\Gamma \vdash \text{ResolveStateMemberList}(m::ms) \Downarrow m'::ms'}$$

**(ResolveStateBlock)**
$$\frac{\Gamma \vdash \text{ResolveStateMemberList}(members) \Downarrow members'}{\Gamma \vdash \text{ResolveStateBlock}(\text{StateBlock}(name,members,span,doc\_opt)) \Downarrow \text{StateBlock}(name,members',span,doc\_opt)}$$

**(ResolveStateBlockList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveStateBlockList}([]) \Downarrow []}$$

**(ResolveStateBlockList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveStateBlock}(b) \Downarrow b' \quad \Gamma \vdash \text{ResolveStateBlockList}(bs) \Downarrow bs'}{\Gamma \vdash \text{ResolveStateBlockList}(b::bs) \Downarrow b'::bs'}$$

**(ResolveTypeOpt-None)**
$$\frac{}{\Gamma \vdash \text{ResolveTypeOpt}(\bot) \Downarrow \bot}$$

**(ResolveTypeOpt-Some)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolveTypeOpt}(ty) \Downarrow ty'}$$

**(ResolveExprOpt-None)**
$$\frac{}{\Gamma \vdash \text{ResolveExprOpt}(\bot) \Downarrow \bot}$$

**(ResolveExprOpt-Some)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'}{\Gamma \vdash \text{ResolveExprOpt}(e) \Downarrow e'}$$

**(ResolveTypePath-Ident)**
$$\frac{|path| = 1 \quad \Gamma \vdash \text{ResolveTypeName}(path[0]) \Downarrow ent \quad ent.\text{origin\_opt} = p \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ path[0])}{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow \text{FullPath}(\text{PathOfModule}(p), name)}$$

**(ResolveTypePath-Ident-Local)**
$$\frac{|path| = 1 \quad \Gamma \vdash \text{ResolveTypeName}(path[0]) \Downarrow ent \quad ent.\text{origin\_opt} = \bot \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ path[0])}{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow [name]}$$

**(ResolveTypePath-Qual)**
$$\frac{|path| \ge 2 \quad path = p \mathbin{+\!\!+} [name] \quad \Gamma \vdash \text{ResolveQualified}(p, name, \text{TypeKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name)}{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow \text{FullPath}(\text{PathOfModule}(mp), name')}$$

$$\text{LocalTypePath}(path) \iff |path|=1 \land \Gamma \vdash \text{ResolveTypeName}(path[0]) \Downarrow ent \land ent.\text{origin\_opt} = \bot$$

**(ResolveClassPath-Ident)**
$$\frac{|path| = 1 \quad \Gamma \vdash \text{ResolveClassName}(path[0]) \Downarrow ent \quad ent.\text{origin\_opt} = p \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ path[0])}{\Gamma \vdash \text{ResolveClassPath}(path) \Downarrow \text{FullPath}(\text{PathOfModule}(p), name)}$$

**(ResolveClassPath-Qual)**
$$\frac{|path| \ge 2 \quad path = p \mathbin{+\!\!+} [name] \quad \Gamma \vdash \text{ResolveQualified}(p, name, \text{ClassKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name)}{\Gamma \vdash \text{ResolveClassPath}(path) \Downarrow \text{FullPath}(\text{PathOfModule}(mp), name')}$$

**(ResolveType-Path)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow path'}{\Gamma \vdash \text{ResolveType}(\text{TypePath}(path)) \Downarrow \text{TypePath}(path')}$$

**(ResolveType-Dynamic)**
$$\frac{\Gamma \vdash \text{ResolveClassPath}(path) \Downarrow path'}{\Gamma \vdash \text{ResolveType}(\text{TypeDynamic}(path)) \Downarrow \text{TypeDynamic}(path')}$$

**(ResolveType-ModalState)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow path'}{\Gamma \vdash \text{ResolveType}(\text{TypeModalState}(path, state)) \Downarrow \text{TypeModalState}(path', state)}$$

**(ResolveTypeRef-Path)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow path'}{\Gamma \vdash \text{ResolveTypeRef}(\text{TypePath}(path)) \Downarrow \text{TypePath}(path')}$$

**(ResolveTypeRef-ModalState)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(path) \Downarrow path'}{\Gamma \vdash \text{ResolveTypeRef}(\text{ModalStateRef}(path, state)) \Downarrow \text{ModalStateRef}(path', state)}$$

**(ResolveType-Hom)**
$$\frac{\forall i,\ \Gamma \vdash \text{ResolveType}(t_i) \Downarrow t_i'}{\Gamma \vdash \text{ResolveType}(C(t_1,\ldots,t_n)) \Downarrow C(t_1',\ldots,t_n')}$$

**(ResolveParam)**
$$\frac{\Gamma \vdash \text{ResolveType}(p.\text{type}) \Downarrow ty'}{\Gamma \vdash \text{ResolveParam}(p) \Downarrow p[\text{type}=ty']}$$

**(ResolveParams-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveParams}([]) \Downarrow []}$$

**(ResolveParams-Cons)**
$$\frac{\Gamma \vdash \text{ResolveParam}(p) \Downarrow p' \quad \Gamma \vdash \text{ResolveParams}(ps) \Downarrow ps'}{\Gamma \vdash \text{ResolveParams}(p::ps) \Downarrow p'::ps'}$$

$$\text{ResolvePattern} : \text{Pattern} \rightharpoonup \text{Pattern}$$

**(ResolvePat-Wild)**
$$\frac{}{\Gamma \vdash \text{ResolvePattern}(\text{WildcardPattern}) \Downarrow \text{WildcardPattern}}$$

**(ResolvePat-Ident)**
$$\frac{}{\Gamma \vdash \text{ResolvePattern}(\text{IdentifierPattern}(x)) \Downarrow \text{IdentifierPattern}(x)}$$

**(ResolvePat-Literal)**
$$\frac{}{\Gamma \vdash \text{ResolvePattern}(\text{LiteralPattern}(lit)) \Downarrow \text{LiteralPattern}(lit)}$$

**(ResolvePat-Typed)**
$$\frac{\Gamma \vdash \text{ResolveType}(ty) \Downarrow ty'}{\Gamma \vdash \text{ResolvePattern}(\text{TypedPattern}(x, ty)) \Downarrow \text{TypedPattern}(x, ty')}$$

**(ResolvePat-Tuple)**
$$\frac{\Gamma \vdash \text{ResolvePatternList}(ps) \Downarrow ps'}{\Gamma \vdash \text{ResolvePattern}(\text{TuplePattern}(ps)) \Downarrow \text{TuplePattern}(ps')}$$

**(ResolvePat-Record)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(tp) \Downarrow tp' \quad \Gamma \vdash \text{ResolveFieldPatternList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolvePattern}(\text{RecordPattern}(tp, fs)) \Downarrow \text{RecordPattern}(tp', fs')}$$

**(ResolvePat-Enum-Record-Fallback)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(tp) \Downarrow tp_e \quad \text{EnumDecl}(tp_e) \uparrow \quad \Gamma \vdash \text{ResolveTypePath}(tp \mathbin{+\!\!+} [name]) \Downarrow tp_r \quad \Gamma \vdash \text{ResolveFieldPatternList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolvePattern}(\text{EnumPattern}(tp, name, \text{RecordPayloadPattern}(fs))) \Downarrow \text{RecordPattern}(tp_r, fs')}$$

**(ResolvePat-Enum)**
$$\frac{\Gamma \vdash \text{ResolveTypePath}(tp) \Downarrow tp' \quad \Gamma \vdash \text{ResolveEnumPayloadPattern}(payload\_opt) \Downarrow payload\_opt'}{\Gamma \vdash \text{ResolvePattern}(\text{EnumPattern}(tp, name, payload\_opt)) \Downarrow \text{EnumPattern}(tp', name, payload\_opt')}$$

**(ResolvePat-Modal)**
$$\frac{\Gamma \vdash \text{ResolveFieldPatternListOpt}(fields\_opt) \Downarrow fields\_opt'}{\Gamma \vdash \text{ResolvePattern}(\text{ModalPattern}(state, fields\_opt)) \Downarrow \text{ModalPattern}(state, fields\_opt')}$$

**(ResolvePat-Range)**
$$\frac{\Gamma \vdash \text{ResolvePattern}(p_l) \Downarrow p_l' \quad \Gamma \vdash \text{ResolvePattern}(p_h) \Downarrow p_h'}{\Gamma \vdash \text{ResolvePattern}(\text{RangePattern}(kind, p_l, p_h)) \Downarrow \text{RangePattern}(kind, p_l', p_h')}$$

**(ResolvePatternList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolvePatternList}([]) \Downarrow []}$$

**(ResolvePatternList-Cons)**
$$\frac{\Gamma \vdash \text{ResolvePattern}(p) \Downarrow p' \quad \Gamma \vdash \text{ResolvePatternList}(ps) \Downarrow ps'}{\Gamma \vdash \text{ResolvePatternList}(p::ps) \Downarrow p'::ps'}$$

**(ResolveFieldPattern-Implicit)**
$$\frac{}{\Gamma \vdash \text{ResolveFieldPattern}(\langle name, \bot, span \rangle) \Downarrow \langle name, \bot, span \rangle}$$

**(ResolveFieldPattern-Explicit)**
$$\frac{\Gamma \vdash \text{ResolvePattern}(p) \Downarrow p'}{\Gamma \vdash \text{ResolveFieldPattern}(\langle name, p, span \rangle) \Downarrow \langle name, p', span \rangle}$$

**(ResolveFieldPatternList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveFieldPatternList}([]) \Downarrow []}$$

**(ResolveFieldPatternList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveFieldPattern}(f) \Downarrow f' \quad \Gamma \vdash \text{ResolveFieldPatternList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolveFieldPatternList}(f::fs) \Downarrow f'::fs'}$$

**(ResolveEnumPayloadPattern-None)**
$$\frac{}{\Gamma \vdash \text{ResolveEnumPayloadPattern}(\bot) \Downarrow \bot}$$

**(ResolveEnumPayloadPattern-Tuple)**
$$\frac{\Gamma \vdash \text{ResolvePatternList}(ps) \Downarrow ps'}{\Gamma \vdash \text{ResolveEnumPayloadPattern}(\text{TuplePayloadPattern}(ps)) \Downarrow \text{TuplePayloadPattern}(ps')}$$

**(ResolveEnumPayloadPattern-Record)**
$$\frac{\Gamma \vdash \text{ResolveFieldPatternList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolveEnumPayloadPattern}(\text{RecordPayloadPattern}(fs)) \Downarrow \text{RecordPayloadPattern}(fs')}$$

**(ResolveFieldPatternListOpt-None)**
$$\frac{}{\Gamma \vdash \text{ResolveFieldPatternListOpt}(\bot) \Downarrow \bot}$$

**(ResolveFieldPatternListOpt-Some)**
$$\frac{\Gamma \vdash \text{ResolveFieldPatternList}(fs) \Downarrow fs'}{\Gamma \vdash \text{ResolveFieldPatternListOpt}(fs) \Downarrow fs'}$$

**(ResolveExpr-Ident)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent}{\Gamma \vdash \text{ResolveExpr}(\text{Identifier}(x)) \Downarrow \text{Identifier}(x)}$$

**(ResolveExpr-Ident-Err)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad c = \text{Code}(\text{ResolveExpr-Ident-Err})}{\Gamma \vdash \text{ResolveExpr}(\text{Identifier}(x)) \Uparrow c}$$

**(ResolveExpr-Qualified)**
$$\frac{\Gamma \vdash \text{ResolveQualifiedForm}(e) \Downarrow e'}{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'}$$

$$\text{ResolveArgsRef} = \{\texttt{"5.1.6"}\}$$
$$\text{ResolveFieldInitsRef} = \{\texttt{"5.1.6"}\}$$

$$\text{ResolveExprListJudg} = \{\text{ResolveExprList}\}$$

**(ResolveExprList-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveExprList}([]) \Downarrow []}$$

**(ResolveExprList-Cons)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e' \quad \Gamma \vdash \text{ResolveExprList}(es) \Downarrow es'}{\Gamma \vdash \text{ResolveExprList}(e::es) \Downarrow e'::es'}$$

$$\text{ResolveEnumPayloadJudg} = \{\text{ResolveEnumPayload}\}$$

**(ResolveEnumPayload-None)**
$$\frac{}{\Gamma \vdash \text{ResolveEnumPayload}(\bot) \Downarrow \bot}$$

**(ResolveEnumPayload-Tuple)**
$$\frac{\Gamma \vdash \text{ResolveExprList}(es) \Downarrow es'}{\Gamma \vdash \text{ResolveEnumPayload}(\text{Paren}(es)) \Downarrow \text{Paren}(es')}$$

**(ResolveEnumPayload-Record)**
$$\frac{\Gamma \vdash \text{ResolveFieldInits}(fields) \Downarrow fields'}{\Gamma \vdash \text{ResolveEnumPayload}(\text{Brace}(fields)) \Downarrow \text{Brace}(fields')}$$

$$\text{ResolveCalleeJudg} = \{\text{ResolveCallee}\}$$

**(ResolveCallee-Ident-Value)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent}{\Gamma \vdash \text{ResolveCallee}(\text{Identifier}(x), args) \Downarrow \text{Identifier}(x)}$$

**(ResolveCallee-Ident-Record)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad args = [] \quad \Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = p \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{RecordDecl}(\text{FullPath}(\text{PathOfModule}(p), name)) = R}{\Gamma \vdash \text{ResolveCallee}(\text{Identifier}(x), args) \Downarrow \text{Identifier}(x)}$$

**(ResolveCallee-Path-Value)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent}{\Gamma \vdash \text{ResolveCallee}(\text{Path}(path,name), args) \Downarrow \text{Path}(path,name)}$$

**(ResolveCallee-Path-Record)**
$$\frac{\Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad args = []}{\Gamma \vdash \text{ResolveCallee}(\text{Path}(path,name), args) \Downarrow \text{Path}(path,name)}$$

**(ResolveCallee-Other)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(callee) \Downarrow callee'}{\Gamma \vdash \text{ResolveCallee}(callee, args) \Downarrow callee'}$$

**(ResolveExpr-Call)**
$$\frac{\Gamma \vdash \text{ResolveArgs}(args) \Downarrow args' \quad \Gamma \vdash \text{ResolveCallee}(callee, args') \Downarrow callee'}{\Gamma \vdash \text{ResolveExpr}(\text{Call}(callee, args)) \Downarrow \text{Call}(callee', args')}$$

**(ResolveExpr-RecordExpr)**
$$\frac{\Gamma \vdash \text{ResolveTypeRef}(tr) \Downarrow tr' \quad \Gamma \vdash \text{ResolveFieldInits}(fields) \Downarrow fields'}{\Gamma \vdash \text{ResolveExpr}(\text{RecordExpr}(tr, fields)) \Downarrow \text{RecordExpr}(tr', fields')}$$

**(ResolveExpr-EnumLiteral)**
$$\frac{\Gamma \vdash \text{ResolveEnumPayload}(payload\_opt) \Downarrow payload\_opt'}{\Gamma \vdash \text{ResolveExpr}(\text{EnumLiteral}(path, payload\_opt)) \Downarrow \text{EnumLiteral}(path, payload\_opt')}$$

$$\text{ResolveArmJudg} = \{\text{ResolveArm},\ \text{ResolveArms}\}$$

**(ResolveArm)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0 \vdash \text{ResolvePattern}(p) \Downarrow p' \quad \Gamma_0 \vdash \text{BindPattern}(p') \Downarrow \Gamma_1 \quad \Gamma_1 \vdash \text{ResolveExprOpt}(g) \Downarrow g' \quad \Gamma_1 \vdash \text{ResolveExpr}(b) \Downarrow b'}{\Gamma \vdash \text{ResolveArm}(\langle p, g, b \rangle) \Downarrow \langle p', g', b' \rangle}$$

**(ResolveArms-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveArms}([]) \Downarrow []}$$

**(ResolveArms-Cons)**
$$\frac{\Gamma \vdash \text{ResolveArm}(a) \Downarrow a' \quad \Gamma \vdash \text{ResolveArms}(as) \Downarrow as'}{\Gamma \vdash \text{ResolveArms}(a::as) \Downarrow a'::as'}$$

**(ResolveExpr-Match)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(scrutinee) \Downarrow scrutinee' \quad \Gamma \vdash \text{ResolveArms}(arms) \Downarrow arms'}{\Gamma \vdash \text{ResolveExpr}(\text{MatchExpr}(scrutinee, arms)) \Downarrow \text{MatchExpr}(scrutinee', arms')}$$

**(ResolveExpr-LoopIter)**
$$\frac{\Gamma \vdash \text{ResolvePattern}(pat) \Downarrow pat' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt' \quad \Gamma \vdash \text{ResolveExpr}(iter) \Downarrow iter' \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0 \vdash \text{BindPattern}(pat') \Downarrow \Gamma_1 \quad \Gamma_1 \vdash \text{ResolveExpr}(body) \Downarrow body'}{\Gamma \vdash \text{ResolveExpr}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \text{LoopIter}(pat', ty\_opt', iter', body')}$$

**(ResolveExpr-Alloc-Explicit-ByAlias)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(r) \Downarrow ent \quad \text{RegionAlias}(ent) \quad \Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'}{\Gamma \vdash \text{ResolveExpr}(\text{Binary}(\texttt{"^"}, \text{Identifier}(r), e)) \Downarrow \text{AllocExpr}(r, e')}$$

$$\text{ResolveExprRules} = \{\text{ResolveExpr-Ident},\ \text{ResolveExpr-Qualified},\ \text{ResolveExpr-Call},\ \text{ResolveExpr-RecordExpr},\ \text{ResolveExpr-EnumLiteral},\ \text{ResolveExpr-Match},\ \text{ResolveExpr-LoopIter},\ \text{ResolveExpr-Alloc-Explicit-ByAlias},\ \text{ResolveExpr-Hom},\ \text{ResolveExpr-Alloc-Implicit},\ \text{ResolveExpr-Alloc-Explicit},\ \text{ResolveExpr-Block}\}$$

$$\text{NoSpecificResolveExpr}(e) \iff \neg \exists r \in \text{ResolveExprRules} \setminus \{\text{ResolveExpr-Hom}\}.\ \text{PremisesHold}(r, e)$$

**(ResolveExpr-Hom)**
$$\frac{\text{NoSpecificResolveExpr}(C(e_1,\ldots,e_n)) \quad \forall i,\ \Gamma \vdash \text{ResolveExpr}(e_i) \Downarrow e_i'}{\Gamma \vdash \text{ResolveExpr}(C(e_1,\ldots,e_n)) \Downarrow C(e_1',\ldots,e_n')}$$

**(ResolveExpr-Alloc-Implicit)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'}{\Gamma \vdash \text{ResolveExpr}(\text{AllocExpr}(\bot, e)) \Downarrow \text{AllocExpr}(\bot, e')}$$

**(ResolveExpr-Alloc-Explicit)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(r) \Downarrow ent \quad \Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'}{\Gamma \vdash \text{ResolveExpr}(\text{AllocExpr}(r, e)) \Downarrow \text{AllocExpr}(r, e')}$$

$$\text{ResolveStmtSeqJudg} = \{\text{ResolveStmtSeq}\}$$

**(ResolveStmtSeq-Empty)**
$$\frac{}{\Gamma \vdash \text{ResolveStmtSeq}([]) \Downarrow (\Gamma, [])}$$

**(ResolveStmtSeq-Cons)**
$$\frac{\Gamma \vdash \text{ResolveStmt}(s) \Downarrow (\Gamma_1, s') \quad \Gamma_1 \vdash \text{ResolveStmtSeq}(ss) \Downarrow (\Gamma_2, ss')}{\Gamma \vdash \text{ResolveStmtSeq}(s::ss) \Downarrow (\Gamma_2, s'::ss')}$$

**(ResolveExpr-Block)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0 \vdash \text{ResolveStmtSeq}(stmts) \Downarrow (\Gamma_1, stmts') \quad (tail\_opt = \bot \Rightarrow tail\_opt' = \bot) \quad (tail\_opt = e \Rightarrow \Gamma_1 \vdash \text{ResolveExpr}(e) \Downarrow e' \land tail\_opt' = e')}{\Gamma \vdash \text{ResolveExpr}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \text{BlockExpr}(stmts', tail\_opt')}$$

**(BindNames-Empty)**
$$\frac{}{\Gamma \vdash \text{BindNames}([]) \Downarrow \Gamma}$$

**(BindNames-Cons)**
$$\frac{\Gamma \vdash \text{Intro}(x, \langle \text{Value}, \bot, \bot, \text{Decl} \rangle) \Downarrow \Gamma_1 \quad \Gamma_1 \vdash \text{BindNames}(xs) \Downarrow \Gamma_2}{\Gamma \vdash \text{BindNames}(x::xs) \Downarrow \Gamma_2}$$

**(BindPattern)**
$$\frac{\Gamma \vdash \text{PatNames}(p) \Downarrow ns \quad \Gamma \vdash \text{BindNames}(ns) \Downarrow \Gamma'}{\Gamma \vdash \text{BindPattern}(p) \Downarrow \Gamma'}$$

**(ResolveStmt-Let)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(init) \Downarrow init' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt' \quad \Gamma \vdash \text{ResolvePattern}(pat) \Downarrow pat' \quad \Gamma \vdash \text{BindPattern}(pat') \Downarrow \Gamma'}{\Gamma \vdash \text{ResolveStmt}(\text{LetStmt}(\langle pat, ty\_opt, op, init, span \rangle)) \Downarrow (\Gamma', \text{LetStmt}(\langle pat', ty\_opt', op, init', span \rangle))}$$

**(ResolveStmt-Var)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(init) \Downarrow init' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt' \quad \Gamma \vdash \text{ResolvePattern}(pat) \Downarrow pat' \quad \Gamma \vdash \text{BindPattern}(pat') \Downarrow \Gamma'}{\Gamma \vdash \text{ResolveStmt}(\text{VarStmt}(\langle pat, ty\_opt, op, init, span \rangle)) \Downarrow (\Gamma', \text{VarStmt}(\langle pat', ty\_opt', op, init', span \rangle))}$$

**(ResolveStmt-ShadowLet)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(init) \Downarrow init' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt' \quad \Gamma \vdash \text{ShadowIntro}(x, \langle \text{Value}, \bot, \bot, \text{Decl} \rangle) \Downarrow \Gamma'}{\Gamma \vdash \text{ResolveStmt}(\text{ShadowLetStmt}(x, ty\_opt, init)) \Downarrow (\Gamma', \text{ShadowLetStmt}(x, ty\_opt', init'))}$$

**(ResolveStmt-ShadowVar)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(init) \Downarrow init' \quad \Gamma \vdash \text{ResolveTypeOpt}(ty\_opt) \Downarrow ty\_opt' \quad \Gamma \vdash \text{ShadowIntro}(x, \langle \text{Value}, \bot, \bot, \text{Decl} \rangle) \Downarrow \Gamma'}{\Gamma \vdash \text{ResolveStmt}(\text{ShadowVarStmt}(x, ty\_opt, init)) \Downarrow (\Gamma', \text{ShadowVarStmt}(x, ty\_opt', init'))}$$

**(ResolveStmt-Defer)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(b) \Downarrow b'}{\Gamma \vdash \text{ResolveStmt}(\text{DeferStmt}(b)) \Downarrow (\Gamma, \text{DeferStmt}(b'))}$$

**(ResolveStmt-Frame-Implicit)**
$$\frac{\Gamma \vdash \text{ResolveExpr}(b) \Downarrow b'}{\Gamma \vdash \text{ResolveStmt}(\text{FrameStmt}(\bot, b)) \Downarrow (\Gamma, \text{FrameStmt}(\bot, b'))}$$

**(ResolveStmt-Frame-Explicit)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(r) \Downarrow ent \quad \Gamma \vdash \text{ResolveExpr}(b) \Downarrow b'}{\Gamma \vdash \text{ResolveStmt}(\text{FrameStmt}(r, b)) \Downarrow (\Gamma, \text{FrameStmt}(r, b'))}$$

**(ResolveStmt-Region)**
$$\frac{\Gamma \vdash \text{ResolveExprOpt}(opts\_opt) \Downarrow opts\_opt' \quad (alias\_opt = \bot \Rightarrow \Gamma_r = \Gamma) \quad (alias\_opt = r \Rightarrow \Gamma \vdash \text{Intro}(r, \langle \text{Value}, \bot, \bot, \text{RegionAlias} \rangle) \Downarrow \Gamma_r) \quad \Gamma_r \vdash \text{ResolveExpr}(b) \Downarrow b'}{\Gamma \vdash \text{ResolveStmt}(\text{RegionStmt}(opts\_opt, alias\_opt, b)) \Downarrow (\Gamma, \text{RegionStmt}(opts\_opt', alias\_opt, b'))}$$

$$\text{ResolveExprOpt}(\bot) = \bot$$
$$\text{ResolveExprOpt}(e) = e' \iff \Gamma \vdash \text{ResolveExpr}(e) \Downarrow e'$$

$$\text{ResState} = \{\text{ResStart}(M),\ \text{ResNames}(M,N),\ \text{ResItems}(M,N),\ \text{ResDone}(M'),\ \text{Error}(code)\}$$

**(Res-Start)**
$$\frac{}{\langle \text{ResStart}(M) \rangle \to \langle \text{ResNames}(M,\_) \rangle}$$

**(Res-Names)**
$$\frac{\Gamma \vdash \text{CollectNames}(M) \Downarrow N}{\langle \text{ResNames}(M,\_) \rangle \to \langle \text{ResItems}(M,N) \rangle}$$

**(Res-Items)**
$$\frac{\Gamma \vdash \text{ResolveModule}(M) \Downarrow M'}{\langle \text{ResItems}(M,N) \rangle \to \langle \text{ResDone}(M') \rangle}$$

**ResolveModules (Big-Step).**

**(ResolveModules-Ok)**
$$\frac{\Gamma \vdash \text{ParseModules}(P) \Downarrow [M_1,\ldots,M_k] \quad \forall i,\ \Gamma \vdash \text{ResolveModule}(M_i) \Downarrow M_i'}{\Gamma \vdash \text{ResolveModules}(P) \Downarrow [M_1',\ldots,M_k']}$$

**(ResolveModules-Err-Parse)**
$$\frac{\Gamma \vdash \text{ParseModules}(P) \Uparrow c}{\Gamma \vdash \text{ResolveModules}(P) \Uparrow c}$$

**(ResolveModules-Err-Resolve)**
$$\frac{\Gamma \vdash \text{ParseModules}(P) \Downarrow [M_1,\ldots,M_k] \quad \exists i.\ \Gamma \vdash \text{ResolveModule}(M_i) \Uparrow c}{\Gamma \vdash \text{ResolveModules}(P) \Uparrow c}$$

### 5.2. Type System Core (Cursive0)

#### 5.2.1. Type Equivalence

$$\text{TypeEqJudg} = \{\equiv\}$$
$$\text{ConstLenJudg} = \{\text{ConstLen}\}$$

**(ConstLen-Lit)**
$$\frac{e = \text{Literal}(lit) \quad lit.\text{kind} = \text{IntLiteral} \quad \text{InRange}(\text{IntValue}(lit), \texttt{"usize"}) \quad n = \text{IntValue}(lit)}{\Gamma \vdash \text{ConstLen}(e) \Downarrow n}$$

**(ConstLen-Path)**
$$\frac{e = \text{Path}(path, name) \quad \text{ValuePathType}(path, name) = T \quad \text{StaticDecl}(\_,\_,\langle \text{IdentPattern}(name),\_,\texttt{"="},init,\_ \rangle,\_,\_) \in \Gamma \quad \Gamma \vdash \text{ConstLen}(init) \Downarrow n}{\Gamma \vdash \text{ConstLen}(e) \Downarrow n}$$

**(ConstLen-Err)**
$$\frac{\neg \exists n.\ \Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad c = \text{Code}(\text{ConstLen-Err})}{\Gamma \vdash \text{ConstLen}(e) \Uparrow c}$$

$$\text{MembersEq}([T_1,\ldots,T_n],[U_1,\ldots,U_n]) \iff \exists U'.\ \text{Permutation}(U', [U_1,\ldots,U_n]) \land \forall i.\ 0 \le i < n \Rightarrow \Gamma \vdash T_i \equiv U'[i]$$

**(T-Equiv-Prim)**
$$\frac{T = \text{TypePrim}(n) \quad U = \text{TypePrim}(n)}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Perm)**
$$\frac{T = \text{TypePerm}(p, T_0) \quad U = \text{TypePerm}(p, U_0) \quad \Gamma \vdash T_0 \equiv U_0}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Tuple)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad U = \text{TypeTuple}([U_1,\ldots,U_n]) \quad \forall i,\ \Gamma \vdash T_i \equiv U_i}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Array)**
$$\frac{T = \text{TypeArray}(T_0, e_0) \quad U = \text{TypeArray}(U_0, e_1) \quad \Gamma \vdash \text{ConstLen}(e_0) \Downarrow n \quad \Gamma \vdash \text{ConstLen}(e_1) \Downarrow n \quad \Gamma \vdash T_0 \equiv U_0}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad U = \text{TypeSlice}(U_0) \quad \Gamma \vdash T_0 \equiv U_0}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Func)**
$$\frac{T = \text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad U = \text{TypeFunc}([\langle m_1, U_1 \rangle,\ldots,\langle m_n, U_n \rangle], S) \quad \forall i,\ \Gamma \vdash T_i \equiv U_i \quad \Gamma \vdash R \equiv S}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad U = \text{TypeUnion}([U_1,\ldots,U_n]) \quad \text{MembersEq}([T_1,\ldots,T_n],[U_1,\ldots,U_n])}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Path)**
$$\frac{T = \text{TypePath}(p) \quad U = \text{TypePath}(p)}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad U = \text{TypeModalState}(p, S)}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-String)**
$$\frac{T = \text{TypeString}(st) \quad U = \text{TypeString}(st)}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Bytes)**
$$\frac{T = \text{TypeBytes}(st) \quad U = \text{TypeBytes}(st)}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Range)**
$$\frac{T = \text{TypeRange} \quad U = \text{TypeRange}}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s) \quad U = \text{TypePtr}(U_0, s) \quad \Gamma \vdash T_0 \equiv U_0}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0) \quad U = \text{TypeRawPtr}(q, U_0) \quad \Gamma \vdash T_0 \equiv U_0}{\Gamma \vdash T \equiv U}$$

**(T-Equiv-Dynamic)**
$$\frac{T = \text{TypeDynamic}(p) \quad U = \text{TypeDynamic}(p)}{\Gamma \vdash T \equiv U}$$

#### 5.2.2. Subtyping

$$\text{SubtypingJudg} = \{<:\}$$

$$\forall T,U \in \text{IntTypes}.\ T \ne U \Rightarrow \neg(\Gamma \vdash T <: U)$$

$$\forall T,U \in \text{FloatTypes}.\ T \ne U \Rightarrow \neg(\Gamma \vdash T <: U)$$

$$\text{PermSubJudg} = \{\text{PermSub}\}$$

**(Perm-Const)**
$$\frac{}{\texttt{const} \;\text{PermSub}\; \texttt{const}}$$

**(Perm-Unique)**
$$\frac{}{\texttt{unique} \;\text{PermSub}\; \texttt{unique}}$$

**(Perm-Unique-Const)**
$$\frac{}{\texttt{unique} \;\text{PermSub}\; \texttt{const}}$$

**(Sub-Perm)**
$$\frac{T = \text{TypePerm}(p, T_0) \quad U = \text{TypePerm}(q, U_0) \quad \text{PermSub}(p, q) \quad \Gamma \vdash T_0 <: U_0}{\Gamma \vdash T <: U}$$

**(Sub-Never)**
$$\frac{T \in \mathcal{T}}{\Gamma \vdash \text{TypePrim}(\texttt{"!"}) <: T}$$

**(Sub-Tuple)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad U = \text{TypeTuple}([U_1,\ldots,U_n]) \quad \forall i,\ \Gamma \vdash T_i <: U_i}{\Gamma \vdash T <: U}$$

**(Sub-Array)**
$$\frac{T = \text{TypeArray}(T_0, e_0) \quad U = \text{TypeArray}(U_0, e_1) \quad \Gamma \vdash \text{ConstLen}(e_0) \Downarrow n \quad \Gamma \vdash \text{ConstLen}(e_1) \Downarrow n \quad \Gamma \vdash T_0 <: U_0}{\Gamma \vdash T <: U}$$

**(Sub-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad U = \text{TypeSlice}(U_0) \quad \Gamma \vdash T_0 <: U_0}{\Gamma \vdash T <: U}$$

**(Sub-Range)**
$$\frac{T = \text{TypeRange} \quad U = \text{TypeRange}}{\Gamma \vdash T <: U}$$

**(Sub-Ptr-State)**
$$\frac{s \in \{\texttt{Valid}, \texttt{Null}\}}{\Gamma \vdash \text{TypePtr}(T, s) <: \text{TypePtr}(T, \bot)}$$

**(Sub-Modal-Niche)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{NicheCompatible}(M,S)}{\Gamma \vdash \text{TypeModalState}(p, S) <: \text{TypePath}(p)}$$

**(Sub-Func)**
$$\frac{T = \text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad U = \text{TypeFunc}([\langle m_1, U_1 \rangle,\ldots,\langle m_n, U_n \rangle], S) \quad \forall i,\ \Gamma \vdash U_i <: T_i \quad \Gamma \vdash R <: S}{\Gamma \vdash T <: U}$$

$$\text{Member}(T,U) \iff U = \text{TypeUnion}([U_1,\ldots,U_n]) \land \exists i.\ \Gamma \vdash T \equiv U_i$$

**(Sub-Member-Union)**
$$\frac{\text{Member}(T, U)}{\Gamma \vdash T <: U}$$

**(Sub-Union-Width)**
$$\frac{U_1 = \text{TypeUnion}([T_1,\ldots,T_n]) \quad U_2 = \text{TypeUnion}([U_1',\ldots,U_m']) \quad \forall i,\ \text{Member}(T_i, U_2)}{\Gamma \vdash U_1 <: U_2}$$

$$\text{SubtypingRules} = \text{RulesIn}(\{\texttt{"5.2.2"},\ \texttt{"5.3.1"},\ \texttt{"5.7"},\ \texttt{"5.8"}\})$$

#### 5.2.3. Function Types

**(T-Proc-As-Value)**
$$\frac{\text{procedure } f(m_1\ x_1 : T_1, \ldots, m_n\ x_n : T_n) \to R\ \text{declared}}{\Gamma \vdash f : \text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R)}$$

$$\text{FuncTypeRules} = \text{RulesIn}(\{\texttt{"5.2.1"},\ \texttt{"5.2.2"}\})$$

#### 5.2.4. Procedure Calls

$$\text{ArgsOkTJudg} = \{\text{ArgsOk}_T\}$$
$$\text{ParamMode}(\langle mode,\ T\rangle) = mode$$
$$\text{ParamType}(\langle mode,\ T\rangle) = T$$
$$\text{ArgMoved}(\langle moved,\ e,\ span\rangle) = moved$$
$$\text{ArgExpr}(\langle moved,\ e,\ span\rangle) = e$$
$$\text{PlaceType}(p) = T \iff \Gamma; R; L \vdash p :place T$$
$$\text{ArgType}(a) =
\begin{cases}
\text{ExprType}(\text{MovedArg}(\text{ArgMoved}(a), \text{ArgExpr}(a))) & \text{if } \text{ArgMoved}(a) = \text{true} \
\text{PlaceType}(\text{ArgExpr}(a)) & \text{if } \text{ArgMoved}(a) = \text{false}
\end{cases}$$

**(ArgsT-Empty)**
$$\frac{}{\Gamma; R; L \vdash \text{ArgsOk}_T([], [])}$$

**(ArgsT-Cons)**
$$\frac{\Gamma; R; L \vdash \text{MovedArg}(moved, e) \Leftarrow T_p \dashv \emptyset \quad moved = \text{true} \quad \Gamma; R; L \vdash \text{ArgsOk}_T(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}_T([\langle \texttt{move}, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

**(ArgsT-Cons-Ref)**
$$\frac{\Gamma; R; L \vdash e \Leftarrow_{\text{place}} T_p \quad \text{AddrOfOk}(e) \quad moved = \text{false} \quad \Gamma; R; L \vdash \text{ArgsOk}_T(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}_T([\langle \bot, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

**(T-Call)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, R_c) \quad \Gamma; R; L \vdash \text{ArgsOk}_T(params, args)}{\Gamma; R; L \vdash \text{Call}(callee, args) : R_c}$$

**(Call-Callee-NotFunc)**
$$\frac{\Gamma; R; L \vdash callee : T \quad T \ne \text{TypeFunc}(\_,\_) \quad \neg(\text{RecordCallee}(callee) \land args = []) \quad c = \text{Code}(\text{Call-Callee-NotFunc})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

**(Call-ArgCount-Err)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, \_) \quad |\text{params}| \ne |\text{args}| \quad c = \text{Code}(\text{Call-ArgCount-Err})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

**(Call-ArgType-Err)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, \_) \quad \exists i.\ \neg(\Gamma; R; L \vdash \text{ArgType}(args[i]) <: \text{ParamType}(params[i])) \quad c = \text{Code}(\text{Call-ArgType-Err})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

**(Call-Move-Missing)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, \_) \quad \exists i.\ \text{ParamMode}(params[i]) = \texttt{move} \land \text{ArgMoved}(args[i]) = \text{false} \quad c = \text{Code}(\text{Call-Move-Missing})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

**(Call-Move-Unexpected)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, \_) \quad \exists i.\ \text{ParamMode}(params[i]) = \bot \land \text{ArgMoved}(args[i]) = \text{true} \quad c = \text{Code}(\text{Call-Move-Unexpected})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

**(Call-Arg-NotPlace)**
$$\frac{\Gamma; R; L \vdash callee : \text{TypeFunc}(params, \_) \quad \exists i.\ \text{ParamMode}(params[i]) = \bot \land \neg \text{IsPlace}(\text{ArgExpr}(args[i])) \quad c = \text{Code}(\text{Call-Arg-NotPlace})}{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}$$

#### 5.2.5. Tuples

**(T-Unit-Literal)**
$$\frac{}{\Gamma \vdash \text{TupleExpr}([]) : \text{TypePrim}(\texttt{"()"})}$$

**(T-Tuple-Literal)**
$$\frac{n \ge 1 \quad \forall i,\ \Gamma \vdash e_i : T_i}{\Gamma \vdash \text{TupleExpr}([e_1,\ldots,e_n]) : \text{TypeTuple}([T_1,\ldots,T_n])}$$

**(T-Tuple-Index)**
$$\frac{\Gamma \vdash e : \text{TypeTuple}([T_0,\ldots,T_{n-1}]) \quad 0 \le i < n \quad \text{BitcopyType}(T_i)}{\Gamma \vdash \text{TupleAccess}(e, i) : T_i}$$

**(T-Tuple-Index-Perm)**
$$\frac{\Gamma \vdash e : \text{TypePerm}(p, \text{TypeTuple}([T_0,\ldots,T_{n-1}])) \quad 0 \le i < n \quad \text{BitcopyType}(\text{TypePerm}(p, T_i))}{\Gamma \vdash \text{TupleAccess}(e, i) : \text{TypePerm}(p, T_i)}$$

**(P-Tuple-Index)**
$$\frac{\Gamma \vdash e :place \text{TypeTuple}([T_0,\ldots,T_{n-1}]) \quad 0 \le i < n}{\Gamma \vdash \text{TupleAccess}(e, i) :place T_i}$$

**(P-Tuple-Index-Perm)**
$$\frac{\Gamma \vdash e :place \text{TypePerm}(p, \text{TypeTuple}([T_0,\ldots,T_{n-1}])) \quad 0 \le i < n}{\Gamma \vdash \text{TupleAccess}(e, i) :place \text{TypePerm}(p, T_i)}$$

$$\text{ConstTupleIndex}(i) \iff \exists n \in \mathbb{Z}.\ i = n$$

**(TupleIndex-NonConst)**
$$\frac{\neg \text{ConstTupleIndex}(i) \quad c = \text{Code}(\text{TupleIndex-NonConst})}{\Gamma \vdash \text{TupleAccess}(e, i) \Uparrow c}$$

**(TupleIndex-OOB)**
$$\frac{\Gamma \vdash e : \text{TypeTuple}([T_0,\ldots,T_{n-1}]) \quad (i < 0 \ \lor\ i \ge n) \quad c = \text{Code}(\text{TupleIndex-OOB})}{\Gamma \vdash \text{TupleAccess}(e, i) \Uparrow c}$$

**(TupleAccess-NotTuple)**
$$\frac{\Gamma \vdash e : T \quad \text{StripPerm}(T) \ne \text{TypeTuple}(\_) \quad c = \text{Code}(\text{TupleAccess-NotTuple})}{\Gamma \vdash \text{TupleAccess}(e, i) \Uparrow c}$$

#### 5.2.6. Arrays and Slices

$$\text{ConstIndex}(e) \iff \exists n.\ \Gamma \vdash \text{ConstLen}(e) \Downarrow n$$

**(T-Array-Literal-List)**
$$\frac{\forall i,\ \Gamma \vdash e_i : T}{\Gamma \vdash \text{ArrayExpr}([e_1,\ldots,e_n]) : \text{TypeArray}(T, \text{Literal}(\text{IntLiteral}(n)))}$$

**(T-Index-Array)**
$$\frac{\Gamma \vdash e_1 : \text{TypeArray}(T, len) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad \text{ConstIndex}(e_2) \quad \Gamma \vdash \text{ConstLen}(e_2) \Downarrow i \quad \Gamma \vdash \text{ConstLen}(len) \Downarrow n \quad i < n \quad \text{BitcopyType}(T)}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : T}$$

**(T-Index-Array-Perm)**
$$\frac{\Gamma \vdash e_1 : \text{TypePerm}(p, \text{TypeArray}(T, len)) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad \text{ConstIndex}(e_2) \quad \Gamma \vdash \text{ConstLen}(e_2) \Downarrow i \quad \Gamma \vdash \text{ConstLen}(len) \Downarrow n \quad i < n \quad \text{BitcopyType}(\text{TypePerm}(p, T))}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : \text{TypePerm}(p, T)}$$

**(Index-Array-NonConst-Err)**
$$\frac{\Gamma \vdash e_1 : \text{TypeArray}(T, \_) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad \neg \text{ConstIndex}(e_2) \quad c = \text{Code}(\text{Index-Array-NonConst-Err})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

**(Index-Array-OOB-Err)**
$$\frac{\Gamma \vdash e_1 : \text{TypeArray}(T, len) \quad \text{ConstIndex}(e_2) \quad \Gamma \vdash \text{ConstLen}(e_2) \Downarrow i \quad \Gamma \vdash \text{ConstLen}(len) \Downarrow n \quad i \ge n \quad c = \text{Code}(\text{Index-Array-OOB-Err})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

**(Index-Slice-Direct-Err)**
$$\frac{\Gamma \vdash e_1 : \text{TypeSlice}(T) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad c = \text{Code}(\text{Index-Slice-Direct-Err})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

**(Index-Slice-Perm-Direct-Err)**
$$\frac{\Gamma \vdash e_1 : \text{TypePerm}(p, \text{TypeSlice}(T)) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad c = \text{Code}(\text{Index-Slice-Direct-Err})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

**(T-Slice-From-Array)**
$$\frac{\Gamma \vdash e_1 : \text{TypeArray}(T, n) \quad \Gamma; R; L \vdash e_2 : \text{Range} \quad \text{BitcopyType}(\text{TypeSlice}(T))}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : \text{TypeSlice}(T)}$$

**(T-Slice-From-Array-Perm)**
$$\frac{\Gamma \vdash e_1 : \text{TypePerm}(p, \text{TypeArray}(T, n)) \quad \Gamma; R; L \vdash e_2 : \text{Range} \quad \text{BitcopyType}(\text{TypePerm}(p, \text{TypeSlice}(T)))}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : \text{TypePerm}(p, \text{TypeSlice}(T))}$$

**(T-Slice-From-Slice)**
$$\frac{\Gamma \vdash e_1 : \text{TypeSlice}(T) \quad \Gamma; R; L \vdash e_2 : \text{Range} \quad \text{BitcopyType}(\text{TypeSlice}(T))}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : \text{TypeSlice}(T)}$$

**(T-Slice-From-Slice-Perm)**
$$\frac{\Gamma \vdash e_1 : \text{TypePerm}(p, \text{TypeSlice}(T)) \quad \Gamma; R; L \vdash e_2 : \text{Range} \quad \text{BitcopyType}(\text{TypePerm}(p, \text{TypeSlice}(T)))}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) : \text{TypePerm}(p, \text{TypeSlice}(T))}$$

**(P-Index-Array)**
$$\frac{\Gamma \vdash e_1 :place \text{TypeArray}(T, len) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad \text{ConstIndex}(e_2) \quad \Gamma \vdash \text{ConstLen}(e_2) \Downarrow i \quad \Gamma \vdash \text{ConstLen}(len) \Downarrow n \quad i < n}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place T}$$

**(P-Index-Array-Perm)**
$$\frac{\Gamma \vdash e_1 :place \text{TypePerm}(p, \text{TypeArray}(T, len)) \quad \Gamma \vdash e_2 : \text{TypePrim}(\texttt{"usize"}) \quad \text{ConstIndex}(e_2) \quad \Gamma \vdash \text{ConstLen}(e_2) \Downarrow i \quad \Gamma \vdash \text{ConstLen}(len) \Downarrow n \quad i < n}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place \text{TypePerm}(p, T)}$$

**(P-Slice-From-Array)**
$$\frac{\Gamma \vdash e_1 :place \text{TypeArray}(T, n) \quad \Gamma; R; L \vdash e_2 : \text{Range}}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place \text{TypeSlice}(T)}$$

**(P-Slice-From-Array-Perm)**
$$\frac{\Gamma \vdash e_1 :place \text{TypePerm}(p, \text{TypeArray}(T, n)) \quad \Gamma; R; L \vdash e_2 : \text{Range}}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place \text{TypePerm}(p, \text{TypeSlice}(T))}$$

**(P-Slice-From-Slice)**
$$\frac{\Gamma \vdash e_1 :place \text{TypeSlice}(T) \quad \Gamma; R; L \vdash e_2 : \text{Range}}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place \text{TypeSlice}(T)}$$

**(P-Slice-From-Slice-Perm)**
$$\frac{\Gamma \vdash e_1 :place \text{TypePerm}(p, \text{TypeSlice}(T)) \quad \Gamma; R; L \vdash e_2 : \text{Range}}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) :place \text{TypePerm}(p, \text{TypeSlice}(T))}$$

**(Coerce-Array-Slice)**
$$\frac{\Gamma \vdash e : \text{TypePerm}(p, \text{TypeArray}(T, n))}{\Gamma \vdash e : \text{TypePerm}(p, \text{TypeSlice}(T))}$$

**(Index-Array-NonUsize)**
$$\frac{\Gamma \vdash e_1 : \text{TypeArray}(T, \_) \quad \Gamma \vdash e_2 : T_i \quad T_i \ne \text{TypePrim}(\texttt{"usize"}) \quad c = \text{Code}(\text{Index-Array-NonUsize})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

**(Index-NonIndexable)**
$$\frac{\Gamma \vdash e_1 : T \quad \text{StripPerm}(T) \notin \{\text{TypeArray}(\_,\_), \text{TypeSlice}(\_)\} \quad c = \text{Code}(\text{Index-NonIndexable})}{\Gamma \vdash \text{IndexAccess}(e_1, e_2) \Uparrow c}$$

#### 5.2.7. Union Types

$$\text{Members}(\text{TypeUnion}([T_1,\ldots,T_n])) = [T_1,\ldots,T_n]$$
$$\text{DistinctMembers}(U) = [T_i \in \text{Members}(U) \mid \forall j < i.\ \neg(\Gamma \vdash T_i \equiv T_j)]$$
$$\text{SetMembers}(U) = \{ T \mid T \in \text{DistinctMembers}(U) \}$$

**(T-Union-Intro)**
$$\frac{\Gamma \vdash e : T \quad \text{Member}(T, U)}{\Gamma \vdash e : U}$$

**(Union-DirectAccess-Err)**
$$\frac{\Gamma; R; L \vdash e : U \quad \text{StripPerm}(U) = \text{TypeUnion}(\_) \quad c = \text{Code}(\text{Union-DirectAccess-Err})}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) \Uparrow c}$$

#### 5.2.8. Default Record Construction

$$\text{Fields}(R) = \text{Fields}_{\S 5.3.2}(R)$$

$$\text{InitOk}(f) \iff f = \text{FieldDecl}(vis, name, T_f, \text{init\_opt}, span, doc) \land \big(\text{init\_opt} = \bot\big) \lor \big(\text{init\_opt} = e \land \Gamma; \bot; \bot \vdash e : T \land \Gamma \vdash T <: T_f\big)$$

**(WF-Record)**
$$\frac{\forall f \in \text{Fields}(R),\ \text{InitOk}(f) \quad \forall f_i \ne f_j,\ f_i.\text{name} \ne f_j.\text{name}}{\Gamma \vdash R\ \text{record} \ \text{wf}}$$

**(WF-Record-DupField)**
$$\frac{\exists f_i \ne f_j.\ f_i.\text{name} = f_j.\text{name} \quad c = \text{Code}(\text{WF-Record-DupField})}{\Gamma \vdash R\ \text{record} \ \text{wf} \Uparrow c}$$

$$\text{DefaultConstructible}(R) \iff \forall f \in \text{Fields}(R).\ f.\text{init\_opt} \ne \bot$$
$$\text{RecordPath}(R) = \text{FullPath}(\text{ModuleOf}(R), R.\text{name})$$
$$\text{RecordCallee}(\text{callee}) = R \iff (\text{callee}=\text{Identifier}(\text{name}) \lor \text{callee}=\text{Path}(\text{path},\text{name})) \land \Gamma \vdash \text{ResolveTypeName}(\text{name}) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ \text{name}) \land \text{RecordDecl}(\text{FullPath}(\text{PathOfModule}(mp), name')) = R$$

**(T-Record-Default)**
$$\frac{\text{RecordCallee}(callee) = R \quad \Gamma \vdash R\ \text{record wf} \quad \text{DefaultConstructible}(R)}{\Gamma \vdash \text{Call}(callee, []) : \text{TypePath}(\text{RecordPath}(R))}$$

**(Record-Default-Init-Err)**
$$\frac{\text{RecordCallee}(callee) = R \quad \neg \text{DefaultConstructible}(R) \quad c = \text{Code}(\text{Record-Default-Init-Err})}{\Gamma \vdash \text{Call}(callee, []) \Uparrow c}$$

#### 5.2.9. Type Inference (Cursive0)

$$\text{TypeInfJudg} = \{\Rightarrow,\ \Leftarrow,\ \text{Solve}\}$$

$$\text{Constraint} = \text{Type} \times \text{Type}$$
$$\text{ConstraintSet} = \mathcal{P}(\text{Constraint})$$
$$\text{Solve}(C) \Downarrow \text{id} \iff C = \emptyset$$
$$\text{Solve}(C) \Uparrow \iff C \ne \emptyset$$
$$\forall \Gamma,R,L,e,T,C.\ \Gamma; R; L \vdash e \Rightarrow T \dashv C \Rightarrow C = \emptyset$$
$$\forall \Gamma,R,L,e,T,C.\ \Gamma; R; L \vdash e \Leftarrow T \dashv C \Rightarrow C = \emptyset$$

**(Syn-Expr)**
$$\frac{\Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash e \Rightarrow T \dashv \emptyset}$$

**(Syn-Ident)**
$$\frac{(x : T) \in \Gamma}{\Gamma; R; L \vdash \text{Identifier}(x) \Rightarrow T \dashv \emptyset}$$

**(Syn-Unit)**
$$\frac{}{\Gamma; R; L \vdash \text{TupleExpr}([]) \Rightarrow \text{TypePrim}(\texttt{"()"}) \dashv \emptyset}$$

**(Syn-Tuple)**
$$\frac{n \ge 1 \quad \forall i,\ \Gamma; R; L \vdash e_i \Rightarrow T_i \dashv C_i}{\Gamma; R; L \vdash \text{TupleExpr}([e_1,\ldots,e_n]) \Rightarrow \text{TypeTuple}([T_1,\ldots,T_n]) \dashv \bigcup_i C_i}$$

**(Syn-Call)**
$$\frac{\Gamma; R; L \vdash callee \Rightarrow \text{TypeFunc}(params, R_c) \dashv C_0 \quad \Gamma; R; L \vdash \text{ArgsOk}_T(params, args)}{\Gamma; R; L \vdash \text{Call}(callee, args) \Rightarrow R_c \dashv C_0}$$

**(Syn-Call-Err)**
$$\frac{\Gamma; R; L \vdash \text{Call}(callee, args) \Uparrow c}{\Gamma; R; L \vdash \text{Call}(callee, args) \Rightarrow T \dashv C \Uparrow c}$$

**(Chk-Subsumption-Modal-NonNiche)**
$$\frac{\Gamma; R; L \vdash e \Rightarrow S \dashv C \quad \text{StripPerm}(S) = \text{TypeModalState}(p, S_s) \quad \text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \neg \text{NicheCompatible}(M, S_s) \quad c = \text{Code}(\text{Chk-Subsumption-Modal-NonNiche})}{\Gamma; R; L \vdash e \Leftarrow T \Uparrow c}$$

**(Chk-Subsumption)**
$$\frac{\Gamma; R; L \vdash e \Rightarrow S \dashv C \quad \Gamma \vdash S <: T}{\Gamma; R; L \vdash e \Leftarrow T \dashv C}$$

**(Chk-Null-Ptr)**
$$\frac{T = \text{TypePtr}(U, s) \quad s \in \{\texttt{Null}, \bot\}}{\Gamma; R; L \vdash \text{PtrNullExpr} \Leftarrow T \dashv \emptyset}$$

$$\text{PtrNullExpected}(T) \iff T = \text{TypePtr}(U, s) \land s \in \{\texttt{Null}, \bot\}$$

**(Syn-PtrNull-Err)**
$$\frac{c = \text{Code}(\text{PtrNull-Infer-Err})}{\Gamma; R; L \vdash \text{PtrNullExpr} \Rightarrow T \dashv C \Uparrow c}$$

**(Chk-PtrNull-Err)**
$$\frac{\neg \text{PtrNullExpected}(T) \quad c = \text{Code}(\text{PtrNull-Infer-Err})}{\Gamma; R; L \vdash \text{PtrNullExpr} \Leftarrow T \dashv C \Uparrow c}$$

#### 5.2.10. Literal Expressions (Cursive0)

$$\text{IntTypes} = \{\texttt{i8},\texttt{i16},\texttt{i32},\texttt{i64},\texttt{i128},\texttt{u8},\texttt{u16},\texttt{u32},\texttt{u64},\texttt{u128},\texttt{isize},\texttt{usize}\}$$
$$\text{FloatTypes} = \{\texttt{f16},\texttt{f32},\texttt{f64}\}$$
$$\text{FloatFormat}(\texttt{"f16"}) = \texttt{binary16} \quad \text{FloatFormat}(\texttt{"f32"}) = \texttt{binary32} \quad \text{FloatFormat}(\texttt{"f64"}) = \texttt{binary64}$$
$$\text{FloatBitWidth}(\texttt{"f16"}) = 16 \quad \text{FloatBitWidth}(\texttt{"f32"}) = 32 \quad \text{FloatBitWidth}(\texttt{"f64"}) = 64$$
$$\text{FloatValueSet}(t) = \{ v \mid v\ \text{is a value representable by IEEE 754-2019 format}\ \text{FloatFormat}(t) \}$$
$$\text{IEEE754Encode}(t, v) = bits \iff v \in \text{FloatValueSet}(t)\ \land\ bits \in [0, 2^{\text{FloatBitWidth}(t)}{-}1]\ \land\ ((v\ \text{is NaN in IEEE 754-2019 format}\ \text{FloatFormat}(t) \land bits=\text{CanonicalNaNBits}(t)) \lor (v\ \text{is not NaN in IEEE 754-2019 format}\ \text{FloatFormat}(t) \land bits\ \text{is the IEEE 754-2019 encoding of}\ v\ \text{in format}\ \text{FloatFormat}(t)))$$
$$\text{CanonicalNaNBits}(\texttt{"f16"}) = 0x7E00 \quad \text{CanonicalNaNBits}(\texttt{"f32"}) = 0x7FC00000 \quad \text{CanonicalNaNBits}(\texttt{"f64"}) = 0x7FF8000000000000$$
$$\text{CanonicalNaN}(t) = v \iff \text{IEEE754Encode}(t, v) = \text{CanonicalNaNBits}(t)$$
$$\text{NonNaNValueSet}(t) = \{ v \in \text{FloatValueSet}(t) \mid \text{IEEE754Encode}(t, v) \ne \text{CanonicalNaNBits}(t) \}$$
$$\text{LSB}(n) = n \bmod 2$$
$$\text{EvenSignificandLSB}(t, v) \iff \text{LSB}(\text{IEEE754Encode}(t, v)) = 0$$
$$\text{DefaultInt} = \texttt{i32}$$
$$\text{DefaultFloat} = \texttt{f64}$$
$$\text{IntValue} : \text{Token} \rightharpoonup \mathbb{Z} \quad \text{FloatValue} : \text{Token} \rightharpoonup \mathbb{R}$$
$$\text{IntSuffix} : \text{Token} \rightharpoonup \text{IntTypes} \quad \text{FloatSuffix} : \text{Token} \rightharpoonup \text{FloatTypes}$$
$$\text{IntCore}(s) \iff s\ \text{matches}\ (\texttt{decimal\_integer} \mid \texttt{hex\_integer} \mid \texttt{octal\_integer} \mid \texttt{binary\_integer})$$
$$\text{FloatCore}(s) \iff s\ \text{matches}\ \texttt{float\_literal}$$
$$\text{StripIntSuffix}(s) = \langle core, t \rangle \iff s = core \mathbin{+\!\!+} t \land t \in \text{IntSuffixSet} \land \text{IntCore}(core)$$
$$\text{StripIntSuffix}(s) = \langle s, \bot \rangle \iff \neg \exists t.\ s = core \mathbin{+\!\!+} t \land t \in \text{IntSuffixSet} \land \text{IntCore}(core)$$
$$\text{StripFloatSuffix}(s) = \langle core, t \rangle \iff s = core \mathbin{+\!\!+} t \land t \in \text{FloatSuffixSet} \land \text{FloatCore}(core)$$
$$\text{StripFloatSuffix}(s) = \langle s, \bot \rangle \iff \neg \exists t.\ s = core \mathbin{+\!\!+} t \land t \in \text{FloatSuffixSet} \land \text{FloatCore}(core)$$
$$\text{IntSuffix}(lit) = t \iff lit.\text{kind}=\text{IntLiteral} \land \text{StripIntSuffix}(\text{Lexeme}(lit)) = \langle \_, t \rangle$$
$$\text{FloatSuffix}(lit) = t \iff lit.\text{kind}=\text{FloatLiteral} \land \text{StripFloatSuffix}(\text{Lexeme}(lit)) = \langle \_, t \rangle$$
$$\text{IntValueCore}(s) = v \iff (s=\texttt{"0x"} \mathbin{+\!\!+} h \land v=\text{HexValue}(\text{Digits}(h))) \lor (s=\texttt{"0o"} \mathbin{+\!\!+} o \land v=\text{OctValue}(\text{Digits}(o))) \lor (s=\texttt{"0b"} \mathbin{+\!\!+} b \land v=\text{BinValue}(\text{Digits}(b))) \lor (s\ \text{matches}\ \texttt{decimal\_integer} \land v=\text{DecValue}(\text{Digits}(s)))$$
$$\text{IntValue}(lit) = v \iff lit.\text{kind}=\text{IntLiteral} \land \text{StripIntSuffix}(\text{Lexeme}(lit)) = \langle core,\_ \rangle \land \text{IntValueCore}(core) = v$$
$$\text{FloatParts}(s) = \langle a,b,e \rangle \iff s = a \mathbin{+\!\!+} \texttt{"."} \mathbin{+\!\!+} b \mathbin{+\!\!+} exp \land (exp=\texttt{"\""} \Rightarrow e=0) \land (exp \ne \texttt{"\""} \Rightarrow exp=\texttt{"e"} \mathbin{+\!\!+} sign \mathbin{+\!\!+} d \lor exp=\texttt{"E"} \mathbin{+\!\!+} sign \mathbin{+\!\!+} d) \land (sign=\texttt{"\""} \Rightarrow e=\text{DecValue}(\text{Digits}(d))) \land (sign=\texttt{"+"} \Rightarrow e=\text{DecValue}(\text{Digits}(d))) \land (sign=\texttt{"-"} \Rightarrow e=-\text{DecValue}(\text{Digits}(d)))$$
$$\text{FloatValueCore}(s) = v \iff \text{FloatParts}(s) = \langle a,b,e \rangle \land v = (\text{DecValue}(\text{Digits}(a)) \cdot 10^{|\text{Digits}(b)|} + \text{DecValue}(\text{Digits}(b))) \cdot 10^{e-|\text{Digits}(b)|}$$
$$\text{FloatValue}(lit) = v \iff lit.\text{kind}=\text{FloatLiteral} \land \text{StripFloatSuffix}(\text{Lexeme}(lit)) = \langle core,\_ \rangle \land \text{FloatValueCore}(core) = v$$
$$\text{InRange}(v, T) \iff v \in \text{RangeOf}(T)$$
$$\text{RangeOf} : \text{TypePrimName} \to \mathcal{P}(\mathbb{R})$$
$$\text{RangeOf}(t) = [-2^{w-1},\ 2^{w-1}-1]\ \text{if}\ t \in \text{SignedIntTypes}\ \land\ w=\text{IntWidth}(t)$$
$$\text{RangeOf}(t) = [0,\ 2^{w}-1]\ \text{if}\ t \in \text{UnsignedIntTypes}\ \land\ w=\text{IntWidth}(t)$$
$$\text{RangeOf}(t)\ \text{undefined otherwise}$$

**(T-Int-Literal-Suffix)**
$$\frac{lit.\text{kind} = \text{IntLiteral} \quad \text{IntSuffix}(lit) = t \quad \text{InRange}(\text{IntValue}(lit), t)}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(t)}$$

**(T-Int-Literal-Default)**
$$\frac{lit.\text{kind} = \text{IntLiteral} \quad \text{IntSuffix}(lit) = \bot \quad \text{InRange}(\text{IntValue}(lit), \texttt{i32})}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(\texttt{"i32"})}$$

**(T-Float-Literal-Suffix)**
$$\frac{lit.\text{kind} = \text{FloatLiteral} \quad \text{FloatSuffix}(lit) = t}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(t)}$$

**(T-Float-Literal-Default)**
$$\frac{lit.\text{kind} = \text{FloatLiteral} \quad \text{FloatSuffix}(lit) = \bot}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(\texttt{"f64"})}$$

**(T-Bool-Literal)**
$$\frac{lit.\text{kind} = \text{BoolLiteral}}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(\texttt{"bool"})}$$

**(T-Char-Literal)**
$$\frac{lit.\text{kind} = \text{CharLiteral}}{\Gamma \vdash \text{Literal}(lit) : \text{TypePrim}(\texttt{"char"})}$$

**(T-String-Literal)**
$$\frac{lit.\text{kind} = \text{StringLiteral}}{\Gamma \vdash \text{Literal}(lit) : \text{TypeString}(\texttt{@View})}$$

**(Syn-Literal)**
$$\frac{\Gamma \vdash \text{Literal}(lit) : T}{\Gamma; R; L \vdash \text{Literal}(lit) \Rightarrow T \dashv \emptyset}$$

$$\text{NullLiteralExpected}(T) \iff T = \text{TypeRawPtr}(q, U)$$

**(Chk-Int-Literal)**
$$\frac{lit.\text{kind} = \text{IntLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad \text{InRange}(\text{IntValue}(lit), t)}{\Gamma; R; L \vdash \text{Literal}(lit) \Leftarrow T \dashv \emptyset}$$

**(Chk-Float-Literal)**
$$\frac{lit.\text{kind} = \text{FloatLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{FloatTypes}}{\Gamma; R; L \vdash \text{Literal}(lit) \Leftarrow T \dashv \emptyset}$$

**(Chk-Null-Literal)**
$$\frac{lit.\text{kind} = \text{NullLiteral} \quad T = \text{TypeRawPtr}(q, U)}{\Gamma; R; L \vdash \text{Literal}(lit) \Leftarrow T \dashv \emptyset}$$

**(Syn-Null-Literal-Err)**
$$\frac{lit.\text{kind} = \text{NullLiteral} \quad c = \text{Code}(\text{NullLiteral-Infer-Err})}{\Gamma; R; L \vdash \text{Literal}(lit) \Rightarrow T \dashv C \Uparrow c}$$

**(Chk-Null-Literal-Err)**
$$\frac{lit.\text{kind} = \text{NullLiteral} \quad \neg \text{NullLiteralExpected}(T) \quad c = \text{Code}(\text{NullLiteral-Infer-Err})}{\Gamma; R; L \vdash \text{Literal}(lit) \Leftarrow T \dashv C \Uparrow c}$$

#### 5.2.11. Statement Typing (Cursive0)

$$\text{MutKind} = \{\texttt{let}, \texttt{var}\}$$
$$\text{Bind} = \{\langle \text{mut}, T \rangle \mid \text{mut} \in \text{MutKind} \land T \in \text{Type}\}$$
$$\text{BindOf}(\Gamma, x) = \langle \text{mut}, T \rangle \iff \langle \text{mut}, T \rangle\ \text{is the binding for}\ x\ \text{in the nearest scope of}\ \text{Scopes}(\Gamma)$$
$$(\,x : T\,) \in \Gamma \iff \exists \text{mut}.\ \text{BindOf}(\Gamma, x) = \langle \text{mut}, T \rangle$$
$$\text{MutOf}(\Gamma, x) = \text{mut} \iff \text{BindOf}(\Gamma, x) = \langle \text{mut}, T \rangle$$

$$\text{StmtJudg} = \{\Gamma; R; L \vdash s \Rightarrow \Gamma' \triangleright \langle Res, Brk, BrkVoid \rangle,\ \Gamma; R; L \vdash ss \Rightarrow \Gamma' \triangleright \langle Res, Brk, BrkVoid \rangle,$$
$$\Gamma; R; L \vdash e : T,\ \Gamma; R; L \vdash b : T,\ \Gamma; R; L \vdash \text{BlockInfo}(b) \Downarrow \langle T, Brk, BrkVoid \rangle,\ \Gamma \vdash pat \Leftarrow T \dashv B\}$$

$$\text{LoopFlag} = \{\bot, \texttt{loop}\}$$

$$\text{PushScope}(\Gamma) = \Gamma' \iff \text{Scopes}(\Gamma') = [\emptyset] \mathbin{+\!\!+} \text{Scopes}(\Gamma) \land \text{Project}(\Gamma') = \text{Project}(\Gamma) \land \text{ResCtx}(\Gamma') = \text{ResCtx}(\Gamma)$$
$$\text{PopScope}(\Gamma') = \Gamma \iff \text{Scopes}(\Gamma') = [\_] \mathbin{+\!\!+} \text{Scopes}(\Gamma) \land \text{Project}(\Gamma') = \text{Project}(\Gamma) \land \text{ResCtx}(\Gamma') = \text{ResCtx}(\Gamma)$$

$$\text{IntroEnt} = \langle Value, \bot, \bot, Decl \rangle$$

**(IntroAll-Empty)**
$$\frac{}{\text{IntroAll}(\Gamma, []) \Downarrow \Gamma}$$

**(IntroAll-Cons)**
$$\frac{\Gamma \vdash \text{Intro}(x, \text{IntroEnt}) \Downarrow \Gamma_1 \quad \text{IntroAll}(\Gamma_1 \cup \{x \mapsto \langle \texttt{let}, T \rangle\}, rest) \Downarrow \Gamma_2}{\text{IntroAll}(\Gamma, [(x, T)] \mathbin{+\!\!+} rest) \Downarrow \Gamma_2}$$

**(IntroAllVar-Empty)**
$$\frac{}{\text{IntroAllVar}(\Gamma, []) \Downarrow \Gamma}$$

**(IntroAllVar-Cons)**
$$\frac{\Gamma \vdash \text{Intro}(x, \text{IntroEnt}) \Downarrow \Gamma_1 \quad \text{IntroAllVar}(\Gamma_1 \cup \{x \mapsto \langle \texttt{var}, T \rangle\}, rest) \Downarrow \Gamma_2}{\text{IntroAllVar}(\Gamma, [(x, T)] \mathbin{+\!\!+} rest) \Downarrow \Gamma_2}$$

**(ShadowAll-Empty)**
$$\frac{}{\text{ShadowAll}(\Gamma, []) \Downarrow \Gamma}$$

**(ShadowAll-Cons)**
$$\frac{\Gamma \vdash \text{ShadowIntro}(x, \text{IntroEnt}) \Downarrow \Gamma_1 \quad \text{ShadowAll}(\Gamma_1 \cup \{x \mapsto \langle \texttt{let}, T \rangle\}, rest) \Downarrow \Gamma_2}{\text{ShadowAll}(\Gamma, [(x, T)] \mathbin{+\!\!+} rest) \Downarrow \Gamma_2}$$

**(ShadowAllVar-Empty)**
$$\frac{}{\text{ShadowAllVar}(\Gamma, []) \Downarrow \Gamma}$$

**(ShadowAllVar-Cons)**
$$\frac{\Gamma \vdash \text{ShadowIntro}(x, \text{IntroEnt}) \Downarrow \Gamma_1 \quad \text{ShadowAllVar}(\Gamma_1 \cup \{x \mapsto \langle \texttt{var}, T \rangle\}, rest) \Downarrow \Gamma_2}{\text{ShadowAllVar}(\Gamma, [(x, T)] \mathbin{+\!\!+} rest) \Downarrow \Gamma_2}$$

$$\text{ResType}([T_1,\ldots,T_n]) = T \iff n \ge 1 \land \forall i.\ \Gamma \vdash T_i \equiv T$$
$$\text{ResType}([]) = \bot$$

$$\text{LoopTypeInf}(Brk, BrkVoid) = \begin{cases}
\text{TypePrim}(\texttt{"!"}) & \text{if } Brk = [] \land BrkVoid = \text{false} \\
\text{TypePrim}(\texttt{"()"}) & \text{if } Brk = [] \land BrkVoid = \text{true} \\
T & \text{if } BrkVoid = \text{false} \land \text{ResType}(Brk) = T \\
\bot & \text{otherwise}
\end{cases}$$

$$\text{LoopTypeFin}(Brk, BrkVoid) = \begin{cases}
\text{TypePrim}(\texttt{"()"}) & \text{if } Brk = [] \\
T & \text{if } BrkVoid = \text{false} \land \text{ResType}(Brk) = T \\
\bot & \text{otherwise}
\end{cases}$$

**Statement Sequences**

**(StmtSeq-Empty)**
$$\frac{}{\Gamma; R; L \vdash [] \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(StmtSeq-Cons)**
$$\frac{\Gamma; R; L \vdash s \Rightarrow \Gamma_1 \triangleright \langle Res_1, Brk_1, B_1 \rangle \quad \Gamma_1; R; L \vdash ss \Rightarrow \Gamma_2 \triangleright \langle Res_2, Brk_2, B_2 \rangle}{\Gamma; R; L \vdash s::ss \Rightarrow \Gamma_2 \triangleright \langle Res_1 \mathbin{+\!\!+} Res_2,\ Brk_1 \mathbin{+\!\!+} Brk_2,\ B_1 \lor B_2 \rangle}$$

**Bindings**

$$\text{binding} = \langle pat,\ ty\_opt,\ op,\ init,\ \_ \rangle$$

**(T-LetStmt-Ann)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Leftarrow T_a \dashv \emptyset \quad \Gamma \vdash pat \Leftarrow T_a \dashv B \quad \text{Distinct}(\text{PatNames}(pat)) \quad \text{IntroAll}(\Gamma, B) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{LetStmt}(binding) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-LetStmt-Ann-Mismatch)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \neg(\Gamma \vdash T_i <: T_a) \quad c = \text{Code}(\text{T-LetStmt-Ann-Mismatch})}{\Gamma; R; L \vdash \text{LetStmt}(binding) \Uparrow c}$$

**(T-LetStmt-Infer)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Downarrow \theta \quad T_b = \theta(T_i) \quad \Gamma \vdash pat \Leftarrow T_b \dashv B \quad \text{Distinct}(\text{PatNames}(pat)) \quad \text{IntroAll}(\Gamma, B) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{LetStmt}(binding) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-LetStmt-Infer-Err)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Uparrow \quad c = \text{Code}(\text{T-LetStmt-Infer-Err})}{\Gamma; R; L \vdash \text{LetStmt}(binding) \Uparrow c}$$

**(T-VarStmt-Ann)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Leftarrow T_a \dashv \emptyset \quad \Gamma \vdash pat \Leftarrow T_a \dashv B \quad \text{Distinct}(\text{PatNames}(pat)) \quad \text{IntroAllVar}(\Gamma, B) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{VarStmt}(binding) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-VarStmt-Ann-Mismatch)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \neg(\Gamma \vdash T_i <: T_a) \quad c = \text{Code}(\text{T-VarStmt-Ann-Mismatch})}{\Gamma; R; L \vdash \text{VarStmt}(binding) \Uparrow c}$$

**(T-VarStmt-Infer)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Downarrow \theta \quad T_b = \theta(T_i) \quad \Gamma \vdash pat \Leftarrow T_b \dashv B \quad \text{Distinct}(\text{PatNames}(pat)) \quad \text{IntroAllVar}(\Gamma, B) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{VarStmt}(binding) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-VarStmt-Infer-Err)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Uparrow \quad c = \text{Code}(\text{T-VarStmt-Infer-Err})}{\Gamma; R; L \vdash \text{VarStmt}(binding) \Uparrow c}$$

**(T-ShadowLetStmt-Ann)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Leftarrow T_a \dashv \emptyset \quad \text{ShadowAll}(\Gamma, [\langle name, T_a \rangle]) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{ShadowLetStmt}(name, ty\_opt, init) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-ShadowLetStmt-Ann-Mismatch)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \neg(\Gamma \vdash T_i <: T_a) \quad c = \text{Code}(\text{T-ShadowLetStmt-Ann-Mismatch})}{\Gamma; R; L \vdash \text{ShadowLetStmt}(name, ty\_opt, init) \Uparrow c}$$

**(T-ShadowLetStmt-Infer)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Downarrow \theta \quad T_b = \theta(T_i) \quad \text{ShadowAll}(\Gamma, [\langle name, T_b \rangle]) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{ShadowLetStmt}(name, ty\_opt, init) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-ShadowLetStmt-Infer-Err)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Uparrow \quad c = \text{Code}(\text{T-ShadowLetStmt-Infer-Err})}{\Gamma; R; L \vdash \text{ShadowLetStmt}(name, ty\_opt, init) \Uparrow c}$$

**(T-ShadowVarStmt-Ann)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Leftarrow T_a \dashv \emptyset \quad \text{ShadowAllVar}(\Gamma, [\langle name, T_a \rangle]) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{ShadowVarStmt}(name, ty\_opt, init) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-ShadowVarStmt-Ann-Mismatch)**
$$\frac{ty\_opt = T_a \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \neg(\Gamma \vdash T_i <: T_a) \quad c = \text{Code}(\text{T-ShadowVarStmt-Ann-Mismatch})}{\Gamma; R; L \vdash \text{ShadowVarStmt}(name, ty\_opt, init) \Uparrow c}$$

**(T-ShadowVarStmt-Infer)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Downarrow \theta \quad T_b = \theta(T_i) \quad \text{ShadowAllVar}(\Gamma, [\langle name, T_b \rangle]) \Downarrow \Gamma'}{\Gamma; R; L \vdash \text{ShadowVarStmt}(name, ty\_opt, init) \Rightarrow \Gamma' \triangleright \langle [], [], \text{false} \rangle}$$

**(T-ShadowVarStmt-Infer-Err)**
$$\frac{ty\_opt = \bot \quad \Gamma; R; L \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Uparrow \quad c = \text{Code}(\text{T-ShadowVarStmt-Infer-Err})}{\Gamma; R; L \vdash \text{ShadowVarStmt}(name, ty\_opt, init) \Uparrow c}$$

**Assignments**

$$\text{PlaceRoot}(\text{Identifier}(x)) = x$$
$$\text{PlaceRoot}(\text{FieldAccess}(p,\_)) = \text{PlaceRoot}(p)$$
$$\text{PlaceRoot}(\text{TupleAccess}(p,\_)) = \text{PlaceRoot}(p)$$
$$\text{PlaceRoot}(\text{IndexAccess}(p,\_)) = \text{PlaceRoot}(p)$$
$$\text{PlaceRoot}(\text{Deref}(p)) = \text{PlaceRoot}(p)$$

**(T-Assign)**
$$\frac{\text{IsPlace}(p) \quad \text{PlaceRoot}(p) = x \quad \text{MutOf}(\Gamma, x) = \texttt{var} \quad \Gamma; R; L \vdash p :place T_p \quad \Gamma; R; L \vdash e \Leftarrow T_p \dashv \emptyset}{\Gamma; R; L \vdash \text{AssignStmt}(p, e) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-CompoundAssign)**
$$\frac{\text{IsPlace}(p) \quad \text{PlaceRoot}(p) = x \quad \text{MutOf}(\Gamma, x) = \texttt{var} \quad \Gamma; R; L \vdash p :place T_p \quad \text{StripPerm}(T_p) = \text{TypePrim}(t) \quad t \in \text{NumericTypes} \quad \Gamma; R; L \vdash e : T_e \quad \Gamma \vdash T_e <: \text{TypePrim}(t)}{\Gamma; R; L \vdash \text{CompoundAssignStmt}(p, op, e) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(Assign-NotPlace)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \neg \text{IsPlace}(p) \quad c = \text{Code}(\text{Assign-NotPlace})}{\Gamma; R; L \vdash stmt \Uparrow c}$$

**(Assign-Immutable-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \text{IsPlace}(p) \quad \text{PlaceRoot}(p) = x \quad \text{MutOf}(\Gamma, x) = \texttt{let} \quad c = \text{Code}(\text{Assign-Immutable-Err})}{\Gamma; R; L \vdash stmt \Uparrow c}$$

**(Assign-Type-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \text{IsPlace}(p) \quad \Gamma; R; L \vdash p :place T_p \quad \Gamma; R; L \vdash e \Rightarrow T_e \dashv C \quad ((stmt = \text{AssignStmt}(p,e) \land \neg(\Gamma \vdash T_e <: T_p)) \lor (stmt = \text{CompoundAssignStmt}(p,op,e) \land (\neg(\Gamma \vdash T_e <: \text{StripPerm}(T_p)) \lor \neg \exists t.\ \text{StripPerm}(T_p) = \text{TypePrim}(t) \land t \in \text{NumericTypes}))) \quad c = \text{Code}(\text{Assign-Type-Err})}{\Gamma; R; L \vdash stmt \Uparrow c}$$

**Const-Qualified Places.**

**(Assign-Const-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \Gamma; R; L \vdash p : \text{TypePerm}(\texttt{const}, T) \quad c = \text{Code}(\text{Assign-Const-Err})}{\Gamma; R; L \vdash stmt \Uparrow c}$$

**Expression and Unsafe Statements**

**(T-ExprStmt)**
$$\frac{\Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash \text{ExprStmt}(e) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-UnsafeStmt)**
$$\frac{\Gamma; R; L \vdash b : T}{\Gamma; R; L \vdash \text{UnsafeBlockStmt}(b) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-DeferStmt)**
$$\frac{\Gamma; R; L \vdash b \Leftarrow \text{TypePrim}(\texttt{"()"}) \dashv \emptyset \quad \text{DeferSafe}(b)}{\Gamma; R; L \vdash \text{DeferStmt}(b) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(Defer-NonUnit-Err)**
$$\frac{\Gamma; R; L \vdash b : T_b \quad T_b \ne \text{TypePrim}(\texttt{"()"}) \quad c = \text{Code}(\text{Defer-NonUnit-Err})}{\Gamma; R; L \vdash \text{DeferStmt}(b) \Uparrow c}$$

**(Defer-NonLocal-Err)**
$$\frac{\neg \text{DeferSafe}(b) \quad c = \text{Code}(\text{Defer-NonLocal-Err})}{\Gamma; R; L \vdash \text{DeferStmt}(b) \Uparrow c}$$

**(HasNonLocalCtrl-Return)**
$$\frac{}{\text{HasNonLocalCtrl}(\text{ReturnStmt}(\_), in\_loop)}$$

**(HasNonLocalCtrl-Result)**
$$\frac{}{\text{HasNonLocalCtrl}(\text{ResultStmt}(\_), in\_loop)}$$

**(HasNonLocalCtrl-Break)**
$$\frac{in\_loop = \text{false}}{\text{HasNonLocalCtrl}(\text{BreakStmt}(\_), in\_loop)}$$

**(HasNonLocalCtrl-Continue)**
$$\frac{in\_loop = \text{false}}{\text{HasNonLocalCtrl}(\text{ContinueStmt}, in\_loop)}$$

**(HasNonLocalCtrl-LoopInfinite)**
$$\frac{\text{HasNonLocalCtrl}(body, \text{true})}{\text{HasNonLocalCtrl}(\text{LoopInfinite}(body), in\_loop)}$$

**(HasNonLocalCtrl-LoopConditional)**
$$\frac{\text{HasNonLocalCtrl}(body, \text{true})}{\text{HasNonLocalCtrl}(\text{LoopConditional}(\_, body), in\_loop)}$$

**(HasNonLocalCtrl-LoopIter)**
$$\frac{\text{HasNonLocalCtrl}(body, \text{true})}{\text{HasNonLocalCtrl}(\text{LoopIter}(\_, \_, \_, body), in\_loop)}$$

**(HasNonLocalCtrl-Child)**
$$\frac{C \notin \{\text{LoopInfinite},\ \text{LoopConditional},\ \text{LoopIter}\} \quad \exists i.\ \text{HasNonLocalCtrl}(x_i, in\_loop)}{\text{HasNonLocalCtrl}(C(x_1,\ldots,x_n), in\_loop)}$$

$$\text{DeferSafe}(b) \iff \neg \text{HasNonLocalCtrl}(b, \text{false})$$

**(T-RegionStmt)**
$$\frac{\text{RegionOptsExpr}(opts\_opt) = opts \quad \Gamma; R; L \vdash opts \Leftarrow \text{TypePath}([\texttt{RegionOptions}]) \dashv \emptyset \quad \text{RegionBind}(\Gamma, alias\_opt) = \Gamma_r \quad \Gamma_r; R; L \vdash b : T_b}{\Gamma; R; L \vdash \text{RegionStmt}(opts\_opt, alias\_opt, b) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-FrameStmt-Implicit)**
$$\frac{\text{FrameBind}(\Gamma, \bot) = \Gamma_f \quad \Gamma_f; R; L \vdash b : T_b}{\Gamma; R; L \vdash \text{FrameStmt}(\bot, b) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-FrameStmt-Explicit)**
$$\frac{\text{FrameBind}(\Gamma, r) = \Gamma_f \quad \Gamma_f; R; L \vdash b : T_b}{\Gamma; R; L \vdash \text{FrameStmt}(r, b) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(Frame-NoActiveRegion-Err)**
$$\frac{\text{InnermostActiveRegion}(\Gamma)\ \text{undefined} \quad c = \text{Code}(\text{Frame-NoActiveRegion-Err})}{\Gamma; R; L \vdash \text{FrameStmt}(\bot, b) \Uparrow c}$$

**(Frame-Target-NotActive-Err)**
$$\frac{\Gamma; R; L \vdash \text{Identifier}(r) : T_r \quad \neg \text{RegionActiveType}(T_r) \quad c = \text{Code}(\text{Frame-Target-NotActive-Err})}{\Gamma; R; L \vdash \text{FrameStmt}(r, b) \Uparrow c}$$

**Control Flow Statements**

**(T-Return-Value)**
$$\frac{\Gamma; R; L \vdash e \Leftarrow R \dashv \emptyset}{\Gamma; R; L \vdash \text{ReturnStmt}(e) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(T-Return-Unit)**
$$\frac{R = \text{TypePrim}(\texttt{"()"})}{\Gamma; R; L \vdash \text{ReturnStmt}(\bot) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(Return-Type-Err)**
$$\frac{\Gamma; R; L \vdash e : T \quad \neg(\Gamma \vdash T <: R) \quad c = \text{Code}(\text{Return-Type-Err})}{\Gamma; R; L \vdash \text{ReturnStmt}(e) \Uparrow c}$$

**(Return-Unit-Err)**
$$\frac{R \ne \text{TypePrim}(\texttt{"()"}) \quad c = \text{Code}(\text{Return-Type-Err})}{\Gamma; R; L \vdash \text{ReturnStmt}(\bot) \Uparrow c}$$

**(T-ResultStmt)**
$$\frac{\Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash \text{ResultStmt}(e) \Rightarrow \Gamma \triangleright \langle [T], [], \text{false} \rangle}$$

$$\text{ResultNotLast}(stmts) \iff \exists pre, rest, e.\ stmts = pre \mathbin{+\!\!+} [\text{ResultStmt}(e)] \mathbin{+\!\!+} rest \land rest \ne []$$

$$\text{FirstResultSpan}([]) = \bot$$
$$\text{FirstResultSpan}(\text{ResultStmt}(e) :: rest) = \text{span}(\text{ResultStmt}(e))$$
$$\text{FirstResultSpan}(s :: rest) = \text{FirstResultSpan}(rest)\ \text{if}\ s \ne \text{ResultStmt}(\_)$$

**(Warn-Result-Unreachable)**
$$\frac{\text{ResultNotLast}(stmts) \quad \text{FirstResultSpan}(stmts) = sp \quad \Gamma \vdash \text{Emit}(W\text{-}SEM\text{-}1001, sp)}{\Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok}$$

**(Warn-Result-Ok)**
$$\frac{\neg \text{ResultNotLast}(stmts)}{\Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok}$$

**(T-Break-Value)**
$$\frac{L = \texttt{loop} \quad \Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash \text{BreakStmt}(e) \Rightarrow \Gamma \triangleright \langle [], [T], \text{false} \rangle}$$

**(T-Break-Unit)**
$$\frac{L = \texttt{loop}}{\Gamma; R; L \vdash \text{BreakStmt}(\bot) \Rightarrow \Gamma \triangleright \langle [], [], \text{true} \rangle}$$

**(Break-Outside-Loop)**
$$\frac{L \ne \texttt{loop} \quad c = \text{Code}(\text{Break-Outside-Loop})}{\Gamma; R; L \vdash \text{BreakStmt}(\_) \Uparrow c}$$

**(T-Continue)**
$$\frac{L = \texttt{loop}}{\Gamma; R; L \vdash \text{ContinueStmt} \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**(Continue-Outside-Loop)**
$$\frac{L \ne \texttt{loop} \quad c = \text{Code}(\text{Continue-Outside-Loop})}{\Gamma; R; L \vdash \text{ContinueStmt} \Uparrow c}$$

**(T-ErrorStmt)**
$$\frac{}{\Gamma; R; L \vdash \text{ErrorStmt}(\_) \Rightarrow \Gamma \triangleright \langle [], [], \text{false} \rangle}$$

**Block Expressions**

$$\text{LastStmt}([]) = \bot$$
$$\text{LastStmt}([s_1,\ldots,s_n]) = s_n \quad (n \ge 1)$$

**(BlockInfo-Res)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = T \quad (tail\_opt = e \Rightarrow \Gamma_1; R; L \vdash e : T_e)}{\Gamma; R; L \vdash \text{BlockInfo}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle T, Brk, BrkVoid \rangle}$$

**(BlockInfo-Res-Err)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad Res \ne [] \quad \neg \exists T.\ \text{ResType}(Res) = T \quad c = \text{Code}(\text{BlockInfo-Res-Err})}{\Gamma; R; L \vdash \text{BlockInfo}(\text{BlockExpr}(stmts, tail\_opt)) \Uparrow c}$$

**(BlockInfo-Tail)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = e \quad \Gamma_1; R; L \vdash e : T}{\Gamma; R; L \vdash \text{BlockInfo}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle T, Brk, BrkVoid \rangle}$$

**(BlockInfo-ReturnTail)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = \bot \quad \text{LastStmt}(stmts) = \text{ReturnStmt}(\_)}{\Gamma; R; L \vdash \text{BlockInfo}(\text{BlockExpr}(stmts, \bot)) \Downarrow \langle \text{TypePrim}(\texttt{"!"}), Brk, BrkVoid \rangle}$$

**(BlockInfo-Unit)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = \bot \quad \text{LastStmt}(stmts) \ne \text{ReturnStmt}(\_)}{\Gamma; R; L \vdash \text{BlockInfo}(\text{BlockExpr}(stmts, \bot)) \Downarrow \langle \text{TypePrim}(\texttt{"()"}), Brk, BrkVoid \rangle}$$

**(T-Block)**
$$\frac{\Gamma; R; L \vdash \text{BlockInfo}(b) \Downarrow \langle T, \_, \_ \rangle}{\Gamma; R; L \vdash b : T}$$

**(Chk-Block-Tail)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = e \quad \Gamma_1; R; L \vdash e \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{BlockExpr}(stmts, tail\_opt) \Leftarrow T \dashv \emptyset}$$

**(Chk-Block-Return)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = \bot \quad \text{LastStmt}(stmts) = \text{ReturnStmt}(\_)}{\Gamma; R; L \vdash \text{BlockExpr}(stmts, \bot) \Leftarrow T \dashv \emptyset}$$

**(Chk-Block-Unit)**
$$\frac{\Gamma_0 = \text{PushScope}(\Gamma) \quad \Gamma_0; R; L \vdash stmts \Rightarrow \Gamma_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad \Gamma \vdash \text{WarnResultUnreachable}(stmts) \Downarrow ok \quad \text{ResType}(Res) = \bot \quad tail\_opt = \bot \quad \text{LastStmt}(stmts) \ne \text{ReturnStmt}(\_) \quad T = \text{TypePrim}(\texttt{"()"})}{\Gamma; R; L \vdash \text{BlockExpr}(stmts, \bot) \Leftarrow T \dashv \emptyset}$$

**(T-Unsafe-Expr)**
$$\frac{\Gamma; R; L \vdash b : T}{\Gamma; R; L \vdash \text{UnsafeBlockExpr}(b) : T}$$

**(Chk-Unsafe-Expr)**
$$\frac{\Gamma; R; L \vdash b \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{UnsafeBlockExpr}(b) \Leftarrow T \dashv \emptyset}$$

**Loop Expressions**

**(T-Loop-Infinite)**
$$\frac{\Gamma; R; \texttt{loop} \vdash \text{BlockInfo}(body) \Downarrow \langle T_b, Brk, BrkVoid \rangle \quad \text{LoopTypeInf}(Brk, BrkVoid) = T}{\Gamma \vdash \text{LoopInfinite}(body) : T}$$

**(T-Loop-Conditional)**
$$\frac{\Gamma; R; L \vdash cond : \text{TypePrim}(\texttt{"bool"}) \quad \Gamma; R; \texttt{loop} \vdash \text{BlockInfo}(body) \Downarrow \langle T_b, Brk, BrkVoid \rangle \quad \text{LoopTypeFin}(Brk, BrkVoid) = T}{\Gamma \vdash \text{LoopConditional}(cond, body) : T}$$

**(T-Loop-Iter)**
$$\frac{\Gamma; R; L \vdash iter : \text{TypePerm}(p, \text{TypeSlice}(T)) \lor \Gamma; R; L \vdash iter : \text{TypeSlice}(T) \lor \Gamma; R; L \vdash iter : \text{TypePerm}(p, \text{TypeArray}(T, n)) \lor \Gamma; R; L \vdash iter : \text{TypeArray}(T, n) \quad ty\_opt = \bot \Rightarrow T_p = T \quad ty\_opt = T_a \Rightarrow \Gamma \vdash T <: T_a \land T_p = T_a \quad \Gamma \vdash pat \Leftarrow T_p \dashv B \quad \text{Distinct}(\text{PatNames}(pat)) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, B) \Downarrow \Gamma_1 \quad \Gamma_1; R; \texttt{loop} \vdash \text{BlockInfo}(body) \Downarrow \langle T_b, Brk, BrkVoid \rangle \quad \text{LoopTypeFin}(Brk, BrkVoid) = T_r}{\Gamma \vdash \text{LoopIter}(pat, ty\_opt, iter, body) : T_r}$$

**Irrefutable Binding Patterns**

$$\text{PatJudg} = \{\Gamma \vdash pat \Leftarrow T \dashv B\}$$

**(Pat-Dup-Err)**
$$\frac{\neg \text{Distinct}(\text{PatNames}(pat)) \quad c = \text{Code}(\text{Pat-Dup-Err})}{\Gamma \vdash pat \Leftarrow T \Uparrow c}$$

**(Pat-Wildcard)**
$$\frac{}{\Gamma \vdash \_ \Leftarrow T \dashv \emptyset}$$

**(Pat-Ident)**
$$\frac{}{\Gamma \vdash x \Leftarrow T \dashv \{x \mapsto T\}}$$

**(Pat-Unit)**
$$\frac{T = \text{TypePrim}(\texttt{"()"})}{\Gamma \vdash () \Leftarrow T \dashv \emptyset}$$

**(Pat-Tuple-Arity-Err)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad ps = [p_1,\ldots,p_m] \quad m \ne n \quad c = \text{Code}(\text{Pat-Tuple-Arity-Err})}{\Gamma \vdash (p_1,\ldots,p_m) \Leftarrow T \Uparrow c}$$

**(Pat-Tuple)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma \vdash p_i \Leftarrow T_i \dashv B_i \quad B = \biguplus_i B_i}{\Gamma \vdash (p_1,\ldots,p_n) \Leftarrow T \dashv B}$$

**(Pat-Record)**
$$\text{RecordDecl}(p) = R \iff \text{RecordPath}(R) = p$$
$$\text{FieldType}(R, f) = T_f \iff \langle \_, f, T_f, \_, \_, \_ \rangle \in \text{Fields}(R)$$
$$\text{FieldName}(\langle f,\ \_,\ \_ \rangle) = f$$
$$\text{PatOf}(\langle f,\ \bot,\ \_ \rangle) = \text{IdentifierPattern}(f)$$
$$\text{PatOf}(\langle f,\ p,\ \_ \rangle) = p \quad \text{if } p \ne \bot$$

$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \forall fp \in fs,\ \text{FieldType}(R, \text{FieldName}(fp)) = T_f \land \text{FieldVisible}(m, R, \text{FieldName}(fp)) \land \Gamma \vdash \text{PatOf}(fp) \Leftarrow T_f \dashv B_f \quad B = \biguplus_{fp \in fs} B_f}{\Gamma \vdash p\{fs\} \Leftarrow T \dashv B}$$

**(RecordPattern-UnknownField-Bind)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \exists fp \in fs.\ \text{FieldName}(fp) \notin \text{FieldNameSet}(R) \quad c = \text{Code}(\text{RecordPattern-UnknownField})}{\Gamma \vdash p\{fs\} \Leftarrow T \Uparrow c}$$

**(Let-Refutable-Pattern-Err)**
$$\frac{pat \in \{\text{TypedPattern}(\_,\_),\ \text{LiteralPattern}(\_),\ \text{EnumPattern}(\_,\_,\_),\ \text{ModalPattern}(\_,\_),\ \text{RangePattern}(\_,\_,\_)\} \quad c = \text{Code}(\text{Let-Refutable-Pattern-Err})}{\Gamma \vdash pat \Leftarrow T \Uparrow c}$$

#### 5.2.12. Expression Typing (Cursive0)

$$\text{UnresolvedExpr} = \{\text{QualifiedName}(\_,\_),\ \text{QualifiedApply}(\_,\_,\_)\}$$

**(Expr-Unresolved-Err)**
$$\frac{e \in \text{UnresolvedExpr} \quad c = \text{Code}(\text{ResolveExpr-Ident-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

$$\text{ExprJudg} = \{\Gamma; R; L \vdash e : T,\ \Gamma; R; L \vdash e \Leftarrow T \dashv C,\ \Gamma; R; L \vdash p :place T,\ \Gamma; R; L \vdash p \Leftarrow_{\text{place}} T,\ \Gamma; R; L \vdash r : \text{Range}\}$$

**(Lift-Expr)**
$$\frac{\Gamma \vdash e : T}{\Gamma; R; L \vdash e : T}$$

**(Place-Check)**
$$\frac{\Gamma; R; L \vdash p :place S \quad \Gamma \vdash S <: T}{\Gamma; R; L \vdash p \Leftarrow_{\text{place}} T}$$

$$\text{StripPerm}(T) = \begin{cases}
T_0 & \text{if } T = \text{TypePerm}(p, T_0) \\
T & \text{otherwise}
\end{cases}$$
$$\text{BitcopyType}(T) \iff \text{BitcopyTypeCore}(T)$$
$$\text{SignedIntTypes} = \{i8,i16,i32,i64,i128,isize\}$$
$$\text{NumericTypes} = \text{IntTypes} \cup \text{FloatTypes}$$
$$\text{EqType}(T) \iff \big(\text{StripPerm}(T) = \text{TypePrim}(t) \land t \in \text{NumericTypes} \cup \{\texttt{"bool"}, \texttt{"char"}\}\big) \lor \text{StripPerm}(T) = \text{TypePtr}(U, s)$$
$$\phantom{\text{EqType}(T) \iff}\ \lor\ \text{StripPerm}(T) = \text{TypeRawPtr}(q, U) \lor \text{StripPerm}(T) = \text{TypeString}(st) \lor \text{StripPerm}(T) = \text{TypeBytes}(st)$$
$$\text{OrdType}(T) \iff \text{StripPerm}(T) = \text{TypePrim}(t) \land t \in \text{IntTypes} \cup \text{FloatTypes} \cup \{\texttt{"char"}\}$$
$$\text{ValuePathType} : \text{Path} \times \text{Ident} \rightharpoonup \text{Type}$$
$$\text{ValuePathType}(path, name) = \text{StaticType}(path, name)\ \text{if}\ \text{StaticType}(path, name)\ \text{defined}$$
$$\text{ValuePathType}(path, name) = \text{TypeFunc}([\langle mode, T \rangle \mid \langle mode, x, T \rangle \in params],\ \text{ProcReturn}(ret\_opt))\ \text{if}\ \text{DeclOf}(path, name)=\text{ProcedureDecl}(\_, name, params, ret\_opt, \_, \_, \_)$$
$$\text{ValuePathType}(path, name)\ \text{undefined otherwise}$$
$$\text{UnsafeSpan}(span) \iff \exists U,K,D,K',i.\ \text{ParseInputs}(U,K,D,K') \land \text{SourceOf}(K'_i).\text{path} = span.\text{file} \land \exists sp \in \text{UnsafeSpans}(K'_i).\ span \subseteq sp$$


**Identifiers and Paths**

**(T-Ident)**
$$\frac{(x : T) \in \Gamma \quad \text{BitcopyType}(T)}{\Gamma; R; L \vdash \text{Identifier}(x) : T}$$

**(T-Path-Value)**
$$\frac{\text{ValuePathType}(path, name) = T}{\Gamma; R; L \vdash \text{Path}(path, name) : T}$$

**Place Typing**

**(P-Ident)**
$$\frac{(x : T) \in \Gamma}{\Gamma; R; L \vdash \text{Identifier}(x) :place T}$$

**Record Field Access**

$$\text{FieldVis}(R, f) = vis \iff \langle vis, f, T_f, \_ \rangle \in \text{Fields}(R)$$
$$\text{FieldVisible}(m, R, f) \iff \text{FieldVis}(R, f) \in \{\texttt{public}, \texttt{internal}\}$$
$$\phantom{\text{FieldVisible}(m, R, f) \iff}\ \lor\ \big(\text{FieldVis}(R, f) \in \{\texttt{private}, \texttt{protected}\} \land \text{ModuleOfPath}(\text{RecordPath}(R)) = m\big)$$

**(T-Field-Record)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{FieldType}(R, f) = T_f \quad \text{FieldVisible}(m, R, f) \quad \text{BitcopyType}(T_f)}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) : T_f}$$

**(T-Field-Record-Perm)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePerm}(p, \text{TypePath}(q)) \quad \text{RecordDecl}(q) = R \quad \text{FieldType}(R, f) = T_f \quad \text{FieldVisible}(m, R, f) \quad \text{BitcopyType}(\text{TypePerm}(p, T_f))}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) : \text{TypePerm}(p, T_f)}$$

**(P-Field-Record)**
$$\frac{\Gamma; R; L \vdash e :place \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{FieldType}(R, f) = T_f \quad \text{FieldVisible}(m, R, f)}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) :place T_f}$$

**(P-Field-Record-Perm)**
$$\frac{\Gamma; R; L \vdash e :place \text{TypePerm}(p, \text{TypePath}(q)) \quad \text{RecordDecl}(q) = R \quad \text{FieldType}(R, f) = T_f \quad \text{FieldVisible}(m, R, f)}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) :place \text{TypePerm}(p, T_f)}$$

**(FieldAccess-Unknown)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad f \notin \text{FieldNameSet}(R) \quad c = \text{Code}(\text{FieldAccess-Unknown})}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) \Uparrow c}$$

**(FieldAccess-NotVisible)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad f \in \text{FieldNameSet}(R) \quad \neg \text{FieldVisible}(m, R, f) \quad c = \text{Code}(\text{FieldAccess-NotVisible})}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) \Uparrow c}$$

**(FieldAccess-Enum)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad c = \text{Code}(\text{FieldAccess-Unknown})}{\Gamma; R; L \vdash \text{FieldAccess}(e, f) \Uparrow c}$$

**(ValueUse-NonBitcopyPlace)**
$$\frac{\text{IsPlace}(e) \quad \neg \text{BitcopyType}(\text{ExprType}(e)) \quad c = \text{Code}(\text{ValueUse-NonBitcopyPlace})}{\Gamma; R; L \vdash e \Uparrow c}$$

**Error Expression**

**(T-ErrorExpr)**
$$\frac{}{\Gamma; R; L \vdash \text{ErrorExpr}(\_) : \text{TypePrim}(\texttt{"!"})}$$

**Range Expressions**

$$\Gamma; R; L \vdash r : \text{Range} \Rightarrow \text{ExprType}(r) = \text{TypeRange}$$

**(Range-Full)**
$$\frac{}{\Gamma; R; L \vdash \text{Range}(\texttt{Full}, \bot, \bot) : \text{Range}}$$

**(Range-To)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(\texttt{"usize"})}{\Gamma; R; L \vdash \text{Range}(\texttt{To}, \bot, e) : \text{Range}}$$

**(Range-ToInclusive)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(\texttt{"usize"})}{\Gamma; R; L \vdash \text{Range}(\texttt{ToInclusive}, \bot, e) : \text{Range}}$$

**(Range-From)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(\texttt{"usize"})}{\Gamma; R; L \vdash \text{Range}(\texttt{From}, e, \bot) : \text{Range}}$$

**(Range-Exclusive)**
$$\frac{\Gamma; R; L \vdash e_1 : \text{TypePrim}(\texttt{"usize"}) \quad \Gamma; R; L \vdash e_2 : \text{TypePrim}(\texttt{"usize"})}{\Gamma; R; L \vdash \text{Range}(\texttt{Exclusive}, e_1, e_2) : \text{Range}}$$

**(Range-Inclusive)**
$$\frac{\Gamma; R; L \vdash e_1 : \text{TypePrim}(\texttt{"usize"}) \quad \Gamma; R; L \vdash e_2 : \text{TypePrim}(\texttt{"usize"})}{\Gamma; R; L \vdash \text{Range}(\texttt{Inclusive}, e_1, e_2) : \text{Range}}$$

**(Range-NonIndex-Err)**
$$\frac{e = \text{Range}(kind, lo\_opt, hi\_opt) \quad c = \text{Code}(\text{Range-NonIndex-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

**If Expressions**

**(T-If)**
$$\frac{\Gamma; R; L \vdash c : \text{TypePrim}(\texttt{"bool"}) \quad \Gamma; R; L \vdash b_t : T \quad \Gamma; R; L \vdash b_f : T}{\Gamma; R; L \vdash \text{IfExpr}(c, b_t, b_f) : T}$$

**(T-If-No-Else)**
$$\frac{\Gamma; R; L \vdash c : \text{TypePrim}(\texttt{"bool"}) \quad \Gamma; R; L \vdash b_t : \text{TypePrim}(\texttt{"()"})}{\Gamma; R; L \vdash \text{IfExpr}(c, b_t, \bot) : \text{TypePrim}(\texttt{"()"})}$$

**(Chk-If)**
$$\frac{\Gamma; R; L \vdash c : \text{TypePrim}(\texttt{"bool"}) \quad \Gamma; R; L \vdash b_t \Leftarrow T \dashv \emptyset \quad \Gamma; R; L \vdash b_f \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{IfExpr}(c, b_t, b_f) \Leftarrow T \dashv \emptyset}$$

**(Chk-If-No-Else)**
$$\frac{\Gamma; R; L \vdash c : \text{TypePrim}(\texttt{"bool"}) \quad T = \text{TypePrim}(\texttt{"()"}) \quad \Gamma; R; L \vdash b_t \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{IfExpr}(c, b_t, \bot) \Leftarrow T \dashv \emptyset}$$

**Unary Operators**

**(T-Not-Bool)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(\texttt{"bool"})}{\Gamma; R; L \vdash \text{Unary}(\texttt{"!"}, e) : \text{TypePrim}(\texttt{"bool"})}$$

**(T-Not-Int)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(t) \quad t \in \text{IntTypes}}{\Gamma; R; L \vdash \text{Unary}(\texttt{"!"}, e) : \text{TypePrim}(t)}$$

**(T-Neg)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePrim}(t) \quad t \in \text{SignedIntTypes} \cup \text{FloatTypes}}{\Gamma; R; L \vdash \text{Unary}(\texttt{"-"}, e) : \text{TypePrim}(t)}$$

**Binary Operators**

$$\text{ArithOps} = \{\texttt{"+"},\ \texttt{"-"},\ \texttt{"*"},\ \texttt{"/"},\ \texttt{"%"},\ \texttt{"**"}\}$$
$$\text{BitOps} = \{\texttt{"&"},\ \texttt{"|"},\ \texttt{"^"}\}$$
$$\text{ShiftOps} = \{\texttt{"<<"},\ \texttt{">>"}\}$$
$$\text{CmpOps} = \{\texttt{"=="},\ \texttt{"!="},\ \texttt{"<"},\ \texttt{"<="},\ \texttt{">"},\ \texttt{">="}\}$$
$$\text{LogicOps} = \{\texttt{"&&"},\ \texttt{"||"}\}$$

**(T-Arith)**
$$\frac{\Gamma; R; L \vdash e_1 : T \quad \Gamma; R; L \vdash e_2 : T \quad \text{StripPerm}(T) = \text{TypePrim}(t) \quad t \in \text{NumericTypes} \quad op \in \text{ArithOps}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(t)}$$

**(T-Bitwise)**
$$\frac{\Gamma; R; L \vdash e_1 : T \quad \Gamma; R; L \vdash e_2 : T \quad \text{StripPerm}(T) = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad op \in \text{BitOps}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(t)}$$

**(T-Shift)**
$$\frac{\Gamma; R; L \vdash e_1 : T_1 \quad \Gamma; R; L \vdash e_2 : \text{TypePrim}(\texttt{"u32"}) \quad \text{StripPerm}(T_1) = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad op \in \text{ShiftOps}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(t)}$$

**(T-Compare-Eq)**
$$\frac{\Gamma; R; L \vdash e_1 : T \quad \Gamma; R; L \vdash e_2 : T \quad \text{EqType}(T) \quad op \in \{\texttt{"=="}, \texttt{"!="}\}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(\texttt{"bool"})}$$

**(T-Compare-Ord)**
$$\frac{\Gamma; R; L \vdash e_1 : T \quad \Gamma; R; L \vdash e_2 : T \quad \text{OrdType}(T) \quad op \in \{\texttt{"<"}, \texttt{"<="}, \texttt{">"}, \texttt{">="}\}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(\texttt{"bool"})}$$

**(T-Logical)**
$$\frac{\Gamma; R; L \vdash e_1 : \text{TypePrim}(\texttt{"bool"}) \quad \Gamma; R; L \vdash e_2 : \text{TypePrim}(\texttt{"bool"}) \quad op \in \text{LogicOps}}{\Gamma; R; L \vdash \text{Binary}(op, e_1, e_2) : \text{TypePrim}(\texttt{"bool"})}$$

**Casts**

$$S' = \text{StripPerm}(S)$$
$$T' = \text{StripPerm}(T)$$
$$\text{CastValid}(S,T) \iff (S'=\text{TypePrim}(s) \land T'=\text{TypePrim}(t) \land s,t \in \text{NumericTypes}) \lor (S'=\text{TypePrim}(\texttt{"bool"}) \land T'=\text{TypePrim}(t) \land t \in \text{IntTypes}) \lor (S'=\text{TypePrim}(t) \land t \in \text{IntTypes} \land T'=\text{TypePrim}(\texttt{"bool"})) \lor (S'=\text{TypePrim}(\texttt{"char"}) \land T'=\text{TypePrim}(\texttt{"u32"})) \lor (S'=\text{TypePrim}(\texttt{"u32"}) \land T'=\text{TypePrim}(\texttt{"char"}))$$

**(T-Cast)**
$$\frac{\Gamma; R; L \vdash e : S \quad \text{CastValid}(S, T)}{\Gamma; R; L \vdash \text{Cast}(e, T) : T}$$

**Address-Of, Dereference, Move**

$$\text{AddrOfOk}(p) \iff \text{IsPlace}(p) \land (p=\text{IndexAccess}(\_,idx) \Rightarrow \Gamma; R; L \vdash idx : T_i \land \text{StripPerm}(T_i) = \text{TypePrim}(\texttt{"usize"}))$$

**(T-AddrOf)**
$$\frac{\Gamma; R; L \vdash p :place T \quad \text{AddrOfOk}(p)}{\Gamma; R; L \vdash \text{AddressOf}(p) : \text{TypePtr}(T, \texttt{Valid})}$$

**(T-Alloc-Explicit)**
$$\frac{\Gamma; R; L \vdash e : T \quad \Gamma; R; L \vdash \text{Identifier}(r) : T_r \quad \text{RegionActiveType}(T_r)}{\Gamma; R; L \vdash \text{AllocExpr}(r, e) : T}$$

**(T-Alloc-Implicit)**
$$\frac{\text{InnermostActiveRegion}(\Gamma) = r \quad \Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash \text{AllocExpr}(\bot, e) : T}$$

**(Alloc-Region-NotFound-Err)**
$$\frac{e = \text{AllocExpr}(r, \_) \quad r \ne \bot \quad \Gamma; R; L \vdash \text{Identifier}(r) : T_r \quad \neg \text{RegionActiveType}(T_r) \quad c = \text{Code}(\text{Alloc-Region-NotFound-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

**(Alloc-Implicit-NoRegion-Err)**
$$\frac{e = \text{AllocExpr}(\bot, \_) \quad \text{InnermostActiveRegion}(\Gamma)\ \text{undefined} \quad c = \text{Code}(\text{Alloc-Implicit-NoRegion-Err})}{\Gamma; R; L \vdash e \Uparrow c}$$

**(T-Deref-Ptr)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePtr}(T, \texttt{Valid}) \quad \text{BitcopyType}(T)}{\Gamma; R; L \vdash \text{Deref}(e) : T}$$

**(T-Deref-Raw)**
$$\frac{\text{UnsafeSpan}(\text{span}(\text{Deref}(e))) \quad \Gamma; R; L \vdash e : \text{TypeRawPtr}(q, T) \quad \text{BitcopyType}(T)}{\Gamma; R; L \vdash \text{Deref}(e) : T}$$

**(P-Deref-Ptr)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePtr}(T, \texttt{Valid})}{\Gamma; R; L \vdash \text{Deref}(e) :place T}$$

**(P-Deref-Raw-Imm)**
$$\frac{\text{UnsafeSpan}(\text{span}(\text{Deref}(e))) \quad \Gamma; R; L \vdash e : \text{TypeRawPtr}(\texttt{imm}, T)}{\Gamma; R; L \vdash \text{Deref}(e) :place \text{TypePerm}(\texttt{const}, T)}$$

**(P-Deref-Raw-Mut)**
$$\frac{\text{UnsafeSpan}(\text{span}(\text{Deref}(e))) \quad \Gamma; R; L \vdash e : \text{TypeRawPtr}(\texttt{mut}, T)}{\Gamma; R; L \vdash \text{Deref}(e) :place \text{TypePerm}(\texttt{unique}, T)}$$

**(T-Move)**
$$\frac{\Gamma; R; L \vdash p :place T}{\Gamma; R; L \vdash \text{MoveExpr}(p) : T}$$

**(AddrOf-NonPlace)**
$$\frac{\neg \text{IsPlace}(e) \quad c = \text{Code}(\text{AddrOf-NonPlace})}{\Gamma; R; L \vdash \text{AddressOf}(e) \Uparrow c}$$

**(AddrOf-Index-Array-NonUsize)**
$$\frac{p = \text{IndexAccess}(base, idx) \quad \Gamma; R; L \vdash base : \text{TypeArray}(T, n) \quad \Gamma; R; L \vdash idx : T_i \quad \text{StripPerm}(T_i) \ne \text{TypePrim}(\texttt{"usize"}) \quad c = \text{Code}(\text{Index-Array-NonUsize})}{\Gamma; R; L \vdash \text{AddressOf}(p) \Uparrow c}$$

**(AddrOf-Index-Slice-NonUsize)**
$$\frac{p = \text{IndexAccess}(base, idx) \quad \Gamma; R; L \vdash base : \text{TypeSlice}(T, n) \quad \Gamma; R; L \vdash idx : T_i \quad \text{StripPerm}(T_i) \ne \text{TypePrim}(\texttt{"usize"}) \quad c = \text{Code}(\text{Index-Slice-NonUsize})}{\Gamma; R; L \vdash \text{AddressOf}(p) \Uparrow c}$$

**(Deref-Null)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePtr}(T, \texttt{Null}) \quad c = \text{Code}(\text{Deref-Null})}{\Gamma; R; L \vdash \text{Deref}(e) \Uparrow c}$$

**(Deref-Expired)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePtr}(T, \texttt{Expired}) \quad c = \text{Code}(\text{Deref-Expired})}{\Gamma; R; L \vdash \text{Deref}(e) \Uparrow c}$$

**(Deref-Raw-Unsafe)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeRawPtr}(q, T) \quad \neg \text{UnsafeSpan}(\text{span}(\text{Deref}(e))) \quad c = \text{Code}(\text{Deref-Raw-Unsafe})}{\Gamma; R; L \vdash \text{Deref}(e) \Uparrow c}$$

**Transmute**

**(T-Transmute-SizeEq)**
$$\frac{\Gamma \vdash \text{sizeof}(t_1) = \text{sizeof}(t_2)}{\Gamma \vdash \text{TransmuteSizeOk}(t_1, t_2)}$$

**(T-Transmute-AlignEq)**
$$\frac{\Gamma \vdash \text{alignof}(t_1) = \text{alignof}(t_2)}{\Gamma \vdash \text{TransmuteAlignOk}(t_1, t_2)}$$

**(T-Transmute)**
$$\frac{\text{UnsafeSpan}(\text{span}(\text{TransmuteExpr}(t_1,t_2,e))) \quad \Gamma \vdash t_1\ \text{wf} \quad \Gamma \vdash t_2\ \text{wf} \quad \Gamma \vdash \text{TransmuteSizeOk}(t_1, t_2) \quad \Gamma \vdash \text{TransmuteAlignOk}(t_1, t_2) \quad \Gamma; R; L \vdash e : t_1}{\Gamma; R; L \vdash \text{TransmuteExpr}(t_1, t_2, e) : t_2}$$

**(Transmute-Unsafe-Err)**
$$\frac{\neg \text{UnsafeSpan}(\text{span}(\text{TransmuteExpr}(t_1,t_2,e))) \quad c = \text{Code}(\text{Transmute-Unsafe-Err})}{\Gamma; R; L \vdash \text{TransmuteExpr}(t_1,t_2,e) \Uparrow c}$$

**Propagation (`?`)**

$$\text{SuccessMember}(R,U) = T_s \iff U=\text{TypeUnion}([T_1,\ldots,T_n]) \land \neg(\Gamma \vdash T_s <: R) \land \forall i \ne s.\ \Gamma \vdash T_i <: R$$

**(T-Propagate)**
$$\frac{\Gamma; R; L \vdash e : U \quad \text{SuccessMember}(R, U) = T_s}{\Gamma; R; L \vdash \text{Propagate}(e) : T_s}$$

**Record Literals**

$$\text{FieldNames}(R) = [ f.\text{name} \mid f \in \text{Fields}(R) ]$$
$$\text{FieldInitNames}(\text{fields}) = [ f \mid \langle f,\_ \rangle \in \text{fields} ]$$
$$\text{Set}(xs) = \{ x \mid x \in xs \}$$
$$\text{FieldNameSet}(R) = \text{Set}(\text{FieldNames}(R))$$
$$\text{FieldInitSet}(\text{fields}) = \text{Set}(\text{FieldInitNames}(\text{fields}))$$

**(T-Record-Literal)**
$$\frac{\text{RecordDecl}(p) = R \quad \text{Distinct}(\text{FieldInitNames}(fields)) \quad \text{FieldInitSet}(fields) = \text{FieldNameSet}(R) \quad \forall \langle f, e \rangle \in fields,\ \text{FieldType}(R, f) = T_f \land \text{FieldVisible}(m, R, f) \land \Gamma; R; L \vdash e \Leftarrow T_f \dashv \emptyset}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) : \text{TypePath}(p)}$$

**(Record-FieldInit-Dup)**
$$\frac{\text{RecordDecl}(p) = R \quad \neg \text{Distinct}(\text{FieldInitNames}(fields)) \quad c = \text{Code}(\text{Record-FieldInit-Dup})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) \Uparrow c}$$

**(Record-FieldInit-Missing)**
$$\frac{\text{RecordDecl}(p) = R \quad \text{FieldInitSet}(fields) \ne \text{FieldNameSet}(R) \quad c = \text{Code}(\text{Record-FieldInit-Missing})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) \Uparrow c}$$

**(Record-Field-Unknown)**
$$\frac{\text{RecordDecl}(p) = R \quad \exists \langle f, e \rangle \in fields.\ f \notin \text{FieldNameSet}(R) \quad c = \text{Code}(\text{Record-Field-Unknown})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) \Uparrow c}$$

**(Record-Field-NotVisible)**
$$\frac{\text{RecordDecl}(p) = R \quad \exists \langle f, e \rangle \in fields.\ \neg \text{FieldVisible}(m, R, f) \quad c = \text{Code}(\text{Record-Field-NotVisible})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) \Uparrow c}$$

**(Record-Field-NonBitcopy-Move)**
$$\frac{\text{RecordDecl}(p) = R \quad \exists \langle f, e \rangle \in fields.\ \text{FieldType}(R, f) = T_f \land \neg \text{BitcopyType}(T_f) \land \text{IsPlace}(e) \land e \ne \text{MoveExpr}(\_) \quad c = \text{Code}(\text{Record-Field-NonBitcopy-Move})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{TypePath}(p), fields) \Uparrow c}$$

**Enum Literals**

$$\text{EnumDecl}(p) = E \iff \text{EnumPathOf}(E) = p$$
$$\text{VariantPayload}(E, v) = payload\_opt \iff \exists disc, span, doc.\ \text{VariantDecl}(v, payload\_opt, disc, span, doc) \in E.\text{variants}$$
$$\text{VariantFieldNames}(fs) = [ f \mid \text{FieldDecl}(\_, f, \_, \_, \_, \_) \in fs ]$$
$$\text{VariantFieldNameSet}(fs) = \text{Set}(\text{VariantFieldNames}(fs))$$

$$\text{EnumFieldType}(E,v,f) = T_f \iff \text{VariantPayload}(E,v)=\text{RecordPayload}(fs) \land \langle \_, f, T_f, \_, \_, \_ \rangle \in fs$$

**(T-Enum-Lit-Unit)**
$$\frac{\text{EnumDecl}(\text{EnumPath}(path)) = E \quad v = \text{VariantName}(path) \quad \text{VariantPayload}(E, v) = \bot}{\Gamma; R; L \vdash \text{EnumLiteral}(path, \bot) : \text{TypePath}(\text{EnumPath}(path))}$$

**(T-Enum-Lit-Tuple)**
$$\frac{\text{EnumDecl}(\text{EnumPath}(path)) = E \quad v = \text{VariantName}(path) \quad \text{VariantPayload}(E, v) = \text{TuplePayload}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma; R; L \vdash e_i \Leftarrow T_i \dashv \emptyset}{\Gamma; R; L \vdash \text{EnumLiteral}(path, \text{Paren}([e_1,\ldots,e_n])) : \text{TypePath}(\text{EnumPath}(path))}$$

**(T-Enum-Lit-Record)**
$$\frac{\text{EnumDecl}(\text{EnumPath}(path)) = E \quad v = \text{VariantName}(path) \quad \text{VariantPayload}(E, v) = \text{RecordPayload}(fs) \quad \text{Distinct}(\text{FieldInitNames}(fields)) \quad \text{FieldInitSet}(fields) = \text{VariantFieldNameSet}(fs) \quad \forall \langle f, e \rangle \in fields,\ \Gamma; R; L \vdash e \Leftarrow \text{EnumFieldType}(E, v, f) \dashv \emptyset}{\Gamma; R; L \vdash \text{EnumLiteral}(path, \text{Brace}(fields)) : \text{TypePath}(\text{EnumPath}(path))}$$

#### 5.2.13. Pattern Matching (Cursive0)

$$\text{MatchJudg} = \{\Gamma \vdash pat \triangleleft T \dashv B,\ \Gamma; R; L \vdash \text{ArmBody}(body) : T,\ \Gamma; R; L \vdash \text{ArmBody}(body) \Leftarrow T\}$$

$$\text{PermWrap}(T, B) = \begin{cases}
\{ x \mapsto \text{TypePerm}(p, T_x) \mid x \mapsto T_x \in B \} & \text{if } T = \text{TypePerm}(p, U) \\
B & \text{otherwise}
\end{cases}$$

**(Pat-StripPerm)**
$$\frac{\Gamma \vdash pat \triangleleft \text{StripPerm}(T) \dashv B}{\Gamma \vdash pat \triangleleft T \dashv \text{PermWrap}(T, B)}$$

$$\text{PatternEffectRules} = \text{RulesIn}(\{\texttt{"5.2.15"}\})$$

$$\text{ConstPatInt}(p) = n \iff p = \text{LiteralPattern}(\text{IntLiteral}(n))$$

**(ArmBody-Expr)**
$$\frac{\Gamma; R; L \vdash e : T}{\Gamma; R; L \vdash \text{ArmBody}(e) : T}$$

**(ArmBody-Block)**
$$\frac{\Gamma; R; L \vdash b : T}{\Gamma; R; L \vdash \text{ArmBody}(b) : T}$$

**(ArmBody-Expr-Chk)**
$$\frac{\Gamma; R; L \vdash e \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{ArmBody}(e) \Leftarrow T}$$

**(ArmBody-Block-Chk)**
$$\frac{\Gamma; R; L \vdash b \Leftarrow T \dashv \emptyset}{\Gamma; R; L \vdash \text{ArmBody}(b) \Leftarrow T}$$

**(Pat-Dup-R-Err)**
$$\frac{\neg \text{Distinct}(\text{PatNames}(pat)) \quad c = \text{Code}(\text{Pat-Dup-Err})}{\Gamma \vdash pat \triangleleft T \Uparrow c}$$

**(Pat-Wildcard-R)**
$$\frac{}{\Gamma \vdash \_ \triangleleft T \dashv \emptyset}$$

**(Pat-Ident-R)**
$$\frac{}{\Gamma \vdash x \triangleleft T \dashv \{x \mapsto T\}}$$

**(Pat-Literal-R)**
$$\frac{\Gamma \vdash \text{Literal}(lit) : T_l \quad \Gamma \vdash T_l <: T}{\Gamma \vdash \text{LiteralPattern}(lit) \triangleleft T \dashv \emptyset}$$

**(Pat-Tuple-R-Arity-Err)**
$$\frac{\text{StripPerm}(T) = \text{TypeTuple}([T_1,\ldots,T_n]) \quad ps = [p_1,\ldots,p_m] \quad m \ne n \quad c = \text{Code}(\text{Pat-Tuple-Arity-Err})}{\Gamma \vdash \text{TuplePattern}(ps) \triangleleft T \Uparrow c}$$

**(Pat-Tuple-R)**
$$\frac{\text{StripPerm}(T) = \text{TypeTuple}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma \vdash p_i \triangleleft T_i \dashv B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{TuplePattern}([p_1,\ldots,p_n]) \triangleleft T \dashv B}$$

**(Pat-Record-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \forall fp \in fs,\ \text{FieldType}(R, \text{FieldName}(fp)) = T_f \land \text{FieldVisible}(m, R, \text{FieldName}(fp)) \land \Gamma \vdash \text{PatOf}(fp) \triangleleft T_f \dashv B_f \quad B = \biguplus_{fp \in fs} B_f}{\Gamma \vdash \text{RecordPattern}(p, fs) \triangleleft T \dashv B}$$

**(RecordPattern-UnknownField)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \exists fp \in fs.\ \text{FieldName}(fp) \notin \text{FieldNameSet}(R) \quad c = \text{Code}(\text{RecordPattern-UnknownField})}{\Gamma \vdash \text{RecordPattern}(p, fs) \triangleleft T \Uparrow c}$$

**(Pat-Enum-Unit-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, v) = \bot}{\Gamma \vdash \text{EnumPattern}(p, v, \bot) \triangleleft T \dashv \emptyset}$$

**(Pat-Enum-Tuple-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, v) = \text{TuplePayload}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma \vdash p_i \triangleleft T_i \dashv B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{EnumPattern}(p, v, \text{TuplePayloadPattern}([p_1,\ldots,p_n])) \triangleleft T \dashv B}$$

**(Pat-Enum-Record-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{VariantPayload}(E, v) = \text{RecordPayload}(fs') \quad \forall fp \in fs,\ \text{EnumFieldType}(E, v, \text{FieldName}(fp)) = T_f \land \Gamma \vdash \text{PatOf}(fp) \triangleleft T_f \dashv B_f \quad B = \biguplus_{fp \in fs} B_f}{\Gamma \vdash \text{EnumPattern}(p, v, \text{RecordPayloadPattern}(fs)) \triangleleft T \dashv B}$$

**(Pat-Modal-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \forall fp \in fs,\ \text{PayloadMap}(M, S)(\text{FieldName}(fp)) = T_f \land \Gamma \vdash \text{PatOf}(fp) \triangleleft T_f \dashv B_f \quad B = \biguplus_{fp \in fs} B_f}{\Gamma \vdash \text{ModalPattern}(S, fs) \triangleleft T \dashv B}$$

**(Pat-Modal-State-R)**
$$\frac{\text{StripPerm}(T) = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \forall fp \in fs,\ \text{PayloadMap}(M, S)(\text{FieldName}(fp)) = T_f \land \Gamma \vdash \text{PatOf}(fp) \triangleleft T_f \dashv B_f \quad B = \biguplus_{fp \in fs} B_f}{\Gamma \vdash \text{ModalPattern}(S, fs) \triangleleft T \dashv B}$$

**(Pat-Range-R)**
$$\frac{\text{StripPerm}(T) = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad \text{ConstPatInt}(p_l) = n_l \quad \text{ConstPatInt}(p_h) = n_h \quad (kind = \texttt{".."} \Rightarrow n_l < n_h) \quad (kind = \texttt{"..="} \Rightarrow n_l \le n_h)}{\Gamma \vdash \text{RangePattern}(kind, p_l, p_h) \triangleleft T \dashv \emptyset}$$

**(RangePattern-NonConst)**
$$\frac{(\text{ConstPatInt}(p_l)\ \text{undefined} \ \lor\ \text{ConstPatInt}(p_h)\ \text{undefined}) \quad c = \text{Code}(\text{RangePattern-NonConst})}{\Gamma \vdash \text{RangePattern}(kind, p_l, p_h) \triangleleft T \Uparrow c}$$

**(RangePattern-Empty)**
$$\frac{\text{ConstPatInt}(p_l) = n_l \quad \text{ConstPatInt}(p_h) = n_h \quad ((kind = \texttt{".."}) \Rightarrow n_l \ge n_h) \quad ((kind = \texttt{"..="}) \Rightarrow n_l > n_h) \quad c = \text{Code}(\text{RangePattern-Empty})}{\Gamma \vdash \text{RangePattern}(kind, p_l, p_h) \triangleleft T \Uparrow c}$$

$$\text{AllEq}_\Gamma([T_1,\ldots,T_n]) \iff \forall i.\ \Gamma \vdash T_i \equiv T_1$$
$$\text{Irrefutable}(\text{pat},T) \iff \text{pat}=\text{WildcardPattern} \lor \text{pat}=\text{IdentifierPattern}(\_) \lor (\text{pat}=\text{TuplePattern}([p_1,\ldots,p_n]) \land \text{StripPerm}(T)=\text{TypeTuple}([T_1,\ldots,T_n]) \land \forall i.\ \text{Irrefutable}(p_i,T_i)) \lor (\text{pat}=\text{RecordPattern}(p,fs) \land \text{StripPerm}(T)=\text{TypePath}(p) \land \text{RecordDecl}(p)=R \land \forall fp \in fs.\ \text{Irrefutable}(\text{PatOf}(fp),\ \text{FieldType}(R,\ \text{FieldName}(fp))))$$
$$\text{HasIrrefutableArm}(\text{arms},T) \iff \exists \text{arm} \in \text{arms}.\ \exists p,g,b.\ \text{arm}=\langle p,g,b\rangle \land \text{Irrefutable}(p,T)$$

**Enum Match**

$$\text{VariantNames}(E) = [ v.\text{name} \mid v \in E.\text{variants} ]$$
$$\text{ArmVariants}(\text{arms}) = \{ v \mid \exists p,g,b.\ \langle p,g,b\rangle \in \text{arms} \land p=\text{EnumPattern}(\_,v,\_) \}$$

**(T-Match-Enum)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypePath}(p) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) : T_i \quad \text{AllEq}_\Gamma([T_1,\ldots,T_k]) \quad (\text{HasIrrefutableArm}(arms, \text{TypePath}(p)) \lor \text{ArmVariants}(arms) = \text{VariantNames}(E))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) : T_1}$$

**Modal Match**

$$\text{StateNames}(M) = \text{States}(M)$$
$$\text{ArmStates}(\text{arms}) = \{ s \mid \exists p,g,b.\ \langle p,g,b\rangle \in \text{arms} \land p=\text{ModalPattern}(\_,s) \}$$

**(T-Match-Modal)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypePath}(p) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) : T_i \quad \text{AllEq}_\Gamma([T_1,\ldots,T_k]) \quad (\text{HasIrrefutableArm}(arms, \text{TypePath}(p)) \lor \text{ArmStates}(arms) = \text{StateNames}(M))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) : T_1}$$

**(Match-Modal-NonExhaustive)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \neg(\text{HasIrrefutableArm}(arms, \text{TypePath}(p)) \lor \text{ArmStates}(arms) = \text{StateNames}(M)) \quad c = \text{Code}(\text{Match-Modal-NonExhaustive})}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Uparrow c}$$

**Union Match**

$$\text{UnionTypes}(U) = [T_1,\ldots,T_n] \iff U=\text{TypeUnion}([T_1,\ldots,T_n])$$
$$\text{ArmUnionTypes}(\text{arms}) = \{ T \mid \exists p,g,b.\ \langle p,g,b\rangle \in \text{arms} \land p=\text{Pat-Union}(T,\_) \}$$
$$\text{UnionTypesExhaustive}(\text{arms},\text{types}) \iff \forall T \in \text{types}.\ \exists \text{arm} \in \text{arms}.\ \exists p,g,b.\ \text{arm}=\langle p,g,b\rangle \land p=\text{Pat-Union}(T,\_)$$

**(T-Match-Union)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeUnion}([T_1,\ldots,T_n]) \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypeUnion}([T_1,\ldots,T_n]) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) : T_i' \quad \text{AllEq}_\Gamma([T_1',\ldots,T_k']) \quad (\text{HasIrrefutableArm}(arms, \text{TypeUnion}([T_1,\ldots,T_n])) \lor \text{UnionTypesExhaustive}(arms, [T_1,\ldots,T_n]))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) : T_1'}$$

**(Match-Union-NonExhaustive)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeUnion}([T_1,\ldots,T_n]) \quad \neg(\text{HasIrrefutableArm}(arms, \text{TypeUnion}([T_1,\ldots,T_n])) \lor \text{UnionTypesExhaustive}(arms, [T_1,\ldots,T_n])) \quad c = \text{Code}(\text{Match-Union-NonExhaustive})}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Uparrow c}$$

**(Chk-Match-Union)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeUnion}([T_1,\ldots,T_n]) \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypeUnion}([T_1,\ldots,T_n]) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) \Leftarrow T \quad (\text{HasIrrefutableArm}(arms, \text{TypeUnion}([T_1,\ldots,T_n])) \lor \text{UnionTypesExhaustive}(arms, [T_1,\ldots,T_n]))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Leftarrow T \dashv \emptyset}$$

**Other Matches**

**(T-Match-Other)**
$$\frac{\Gamma; R; L \vdash e : T \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft T \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) : T_i \quad \text{AllEq}_\Gamma([T_1,\ldots,T_k]) \quad \text{HasIrrefutableArm}(arms, T)}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) : T_1}$$

**(Chk-Match-Enum)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypePath}(p) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) \Leftarrow T \quad (\text{HasIrrefutableArm}(arms, \text{TypePath}(p)) \lor \text{ArmVariants}(arms) = \text{VariantNames}(E))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Leftarrow T \dashv \emptyset}$$

**(Chk-Match-Modal)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft \text{TypePath}(p) \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) \Leftarrow T \quad (\text{HasIrrefutableArm}(arms, \text{TypePath}(p)) \lor \text{ArmStates}(arms) = \text{StateNames}(M))}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Leftarrow T \dashv \emptyset}$$

**(Chk-Match-Other)**
$$\frac{\Gamma; R; L \vdash e : T_s \quad \forall i,\ \text{arm}_i = \langle p_i, g_i, b_i \rangle \quad \Gamma \vdash p_i \triangleleft T_s \dashv B_i \quad \text{Distinct}(\text{PatNames}(p_i)) \quad \Gamma_i = \text{IntroAll}(\Gamma, B_i) \quad (g_i \ne \bot \Rightarrow \Gamma_i; R; L \vdash g_i : \text{TypePrim}(\texttt{"bool"})) \quad \Gamma_i; R; L \vdash \text{ArmBody}(b_i) \Leftarrow T \quad \text{HasIrrefutableArm}(arms, T_s)}{\Gamma; R; L \vdash \text{MatchExpr}(e, arms) \Leftarrow T \dashv \emptyset}$$

#### 5.2.14. Declaration Typing (Cursive0)

$$\text{DeclJudg} = \{\Gamma \vdash \text{ProcedureDecl} : \text{ok},\ \Gamma \vdash \text{StaticDecl} : \text{ok},\ \Gamma \vdash \text{RecordDecl} : \text{ok},\ \Gamma \vdash \text{EnumDecl} : \text{ok},\ \Gamma \vdash \text{ModalDecl} : \text{ok},\ \Gamma \vdash \text{ClassDecl} : \text{ok}\}$$

**DeclTyping.**
$$\text{DeclTyping}(Ms) \Downarrow ok \iff \forall M \in Ms.\ \Gamma \vdash \text{DeclTypingMod}(M) \Downarrow ok$$
$$\text{DeclTypingMod}(M) \Downarrow ok \iff \forall it \in M.\text{items}.\ \Gamma \vdash \text{DeclTypingItem}(M.\text{path}, it) \Downarrow ok$$

$$\text{ProvBindCheck}(\text{params}, body) \Downarrow ok \iff body=\text{BlockExpr}(stmts, tail\_opt) \land \exists \vec{\pi}.\ |\vec{\pi}|=|\text{params}| \land \Gamma; \text{InitProvEnv}(\text{params}, \vec{\pi}, []) \vdash \text{BlockProv}(stmts, tail\_opt) \Downarrow \pi$$

$$\text{DeclTypingItem}(m, \text{UsingDecl}(\_)) \Downarrow ok$$
$$\text{DeclTypingItem}(m, \text{StaticDecl}(\_,\_,\_,\_,\_)) \Downarrow ok \iff \Gamma \vdash \text{StaticDecl} : \text{ok}$$
$$\text{DeclTypingItem}(m, \text{TypeAliasDecl}(\_, name,\_,\_,\_)) \Downarrow ok \iff \Gamma \vdash \text{FullPath}(m, name) : \text{TypeAliasOk}$$
$$\text{DeclTypingItem}(m, \text{ProcedureDecl}(\_,\_,params,\_,body,\_,\_) = item) \Downarrow ok \iff \Gamma \vdash \text{ProcedureDecl} : \text{ok} \land \text{ProcBindCheck}(m, item) \Downarrow ok \land \text{ProvBindCheck}(params, body) \Downarrow ok$$
$$\text{DeclTypingItem}(m, R) \Downarrow ok \iff R=\text{RecordDecl}(\_,\_,\_,\_,\_,\_) \land \Gamma \vdash R\ \text{record} : \text{ok} \land \forall md \in \text{Methods}(R).\ \text{MethodBindCheck}(m, \text{TypePath}(\text{RecordPath}(R)), md) \Downarrow ok \land \text{ProvBindCheck}(\text{MethodParamsDecl}(\text{TypePath}(\text{RecordPath}(R)), md), md.\text{body}) \Downarrow ok$$
$$\text{DeclTypingItem}(m, E) \Downarrow ok \iff E=\text{EnumDecl}(\_,\_,\_,\_,\_,\_) \land \Gamma \vdash E\ \text{enum} : \text{ok}$$
$$\text{DeclTypingItem}(m, M) \Downarrow ok \iff M=\text{ModalDecl}(\_,\_,\_,\_,\_,\_) \land \Gamma \vdash M\ \text{modal} : \text{ok} \land \forall S \in \text{States}(M),\ \forall md \in \text{Methods}(S).\ \text{StateMethodBindCheck}(m, M, S, md) \Downarrow ok \land \text{ProvBindCheck}(\text{StateMethodParams}(M, S, md), md.\text{body}) \Downarrow ok \land \forall tr \in \text{Transitions}(S).\ \text{TransitionBindCheck}(m, M, S, tr) \Downarrow ok \land \text{ProvBindCheck}(\text{TransitionParams}(M, S, tr), tr.\text{body}) \Downarrow ok$$
$$\text{DeclTypingItem}(m, Cl) \Downarrow ok \iff Cl=\text{ClassDecl}(\_,\_,\_,\_,\_) \land \Gamma \vdash Cl : \text{ok} \land \forall md \in \text{ClassMethods}(Cl).\ (md.\text{body\_opt}=\bot \ \lor\ (\text{ClassMethodBindCheck}(m, Cl, md) \Downarrow ok \land \text{ProvBindCheck}(\text{ClassMethodParams}(Cl, md), md.\text{body\_opt}) \Downarrow ok))$$

$$\text{ParamBinds}(\text{params}) = [\langle x, T \rangle \mid \langle \_, x, T \rangle \in \text{params}]$$
$$\text{ProcReturn}(ret\_opt) = \begin{cases}
\text{TypePrim}(\texttt{"()"}) & \text{if } ret\_opt = \bot \\
ret\_opt & \text{otherwise}
\end{cases}$$
$$\text{ReturnAnnOk}(ret\_opt) \iff ret\_opt \ne \bot$$

$$\text{ExplicitReturn}(\text{BlockExpr}(stmts, tail\_opt)) \iff tail\_opt = \bot \land stmts \ne [] \land \text{LastStmt}(stmts) = \text{ReturnStmt}(\_)$$

$$\text{VisRank}(\texttt{public}) = 3 \quad \text{VisRank}(\texttt{internal}) = 2 \quad \text{VisRank}(\texttt{private}) = 1 \quad \text{VisRank}(\texttt{protected}) = 1$$
$$\text{FieldVisOk}(R) \iff \forall f \in \text{Fields}(R).\ \text{VisRank}(f.\text{vis}) \le \text{VisRank}(R.\text{vis})$$
$$\text{StateMemberVisOk}(M) \iff \forall S \in \text{States}(M),\ \forall m \in \text{Payload}(M, S) \cup \text{Methods}(S) \cup \text{Transitions}(S).\\ \text{VisRank}(m.\text{vis}) \le \text{VisRank}(M.\text{vis})$$

**(WF-ProcedureDecl)**
$$\frac{\text{Distinct}(\text{ParamNames}(\text{params})) \quad \text{ReturnAnnOk}(ret\_opt) \quad R = \text{ProcReturn}(ret\_opt) \quad \forall \langle \_, x_i, T_i \rangle \in \text{params},\ \Gamma \vdash T_i\ \text{wf} \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, \text{ParamBinds}(\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; R; \bot \vdash \text{body} : T_b \quad \Gamma \vdash T_b <: R \quad (R \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(\text{body}))}{\Gamma \vdash \text{ProcedureDecl} : \text{ok}}$$

**(WF-ProcedureDecl-MissingReturnType)**
$$\frac{\text{item} = \text{ProcedureDecl}(\_,\_,\_, ret\_opt,\_,\_,\_) \quad \neg \text{ReturnAnnOk}(ret\_opt) \quad c = \text{Code}(\text{WF-ProcedureDecl-MissingReturnType})}{\Gamma \vdash \text{item} \Uparrow c}$$

**(WF-ProcBody-ExplicitReturn-Err)**
$$\frac{\text{item} = \text{ProcedureDecl}(\_,\_,\_, ret\_opt, body,\_,\_) \quad R = \text{ProcReturn}(ret\_opt) \quad R \ne \text{TypePrim}(\texttt{"()"}) \quad \neg \text{ExplicitReturn}(body) \quad c = \text{Code}(\text{WF-ProcBody-ExplicitReturn-Err})}{\Gamma \vdash \text{item} \Uparrow c}$$

$$\text{StaticVisOk}(vis, mut) \iff \neg (vis = \texttt{public} \land mut = \texttt{var})$$

**(WF-StaticDecl)**
$$\frac{\text{binding} = \langle pat, ty\_opt, op, init, \_ \rangle \quad \text{StaticVisOk}(vis, mut) \quad ty\_opt = T_a \quad \Gamma; \bot; \bot \vdash init \Leftarrow T_a \dashv \emptyset \quad \Gamma \vdash pat \Leftarrow T_a \dashv B \quad \text{Distinct}(\text{PatNames}(pat))}{\Gamma \vdash \text{StaticDecl} : \text{ok}}$$

**(WF-StaticDecl-Ann-Mismatch)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, \langle pat, ty\_opt, op, init, \_ \rangle, \_, \_) \quad ty\_opt = T_a \quad \Gamma; \bot; \bot \vdash init \Rightarrow T_i \dashv C \quad \text{Solve}(C) \Downarrow \theta \quad \neg(\Gamma \vdash \theta(T_i) <: T_a) \quad c = \text{Code}(\text{WF-StaticDecl-Ann-Mismatch})}{\Gamma \vdash \text{item} \Uparrow c}$$

**(WF-StaticDecl-MissingType)**
$$\frac{\text{item} = \text{StaticDecl}(\_, \_, \langle pat, ty\_opt, op, init, \_ \rangle, \_, \_) \quad ty\_opt = \bot \quad c = \text{Code}(\text{WF-StaticDecl-MissingType})}{\Gamma \vdash \text{item} \Uparrow c}$$

**(StaticVisOk-Err)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, \_, \_, \_) \quad \neg \text{StaticVisOk}(vis, mut) \quad c = \text{Code}(\text{StaticVisOk-Err})}{\Gamma \vdash \text{item} \Uparrow c}$$

**(WF-RecordDecl)**
$$\frac{\forall f \in \text{Fields}(R),\ \Gamma \vdash f.\text{type}\ \text{wf} \quad \text{FieldVisOk}(R) \quad \Gamma \vdash R\ \text{record wf} \quad \Gamma \vdash \text{Methods}(R) : \text{ok} \quad \Gamma \vdash \text{TypePath}(\text{RecordPath}(R)) : \text{ImplementsOk}}{\Gamma \vdash R\ \text{record} : \text{ok}}$$

**(FieldVisOk-Err)**
$$\frac{R = \text{RecordDecl}(\_,\_,\_,\_,\_,\_) \quad \neg \text{FieldVisOk}(R) \quad c = \text{Code}(\text{FieldVisOk-Err})}{\Gamma \vdash R \Uparrow c}$$

$$\text{EnumPathOf}(E) = \text{FullPath}(\text{ModuleOf}(E), E.\text{name})$$

**Enum Variant Visibility.**

$$\text{VariantVis}(E, v) = \text{Vis}(E)$$
$$\text{VariantVisible}(m, E, v) \iff \Gamma \vdash \text{CanAccess}(m, E) \Downarrow ok$$

**(WF-EnumDecl)**
$$\frac{\text{variants} \ne [] \quad \text{Distinct}([v.\text{name} \mid v \in \text{variants}]) \quad \forall v \in \text{variants},\ \Gamma \vdash v.\text{payload\_opt}\ \text{wf} \quad \text{EnumDiscriminants}(E) \Downarrow \_ \quad \Gamma \vdash \text{TypePath}(\text{EnumPathOf}(E)) : \text{ImplementsOk}}{\Gamma \vdash E\ \text{enum} : \text{ok}}$$

$$\text{PayloadOptWF}(\bot)$$
$$\text{PayloadOptWF}(\text{TuplePayload}([T_1,\ldots,T_n])) \iff \forall i.\ \Gamma \vdash T_i\ \text{wf}$$
$$\text{PayloadOptWF}(\text{RecordPayload}([\langle f_1, T_1 \rangle,\ldots,\langle f_k, T_k \rangle])) \iff \text{Distinct}([f_1,\ldots,f_k]) \land \forall i.\ \Gamma \vdash T_i\ \text{wf}$$

$$\Gamma \vdash payload\_opt\ \text{wf} \iff \text{PayloadOptWF}(payload\_opt)$$

$$\text{ModalPath}(M) = \text{FullPath}(\text{ModuleOf}(M), M.\text{name})$$

**(WF-ModalDecl)**
$$\frac{p = \text{ModalPath}(M) \quad \Gamma \vdash \texttt{modal } M\ \text{wf} \quad \text{StateMemberVisOk}(M) \quad \Gamma \vdash \text{TypePath}(p) : \text{ImplementsOk} \quad \forall S \in \text{States}(M),\ \forall md \in \text{Methods}(S),\ \Gamma \vdash md : \text{StateMethodOK}(M, S) \quad \Gamma \vdash md : \text{StateMethodBodyOK}(p, S) \quad \forall tr \in \text{Transitions}(S),\ \Gamma \vdash tr : \text{TransitionOK}(M, S) \quad \Gamma \vdash tr : \text{TransitionBodyOK}(p, S)}{\Gamma \vdash M\ \text{modal} : \text{ok}}$$

**(StateMemberVisOk-Err)**
$$\frac{M = \text{ModalDecl}(\_,\_,\_,\_,\_,\_) \quad \neg \text{StateMemberVisOk}(M) \quad c = \text{Code}(\text{StateMemberVisOk-Err})}{\Gamma \vdash M \Uparrow c}$$

**(WF-ClassDecl)**
$$\frac{\Gamma \vdash Cl : \text{ClassOk}}{\Gamma \vdash Cl : \text{ok}}$$

**Program Entry Point (Cursive0).**

$$\text{MainDecls}(P) = [\ d \mid m \in P.\text{modules},\ d \in \text{ASTModule}(P, m).\text{items},\ d = \text{ProcedureDecl}(vis,\ name,\ params,\ ret\_opt,\ body,\ span,\ doc),\ name = \texttt{"main"}\ ]$$

$$\text{TypeParams}(\text{ProcedureDecl}(\_)) = []$$
$$\text{MainGeneric}(d) \iff \text{TypeParams}(d) \ne []$$

$$\text{MainSigOk}(d) \iff d = \text{ProcedureDecl}(vis, \texttt{"main"}, params, ret\_opt, \_, \_, \_) \land vis = \texttt{public} \land params = [\langle mode,\ name,\ ty \rangle] \land mode \in \{\bot, \texttt{move}\} \land ty = \text{TypePath}([\texttt{"Context"}]) \land \text{BuiltInContext}(\text{TypePath}([\texttt{"Context"}])) \land ret\_opt = \text{TypePrim}(\texttt{"i32"})$$
$$\text{MainConsumesContext}(d) \iff \text{MainSigOk}(d) \land \exists mode.\ d.\text{params}=[\langle mode,\_,\_\rangle] \land mode=\texttt{move}$$
$$\text{MainRetainsContext}(d) \iff \text{MainSigOk}(d) \land \exists mode.\ d.\text{params}=[\langle mode,\_,\_\rangle] \land mode=\bot$$

$$\text{MainCheck} : \text{Project} \rightharpoonup \text{ok}$$

**(Main-Ok)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P) = [d] \quad \neg \text{MainGeneric}(d) \quad \text{MainSigOk}(d)}{\Gamma \vdash \text{MainCheck}(P) \Downarrow ok}$$

**(Main-Bypass-Lib)**
$$\frac{\neg \text{Executable}(P)}{\Gamma \vdash \text{MainCheck}(P) \Downarrow ok}$$

**(Main-Multiple)**
$$\frac{\text{Executable}(P) \quad |\text{MainDecls}(P)| > 1 \quad c = \text{Code}(\text{Main-Multiple})}{\Gamma \vdash \text{MainCheck}(P) \Uparrow c}$$

**(Main-Generic-Err)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P) = [d] \quad \text{MainGeneric}(d) \quad c = \text{Code}(\text{Main-Generic-Err})}{\Gamma \vdash \text{MainCheck}(P) \Uparrow c}$$

**(Main-Signature-Err)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P) = [d] \quad \neg \text{MainSigOk}(d) \quad c = \text{Code}(\text{Main-Signature-Err})}{\Gamma \vdash \text{MainCheck}(P) \Uparrow c}$$

**(Main-Missing)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P) = [] \quad c = \text{Code}(\text{Main-Missing})}{\Gamma \vdash \text{MainCheck}(P) \Uparrow c}$$

$$\text{MainDiagRefs} = \{\texttt{"8.2"}\}$$

$$\text{Phase3Checks}(P, Ms) = [\Gamma \vdash \text{ResolveModules}(P) \Downarrow Ms,\ \Gamma \vdash \text{DeclTyping}(Ms) \Downarrow ok,\ \Gamma \vdash \text{MainCheck}(P) \Downarrow ok]$$
$$\text{Phase3Order}(P) \iff \exists Ms.\ \text{FirstFail}(\text{Phase3Checks}(P, Ms)) = \bot$$

#### 5.2.15. Binding and Permission State (Cursive0)

**Binding State.**

$$\text{BindingState} ::= \text{Valid} \mid \text{Moved} \mid \text{PartiallyMoved}(F)\quad (F \subseteq \text{Name})$$

**Binding Metadata.**

$$\text{Movability} ::= \text{mov} \mid \text{immov}$$
$$\text{Responsibility} ::= \text{resp} \mid \text{alias}$$
$$\text{Mutability} = \{\texttt{let}, \texttt{var}\}$$
$$\text{BindInfo} ::= \langle \text{state},\ \text{mov},\ \text{mut},\ \text{resp} \rangle\quad (\text{mut} \in \text{Mutability})$$

**Binding Environment.**

$$\text{BindScope} = \text{Map}(\text{Identifier}, \text{BindInfo})$$
$$\mathcal{B} = [\text{BindScope}]$$

$$\text{PushScope}_B(\mathcal{B}) = [\emptyset] \mathbin{+\!\!+} \mathcal{B}$$
$$\text{PopScope}_B([\_]\mathbin{+\!\!+}\mathcal{B}) = \mathcal{B}$$

$$\text{Lookup}_B([\sigma] \mathbin{+\!\!+} \mathcal{B}', x) = \begin{cases}
\sigma[x] & \text{if } x \in \text{dom}(\sigma)\\
\text{Lookup}_B(\mathcal{B}', x) & \text{otherwise}
\end{cases}$$
$$\text{Lookup}_B([], x) = \bot$$

$$\text{Update}_B([\sigma] \mathbin{+\!\!+} \mathcal{B}', x, info) = \begin{cases}
[\sigma[x \mapsto info]] \mathbin{+\!\!+} \mathcal{B}' & \text{if } x \in \text{dom}(\sigma)\\
[\sigma] \mathbin{+\!\!+} \text{Update}_B(\mathcal{B}', x, info) & \text{otherwise}
\end{cases}$$
$$\text{Update}_B([], x, info) = \bot$$

$$\text{Intro}_B([\sigma] \mathbin{+\!\!+} \mathcal{B}', x, info) = [\sigma[x \mapsto info]] \mathbin{+\!\!+} \mathcal{B}'$$
$$\text{ShadowIntro}_B(\mathcal{B}, x, info) = \text{Update}_B(\mathcal{B}, x, info)$$

**Permission of a Type.**

$$\text{PermOf}(\text{TypePerm}(p, T)) = p$$
$$\text{PermOf}(T) = \texttt{const} \quad \text{if } T \ne \text{TypePerm}(\_,\_)$$

**Permission State.**

$$\text{ActiveState} ::= \text{Active} \mid \text{Inactive}$$

$$\text{PermKey} = \text{Identifier} \times \text{FieldPath}$$
$$\text{PermScope} = \text{Map}(\text{PermKey}, \text{ActiveState})$$
$$\Pi = [\text{PermScope}]$$

$$\text{PushScope}_\Pi(\Pi) = [\emptyset] \mathbin{+\!\!+} \Pi$$
$$\text{PopScope}_\Pi([\_]\mathbin{+\!\!+}\Pi) = \Pi$$

$$\text{Lookup}_\Pi([\sigma] \mathbin{+\!\!+} \Pi', k) = \begin{cases}
\text{Inactive} & \text{if } k \in \text{dom}(\sigma) \land \sigma[k] = \text{Inactive}\\
\text{Lookup}_\Pi(\Pi', k) & \text{otherwise}
\end{cases}$$
$$\text{Lookup}_\Pi([], k) = \text{Active}$$

$$\text{Update}_\Pi([\sigma] \mathbin{+\!\!+} \Pi', k, s) = [\sigma[k \mapsto s]] \mathbin{+\!\!+} \Pi'$$

**Join at Control-Flow Merge.**

$$\text{JoinState}(\text{Moved}, s) = \text{Moved}$$
$$\text{JoinState}(s, \text{Moved}) = \text{Moved}$$
$$\text{JoinState}(\text{PartiallyMoved}(F_1), \text{PartiallyMoved}(F_2)) = \text{PartiallyMoved}(F_1 \cup F_2)$$
$$\text{JoinState}(\text{Valid}, \text{PartiallyMoved}(F)) = \text{PartiallyMoved}(F)$$
$$\text{JoinState}(\text{PartiallyMoved}(F), \text{Valid}) = \text{PartiallyMoved}(F)$$
$$\text{JoinState}(\text{Valid}, \text{Valid}) = \text{Valid}$$

$$\text{JoinBindInfo}(\langle s_1, mv_1, mut_1, resp_1 \rangle,\ \langle s_2, mv_2, mut_2, resp_2 \rangle) =
\begin{cases}
\langle \text{JoinState}(s_1,s_2),\ mv_1,\ mut_1,\ resp_1 \rangle & \text{if } mv_1=mv_2 \land mut_1=mut_2 \land resp_1=resp_2\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{JoinScope}_B(B_1,B_2) =
\begin{cases}
\{ x \mapsto \text{JoinBindInfo}(B_1[x], B_2[x]) \mid x \in \text{dom}(B_1) \} & \text{if } \text{dom}(B_1)=\text{dom}(B_2) \land \forall x \in \text{dom}(B_1).\ \text{JoinBindInfo}(B_1[x], B_2[x]) \ne \bot\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{Join}_B([], []) = []$$
$$\text{Join}_B(B_1::\mathcal{B}_1,\ B_2::\mathcal{B}_2) =
\begin{cases}
\text{JoinScope}_B(B_1,B_2) :: \text{Join}_B(\mathcal{B}_1,\mathcal{B}_2) & \text{if } \text{JoinScope}_B(B_1,B_2) \ne \bot \land \text{Join}_B(\mathcal{B}_1,\mathcal{B}_2) \ne \bot\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{Join}_B(\mathcal{B}_1,\mathcal{B}_2) = \bot \quad \text{if } |\mathcal{B}_1| \ne |\mathcal{B}_2|$$

$$\text{JoinPermState}(\text{Active},\text{Active}) = \text{Active}$$
$$\text{JoinPermState}(\_,\_) = \text{Inactive} \quad \text{otherwise}$$

$$\text{PermAt}(B,x) =
\begin{cases}
B[x] & \text{if } x \in \text{dom}(B)\\
\text{Active} & \text{otherwise}
\end{cases}$$

$$\text{JoinScope}_\Pi(B_1,B_2) = \{ x \mapsto \text{JoinPermState}(\text{PermAt}(B_1,x), \text{PermAt}(B_2,x)) \mid x \in \text{dom}(B_1) \cup \text{dom}(B_2) \}$$

$$\text{JoinPerm}([], []) = []$$
$$\text{JoinPerm}(B_1::\Pi_1,\ B_2::\Pi_2) =
\begin{cases}
\text{JoinScope}_\Pi(B_1,B_2) :: \text{JoinPerm}(\Pi_1,\Pi_2) & \text{if } \text{JoinScope}_\Pi(B_1,B_2) \ne \bot \land \text{JoinPerm}(\Pi_1,\Pi_2) \ne \bot\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{JoinPerm}(\Pi_1,\Pi_2) = \bot \quad \text{if } |\Pi_1| \ne |\Pi_2|$$

**Place Roots and Field Heads.**

$$\text{FieldHead}(\text{Identifier}(x)) = \bot$$
$$\text{FieldHead}(\text{FieldAccess}(p,f)) = \begin{cases}
f & \text{if }\text{FieldHead}(p) = \bot\\
\text{FieldHead}(p) & \text{otherwise}
\end{cases}$$
$$\text{FieldHead}(\text{TupleAccess}(p,\_)) = \text{FieldHead}(p)$$
$$\text{FieldHead}(\text{IndexAccess}(p,\_)) = \text{FieldHead}(p)$$
$$\text{FieldHead}(\text{Deref}(p)) = \bot$$

**Access Legality.**

$$\text{AccessStateOk}(\text{Valid}, p) = \text{true}$$
$$\text{AccessStateOk}(\text{PartiallyMoved}(F), p) = (\text{FieldHead}(p)=f \land f \notin F)$$
$$\text{AccessStateOk}(\text{Moved}, p) = \text{false}$$

$$\text{AccessOk}_B(\mathcal{B}, p) \iff x=\text{PlaceRoot}(p) \land \text{Lookup}_B(\mathcal{B}, x)=\langle s,\_,\_,\_ \rangle \land \text{AccessStateOk}(s,p)$$

$$\text{AccessOk}_\Pi(\Pi, p) \iff (\text{PermOf}(\text{ExprType}(p)) \ne \texttt{unique}) \lor \text{AccessPathOk}(\Pi,p)$$

$$\text{AccessOk}(\mathcal{B}, \Pi, p) \iff \text{AccessOk}_B(\mathcal{B}, p) \land \text{AccessOk}_\Pi(\Pi, p)$$

**Binding Introduction.**

$$\text{MovOf}("=") = \text{mov}$$
$$\text{MovOf}(":=") = \text{immov}$$

$$\text{IsMoveExpr}(\text{MoveExpr}(\_)) = \text{true}$$
$$\text{IsMoveExpr}(\_) = \text{false} \quad \text{otherwise}$$

$$\text{RespOfInit}(init) = \begin{cases}
\text{resp} & \text{if } \neg \text{IsPlace}(init)\\
\text{resp} & \text{if } \text{IsMoveExpr}(init)\\
\text{alias} & \text{otherwise}
\end{cases}$$

**Temporary Lifetime.**

$$\text{InitExpr}(\langle \_,\_,\_, init,\_ \rangle) = init$$

$$\text{BindInitScope}(e) = \text{BindScope}(s) \iff
\big(s=\text{LetStmt}(binding) \land \text{InitExpr}(binding)=e\big)\ \lor\
\big(s=\text{VarStmt}(binding) \land \text{InitExpr}(binding)=e\big)\ \lor\
\big(s=\text{ShadowLetStmt}(\_,\_,e)\big)\ \lor\
\big(s=\text{ShadowVarStmt}(\_,\_,e)\big)$$

$$\text{TempScope}(e) =
\begin{cases}
\text{BindInitScope}(e) & \text{if } \text{BindInitScope}(e) \ne \bot\\
\text{StmtScope}(\text{EnclosingStmt}(e)) & \text{otherwise}
\end{cases}$$

$$\text{TempValue}(e) \iff \neg \text{IsPlace}(e)$$

$$\text{TempOrderList}([]) = []$$
$$\text{TempOrderList}([e] \mathbin{+\!\!+} es) = \text{TempOrder}(e) \mathbin{+\!\!+} \text{TempOrderList}(es)$$

$$\text{TempOrder}(e) =
\begin{cases}
\text{TempOrderList}(\text{Children}_{\text{LTR}}(e)) \mathbin{+\!\!+} [e] & \text{if } \text{TempValue}(e)\\
\text{TempOrderList}(\text{Children}_{\text{LTR}}(e)) & \text{otherwise}
\end{cases}$$

$$\text{TempOrderStmt}(s) = \text{TempOrderList}(\text{StmtExprs}(s))$$

$$\text{ControlExpr}(\text{ReturnStmt}(e)) = e \quad \text{ControlExpr}(\text{ResultStmt}(e)) = e \quad \text{ControlExpr}(\text{BreakStmt}(e)) = e$$
$$\text{ControlExpr}(s) = \bot \quad \text{if } s \notin \{\text{ReturnStmt}(\_),\ \text{ResultStmt}(\_),\ \text{BreakStmt}(\_)\}$$

$$\text{TempStmtList}(s) = [\,e \in \text{TempOrderStmt}(s)\mid \text{TempScope}(e) = \text{StmtScope}(s)\ \land\ e \ne \text{ControlExpr}(s)\,]$$
$$\text{TempDropOrder}(s) = \text{Rev}(\text{TempStmtList}(s))$$

**Judgments.**

$$\text{BJudgment} = \{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}' \triangleright \Pi',\ \Gamma;\mathcal{B};\Pi \vdash s \Rightarrow \mathcal{B}' \triangleright \Pi'\}$$

$$\text{ExprType}(e) = T \iff \Gamma;R;L \vdash e : T$$
$$\text{ExprType}(p) = T \iff \text{IsPlace}(p) \land \Gamma;R;L \vdash p :place T$$

$$\text{BindType}(\langle pat, ty\_opt, op, init, \_ \rangle) = T \iff ty\_opt = T$$
$$\text{BindType}(\langle pat, \bot, op, init, \_ \rangle) = \theta(T_i) \iff \Gamma;R;L \vdash init \Rightarrow T_i \dashv C \land \text{Solve}(C) \Downarrow \theta$$
$$\text{BindType}(\text{ShadowLetStmt}(\_, ty\_opt, init)) = T \iff ty\_opt = T$$
$$\text{BindType}(\text{ShadowLetStmt}(\_, \bot, init)) = \theta(T_i) \iff \Gamma;R;L \vdash init \Rightarrow T_i \dashv C \land \text{Solve}(C) \Downarrow \theta$$
$$\text{BindType}(\text{ShadowVarStmt}(\_, ty\_opt, init)) = T \iff ty\_opt = T$$
$$\text{BindType}(\text{ShadowVarStmt}(\_, \bot, init)) = \theta(T_i) \iff \Gamma;R;L \vdash init \Rightarrow T_i \dashv C \land \text{Solve}(C) \Downarrow \theta$$

$$\text{MapUnion}(M_1, M_2) = \{ x \mapsto (M_2[x] \ \text{if } x \in \text{dom}(M_2)\ \text{else } M_1[x]) \mid x \in \text{dom}(M_1) \cup \text{dom}(M_2) \}$$

$$\text{IntroAll}_B([\sigma] \mathbin{+\!\!+} \mathcal{B}', B) = [\text{MapUnion}(\sigma, B)] \mathbin{+\!\!+} \mathcal{B}'$$

$$\text{ShadowAll}_B(\mathcal{B}, B) = \text{ShadowAll}_B(\mathcal{B}, \text{Entries}(B))$$
$$\text{ShadowAll}_B(\mathcal{B}, []) = \mathcal{B}$$
$$\text{ShadowAll}_B(\mathcal{B}, [\langle x, info \rangle] \mathbin{+\!\!+} xs) = \text{ShadowAll}_B(\text{ShadowIntro}_B(\mathcal{B}, x, info), xs)$$

$$\text{BindInfoMap}(f, B, mv, mut) = \{ x \mapsto \langle \text{Valid}, \text{MovEff}(mv, f(B[x])), mut, f(B[x]) \rangle \mid x \in \text{dom}(B) \}$$

$$\text{MovEff}(mv, \text{resp}) = mv \quad\quad \text{MovEff}(mv, \text{alias}) = \text{immov}$$

$$T_{\text{Region}} = \text{TypeModalState}([\texttt{Region}], \texttt{Active})$$
$$\text{RegionBindName}(\Gamma, alias\_opt) = \begin{cases}
alias\_opt & \text{if } alias\_opt \ne \bot\\
\text{FreshRegion}(\Gamma) & \text{otherwise}
\end{cases}$$
$$\text{RegionBindMap}(\Gamma, alias\_opt) = \{ r \mapsto T_{\text{Region}} \mid r = \text{RegionBindName}(\Gamma, alias\_opt) \}$$
$$\text{RegionBindInfo}(\Gamma, alias\_opt) = \text{BindInfoMap}(\lambda U.\ \text{resp}, \text{RegionBindMap}(\Gamma, alias\_opt), \text{mov}, \texttt{let})$$
$$\text{FrameBindInfo}(\Gamma) = \text{RegionBindInfo}(\Gamma, \bot)$$

$$\text{Names}(B) = \text{dom}(B)$$

$$\text{JoinAll}_B([]) = \bot$$
$$\text{JoinAll}_B([\mathcal{B}]) = \mathcal{B}$$
$$\text{JoinAll}_B(\mathcal{B}_1::\mathcal{B}_2::rest) = \text{JoinAll}_B([\text{Join}_B(\mathcal{B}_1,\mathcal{B}_2)] \mathbin{+\!\!+} rest)$$

$$\text{JoinAllPerm}([]) = \bot$$
$$\text{JoinAllPerm}([\Pi]) = \Pi$$
$$\text{JoinAllPerm}(\Pi_1::\Pi_2::rest) = \text{JoinAllPerm}([\text{JoinPerm}(\Pi_1,\Pi_2)] \mathbin{+\!\!+} rest)$$

$$\text{Top}([\sigma] \mathbin{+\!\!+} \Pi') = \sigma$$

$$\text{SetTop}([\sigma] \mathbin{+\!\!+} \Pi', \sigma') = [\sigma'] \mathbin{+\!\!+} \Pi'$$

$$\text{InactivateScope}(\sigma, K) = \{ x \mapsto (\text{Inactive}\ \text{if } x \in K\ \text{else } \sigma[x]) \mid x \in \text{dom}(\sigma) \cup K \}$$

$$\text{Roots}(\Pi_2, \Pi_1) = \{ k \mid \text{Top}(\Pi_2)[k] = \text{Inactive} \land \text{Lookup}_\Pi(\Pi_1, k) = \text{Active} \}$$

$$\text{ConsumeOnMove}(\mathcal{B}, e) =
\begin{cases}
\text{Update}_B(\mathcal{B}, x, \langle \text{Moved}, mv, mut, resp \rangle) & \text{if } \text{IsMoveExpr}(e) \land x=\text{PlaceRoot}(\text{MoveInner}(e)) \land \text{Lookup}_B(\mathcal{B}, x)=\langle s, mv, mut, resp \rangle\\
\mathcal{B} & \text{otherwise}
\end{cases}$$

$$\text{MoveInner}(\text{MoveExpr}(p)) = p$$

$$\text{OptList}(\bot) = []$$
$$\text{OptList}(e) = [e] \quad \text{if } e \ne \bot$$

$$\text{StmtExprs}(\text{LetStmt}(\langle \_,\_,\_, init,\_ \rangle)) = [init]$$
$$\text{StmtExprs}(\text{VarStmt}(\langle \_,\_,\_, init,\_ \rangle)) = [init]$$
$$\text{StmtExprs}(\text{ShadowLetStmt}(\_,\_,init)) = [init]$$
$$\text{StmtExprs}(\text{ShadowVarStmt}(\_,\_,init)) = [init]$$
$$\text{StmtExprs}(\text{AssignStmt}(p,e)) = [e,p]$$
$$\text{StmtExprs}(\text{CompoundAssignStmt}(p,\_,e)) = [p,e]$$
$$\text{StmtExprs}(\text{ExprStmt}(e)) = [e]$$
$$\text{StmtExprs}(\text{ReturnStmt}(e\_opt)) = \text{OptList}(e\_opt)$$
$$\text{StmtExprs}(\text{ResultStmt}(e)) = [e]$$
$$\text{StmtExprs}(\text{BreakStmt}(e\_opt)) = \text{OptList}(e\_opt)$$
$$\text{StmtExprs}(\text{ContinueStmt}) = []$$
$$\text{StmtExprs}(\text{DeferStmt}(\_)) = []$$
$$\text{StmtExprs}(\text{UnsafeBlockStmt}(b)) = [b]$$
$$\text{StmtExprs}(\text{RegionStmt}(opts\_opt,\_, b)) = [\text{RegionOptsExpr}(opts\_opt), b]$$
$$\text{StmtExprs}(\text{FrameStmt}(\_, b)) = [b]$$
$$\text{StmtExprs}(\text{ErrorStmt}(\_)) = []$$

$$\text{StmtScope}(s) = s$$
$$\text{BindScope}(s) = \text{BlockOfStmt}(s)$$
$$\text{EnclosingStmt}(e) = s \iff e \in \text{SubExprs}(s) \land \forall s' \in \text{SubStmts}(s).\ e \notin \text{SubExprs}(s')$$
$$\text{BlockOfStmt}(s) = b \iff s \in \text{BlockStmts}(b) \land \forall b' \in \text{SubBlocks}(b).\ s \notin \text{BlockStmts}(b')$$

$$\text{BlockStmts}(\text{BlockExpr}(stmts,\_)) = stmts$$

$$\text{StmtBlocks}(\text{UnsafeBlockStmt}(b)) = [b]$$
$$\text{StmtBlocks}(\text{DeferStmt}(b)) = [b]$$
$$\text{StmtBlocks}(\text{RegionStmt}(\_,\_,b)) = [b]$$
$$\text{StmtBlocks}(\text{FrameStmt}(\_,b)) = [b]$$
$$\text{StmtBlocks}(s) = [] \quad \text{if } s \notin \{\text{UnsafeBlockStmt}(\_),\ \text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_)\}$$

$$\text{SubExprs}(s) = \text{SubExprsList}(\text{StmtExprs}(s))$$
$$\text{SubExprsList}([]) = \emptyset$$
$$\text{SubExprsList}([e] \mathbin{+\!\!+} es) = \{e\} \cup \text{SubExprsList}(\text{Children}_{\text{LTR}}(e)) \cup \text{SubExprsList}(es)$$

$$\text{SubStmts}(s) = \text{SubStmtsList}(\text{StmtBlocks}(s))$$
$$\text{SubStmtsList}([]) = \emptyset$$
$$\text{SubStmtsList}([b] \mathbin{+\!\!+} bs) = \text{BlockStmts}(b) \cup \text{SubStmtsSeq}(\text{BlockStmts}(b)) \cup \text{SubStmtsList}(bs)$$
$$\text{SubStmtsSeq}([]) = \emptyset$$
$$\text{SubStmtsSeq}([s] \mathbin{+\!\!+} ss) = \text{SubStmts}(s) \cup \text{SubStmtsSeq}(ss)$$

$$\text{SubBlocks}(b) = \text{SubBlocksSeq}(\text{BlockStmts}(b))$$
$$\text{SubBlocksSeq}([]) = \emptyset$$
$$\text{SubBlocksSeq}([s] \mathbin{+\!\!+} ss) = \text{StmtBlocks}(s) \cup \bigcup_{b' \in \text{StmtBlocks}(s)} \text{SubBlocks}(b') \cup \text{SubBlocksSeq}(ss)$$

$$\text{Entries}(B) = [\langle x_1, B[x_1] \rangle,\ldots,\langle x_n, B[x_n] \rangle] \iff [x_1,\ldots,x_n]\ \text{enumerates}\ \text{dom}(B)\ \text{without repetition}$$

$$\text{SynthParams}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle]) = [\langle m_1, \bot, T_1 \rangle,\ldots,\langle m_n, \bot, T_n \rangle]$$

$$\text{CalleeProc}(\text{Identifier}(x)) = proc \iff \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \land \text{DeclOf}(mp, name) = proc \land proc = \text{ProcedureDecl}(\_)$$
$$\text{CalleeProc}(\text{Path}(path, name)) = proc \iff \Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \land \text{DeclOf}(mp, name') = proc \land proc = \text{ProcedureDecl}(\_)$$

$$\text{Params}(\text{Call}(callee, args)) =
\begin{cases}
proc.\text{params} & \text{if } \text{CalleeProc}(callee) = proc\\
\text{SynthParams}(params) & \text{if } \text{ExprType}(callee) = \text{TypeFunc}(params, \_)\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{MethodOf}(base, name) = m \iff \text{LookupMethod}(\text{StripPerm}(\text{ExprType}(base)), name) = m$$
$$\text{RecvBase}(base, name) = T \iff \text{MethodOf}(base, name) = m \land T = \text{StripPerm}(\text{ExprType}(base))$$

$$\text{RecvParams}(base, name) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(T, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params} \iff \text{MethodOf}(base, name) = m \land \text{RecvBase}(base, name) = T$$

**Static Binding Maps (Module Scope).**

$$\text{StaticBindTypesMod}(P, m) = \mathbin{+\!\!+}_{\text{item} \in \text{ASTModule}(P, m).\text{items},\ \text{item}=\text{StaticDecl}(\_,\_,binding,\_,\_)} \text{StaticBindTypes}(binding)$$

$$\text{StaticBindInfo}(\text{item}) = \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init),\ \text{StaticBindTypes}(binding),\ \text{MovOf}(op),\ mut)\ \iff\ \text{item}=\text{StaticDecl}(\_, mut, binding, \_, \_) \land binding = \langle \_, \_, op, init, \_ \rangle$$

$$\text{StaticBindMap}(P, m) = \mathbin{+\!\!+}_{\text{item} \in \text{ASTModule}(P, m).\text{items},\ \text{item}=\text{StaticDecl}(\_,\_,\_,\_,\_)} \text{StaticBindInfo}(\text{item})$$

**Procedure Entry.**

$$\mathcal{B}_{\text{global}} = \text{IntroAll}_B(\text{PushScope}_B(\mathcal{B}), \text{StaticBindMap}(\text{Project}(\Gamma), m))$$
$$\mathcal{B}_{\text{proc}} = \text{IntroAll}_B(\text{PushScope}_B(\mathcal{B}_{\text{global}}), \text{ParamBindMap}(params))$$

$$\text{ParamBindMap}([]) = \emptyset$$
$$\text{ParamBindMap}([\langle mode, x, T \rangle] \mathbin{+\!\!+} ps) = \text{MapUnion}(\text{ParamBindMap}(ps), \{ x \mapsto \langle \text{Valid}, \text{ParamMov}(mode), \texttt{let}, \text{ParamResp}(mode) \rangle \})$$
$$\text{MethodParamBindMap}(base, name) = \text{ParamBindMap}(\text{RecvParams}(base, name))$$

$$\text{ParamTypeMap}([]) = \emptyset$$
$$\text{ParamTypeMap}([\langle mode, x, T \rangle] \mathbin{+\!\!+} ps) = \text{MapUnion}(\text{ParamTypeMap}(ps), \{ x \mapsto T \})$$

$$\text{ParamMov}(\texttt{move}) = \text{mov} \quad\quad \text{ParamMov}(\bot) = \text{immov}$$
$$\text{ParamResp}(\texttt{move}) = \text{resp} \quad\quad \text{ParamResp}(\bot) = \text{alias}$$

$$B_{\text{params}} = \text{ParamTypeMap}(params)$$
$$B_{\text{static}} = \text{StaticBindTypesMod}(\text{Project}(\Gamma), m)$$
$$\Pi_{\text{global}} = [\{ x \mapsto \text{Active} \mid (x:T) \in B_{\text{static}} \land \text{PermOf}(T)=\texttt{unique} \}]$$
$$\Pi_{\text{proc}} = [\{ x \mapsto \text{Active} \mid (x:T) \in B_{\text{params}} \land \text{PermOf}(T)=\texttt{unique} \}] \mathbin{+\!\!+} \Pi_{\text{global}}$$

**Expression Rules (Selected).**

**(B-Place)**
$$\frac{\text{IsPlace}(p) \quad \text{AccessOk}(\mathcal{B}, \Pi, p)}{\Gamma; \mathcal{B}; \Pi \vdash p \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-Place-Unique-Err)**
$$\frac{\text{IsPlace}(p) \quad \Gamma; R; L \vdash p : T_p \quad \text{PermOf}(T_p)=\texttt{unique} \quad \neg \text{AccessPathOk}(\Pi, p) \quad c = \text{Code}(\text{B-Place-Unique-Err})}{\Gamma; \mathcal{B}; \Pi \vdash p \Uparrow c}$$

**(B-Place-Moved-Err)**
$$\frac{\text{IsPlace}(p) \quad \Gamma; R; L \vdash p : T_p \quad x = \text{PlaceRoot}(p) \quad \text{Lookup}_B(\mathcal{B}, x)=\langle s, \_, \_, \_ \rangle \quad (s=\text{Moved} \ \lor\ (s=\text{PartiallyMoved}(F) \land (\text{FieldHead}(p)=\bot \ \lor\ \text{FieldHead}(p) \in F))) \quad (\text{PermOf}(T_p) \ne \texttt{unique} \ \lor\ \text{AccessPathOk}(\Pi, p)) \quad c = \text{Code}(\text{B-Place-Moved-Err})}{\Gamma; \mathcal{B}; \Pi \vdash p \Uparrow c}$$

**(B-Move-Whole)**
$$\frac{\text{IsPlace}(p) \quad x=\text{PlaceRoot}(p) \quad \text{FieldHead}(p)=\bot \quad \text{Lookup}_B(\mathcal{B}, x)=\langle \text{Valid}, mv, m, r \rangle \quad mv=\text{mov}}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Rightarrow \text{Update}_B(\mathcal{B}, x, \langle \text{Moved}, \text{mov}, m, r \rangle) \triangleright \Pi}$$

**(B-Move-Field)**
$$\frac{\text{IsPlace}(p) \quad x=\text{PlaceRoot}(p) \quad \text{FieldHead}(p)=f \quad \Gamma; R; L \vdash p : T_p \quad \text{PermOf}(T_p)=\texttt{unique} \quad \text{Lookup}_B(\mathcal{B}, x)=\langle s, mv, m, r \rangle \quad mv=\text{mov}}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Rightarrow \text{Update}_B(\mathcal{B}, x, \langle \text{PM}(s,f), \text{mov}, m, r \rangle) \triangleright \Pi}$$

$$\text{PM}(\text{Valid}, f) = \text{PartiallyMoved}(\{f\})$$
$$\text{PM}(\text{PartiallyMoved}(F), f) = \text{PartiallyMoved}(F \cup \{f\})$$
$$\text{PM}(\text{Moved}, f) = \bot$$

**(B-Move-Whole-Moved-Err)**
$$\frac{\text{IsPlace}(p) \quad \text{FieldHead}(p)=\bot \quad x = \text{PlaceRoot}(p) \quad \text{Lookup}_B(\mathcal{B}, x)=\langle s, mv, \_, \_ \rangle \quad s \ne \text{Valid} \quad mv=\text{mov} \quad c = \text{Code}(\text{B-Move-Whole-Moved-Err})}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

**(B-Move-Field-Moved-Err)**
$$\frac{\text{IsPlace}(p) \quad \text{FieldHead}(p)=f \quad x = \text{PlaceRoot}(p) \quad \Gamma; R; L \vdash p : T_p \quad \text{PermOf}(T_p)=\texttt{unique} \quad \text{Lookup}_B(\mathcal{B}, x)=\langle s, mv, \_, \_ \rangle \quad (s=\text{Moved} \ \lor\ (s=\text{PartiallyMoved}(F) \land f \in F)) \quad mv=\text{mov} \quad c = \text{Code}(\text{B-Move-Field-Moved-Err})}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

**(B-Move-Field-NonUnique-Err)**
$$\frac{\text{IsPlace}(p) \quad \text{FieldHead}(p)=f \quad x = \text{PlaceRoot}(p) \quad \Gamma; R; L \vdash p : T_p \quad \text{PermOf}(T_p)\ne\texttt{unique} \quad \text{Lookup}_B(\mathcal{B}, x)=\langle \_, mv, \_, \_ \rangle \quad mv=\text{mov} \quad c = \text{Code}(\text{B-Move-Field-NonUnique-Err})}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

**(B-Move-Whole-Immovable-Err)**
$$\frac{\text{IsPlace}(p) \quad \text{FieldHead}(p)=\bot \quad x = \text{PlaceRoot}(p) \quad \text{Lookup}_B(\mathcal{B}, x)=\langle \_, mv, \_, \_ \rangle \quad mv=\text{immov} \quad c = \text{Code}(\text{B-Move-Whole-Immovable-Err})}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

**(B-Move-Field-Immovable-Err)**
$$\frac{\text{IsPlace}(p) \quad \text{FieldHead}(p)=f \quad x = \text{PlaceRoot}(p) \quad \text{Lookup}_B(\mathcal{B}, x)=\langle \_, mv, \_, \_ \rangle \quad mv=\text{immov} \quad c = \text{Code}(\text{B-Move-Field-Immovable-Err})}{\Gamma; \mathcal{B}; \Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

$$\text{BExprRules} = \{\text{B-Place},\ \text{B-Move-Whole},\ \text{B-Move-Field},\ \text{B-Call},\ \text{B-MethodCall},\ \text{B-Transition},\ \text{B-Expr-Sub}\}$$

$$\text{NoSpecificBExpr}(e) \iff \neg \exists r \in \text{BExprRules} \setminus \{\text{B-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(B-Expr-Sub)**
$$\frac{\text{NoSpecificBExpr}(e) \quad \text{Children}_{\text{LTR}}(e) = [e_1,\ldots,e_n] \quad \Gamma;\mathcal{B}_0;\Pi_0 \vdash e_1 \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \ \cdots\ \Gamma;\mathcal{B}_{n-1};\Pi_{n-1} \vdash e_n \Rightarrow \mathcal{B}_n \triangleright \Pi_n}{\Gamma;\mathcal{B}_0;\Pi_0 \vdash e \Rightarrow \mathcal{B}_n \triangleright \Pi_n}$$

**Call and Method Argument Passing.**

**Field-Path Permission Tracking.**

$$\text{FieldPath} = [\text{Name}]$$

$$\text{FieldPathOf}(\text{Identifier}(x)) = []$$
$$\text{FieldPathOf}(\text{FieldAccess}(p,f)) = \text{FieldPathOf}(p) \mathbin{+\!\!+} [f]$$
$$\text{FieldPathOf}(\text{TupleAccess}(p,\_)) = \text{FieldPathOf}(p)$$
$$\text{FieldPathOf}(\text{IndexAccess}(p,\_)) = \text{FieldPathOf}(p)$$
$$\text{FieldPathOf}(\text{Deref}(p)) = []$$

$$\text{PlacePath}(p) = \begin{cases}
(\text{PlaceRoot}(p), []) & \text{if } p = \text{Identifier}(x) \\
(\text{PlaceRoot}(p), \text{FieldPathOf}(p)) & \text{otherwise}
\end{cases}$$

$$\text{Prefixes}([]) = [[]]$$
$$\text{Prefixes}([f] \mathbin{+\!\!+} fs) = [[]] \cup \{ [f] \mathbin{+\!\!+} p \mid p \in \text{Prefixes}(fs) \}$$
$$\text{AncPaths}(p) = \{ (\text{PlaceRoot}(p), fp) \mid fp \in \text{Prefixes}(\text{FieldPathOf}(p)) \}$$

$$\text{AccessPathOk}(\Pi, p) \iff \forall k \in \text{AncPaths}(p).\ \text{Lookup}_\Pi(\Pi, k) = \text{Active}$$

$$\text{DowngradeUniquePath}(\Pi, mode, p) = \begin{cases}
\text{SetTop}(\Pi, \text{InactivateScope}(\text{Top}(\Pi), \text{AncPaths}(p))) & \text{if } mode = \bot \land \text{IsPlace}(p) \land \text{PermOf}(\text{ExprType}(p)) = \texttt{unique} \\
\Pi & \text{otherwise}
\end{cases}$$

$$\text{DowngradeUnique}(\Pi, mode, e) = \begin{cases}
\text{DowngradeUniquePath}(\Pi, mode, e) & \text{if } \text{IsPlace}(e) \\
\Pi & \text{otherwise}
\end{cases}$$

$$\text{DowngradeUniqueBind}(\Pi, init, T_b) = \begin{cases}
\text{DowngradeUniquePath}(\Pi, \bot, init) & \text{if } \text{IsPlace}(init) \land \text{PermOf}(\text{ExprType}(init)) = \texttt{unique} \land \text{PermOf}(T_b) = \texttt{const} \\
\Pi & \text{otherwise}
\end{cases}$$

$$\text{RemoveKeys}(\sigma, D) = \{ k \mapsto \sigma[k] \mid k \in \text{dom}(\sigma) \land k \notin D \}$$
$$\text{Reactivate}([\sigma] \mathbin{+\!\!+} \Pi', D) = [\text{RemoveKeys}(\sigma, D)] \mathbin{+\!\!+} \Pi'$$

$$\text{ArgPassExpr}(mode, moved, e) =
\begin{cases}
\text{MovedArg}(moved, e) & \text{if } mode = \texttt{move} \land moved = \text{true} \\
e & \text{otherwise}
\end{cases}$$

$$\text{ArgPassJudg} = \{\Gamma; \mathcal{B}; \Pi \vdash \text{ArgPass}(params, args) \Rightarrow \mathcal{B}' \triangleright \Pi', D\}$$

**(B-ArgPass-Empty)**
$$\frac{}{\Gamma; \mathcal{B}; \Pi \vdash \text{ArgPass}([], []) \Rightarrow \mathcal{B} \triangleright \Pi,\ \emptyset}$$

**(B-ArgPass-Move-Missing)**
$$\frac{params = [\langle \texttt{move},\_,T_p\rangle]\mathbin{+\!\!+}ps \quad args = [\langle moved, e, \_ \rangle]\mathbin{+\!\!+}as \quad moved = \text{false} \quad c = \text{Code}(\text{B-ArgPass-Move-Missing})}{\Gamma; \mathcal{B}; \Pi \vdash \text{ArgPass}(params, args) \Uparrow c}$$

**(B-ArgPass-Cons)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash \text{ArgPassExpr}(mode, moved, e) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad (mode = \bot \Rightarrow \text{IsPlace}(e)) \quad \Pi_2 = \text{DowngradeUnique}(\Pi_1, mode, e) \quad \Gamma;\mathcal{B}_1;\Pi_2 \vdash \text{ArgPass}(ps, as) \Rightarrow \mathcal{B}_2 \triangleright \Pi_3,\ D}{\Gamma;\mathcal{B};\Pi \vdash \text{ArgPass}([\langle mode,\_,T_p\rangle]\mathbin{+\!\!+}ps,\ [\langle moved,e,\_\rangle]\mathbin{+\!\!+}as) \Rightarrow \mathcal{B}_2 \triangleright \Pi_3,\ D \cup \text{Roots}(\Pi_2,\Pi_1)}$$

**(B-Call)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash f \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad \Gamma;\mathcal{B}_1;\Pi_1 \vdash \text{ArgPass}(\text{Params}(\text{Call}(f,args)), args) \Rightarrow \mathcal{B}_2 \triangleright \Pi_2,\ D \quad \Pi_3 = \text{Reactivate}(\Pi_2, D)}{\Gamma;\mathcal{B};\Pi \vdash \text{Call}(f, args) \Rightarrow \mathcal{B}_2 \triangleright \Pi_3}$$

**(B-MethodCall)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash base \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad \Gamma;\mathcal{B}_1;\Pi_1 \vdash \text{ArgPass}(\text{RecvParams}(base, name), args) \Rightarrow \mathcal{B}_2 \triangleright \Pi_2,\ D \quad \Pi_3 = \text{Reactivate}(\Pi_2, D)}{\Gamma;\mathcal{B};\Pi \vdash \text{MethodCall}(base, name, args) \Rightarrow \mathcal{B}_2 \triangleright \Pi_3}$$

**(B-Transition)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e_{self} \Rightarrow \mathcal{B}_0 \triangleright \Pi_0 \quad x = \text{PlaceRoot}(e_{self}) \quad \text{Lookup}_B(\mathcal{B}_0, x) = \langle Valid, mov, m, r \rangle \quad mov = mov \quad \mathcal{B}_1 = \text{Update}_B(\mathcal{B}_0, x, \langle Moved, mov, m, r \rangle) \quad \Gamma;\mathcal{B}_1;\Pi_0 \vdash \text{ArgPass}(tr.params, args) \Rightarrow \mathcal{B}_2 \triangleright \Pi_1,\ D}{\Gamma;\mathcal{B};\Pi \vdash e_{self} \twoheadrightarrow t(args) \Rightarrow \mathcal{B}_2 \triangleright \text{Reactivate}(\Pi_1, D)}$$

**Statement Rules (Selected).**

**(B-Seq-Empty)**
$$\frac{}{\Gamma;\mathcal{B};\Pi \vdash [] \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-Seq-Cons)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash s \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad \Gamma;\mathcal{B}_1;\Pi_1 \vdash ss \Rightarrow \mathcal{B}_2 \triangleright \Pi_2}{\Gamma;\mathcal{B};\Pi \vdash s::ss \Rightarrow \mathcal{B}_2 \triangleright \Pi_2}$$

**(B-LetVar-UniqueNonMove-Err)**
$$\frac{T_b = \text{BindType}(\langle pat, ty\_opt, op, init, \_\rangle) \quad \text{PermOf}(T_b) = \texttt{unique} \quad \text{IsPlace}(init) \quad \neg \text{IsMoveExpr}(init) \quad c = \text{Code}(\text{B-LetVar-UniqueNonMove-Err})}{\Gamma;\mathcal{B};\Pi \vdash \text{LetOrVarStmt}(\langle pat, ty\_opt, op, init, \_\rangle) \Uparrow c}$$

**(B-LetVar)**
$$\frac{\Gamma; \mathcal{B}; \Pi \vdash init \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad T_b = \text{BindType}(\langle pat, ty\_opt, op, init, \_\rangle) \quad \Pi_2 = \text{DowngradeUniqueBind}(\Pi_1, init, T_b) \quad \mathcal{B}_2 = \text{ConsumeOnMove}(\mathcal{B}_1, init) \quad \Gamma \vdash pat \Leftarrow T_b \dashv B \quad \mathcal{B}_3 = \text{IntroAll}_B(\mathcal{B}_2, \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init), B, \text{MovOf}(op), mut))}{\Gamma;\mathcal{B};\Pi \vdash \text{LetOrVarStmt}(\langle pat, ty\_opt, op, init, \_\rangle) \Rightarrow \mathcal{B}_3 \triangleright \Pi_2}$$

**(B-ShadowLet-UniqueNonMove-Err)**
$$\frac{T_b = \text{BindType}(\text{ShadowLetStmt}(x, ty\_opt, init)) \quad \text{PermOf}(T_b) = \texttt{unique} \quad \text{IsPlace}(init) \quad \neg \text{IsMoveExpr}(init) \quad c = \text{Code}(\text{B-ShadowLet-UniqueNonMove-Err})}{\Gamma;\mathcal{B};\Pi \vdash \text{ShadowLetStmt}(x, ty\_opt, init) \Uparrow c}$$

**(B-ShadowLet)**
$$\frac{\Gamma; \mathcal{B}; \Pi \vdash init \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad T_b = \text{BindType}(\text{ShadowLetStmt}(x, ty\_opt, init)) \quad \Pi_2 = \text{DowngradeUniqueBind}(\Pi_1, init, T_b) \quad \mathcal{B}_2 = \text{ConsumeOnMove}(\mathcal{B}_1, init) \quad B = \{ x \mapsto T_b \} \quad \mathcal{B}_3 = \text{ShadowAll}_B(\mathcal{B}_2, \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init), B, \text{MovOf}("="), \texttt{let}))}{\Gamma;\mathcal{B};\Pi \vdash \text{ShadowLetStmt}(x, ty\_opt, init) \Rightarrow \mathcal{B}_3 \triangleright \Pi_2}$$

**(B-ShadowVar-UniqueNonMove-Err)**
$$\frac{T_b = \text{BindType}(\text{ShadowVarStmt}(x, ty\_opt, init)) \quad \text{PermOf}(T_b) = \texttt{unique} \quad \text{IsPlace}(init) \quad \neg \text{IsMoveExpr}(init) \quad c = \text{Code}(\text{B-ShadowVar-UniqueNonMove-Err})}{\Gamma;\mathcal{B};\Pi \vdash \text{ShadowVarStmt}(x, ty\_opt, init) \Uparrow c}$$

**(B-ShadowVar)**
$$\frac{\Gamma; \mathcal{B}; \Pi \vdash init \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad T_b = \text{BindType}(\text{ShadowVarStmt}(x, ty\_opt, init)) \quad \Pi_2 = \text{DowngradeUniqueBind}(\Pi_1, init, T_b) \quad \mathcal{B}_2 = \text{ConsumeOnMove}(\mathcal{B}_1, init) \quad B = \{ x \mapsto T_b \} \quad \mathcal{B}_3 = \text{ShadowAll}_B(\mathcal{B}_2, \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init), B, \text{MovOf}("="), \texttt{var}))}{\Gamma;\mathcal{B};\Pi \vdash \text{ShadowVarStmt}(x, ty\_opt, init) \Rightarrow \mathcal{B}_3 \triangleright \Pi_2}$$

**(B-ExprStmt)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{ExprStmt}(e) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}$$

**(B-ResultStmt)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{ResultStmt}(e) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}$$

**(B-UnsafeStmt)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash b \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{UnsafeBlockStmt}(b) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}$$

**(B-Defer)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash b \Rightarrow \mathcal{B}_1 \triangleright \Pi_1 \quad \mathcal{B}_1 = \mathcal{B} \quad \Pi_1 = \Pi}{\Gamma;\mathcal{B};\Pi \vdash \text{DeferStmt}(b) \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-RegionStmt)**
$$\frac{(opts\_opt = \bot \Rightarrow \mathcal{B}_0 = \mathcal{B} \land \Pi_0 = \Pi)\ \land\ (opts\_opt = e \Rightarrow \Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_0 \triangleright \Pi_0)\quad \mathcal{B}_1 = \text{PushScope}_B(\mathcal{B}_0) \quad \Pi_1 = \text{PushScope}_\Pi(\Pi_0) \quad \mathcal{B}_2 = \text{IntroAll}_B(\mathcal{B}_1, \text{RegionBindInfo}(\Gamma, alias\_opt)) \quad \Gamma;\mathcal{B}_2;\Pi_1 \vdash b \Rightarrow \mathcal{B}_3 \triangleright \Pi_2}{\Gamma;\mathcal{B};\Pi \vdash \text{RegionStmt}(opts\_opt, alias\_opt, b) \Rightarrow \text{PopScope}_B(\mathcal{B}_3) \triangleright \text{PopScope}_\Pi(\Pi_2)}$$

**(B-FrameStmt)**
$$\frac{\mathcal{B}_1 = \text{PushScope}_B(\mathcal{B}) \quad \Pi_1 = \text{PushScope}_\Pi(\Pi) \quad \mathcal{B}_2 = \text{IntroAll}_B(\mathcal{B}_1, \text{FrameBindInfo}(\Gamma)) \quad \Gamma;\mathcal{B}_2;\Pi_1 \vdash b \Rightarrow \mathcal{B}_3 \triangleright \Pi_2}{\Gamma;\mathcal{B};\Pi \vdash \text{FrameStmt}(r\_opt, b) \Rightarrow \text{PopScope}_B(\mathcal{B}_3) \triangleright \text{PopScope}_\Pi(\Pi_2)}$$

**(B-Assign-Immutable-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \text{IsPlace}(p) \quad \text{PlaceRoot}(p)=x \quad \text{Lookup}_B(\mathcal{B}, x)=\langle \_, \_, \texttt{let}, \_ \rangle \quad c = \text{Code}(\text{B-Assign-Immutable-Err})}{\Gamma;\mathcal{B};\Pi \vdash stmt \Uparrow c}$$

**(B-Assign)**
$$\frac{\text{IsPlace}(p) \quad \text{PlaceRoot}(p)=x \quad \text{Lookup}_B(\mathcal{B},x)=\langle s, mov, \texttt{var}, r \rangle \quad \Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{AssignStmt}(p,e) \Rightarrow \text{Update}_B(\mathcal{B}_1, x, \langle \text{Valid}, mov, \texttt{var}, r \rangle) \triangleright \Pi_1}$$

**(B-Assign-Const-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,op,e)\} \quad \Gamma; R; L \vdash p : \text{TypePerm}(\texttt{const}, T) \quad c = \text{Code}(\text{B-Assign-Const-Err})}{\Gamma;\mathcal{B};\Pi \vdash stmt \Uparrow c}$$

**(B-If)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash c \Rightarrow \mathcal{B}_c \triangleright \Pi_c \quad \Gamma;\mathcal{B}_c;\Pi_c \vdash b_t \Rightarrow \mathcal{B}_t \triangleright \Pi_t \quad \Gamma;\mathcal{B}_c;\Pi_c \vdash b_f \Rightarrow \mathcal{B}_f \triangleright \Pi_f}{\Gamma;\mathcal{B};\Pi \vdash \text{IfExpr}(c,b_t,b_f) \Rightarrow \text{Join}_B(\mathcal{B}_t,\mathcal{B}_f) \triangleright \text{JoinPerm}(\Pi_t,\Pi_f)}$$

**(B-Match)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_0 \triangleright \Pi_0 \quad \Gamma;R;L \vdash e : T \quad moved = \text{IsMoveExpr}(e) \quad \mathcal{B}_1 = \text{ConsumeOnMove}(\mathcal{B}_0, e) \quad \forall i,\ \Gamma;\text{PushScope}_B(\mathcal{B}_1);\text{PushScope}_\Pi(\Pi_0) \vdash \text{Arm}(moved, p_i, g_i, b_i) \Rightarrow \mathcal{B}_i \triangleright \Pi_i}{\Gamma;\mathcal{B};\Pi \vdash \text{MatchExpr}(e, arms) \Rightarrow \text{JoinAll}_B([\mathcal{B}_i]) \triangleright \text{JoinAllPerm}([\Pi_i])}$$

$$\text{RespOfScrutinee}(\text{true}) = \text{resp}$$
$$\text{RespOfScrutinee}(\text{false}) = \text{alias}$$

**(B-Arm)**
$$\frac{\Gamma \vdash p \Uparrow T \dashv B \quad \mathcal{B}_0 = \text{IntroAll}_B(\mathcal{B}, \text{BindInfoMap}(\lambda U.\ \text{RespOfScrutinee}(moved), B, \text{mov}, \texttt{let})) \quad (g \ne \bot \Rightarrow \Gamma;\mathcal{B}_0;\Pi \vdash g \Rightarrow \mathcal{B}_1 \triangleright \Pi_1) \quad (g = \bot \Rightarrow \mathcal{B}_1 = \mathcal{B}_0 \land \Pi_1 = \Pi) \quad \Gamma;\mathcal{B}_1;\Pi_1 \vdash b \Rightarrow \mathcal{B}_2 \triangleright \Pi_2}{\Gamma;\mathcal{B};\Pi \vdash \text{Arm}(moved, p, g, b) \Rightarrow \mathcal{B}_2 \triangleright \Pi_2}$$


**(B-Block)**
$$\frac{\Gamma; \text{PushScope}_B(\mathcal{B}); \text{PushScope}_\Pi(\Pi) \vdash stmts \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{BlockExpr}(stmts, tail\_opt) \Rightarrow \text{PopScope}_B(\mathcal{B}_1) \triangleright \text{PopScope}_\Pi(\Pi_1)}$$

**Loop Fixpoint.**

$$\text{Moved} <_B \text{PartiallyMoved}(F) <_B \text{Valid}$$
$$\text{PartiallyMoved}(F_1) <_B \text{PartiallyMoved}(F_2) \iff F_1 \supseteq F_2$$
$$x \le_B y \iff x <_B y \lor x = y$$
$$\text{Active} <_\Pi \text{Inactive}$$
$$x \le_\Pi y \iff x <_\Pi y \lor x = y$$
$$\mathcal{B}_1 \le \mathcal{B}_2 \iff \forall i.\ \mathcal{B}_1[i] \le_B \mathcal{B}_2[i]$$
$$\Pi_1 \le_\Pi \Pi_2 \iff \forall i.\ \Pi_1[i] \le_\Pi \Pi_2[i]$$

$$\text{LoopStep} : (\mathcal{B},\Pi) \to (\mathcal{B},\Pi)$$
$$F(\mathcal{B},\Pi) = (\text{Join}_B(\mathcal{B}_0,\mathcal{B}'),\ \text{JoinPerm}(\Pi_0,\Pi')) \ \text{where } (\mathcal{B}',\Pi')=\text{LoopStep}(\mathcal{B},\Pi)$$
$$(\mathcal{B}_0,\Pi_0) = (\mathcal{B}_{\text{init}},\Pi_{\text{init}})$$
$$(\mathcal{B}_{k+1},\Pi_{k+1}) = F(\mathcal{B}_k,\Pi_k)$$
$$n = \min\{ k \mid (\mathcal{B}_k,\Pi_k) = (\mathcal{B}_{k+1},\Pi_{k+1}) \}$$
$$\text{LoopFix}(\mathcal{B}_{\text{init}},\Pi_{\text{init}},\text{LoopStep}) = (\mathcal{B}_n,\Pi_n)$$

**(B-Loop-Infinite)**
$$\frac{\text{LoopStep}(\mathcal{B},\Pi) = (\mathcal{B}_b,\Pi_b)\ \text{where}\ \Gamma;\mathcal{B};\Pi \vdash body \Rightarrow \mathcal{B}_b \triangleright \Pi_b \quad (\mathcal{B}',\Pi') = \text{LoopFix}(\mathcal{B},\Pi,\text{LoopStep})}{\Gamma;\mathcal{B};\Pi \vdash \text{LoopInfinite}(body) \Rightarrow \mathcal{B}' \triangleright \Pi'}$$

**(B-Loop-Conditional)**
$$\frac{\text{LoopStep}(\mathcal{B},\Pi) = (\mathcal{B}_b,\Pi_b)\ \text{where}\ \Gamma;\mathcal{B};\Pi \vdash cond \Rightarrow \mathcal{B}_c \triangleright \Pi_c \ \land\ \Gamma;\mathcal{B}_c;\Pi_c \vdash body \Rightarrow \mathcal{B}_b \triangleright \Pi_b \quad (\mathcal{B}',\Pi') = \text{LoopFix}(\mathcal{B},\Pi,\text{LoopStep})}{\Gamma;\mathcal{B};\Pi \vdash \text{LoopConditional}(cond, body) \Rightarrow \mathcal{B}' \triangleright \Pi'}$$

**(B-Loop-Iter)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash iter \Rightarrow \mathcal{B}_0 \triangleright \Pi_0 \quad \Gamma \vdash pat \Leftarrow T_p \dashv B \quad \text{LoopStep}(\mathcal{B},\Pi) = (\mathcal{B}_b,\Pi_b)\ \text{where}\ \mathcal{B}_1 = \text{PushScope}_B(\mathcal{B})\ \land\ \mathcal{B}_2 = \text{IntroAll}_B(\mathcal{B}_1, \text{BindInfoMap}(\lambda U.\ \text{resp}, B, \text{mov}, \texttt{let}))\ \land\ \Pi_1 = \text{PushScope}_\Pi(\Pi)\ \land\ \Gamma;\mathcal{B}_2;\Pi_1 \vdash body \Rightarrow \mathcal{B}_3 \triangleright \Pi_2\ \land\ \mathcal{B}_b = \text{PopScope}_B(\mathcal{B}_3) \ \land\ \Pi_b = \text{PopScope}_\Pi(\Pi_2) \quad (\mathcal{B}',\Pi') = \text{LoopFix}(\mathcal{B}_0,\Pi_0,\text{LoopStep})}{\Gamma;\mathcal{B};\Pi \vdash \text{LoopIter}(pat, ty\_opt, iter, body) \Rightarrow \mathcal{B}' \triangleright \Pi'}$$

**(B-Return)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{ReturnStmt}(e) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}$$

**(B-Return-Unit)**
$$\frac{}{\Gamma;\mathcal{B};\Pi \vdash \text{ReturnStmt}(\bot) \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-Break)**
$$\frac{\Gamma;\mathcal{B};\Pi \vdash e \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}{\Gamma;\mathcal{B};\Pi \vdash \text{BreakStmt}(e) \Rightarrow \mathcal{B}_1 \triangleright \Pi_1}$$

**(B-Break-Unit)**
$$\frac{}{\Gamma;\mathcal{B};\Pi \vdash \text{BreakStmt}(\bot) \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-Continue)**
$$\frac{}{\Gamma;\mathcal{B};\Pi \vdash \text{ContinueStmt} \Rightarrow \mathcal{B} \triangleright \Pi}$$

**(B-Move-Unique-Err)**
$$\frac{\text{IsPlace}(p) \quad \Gamma; R; L \vdash p : T_p \quad \text{PermOf}(T_p)=\texttt{unique} \quad \neg \text{AccessPathOk}(\Pi, p) \quad c = \text{Code}(\text{B-Place-Unique-Err})}{\Gamma;\mathcal{B};\Pi \vdash \text{MoveExpr}(p) \Uparrow c}$$

**Procedure/Method Binding-Check.**

$$\text{Init}_B(m, params) = \text{IntroAll}_B(\text{PushScope}_B(\text{IntroAll}_B(\text{PushScope}_B([]), \text{StaticBindMap}(\text{Project}(\Gamma), m))), \text{ParamBindMap}(params))$$
$$\text{Init}_\Pi(m, params) = [\{ x \mapsto \text{Active} \mid (x:T) \in \text{ParamTypeMap}(params) \land \text{PermOf}(T)=\texttt{unique} \}] \mathbin{+\!\!+} [\{ x \mapsto \text{Active} \mid (x:T) \in \text{StaticBindTypesMod}(\text{Project}(\Gamma), m) \land \text{PermOf}(T)=\texttt{unique} \}]$$

$$\text{BindCheck}(m, params, body) \Downarrow ok \iff \Gamma; \text{Init}_B(m, params);\ \text{Init}_\Pi(m, params) \vdash body \Rightarrow \mathcal{B}' \triangleright \Pi'$$

$$\text{ProcBindCheck}(m, \text{ProcedureDecl}(\_,\_,params,\_,body,\_,\_)) \Downarrow ok \iff \text{BindCheck}(m, params, body) \Downarrow ok$$

$$\text{MethodParamsDecl}(T, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(T, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params}$$
$$\text{MethodBindCheck}(m, T, md) \Downarrow ok \iff md.\text{body}=body \land \text{BindCheck}(m, \text{MethodParamsDecl}(T, md), body) \Downarrow ok$$
$$\text{ClassMethodBindCheck}(m, Cl, md) \Downarrow ok \iff md.\text{body\_opt}=body \land \text{BindCheck}(m, \text{ClassMethodParams}(Cl, md), body) \Downarrow ok$$
$$\text{StateMethodBindCheck}(m, M, S, md) \Downarrow ok \iff md.\text{body}=body \land \text{BindCheck}(m, \text{StateMethodParams}(M, S, md), body) \Downarrow ok$$
$$\text{TransitionBindCheck}(m, M, S, tr) \Downarrow ok \iff tr.\text{body}=body \land \text{BindCheck}(m, \text{TransitionParams}(M, S, tr), body) \Downarrow ok$$

$$\text{BindDiagRefs} = \{\texttt{"8.2"},\ \texttt{"8.7"},\ \texttt{"8.10"}\}$$

#### 5.2.16. Safe Pointer Types (Cursive0)

$$\text{PtrState} = \{\texttt{Valid},\ \texttt{Null},\ \texttt{Expired}\}$$

$$\text{Ptr<T>} = \text{TypePtr}(T, \bot)$$
$$\text{Ptr<T>@s} = \text{TypePtr}(T, s) \quad (s \ne \bot)$$

**Static Semantics**

$$\text{BitcopyType}(\text{TypePtr}(T, s))$$
$$\text{CloneType}(\text{TypePtr}(T, s))$$
$$\neg \text{DropType}(\text{TypePtr}(T, s))$$

$$\text{sizeof}(\texttt{Ptr<T>}) = \text{sizeof}(\texttt{usize}) \quad\quad \text{alignof}(\texttt{Ptr<T>}) = \text{alignof}(\texttt{usize})$$
$$\text{PtrDiagRefs} = \{\texttt{"8.10"}\}$$

#### 5.2.17. Regions, Frames, and Provenance (Cursive0)

**Built-in Record Type `RegionOptions`.**

$$\text{RegionOptionsFields} = [
\langle \texttt{public},\ \texttt{stack\_size},\ \text{TypePrim}(\texttt{"usize"}),\ \text{Literal}(\text{IntLiteral}(0)),\ \bot,\ \bot \rangle,\ 
\langle \texttt{public},\ \texttt{name},\ \text{TypeString}(\bot),\ \text{Literal}(\text{StringLiteral}(\texttt{"\""})),\ \bot,\ \bot \rangle
]$$

$$\text{RegionOptionsDecl} = \text{RecordDecl}(\texttt{public},\ \texttt{RegionOptions},\ [],\ \text{RegionOptionsFields},\ \bot,\ \bot)$$

$$\Sigma.\text{Types}[\texttt{RegionOptions}] = \text{RegionOptionsDecl}$$

$$\text{RegionPrealloc}(opts) = opts.\text{stack\_size}$$
$$\text{NoPrealloc}(opts) \iff \text{RegionPrealloc}(opts) = 0$$

**Region/Frame Helpers.**

$$\text{RegionActiveType}(T) \iff \text{StripPerm}(T) = \text{TypeModalState}([\texttt{Region}], \texttt{Active})$$

$$\text{FreshRegion}(\Gamma) \in \text{Name} \setminus \text{dom}(\Gamma)$$

$$\text{RegionOptsExpr}(\bot) = \text{Call}(\text{Identifier}(\texttt{RegionOptions}), [])$$
$$\text{RegionOptsExpr}(e) = e \quad \text{if } e \ne \bot$$

$$\text{RegionBind}(\Gamma, alias\_opt) = \Gamma_r \iff r = \begin{cases}
alias\_opt & \text{if } alias\_opt \ne \bot\\
\text{FreshRegion}(\Gamma) & \text{otherwise}
\end{cases} \land \text{IntroAll}(\Gamma, [\langle r,\ \text{TypeModalState}([\texttt{Region}], \texttt{Active}) \rangle]) \Downarrow \Gamma_r$$

$$\text{InnermostActiveRegion}([]) = \bot$$
$$\text{InnermostActiveRegion}([\sigma] \mathbin{+\!\!+} \Gamma') = \begin{cases}
r & \text{if } \exists r.\ r \in \text{dom}(\sigma) \land \text{RegionActiveType}(\sigma[r])\\
\text{InnermostActiveRegion}(\Gamma') & \text{otherwise}
\end{cases}$$

$$\text{FrameBind}(\Gamma, target\_opt) = \Gamma_f \iff r = \begin{cases}
\text{InnermostActiveRegion}(\Gamma) & \text{if } target\_opt = \bot\\
target\_opt & \text{if } target\_opt \ne \bot \land \Gamma; R; L \vdash \text{Identifier}(target\_opt) : T_r \land \text{RegionActiveType}(T_r)
\end{cases} \land F = \text{FreshRegion}(\Gamma) \land \text{IntroAll}(\Gamma, [\langle F,\ \text{TypeModalState}([\texttt{Region}], \texttt{Active}) \rangle]) \Downarrow \Gamma_f$$

**Provenance Tags.**

$$\pi ::= \pi_{\text{Global}} \mid \pi_{\text{Stack}}(S) \mid \pi_{\text{Heap}} \mid \pi_{\text{Region}}(r) \mid \bot$$

**Lifetime Order.**

$$\pi_1 < \pi_2 \iff (\pi_1 = \pi_{\text{Region}}(r_{\text{inner}}) \land \pi_2 = \pi_{\text{Region}}(r_{\text{outer}}) \land \text{RegionNesting}(r_{\text{inner}}, r_{\text{outer}})) \ \lor\ (\pi_1 = \pi_{\text{Region}}(r) \land \pi_2 = \pi_{\text{Stack}}(S)) \ \lor\ (\pi_1 = \pi_{\text{Stack}}(S) \land \pi_2 = \pi_{\text{Heap}}) \ \lor\ (\pi_1 = \pi_{\text{Heap}} \land \pi_2 = \pi_{\text{Global}}) \ \lor\ (\pi_1 = \pi_{\text{Global}} \land \pi_2 = \bot)$$

$$\pi_1 \le \pi_2 \iff \pi_1 = \pi_2 \ \lor\ (\pi_1 < \pi_2) \ \lor\ \exists \pi.\ (\pi_1 < \pi \land \pi \le \pi_2)$$

$$\text{FrameTargetRel}(F, r) \iff \text{FrameTarget}(\Gamma, F) = r$$
$$\text{FrameTargetRel}(F, r) \Rightarrow \pi_{\text{Region}}(F) < \pi_{\text{Region}}(r)$$

$$\text{JoinProv}(\pi_1, \pi_2) = \begin{cases}
\pi_1 & \text{if } \pi_1 \le \pi_2\\
\pi_2 & \text{if } \pi_2 \le \pi_1\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{JoinAllProv}([]) = \bot$$
$$\text{JoinAllProv}([\pi]) = \pi$$
$$\text{JoinAllProv}([\pi_1,\pi_2] \mathbin{+\!\!+} ps) = \text{JoinAllProv}([\text{JoinProv}(\pi_1,\pi_2)] \mathbin{+\!\!+} ps)$$

**Provenance Environment.**

$$\Omega = \langle \Sigma_\pi, RS \rangle$$
$$\text{Scope}_\pi = \langle S, M \rangle \ \text{where}\ M : \text{Ident} \rightharpoonup \pi$$
$$\Sigma_\pi \in [\text{Scope}_\pi]$$
$$\text{RegionEntry}_\pi = \langle tag, target \rangle$$
$$RS \in [\text{RegionEntry}_\pi]$$

$$\text{ScopeId}(\langle S, M \rangle) = S$$
$$\text{ScopeMap}(\langle S, M \rangle) = M$$
$$\text{TopScopeId}([\langle S, M \rangle] \mathbin{+\!\!+} \Sigma_\pi) = S$$
$$\text{StackProv}(\Sigma_\pi) = \pi_{\text{Stack}}(\text{TopScopeId}(\Sigma_\pi))$$

$$\text{PushScope}_\pi(\Sigma_\pi) = [\langle S, \emptyset \rangle] \mathbin{+\!\!+} \Sigma_\pi \quad (S\ \text{fresh})$$
$$\text{PopScope}_\pi([\_]\mathbin{+\!\!+}\Sigma_\pi) = \Sigma_\pi$$

$$\text{Lookup}_\pi([\langle S, M \rangle] \mathbin{+\!\!+} \Sigma_\pi, x) = \begin{cases}
M[x] & \text{if } x \in \text{dom}(M) \\
\text{Lookup}_\pi(\Sigma_\pi, x) & \text{otherwise}
\end{cases}$$

$$\text{Intro}_\pi([\langle S, M \rangle] \mathbin{+\!\!+} \Sigma_\pi, x, \pi) = [\langle S, M[x \mapsto \pi] \rangle] \mathbin{+\!\!+} \Sigma_\pi$$

$$\text{ShadowIntro}_\pi(\Sigma_\pi, x, \pi) = \begin{cases}
[\langle S, M[x \mapsto \pi] \rangle] \mathbin{+\!\!+} \Sigma_\pi' & \text{if } \Sigma_\pi = [\langle S, M \rangle] \mathbin{+\!\!+} \Sigma_\pi' \land x \in \text{dom}(M) \\
[\langle S, M \rangle] \mathbin{+\!\!+} \text{ShadowIntro}_\pi(\Sigma_\pi', x, \pi) & \text{if } \Sigma_\pi = [\langle S, M \rangle] \mathbin{+\!\!+} \Sigma_\pi' \land x \notin \text{dom}(M) \\
\bot & \text{if } \Sigma_\pi = []
\end{cases}$$

$$\text{IntroAll}_\pi(\Sigma_\pi, [], \pi) = \Sigma_\pi$$
$$\text{IntroAll}_\pi(\Sigma_\pi, [x] \mathbin{+\!\!+} xs, \pi) = \text{IntroAll}_\pi(\text{Intro}_\pi(\Sigma_\pi, x, \pi), xs, \pi)$$

$$\text{ShadowAll}_\pi(\Sigma_\pi, [], \pi) = \Sigma_\pi$$
$$\text{ShadowAll}_\pi(\Sigma_\pi, [x] \mathbin{+\!\!+} xs, \pi) = \text{ShadowAll}_\pi(\text{ShadowIntro}_\pi(\Sigma_\pi, x, \pi), xs, \pi)$$

$$\text{ParamProvMap}(\text{params}, \vec{\pi}) = \{ x_i \mapsto \pi_i \mid \text{params} = [\langle \_, x_i, \_ \rangle],\ \vec{\pi} = [\pi_i] \}$$
$$\text{InitProvEnv}(\text{params}, \vec{\pi}, RS) = \langle [\langle S, \text{ParamProvMap}(\text{params}, \vec{\pi}) \rangle], RS \rangle \quad (S\ \text{fresh})$$

$$\text{AllocTag}([], r) = \bot$$
$$\text{AllocTag}([\langle tag, target \rangle] \mathbin{+\!\!+} RS, \bot) = tag$$
$$\text{AllocTag}([\langle tag, target \rangle] \mathbin{+\!\!+} RS, r) = \begin{cases}
tag & \text{if } target = r \\
\text{AllocTag}(RS, r) & \text{otherwise}
\end{cases}$$

**Provenance of Places.**

$$\text{ProvPlaceJudg} = \{\Gamma; \Omega \vdash p \Downarrow \pi\}$$

$$\frac{\text{Lookup}_\pi(\Sigma_\pi, x) = Ï€}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{Identifier}(x) \Downarrow Ï€}$$

**(P-Field)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash \text{FieldAccess}(p, f) \Downarrow Ï€}$$

**(P-Tuple)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash \text{TupleAccess}(p, i) \Downarrow Ï€}$$

**(P-Index)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash \text{IndexAccess}(p, i) \Downarrow Ï€}$$

**(P-Deref)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow Ï€}{\Gamma; \Omega \vdash \text{Deref}(e) \Downarrow Ï€}$$

**Provenance of Expressions.**

$$\text{ProvExprJudg} = \{\Gamma; \Omega \vdash e \Downarrow \pi\}$$

**(P-Place-Expr)**
$$\frac{\text{IsPlace}(p) \quad \Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash p \Downarrow Ï€}$$

**(P-Literal)**
$$\frac{}{\Gamma; \Omega \vdash \text{Literal}(\_) \Downarrow \bot}$$

**(P-Move)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash \text{MoveExpr}(p) \Downarrow Ï€}$$

**(P-AddrOf)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow Ï€}{\Gamma; \Omega \vdash \text{AddressOf}(p) \Downarrow Ï€}$$

**(P-Alloc)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow Ï€_e \quad \text{AllocTag}(RS, r\_opt) = tag}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{AllocExpr}(r\_opt, e) \Downarrow \pi_{\text{Region}}(tag)}$$

**(P-Region-Alloc-Method)**
$$\frac{name = \texttt{alloc} \quad (r : T_r) \in \Gamma \quad \text{RegionActiveType}(T_r) \quad \text{AllocTag}(RS, r) = tag}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{MethodCall}(\text{Identifier}(r), name, args) \Downarrow \pi_{\text{Region}}(tag)}$$

**(P-If)**
$$\frac{\Gamma; \Omega \vdash b_t \Downarrow Ï€_t \quad \Gamma; \Omega \vdash b_f \Downarrow Ï€_f \quad \text{JoinProv}(Ï€_t, Ï€_f) = Ï€}{\Gamma; \Omega \vdash \text{IfExpr}(c, b_t, b_f) \Downarrow Ï€}$$

**(P-If-No-Else)**
$$\frac{}{\Gamma; \Omega \vdash \text{IfExpr}(\_, b_t, \bot) \Downarrow \bot}$$

$$\text{ArmBodyProv}(e, \Omega) = \pi \iff \Gamma; \Omega \vdash e \Downarrow \pi$$
$$\text{ArmBodyProv}(b, \Omega) = \pi \iff \Gamma; \Omega \vdash b \Downarrow \pi$$

$$\text{ArmEnv}(\langle \Sigma_\pi, RS \rangle, pat) = \langle \Sigma_\pi', RS \rangle \iff \Gamma \vdash \text{PatNames}(pat) \Downarrow N \land \pi_b = \text{BindProv}(\langle \Sigma_\pi, RS \rangle, \bot) \land \Sigma_\pi' = \text{IntroAll}_\pi(\Sigma_\pi, N, \pi_b)$$

$$\text{ArmProv}(\langle pat,\_,body \rangle) = \pi \iff \text{ArmEnv}(\Omega, pat) = \Omega' \land \text{ArmBodyProv}(body, \Omega') = \pi$$

**(P-Match)**
$$\frac{\forall i,\ \text{ArmProv}(\text{arm}_i.\text{body}) = Ï€_i \quad \text{JoinAllProv}([Ï€_1,\ldots,Ï€_n]) = Ï€}{\Gamma; \Omega \vdash \text{MatchExpr}(\_, arms) \Downarrow Ï€}$$

$$\text{ProvExprRules} = \{\text{P-Place-Expr},\ \text{P-Literal},\ \text{P-Move},\ \text{P-AddrOf},\ \text{P-Alloc},\ \text{P-Region-Alloc-Method},\ \text{P-If},\ \text{P-If-No-Else},\ \text{P-Match},\ \text{P-Block},\ \text{P-Loop-Infinite},\ \text{P-Loop-Conditional},\ \text{P-Loop-Iter},\ \text{P-Expr-Sub}\}$$

$$\text{NoSpecificProvExpr}(e) \iff \neg \exists r \in \text{ProvExprRules} \setminus \{\text{P-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(P-Expr-Sub)**
$$\frac{\text{NoSpecificProvExpr}(e) \quad \text{Children\_LTR}(e) = [e_1,\ldots,e_n] \quad \forall i,\ \Gamma; \Omega \vdash e_i \Downarrow Ï€_i \quad \text{JoinAllProv}([Ï€_1,\ldots,Ï€_n]) = Ï€}{\Gamma; \Omega \vdash e \Downarrow Ï€}$$

**Provenance of Statements.**

$$\text{ProvStmtJudg} = \{\Gamma; \Omega \vdash s \Rightarrow \Omega' \triangleright \langle Res, Brk, BrkVoid \rangle,\ \Gamma; \Omega \vdash ss \Rightarrow \Omega' \triangleright \langle Res, Brk, BrkVoid \rangle\}$$

$$\text{LetOrVarStmt}(binding) \in \{\text{LetStmt}(binding),\ \text{VarStmt}(binding)\}$$

**(Prov-Seq-Empty)**
$$\frac{}{\Gamma; \Omega \vdash [] \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-Seq-Cons)**
$$\frac{\Gamma; \Omega \vdash s \Rightarrow \Omega_1 \triangleright \langle Res_1, Brk_1, B_1 \rangle \quad \Gamma; \Omega_1 \vdash ss \Rightarrow \Omega_2 \triangleright \langle Res_2, Brk_2, B_2 \rangle}{\Gamma; \Omega \vdash s::ss \Rightarrow \Omega_2 \triangleright \langle Res_1 \mathbin{+\!\!+} Res_2,\ Brk_1 \mathbin{+\!\!+} Brk_2,\ B_1 \lor B_2 \rangle}$$

**(Prov-LetVar)**
$$\frac{\text{binding}=\langle pat, \_, \_, init, \_ \rangle \quad \Gamma; \Omega \vdash init \Downarrow \pi_{\text{init}} \quad \Gamma \vdash \text{PatNames}(pat) \Downarrow N \quad \pi_{\text{bind}}=\text{BindProv}(\Omega, \pi_{\text{init}}) \quad \Sigma_\pi'=\text{IntroAll}_\pi(\Sigma_\pi, N, \pi_{\text{bind}})}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{LetOrVarStmt}(binding) \Rightarrow \langle \Sigma_\pi', RS \rangle \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-ShadowLet)**
$$\frac{\Gamma; \Omega \vdash init \Downarrow \pi_{\text{init}} \quad \pi_{\text{bind}}=\text{BindProv}(\Omega, \pi_{\text{init}}) \quad \Sigma_\pi'=\text{ShadowAll}_\pi(\Sigma_\pi, [x], \pi_{\text{bind}})}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{ShadowLetStmt}(x, \_, init) \Rightarrow \langle \Sigma_\pi', RS \rangle \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-ShadowVar)**
$$\frac{\Gamma; \Omega \vdash init \Downarrow \pi_{\text{init}} \quad \pi_{\text{bind}}=\text{BindProv}(\Omega, \pi_{\text{init}}) \quad \Sigma_\pi'=\text{ShadowAll}_\pi(\Sigma_\pi, [x], \pi_{\text{bind}})}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{ShadowVarStmt}(x, \_, init) \Rightarrow \langle \Sigma_\pi', RS \rangle \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-Assign)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow \pi_x \quad \Gamma; \Omega \vdash e \Downarrow \pi_e \quad \neg (\pi_e < \pi_x)}{\Gamma; \Omega \vdash \text{AssignStmt}(p,e) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-CompoundAssign)**
$$\frac{\Gamma; \Omega \vdash p \Downarrow \pi_x \quad \Gamma; \Omega \vdash e \Downarrow \pi_e \quad \neg (\pi_e < \pi_x)}{\Gamma; \Omega \vdash \text{CompoundAssignStmt}(p,\_,e) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-Escape-Err)**
$$\frac{stmt \in \{\text{AssignStmt}(p,e),\ \text{CompoundAssignStmt}(p,\_,e)\} \quad \Gamma; \Omega \vdash p \Downarrow \pi_x \quad \Gamma; \Omega \vdash e \Downarrow \pi_e \quad \pi_e < \pi_x \quad c = \text{Code}(\text{Prov-Escape-Err})}{\Gamma; \Omega \vdash stmt \Uparrow c}$$

**(Prov-ExprStmt)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow \pi}{\Gamma; \Omega \vdash \text{ExprStmt}(e) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-ResultStmt)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow \pi}{\Gamma; \Omega \vdash \text{ResultStmt}(e) \Rightarrow \Omega \triangleright \langle [\pi], [], \text{false} \rangle}$$

**(Prov-Return)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow \pi}{\Gamma; \Omega \vdash \text{ReturnStmt}(e) \Rightarrow \Omega \triangleright \langle [\pi], [], \text{false} \rangle}$$

**(Prov-Return-Unit)**
$$\frac{}{\Gamma; \Omega \vdash \text{ReturnStmt}(\bot) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-Break)**
$$\frac{\Gamma; \Omega \vdash e \Downarrow \pi}{\Gamma; \Omega \vdash \text{BreakStmt}(e) \Rightarrow \Omega \triangleright \langle [], [\pi], \text{false} \rangle}$$

**(Prov-Break-Unit)**
$$\frac{}{\Gamma; \Omega \vdash \text{BreakStmt}(\bot) \Rightarrow \Omega \triangleright \langle [], [], \text{true} \rangle}$$

**(Prov-Continue)**
$$\frac{}{\Gamma; \Omega \vdash \text{ContinueStmt} \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-UnsafeStmt)**
$$\frac{\Gamma; \Omega \vdash b \Downarrow \pi}{\Gamma; \Omega \vdash \text{UnsafeBlockStmt}(b) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-DeferStmt)**
$$\frac{\Gamma; \Omega \vdash b \Downarrow \pi}{\Gamma; \Omega \vdash \text{DeferStmt}(b) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

$$\text{FrameTarget}(\Gamma, \bot) = r \iff \text{InnermostActiveRegion}(\Gamma) = r$$
$$\text{FrameTarget}(\Gamma, r) = r \iff \Gamma; R; L \vdash \text{Identifier}(r) : T_r \land \text{RegionActiveType}(T_r)$$

**(Prov-RegionStmt)**
$$\frac{\text{RegionOptsExpr}(opts\_opt) = opts \quad \Gamma; \Omega \vdash opts \Downarrow \pi_{opts} \quad r = \text{RegionBindName}(\Gamma, alias\_opt) \quad \Sigma_\pi^0 = \text{PushScope}_\pi(\Sigma_\pi) \quad \pi_r = \text{BindProv}(\langle \Sigma_\pi^0, RS \rangle, \bot) \quad \Sigma_\pi'=\text{Intro}_\pi(\Sigma_\pi^0, r, \pi_r) \quad RS' = \langle r, r \rangle :: RS \quad \Gamma; \langle \Sigma_\pi', RS' \rangle \vdash b \Downarrow \pi_b}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{RegionStmt}(opts\_opt, alias\_opt, b) \Rightarrow \langle \Sigma_\pi, RS \rangle \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-FrameStmt)**
$$\frac{\text{FrameTarget}(\Gamma, target\_opt) = r \quad F = \text{FreshRegion}(\Gamma) \quad \Sigma_\pi^0 = \text{PushScope}_\pi(\Sigma_\pi) \quad \pi_F = \text{BindProv}(\langle \Sigma_\pi^0, RS \rangle, \bot) \quad \Sigma_\pi'=\text{Intro}_\pi(\Sigma_\pi^0, F, \pi_F) \quad RS' = \langle F, r \rangle :: RS \quad \Gamma; \langle \Sigma_\pi', RS' \rangle \vdash b \Downarrow \pi_b}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{FrameStmt}(target\_opt, b) \Rightarrow \langle \Sigma_\pi, RS \rangle \triangleright \langle [], [], \text{false} \rangle}$$

**(Prov-ErrorStmt)**
$$\frac{}{\Gamma; \Omega \vdash \text{ErrorStmt}(\_) \Rightarrow \Omega \triangleright \langle [], [], \text{false} \rangle}$$

**Block Provenance.**

$$\text{BlockProvJudg} = \{\Gamma; \Omega \vdash \text{BlockProv}(stmts, tail\_opt) \Downarrow \pi\}$$

$$\Omega_0 = \langle \text{PushScope}_\pi(\Sigma_\pi), RS \rangle$$

**(BlockProv-Res)**
$$\frac{\Gamma; \Omega_0 \vdash stmts \Rightarrow \Omega_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad Res \ne [] \quad \text{JoinAllProv}(Res) = Ï€ \quad (tail\_opt = e \Rightarrow \Gamma; \Omega_1 \vdash e \Downarrow \pi_t)}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{BlockProv}(stmts, tail\_opt) \Downarrow Ï€}$$

**(BlockProv-Tail)**
$$\frac{\Gamma; \Omega_0 \vdash stmts \Rightarrow \Omega_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad Res = [] \quad tail\_opt = e \quad \Gamma; \Omega_1 \vdash e \Downarrow Ï€}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{BlockProv}(stmts, tail\_opt) \Downarrow Ï€}$$

**(BlockProv-Unit)**
$$\frac{\Gamma; \Omega_0 \vdash stmts \Rightarrow \Omega_1 \triangleright \langle Res, Brk, BrkVoid \rangle \quad Res = [] \quad tail\_opt = \bot}{\Gamma; \langle \Sigma_\pi, RS \rangle \vdash \text{BlockProv}(stmts, \bot) \Downarrow \bot}$$

**(P-Block)**
$$\frac{\Gamma; \Omega \vdash \text{BlockProv}(stmts, tail\_opt) \Downarrow Ï€}{\Gamma; \Omega \vdash \text{BlockExpr}(stmts, tail\_opt) \Downarrow Ï€}$$

**Loop Provenance.**

$$\text{BreakProv}(body, \Omega) = \langle Brk, BrkVoid \rangle \iff body = \text{BlockExpr}(stmts, tail\_opt) \land \Omega_0 = \langle \text{PushScope}_\pi(\Sigma_\pi), RS \rangle \land \Gamma; \Omega_0 \vdash stmts \Rightarrow \Omega_1 \triangleright \langle Res, Brk, BrkVoid \rangle \land (tail\_opt = e \Rightarrow \Gamma; \Omega_1 \vdash e \Downarrow \pi_t)$$

$$\text{IterElemProv}(iter, \Omega) = \pi \iff \Gamma; \Omega \vdash iter \Downarrow \pi$$

$$\text{LoopProvInf}(Brk, BrkVoid) = \bot \iff Brk = []$$
$$\text{LoopProvInf}(Brk, BrkVoid) = \pi \iff Brk = [\pi_1,\ldots,\pi_n] \land BrkVoid = \text{false} \land \text{JoinAllProv}([\pi_1,\ldots,\pi_n]) = \pi$$

$$\text{LoopProvFin}(Brk, BrkVoid) = \bot \iff Brk = []$$
$$\text{LoopProvFin}(Brk, BrkVoid) = \pi \iff Brk = [\pi_1,\ldots,\pi_n] \land BrkVoid = \text{false} \land \text{JoinAllProv}([\pi_1,\ldots,\pi_n]) = \pi$$

$$\text{ExtendProv}(\langle \Sigma_\pi, RS \rangle, pat, \pi) = \langle \Sigma_\pi', RS \rangle \iff \Gamma \vdash \text{PatNames}(pat) \Downarrow N \land \Sigma_\pi' = \text{IntroAll}_\pi(\Sigma_\pi, N, \pi)$$

**(P-Loop-Infinite)**
$$\frac{\text{BreakProv}(body, \Omega) = \langle Brk, BrkVoid \rangle \quad \text{LoopProvInf}(Brk, BrkVoid) = Ï€}{\Gamma; \Omega \vdash \text{LoopInfinite}(body) \Downarrow Ï€}$$

**(P-Loop-Conditional)**
$$\frac{\text{BreakProv}(body, \Omega) = \langle Brk, BrkVoid \rangle \quad \text{LoopProvFin}(Brk, BrkVoid) = Ï€}{\Gamma; \Omega \vdash \text{LoopConditional}(cond, body) \Downarrow Ï€}$$

**(P-Loop-Iter)**
$$\frac{\text{IterElemProv}(iter, \Omega) = Ï€_{\text{elem}} \quad \text{ExtendProv}(\Omega, pat, Ï€_{\text{elem}}) = \Omega' \quad \text{BreakProv}(body, \Omega') = \langle Brk, BrkVoid \rangle \quad \text{LoopProvFin}(Brk, BrkVoid) = Ï€}{\Gamma; \Omega \vdash \text{LoopIter}(pat, ty\_opt, iter, body) \Downarrow Ï€}$$


$$\text{EscapeOk}(\pi_e, \pi_x) \iff \neg(\pi_e < \pi_x)$$

$$\text{BindProv}(\langle \Sigma_\pi, RS \rangle, \pi_{\text{init}}) = \begin{cases}
\text{StackProv}(\Sigma_\pi) & \text{if } \pi_{\text{init}} = \bot \\
\pi_{\text{init}} & \text{otherwise}
\end{cases}$$

$$\text{StaticBindProv} = \pi_{\text{Global}}$$

$$\text{AssignProvOk}(\Omega, p, e) \iff \Gamma; \Omega \vdash p \Downarrow \pi_x \land \Gamma; \Omega \vdash e \Downarrow \pi_e \land \text{EscapeOk}(\pi_e, \pi_x)$$

### 5.3. Classes and Record Methods (Cursive0)

#### 5.3.1. Classes (Cursive0)

**Common Method-Signature Definitions.**

$$\text{Distinct}(xs) \iff \forall i \ne j.\ xs[i] \ne xs[j]$$
$$\text{Disjoint}(xs, ys) \iff \forall x \in xs.\ x \notin ys$$

$$\text{ReturnType}(m) = \begin{cases}
m.\text{return\_type}\_opt & \text{if } m.\text{return\_type}\_opt \ne \bot \\
\text{TypePrim}(\texttt{"()"}) & \text{if } m.\text{return\_type}\_opt = \bot
\end{cases}$$

$$\text{SelfVar} = \text{TypePath}([\texttt{Self}])$$

$$\text{SubstSelf}(T, \text{TypePath}([\texttt{Self}])) = T$$
$$\text{SubstSelf}(T, \text{TypePerm}(p, ty)) = \text{TypePerm}(p, \text{SubstSelf}(T, ty))$$
$$\text{SubstSelf}(T, \text{TypeTuple}([t_1,\ldots,t_n])) = \text{TypeTuple}([\text{SubstSelf}(T,t_1),\ldots,\text{SubstSelf}(T,t_n)])$$
$$\text{SubstSelf}(T, \text{TypeArray}(ty, e)) = \text{TypeArray}(\text{SubstSelf}(T, ty), e)$$
$$\text{SubstSelf}(T, \text{TypeSlice}(ty)) = \text{TypeSlice}(\text{SubstSelf}(T, ty))$$
$$\text{SubstSelf}(T, \text{TypeUnion}([t_1,\ldots,t_n])) = \text{TypeUnion}([\text{SubstSelf}(T,t_1),\ldots,\text{SubstSelf}(T,t_n)])$$
$$\text{SubstSelf}(T, \text{TypeFunc}([\langle m_1, t_1 \rangle,\ldots,\langle m_n, t_n \rangle], r)) = \text{TypeFunc}([\langle m_1, \text{SubstSelf}(T,t_1) \rangle,\ldots,\langle m_n, \text{SubstSelf}(T,t_n) \rangle], \text{SubstSelf}(T, r))$$
$$\text{SubstSelf}(T, \text{TypePtr}(ty, s)) = \text{TypePtr}(\text{SubstSelf}(T, ty), s)$$
$$\text{SubstSelf}(T, \text{TypeRawPtr}(q, ty)) = \text{TypeRawPtr}(q, \text{SubstSelf}(T, ty))$$
$$\text{SubstSelf}(T, \text{TypeString}(state\_opt)) = \text{TypeString}(state\_opt)$$
$$\text{SubstSelf}(T, \text{TypeBytes}(state\_opt)) = \text{TypeBytes}(state\_opt)$$
$$\text{SubstSelf}(T, \text{TypeModalState}(p, S)) = \text{TypeModalState}(p, S)$$
$$\text{SubstSelf}(T, \text{TypeDynamic}(p)) = \text{TypeDynamic}(p)$$
$$\text{SubstSelf}(T, \text{TypePrim}(n)) = \text{TypePrim}(n)$$
$$\text{SubstSelf}(T, \text{TypePath}(p)) = \text{TypePath}(p) \quad \text{if } p \ne [\texttt{Self}]$$

$$\text{RecvType}(T, \text{ReceiverShorthand}(\texttt{const})) = \text{TypePerm}(\texttt{const}, T)$$
$$\text{RecvType}(T, \text{ReceiverShorthand}(\texttt{unique})) = \text{TypePerm}(\texttt{unique}, T)$$
$$\text{RecvType}(T, \text{ReceiverExplicit}(mode\_opt, ty)) = \text{SubstSelf}(T, ty)$$

$$\text{RecvMode}(\text{ReceiverShorthand}(\_)) = \bot$$
$$\text{RecvMode}(\text{ReceiverExplicit}(mode\_opt, \_)) = mode\_opt$$

$$\text{PermOf}(\text{TypePerm}(p, \_)) = p$$
$$\text{PermOf}(ty) = \texttt{const}\ \text{otherwise}$$

$$\text{RecvPerm}(T,r) = \text{PermOf}(\text{RecvType}(T,r))$$

$$\text{ParamSig}_T(T,\text{params}) = [\langle mode,\ \text{SubstSelf}(T, ty) \rangle \mid \langle mode,\ name,\ ty \rangle \in \text{params}]$$
$$\text{ParamBinds}_T(T,\text{params}) = [\langle x_1,\ \text{SubstSelf}(T, T_1) \rangle,\ldots,\langle x_n,\ \text{SubstSelf}(T, T_n) \rangle]$$
$$\text{ReturnType}_T(T,m) = \text{SubstSelf}(T,\ \text{ReturnType}(m))$$

$$\text{Sig}_T(T, m) = \langle \text{RecvType}(T, m.\text{receiver}),\ \text{ParamSig}_T(T, m.\text{params}),\ \text{SubstSelf}(T, \text{ReturnType}(m)) \rangle$$

$$\text{SigSelf}(m) = \text{Sig}_T(\text{SelfVar}, m)$$

**Class Declarations.**

$$\text{ClassItems}(Cl) = Cl.\text{items}$$
$$\text{ClassMethods}(Cl) = [ m \mid m \in \text{ClassItems}(Cl) \land \exists vis,name,recv,params,ret,body,span,doc.\ m=\text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc)]$$
$$\text{ClassFields}(Cl) = [ f \mid f \in \text{ClassItems}(Cl) \land \exists vis,name,ty,span,doc.\ f=\text{ClassFieldDecl}(vis,name,ty,span,doc)]$$
$$\text{MethodNames}(Cl) = [ m.\text{name} \mid m \in \text{ClassMethods}(Cl) ]$$
$$\text{FieldNames}(Cl) = [ f.\text{name} \mid f \in \text{ClassFields}(Cl) ]$$

**Class Path Well-Formedness.**

**(WF-ClassPath)**
$$\frac{p \in \text{dom}(\Sigma.\text{Classes})}{\Gamma \vdash p : \text{ClassPath}}$$

**(WF-ClassPath-Err)**
$$\frac{p \notin \text{dom}(\Sigma.\text{Classes}) \quad c = \text{Code}(\text{Superclass-Undefined})}{\Gamma \vdash p : \text{ClassPath} \Uparrow c}$$

**Superclass Linearization (C3).**

$$\text{Supers}(Cl) = [S_1,\ldots,S_n]$$

**(Lin-Base)**
$$\frac{\text{Supers}(Cl) = []}{\Gamma \vdash \text{Linearize}(Cl) \Downarrow [Cl]}$$

$$\text{Head}(h::t) = h$$
$$\text{Tail}([]) = []$$
$$\text{Tail}(h::t) = t$$
$$\text{HeadOk}(h, Ls) \iff \exists L \in Ls.\ L = h::t \land \forall L' \in Ls.\ h \notin \text{Tail}(L')$$
$$\text{SelectHead}(Ls) = h \iff Ls = [L_1,\ldots,L_n] \land L_i = h::t \land \text{HeadOk}(h,Ls) \land \forall j < i.\ \neg \text{HeadOk}(\text{Head}(L_j),Ls)$$
$$\text{SelectHead}(Ls) = \bot \iff \neg \exists h.\ \text{HeadOk}(h, Ls)$$
$$\text{PopHead}(h, L) = t \iff L = h::t$$
$$\text{PopHead}(h, L) = L \iff \neg (L = h::t)$$
$$\text{PopAll}(h, Ls) = [\text{PopHead}(h,L) \mid L \in Ls]$$

**(Merge-Empty)**
$$\frac{\forall L \in Ls,\ L = []}{\Gamma \vdash \text{Merge}(Ls) \Downarrow []}$$

**(Merge-Step)**
$$\frac{\text{SelectHead}(Ls) = h \quad \Gamma \vdash \text{Merge}(\text{PopAll}(h, Ls)) \Downarrow L}{\Gamma \vdash \text{Merge}(Ls) \Downarrow [h] \mathbin{+\!\!+} L}$$

**(Merge-Fail)**
$$\frac{\neg \exists h.\ \text{HeadOk}(h, Ls)}{\Gamma \vdash \text{Merge}(Ls) \Uparrow}$$

**(Lin-Ok)**
$$\frac{\Gamma \vdash \text{Merge}([\text{Linearize}(S_1),\ldots,\text{Linearize}(S_n), [S_1,\ldots,S_n]]) \Downarrow L}{\Gamma \vdash \text{Linearize}(Cl) \Downarrow [Cl] \mathbin{+\!\!+} L}$$

**(Lin-Fail)**
$$\frac{\Gamma \vdash \text{Merge}(\cdots) \Uparrow}{\Gamma \vdash \text{Linearize}(Cl) \Uparrow}$$

**(Superclass-Cycle)**
$$\frac{\Gamma \vdash \text{Linearize}(Cl) \Uparrow \quad c = \text{Code}(\text{Superclass-Cycle})}{\Gamma \vdash Cl \Uparrow c}$$

**Effective Method Set.**

$$\text{Linearize}(Cl) = [C_0, C_1, \ldots, C_k] \land C_0 = Cl$$

$$\text{EffMethods}(Cl) = \text{FirstByName}\Big(\mathbin{+\!\!+}_{i=0}^{k} \text{ClassMethods}(C_i)\Big)$$

$$\text{FirstByName}(ms) = \text{FirstByName}(ms,\emptyset)$$

$$\text{FirstByName}([], Seen) = []$$
$$\text{FirstByName}(m::ms, Seen) = \begin{cases}
m :: \text{FirstByName}(ms, Seen \cup \{m.\text{name} \mapsto \text{SigSelf}(m)\}) & \text{if } m.\text{name} \notin \text{dom}(Seen) \\
\text{FirstByName}(ms, Seen) & \text{if } Seen[m.\text{name}] = \text{SigSelf}(m) \\
\Uparrow & \text{otherwise}
\end{cases}$$

**(EffMethods-Conflict)**
$$\frac{\text{FirstByName}(ms) \Uparrow \quad c = \text{Code}(\text{EffMethods-Conflict})}{\Gamma \vdash \text{Emit}(c)}$$

**Effective Field Set.**

$$\text{FieldSig}(f) = \text{SubstSelf}(\text{SelfVar}, f.\text{type})$$

$$\text{EffFields}(Cl) = \text{FirstFieldByName}\Big(\mathbin{+\!\!+}_{i=0}^{k} \text{ClassFields}(C_i)\Big)$$

$$\text{FirstFieldByName}(fs) = \text{FirstFieldByName}(fs,\emptyset)$$

$$\text{FirstFieldByName}([], Seen) = []$$
$$\text{FirstFieldByName}(f::fs, Seen) = \begin{cases}
f :: \text{FirstFieldByName}(fs, Seen \cup \{f.\text{name} \mapsto \text{FieldSig}(f)\}) & \text{if } f.\text{name} \notin \text{dom}(Seen) \\
\text{FirstFieldByName}(fs, Seen) & \text{if } Seen[f.\text{name}] = \text{FieldSig}(f) \\
\Uparrow & \text{otherwise}
\end{cases}$$

**(EffFields-Conflict)**
$$\frac{\text{FirstFieldByName}(fs) \Uparrow \quad c = \text{Code}(\text{EffFields-Conflict})}{\Gamma \vdash \text{Emit}(c)}$$

**Dispatchability.**

$$\text{SelfOccurs}(\text{TypePath}([\texttt{Self}])) = \text{true}$$
$$\text{SelfOccurs}(\text{TypePerm}(p, ty)) = \text{SelfOccurs}(ty)$$
$$\text{SelfOccurs}(\text{TypeTuple}([t_1,\ldots,t_n])) = \bigvee_i \text{SelfOccurs}(t_i)$$
$$\text{SelfOccurs}(\text{TypeArray}(ty, e)) = \text{SelfOccurs}(ty)$$
$$\text{SelfOccurs}(\text{TypeSlice}(ty)) = \text{SelfOccurs}(ty)$$
$$\text{SelfOccurs}(\text{TypeUnion}([t_1,\ldots,t_n])) = \bigvee_i \text{SelfOccurs}(t_i)$$
$$\text{SelfOccurs}(\text{TypeFunc}([\langle m_1, t_1 \rangle,\ldots,\langle m_n, t_n \rangle], r)) = \Big(\bigvee_i \text{SelfOccurs}(t_i)\Big) \lor \text{SelfOccurs}(r)$$
$$\text{SelfOccurs}(\text{TypePtr}(ty, s)) = \text{SelfOccurs}(ty)$$
$$\text{SelfOccurs}(\text{TypeRawPtr}(q, ty)) = \text{SelfOccurs}(ty)$$
$$\text{SelfOccurs}(\text{TypeString}(state\_opt)) = \text{false}$$
$$\text{SelfOccurs}(\text{TypeBytes}(state\_opt)) = \text{false}$$
$$\text{SelfOccurs}(\text{TypeModalState}(p, S)) = \text{false}$$
$$\text{SelfOccurs}(\text{TypeDynamic}(p)) = \text{false}$$
$$\text{SelfOccurs}(\text{TypePrim}(n)) = \text{false}$$
$$\text{SelfOccurs}(\text{TypePath}(p)) = \text{false} \quad \text{if } p \ne [\texttt{Self}]$$

$$\text{SelfOccurs}(m) \iff \text{SelfOccurs}(\text{ReturnType}(m)) \lor \exists \langle \_,\_,ty \rangle \in m.\text{params}.\ \text{SelfOccurs}(ty)$$
$$\text{HasReceiver}(m) \iff m.\text{receiver} \ne \bot$$
$$\text{vtable\_eligible}(m) \iff \text{HasReceiver}(m) \land \neg \text{SelfOccurs}(m)$$

$$\text{dispatchable}(Cl) \iff \forall m \in \text{EffMethods}(Cl).\ \text{vtable\_eligible}(m)$$

**Class Method Well-Formedness.**

$$\text{SelfTypeClass}(ty) \iff ty = \text{SelfVar} \lor \exists p.\ ty = \text{TypePerm}(p,\ \text{SelfVar})$$

**(WF-Class-Method)**
$$\frac{(r = \text{ReceiverExplicit}(mode\_opt, ty) \Rightarrow \text{SelfTypeClass}(ty)) \quad (r = \text{ReceiverShorthand}(\_) \Rightarrow \text{true}) \quad \Gamma \vdash \text{RecvType}(\text{SelfVar}, r)\ \text{wf} \quad \text{self} \notin \text{ParamNames}(\text{params}) \quad \text{Distinct}(\text{ParamNames}(\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in \text{params},\ \Gamma \vdash T_i\ \text{wf} \quad (\text{return\_type}\_opt = \bot \ \lor\ \Gamma \vdash \text{return\_type}\_opt\ \text{wf})}{\Gamma \vdash \langle \text{ClassMethodDecl}, \_, \text{name}, r, \text{params}, \text{return\_type}\_opt, \text{body}\_opt, \_, \_ \rangle : \text{ClassMethodOK}(Cl)}$$

**(T-Class-Method-Body-Abstract)**
$$\frac{m.\text{body\_opt} = \bot}{\Gamma \vdash m : \text{ClassMethodBodyOK}}$$

**(T-Class-Method-Body)**
$$\frac{m.\text{body\_opt} = body \quad T_{\text{self}} = \text{RecvType}(\text{SelfVar}, m.\text{receiver}) \quad R_m = \text{ReturnType}_T(\text{SelfVar}, m) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, T_{\text{self}} \rangle] \mathbin{+\!\!+} \text{ParamBinds}_T(\text{SelfVar}, m.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; R_m; \bot \vdash body : T_b \quad \Gamma \vdash T_b <: R_m \quad (R_m \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(body))}{\Gamma \vdash m : \text{ClassMethodBodyOK}}$$

**(WF-Class)**
$$\frac{\text{Distinct}(\text{MethodNames}(Cl)) \quad \text{Distinct}(\text{FieldNames}(Cl)) \quad \text{Disjoint}(\text{MethodNames}(Cl), \text{FieldNames}(Cl)) \quad \text{Distinct}(\text{Supers}(Cl)) \quad \forall S \in \text{Supers}(Cl),\ \Gamma \vdash S : \text{ClassPath} \quad \forall m \in \text{ClassMethods}(Cl),\ \Gamma \vdash m : \text{ClassMethodOK}(Cl) \quad \Gamma \vdash m : \text{ClassMethodBodyOK} \quad \Gamma \vdash \text{Linearize}(Cl) \Downarrow L}{\Gamma \vdash Cl : \text{ClassOk}}$$

**(Class-Method-Dup)**
$$\frac{\neg \text{Distinct}(\text{MethodNames}(Cl)) \quad c = \text{Code}(\text{Class-Method-Dup})}{\Gamma \vdash Cl \Uparrow c}$$

**(Class-AbstractField-Dup)**
$$\frac{\neg \text{Distinct}(\text{FieldNames}(Cl)) \quad c = \text{Code}(\text{Class-AbstractField-Dup})}{\Gamma \vdash Cl \Uparrow c}$$

**(Class-Name-Conflict)**
$$\frac{\neg \text{Disjoint}(\text{MethodNames}(Cl), \text{FieldNames}(Cl)) \quad c = \text{Code}(\text{Class-Name-Conflict})}{\Gamma \vdash Cl \Uparrow c}$$

**(Superclass-Undefined)**
$$\frac{S \in \text{Supers}(Cl) \quad \neg(\Gamma \vdash S : \text{ClassPath}) \quad c = \text{Code}(\text{Superclass-Undefined})}{\Gamma \vdash Cl \Uparrow c}$$

**Class Implementation.**

$$\text{Implements}(T) = \text{impls} \iff T=\text{RecordDecl}(\_,\_,\text{impls},\_,\_,\_) \lor T=\text{EnumDecl}(\_,\_,\text{impls},\_,\_,\_) \lor T=\text{ModalDecl}(\_,\_,\text{impls},\_,\_,\_) \lor T=\text{ClassDecl}(\_,\_,\text{impls},\_,\_)$$

**Implements Clause Constraints.**
$$\text{NoDefaultMethods}(Cl) \iff \forall m \in \text{ClassMethods}(Cl).\ m.\text{body} = \bot$$
$$\text{BitcopyImpliesClone}(T) \iff (\texttt{Bitcopy} \in \text{Implements}(T)) \Rightarrow (\text{Clone} \in \text{Implements}(T))$$
$$\text{AbstractsImplemented}(T) \iff \forall Cl \in \text{Implements}(T).\ \forall m \in \text{ClassMethodTable}(Cl).\ (m.\text{body}=\bot \Rightarrow \text{MethodByName}(T,m.\text{name}) \ne \bot)$$

**(Impl-Duplicate-Class-Err)**
$$\frac{\neg \text{Distinct}(\text{Implements}(T)) \quad c = \text{Code}(\text{Impl-Duplicate-Class-Err})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

$$\text{Fields}(T) = \text{Fields}(R) \iff T=\text{TypePath}(p) \land \text{RecordDecl}(p)=R$$
$$\text{Methods}(T) = \text{Methods}(R) \iff T=\text{TypePath}(p) \land \text{RecordDecl}(p)=R$$
$$\text{Fields}(T) = [] \iff T=\text{TypePath}(p) \land (\text{EnumDecl}(p)=E \lor \Sigma.\text{Types}[p]=\texttt{modal } M)$$
$$\text{Methods}(T) = [] \iff T=\text{TypePath}(p) \land (\text{EnumDecl}(p)=E \lor \Sigma.\text{Types}[p]=\texttt{modal } M)$$
$$\text{MethodByName}(T,\text{name}) = m' \iff m' \in \text{Methods}(T) \land m'.\text{name}=\text{name}$$
$$\text{MethodByName}(T,\text{name}) = \bot \iff \neg \exists m' \in \text{Methods}(T).\ m'.\text{name}=\text{name}$$
$$\text{ClassMethodTable}(Cl) = \text{EffMethods}(Cl)$$
$$\text{ClassFieldTable}(Cl) = \text{EffFields}(Cl)$$

**(Impl-Abstract-Method)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} = \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad m'.\text{override} = \text{false}}{\Gamma \vdash T \text{ implements abstract } m}$$

**(Impl-Missing-Method)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} = \bot \quad \text{MethodByName}(T, m.\text{name}) = \bot \quad c = \text{Code}(\text{Impl-Missing-Method})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Sig-Err)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} = \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m) \quad c = \text{Code}(\text{Impl-Missing-Method})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Override-Abstract-Err)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} = \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad m'.\text{override} = \text{true} \quad c = \text{Code}(\text{Override-Abstract-Err})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Concrete-Default)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} \ne \bot \quad \text{MethodByName}(T, m.\text{name}) = \bot}{\Gamma \vdash T \text{ uses default } m}$$

**(Impl-Concrete-Override)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} \ne \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad m'.\text{override} = \text{true}}{\Gamma \vdash T \text{ overrides } m}$$

**(Override-Missing-Err)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} \ne \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad m'.\text{override} = \text{false} \quad c = \text{Code}(\text{Override-Missing-Err})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Sig-Err-Concrete)**
$$\frac{m \in \text{ClassMethodTable}(Cl) \quad m.\text{body} \ne \bot \quad \text{MethodByName}(T, m.\text{name}) = m' \quad \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m) \quad c = \text{Code}(\text{Impl-Missing-Method})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Override-NoConcrete)**
$$\frac{m' \in \text{Methods}(T) \quad m'.\text{override} = \text{true} \quad \neg \exists Cl \in \text{Implements}(T).\ \exists m \in \text{ClassMethodTable}(Cl).\ m.\text{name} = m'.\text{name} \land m.\text{body} \ne \bot \quad c = \text{Code}(\text{Override-NoConcrete})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Field)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad f : T_i \in \text{Fields}(T) \quad T_i <: T_c}{\Gamma \vdash T \text{ satisfies field } f}$$

**(Impl-Field-Missing)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad \neg \exists T_i.\ f : T_i \in \text{Fields}(T) \quad c = \text{Code}(\text{Impl-Field-Missing})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(Impl-Field-Type-Err)**
$$\frac{f : T_c \in \text{ClassFieldTable}(Cl) \quad f : T_i \in \text{Fields}(T) \quad \neg(\Gamma \vdash T_i <: T_c) \quad c = \text{Code}(\text{Impl-Field-Type-Err})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

**(WF-Impl)**
$$\frac{\forall Cl \in \text{Implements}(T),\ \Gamma \vdash Cl : \text{ClassOk} \quad \text{Distinct}(\text{Implements}(T)) \quad \Gamma \vdash T : \text{BitcopyDropOk} \quad \forall Cl \in \text{Implements}(T),\ \forall m \in \text{ClassMethodTable}(Cl),\ (\Gamma \vdash T \text{ implements abstract } m \ \lor\ \Gamma \vdash T \text{ overrides } m \ \lor\ \Gamma \vdash T \text{ uses default } m) \quad \forall Cl \in \text{Implements}(T),\ \forall f \in \text{ClassFieldTable}(Cl),\ \Gamma \vdash T \text{ satisfies field } f}{\Gamma \vdash T : \text{ImplementsOk}}$$

**(Impl-Dup)**
$$\frac{\neg \text{Distinct}(\text{Implements}(T)) \quad c = \text{Code}(\text{Impl-Dup})}{\Gamma \vdash T : \text{ImplementsOk} \Uparrow c}$$

$$\Gamma \vdash T <: Cl \iff Cl \in \text{Implements}(T) \land \Gamma \vdash T : \text{ImplementsOk}$$

**Superclass Closure.**
$$\frac{S \in \text{Supers}(Cl) \ \lor\ (S \in \text{Linearize}(Cl) \land S \ne Cl)}{\Gamma \vdash Cl <: S}$$
$$\frac{\Gamma \vdash T <: Cl \quad \Gamma \vdash Cl <: S}{\Gamma \vdash T <: S}$$

**Dynamic Class Types.**

**(T-Dynamic-Form)**
$$\frac{\Gamma; R; L \vdash e :place T \quad \text{IsPlace}(e) \quad \text{AddrOfOk}(e) \quad \Gamma \vdash Cl : \text{ClassPath} \quad \Gamma \vdash \text{StripPerm}(T) <: Cl \quad \text{dispatchable}(Cl)}{\Gamma; R; L \vdash e \ \texttt{as}\ \text{TypeDynamic}(Cl) : \text{TypeDynamic}(Cl)}$$

**(Dynamic-NonDispatchable)**
$$\frac{\Gamma; R; L \vdash e :place T \quad \text{IsPlace}(e) \quad \Gamma \vdash Cl : \text{ClassPath} \quad \Gamma \vdash \text{StripPerm}(T) <: Cl \quad \neg \text{dispatchable}(Cl) \quad c = \text{Code}(\text{Dynamic-NonDispatchable})}{\Gamma; R; L \vdash e \ \texttt{as}\ \text{TypeDynamic}(Cl) \Uparrow c}$$

**Method Lookup for Concrete Types.**

$$\text{ClassDefaults}(T,\text{name}) = \{ m \mid \exists Cl \in \text{Implements}(T).\ m \in \text{ClassMethodTable}(Cl) \land m.\text{name}=\text{name} \land m.\text{body} \ne \bot \}$$
$$\text{LookupMethod}(T,\text{name}) = m \iff \text{MethodByName}(T,\text{name}) = m$$
$$\text{LookupMethod}(T,\text{name}) = m \iff \text{MethodByName}(T,\text{name}) = \bot \land |\text{ClassDefaults}(T,\text{name})| = 1 \land m \in \text{ClassDefaults}(T,\text{name})$$
$$\text{LookupMethod}(T,\text{name}) = \bot \iff \text{MethodByName}(T,\text{name}) = \bot \land (|\text{ClassDefaults}(T,\text{name})| = 0 \lor |\text{ClassDefaults}(T,\text{name})| > 1)$$

**(LookupMethod-NotFound)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{MethodByName}(\text{StripPerm}(T_b), name) = \bot \quad \text{ClassDefaults}(\text{StripPerm}(T_b), name) = \emptyset \quad c = \text{Code}(\text{LookupMethod-NotFound})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(LookupMethod-Ambig)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{MethodByName}(\text{StripPerm}(T_b), name) = \bot \quad |\text{ClassDefaults}(\text{StripPerm}(T_b), name)| > 1 \quad c = \text{Code}(\text{LookupMethod-Ambig})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(Drop-Call-Err)**
$$\frac{\Gamma; R; L \vdash base : T_b \quad \text{LookupMethod}(\text{StripPerm}(T_b), name) = m \quad \text{MethodOwner}(m) = \texttt{Drop} \quad \text{MethodName}(m) = \texttt{"drop"} \quad c = \text{Code}(\text{Drop-Call-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(Drop-Call-Err-Dyn)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name) = m \quad \text{MethodOwner}(m) = \texttt{Drop} \quad \text{MethodName}(m) = \texttt{"drop"} \quad c = \text{Code}(\text{Drop-Call-Err-Dyn})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

**(T-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ T \quad \text{LookupMethod}(T, name) = m \quad \text{RecvPerm}(T, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

**(MethodCall-RecvPerm-Err)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ T \quad \text{LookupMethod}(T, name) = m \quad \text{RecvPerm}(T, m.\text{receiver}) = P_{\text{method}} \quad \neg \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad c = \text{Code}(\text{MethodCall-RecvPerm-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$
**(T-Dynamic-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name) = m \quad \text{RecvPerm}(\text{SelfVar}, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

**(LookupClassMethod-NotFound)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(Cl) \quad \text{LookupClassMethod}(Cl, name)\ \text{undefined} \quad c = \text{Code}(\text{LookupMethod-NotFound})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$


#### 5.3.2. Record Methods (Cursive0)

**Definitions.**

$$\text{Fields}(R) = [ f \mid f \in R.\text{members} \land \exists vis,name,ty,init,span,doc.\ f=\text{FieldDecl}(vis,name,ty,init,span,doc) ]$$
$$\text{Methods}(R) = [ m \mid m \in R.\text{members} \land \exists vis,override,name,recv,params,ret,body,span,doc.\ m=\text{MethodDecl}(vis,override,name,recv,params,ret,body,span,doc) ]$$
$$\text{Self}_R = \text{TypePath}(\text{RecordPath}(R))$$
$$\text{SelfType}(R, ty) \iff ty = \text{Self}_R \lor \exists p.\ ty = \text{TypePerm}(p,\ \text{Self}_R)$$

**Static Semantics**

**(Recv-Explicit)**
$$\frac{\text{SelfType}(R, ty)}{\Gamma \vdash \text{ReceiverExplicit}(mode\_opt, ty) : \text{Recv}(R, \text{PermOf}(ty), mode\_opt)}$$

**(Record-Method-RecvSelf-Err)**
$$\frac{\neg \text{SelfType}(R, ty) \quad c = \text{Code}(\text{Record-Method-RecvSelf-Err})}{\Gamma \vdash \text{ReceiverExplicit}(mode\_opt, ty) \Uparrow c}$$

**(Recv-Const)**
$$\frac{}{\Gamma \vdash \text{ReceiverShorthand}(\texttt{const}) : \text{Recv}(R, \texttt{const}, \bot)}$$

**(Recv-Unique)**
$$\frac{}{\Gamma \vdash \text{ReceiverShorthand}(\texttt{unique}) : \text{Recv}(R, \texttt{unique}, \bot)}$$

$$\text{ParamNames}(\text{params}) = [x \mid \langle \_, x, \_ \rangle \in \text{params}]$$

**(WF-Record-Method)**
$$\frac{\Gamma \vdash r : \text{Recv}(R, P, mode) \quad \text{self} \notin \text{ParamNames}(\text{params}) \quad \text{Distinct}(\text{ParamNames}(\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in \text{params},\ \Gamma \vdash T_i\ \text{wf} \quad (\text{return\_type}\_opt = \bot \ \lor\ \Gamma \vdash \text{return\_type}\_opt\ \text{wf})}{\Gamma \vdash \langle \text{MethodDecl}, \_, \text{name}, r, \text{params}, \text{return\_type}\_opt, \text{body}, \_, \_ \rangle : \text{MethodOK}(R, P, mode)}$$

**(T-Record-Method-Body)**
$$\frac{\Gamma \vdash m : \text{MethodOK}(R, P, mode) \quad T_{\text{self}} = \text{RecvType}(\text{Self}_R, m.\text{receiver}) \quad R_m = \text{ReturnType}_T(\text{Self}_R, m) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, T_{\text{self}} \rangle] \mathbin{+\!\!+} \text{ParamBinds}_T(\text{Self}_R, m.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; R_m; \bot \vdash m.\text{body} : T_b \quad \Gamma \vdash T_b <: R_m \quad (R_m \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(m.\text{body}))}{\Gamma \vdash m : \text{MethodBodyOK}(R)}$$

$$\text{MethodNames}(R) = [ m.\text{name} \mid m \in \text{Methods}(R) ]$$

**(WF-Record-Methods)**
$$\frac{\text{Distinct}(\text{MethodNames}(R)) \quad \forall m \in \text{Methods}(R),\ \Gamma \vdash m : \text{MethodOK}(R, \_, \_) \quad \Gamma \vdash m : \text{MethodBodyOK}(R)}{\Gamma \vdash \text{Methods}(R) : \text{ok}}$$

**(Record-Method-Dup)**
$$\frac{\neg \text{Distinct}(\text{MethodNames}(R)) \quad c = \text{Code}(\text{Record-Method-Dup})}{\Gamma \vdash \text{Methods}(R) \Uparrow c}$$

**Method Lookup.**

$$\text{LookupMethodRules} = \text{RulesIn}(\{\texttt{"5.3.1"}\})$$

**Argument Compatibility.**

$$\text{ArgsOkJudg} = \{\Gamma; R; L \vdash \text{ArgsOk}(params, args)\}$$

$$\text{RecvBaseType}(base, mode) = P\ T \iff (mode = \bot \land \Gamma; R; L \vdash base :place P\ T) \lor (mode = \texttt{move} \land \Gamma; R; L \vdash base : P\ T)$$

**(Args-Empty)**
$$\frac{}{\Gamma; R; L \vdash \text{ArgsOk}([], [])}$$

**(Args-Cons)**
$$\frac{\Gamma; R; L \vdash \text{MovedArg}(moved, e) \Leftarrow T_p \dashv \emptyset \quad moved = \text{true} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

**(Args-Cons-Ref)**
$$\frac{\Gamma; R; L \vdash e \Leftarrow_{\text{place}} T_p \quad \text{AddrOfOk}(e) \quad moved = \text{false} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, as)}{\Gamma; R; L \vdash \text{ArgsOk}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as)}$$

$$\text{RecvArgOk}(base, mode) \iff (mode = \bot \land \text{AddrOfOk}(base)) \lor (mode = \texttt{move} \land \exists p.\ base = \text{MoveExpr}(p))$$
$$\text{ArgsOkDiagRules} = \text{RulesIn}(\{\texttt{"5.2.4"}\})$$

**(T-Record-MethodCall)**
$$\frac{\text{RecvBaseType}(base, \text{RecvMode}(m.\text{receiver})) = P_{\text{caller}}\ R_{\text{rec}} \quad \text{LookupMethod}(R_{\text{rec}}, name) = m \quad \text{RecvPerm}(R_{\text{rec}}, m.\text{receiver}) = P_{\text{method}} \quad \text{PermSub}(P_{\text{caller}}, P_{\text{method}}) \quad \text{RecvArgOk}(base, \text{RecvMode}(m.\text{receiver})) \quad \Gamma; R; L \vdash \text{ArgsOk}(m.\text{params}, args)}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) : \text{ReturnType}(m)}$$

$$\text{BindParams}(m, v_{\text{self}}, \vec{v}) = \{\texttt{self} \mapsto v_{\text{self}}\} \cup \{ x_i \mapsto v_i \mid m.\text{params} = [\langle \_, x_i, \_ \rangle],\ \vec{v} = [v_i] \}$$
$$\text{BindStmt}(x, e) = \text{LetStmt}(\langle \text{IdentifierPattern}(x),\ \bot,\ \text{Operator}(\texttt{"="}),\ e,\ \bot \rangle)$$
$$\text{BindStmts}(m, v_{\text{self}}, \vec{v}) = [\text{BindStmt}(\texttt{self}, v_{\text{self}})] \mathbin{+\!\!+} [\text{BindStmt}(x_i, v_i) \mid m.\text{params} = [\langle \_, x_i, \_ \rangle],\ \vec{v} = [v_i]]$$
$$\text{ApplyMethod}(m, v_{\text{self}}, \vec{v}) = \text{BlockExpr}(bs \mathbin{+\!\!+} ss, t) \iff \text{BindStmts}(m, v_{\text{self}}, \vec{v}) = bs \land m.\text{body} = \text{BlockExpr}(ss, t)$$

**(Step-MethodCall)**
$$\frac{\Gamma \vdash v_{\text{self}} : P_{\text{caller}}\ R \quad \text{LookupMethod}(R, name) = m}{\langle \text{MethodCall}(v_{\text{self}}, name, \vec{v}) \rangle \to \langle \text{ApplyMethod}(m, v_{\text{self}}, \vec{v}) \rangle}$$


### 5.4. Modal Types (Definitions)

$$\text{States}(M) \ne \emptyset$$
$$\text{States}(M) = \{ S \mid S \in \text{StateNames}(M) \}$$
$$\text{Payload}(M, S) = [\langle f_1, T_1 \rangle,\ \ldots,\ \langle f_k, T_k \rangle]$$
$$\mathcal{T}_M = \{M\} \cup \{ M@S \mid S \in \text{States}(M) \}$$

**Payload Map.**

$$\text{PayloadMap}(M, S) =
\begin{cases}
\{ f_i \mapsto T_i \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S) \} & \text{if } \text{Distinct}([f_i \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S)]) \\
\bot & \text{otherwise}
\end{cases}$$

**(WF-Modal-Payload)**
$$\frac{\forall i,\ \Gamma \vdash T_i\ \text{wf} \quad \forall i \ne j,\ f_i \ne f_j}{\Gamma \vdash \text{Payload}(M, S)\ \text{wf}}$$

**(Modal-Payload-DupField)**
$$\frac{\exists i \ne j.\ f_i = f_j \quad c = \text{Code}(\text{Modal-Payload-DupField})}{\Gamma \vdash \text{Payload}(M, S)\ \text{wf} \Uparrow c}$$

**Type Well-Formedness (Cursive0).**

$$\text{TypesMap} = \Sigma.\text{Types}$$
$$\text{ClassesMap} = \Sigma.\text{Classes}$$

$$\text{TypeWFJudg} = \{\Gamma \vdash T\ \text{wf}\}$$

**(WF-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad name \in \text{PrimTypes}_{C0}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Perm)**
$$\frac{T = \text{TypePerm}(p, T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Tuple)**
$$\frac{T = \text{TypeTuple}([T_1,\ldots,T_n]) \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Array)**
$$\frac{T = \text{TypeArray}(T_0, e) \quad \Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad n \ge 2 \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Union-TooFew)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad n < 2 \quad c = \text{Code}(\text{WF-Union-TooFew})}{\Gamma \vdash T\ \text{wf} \Uparrow c}$$

**(WF-Func)**
$$\frac{T = \text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad \Gamma \vdash R\ \text{wf} \quad \forall i,\ \Gamma \vdash T_i\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Path)**
$$\frac{T = \text{TypePath}(p) \quad p \in \text{dom}(\Sigma.\text{Types})}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Dynamic)**
$$\frac{T = \text{TypeDynamic}(p) \quad p \in \text{dom}(\Sigma.\text{Classes})}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Dynamic-Err)**
$$\frac{T = \text{TypeDynamic}(p) \quad p \notin \text{dom}(\Sigma.\text{Classes}) \quad c = \text{Code}(\text{Superclass-Undefined})}{\Gamma \vdash T\ \text{wf} \Uparrow c}$$

**(WF-String)**
$$\frac{T = \text{TypeString}(state\_opt) \quad state\_opt \in \{\bot, \texttt{View}, \texttt{Managed}\}}{\Gamma \vdash T\ \text{wf}}$$


**(WF-Bytes)**
$$\frac{T = \text{TypeBytes}(state\_opt) \quad state\_opt \in \{\bot, \texttt{View}, \texttt{Managed}\}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, state\_opt) \quad state\_opt \in \{\bot, \texttt{Valid}, \texttt{Null}, \texttt{Expired}\} \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**(WF-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad p \in \text{dom}(\Sigma.\text{Types}) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M)}{\Gamma \vdash T\ \text{wf}}$$

**(WF-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0) \quad \Gamma \vdash T_0\ \text{wf}}{\Gamma \vdash T\ \text{wf}}$$

**Static Semantics**

**(Modal-WF)**
$$\frac{n \ge 1 \quad \forall i \in 1..n,\ S_i\ \text{unique} \quad \forall i,\ \Gamma \vdash \text{Payload}(M, S_i)\ \text{wf} \quad \forall i,\ S_i \ne M}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf}}$$

**(Modal-NoStates-Err)**
$$\frac{n = 0 \quad c = \text{Code}(\text{Modal-NoStates-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(Modal-DupState-Err)**
$$\frac{\neg \text{Distinct}([S_1,\ldots,S_n]) \quad c = \text{Code}(\text{Modal-DupState-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(Modal-StateName-Err)**
$$\frac{\exists i.\ S_i = M \quad c = \text{Code}(\text{Modal-StateName-Err})}{\Gamma \vdash \texttt{modal } M\ \{@S_1\ \ldots\ @S_n\}\ \text{wf} \Uparrow c}$$

**(State-Specific-WF)**
$$\frac{S \in \text{States}(M)}{\Gamma \vdash M@S\ \text{wf}}$$

$$\text{PayloadNames}(M, S) = [ f \mid \langle f,\_ \rangle \in \text{Payload}(M, S) ]$$
$$\text{PayloadNameSet}(M, S) = \text{Set}(\text{PayloadNames}(M, S))$$

**(T-Modal-State-Intro)**
$$\frac{\Sigma.\text{Types}[path] = \texttt{modal } M \quad S \in \text{States}(M) \quad path \notin \{[\texttt{"File"}], [\texttt{"DirIter"}]\} \quad \text{PayloadNameSet}(M, S) = \text{FieldInitSet}(fields) \quad \text{Distinct}(\text{FieldInitNames}(fields)) \quad \forall \langle f, e \rangle \in fields,\ \text{PayloadMap}(M, S)(f) = T_f \land \Gamma; R; L \vdash e \Leftarrow T_f \dashv \emptyset}{\Gamma; R; L \vdash \text{RecordExpr}(\text{ModalStateRef}(path, S), fields) : \text{TypeModalState}(path, S)}$$

**(Modal-Incomparable)**
$$\frac{S_A \ne S_B}{\Gamma \vdash M@S_A \not<: M@S_B \quad \land \quad \Gamma \vdash M@S_B \not<: M@S_A}$$

#### 5.4.1. Built-in Modal Type `Region` (Cursive0)

$$[\texttt{"Region"}] \in \text{dom}(\Sigma.\text{Types})$$
$$\text{States}(\texttt{Region}) = \{\ \texttt{@Active},\ \texttt{@Frozen},\ \texttt{@Freed}\ \}$$

$$\text{RegionPayloadFields} = [\langle \texttt{handle}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$

$$\text{Payload}(\texttt{Region}, \texttt{@Active}) = \text{RegionPayloadFields} \quad \text{Payload}(\texttt{Region}, \texttt{@Frozen}) = \text{RegionPayloadFields} \quad \text{Payload}(\texttt{Region}, \texttt{@Freed}) = \text{RegionPayloadFields}$$

$$\text{RegionProcs} = \{\texttt{Region::new\_scoped},\ \texttt{Region::alloc},\ \texttt{Region::reset\_unchecked},\ \texttt{Region::freeze},\ \texttt{Region::thaw},\ \texttt{Region::free\_unchecked}\}$$

$$\text{RegionProcSig}(\texttt{Region::new\_scoped}) = \langle [\langle \bot,\ \texttt{options},\ \text{TypePath}([\texttt{"RegionOptions"}]) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::alloc}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle,\ \langle \bot,\ \texttt{value},\ T \rangle],\ T_{\pi_{\text{Region}}(\texttt{self})} \rangle \quad (T \in \text{Type})$$
$$\text{RegionProcSig}(\texttt{Region::reset\_unchecked}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::freeze}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::thaw}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen})) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}) \rangle$$
$$\text{RegionProcSig}(\texttt{Region::free\_unchecked}) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeUnion}([\text{TypeModalState}([\texttt{"Region"}], \texttt{@Active}),\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Frozen})])) \rangle],\ \text{TypeModalState}([\texttt{"Region"}], \texttt{@Freed}) \rangle$$

$$\text{ProvType}(T,\pi) = T_\pi$$
$$\text{BaseType}(T_\pi) = T \quad \text{ProvOf}(T_\pi) = \pi$$

$$\texttt{Bitcopy} \notin \text{Implements}(\text{TypePath}([\texttt{"Region"}]))$$

**(Region-Unchecked-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : T \quad \text{StripPerm}(T) = \text{TypeModalState}([\texttt{"Region"}], S) \quad S \in \{\texttt{Active}, \texttt{Frozen}\} \quad name \in \{\texttt{"reset\_unchecked"}, \texttt{"free\_unchecked"}\} \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, name, args))) \quad c = \text{Code}(\text{Region-Unchecked-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, name, args) \Uparrow c}$$

### 5.5. State-Specific Fields

$$\text{ModalFieldVisible}(m, p) \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land \text{ModuleOfPath}(\text{ModalPath}(M)) = m$$

**(T-Modal-Field)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \text{ModalFieldVisible}(m, p)}{\Gamma; R; L \vdash e.f : T}$$

**(T-Modal-Field-Perm)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePerm}(p', \text{TypeModalState}(p, S)) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \text{ModalFieldVisible}(m, p)}{\Gamma; R; L \vdash e.f : \text{TypePerm}(p', T)}$$

**(Modal-Field-Missing)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f)\ \text{undefined} \quad c = \text{Code}(\text{Modal-Field-Missing})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

**(Modal-Field-General-Err)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad c = \text{Code}(\text{Modal-Field-General-Err})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

**(Modal-Field-NotVisible)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{PayloadMap}(M, S)(f) = T \quad \neg \text{ModalFieldVisible}(m, p) \quad c = \text{Code}(\text{Modal-Field-NotVisible})}{\Gamma; R; L \vdash e.f \Uparrow c}$$

### 5.6. Transitions and State-Specific Methods

$$\text{Methods}(S) = [ m \mid m \in \text{StateMembers}(S) \land \exists vis,name,params,ret,body,span,doc.\ m=\text{StateMethodDecl}(vis,name,params,ret,body,span,doc) ]$$
$$\text{Transitions}(S) = [ t \mid t \in \text{StateMembers}(S) \land \exists vis,name,params,target,body,span,doc.\ t=\text{TransitionDecl}(vis,name,params,target,body,span,doc) ]$$
$$\text{StateMethodNames}(S) = [ m.\text{name} \mid m \in \text{Methods}(S) ]$$
$$\text{TransitionNames}(S) = [ t.\text{name} \mid t \in \text{Transitions}(S) ]$$

**(StateMethod-Dup)**
$$\frac{\neg \text{Distinct}(\text{StateMethodNames}(S)) \quad c = \text{Code}(\text{StateMethod-Dup})}{\Gamma \vdash S \Uparrow c}$$

**(Transition-Dup)**
$$\frac{\neg \text{Distinct}(\text{TransitionNames}(S)) \quad c = \text{Code}(\text{Transition-Dup})}{\Gamma \vdash S \Uparrow c}$$

$$\text{LookupStateMethod}(S,\text{name}) = m \iff m \in \text{Methods}(S) \land m.\text{name}=\text{name}$$
$$\text{LookupStateMethod}(S,\text{name}) = \bot \iff \neg \exists m \in \text{Methods}(S).\ m.\text{name}=\text{name}$$
$$\text{LookupTransition}(S,\text{name}) = t \iff t \in \text{Transitions}(S) \land t.\text{name}=\text{name}$$
$$\text{LookupTransition}(S,\text{name}) = \bot \iff \neg \exists t \in \text{Transitions}(S).\ t.\text{name}=\text{name}$$
$$\text{StateMemberVisible}(\text{mod}, M, \text{vis}) \iff \text{vis} \in \{\texttt{public},\ \texttt{internal}\} \lor (\text{vis} \in \{\texttt{private},\ \texttt{protected}\} \land \text{ModuleOfPath}(\text{ModalPath}(M)) = \text{mod})$$
$$\text{MethodSig}(M,S,m).\text{recv} = \text{TypePerm}(\texttt{const},\ M@S)$$
$$\text{MethodSig}(M,S,m).\text{params} = m.\text{params}$$
$$\text{MethodSig}(M,S,m).\text{ret} = \text{ReturnType}(m)$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{recv} = \text{TypePerm}(\texttt{unique},\ M@S_{\text{src}})$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{params} = t.\text{params}$$
$$S_{\text{tgt}} = t.\text{target}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{ret} = M@S_{\text{tgt}}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{target} = S_{\text{tgt}}$$
$$\text{TransitionSig}(M,S_{\text{src}},t).\text{mode} = \texttt{move}$$

**State Method and Transition Well-Formedness.**

**(WF-State-Method)**
$$\frac{\text{self} \notin \text{ParamNames}(md.\text{params}) \quad \text{Distinct}(\text{ParamNames}(md.\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in md.\text{params},\ \Gamma \vdash T_i\ \text{wf} \quad (md.\text{return\_type}\_opt = \bot \ \lor\ \Gamma \vdash md.\text{return\_type}\_opt\ \text{wf})}{\Gamma \vdash md : \text{StateMethodOK}(M, S)}$$

**(WF-Transition)**
$$\frac{\text{self} \notin \text{ParamNames}(tr.\text{params}) \quad \text{Distinct}(\text{ParamNames}(tr.\text{params})) \quad \forall \langle \_,\ \_,\ T_i \rangle \in tr.\text{params},\ \Gamma \vdash T_i\ \text{wf} \quad tr.\text{target} \in \text{States}(M)}{\Gamma \vdash tr : \text{TransitionOK}(M, S_{\text{src}})}$$

**(Transition-Target-Err)**
$$\frac{tr.\text{target} \notin \text{States}(M) \quad c = \text{Code}(\text{Transition-Target-Err})}{\Gamma \vdash tr \Uparrow c}$$

**(T-Modal-Transition)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : \texttt{unique}\ M@S_{\text{src}} \quad \text{LookupTransition}(S_{\text{src}}, t) = tr \quad \text{StateMemberVisible}(mod, M, tr.\text{vis}) \quad \text{TransitionSig}(M, S_{\text{src}}, tr).\text{params} = ps \quad \text{TransitionSig}(M, S_{\text{src}}, tr).\text{target} = S_{\text{tgt}} \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, args) \quad \text{RecvArgOk}(e_{\text{self}}, \texttt{move})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) : M@S_{\text{tgt}}}$$

**(Transition-Source-Err)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : T \quad (\text{PermOf}(T) \ne \texttt{unique} \ \lor\ \text{StripPerm}(T) \ne \text{TypeModalState}(\_,\_)) \quad c = \text{Code}(\text{Transition-Source-Err})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) \Uparrow c}$$

**(Transition-NotVisible)**
$$\frac{\Gamma; R; L \vdash e_{\text{self}} : \texttt{unique}\ M@S_{\text{src}} \quad \text{LookupTransition}(S_{\text{src}}, t) = tr \quad \neg \text{StateMemberVisible}(mod, M, tr.\text{vis}) \quad c = \text{Code}(\text{Transition-NotVisible})}{\Gamma; R; L \vdash e_{\text{self}} \mathord{\sim>} t(args) \Uparrow c}$$


**(T-Modal-Transition-Body)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S_{\text{src}} \in \text{States}(M) \quad tr \in \text{Transitions}(S_{\text{src}}) \quad tr.\text{body} = body \quad tr.\text{target} = S_{\text{tgt}} \quad S_{\text{tgt}} \in \text{States}(M) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(p, S_{\text{src}})) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(tr.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; \text{TypeModalState}(p, S_{\text{tgt}}); \bot \vdash body : T_b \quad \Gamma \vdash T_b <: \text{TypeModalState}(p, S_{\text{tgt}})}{\Gamma \vdash tr : \text{TransitionBodyOK}(p, S_{\text{src}})}$$

**(Transition-Body-Err)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S_{\text{src}} \in \text{States}(M) \quad tr \in \text{Transitions}(S_{\text{src}}) \quad tr.\text{body} = body \quad tr.\text{target} = S_{\text{tgt}} \quad S_{\text{tgt}} \in \text{States}(M) \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(p, S_{\text{src}})) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(tr.\text{params})) \Downarrow \Gamma_1 \quad \Gamma_1; \text{TypeModalState}(p, S_{\text{tgt}}); \bot \vdash body : T_b \quad \neg(\Gamma \vdash T_b <: \text{TypeModalState}(p, S_{\text{tgt}})) \quad c = \text{Code}(\text{Transition-Body-Err})}{\Gamma \vdash tr \Uparrow c}$$

**(T-Modal-Method)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{PermSub}(P_{\text{caller}}, \texttt{const}) \quad \text{LookupStateMethod}(S, m) = md \quad \text{StateMemberVisible}(mod, M, md.\text{vis}) \quad \text{MethodSig}(M,S,md).\text{params} = ps \quad \Gamma; R; L \vdash \text{ArgsOk}(ps, args)}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) : \text{ReturnType}(md)}$$

**(Modal-Method-NotFound)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{LookupStateMethod}(S, m)\ \text{undefined} \quad c = \text{Code}(\text{Modal-Method-NotFound})}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) \Uparrow c}$$

**(Modal-Method-NotVisible)**
$$\frac{\Gamma; R; L \vdash e : P_{\text{caller}}\ M@S \quad \text{LookupStateMethod}(S, m) = md \quad \neg \text{StateMemberVisible}(mod, M, md.\text{vis}) \quad c = \text{Code}(\text{Modal-Method-NotVisible})}{\Gamma; R; L \vdash e \mathord{\sim>} m(args) \Uparrow c}$$

**(T-Modal-Method-Body)**
$$\frac{\Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad md \in \text{Methods}(S) \quad md.\text{body} = body \quad \Gamma_0 = \text{PushScope}(\Gamma) \quad \text{IntroAll}(\Gamma_0, [\langle \texttt{self}, \text{TypePerm}(\texttt{const}, \text{TypeModalState}(p, S)) \rangle] \mathbin{+\!\!+} \text{ParamBinds}(md.\text{params})) \Downarrow \Gamma_1 \quad R_m = \text{ReturnType}(md) \quad \Gamma_1; R_m; \bot \vdash body : T_b \quad \Gamma \vdash T_b <: R_m \quad (R_m \ne \text{TypePrim}(\texttt{"()"}) \Rightarrow \text{ExplicitReturn}(body))}{\Gamma \vdash md : \text{StateMethodBodyOK}(p, S)}$$

### 5.7. Modal Widening (`widen`)

$$\text{WIDEN\_LARGE\_PAYLOAD\_THRESHOLD\_BYTES} = 256$$

**(T-Modal-Widen)**
$$\frac{\Gamma; R; L \vdash e : \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}{\Gamma; R; L \vdash \texttt{widen } e : \text{TypePath}(p)}$$

**(T-Modal-Widen-Perm)**
$$\frac{\Gamma; R; L \vdash e : \text{TypePerm}(p', \text{TypeModalState}(p, S)) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}{\Gamma; R; L \vdash \texttt{widen } e : \text{TypePerm}(p', \text{TypePath}(p))}$$

**(Widen-AlreadyGeneral)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad c = \text{Code}(\text{Widen-AlreadyGeneral})}{\Gamma; R; L \vdash \texttt{widen } e \Uparrow c}$$

**(Widen-NonModal)**
$$\frac{\Gamma; R; L \vdash e : T \quad \text{StripPerm}(T) = U \quad U \ne \text{TypeModalState}(\_,\_) \quad \neg \exists p, M.\ (U = \text{TypePath}(p) \land \Sigma.\text{Types}[p] = \texttt{modal } M) \quad c = \text{Code}(\text{Widen-NonModal})}{\Gamma; R; L \vdash \texttt{widen } e \Uparrow c}$$

**Niche-Layout-Compatible Conditions**

$$\text{NicheCompatible}(M,S) \iff \text{NicheApplies}(M) \land \text{PayloadState}(M) = S \land \text{sizeof}(M@S) = \text{sizeof}(M) \land \text{alignof}(M@S) = \text{alignof}(M)$$

$$\text{WidenWarnCond}(p,S) \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land \text{sizeof}(M@S) > \text{WIDEN\_LARGE\_PAYLOAD\_THRESHOLD\_BYTES} \land \neg \text{NicheCompatible}(M,S)$$

**(Warn-Widen-LargePayload)**
$$\frac{\text{WidenWarnCond}(p,S) \quad sp = \text{span}(\text{Unary}(\texttt{"widen"}, e)) \quad \Gamma \vdash \text{Emit}(W\text{-}SYS\text{-}4010, sp)}{\Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}$$

**(Warn-Widen-Ok)**
$$\frac{\neg \text{WidenWarnCond}(p,S)}{\Gamma \vdash \text{WarnWidenLargePayload}(e, p, S) \Downarrow ok}$$

**Size Relationship**

$$\text{sizeof}(M@S) \le \text{sizeof}(M)$$

### 5.8. String and Bytes Types and States

$$\text{States}(\texttt{string}) = \{\ \texttt{@Managed},\ \texttt{@View}\ \}$$
$$\text{States}(\texttt{bytes}) = \{\ \texttt{@Managed},\ \texttt{@View}\ \}$$

**Modal Widening.**

$$\frac{S \in \{\texttt{@Managed}, \texttt{@View}\}}{\Gamma \vdash \texttt{string@}S <: \texttt{string}}$$
$$\frac{S \in \{\texttt{@Managed}, \texttt{@View}\}}{\Gamma \vdash \texttt{bytes@}S <: \texttt{bytes}}$$

$$\text{StringBytesBuiltinTable} =
\left\{
\begin{aligned}
&\langle \texttt{string::from},\ [\langle \bot,\ \texttt{source},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::as\_view},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@Managed})) \rangle],\ \text{TypeString}(\texttt{@View}) \rangle,\\
&\langle \texttt{string::to\_managed},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::clone\_with},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::append},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeString}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{string::length},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"usize"}) \rangle,\\
&\langle \texttt{string::is\_empty},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeString}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle,\\
&\langle \texttt{bytes::with\_capacity},\ [\langle \bot,\ \texttt{cap},\ \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::from\_slice},\ [\langle \bot,\ \texttt{data},\ \text{TypePerm}(\texttt{const}, \text{TypeSlice}(\text{TypePrim}(\texttt{"u8"}))) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::as\_view},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@Managed})) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::to\_managed},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::view},\ [\langle \bot,\ \texttt{data},\ \text{TypePerm}(\texttt{const}, \text{TypeSlice}(\text{TypePrim}(\texttt{"u8"}))) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::view\_string},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeBytes}(\texttt{@View}) \rangle,\\
&\langle \texttt{bytes::append},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{unique}, \text{TypeBytes}(\texttt{@Managed})) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"AllocationError"}])]) \rangle,\\
&\langle \texttt{bytes::length},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"usize"}) \rangle,\\
&\langle \texttt{bytes::is\_empty},\ [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\texttt{const}, \text{TypeBytes}(\texttt{@View})) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle
\end{aligned}
\right\}$$
$$\text{StringBytesBuiltinSig}(method) = \langle params, ret \rangle \iff \langle method, params, ret \rangle \in \text{StringBytesBuiltinTable}$$

$$\text{ByteSeq} = \text{List}(\texttt{u8})$$
$$SB = \langle \text{StrBuf},\ \text{BytesBuf},\ \text{BytesCap} \rangle$$
$$\text{StrBuf} : \texttt{string@Managed} \rightharpoonup \text{ByteSeq}$$
$$\text{BytesBuf} : \texttt{bytes@Managed} \rightharpoonup \text{ByteSeq}$$
$$\text{BytesCap} : \texttt{bytes@Managed} \rightharpoonup \text{usize}$$

$$\text{ViewBytes} : (\texttt{string@View} \cup \texttt{bytes@View}) \to \text{ByteSeq}$$
$$\text{ByteSeqOf}(SB, v) = \begin{cases}
\text{StrBuf}(v) & v:\texttt{string@Managed} \\
\text{BytesBuf}(v) & v:\texttt{bytes@Managed} \\
\text{ViewBytes}(v) & v:\texttt{string@View}\ \text{or}\ v:\texttt{bytes@View}
\end{cases}$$
$$\text{ByteLen}(SB, v) = |\text{ByteSeqOf}(SB, v)|$$

$$\text{SliceBytes}(\text{data}) = [b \mid b \in \text{data}]$$

$$\text{StringBytesJudg} = \{\text{StringFrom}(SB, source, heap) \Downarrow (r, SB'),\ \text{StringAsView}(SB, self) \Downarrow v,\ \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB'),\ \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB'),\ \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB'),\ \text{StringLength}(SB, self) \Downarrow n,\ \text{StringIsEmpty}(SB, self) \Downarrow b,\ \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB'),\ \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB'),\ \text{BytesAsView}(SB, self) \Downarrow v,\ \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB'),\ \text{BytesView}(SB, data) \Downarrow v,\ \text{BytesViewString}(SB, data) \Downarrow v,\ \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB'),\ \text{BytesLength}(SB, self) \Downarrow n,\ \text{BytesIsEmpty}(SB, self) \Downarrow b\}$$


**(StringFrom-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, source)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringFrom}(SB, source, heap) \Downarrow (r, SB')}$$

**(StringFrom-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringFrom}(SB, source, heap) \Downarrow (r, SB')}$$

**(StringAsView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, self)}{\Gamma \vdash \text{StringAsView}(SB, self) \Downarrow v}$$

**(StringToManaged-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, self)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringToManaged-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringCloneWith-Ok)**
$$\frac{r = v \quad SB' = \langle \text{StrBuf}[v \mapsto \text{ByteSeqOf}(SB, self)],\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringCloneWith-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringCloneWith}(SB, self, heap) \Downarrow (r, SB')}$$

**(StringAppend-Ok)**
$$\frac{r = \texttt{()} \quad \text{StrBuf}' = \text{StrBuf}[self \mapsto \text{ByteSeqOf}(SB, self) \mathbin{+\!\!+} \text{ByteSeqOf}(SB, data)] \quad SB' = \langle \text{StrBuf}',\ \text{BytesBuf},\ \text{BytesCap} \rangle}{\Gamma \vdash \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(StringAppend-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{StringAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(StringLength)**
$$\frac{n = \text{ByteLen}(SB, self)}{\Gamma \vdash \text{StringLength}(SB, self) \Downarrow n}$$

**(StringIsEmpty)**
$$\frac{b = (\text{ByteLen}(SB, self) = 0)}{\Gamma \vdash \text{StringIsEmpty}(SB, self) \Downarrow b}$$

**(BytesWithCapacity-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto []] \quad \text{BytesCap}' = \text{BytesCap}[v \mapsto cap'] \quad cap' \ge cap \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap}' \rangle}{\Gamma \vdash \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB')}$$

**(BytesWithCapacity-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesWithCapacity}(SB, cap, heap) \Downarrow (r, SB')}$$

**(BytesFromSlice-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto \text{SliceBytes}(data)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB')}$$

**(BytesFromSlice-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesFromSlice}(SB, data, heap) \Downarrow (r, SB')}$$

**(BytesAsView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, self)}{\Gamma \vdash \text{BytesAsView}(SB, self) \Downarrow v}$$

**(BytesToManaged-Ok)**
$$\frac{r = v \quad \text{BytesBuf}' = \text{BytesBuf}[v \mapsto \text{ByteSeqOf}(SB, self)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(BytesToManaged-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesToManaged}(SB, self, heap) \Downarrow (r, SB')}$$

**(BytesView-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{SliceBytes}(data)}{\Gamma \vdash \text{BytesView}(SB, data) \Downarrow v}$$

**(BytesViewString-Ok)**
$$\frac{\text{ByteSeqOf}(SB, v) = \text{ByteSeqOf}(SB, data)}{\Gamma \vdash \text{BytesViewString}(SB, data) \Downarrow v}$$

**(BytesAppend-Ok)**
$$\frac{r = \texttt{()} \quad \text{BytesBuf}' = \text{BytesBuf}[self \mapsto \text{ByteSeqOf}(SB, self) \mathbin{+\!\!+} \text{ByteSeqOf}(SB, data)] \quad SB' = \langle \text{StrBuf},\ \text{BytesBuf}',\ \text{BytesCap} \rangle}{\Gamma \vdash \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(BytesAppend-Err)**
$$\frac{\text{AllocErrorVal}(r) \quad SB' = SB}{\Gamma \vdash \text{BytesAppend}(SB, self, data, heap) \Downarrow (r, SB')}$$

**(BytesLength)**
$$\frac{n = \text{ByteLen}(SB, self)}{\Gamma \vdash \text{BytesLength}(SB, self) \Downarrow n}$$

**(BytesIsEmpty)**
$$\frac{b = (\text{ByteLen}(SB, self) = 0)}{\Gamma \vdash \text{BytesIsEmpty}(SB, self) \Downarrow b}$$

### 5.9. Capabilities and Context (Cursive0)


#### 5.9.1. Capability Access

$$\text{CapClass} = \{\texttt{FileSystem},\ \texttt{HeapAllocator}\}$$
$$\text{CapType}(Cl) = \text{TypeDynamic}(Cl)$$

$$\text{CapMethodSig}(\texttt{FileSystem}, name) = \langle params, ret \rangle \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}$$
$$\text{CapMethodSig}(\texttt{HeapAllocator}, name) = \langle params, ret \rangle \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}$$
$$\text{CapRecv}(\texttt{FileSystem}, name) = recv \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}$$
$$\text{CapRecv}(\texttt{HeapAllocator}, name) = recv \iff \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}$$


#### 5.9.2. `FileSystem` Capability Class

$$\text{BuiltinTypes}_{FS} = \{\texttt{File},\ \texttt{DirIter},\ \texttt{DirEntry},\ \texttt{FileKind},\ \texttt{IoError}\}$$

$$\text{FileSystemInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"open\_read"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Read}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_write"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Write}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_append"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Append}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"create\_write"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"File"}], \texttt{@Write}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"read\_file"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"read\_bytes"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_file"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle,\ \langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_stdout"},\ \texttt{~},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"write\_stderr"},\ \texttt{~},\ [\langle \bot,\ \texttt{data},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"exists"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypePrim}(\texttt{"bool"}) \rangle,\\
&\langle \texttt{"remove"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"open\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeModalState}([\texttt{"DirIter"}], \texttt{@Open}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"create\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"ensure\_dir"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"kind"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePath}([\texttt{"FileKind"}]),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{"restrict"},\ \texttt{~},\ [\langle \bot,\ \texttt{path},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeDynamic}(\texttt{FileSystem}) \rangle
\end{aligned}
\right\}$$

$$\text{Variants}(\texttt{FileKind}) = [\texttt{File},\ \texttt{Dir},\ \texttt{Other}]$$

$$\text{Implements}(\texttt{FileKind}) = [\texttt{Bitcopy}]$$

$$\text{Fields}(\texttt{DirEntry}) = [\langle \texttt{name},\ \text{TypeString}(\texttt{@Managed}) \rangle,\ \langle \texttt{path},\ \text{TypeString}(\texttt{@Managed}) \rangle,\ \langle \texttt{kind},\ \text{TypePath}([\texttt{"FileKind"}]) \rangle]$$

**DirIter Modal Type.**

$$\text{States}(\texttt{DirIter}) = \{\texttt{@Open}, \texttt{@Closed}\}$$

$$\text{Payload}(\texttt{DirIter}, \texttt{@Open}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{DirIter}, \texttt{@Closed}) = []$$

$$\text{DirIterStateMembers} =
\left\{
\begin{aligned}
&\langle \texttt{@Open},\ \texttt{"next"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePath}([\texttt{"DirEntry"}]),\ \text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Open},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"DirIter"}], \texttt{@Closed}) \rangle
\end{aligned}
\right\}$$

**File Modal Type.**

$$\text{States}(\texttt{File}) = \{\texttt{@Read}, \texttt{@Write}, \texttt{@Append}, \texttt{@Closed}\}$$

$$\text{Payload}(\texttt{File}, \texttt{@Read}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Write}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Append}) = [\langle \texttt{handle}, \texttt{usize} \rangle]$$
$$\text{Payload}(\texttt{File}, \texttt{@Closed}) = []$$

$$\text{FileStateMembers} =
\left\{
\begin{aligned}
&\langle \texttt{@Read},\ \texttt{"read\_all"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypeString}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Read},\ \texttt{"read\_all\_bytes"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypeBytes}(\texttt{@Managed}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Read},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"write"},\ \texttt{method},\ [\langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"flush"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Write},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"write"},\ \texttt{method},\ [\langle \bot,\ \texttt{data},\ \text{TypeBytes}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"flush"},\ \texttt{method},\ [],\ \text{TypeUnion}([\text{TypePrim}(\texttt{"()"}),\ \text{TypePath}([\texttt{"IoError"}])]) \rangle,\\
&\langle \texttt{@Append},\ \texttt{"close"},\ \texttt{transition},\ [],\ \text{TypeModalState}([\texttt{"File"}], \texttt{@Closed}) \rangle
\end{aligned}
\right\}$$

$$\text{Variants}(\texttt{IoError}) = [\texttt{NotFound},\ \texttt{PermissionDenied},\ \texttt{AlreadyExists},\ \texttt{InvalidPath},\ \texttt{Busy},\ \texttt{IoFailure}]$$

$$\text{Implements}(\texttt{IoError}) = [\texttt{Bitcopy}]$$

**(Record-FileDir-Err)**
$$\frac{\text{path} \in \{[\texttt{"File"}], [\texttt{"DirIter"}]\} \quad c = \text{Code}(\text{Record-FileDir-Err})}{\Gamma; R; L \vdash \text{RecordExpr}(\text{ModalStateRef}(path, S), fields) \Uparrow c}$$

#### 5.9.3. `HeapAllocator` Capability Class

$$\text{HeapAllocatorInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"with\_quota"},\ \texttt{~!},\ [\langle \bot,\ \texttt{size},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle,\\
&\langle \texttt{"alloc\_raw"},\ \texttt{~},\ [\langle \bot,\ \texttt{count},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypeRawPtr}(\texttt{mut}, \text{TypePrim}(\texttt{"u8"})) \rangle,\\
&\langle \texttt{"dealloc\_raw"},\ \texttt{~},\ [\langle \bot,\ \texttt{ptr},\ \text{TypeRawPtr}(\texttt{mut}, \text{TypePrim}(\texttt{"u8"})) \rangle,\ \langle \bot,\ \texttt{count},\ \text{TypePrim}(\texttt{"usize"}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle
\end{aligned}
\right\}$$

**(AllocRaw-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(\texttt{HeapAllocator}) \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, \texttt{"alloc\_raw"}, args))) \quad c = \text{Code}(\text{AllocRaw-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, \texttt{"alloc\_raw"}, args) \Uparrow c}$$

**(DeallocRaw-Unsafe-Err)**
$$\frac{\Gamma; R; L \vdash base : \text{TypeDynamic}(\texttt{HeapAllocator}) \quad \neg \text{UnsafeSpan}(\text{span}(\text{MethodCall}(base, \texttt{"dealloc\_raw"}, args))) \quad c = \text{Code}(\text{DeallocRaw-Unsafe-Err})}{\Gamma; R; L \vdash \text{MethodCall}(base, \texttt{"dealloc\_raw"}, args) \Uparrow c}$$

$$\text{Variants}(\texttt{AllocationError}) = [\texttt{OutOfMemory},\ \texttt{QuotaExceeded}]$$
$$\text{VariantPayload}(\texttt{AllocationError}, \texttt{OutOfMemory}) = \text{TuplePayload}([\text{TypePrim}(\texttt{"usize"})])$$
$$\text{VariantPayload}(\texttt{AllocationError}, \texttt{QuotaExceeded}) = \text{TuplePayload}([\text{TypePrim}(\texttt{"usize"})])$$
$$\text{AllocErrorVal}(r) \iff \exists s.\ r = \text{EnumValue}([\texttt{"AllocationError"},\ \texttt{"OutOfMemory"}], \text{TuplePayload}([s]))\ \lor\ r = \text{EnumValue}([\texttt{"AllocationError"},\ \texttt{"QuotaExceeded"}], \text{TuplePayload}([s]))$$

#### 5.9.4. `Context` Record (Cursive0)

$$\text{BuiltinRecord} \supseteq \{\texttt{Context},\ \texttt{System}\}$$

$$\text{Fields}(\texttt{Context}) = [\langle \texttt{fs},\ \text{TypeDynamic}(\texttt{FileSystem}) \rangle,\ \langle \texttt{heap},\ \text{TypeDynamic}(\texttt{HeapAllocator}) \rangle,\ \langle \texttt{sys},\ \text{TypePath}([\texttt{"System"}]) \rangle]$$

$$\text{Implements}(\texttt{Context}) = [\texttt{Bitcopy}]$$
$$\text{Implements}(\texttt{System}) = [\texttt{Bitcopy}]$$

$$\text{SystemInterface} =
\left\{
\begin{aligned}
&\langle \texttt{"exit"},\ [\langle \bot,\ \texttt{code},\ \text{TypePrim}(\texttt{"i32"}) \rangle],\ \text{TypePrim}(\texttt{"!"}) \rangle,\\
&\langle \texttt{"get\_env"},\ [\langle \bot,\ \texttt{key},\ \text{TypeString}(\texttt{@View}) \rangle],\ \text{TypeUnion}([\text{TypeString}(\bot),\ \text{TypePrim}(\texttt{"()"})]) \rangle
\end{aligned}
\right\}$$
$$\text{SystemMethodSig}(name) = \langle params, ret \rangle \iff \langle name,\ params,\ ret \rangle \in \text{SystemInterface}$$
### 5.10. Enum Discriminant Defaults

$$\text{Variants}(E) = E.\text{variants}$$
$$\text{disc\_opt}(v) = v.\text{discriminant\_opt}$$

$$\text{DiscValue}(tok) = \text{IntValue}(tok)$$

$$\text{DiscOf}(v,n) = \begin{cases}
n & \text{if } \text{disc\_opt}(v)=\bot \\
\text{DiscValue}(tok) & \text{if } \text{disc\_opt}(v)=tok
\end{cases}$$
$$\text{DiscSeq}([], n) = []$$
$$\text{DiscSeq}(v::vs, n) = [\text{DiscOf}(v,n)] \mathbin{+\!\!+} \text{DiscSeq}(vs, \text{DiscOf}(v,n)+1)$$

$$\text{EnumDiscriminants}(E) \Downarrow ds \iff ds = \text{DiscSeq}(\text{Variants}(E), 0) \land \text{Distinct}(ds) \land \forall d \in ds.\ d \ge 0$$

**(Enum-Disc-NotInt)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad tok.\text{kind} \ne \text{IntLiteral} \quad c = \text{Code}(\text{Enum-Disc-NotInt})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Invalid)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad \text{DiscValue}(tok)\ \text{undefined} \quad c = \text{Code}(\text{Enum-Disc-Invalid})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Negative)**
$$\frac{\exists v \in \text{Variants}(E).\ \text{disc\_opt}(v) = tok \quad \text{DiscValue}(tok) = d \quad d < 0 \quad c = \text{Code}(\text{Enum-Disc-Negative})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

**(Enum-Disc-Dup)**
$$\frac{ds = \text{DiscSeq}(\text{Variants}(E), 0) \quad \neg \text{Distinct}(ds) \quad c = \text{Code}(\text{Enum-Disc-Dup})}{\Gamma \vdash \text{EnumDiscriminants}(E) \Uparrow c}$$

$$\text{MaxDisc}(E) = \max(ds) \iff \text{EnumDiscriminants}(E) \Downarrow ds$$

$$\text{DiscType}(E) = \begin{cases}
\texttt{u8} & 0 \le \text{MaxDisc}(E) \le 255 \\
\texttt{u16} & 256 \le \text{MaxDisc}(E) \le 65{,}535 \\
\texttt{u32} & 65{,}536 \le \text{MaxDisc}(E) \le 4{,}294{,}967{,}295 \\
\texttt{u64} & \text{otherwise}
\end{cases}$$


### 5.11. Foundational Classes (Cursive0)

**Class Signatures (built-in).**

```cursive
class Drop {
    procedure drop(~!)
}

class Bitcopy { }

class Clone {
    procedure clone(~) -> Self
}
```

$$\text{BitcopyDropJudg} = \{\Gamma \vdash T : \text{BitcopyDropOk}\}$$

$$\text{ImplementsBitcopy}(T) \iff \texttt{Bitcopy} \in \text{Implements}(T)$$
$$\text{ImplementsDrop}(T) \iff \texttt{Drop} \in \text{Implements}(T)$$
$$\text{ImplementsClone}(T) \iff \texttt{Clone} \in \text{Implements}(T)$$

**(BitcopyDrop-Ok)**
$$\frac{\neg(\text{ImplementsBitcopy}(T) \land \text{ImplementsDrop}(T)) \quad (\text{ImplementsBitcopy}(T) \Rightarrow \text{ImplementsClone}(T)) \quad (\text{ImplementsBitcopy}(T) \Rightarrow \forall f : T_f \in \text{Fields}(T).\ \text{BitcopyType}(T_f))}{\Gamma \vdash T : \text{BitcopyDropOk}}$$

**(BitcopyDrop-Conflict)**
$$\frac{\text{ImplementsBitcopy}(T) \land \text{ImplementsDrop}(T) \quad c = \text{Code}(\text{BitcopyDrop-Conflict})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

**(Bitcopy-Clone-Missing)**
$$\frac{\text{ImplementsBitcopy}(T) \quad \neg \text{ImplementsClone}(T) \quad c = \text{Code}(\text{Bitcopy-Clone-Missing})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

**(Bitcopy-Field-NonBitcopy)**
$$\frac{\text{ImplementsBitcopy}(T) \quad \exists f : T_f \in \text{Fields}(T).\ \neg \text{BitcopyType}(T_f) \quad c = \text{Code}(\text{Bitcopy-Field-NonBitcopy})}{\Gamma \vdash T : \text{BitcopyDropOk} \Uparrow c}$$

$$\text{BitcopyTypeCore}(T) \iff
\begin{cases}
\text{false} & T = \text{TypePerm}(\texttt{unique}, \_) \\
\text{BuiltinBitcopyType}(T_0) \lor \Gamma \vdash T_0 <: \texttt{Bitcopy} & T = \text{TypePerm}(p, T_0) \land p \ne \texttt{unique} \\
\text{BuiltinBitcopyType}(T) \lor \Gamma \vdash T <: \texttt{Bitcopy} & \text{otherwise}
\end{cases}$$

$$\text{BuiltinBitcopyType}(T) \iff
\begin{aligned}
&T = \text{TypePrim}(t) \land t \in \text{PrimTypes}_{C0}\ \lor \\
&T = \text{TypePtr}(U, s)\ \lor \\
&T = \text{TypeRawPtr}(q, U)\ \lor \\
&T = \text{TypeSlice}(U)\ \lor \\
&T = \text{TypeFunc}(ps, R)\ \lor \\
&T = \text{TypeDynamic}(Cl)\ \lor \\
&T = \text{TypeRange}\ \lor \\
&T = \text{TypeString}(\texttt{@View})\ \lor \\
&T = \text{TypeBytes}(\texttt{@View})
\end{aligned}$$

$$\text{BuiltinDropType}(T) \iff T = \text{TypeString}(\texttt{@Managed}) \lor T = \text{TypeBytes}(\texttt{@Managed})$$

$$\text{BuiltinCloneType}(T) \iff \text{BuiltinBitcopyType}(T)$$

### 5.12. Initialization Planning

**Module Prefix Resolution.**
$$P = \text{Project}(\Gamma)$$
$$m = \text{CurrentModule}(\Gamma)$$
$$\text{Modules} = P.\text{modules}$$
$$\text{PathPrefix}(path, pref) \iff \exists rest.\ path = pref \mathbin{+\!\!+} rest$$

**Alias Expansion.**

**(AliasExpand-None)**
$$\frac{path = a::rest \quad a \notin \text{dom}(\text{AliasMap}(m))}{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path}$$

**(AliasExpand-Yes)**
$$\frac{path = a::rest \quad a \in \text{dom}(\text{AliasMap}(m)) \quad \text{AliasMap}(m)[a] = p_a}{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow p_a \mathbin{+\!\!+} rest}$$

**(ModulePrefix-Direct)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path' \quad \exists p \in Modules,\ \text{PathPrefix}(path',p) \quad p = \arg\max_{q \in Modules,\ \text{PathPrefix}(path',q)} |q|}{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{AliasMap}(m)) \Downarrow p}$$

**(ModulePrefix-None)**
$$\frac{\Gamma \vdash \text{AliasExpand}(path, \text{AliasMap}(m)) \Downarrow path' \quad \neg \exists p \in Modules.\ \text{PathPrefix}(path',p)}{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{AliasMap}(m)) \uparrow}$$

$$env = \langle \text{self},\ \text{Modules},\ \text{AliasMap}(m),\ \text{UsingValueMap},\ \text{UsingTypeMap} \rangle$$

**(Reachable-Edge)**
$$\frac{(u,v) \in E}{\Gamma \vdash \text{Reachable}(u,v,E)}$$

**(Reachable-Step)**
$$\frac{(u,w) \in E \quad \Gamma \vdash \text{Reachable}(w,v,E)}{\Gamma \vdash \text{Reachable}(u,v,E)}$$

**Type References.**
$$\text{FullPath}(path, name) = path \mathbin{+\!\!+} [name]$$
$$\text{EnumPath}(path) = p \iff \text{SplitLast}(path) = (p, n)$$
$$\text{VariantName}(path) = n \iff \text{SplitLast}(path) = (p, n)$$

$$\text{TypeRefsJudg} = \{\text{TypeRefsTy},\ \text{TypeRefsRef},\ \text{TypeRefsExpr},\ \text{TypeRefsPat}\}$$
$$\text{Modules} = env.\text{Modules}$$
$$\text{Alias} = env.\text{Alias}$$
$$\text{UsingTypeMap} = env.\text{UsingTypeMap}$$

**(TypeRef-Path)**
$$\frac{|path| \ge 2 \quad \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self}}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \{mp\}}$$

**(TypeRef-Using)**
$$\frac{path = [name] \quad name \in \text{dom}(\text{UsingTypeMap}) \quad \text{UsingTypeMap}[name] \ne env.\text{self}}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \{\text{UsingTypeMap}[name]\}}$$

**(TypeRef-Path-Local)**
$$\frac{(|path| \ne 1 \ \lor\ (path = [name] \land name \notin \text{dom}(\text{UsingTypeMap}))) \quad (\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self})}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow \emptyset}$$

**(TypeRef-Dynamic)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeDynamic}(path), env) \Downarrow T}$$

**(TypeRef-ModalState)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeModalState}(path, state), env) \Downarrow T}$$

**(TypeRef-Perm)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(base, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePerm}(perm, base), env) \Downarrow T}$$

**(TypeRef-Prim)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePrim}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeTuple}([t_1,\ldots,t_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-Array)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsExpr}(size\_expr, env) \Downarrow T_s}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeArray}(elem, size\_expr), env) \Downarrow T_e \cup T_s}$$

**(TypeRef-Slice)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeSlice}(elem), env) \Downarrow T}$$

**(TypeRef-Union)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeUnion}([t_1,\ldots,t_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-Func)**
$$\frac{\forall i,\ \text{params}_i = \langle m_i, t_i \rangle \quad \Gamma \vdash \text{TypeRefsTy}(t_i, env) \Downarrow T_i \quad \Gamma \vdash \text{TypeRefsTy}(ret, env) \Downarrow T_r}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeFunc}([\text{params}_1,\ldots,\text{params}_n], ret), env) \Downarrow (\bigcup_{i=1}^n T_i) \cup T_r}$$

**(TypeRef-String)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeString}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Bytes)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeBytes}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-Ptr)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypePtr}(elem, \_), env) \Downarrow T}$$

**(TypeRef-RawPtr)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(elem, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeRawPtr}(\_, elem), env) \Downarrow T}$$

**(TypeRef-Range)**
$$\frac{}{\Gamma \vdash \text{TypeRefsTy}(\text{TypeRange}, env) \Downarrow \emptyset}$$

**(TypeRef-Ref-Path)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(path), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsRef}(\text{TypePath}(path), env) \Downarrow T}$$

**(TypeRef-Ref-ModalState)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypeModalState}(path, state), env) \Downarrow T}{\Gamma \vdash \text{TypeRefsRef}(\text{ModalStateRef}(path, state), env) \Downarrow T}$$

**(TypeRef-RecordExpr)**
$$\frac{\Gamma \vdash \text{TypeRefsRef}(r, env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T_e}{\Gamma \vdash \text{TypeRefsExpr}(\text{RecordExpr}(r, fields), env) \Downarrow T_t \cup T_e}$$

**(TypeRef-EnumLiteral)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(\text{EnumPath}(path)), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsEnumPayload}(payload\_opt, env) \Downarrow T_p}{\Gamma \vdash \text{TypeRefsExpr}(\text{EnumLiteral}(path, payload\_opt), env) \Downarrow T_t \cup T_p}$$

**(TypeRef-QualBrace)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(\text{FullPath}(path, name)), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsExpr}(\text{QualifiedApply}(path, name, \text{Brace}(fields)), env) \Downarrow T_t \cup T_f}$$

**(TypeRef-Cast)**
$$\frac{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsTy}(ty, env) \Downarrow T_t}{\Gamma \vdash \text{TypeRefsExpr}(\text{Cast}(e, ty), env) \Downarrow T_e \cup T_t}$$

**(TypeRef-Transmute)**
$$\frac{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsTy}(t_1, env) \Downarrow T_1 \quad \Gamma \vdash \text{TypeRefsTy}(t_2, env) \Downarrow T_2}{\Gamma \vdash \text{TypeRefsExpr}(\text{TransmuteExpr}(t_1, t_2, e), env) \Downarrow T_e \cup T_1 \cup T_2}$$

$$\text{TypeRefsExprRules} = \{\text{TypeRef-RecordExpr},\ \text{TypeRef-EnumLiteral},\ \text{TypeRef-QualBrace},\ \text{TypeRef-Cast},\ \text{TypeRef-Transmute},\ \text{TypeRef-Expr-Sub}\}$$
$$\text{NoSpecificTypeRefsExpr}(e) \iff \neg \exists r \in \text{TypeRefsExprRules} \setminus \{\text{TypeRef-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(TypeRef-Expr-Sub)**
$$\frac{\text{NoSpecificTypeRefsExpr}(e) \quad \text{Children\_LTR}(e) = [e_1,\ldots,e_n] \quad \forall i,\ \Gamma \vdash \text{TypeRefsExpr}(e_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-RecordPattern)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(tp), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsPat}(\text{RecordPattern}(tp, fields), env) \Downarrow T_t \cup T_f}$$

**(TypeRef-EnumPattern)**
$$\frac{\Gamma \vdash \text{TypeRefsTy}(\text{TypePath}(tp), env) \Downarrow T_t \quad \Gamma \vdash \text{TypeRefsPayload}(payload, env) \Downarrow T_p}{\Gamma \vdash \text{TypeRefsPat}(\text{EnumPattern}(tp, \_, payload), env) \Downarrow T_t \cup T_p}$$

**(TypeRef-LiteralPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{LiteralPattern}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-WildcardPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{WildcardPattern}, env) \Downarrow \emptyset}$$

**(TypeRef-IdentifierPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{IdentifierPattern}(\_), env) \Downarrow \emptyset}$$

**(TypeRef-TypedPattern)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{TypedPattern}(\_, \_), env) \Downarrow \emptyset}$$

**(TypeRef-TuplePattern)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsPat}(p_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsPat}(\text{TuplePattern}([p_1,\ldots,p_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRef-ModalPattern-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\text{ModalPattern}(\_, \bot), env) \Downarrow \emptyset}$$

**(TypeRef-ModalPattern-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPat}(\text{ModalPattern}(\_, \text{ModalRecordPayload}(fields)), env) \Downarrow T}$$

**(TypeRef-RangePattern)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(p_l, env) \Downarrow T_l \quad \Gamma \vdash \text{TypeRefsPat}(p_h, env) \Downarrow T_h}{\Gamma \vdash \text{TypeRefsPat}(\text{RangePattern}(\_, p_l, p_h), env) \Downarrow T_l \cup T_h}$$

**(TypeRef-Field-Explicit)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(p, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPat}(\langle \text{name},\ \text{pattern\_opt}=p,\ \text{span} \rangle, env) \Downarrow T}$$

**(TypeRef-Field-Implicit)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPat}(\langle \text{name},\ \text{pattern\_opt}=\bot,\ \text{span} \rangle, env) \Downarrow \emptyset}$$

**(TypeRefsExprs-Empty)**
$$\frac{}{\Gamma \vdash \text{TypeRefsExprs}([], env) \Downarrow \emptyset}$$

**(TypeRefsExprs-Cons)**
$$\frac{f = \langle \text{name}, e \rangle \quad \Gamma \vdash \text{TypeRefsExpr}(e, env) \Downarrow T_e \quad \Gamma \vdash \text{TypeRefsExprs}(fs, env) \Downarrow T_f}{\Gamma \vdash \text{TypeRefsExprs}(f::fs, env) \Downarrow T_e \cup T_f}$$

**(TypeRefsEnumPayload-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsEnumPayload}(\bot, env) \Downarrow \emptyset}$$

**(TypeRefsEnumPayload-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsExpr}(e_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsEnumPayload}(\text{Paren}([e_1,\ldots,e_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRefsEnumPayload-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsExprs}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsEnumPayload}(\text{Brace}(fields), env) \Downarrow T}$$

**(TypeRefsFields-Empty)**
$$\frac{}{\Gamma \vdash \text{TypeRefsFields}([], env) \Downarrow \emptyset}$$

**(TypeRefsFields-Cons)**
$$\frac{\Gamma \vdash \text{TypeRefsPat}(f, env) \Downarrow T_f \quad \Gamma \vdash \text{TypeRefsFields}(fs, env) \Downarrow T_s}{\Gamma \vdash \text{TypeRefsFields}(f::fs, env) \Downarrow T_f \cup T_s}$$

**(TypeRefsPayload-None)**
$$\frac{}{\Gamma \vdash \text{TypeRefsPayload}(\bot, env) \Downarrow \emptyset}$$

**(TypeRefsPayload-Tuple)**
$$\frac{\forall i,\ \Gamma \vdash \text{TypeRefsPat}(p_i, env) \Downarrow T_i}{\Gamma \vdash \text{TypeRefsPayload}(\text{TuplePayloadPattern}([p_1,\ldots,p_n]), env) \Downarrow \bigcup_{i=1}^n T_i}$$

**(TypeRefsPayload-Record)**
$$\frac{\Gamma \vdash \text{TypeRefsFields}(fields, env) \Downarrow T}{\Gamma \vdash \text{TypeRefsPayload}(\text{RecordPayloadPattern}(fields), env) \Downarrow T}$$

**Value References.**

$$\text{UsingValueMap} = env.\text{UsingValueMap}$$
$$\text{ValueRefsJudg} = \{\text{ValueRefs},\ \text{ValueRefsArgs},\ \text{ValueRefsFields}\}$$

**(ValueRef-Ident)**
$$\frac{name \in \text{dom}(\text{UsingValueMap}) \quad \text{UsingValueMap}[name] \ne env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{Identifier}(name), env) \Downarrow \{\text{UsingValueMap}[name]\}}$$

**(ValueRef-Ident-Local)**
$$\frac{name \notin \text{dom}(\text{UsingValueMap})}{\Gamma \vdash \text{ValueRefs}(\text{Identifier}(name), env) \Downarrow \emptyset}$$

**(ValueRef-Qual)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedName}(path, \_), env) \Downarrow \{mp\}}$$

**(ValueRef-Qual-Local)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self}}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedName}(path, \_), env) \Downarrow \emptyset}$$

**(ValueRef-QualApply)**
$$\frac{\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow mp \quad mp \ne env.\text{self} \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Paren}(args)), env) \Downarrow \{mp\} \cup V_a}$$

**(ValueRef-QualApply-Local)**
$$\frac{(\Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Uparrow \ \lor\ \Gamma \vdash \text{ModulePrefix}(path, Modules, \text{Alias}) \Downarrow env.\text{self}) \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Paren}(args)), env) \Downarrow V_a}$$

**(ValueRef-QualApply-Brace)**
$$\frac{\Gamma \vdash \text{ValueRefsFields}(fields, env) \Downarrow V_f}{\Gamma \vdash \text{ValueRefs}(\text{QualifiedApply}(path, \_, \text{Brace}(fields)), env) \Downarrow V_f}$$

$$\text{ValueRefsRules} = \{\text{ValueRef-Ident},\ \text{ValueRef-Ident-Local},\ \text{ValueRef-Qual},\ \text{ValueRef-Qual-Local},\ \text{ValueRef-QualApply},\ \text{ValueRef-QualApply-Local},\ \text{ValueRef-QualApply-Brace},\ \text{ValueRef-Expr-Sub}\}$$
$$\text{NoSpecificValueRefsExpr}(e) \iff \neg \exists r \in \text{ValueRefsRules} \setminus \{\text{ValueRef-Expr-Sub}\}.\ \text{PremisesHold}(r, e)$$

**(ValueRef-Expr-Sub)**
$$\frac{\text{NoSpecificValueRefsExpr}(e) \quad \text{Children\_LTR}(e) = [e_1,\ldots,e_n] \quad \forall i,\ \Gamma \vdash \text{ValueRefs}(e_i, env) \Downarrow V_i}{\Gamma \vdash \text{ValueRefs}(e, env) \Downarrow \bigcup_{i=1}^n V_i}$$

**(ValueRefsArgs-Empty)**
$$\frac{}{\Gamma \vdash \text{ValueRefsArgs}([], env) \Downarrow \emptyset}$$

**(ValueRefsArgs-Cons)**
$$\frac{a = \langle \text{moved}, e, \text{span} \rangle \quad \Gamma \vdash \text{ValueRefs}(e, env) \Downarrow V_e \quad \Gamma \vdash \text{ValueRefsArgs}(args, env) \Downarrow V_a}{\Gamma \vdash \text{ValueRefsArgs}(a::args, env) \Downarrow V_e \cup V_a}$$

**(ValueRefsFields-Empty)**
$$\frac{}{\Gamma \vdash \text{ValueRefsFields}([], env) \Downarrow \emptyset}$$

**(ValueRefsFields-Cons)**
$$\frac{f = \langle \text{name}, e \rangle \quad \Gamma \vdash \text{ValueRefs}(e, env) \Downarrow V_e \quad \Gamma \vdash \text{ValueRefsFields}(fs, env) \Downarrow V_f}{\Gamma \vdash \text{ValueRefsFields}(f::fs, env) \Downarrow V_e \cup V_f}$$

**Dependency Sets.**

$$env_m = \langle \text{self}=m,\ \text{Modules}=P.\text{modules},\ \text{Alias}_m,\ \text{UsingValueMap}_m,\ \text{UsingTypeMap}_m \rangle$$
$$\text{Alias}_m = \text{AliasMap}(m)$$
$$\text{UsingValueMap}_m = \text{UsingValueMap}(m)$$
$$\text{UsingTypeMap}_m = \text{UsingTypeMap}(m)$$
$$\text{ASTModule}(P, m) = \text{ModuleMap}(P, m)$$

$$\text{TypeOptSet}(\bot) = \emptyset$$
$$\text{TypeOptSet}(T) = \{T\}$$
$$\text{ParamTypeSet}(params) = \{ t \mid \exists mode,name.\ \langle mode,name,t \rangle \in params \}$$
$$\text{RecvTypeSet}(\text{ReceiverExplicit}(\_, t)) = \{t\}$$
$$\text{RecvTypeSet}(\text{ReceiverShorthand}(\_)) = \emptyset$$
$$\text{ClassPathTypeSet}(paths) = \{ \text{TypePath}(p) \mid p \in paths \}$$

$$\text{RecordFieldTypeSet}(members) = \{ t \mid \exists vis,name,init,span,doc.\ \text{FieldDecl}(vis,name,t,init,span,doc) \in members \}$$
$$\text{RecordMethodRecvTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{RecvTypeSet}(recv) \}$$
$$\text{RecordMethodParamTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{ParamTypeSet}(params) \}$$
$$\text{RecordMethodRetTypes}(members) = \{ t \mid \exists vis,ov,name,recv,params,ret,body,span,doc.\ \text{MethodDecl}(vis,ov,name,recv,params,ret,body,span,doc) \in members \land t \in \text{TypeOptSet}(ret) \}$$
$$\text{RecordMemberTypeSet}(members) = \text{RecordFieldTypeSet}(members) \cup \text{RecordMethodRecvTypes}(members) \cup \text{RecordMethodParamTypes}(members) \cup \text{RecordMethodRetTypes}(members)$$

$$\text{ClassFieldTypeSet}(items) = \{ t \mid \exists vis,name,span,doc.\ \text{ClassFieldDecl}(vis,name,t,span,doc) \in items \}$$
$$\text{ClassMethodRecvTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{RecvTypeSet}(recv) \}$$
$$\text{ClassMethodParamTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{ParamTypeSet}(params) \}$$
$$\text{ClassMethodRetTypes}(items) = \{ t \mid \exists vis,name,recv,params,ret,body,span,doc.\ \text{ClassMethodDecl}(vis,name,recv,params,ret,body,span,doc) \in items \land t \in \text{TypeOptSet}(ret) \}$$
$$\text{ClassItemTypeSet}(items) = \text{ClassFieldTypeSet}(items) \cup \text{ClassMethodRecvTypes}(items) \cup \text{ClassMethodParamTypes}(items) \cup \text{ClassMethodRetTypes}(items)$$

$$\text{VariantPayloadTypeSet}(\bot) = \emptyset$$
$$\text{VariantPayloadTypeSet}(\text{TuplePayload}(tys)) = \{ t \mid t \in tys \}$$
$$\text{VariantPayloadTypeSet}(\text{RecordPayload}(fields)) = \{ t \mid \exists vis,name,init,span,doc.\ \text{FieldDecl}(vis,name,t,init,span,doc) \in fields \}$$
$$\text{EnumVariantTypeSet}(variants) = \{ t \mid \exists name,payload,disc,span,doc.\ \text{VariantDecl}(name,payload,disc,span,doc) \in variants \land t \in \text{VariantPayloadTypeSet}(payload) \}$$

$$\text{TypePos}_\text{Static}(P, m) = \{ t \mid \exists vis,mut,bind,span,doc.\ \langle \text{StaticDecl}, vis, mut, bind, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land bind.\text{type\_opt} = t \land t \ne \bot \}$$
$$\text{TypePos}_\text{Proc}(P, m) = \{ t \mid \exists vis,name,params,ret,body,span,doc.\ \langle \text{ProcedureDecl}, vis, name, params, ret, body, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ParamTypeSet}(params) \cup \text{TypeOptSet}(ret)) \}$$
$$\text{TypePos}_\text{Record}(P, m) = \{ t \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(impls) \cup \text{RecordMemberTypeSet}(members)) \}$$
$$\text{TypePos}_\text{Enum}(P, m) = \{ t \mid \exists vis,name,impls,variants,span,doc.\ \langle \text{EnumDecl}, vis, name, impls, variants, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(impls) \cup \text{EnumVariantTypeSet}(variants)) \}$$
$$\text{TypePos}_\text{Modal}(P, m) = \{ t \mid \exists vis,name,impls,states,span,doc.\ \langle \text{ModalDecl}, vis, name, impls, states, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in \text{ClassPathTypeSet}(impls) \}$$
$$\text{TypePos}_\text{Class}(P, m) = \{ t \mid \exists vis,name,supers,items,span,doc.\ \langle \text{ClassDecl}, vis, name, supers, items, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t \in (\text{ClassPathTypeSet}(supers) \cup \text{ClassItemTypeSet}(items)) \}$$
$$\text{TypePos}_\text{Alias}(P, m) = \{ t \mid \exists vis,name,ty,span,doc.\ \langle \text{TypeAliasDecl}, vis, name, ty, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land t = ty \}$$
$$\text{TypePositions}(P, m) = \text{TypePos}_\text{Static}(P, m) \cup \text{TypePos}_\text{Proc}(P, m) \cup \text{TypePos}_\text{Record}(P, m) \cup \text{TypePos}_\text{Enum}(P, m) \cup \text{TypePos}_\text{Modal}(P, m) \cup \text{TypePos}_\text{Class}(P, m) \cup \text{TypePos}_\text{Alias}(P, m)$$

$$\text{ArraySizeExprs}(P, m) = \{ e \mid \exists elem.\ \text{TypeArray}(elem, e) \in \text{TypePositions}(P, m) \}$$
$$\text{EnumDiscriminantExprs}(P, m) = \{ e \mid \exists vis,name,impls,variants,span,doc.\ \langle \text{EnumDecl}, vis, name, impls, variants, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists v.\ v = \text{VariantDecl}(\_,\_,e,\_,\_) \in variants \land e \ne \bot \}$$
$$\text{TypePosExprs}(P, m) = \text{ArraySizeExprs}(P, m) \cup \text{EnumDiscriminantExprs}(P, m)$$

$$\text{Elems}(v) =
\begin{cases}
\{v\} & v \in \text{ASTNode} \\
\{x \mid x \in v \land x \in \text{ASTNode}\} & v \in [\_] \\
\emptyset & v = \bot \\
\emptyset & \text{otherwise}
\end{cases}$$
$$\text{Child}(x,y) \iff \exists C,\ a_1,\ldots,a_k.\ x = C(a_1,\ldots,a_k) \land y \in \bigcup_{i=1}^k \text{Elems}(a_i)$$
$$E_{\text{child}} = \{ (x,y) \mid \text{Child}(x,y) \}$$
$$\text{Subnode}(x,y) \iff x = y \lor \Gamma \vdash \text{Reachable}(x,y,E_{\text{child}})$$
$$\text{ExprNodes}(P, m) = \{ e \mid e \in \text{Expr} \land \text{Subnode}(\text{ASTModule}(P, m), e) \}$$
$$\text{PatNodes}(P, m) = \{ p \mid p \in \text{Pattern} \land \text{Subnode}(\text{ASTModule}(P, m), p) \}$$
$$\text{ExprNodesOf}(x) = \{ e \mid e \in \text{Expr} \land \text{Subnode}(x, e) \}$$

$$\text{TypeDeps}(P, m) = \{ n \mid \exists t \in \text{TypePositions}(P, m).\ \Gamma \vdash \text{TypeRefsTy}(t, env_m) \Downarrow T \land n \in T \} \cup \{ n \mid \exists p \in \text{PatNodes}(P, m).\ \Gamma \vdash \text{TypeRefsPat}(p, env_m) \Downarrow T \land n \in T \} \cup \{ n \mid \exists e \in (\text{ExprNodes}(P, m) \cup \text{TypePosExprs}(P, m)).\ \Gamma \vdash \text{TypeRefsExpr}(e, env_m) \Downarrow T \land n \in T \}$$

$$\text{StaticInitExprs}(P, m) = \{ init \mid \exists vis,mut,bind,span,doc.\ \langle \text{StaticDecl}, vis, mut, bind, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land bind.\text{init} = init \}$$
$$\text{RecordFieldInitExprs}(P, m) = \{ init \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists f.\ f = \text{FieldDecl}(\_,\_,\_,init,\_,\_) \in members \land init \ne \bot \}$$
$$\text{ProcBodies}(P, m) = \{ body \mid \exists vis,name,params,ret,body,span,doc.\ \langle \text{ProcedureDecl}, vis, name, params, ret, body, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \}$$
$$\text{RecordMethodBodies}(P, m) = \{ body \mid \exists vis,name,impls,members,span,doc.\ \langle \text{RecordDecl}, vis, name, impls, members, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists md.\ md = \text{MethodDecl}(\_,\_,\_,\_,\_,\_,body,\_,\_) \in members \}$$
$$\text{ClassMethodBodies}(P, m) = \{ body \mid \exists vis,name,supers,items,span,doc.\ \langle \text{ClassDecl}, vis, name, supers, items, span, doc \rangle \in \text{ASTModule}(P, m).\text{items} \land \exists md.\ md = \text{ClassMethodDecl}(\_,\_,\_,\_,\_,body,\_,\_) \in items \land body \ne \bot \}$$

$$\text{ValueDepsEager}(P, m) = \{ n \mid \exists e \in \text{StaticInitExprs}(P, m).\ \Gamma \vdash \text{ValueRefs}(e, env_m) \Downarrow V \land n \in V \}$$
$$\text{ValueDepsLazy}(P, m) = \{ n \mid \exists e \in \text{RecordFieldInitExprs}(P, m) \cup \bigcup_{b \in (\text{ProcBodies}(P, m) \cup \text{RecordMethodBodies}(P, m) \cup \text{ClassMethodBodies}(P, m))} \text{ExprNodesOf}(b).\ \Gamma \vdash \text{ValueRefs}(e, env_m) \Downarrow V \land n \in V \}$$

**Dependency Graph.**

$$V = \text{Modules}$$

$$E_{type} = \{(m, n) \mid n \in \text{TypeDeps}(P, m)\}$$
$$E_{val}^{eager} = \{(m, n) \mid n \in \text{ValueDepsEager}(P, m)\}$$
$$E_{val}^{lazy} = \{(m, n) \mid n \in \text{ValueDepsLazy}(P, m)\}$$

$$G = \langle V,\ E_{type},\ E_{val}^{eager},\ E_{val}^{lazy} \rangle$$
$$G_e = \langle V,\ E_{val}^{eager} \rangle$$

**(WF-Acyclic-Eager)**
$$\frac{\forall v \in V,\ \neg \text{Reachable}(v, v, E_{val}^{eager})}{\Gamma \vdash G_e : \text{DAG}}$$

## 6. Phase 4: Code Generation

### 6.0. Codegen Model and Judgments

$$\text{ArtifactsOf}(P) = \text{Set}(Objs) \cup \text{Set}(IRs) \cup \{Exe\} \iff \Gamma \vdash \text{OutputPipeline}(P) \Downarrow (Objs, IRs, Exe)$$
$$\text{IRTarget} = \texttt{"LLVM-21.1.8"}$$
$$\text{ObjTarget} = \texttt{"COFF"}$$
$$\text{LLVMValid}_{21.1.8}(L) \iff L \in \text{LLVMIR}_{21.1.8}$$
$$\forall IR,L.\ \Gamma \vdash \text{LowerIR}(IR) \Downarrow L \Rightarrow \text{LLVMValid}_{21.1.8}(L)$$

$$\text{CodegenJudg} = \{\text{CodegenProject},\ \text{CodegenModule},\ \text{CodegenItem},\ \text{CodegenExpr},\ \text{CodegenStmt},\ \text{CodegenBlock},\ \text{CodegenPlace}\}$$

$$\text{IRDefined}(IR) \iff \forall \sigma.\ \exists out,\sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')$$

$$\text{CodegenExprValCorrect} \iff \forall e, IR, v, \sigma, v', \sigma'.\ \left(\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v'), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(v'), \sigma') \land v = v'\right)$$
$$\text{CodegenExprCtrlCorrect} \iff \forall e, IR, v, \sigma, \kappa, \sigma'.\ \left(\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right)$$
$$\text{CodegenStmtCorrect} \iff \forall s, IR, \sigma, sout, \sigma'.\ \left(\Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR \land \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (sout, \sigma')\right)$$
$$\text{CodegenBlockValCorrect} \iff \forall b, IR, v, \sigma, v', \sigma'.\ \left(\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (\text{Val}(v'), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(v'), \sigma') \land v = v'\right)$$
$$\text{CodegenBlockCtrlCorrect} \iff \forall b, IR, v, \sigma, \kappa, \sigma'.\ \left(\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right) \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')\right)$$

$$\text{CodegenCorrect} \iff \text{CodegenExprValCorrect} \land \text{CodegenExprCtrlCorrect} \land \text{CodegenStmtCorrect} \land \text{CodegenBlockValCorrect} \land \text{CodegenBlockCtrlCorrect}$$
$$\text{CodegenUndefined} \iff \exists e,IR,v.\ \Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle \land \neg \text{IRDefined}(IR)\ \lor\ \exists s,IR.\ \Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR \land \neg \text{IRDefined}(IR)\ \lor\ \exists b,IR,v.\ \Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle \land \neg \text{IRDefined}(IR)$$
$$\text{CodegenUndefined} \Rightarrow \text{OutsideConformance}$$

$$\text{IRDecls} = [\text{IRDecl}]$$
$$\text{ModuleIR} = \text{IRDecls}$$

**(CG-Project)**
$$\frac{\Gamma \vdash \text{OutputPipeline}(P) \Downarrow (Objs, IRs, Exe)}{\Gamma \vdash \text{CodegenProject}(P) \Downarrow (\text{Set}(Objs) \cup \text{Set}(IRs) \cup \{Exe\})}$$

$$\text{Items}(P, m) = \text{ASTModule}(P, m).\text{items}$$

**(CG-Module)**
$$\frac{\text{Items}(\text{Project}(\Gamma), m) = [i_1,\ldots,i_k] \quad \forall j,\ \Gamma \vdash \text{CodegenItem}(i_j) \Downarrow ds_j \quad \Gamma \vdash \text{InitFn}(m) \Downarrow sym_{\text{init}} \quad \Gamma \vdash \text{DeinitFn}(m) \Downarrow sym_{\text{deinit}} \quad \Gamma \vdash \text{Lower-StaticInit}(m) \Downarrow IR_{\text{init}} \quad \Gamma \vdash \text{Lower-StaticDeinit}(m) \Downarrow IR_{\text{deinit}}}{\Gamma \vdash \text{CodegenModule}(m) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k \mathbin{+\!\!+} [\text{ProcIR}(sym_{\text{init}}, [\text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{init}}),\ \text{ProcIR}(sym_{\text{deinit}}, [\text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{deinit}})]}$$

$$\Gamma \vdash \text{CodegenItem}(item) \Downarrow ds \Rightarrow ds \in \text{IRDecls}$$
$$\text{ProcIR} : \text{Symbol} \times [\text{Param}] \times \text{Type} \times \text{IR} \to \text{IRDecl}$$

$$\text{PanicOutParam} = \langle \texttt{move},\ \text{PanicOutName},\ \text{PanicOutType} \rangle$$
$$\text{CodegenParams}(params) = params \mathbin{+\!\!+} [\text{PanicOutParam}]$$

$$\text{MethodParams}(R, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(\text{Self}_R, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params}$$
$$\text{ClassMethodParams}(Cl, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(\text{SelfVar}, m.\text{receiver}) \rangle] \mathbin{+\!\!+} m.\text{params}$$

$$\text{ParamList}_T(T, params) = [\langle mode_i, name_i, \text{SubstSelf}(T, ty_i) \rangle \mid \langle mode_i, name_i, ty_i \rangle \in params]$$
$$\text{ClassMethodParams}_T(T, m) = [\langle \text{RecvMode}(m.\text{receiver}), \texttt{self}, \text{RecvType}(T, m.\text{receiver}) \rangle] \mathbin{+\!\!+} \text{ParamList}_T(T, m.\text{params})$$

$$\text{StateMethodParams}(M, S, md) = [\langle \bot, \texttt{self}, \text{TypePerm}(\texttt{const}, \text{TypeModalState}(\text{ModalPath}(M), S)) \rangle] \mathbin{+\!\!+} md.\text{params}$$
$$\text{TransitionParams}(M, S, tr) = [\langle \texttt{move}, \texttt{self}, \text{TypePerm}(\texttt{unique}, \text{TypeModalState}(\text{ModalPath}(M), S)) \rangle] \mathbin{+\!\!+} tr.\text{params}$$

$$\text{StateList}(M) = [s \mid s \in M.\text{states}]$$
$$\text{DefaultImpl} : \text{Type} \times \text{ClassMethodDecl} \to \text{ASTItem}$$
$$\text{DefaultUserSet}(m) = \{ T \mid \Gamma \vdash T \text{ uses default } m \}$$
$$\text{DefaultUserList}(m) = \text{sort}_{\prec_{\text{type}}}(\text{DefaultUserSet}(m))$$

**(CG-Item-Using)**
$$\frac{\text{item} = \text{UsingDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-TypeAlias)**
$$\frac{\text{item} = \text{TypeAliasDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-Procedure-Main)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, \texttt{"main"}, params, ret\_opt, body, span, doc) \quad Project(\Gamma) = P \quad \text{Executable}(P) \quad \text{MainSigOk}(\text{item}) \quad R = \text{ProcReturn}(ret\_opt) \quad \Gamma \vdash \text{EmitInitPlan}(P) \Downarrow IR_{\text{init}} \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_{\text{body}}, v \rangle \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym \quad params' = \text{CodegenParams}(params)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow [\text{ProcIR}(sym, params', R, \text{SeqIR}(IR_{\text{init}}, IR_{\text{body}}))]}$$

**(CG-Item-Procedure)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc) \quad Project(\Gamma) = P \quad (name \ne \texttt{"main"} \ \lor\ \neg \text{Executable}(P)) \quad R = \text{ProcReturn}(ret\_opt) \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym \quad params' = \text{CodegenParams}(params)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow [\text{ProcIR}(sym, params', R, IR)]}$$

**(CG-Item-Static)**
$$\frac{\text{item} = \text{StaticDecl}(\_) \quad \Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow ds}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds}$$

**(CG-Item-Record)**
$$\frac{\text{item} = \text{RecordDecl}(vis, name, implements, members, span, doc) \quad R = \text{item} \quad \text{Methods}(R) = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{CodegenItem}(m_i) \Downarrow ds_i}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k}$$

**(CG-Item-Method)**
$$\frac{m \in \text{Methods}(R) \quad params' = \text{MethodParams}(R, m) \quad R_m = \text{ReturnType}(m) \quad m.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(m) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow [\text{ProcIR}(sym, params'', R_m, IR)]}$$

**(CG-Item-Modal)**
$$\frac{\text{item} = \text{ModalDecl}(vis, name, implements, states, span, doc) \quad M = \text{item} \quad \forall S \in \text{StateList}(M),\ \forall md \in \text{Methods}(S),\ \Gamma \vdash \text{CodegenItem}(md) \Downarrow ds_{S,md} \quad \forall S \in \text{StateList}(M),\ \forall tr \in \text{Transitions}(S),\ \Gamma \vdash \text{CodegenItem}(tr) \Downarrow ds_{S,tr}}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow \mathbin{+\!\!+}_{S \in \text{StateList}(M)} \left( \mathbin{+\!\!+}_{md \in \text{Methods}(S)} ds_{S,md} \mathbin{+\!\!+} \mathbin{+\!\!+}_{tr \in \text{Transitions}(S)} ds_{S,tr} \right)}$$

**(CG-Item-StateMethod)**
$$\frac{S \in \text{StateList}(M) \quad md \in \text{Methods}(S) \quad params' = \text{StateMethodParams}(M, S, md) \quad R_m = \text{ReturnType}(md) \quad md.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(md) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(md) \Downarrow [\text{ProcIR}(sym, params'', R_m, IR)]}$$

**(CG-Item-Transition)**
$$\frac{S \in \text{StateList}(M) \quad tr \in \text{Transitions}(S) \quad params' = \text{TransitionParams}(M, S, tr) \quad \text{TransitionSig}(M, S, tr).\text{target} = S_t \quad tr.\text{body} = body \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR, v \rangle \quad \Gamma \vdash \text{Mangle}(tr) \Downarrow sym \quad params'' = \text{CodegenParams}(params')}{\Gamma \vdash \text{CodegenItem}(tr) \Downarrow [\text{ProcIR}(sym, params'', \text{TypeModalState}(\text{ModalPath}(M), S_t), IR)]}$$

**(CG-Item-Class)**
$$\frac{\text{item} = \text{ClassDecl}(vis, name, supers, items, span, doc) \quad Cl = \text{item} \quad \text{ClassMethods}(Cl) = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{CodegenItem}(m_i) \Downarrow ds_i}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ds_k}$$

**(CG-Item-ClassMethod-Abstract)**
$$\frac{m \in \text{ClassMethods}(Cl) \quad m.\text{body\_opt} = \bot}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow []}$$

**(CG-Item-ClassMethod-Body)**
$$\frac{m \in \text{ClassMethods}(Cl) \quad m.\text{body\_opt} = body \quad \text{DefaultUserList}(m) = [T_1,\ldots,T_k] \quad \forall i,\ \Gamma_i = \Gamma[\text{SelfVar} \mapsto T_i] \quad \text{params}_i = \text{ClassMethodParams}_T(T_i, m) \quad R_i = \text{ReturnType}_T(T_i, m) \quad \Gamma_i \vdash \text{LowerBlock}(body) \Downarrow \langle IR_i, v_i \rangle \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T_i, m)) \Downarrow sym_i \quad \text{params}_i' = \text{CodegenParams}(\text{params}_i)}{\Gamma \vdash \text{CodegenItem}(m) \Downarrow [\text{ProcIR}(sym_1, \text{params}_1', R_1, IR_1),\ldots,\text{ProcIR}(sym_k, \text{params}_k', R_k, IR_k)]}$$

**(CG-Item-Enum)**
$$\frac{\text{item} = \text{EnumDecl}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$

**(CG-Item-ErrorItem)**
$$\frac{\text{item} = \text{ErrorItem}(\_)}{\Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow []}$$
$$\exists \text{item}, ds.\ \text{item} = \text{ErrorItem}(\_) \land \Gamma \vdash \text{CodegenItem}(\text{item}) \Downarrow ds \Rightarrow \text{OutsideConformance}$$

**(CG-Expr)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{CodegenExpr}(e) \Downarrow \langle IR, v \rangle}$$

**(CG-Stmt)**
$$\frac{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR}{\Gamma \vdash \text{CodegenStmt}(s) \Downarrow IR}$$

**(CG-Block)**
$$\frac{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{CodegenBlock}(b) \Downarrow \langle IR, v \rangle}$$

**(CG-Place)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{\Gamma \vdash \text{CodegenPlace}(p) \Downarrow l}$$


### 6.1. Layout and Representation

#### 6.1.1. Primitive Layout and Encoding

$$\text{PtrSize} = 8$$
$$\text{PointerSize} = \text{PtrSize}$$
$$\text{PtrAlign} = 8$$

$$\text{PrimSize}(\texttt{"i8"}) = 1$$
$$\text{PrimSize}(\texttt{"i16"}) = 2$$
$$\text{PrimSize}(\texttt{"i32"}) = 4$$
$$\text{PrimSize}(\texttt{"i64"}) = 8$$
$$\text{PrimSize}(\texttt{"i128"}) = 16$$
$$\text{PrimSize}(\texttt{"u8"}) = 1$$
$$\text{PrimSize}(\texttt{"u16"}) = 2$$
$$\text{PrimSize}(\texttt{"u32"}) = 4$$
$$\text{PrimSize}(\texttt{"u64"}) = 8$$
$$\text{PrimSize}(\texttt{"u128"}) = 16$$
$$\text{PrimSize}(\texttt{"f16"}) = 2$$
$$\text{PrimSize}(\texttt{"f32"}) = 4$$
$$\text{PrimSize}(\texttt{"f64"}) = 8$$
$$\text{PrimSize}(\texttt{"bool"}) = 1$$
$$\text{PrimSize}(\texttt{"char"}) = 4$$
$$\text{PrimSize}(\texttt{"usize"}) = \text{PtrSize}$$
$$\text{PrimSize}(\texttt{"isize"}) = \text{PtrSize}$$
$$\text{PrimSize}(\texttt{"()"}) = 0$$
$$\text{PrimSize}(\texttt{"!"}) = 0$$

$$\text{PrimAlign}(\texttt{"i8"}) = 1$$
$$\text{PrimAlign}(\texttt{"i16"}) = 2$$
$$\text{PrimAlign}(\texttt{"i32"}) = 4$$
$$\text{PrimAlign}(\texttt{"i64"}) = 8$$
$$\text{PrimAlign}(\texttt{"i128"}) = 16$$
$$\text{PrimAlign}(\texttt{"u8"}) = 1$$
$$\text{PrimAlign}(\texttt{"u16"}) = 2$$
$$\text{PrimAlign}(\texttt{"u32"}) = 4$$
$$\text{PrimAlign}(\texttt{"u64"}) = 8$$
$$\text{PrimAlign}(\texttt{"u128"}) = 16$$
$$\text{PrimAlign}(\texttt{"f16"}) = 2$$
$$\text{PrimAlign}(\texttt{"f32"}) = 4$$
$$\text{PrimAlign}(\texttt{"f64"}) = 8$$
$$\text{PrimAlign}(\texttt{"bool"}) = 1$$
$$\text{PrimAlign}(\texttt{"char"}) = 4$$
$$\text{PrimAlign}(\texttt{"usize"}) = \text{PtrAlign}$$
$$\text{PrimAlign}(\texttt{"isize"}) = \text{PtrAlign}$$
$$\text{PrimAlign}(\texttt{"()"}) = 1$$
$$\text{PrimAlign}(\texttt{"!"}) = 1$$

$$\text{LayoutJudg} = \{\text{sizeof},\ \text{alignof},\ \text{layout}\}$$

**(Size-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimSize}(name) = n}{\Gamma \vdash \text{sizeof}(T) = n}$$

**(Align-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimAlign}(name) = a}{\Gamma \vdash \text{alignof}(T) = a}$$

**(Layout-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{PrimSize}(name) = n \quad \text{PrimAlign}(name) = a}{\Gamma \vdash \text{layout}(T) \Downarrow \langle n, a \rangle}$$

**Encoding.**

$$\text{LEBytes}(v, n) = \text{LE}(v \bmod 2^{8n}, n)$$
$$\text{FloatBits}_t(v) = \text{IEEE754Bits}(t, v)$$
$$\text{EncodeConstJudg} = \{\text{EncodeConst}\}$$
$$\text{BoolByte}(\text{false}) = \texttt{0x00}$$
$$\text{BoolByte}(\text{true}) = \texttt{0x01}$$

**(Encode-Bool)**
$$\frac{\text{LiteralValue}(lit, \text{TypePrim}(\texttt{"bool"})) = b}{\Gamma \vdash \text{EncodeConst}(\text{TypePrim}(\texttt{"bool"}), lit) \Downarrow \text{LEBytes}(\text{BoolByte}(b), 1)}$$

**(Encode-Char)**
$$\frac{\text{LiteralValue}(lit, \text{TypePrim}(\texttt{"char"})) = c}{\Gamma \vdash \text{EncodeConst}(\text{TypePrim}(\texttt{"char"}), lit) \Downarrow \text{LEBytes}(c, 4)}$$

**(Encode-Int)**
$$\frac{lit.\text{kind} = \text{IntLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad v = \text{LiteralValue}(lit, T) \quad x = \text{IntValValue}(v)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(x, \text{sizeof}(T))}$$

**(Encode-Float)**
$$\frac{lit.\text{kind} = \text{FloatLiteral} \quad T = \text{TypePrim}(t) \quad t \in \text{FloatTypes} \quad v = \text{LiteralValue}(lit, T) \quad x = \text{FloatValValue}(v)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(\text{FloatBits}_t(x), \text{sizeof}(T))}$$

**(Encode-Unit)**
$$\frac{T = \text{TypePrim}(\texttt{"()"})}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow []}$$

**(Encode-Never)**
$$\frac{T = \text{TypePrim}(\texttt{"!"})}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow []}$$

**(Encode-RawPtr-Null)**
$$\frac{lit.\text{kind} = \text{NullLiteral} \quad T = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow \text{LEBytes}(0, \text{sizeof}(T))}$$

**Validity.**

$$\text{ValidValueJudg} = \{\text{ValidValue}\}$$

**(Valid-Bool)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"bool"}), bits) \iff bits \in \{[\texttt{0x00}],[\texttt{0x01}]\}$$

**(Valid-Char)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"char"}), bits) \iff \exists c.\ \text{LEBytes}(c, 4) = bits \land c \in \text{UnicodeScalar}$$

**(Valid-Scalar)**
$$\text{ScalarTypes} = \{\texttt{"i8"},\texttt{"i16"},\texttt{"i32"},\texttt{"i64"},\texttt{"i128"},\texttt{"u8"},\texttt{"u16"},\texttt{"u32"},\texttt{"u64"},\texttt{"u128"},\texttt{"f16"},\texttt{"f32"},\texttt{"f64"},\texttt{"usize"},\texttt{"isize"}\}$$
$$\forall t \in \text{ScalarTypes}.\ \text{ValidValue}(\text{TypePrim}(t), bits) \iff |bits| = \text{PrimSize}(t)$$

**(Valid-Unit)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"()"}), bits) \iff bits = []$$

**(Valid-Never)**
$$\text{ValidValue}(\text{TypePrim}(\texttt{"!"}), bits) \iff \text{false}$$

#### 6.1.2. Permission, Pointer, and Function Layout

**(Layout-Perm)**
$$\frac{\Gamma \vdash \text{layout}(T) \Downarrow L}{\Gamma \vdash \text{layout}(\text{TypePerm}(p, T)) \Downarrow L}$$

**(Size-Perm)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = n}{\Gamma \vdash \text{sizeof}(\text{TypePerm}(p, T)) = n}$$

**(Align-Perm)**
$$\frac{\Gamma \vdash \text{alignof}(T) = a}{\Gamma \vdash \text{alignof}(\text{TypePerm}(p, T)) = a}$$

**(Size-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Ptr)**
$$\frac{T = \text{TypePtr}(T_0, s)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, T_0)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{sizeof}(T) = \text{PtrSize}}$$

**(Align-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{layout}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

#### 6.1.3. Record Layout Without `[[layout(C)]]`

$$\text{AlignUp}(x,a) = \lceil x/a \rceil \times a \quad \text{where } a > 0$$
$$\text{Offsets}([]) = []$$
$$\text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n] \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1 \land \text{offset}_1 = 0 \land \forall i \in \{2,\ldots,n\}.\ \text{offset}_i = \text{AlignUp}(\text{offset}_{i-1} + \text{sizeof}(T_{i-1}), \text{alignof}(T_i))$$
$$\text{RecordAlign}([]) = 1$$
$$\text{RecordAlign}(fields) = \max_{i \in \{1,\ldots,n\}}(\text{alignof}(T_i)) \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1$$
$$\text{RecordSize}([]) = 0$$
$$\text{RecordSize}(fields) = \text{AlignUp}(\text{offset}_n + \text{sizeof}(T_n), \text{RecordAlign}(fields)) \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land n \ge 1 \land \text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n]$$
$$\text{RecordLayoutJudg} = \{\text{RecordLayout}\}$$

**(Layout-Record-Empty)**
$$\frac{ }{\Gamma \vdash \text{RecordLayout}([]) \Downarrow \langle 0, 1, [] \rangle}$$

**(Layout-Record-Cons)**
$$\frac{n \ge 1 \quad \text{offsets} = [offset_1,\ldots,offset_n] \quad align = \text{RecordAlign}(fields) \quad size = \text{RecordSize}(fields)}{\Gamma \vdash \text{RecordLayout}(fields) \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

$$\text{FieldOffset}(fields, f_i) = \text{offset}_i \iff fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land 1 \le i \le n \land \text{Offsets}(fields) = [\text{offset}_1,\ldots,\text{offset}_n]$$

**Type Aliases.**
$$\text{AliasBody}(p) = ty \iff \Sigma.\text{Types}[p] = \text{TypeAliasDecl}(vis, name, ty, span, doc)$$

**(Size-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{sizeof}(ty) = size}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{alignof}(ty) = align}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{layout}(ty) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.4. Union Layout and Discriminants

##### 6.1.4.1. Niche Optimization (Cursive0)

**Niche Sets.**

$$\text{NicheSet}(T) \subseteq \{ bits \mid \neg \text{ValidValue}(T, bits) \}$$
$$\text{NicheSet}(T) = \{\text{LEBytes}(0, \text{PtrSize})\} \iff \exists U.\ T = \text{TypePtr}(U, \texttt{Valid})$$
$$\text{NicheSet}(T) = \emptyset \iff \neg \exists U.\ T = \text{TypePtr}(U, \texttt{Valid})$$

$$\text{BitsToUInt}(bits) = v \iff \text{LEBytes}(v, |bits|) = bits$$
$$bits_1 \prec_u bits_2 \iff \exists v_1,v_2.\ \text{BitsToUInt}(bits_1) = v_1 \land \text{BitsToUInt}(bits_2) = v_2 \land v_1 < v_2$$
$$\text{NicheOrder}(T) = \text{sort}_{\prec_u}(\text{NicheSet}(T))$$
$$\text{NicheCount}(T) = |\text{NicheSet}(T)|$$

**Valid Pointer Non-Zero Invariant.**

$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Valid}), bits) \iff |bits| = \text{PtrSize} \land bits \ne \text{LEBytes}(0, \text{PtrSize})$$
$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Null}), bits) \iff bits = \text{LEBytes}(0, \text{PtrSize})$$
$$\text{ValidValue}(\text{TypePtr}(T,\texttt{Expired}), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(\text{TypePtr}(T,\bot), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(\text{TypeRawPtr}(q, T), bits) \iff |bits| = \text{PtrSize}$$
$$\text{ValidValue}(T, bits) \iff T \notin \{\text{TypePrim}(\_),\ \text{TypePtr}(\_,\_),\ \text{TypeRawPtr}(\_,\_)\} \land \exists v.\ \text{ValueBits}(T, v) = bits$$

**Union Niche Encoding.**

$$U = \text{TypeUnion}([T_1,\ldots,T_n])$$

**Type Ordering (Cursive0).**

$$\text{PathOrderKey}(p) = \langle \text{Fold}(p), p \rangle$$
$$\text{ArrayLen}(e) = n \iff \Gamma \vdash \text{ConstLen}(e) \Downarrow n$$

$$\text{TagKey}(\texttt{prim}) = 0$$
$$\text{TagKey}(\texttt{tuple}) = 1$$
$$\text{TagKey}(\texttt{array}) = 2$$
$$\text{TagKey}(\texttt{slice}) = 3$$
$$\text{TagKey}(\texttt{func}) = 4$$
$$\text{TagKey}(\texttt{path}) = 5$$
$$\text{TagKey}(\texttt{modal\_state}) = 6$$
$$\text{TagKey}(\texttt{string}) = 7$$
$$\text{TagKey}(\texttt{bytes}) = 8$$
$$\text{TagKey}(\texttt{dynamic}) = 9$$
$$\text{TagKey}(\texttt{ptr}) = 10$$
$$\text{TagKey}(\texttt{rawptr}) = 11$$
$$\text{TagKey}(\texttt{union}) = 12$$
$$\text{TagKey}(\texttt{perm}) = 13$$
$$\text{TagKey}(\texttt{range}) = 14$$

$$\text{PermKey}(\texttt{const}) = 0$$
$$\text{PermKey}(\texttt{unique}) = 1$$
$$\text{PtrStateKey}(\bot) = 0$$
$$\text{PtrStateKey}(\texttt{Valid}) = 1$$
$$\text{PtrStateKey}(\texttt{Null}) = 2$$
$$\text{PtrStateKey}(\texttt{Expired}) = 3$$
$$\text{QualKey}(\texttt{imm}) = 0$$
$$\text{QualKey}(\texttt{mut}) = 1$$
$$\text{ModeKey}(\bot) = 0$$
$$\text{ModeKey}(\texttt{move}) = 1$$
$$\text{StateKey}(\texttt{View}) = 0$$
$$\text{StateKey}(\texttt{Managed}) = 1$$
$$\text{StateKey}(\bot) = 2$$

$$\text{TypeKey}(\text{TypePrim}(name)) = \langle \text{TagKey}(\texttt{prim}), name \rangle$$
$$\text{TypeKey}(\text{TypeRange}) = \langle \text{TagKey}(\texttt{range}) \rangle$$
$$\text{TypeKey}(\text{TypeTuple}([T_1,\ldots,T_n])) = \langle \text{TagKey}(\texttt{tuple}), n, \text{TypeKey}(T_1),\ldots,\text{TypeKey}(T_n) \rangle$$
$$\text{TypeKey}(\text{TypeArray}(T, e)) = \langle \text{TagKey}(\texttt{array}), \text{TypeKey}(T), \text{ArrayLen}(e) \rangle$$
$$\text{TypeKey}(\text{TypeSlice}(T)) = \langle \text{TagKey}(\texttt{slice}), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeFunc}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R)) = \langle \text{TagKey}(\texttt{func}), n, \text{ModeKey}(m_1), \text{TypeKey}(T_1),\ldots,\text{ModeKey}(m_n), \text{TypeKey}(T_n), \text{TypeKey}(R) \rangle$$
$$\text{TypeKey}(\text{TypePath}(p)) = \langle \text{TagKey}(\texttt{path}), \text{PathOrderKey}(p) \rangle$$
$$\text{TypeKey}(\text{TypeModalState}(p, S)) = \langle \text{TagKey}(\texttt{modal\_state}), \text{PathOrderKey}(p), S \rangle$$
$$\text{TypeKey}(\text{TypeString}(st)) = \langle \text{TagKey}(\texttt{string}), \text{StateKey}(st) \rangle$$
$$\text{TypeKey}(\text{TypeBytes}(st)) = \langle \text{TagKey}(\texttt{bytes}), \text{StateKey}(st) \rangle$$
$$\text{TypeKey}(\text{TypeDynamic}(p)) = \langle \text{TagKey}(\texttt{dynamic}), \text{PathOrderKey}(p) \rangle$$
$$\text{TypeKey}(\text{TypePtr}(T, s)) = \langle \text{TagKey}(\texttt{ptr}), \text{PtrStateKey}(s), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeRawPtr}(q, T)) = \langle \text{TagKey}(\texttt{rawptr}), \text{QualKey}(q), \text{TypeKey}(T) \rangle$$
$$\text{TypeKey}(\text{TypeUnion}([T_1,\ldots,T_n])) = \langle \text{TagKey}(\texttt{union}), \text{Sort}([\text{TypeKey}(T_1),\ldots,\text{TypeKey}(T_n)]) \rangle$$
$$\text{TypeKey}(\text{TypePerm}(p, T)) = \langle \text{TagKey}(\texttt{perm}), \text{PermKey}(p), \text{TypeKey}(T) \rangle$$

$$\text{Key} = \{ \text{TypeKey}(T) \mid T \in \text{Type} \}$$
$$\text{KeyList} = \{ [k_1,\ldots,k_n] \mid \forall i.\ k_i \in \text{Key} \}$$
$$a \prec_{\text{atom}} b \iff (a,b \in \mathbb{N} \land a<b) \lor (a,b \in \text{String} \land \text{Utf8LexLess}(a,b)) \lor (a,b \in \text{Key} \land a \prec_{\text{key}} b) \lor (a,b \in \text{KeyList} \land a \prec_{\text{keylist}} b)$$
$$\text{LexLess}_{\prec}(L_1,L_2) \iff (\exists k.\ 0 \le k < |L_1| \land 0 \le k < |L_2| \land (\forall i.\ 0 \le i < k \Rightarrow L_1[i]=L_2[i]) \land L_1[k] \prec L_2[k]) \lor (|L_1| < |L_2| \land \forall i.\ 0 \le i < |L_1| \Rightarrow L_1[i]=L_2[i])$$
$$k_1 \prec_{\text{key}} k_2 \iff \text{LexLess}_{\prec_{\text{atom}}}(k_1,k_2)$$
$$L_1 \prec_{\text{keylist}} L_2 \iff \text{LexLess}_{\prec_{\text{key}}}(L_1,L_2)$$
$$\text{Sorted}_{\prec}(L) \iff \forall i,j.\ 0 \le i < j < |L| \Rightarrow \neg (L[j] \prec L[i])$$
$$\text{Sort}(L) = L' \iff \text{Permutation}(L', L) \land \text{Sorted}_{\prec_{\text{key}}}(L')$$
$$T_1 \prec_{\text{type}} T_2 \iff \text{TypeKey}(T_1) \prec_{\text{key}} \text{TypeKey}(T_2)$$

$$\text{MemberList}(U) = \text{Sort}(\text{Members}(U))$$
$$\text{MemberIndex}(U, T) = i \iff \text{MemberList}(U)[i] \equiv T$$
$$\text{UnionDiscValue}(U, T) = i \iff \text{MemberIndex}(U, T) = i$$
$$\text{EmptyMember}(T) \iff T \equiv \text{TypePrim}(\texttt{"()"})$$
$$\text{EmptyList}(U) = [\text{MemberList}(U)[i] \mid 0 \le i < |\text{MemberList}(U)| \land \text{EmptyMember}(\text{MemberList}(U)[i])]$$
$$\text{PayloadMember}(U) = T_p \iff \exists j.\ \text{MemberList}(U)[j] \equiv T_p \land \text{NicheCount}(T_p) > 0 \land (\forall i.\ 0 \le i < |\text{MemberList}(U)| \land i \ne j \Rightarrow \text{EmptyMember}(\text{MemberList}(U)[i])) \land \text{NicheCount}(T_p) \ge |\text{MemberList}(U)| - 1$$
$$\text{NicheApplies}(U) \iff \exists T_p.\ \text{PayloadMember}(U) = T_p$$

**ValueBits.**

$$\text{FieldValueList}(fs, f) = v \iff \langle f, v \rangle \in fs$$
$$\text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], [o_1,\ldots,o_n], size) = bits \iff |bits| = size \land \forall i.\ \text{ValueBits}(T_i, v_i) = b_i \land bits[o_i..o_i+|b_i|) = b_i \land \forall j.\ (\forall i.\ j \notin [o_i, o_i+|b_i|)) \Rightarrow bits[j]=\texttt{0x00}$$
$$\text{PadBytes}(b, size) = bits \iff |bits| = size \land bits[0..|b|) = b \land \forall i.\ |b| \le i < size \Rightarrow bits[i]=\texttt{0x00}$$

$$\text{ValueBits}(\text{TypePrim}(\texttt{"bool"}), v) = bits \iff (v=\text{BoolVal}(\text{true}) \land bits=[\texttt{0x01}]) \lor (v=\text{BoolVal}(\text{false}) \land bits=[\texttt{0x00}])$$
$$\text{ValueBits}(\text{TypePrim}(\texttt{"char"}), v) = bits \iff v=\text{CharVal}(u) \land \text{LEBytes}(u, 4) = bits$$
$$\text{ValueBits}(\text{TypePrim}(\texttt{"()"}), v) = bits \iff v=\text{UnitVal} \land bits = []$$
$$\text{ValueBits}(\text{TypePrim}(t), v) = bits \iff t \in \text{IntTypes} \land v=\text{IntVal}(t, x) \land \text{LEBytes}(x, \text{sizeof}(\text{TypePrim}(t))) = bits$$
$$\text{ValueBits}(\text{TypePrim}(t), v) = bits \iff t \in \text{FloatTypes} \land v=\text{FloatVal}(t, x) \land \text{LEBytes}(\text{IEEE754Bits}(t, x), \text{sizeof}(\text{TypePrim}(t))) = bits$$
$$\text{ValueBits}(\text{TypePerm}(p, T), v) = bits \iff \text{ValueBits}(T, v) = bits$$

$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Valid}), v) = bits \iff v=\text{PtrVal}(\texttt{Valid}, addr) \land addr \ne 0x0 \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Null}), v) = bits \iff v=\text{PtrVal}(\texttt{Null}, addr) \land addr = 0x0 \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \texttt{Expired}), v) = bits \iff v=\text{PtrVal}(\texttt{Expired}, addr) \land bits=\text{LEBytes}(addr, \text{PtrSize})$$
$$\text{ValueBits}(\text{TypePtr}(T, \bot), v) = bits \iff \exists s.\ s \in \text{PtrStateSet} \land \text{ValueBits}(\text{TypePtr}(T, s), v) = bits$$
$$\text{ValueBits}(\text{TypeRawPtr}(q, T), v) = bits \iff v=\text{RawPtr}(q, addr) \land bits=\text{LEBytes}(addr, \text{PtrSize})$$

$$\text{ValueBits}(\text{TypeTuple}([T_1,\ldots,T_n]), (v_1,\ldots,v_n)) = bits \iff \text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypeArray}(T, e), [v_0,\ldots,v_{n-1}]) = bits \iff \text{ArrayLen}(e)=n \land s=\text{sizeof}(T) \land |bits| = n \times s \land \forall i.\ 0 \le i < n \Rightarrow (\text{ValueBits}(T, v_i) = b_i \land bits[i \times s .. i \times s + |b_i|) = b_i)$$
$$\text{ValueBits}(\text{TypeSlice}(T), \text{SliceValue}(v, r)) = bits \iff \text{SliceBounds}(r, \text{Len}(v)) = (start, end) \land n = end - start \land \exists addr.\ \text{ValueBits}(\text{TypeRawPtr}(\texttt{imm}, T), \text{RawPtr}(\texttt{imm}, addr)) = b_{\text{ptr}} \land \text{ValueBits}(\text{TypePrim}(\texttt{"usize"}), \text{IntVal}(\texttt{"usize"}, n)) = b_{\text{len}} \land bits = b_{\text{ptr}} \mathbin{+\!\!+} b_{\text{len}}$$
$$\text{ValueBits}(\text{TypeRange}, r) = bits \iff \text{RangeValFields}(r) = [\langle \texttt{kind}, v_k \rangle,\ \langle \texttt{lo}, v_l \rangle,\ \langle \texttt{hi}, v_h \rangle] \land \text{RangeFields} = [\langle \texttt{kind}, T_k \rangle,\ \langle \texttt{lo}, T_l \rangle,\ \langle \texttt{hi}, T_h \rangle] \land \text{RecordLayout}(\text{RangeFields}) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([T_k, T_l, T_h], [v_k, v_l, v_h], offsets, size) = bits$$

$$\text{ValueBits}(\text{TypeModalState}(p, S), v) = bits \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land S \in \text{States}(M) \land v=\text{RecordValue}(\text{ModalStateRef}(p, S), fs) \land \text{Payload}(M, S) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(\text{ModalStateRef}(p, S), fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$

$$\text{EnumPayloadBits}(E, name, \bot) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\bot) \land \text{PadBytes}([], \text{PayloadSize}(E)) = bits$$
$$\text{EnumPayloadBits}(E, name, \text{TuplePayload}([v_1,\ldots,v_k])) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\text{TuplePayload}([T_1,\ldots,T_k])) \land \text{ValueBits}(\text{TypeTuple}([T_1,\ldots,T_k]), (v_1,\ldots,v_k)) = b \land \text{PadBytes}(b, \text{PayloadSize}(E)) = bits$$
$$\text{EnumPayloadBits}(E, name, \text{RecordPayload}(fs)) = bits \iff (\exists v \in \text{Variants}(E).\ v.\text{name} = name \land \text{VariantPayloadOpt}(v)=\text{RecordPayload}(fields)) \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValueList}(fs, f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = b \land \text{PadBytes}(b, \text{PayloadSize}(E)) = bits$$

$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{AliasBody}(p) = ty \land \text{ValueBits}(ty, v) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{RecordDecl}(p) = R \land v=\text{RecordValue}(\text{TypePath}(p), fs) \land \text{Fields}(R) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(\text{TypePath}(p), fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \text{EnumDecl}(p) = E \land v=\text{EnumValue}(path, payload) \land \text{EnumPath}(path)=p \land name=\text{VariantName}(path) \land \text{EnumDisc}(E, name) = d \land \text{EnumPayloadBits}(E, name, payload) = payload\_bits \land \text{EnumDiscType}(E)=D \land D=\text{TypePrim}(t) \land \text{ValueBits}(D, \text{IntVal}(t, d)) = disc\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{PayloadSize}(E), \text{PayloadAlign}(E), \text{EnumSize}(E)) = bits$$
$$\text{ValueBits}(\text{TypePath}(p), v) = bits \iff \Sigma.\text{Types}[p] = \texttt{modal } M \land v=\langle S, v_s \rangle \land \text{ModalBits}(M, S, v_s) = bits$$

$$\text{ValueBits}(\text{TypeUnion}(U), v) = bits \iff \exists T.\ \text{Member}(T, \text{TypeUnion}(U)) \land \text{UnionBits}(U, T, v) = bits$$

$$\text{ValueBits}(\text{TypeDynamic}(Cl), v) = bits \iff v=\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T) \land sym=\text{ScopedSym}(\text{VTableDecl}(T, Cl)) \land addr_{vt}=\text{AddrOfSym}(sym) \land \text{RecordLayout}(\text{DynFields}(Cl)) \Downarrow \langle size, \_, offsets \rangle \land \text{StructBits}([\text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})), \text{TypeRawPtr}(\texttt{imm}, \text{TypePath}([\texttt{"VTable"}]))], [\text{RawPtr}(\texttt{imm}, addr), \text{RawPtr}(\texttt{imm}, addr_{vt})], offsets, size) = bits$$
$$\text{ValueBits}(\text{TypeString}(st), v) = bits \iff \text{ValueType}(v) = \text{TypeString}(st) \land |bits| = \text{sizeof}(\text{TypeString}(st))$$
$$\text{ValueBits}(\text{TypeBytes}(st), v) = bits \iff \text{ValueType}(v) = \text{TypeBytes}(st) \land |bits| = \text{sizeof}(\text{TypeBytes}(st))$$

$$\text{ValueBits}(T, v) = bits \Rightarrow \text{ValidValue}(T, bits)$$
$$\text{UnionNicheBits}(U, T, v) = bits \iff \text{NicheApplies}(U) \land \text{PayloadMember}(U) = T_p \land ((T \equiv T_p \land \text{ValueBits}(T_p, v) = bits \land bits \notin \text{NicheSet}(T_p)) \lor (\exists i.\ \text{EmptyList}(U)[i] \equiv T \land v = () \land \text{NicheOrder}(T_p)[i] = bits))$$

**Union Layout.**

$$k = |\text{MemberList}(U)| - 1$$
$$\text{UnionDiscType}(U) = \text{DiscType}(k)$$
$$\text{PayloadSize}(U) = \max_{T \in \text{MemberList}(U)}(\text{sizeof}(T))$$
$$\text{PayloadAlign}(U) = \max_{T \in \text{MemberList}(U)}(\text{alignof}(T))$$
$$\text{UnionAlign}(U) = \max(\text{alignof}(\text{UnionDiscType}(U)), \text{PayloadAlign}(U))$$
$$\text{UnionSize}(U) = \text{AlignUp}(\text{sizeof}(\text{UnionDiscType}(U)) + \text{PayloadSize}(U), \text{UnionAlign}(U))$$
$$\text{UnionLayoutJudg} = \{\text{UnionLayout}\}$$

**(Layout-Union-Niche)**
$$\frac{\text{NicheApplies}(U) \quad \text{PayloadMember}(U) = T_p \quad \Gamma \vdash \text{layout}(T_p) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{UnionLayout}(U) \Downarrow \langle size, align, \bot, \text{layout}(T_p) \rangle}$$

**(Layout-Union-Tagged)**
$$\frac{\neg \text{NicheApplies}(U) \quad size = \text{UnionSize}(U) \quad align = \text{UnionAlign}(U)}{\Gamma \vdash \text{UnionLayout}(U) \Downarrow \langle size, align, \text{UnionDiscType}(U), \text{PayloadSize}(U) \rangle}$$

**(Size-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

$$\text{PayloadBits}(U, T, v) = bits \iff \text{ValueBits}(T, v) = b \land |bits| = \text{PayloadSize}(U) \land bits[0..|b|) = b$$
$$\text{TaggedBits}(disc\_bits, payload\_bits, disc\_size, payload\_size, payload\_align, size) = bits \iff |bits| = size \land payload\_off = \text{AlignUp}(disc\_size, payload\_align) \land bits[0..disc\_size) = disc\_bits \land bits[payload\_off..payload\_off + payload\_size) = payload\_bits$$

**Informative.** TaggedBits constrains only the discriminant and payload ranges; bytes outside those ranges are unconstrained.

$$\text{UnionTaggedBits}(U, T, v) = bits \iff \neg \text{NicheApplies}(U) \land \text{UnionDiscType}(U) = D \land \text{UnionDiscValue}(U, T) = d \land \text{ValueBits}(D, d) = disc\_bits \land \text{PayloadBits}(U, T, v) = payload\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{PayloadSize}(U), \text{PayloadAlign}(U), \text{UnionSize}(U)) = bits$$
$$\text{UnionBits}(U, T, v) = bits \iff \text{UnionNicheBits}(U, T, v) = bits \lor \text{UnionTaggedBits}(U, T, v) = bits$$

**Modal Niche Encoding.**

$$\text{SingleFieldPayload}(M, S) = T \iff \text{Payload}(M, S) = [\langle f, T \rangle]$$
$$\text{EmptyState}(M, S) \iff \text{Payload}(M, S) = []$$
$$\text{PayloadState}(M) = S_p \iff S_p \in \text{States}(M) \land \text{SingleFieldPayload}(M, S_p) = T_p \land \text{NicheCount}(T_p) > 0 \land (\forall S \in \text{States}(M).\ S \ne S_p \Rightarrow \text{EmptyState}(M, S)) \land \text{NicheCount}(T_p) \ge |\text{States}(M)| - 1$$
$$\text{NicheApplies}(M) \iff \exists S_p.\ \text{PayloadState}(M) = S_p$$
$$\text{EmptyStates}(M) = [ S \in \text{States}(M) \mid \text{EmptyState}(M, S) ]$$
$$\text{EmptyRecordVal}(v) \iff \exists tr.\ v = \text{RecordValue}(tr, [])$$
$$\text{ModalNicheBits}(M, S, v) = bits \iff \text{NicheApplies}(M) \land \text{PayloadState}(M) = S_p \land \text{SingleFieldPayload}(M, S_p) = T_p \land ((S = S_p \land \text{ValueBits}(T_p, v) = bits \land bits \notin \text{NicheSet}(T_p)) \lor (\exists i.\ \text{EmptyStates}(M)[i] = S \land (v = () \lor \text{EmptyRecordVal}(v)) \land \text{NicheOrder}(T_p)[i] = bits))$$
$$\text{ModalBits}(M, S, v) = bits \iff \text{ModalNicheBits}(M, S, v) = bits \lor \text{ModalTaggedBits}(M, S, v) = bits$$

$$\text{ModalPayloadSize}(M) = \max_{S \in \text{States}(M)}(\text{StateSize}(M, S))$$
$$\text{ModalPayloadAlign}(M) = \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S))$$
$$\text{StateRecordBits}(M, S, v) = b \iff \text{Payload}(M, S) = fields \land \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \land fields = [\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle] \land ((n = 0 \land (v = () \lor \text{EmptyRecordVal}(v)) \land b = []) \lor (n > 0 \land v = \text{RecordValue}(tr, fs) \land (\forall i.\ \text{FieldValue}(\text{RecordValue}(tr, fs), f_i) = v_i) \land \text{StructBits}([T_1,\ldots,T_n], [v_1,\ldots,v_n], offsets, size) = b))$$
$$\text{ModalPayloadBits}(M, S, v) = bits \iff \text{StateRecordBits}(M, S, v) = b \land \text{PadBytes}(b, \text{ModalPayloadSize}(M)) = bits$$

Modal tagged layout is fully defined; all bytes outside the discriminant and payload ranges MUST be zero.
$$\text{ModalTaggedBits}(M, S, v) = bits \iff \neg \text{NicheApplies}(M) \land \text{ModalDiscType}(M) = D \land \text{StateIndex}(M, S) = i \land \text{ValueBits}(D, i) = disc\_bits \land \text{ModalPayloadBits}(M, S, v) = payload\_bits \land \text{TaggedBits}(disc\_bits, payload\_bits, \text{sizeof}(D), \text{ModalPayloadSize}(M), \text{ModalPayloadAlign}(M), \text{ModalSize}(M)) = bits \land payload\_off = \text{AlignUp}(\text{sizeof}(D), \text{ModalPayloadAlign}(M)) \land \forall j.\ 0 \le j < |bits| \land j \notin [0,\text{sizeof}(D)) \land j \notin [payload\_off,\ payload\_off + \text{ModalPayloadSize}(M)) \Rightarrow bits[j]=\texttt{0x00}$$



#### 6.1.5. String and Bytes Layout

**`string@Managed` Representation**

$$\text{StringManagedFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{capacity}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{StringManagedOffsets} = [0,\ \text{PtrSize},\ 2 \times \text{PtrSize}]$$
$$\text{RecordLayout}(\text{StringManagedFields}) = \langle 3 \times \text{PtrSize},\ \text{PtrAlign},\ \text{StringManagedOffsets} \rangle$$
$$\text{sizeof}(\texttt{string@Managed}) = 3 \times \text{PtrSize}$$

**`string@View` Representation**

$$\text{StringViewFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{StringViewOffsets} = [0,\ \text{PtrSize}]$$
$$\text{RecordLayout}(\text{StringViewFields}) = \langle 2 \times \text{PtrSize},\ \text{PtrAlign},\ \text{StringViewOffsets} \rangle$$
$$\text{sizeof}(\texttt{string@View}) = 2 \times \text{PtrSize}$$

**String Layout Rules.**

**(Size-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{sizeof}(T) = 3 \times \text{PtrSize}}$$

**(Align-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-String-Managed)**
$$\frac{T = \text{TypeString}(\texttt{@Managed})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 3 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-String-View)**
$$\frac{T = \text{TypeString}(\texttt{@View})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**`bytes@Managed` Representation**

$$\text{BytesManagedFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{capacity}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{BytesManagedOffsets} = [0,\ \text{PtrSize},\ 2 \times \text{PtrSize}]$$
$$\text{RecordLayout}(\text{BytesManagedFields}) = \langle 3 \times \text{PtrSize},\ \text{PtrAlign},\ \text{BytesManagedOffsets} \rangle$$
$$\text{sizeof}(\texttt{bytes@Managed}) = 3 \times \text{PtrSize}$$

**`bytes@View` Representation**

$$\text{BytesViewFields} = [\langle \texttt{pointer}, \text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid}) \rangle,\ \langle \texttt{length}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{BytesViewOffsets} = [0,\ \text{PtrSize}]$$
$$\text{RecordLayout}(\text{BytesViewFields}) = \langle 2 \times \text{PtrSize},\ \text{PtrAlign},\ \text{BytesViewOffsets} \rangle$$
$$\text{sizeof}(\texttt{bytes@View}) = 2 \times \text{PtrSize}$$

**Bytes Layout Rules.**

**(Size-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{sizeof}(T) = 3 \times \text{PtrSize}}$$

**(Align-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Bytes-Managed)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 3 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Bytes-View)**
$$\frac{T = \text{TypeBytes}(\texttt{@View})}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(Size-String-Modal)**
$$\frac{T = \text{TypeString}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{string}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-String-Modal)**
$$\frac{T = \text{TypeString}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{string}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Size-Bytes-Modal)**
$$\frac{T = \text{TypeBytes}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{bytes}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Bytes-Modal)**
$$\frac{T = \text{TypeBytes}(\bot) \quad \Gamma \vdash \text{ModalLayout}(\texttt{bytes}) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$


#### 6.1.6. Aggregate Layouts (Tuples, Arrays, Slices, Ranges, Enums)

**Tuples.**

$$\text{TupleFields}([T_1,\ldots,T_n]) = [\langle 0, T_1 \rangle,\ldots,\langle n-1, T_n \rangle]$$
$$\text{TupleLayoutJudg} = \{\text{TupleLayout}\}$$

**(Layout-Tuple-Empty)**
$$\frac{}{\Gamma \vdash \text{TupleLayout}([]) \Downarrow \langle 0, 1, [] \rangle}$$

**(Layout-Tuple-Cons)**
$$\frac{n \ge 1 \quad \text{TupleFields}([T_1,\ldots,T_n]) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, offsets \rangle}{\Gamma \vdash \text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(\text{TypeTuple}([T_1,\ldots,T_n])) = size}$$

**(Align-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(\text{TypeTuple}([T_1,\ldots,T_n])) = align}$$

**(Layout-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \langle size, align \rangle}$$

**Arrays.**

**(Size-Array)**
$$\frac{\Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash \text{sizeof}(T_0) = s}{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T_0, e)) = n \times s}$$

**(Align-Array)**
$$\frac{\Gamma \vdash \text{alignof}(T_0) = a}{\Gamma \vdash \text{alignof}(\text{TypeArray}(T_0, e)) = a}$$

**(Layout-Array)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T_0, e)) = size \quad \Gamma \vdash \text{alignof}(\text{TypeArray}(T_0, e)) = align}{\Gamma \vdash \text{layout}(\text{TypeArray}(T_0, e)) \Downarrow \langle size, align \rangle}$$

**Slices.**

**(Size-Slice)**
$$\frac{}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-Slice)**
$$\frac{}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

**(Layout-Slice)**
$$\frac{}{\Gamma \vdash \text{layout}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**Ranges.**

$$\text{RangeTag}(\texttt{To}) = 0$$
$$\text{RangeTag}(\texttt{ToInclusive}) = 1$$
$$\text{RangeTag}(\texttt{Full}) = 2$$
$$\text{RangeTag}(\texttt{From}) = 3$$
$$\text{RangeTag}(\texttt{Exclusive}) = 4$$
$$\text{RangeTag}(\texttt{Inclusive}) = 5$$
$$\text{RangeFields} = [\langle \texttt{kind}, \text{TypePrim}(\texttt{"u8"}) \rangle,\ \langle \texttt{lo}, \text{TypePrim}(\texttt{"usize"}) \rangle,\ \langle \texttt{hi}, \text{TypePrim}(\texttt{"usize"}) \rangle]$$
$$\text{OptVal}(v_\text{opt}) = \begin{cases}\text{IntVal}(\texttt{"usize"}, 0) & v_\text{opt} = \bot \\ v_\text{opt} & \text{otherwise}\end{cases}$$
$$\text{RangeValFields}(\text{RangeVal}(kind, lo\_opt, hi\_opt)) = [\langle \texttt{kind}, \text{IntVal}(\texttt{"u8"}, \text{RangeTag}(kind)) \rangle,\ \langle \texttt{lo}, \text{OptVal}(lo\_opt) \rangle,\ \langle \texttt{hi}, \text{OptVal}(hi\_opt) \rangle]$$
$$\text{RangeLayoutJudg} = \{\text{RangeLayout}\}$$

**(Layout-Range)**
$$\frac{\text{RecordLayout}(\text{RangeFields}) \Downarrow \langle size, align, offsets \rangle}{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, align, offsets \rangle}$$

**(Size-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(\text{TypeRange}) = size}$$

**(Align-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle \_, align, \_ \rangle}{\Gamma \vdash \text{alignof}(\text{TypeRange}) = align}$$

**(Layout-Range-SizeAlign)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{layout}(\text{TypeRange}) \Downarrow \langle size, align \rangle}$$

**Enums.**

$$\text{EnumDiscType}(E) = \text{DiscType}(E)$$
$$\text{VariantPayloadOpt}(v) = payload\_opt \iff v = \langle \text{name},\ payload\_opt,\ \text{disc}\_opt,\ \text{span},\ \text{doc}\_opt \rangle$$
$$\text{VariantSize}(v) = 0 \iff \text{VariantPayloadOpt}(v) = \bot$$
$$\text{VariantAlign}(v) = 1 \iff \text{VariantPayloadOpt}(v) = \bot$$
$$\text{VariantSize}(v) = s \iff \text{VariantPayloadOpt}(v) = \text{TuplePayload}([T_1,\ldots,T_k]) \land \text{TupleLayout}([T_1,\ldots,T_k]) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantAlign}(v) = a \iff \text{VariantPayloadOpt}(v) = \text{TuplePayload}([T_1,\ldots,T_k]) \land \text{TupleLayout}([T_1,\ldots,T_k]) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantSize}(v) = s \iff \text{VariantPayloadOpt}(v) = \text{RecordPayload}(fields) \land \text{RecordLayout}(fields) \Downarrow \langle s, a, \_ \rangle$$
$$\text{VariantAlign}(v) = a \iff \text{VariantPayloadOpt}(v) = \text{RecordPayload}(fields) \land \text{RecordLayout}(fields) \Downarrow \langle s, a, \_ \rangle$$
$$\text{PayloadSize}(E) = \max_{v \in \text{Variants}(E)}(\text{VariantSize}(v))$$
$$\text{PayloadAlign}(E) = \max_{v \in \text{Variants}(E)}(\text{VariantAlign}(v))$$
$$\text{EnumAlign}(E) = \max(\text{alignof}(\text{EnumDiscType}(E)), \text{PayloadAlign}(E))$$
$$\text{EnumSize}(E) = \text{AlignUp}(\text{sizeof}(\text{EnumDiscType}(E)) + \text{PayloadSize}(E), \text{EnumAlign}(E))$$
$$\text{EnumLayoutJudg} = \{\text{EnumLayout}\}$$

**(Layout-Enum-Tagged)**
$$\frac{size = \text{EnumSize}(E) \quad align = \text{EnumAlign}(E)}{\Gamma \vdash \text{EnumLayout}(E) \Downarrow \langle size, align, \text{EnumDiscType}(E), \text{PayloadSize}(E) \rangle}$$

**(Size-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.7. Modal Layout (Codegen)

$$\text{ModalDiscType}(M) = \text{DiscType}(|\text{States}(M)| - 1)$$
$$\text{StateSize}(M, S) = s \iff \text{RecordLayout}(\text{Payload}(M, S)) \Downarrow \langle s, a, \_ \rangle$$
$$\text{StateAlign}(M, S) = a \iff \text{RecordLayout}(\text{Payload}(M, S)) \Downarrow \langle s, a, \_ \rangle$$
$$\text{ModalAlign}(M) = \max(\text{alignof}(\text{ModalDiscType}(M)), \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S)))$$
$$\text{ModalSize}(M) = \text{AlignUp}(\text{sizeof}(\text{ModalDiscType}(M)) + \max_{S \in \text{States}(M)}(\text{StateSize}(M, S)), \text{ModalAlign}(M))$$
$$\text{ModalLayoutJudg} = \{\text{ModalLayout}\}$$

**(Layout-Modal-Niche)**
$$\frac{\text{NicheApplies}(M) \quad \text{PayloadState}(M) = S_p \quad \text{SingleFieldPayload}(M, S_p) = T_p \quad \Gamma \vdash \text{layout}(T_p) \Downarrow \langle size, align \rangle}{\Gamma \vdash \text{ModalLayout}(M) \Downarrow \langle size, align, \bot, \text{layout}(T_p) \rangle}$$

**(Layout-Modal-Tagged)**
$$\frac{\neg \text{NicheApplies}(M) \quad size = \text{ModalSize}(M) \quad align = \text{ModalAlign}(M)}{\Gamma \vdash \text{ModalLayout}(M) \Downarrow \langle size, align, \text{ModalDiscType}(M), \max_{S \in States(M)}(\text{StateSize}(M, S)) \rangle}$$

**(Size-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, \_, \_, \_ \rangle}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle \_, align, \_, \_ \rangle}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

**(Size-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateSize}(M, S) = size}{\Gamma \vdash \text{sizeof}(T) = size}$$

**(Align-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateAlign}(M, S) = align}{\Gamma \vdash \text{alignof}(T) = align}$$

**(Layout-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{StateSize}(M, S) = size \quad \text{StateAlign}(M, S) = align}{\Gamma \vdash \text{layout}(T) \Downarrow \langle size, align \rangle}$$

#### 6.1.8. Dynamic Class Object Layout

$$\text{DynFields}(Cl) = [\langle \texttt{data}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})) \rangle,\ \langle \texttt{vtable}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePath}([\texttt{"VTable"}])) \rangle]$$
$$\text{DynLayoutJudg} = \{\text{DynLayout}\}$$

**(Layout-DynamicClass)**
$$\frac{}{\Gamma \vdash \text{DynLayout}(Cl) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign}, \text{DynFields}(Cl) \rangle}$$

**(Size-DynamicClass)**
$$\frac{T = \text{TypeDynamic}(Cl)}{\Gamma \vdash \text{sizeof}(T) = 2 \times \text{PtrSize}}$$

**(Align-DynamicClass)**
$$\frac{T = \text{TypeDynamic}(Cl)}{\Gamma \vdash \text{alignof}(T) = \text{PtrAlign}}$$

### 6.2. ABI Lowering (Cursive0)

#### 6.2.1. Default Calling Convention

**DefaultCallingConvention.**
$$\text{CallConvDefault} = \text{Cursive0ABI}$$


#### 6.2.2. ABI Type Lowering

$$\text{ABIType} = \{ \langle size, align \rangle \mid size \in \mathbb{N} \land align \in \mathbb{N} \}$$
$$\text{ABITyJudg} = \{\text{ABITy}\}$$

**(ABI-Prim)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypePrim}(name)) = s \quad \Gamma \vdash \text{alignof}(\text{TypePrim}(name)) = a}{\Gamma \vdash \text{ABITy}(\text{TypePrim}(name)) \Downarrow \langle s, a \rangle}$$

**(ABI-Perm)**
$$\frac{\Gamma \vdash \text{ABITy}(T) \Downarrow \tau}{\Gamma \vdash \text{ABITy}(\text{TypePerm}(p, T)) \Downarrow \tau}$$

**(ABI-Ptr)**
$$\frac{T = \text{TypePtr}(U, s)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Func)**
$$\frac{T = \text{TypeFunc}(params, R)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{ABITy}(ty) \Downarrow \tau}{\Gamma \vdash \text{ABITy}(T) \Downarrow \tau}$$

**(ABI-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \langle size, align \rangle}$$

**(ABI-Array)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeArray}(T, e)) = size \quad \Gamma \vdash \text{alignof}(\text{TypeArray}(T, e)) = align}{\Gamma \vdash \text{ABITy}(\text{TypeArray}(T, e)) \Downarrow \langle size, align \rangle}$$

**(ABI-Slice)**
$$\frac{T = \text{TypeSlice}(U)}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle 2 \times \text{PtrSize}, \text{PtrAlign} \rangle}$$

**(ABI-Range)**
$$\frac{\Gamma \vdash \text{sizeof}(\text{TypeRange}) = size \quad \Gamma \vdash \text{alignof}(\text{TypeRange}) = align}{\Gamma \vdash \text{ABITy}(\text{TypeRange}) \Downarrow \langle size, align \rangle}$$

**(ABI-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Union)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Modal)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, align, \_, \_ \rangle}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

**(ABI-Dynamic)**
$$\frac{\Gamma \vdash \text{DynLayout}(Cl) \Downarrow \langle size, align, \_ \rangle}{\Gamma \vdash \text{ABITy}(\text{TypeDynamic}(Cl)) \Downarrow \langle size, align \rangle}$$

**(ABI-StringBytes)**
$$\frac{T \in \{\text{TypeString}(\texttt{@View}), \text{TypeString}(\texttt{@Managed}), \text{TypeBytes}(\texttt{@View}), \text{TypeBytes}(\texttt{@Managed})\} \quad \Gamma \vdash \text{sizeof}(T) = size \quad \Gamma \vdash \text{alignof}(T) = align}{\Gamma \vdash \text{ABITy}(T) \Downarrow \langle size, align \rangle}$$

#### 6.2.3. ABI Parameter and Return Passing

$$\text{PassKind} = \{\texttt{ByValue},\ \texttt{ByRef},\ \texttt{SRet}\}$$
$$\text{ByValMax} = 2 \times \text{PtrSize}$$
$$\text{ByValAlign} = \text{PtrAlign}$$
$$\text{ByValOk}(T) \iff \Gamma \vdash \text{sizeof}(T) = n \land \Gamma \vdash \text{alignof}(T) = a \land n \le \text{ByValMax} \land a \le \text{ByValAlign}$$
$$\text{ABIParamJudg} = \{\text{ABIParam}\}$$
$$\text{ABIRetJudg} = \{\text{ABIRet}\}$$
$$\text{ABICallJudg} = \{\text{ABICall}\}$$

**(ABI-Param-ByRef-Alias)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{sizeof}(T) = n}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef}}$$

**(ABI-Param-ByValue-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{sizeof}(T) = 0 \ \lor\ \text{ByValOk}(T)}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByValue}}$$

**(ABI-Param-ByRef-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{sizeof}(T) = n \quad n > 0 \quad \neg \text{ByValOk}(T)}{\Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef}}$$

**(ABI-Ret-ByValue)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = 0 \ \lor\ \text{ByValOk}(T)}{\Gamma \vdash \text{ABIRet}(T) \Downarrow \texttt{ByValue}}$$

**(ABI-Ret-ByRef)**
$$\frac{\Gamma \vdash \text{sizeof}(T) = n \quad n > 0 \quad \neg \text{ByValOk}(T)}{\Gamma \vdash \text{ABIRet}(T) \Downarrow \texttt{SRet}}$$

**(ABI-Call)**
$$\frac{\forall i,\ \Gamma \vdash \text{ABIParam}(m_i, T_i) \Downarrow k_i \quad \Gamma \vdash \text{ABIRet}(R) \Downarrow k_r}{\Gamma \vdash \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \Downarrow \langle [k_1,\ldots,k_n], k_r, (k_r = \texttt{SRet}) \rangle}$$

**Panic Out-Parameter (Cursive0).**

$$\text{PanicRecordFields} = [\langle \texttt{panic}, \text{TypePrim}(\texttt{"bool"}) \rangle,\ \langle \texttt{code}, \text{TypePrim}(\texttt{"u32"}) \rangle]$$
$$\text{PanicRecordLayout} = \text{RecordLayout}(\text{PanicRecordFields})$$
$$\text{PanicRecordFieldsOf}(\text{PanicRecord}) = \text{PanicRecordFields}$$
$$\text{PanicRecordLayoutOf}(\text{PanicRecord}) = \text{PanicRecordLayout}$$

$$\text{PanicOutType} = \text{TypeRawPtr}(\texttt{mut}, \text{PanicRecord})$$
$$\text{PanicOutName} = \texttt{"__panic"}$$

$$\text{NeedsPanicOut}(callee) \iff callee \ne \text{RecordCtor}(\_) \land callee \ne \text{EntrySym} \land \text{RuntimeSig}(callee)\ \text{undefined}.$$

$$\text{PanicOutParams}(params, callee) =
\begin{cases}
params \mathbin{+\!\!+} [\langle \texttt{move},\ \text{PanicOutName},\ \text{PanicOutType} \rangle] & \text{if } \text{NeedsPanicOut}(callee)\\
params & \text{otherwise}
\end{cases}$$

#### 6.2.4. Call Lowering for Procedures and Methods

$$\text{LowerCallJudg} = \{\text{MethodSymbol},\ \text{BuiltinMethodSym},\ \text{LowerMethodCall},\ \text{LowerArgs},\ \text{LowerRecvArg}\}$$
$$\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \iff \text{StripPerm}(T) = \text{TypeModalState}(p, S)$$
$$\text{BuiltinCapClass} = \{\texttt{FileSystem},\ \texttt{HeapAllocator}\}$$

**(MethodSymbol-Record)**
$$\frac{\text{LookupMethod}(T, name) = m \quad m = \text{MethodDecl}(\_) \quad \Gamma \vdash \text{Mangle}(m) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-Default)**
$$\frac{\text{LookupMethod}(T, name) = m \quad m = \text{ClassMethodDecl}(\_) \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-ModalState-Method)**
$$\frac{\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \quad \text{LookupStateMethod}(S, name) = md \quad \Gamma \vdash \text{Mangle}(md) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(MethodSymbol-ModalState-Transition)**
$$\frac{\text{ModalStateOf}(T) = \text{TypeModalState}(p, S) \quad \text{LookupTransition}(S, name) = tr \quad \Gamma \vdash \text{Mangle}(tr) \Downarrow sym}{\Gamma \vdash \text{MethodSymbol}(T, name) \Downarrow sym}$$

**(BuiltinMethodSym-FileSystem)**
$$\frac{\text{BuiltinSym}(\texttt{FileSystem}::name) \Downarrow sym}{\Gamma \vdash \text{BuiltinMethodSym}(\texttt{FileSystem}, name) \Downarrow sym}$$

**(BuiltinMethodSym-HeapAllocator)**
$$\frac{\text{BuiltinSym}(\texttt{HeapAllocator}::name) \Downarrow sym}{\Gamma \vdash \text{BuiltinMethodSym}(\texttt{HeapAllocator}, name) \Downarrow sym}$$

**(Lower-Args-Empty)**
$$\frac{}{\Gamma \vdash \text{LowerArgs}([], []) \Downarrow \langle \epsilon, [] \rangle}$$

**(Lower-Args-Cons-Move)**
$$\frac{\Gamma \vdash \text{LowerExpr}(\text{MovedArg}(moved, e)) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerArgs}(ps, as) \Downarrow \langle IR_a, \vec{v} \rangle}{\Gamma \vdash \text{LowerArgs}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as) \Downarrow \langle \text{SeqIR}(IR_e, IR_a), [v] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(Lower-Args-Cons-Ref)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(e) \Downarrow \langle IR_e, addr \rangle \quad \Gamma \vdash \text{LowerArgs}(ps, as) \Downarrow \langle IR_a, \vec{v} \rangle}{\Gamma \vdash \text{LowerArgs}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as) \Downarrow \langle \text{SeqIR}(IR_e, IR_a), [\text{Ptr@Valid}(addr)] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(Lower-RecvArg-Move)**
$$\frac{base = \text{MoveExpr}(p) \quad \Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle}{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle}$$

**(Lower-RecvArg-Ref)**
$$\frac{base \ne \text{MoveExpr}(\_) \quad \Gamma \vdash \text{LowerAddrOf}(base) \Downarrow \langle IR_b, addr \rangle}{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, \text{Ptr@Valid}(addr) \rangle}$$

**(Lower-MethodCall-Static-PanicOut)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad T = \text{ExprType}(base) \quad T \ne \text{TypeDynamic}(\_) \quad \text{LookupMethod}(T, name) = m \quad \text{MethodSymbol}(T, name) \Downarrow sym \quad \text{NeedsPanicOut}(sym)}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]), \text{PanicCheck}), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Static-NoPanicOut)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad T = \text{ExprType}(base) \quad T \ne \text{TypeDynamic}(\_) \quad \text{LookupMethod}(T, name) = m \quad \text{MethodSymbol}(T, name) \Downarrow sym \quad \neg \text{NeedsPanicOut}(sym)}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Capability)**
$$\frac{\Gamma \vdash \text{LowerRecvArg}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{ExprType}(base) = \text{TypeDynamic}(Cl) \quad Cl \in \text{BuiltinCapClass} \quad \text{LookupClassMethod}(Cl, name) = m \quad \Gamma \vdash \text{BuiltinMethodSym}(Cl, name) \Downarrow sym}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, \text{CallIR}(sym, [v_{\text{self}}] \mathbin{+\!\!+} \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-MethodCall-Dynamic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_{\text{self}} \rangle \quad \Gamma \vdash \text{LowerArgs}(m.\text{params}, args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{ExprType}(base) = \text{TypeDynamic}(Cl) \quad Cl \notin \text{BuiltinCapClass} \quad \text{LookupClassMethod}(Cl, name) = m \quad \Gamma \vdash \text{LowerDynCall}(v_{\text{self}}, name, \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]) \Downarrow IR_d}{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle \text{SeqIR}(IR_b, IR_a, IR_d), v_{\text{call}} \rangle}$$

$$\text{SeqIR}() = \epsilon$$
$$\text{SeqIR}(IR) = IR$$
$$\text{SeqIR}(IR_1,\ldots,IR_n) = \text{SeqIR}(IR_1,\ \text{SeqIR}(IR_2,\ldots,IR_n))\quad(n \ge 2)$$

### 6.3. Symbols, Mangling, and Linkage

#### 6.3.1. Symbol Names and Mangling

$$\text{MangleJudg} = \{\text{Mangle}\}$$
$$\text{VTableDecl}(T, Cl)\ \text{constructor}$$
$$\text{LiteralData}(kind, contents)\ \text{constructor}$$
$$\text{DefaultImpl}(T, m)\ \text{constructor}$$

$$\text{Join}(sep, []) = \texttt{"\""}$$
$$\text{Join}(sep, [s]) = s$$
$$\text{Join}(sep, [s_1,\ldots,s_n]) = s_1 \mathbin{+\!\!+} sep \mathbin{+\!\!+} \text{Join}(sep, [s_2,\ldots,s_n])\quad(n \ge 2)$$
$$\text{PathSig}(p) = \text{mangle}(\text{PathString}(p))$$

$$\text{ItemPath}(it) = \text{PathOfModule}(\text{ModuleOf}(it)) \mathbin{+\!\!+} [name] \iff it = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc)$$
$$\text{ItemPath}(m) = \text{RecordPath}(R) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{Methods}(R)$$
$$\text{ItemPath}(m) = \text{ClassPath}(Cl) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{ClassMethods}(Cl)$$
$$\text{ItemPath}(m) = \text{ModalPath}(M) \mathbin{+\!\!+} [S] \mathbin{+\!\!+} [m.\text{name}] \iff S \in \text{States}(M) \land m \in \text{Methods}(S)$$
$$\text{ItemPath}(tr) = \text{ModalPath}(M) \mathbin{+\!\!+} [S] \mathbin{+\!\!+} [tr.\text{name}] \iff S \in \text{States}(M) \land tr \in \text{Transitions}(S)$$
$$\text{ItemPath}(it) = \text{PathOfModule}(\text{ModuleOf}(it)) \mathbin{+\!\!+} [\text{StaticName}(binding)] \iff it = \text{StaticDecl}(vis, mut, binding, span, doc) \land \text{StaticName}(binding) \ne \bot$$
$$\text{ItemPath}(\text{StaticBinding}(\text{StaticDecl}(vis, mut, binding, span, doc), x)) = \text{PathOfModule}(\text{ModuleOf}(\text{StaticDecl}(vis, mut, binding, span, doc))) \mathbin{+\!\!+} [x]$$
$$\text{ItemPath}(\text{VTableDecl}(T, Cl)) = [\texttt{"vtable"}] \mathbin{+\!\!+} \text{PathOfType}(T) \mathbin{+\!\!+} [\texttt{"cl"}] \mathbin{+\!\!+} \text{ClassPath}(Cl)$$
$$\text{ItemPath}(\text{DefaultImpl}(T, m)) = [\texttt{"default"}] \mathbin{+\!\!+} \text{PathOfType}(T) \mathbin{+\!\!+} [\texttt{"cl"}] \mathbin{+\!\!+} \text{ClassPath}(Cl) \mathbin{+\!\!+} [m.\text{name}] \iff m \in \text{ClassMethods}(Cl)$$

$$\text{TypeStateName}(\texttt{View}) = \texttt{"view"}$$
$$\text{TypeStateName}(\texttt{Managed}) = \texttt{"managed"}$$
$$\text{PathOfType}(\text{TypePrim}(name)) = [\texttt{"prim"}, name]$$
$$\text{PathOfType}(\text{TypeString}(st)) = [\texttt{"string"}, \text{TypeStateName}(st)]$$
$$\text{PathOfType}(\text{TypeBytes}(st)) = [\texttt{"bytes"}, \text{TypeStateName}(st)]$$
$$\text{PathOfType}(\text{TypePath}(p)) = p$$
$$\text{PathOfType}(\text{TypeModalState}(p, S)) = p \mathbin{+\!\!+} [S]$$
$$\text{PathOfType}(T) = \bot \iff T \notin \{\text{TypePrim}(\_),\ \text{TypeString}(\_),\ \text{TypeBytes}(\_),\ \text{TypePath}(\_),\ \text{TypeModalState}(\_,\_)\}$$
$$\text{ClassPath}(Cl) = p \iff \Sigma.\text{Classes}[p] = Cl$$

**Literal Identity.**

$$\text{FNVOffset64} = 14695981039346656037$$
$$\text{FNVPrime64} = 1099511628211$$
$$\text{FNV1a64}([]) = \text{FNVOffset64}$$
$$\text{FNV1a64}([b_1,\ldots,b_n]) = h_n \iff h_0 = \text{FNVOffset64} \land \forall i \in 0..n{-}1.\ h_{i+1} = ((h_i \oplus b_{i+1}) \times \text{FNVPrime64}) \bmod 2^{64}$$
$$\text{Hex64}(h) = \text{Join}(\texttt{"\""}, [\text{Hex2}(b_1),\ldots,\text{Hex2}(b_8)]) \iff \text{rev}(\text{LEBytes}(h, 8)) = [b_1,\ldots,b_8]$$
$$\text{LiteralID}(kind, contents) = \text{mangle}(kind) \mathbin{+\!\!+} \texttt{"_"} \mathbin{+\!\!+} \text{Hex64}(\text{FNV1a64}(contents))$$

**Mangle Rules.**

$$\text{ScopedSym}(item) = \text{PathSig}(\text{ItemPath}(item))$$

**(Mangle-Proc)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, name, params, ret\_opt, body, span, doc) \quad name \ne \texttt{"main"}}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Main)**
$$\frac{\text{item} = \text{ProcedureDecl}(vis, \texttt{"main"}, params, ret\_opt, body, span, doc) \quad \text{MainSigOk}(\text{item})}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Record-Method)**
$$\frac{\text{item} = \text{MethodDecl}(vis, override, name, receiver, params, ret\_opt, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Class-Method)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-State-Method)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Transition)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Static)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) \ne \bot}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-StaticBinding)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(_,_, binding,_,_), x)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-VTable)**
$$\frac{\text{item} = \text{VTableDecl}(T, Cl)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

**(Mangle-Literal)**
$$\frac{\text{item} = \text{LiteralData}(kind, contents) \quad \text{LiteralID}(kind, contents) = id}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"literal"}, id])}$$

**(Mangle-DefaultImpl)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m)}{\Gamma \vdash \text{Mangle}(\text{item}) \Downarrow \text{ScopedSym}(\text{item})}$$

#### 6.3.4. Linkage for Generated Symbols

$$\text{LinkageKind} = \{\texttt{internal},\ \texttt{external}\}$$
$$\text{LinkageJudg} = \{\text{Linkage}\}$$

**(Linkage-UserItem)**
$$\frac{\text{item} \in \{\text{ProcedureDecl}, \text{StaticDecl}, \text{MethodDecl}\} \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-UserItem-Internal)**
$$\frac{\text{item} \in \{\text{ProcedureDecl}, \text{StaticDecl}, \text{MethodDecl}\} \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-StaticBinding)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(vis,\_,\_,\_,\_), x) \quad vis \in \{\texttt{public},\texttt{internal}\} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-StaticBinding-Internal)**
$$\frac{\text{item} = \text{StaticBinding}(\text{StaticDecl}(vis,\_,\_,\_,\_), x) \quad vis = \texttt{private} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-ClassMethod)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt) \quad body\_opt \ne \bot \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-ClassMethod-Internal)**
$$\frac{\text{item} = \text{ClassMethodDecl}(vis, name, receiver, params, ret\_opt, body\_opt, span, doc\_opt) \quad body\_opt \ne \bot \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-StateMethod)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt) \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-StateMethod-Internal)**
$$\frac{\text{item} = \text{StateMethodDecl}(vis, name, params, ret\_opt, body, span, doc\_opt) \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-Transition)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt) \quad \text{Vis}(item) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-Transition-Internal)**
$$\frac{\text{item} = \text{TransitionDecl}(vis, name, params, target, body, span, doc\_opt) \quad \text{Vis}(item) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(item) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-InitFn)**
$$\frac{\text{InitFn}(m) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DeinitFn)**
$$\frac{\text{DeinitFn}(m) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-VTable)**
$$\frac{\text{Mangle}(\text{VTableDecl}(T, Cl)) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-LiteralData)**
$$\frac{\text{Mangle}(\text{LiteralData}(kind, contents)) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DropGlue)**
$$\frac{\text{DropGlueSym}(T) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-DefaultImpl)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m) \quad \text{Vis}(m) \in \{\texttt{public},\texttt{internal},\texttt{protected}\} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

**(Linkage-DefaultImpl-Internal)**
$$\frac{\text{item} = \text{DefaultImpl}(T, m) \quad \text{Vis}(m) = \texttt{private} \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-PanicSym)**
$$\frac{\text{PanicSym} \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-RegionSym)**
$$\frac{\text{RegionSym}(proc) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-BuiltinSym)**
$$\frac{\text{BuiltinSym}(method) \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{internal}}$$

**(Linkage-EntrySym)**
$$\frac{\text{EntrySym} \Downarrow sym}{\Gamma \vdash \text{Linkage}(sym) \Downarrow \texttt{external}}$$

### 6.4. Expression Lowering and Evaluation Order

$$\text{EvalOrderJudg} = \{\text{Children\_LTR}\}$$

**(ArgsExprs-Empty)**
$$\text{ArgsExprs}([]) = []$$

**(ArgsExprs-Cons)**
$$\text{ArgsExprs}([\langle moved, e, span \rangle] \mathbin{+\!\!+} rest) = [e] \mathbin{+\!\!+} \text{ArgsExprs}(rest)$$

**(FieldExprs-Empty)**
$$\text{FieldExprs}([]) = []$$

**(FieldExprs-Cons)**
$$\text{FieldExprs}([\langle f, e \rangle] \mathbin{+\!\!+} rest) = [e] \mathbin{+\!\!+} \text{FieldExprs}(rest)$$

**(OptExprs-None)**
$$\text{OptExprs}(\bot, \bot) = []$$

**(OptExprs-Lo)**
$$\text{OptExprs}(e, \bot) = [e]$$

**(OptExprs-Hi)**
$$\text{OptExprs}(\bot, e) = [e]$$

**(OptExprs-Both)**
$$\text{OptExprs}(e_1, e_2) = [e_1, e_2]$$

$$\text{LowerExprJudg} = \{\text{LowerExpr},\ \text{LowerUnOp},\ \text{LowerBinOp},\ \text{LowerCast},\ \text{LowerList},\ \text{LowerFieldInits},\ \text{LowerOpt},\ \text{LowerReadPlace},\ \text{LowerWritePlace},\ \text{LowerMovePlace},\ \text{LowerAddrOf},\ \text{LowerPlace}\}$$

**(EvalOrder-Literal)** `Children_LTR(Literal(â„“)) = []`.

**(EvalOrder-PtrNull)** `Children_LTR(PtrNullExpr) = []`.
  
**(EvalOrder-Ident)** `Children_LTR(Identifier(x)) = []`.
  
**(EvalOrder-Path)** `Children_LTR(Path(path, name)) = []`.
  
**(EvalOrder-Tuple)** `Children_LTR(TupleExpr(es)) = es`.
  
**(EvalOrder-Array)** `Children_LTR(ArrayExpr(es)) = es`.
  
**(EvalOrder-Record)** `Children_LTR(RecordExpr(tr, fields)) = FieldExprs(fields)`.
  
**(EvalOrder-Enum-Unit)** `Children_LTR(EnumLiteral(path, âŠ¥)) = []`.
  
**(EvalOrder-Enum-Tuple)** `Children_LTR(EnumLiteral(path, Paren(es))) = es`.
  
**(EvalOrder-Enum-Record)** `Children_LTR(EnumLiteral(path, Brace(fields))) = FieldExprs(fields)`.
  
**(EvalOrder-FieldAccess)** `Children_LTR(FieldAccess(base, f)) = [base]`.
  
**(EvalOrder-TupleAccess)** `Children_LTR(TupleAccess(base, i)) = [base]`.
  
**(EvalOrder-IndexAccess)** `Children_LTR(IndexAccess(base, idx)) = [base, idx]`.
  
**(EvalOrder-Call)** `Children_LTR(Call(callee, args)) = [callee] \mathbin{+\!\!+} ArgsExprs(args)`.
  
**(EvalOrder-MethodCall)** `Children_LTR(MethodCall(base, name, args)) = [base] \mathbin{+\!\!+} ArgsExprs(args)`.
  
**(EvalOrder-Unary)** `Children_LTR(Unary(op, e)) = [e]`.
  
**(EvalOrder-Binary)** `Children_LTR(Binary(op, e_1, e_2)) = [e_1, e_2]`.
  
**(EvalOrder-Cast)** `Children_LTR(Cast(e, T)) = [e]`.
  
**(EvalOrder-Transmute)** `Children_LTR(TransmuteExpr(T_1, T_2, e)) = [e]`.
  
**(EvalOrder-Propagate)** `Children_LTR(Propagate(e)) = [e]`.
  
**(EvalOrder-Range)** `Children_LTR(Range(kind, lo_opt, hi_opt)) = OptExprs(lo_opt, hi_opt)`.
  
**(EvalOrder-If)** `Children_LTR(IfExpr(cond, b1, b2)) = [cond]`.
  
**(EvalOrder-Match)** `Children_LTR(MatchExpr(scrut, arms)) = [scrut]`.
  
**(EvalOrder-Loop)** `Children_LTR(LoopInfinite(body)) = [body]`, `Children_LTR(LoopConditional(cond, body)) = [cond, body]`, `Children_LTR(LoopIter(pat, ty_opt, iter, body)) = [iter, body]`.
  
**(EvalOrder-Block)** `Children_LTR(BlockExpr(stmts, tail_opt)) = []`.
  
**(EvalOrder-UnsafeBlock)** `Children_LTR(UnsafeBlockExpr(b)) = []`.
  
**(EvalOrder-Move)** `Children_LTR(MoveExpr(p)) = []`.
  
**(EvalOrder-AddressOf)** `Children_LTR(AddressOf(p)) = []`.
  
**(EvalOrder-Deref)** `Children_LTR(Deref(e)) = [e]`.
  
**(EvalOrder-Alloc)** `Children_LTR(AllocExpr(r_opt, e)) = [e]`.

$$\text{RetType}(\Gamma) = R \iff \text{ProcRet}(\Gamma) = R$$

**(Lower-Expr-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle}$$

$$\text{ExprForms0} = \{\text{Literal}(\_),\ \text{PtrNullExpr},\ \text{Identifier}(\_),\ \text{Path}(\_,\_),\ \text{ErrorExpr}(\_),\ \text{TupleExpr}(\_),\ \text{ArrayExpr}(\_),\ \text{RecordExpr}(\_,\_),\ \text{EnumLiteral}(\_,\_),\ \text{FieldAccess}(\_,\_),\ \text{TupleAccess}(\_,\_),\ \text{IndexAccess}(\_,\_),\ \text{Call}(\_,\_),\ \text{MethodCall}(\_,\_,\_),\ \text{Unary}(\_,\_),\ \text{Binary}(\_,\_,\_),\ \text{Cast}(\_,\_),\ \text{TransmuteExpr}(\_,\_,\_),\ \text{Propagate}(\_),\ \text{Range}(\_,\_,\_),\ \text{IfExpr}(\_,\_,\_),\ \text{MatchExpr}(\_,\_),\ \text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_),\ \text{BlockExpr}(\_,\_),\ \text{UnsafeBlockExpr}(\_),\ \text{MoveExpr}(\_),\ \text{AddressOf}(\_),\ \text{Deref}(\_),\ \text{AllocExpr}(\_,\_)\}$$
$$\text{LowerExprTotal}(\Gamma) \iff \forall e.\ e \in \text{ExprForms0} \Rightarrow \exists IR, v.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle$$

$$\text{ExecIRJudg} = \{\text{ExecIRSigma},\ \text{MoveStateSigma}\}$$

**(ExecIR-ReadVar)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\text{ExecIRSigma}(\text{ReadVarIR}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ExecIR-ReadPath)**
$$\frac{\text{LookupValPath}(\sigma, path, name) = v}{\text{ExecIRSigma}(\text{ReadPathIR}(path, name), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ExecIR-StoreVar)**
$$\frac{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{StoreVarIR}(x, v), \sigma) \Downarrow (sout, \sigma')}$$

**(ExecIR-StoreVarNoDrop)**
$$\frac{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{StoreVarNoDropIR}(x, v), \sigma) \Downarrow (sout, \sigma')}$$

**(ExecIR-BindVar)**
$$\frac{\text{BindVal}(\sigma, x, v) \Downarrow (\sigma', b)}{\text{ExecIRSigma}(\text{BindVarIR}(x, v), \sigma) \Downarrow (ok, \sigma')}$$

**(ExecIR-ReadPtr)**
$$\frac{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{ReadPtrIR}(v_{ptr}), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-WritePtr)**
$$\frac{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (sout, \sigma')}{\text{ExecIRSigma}(\text{WritePtrIR}(v_{ptr}, v), \sigma) \Downarrow (sout, \sigma')}$$

$$\text{AllocTarget}(\sigma, \bot) = \text{ActiveTarget}(\sigma)$$
$$\text{AllocTarget}(\sigma, r) = \text{ResolveTarget}(\sigma, r)$$

**(ExecIR-Alloc)**
$$\frac{\text{AllocTarget}(\sigma, r_{opt}) = r \quad \text{RegionAlloc}(\sigma, r, v) \Downarrow (\sigma', v')}{\text{ExecIRSigma}(\text{AllocIR}(r_{opt}, v), \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(MoveState-Root)**
$$\frac{\text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = \bot \quad \text{LookupBind}(\sigma, x) = b \quad \text{SetState}(\sigma, b, \text{Moved}) \Downarrow \sigma'}{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}$$

**(MoveState-Field)**
$$\frac{\text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{LookupBind}(\sigma, x) = b \quad \text{BindState}(\sigma, b) = s \quad \text{PM}(s, f) = s' \quad \text{SetState}(\sigma, b, s') \Downarrow \sigma'}{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}$$

**(ExecIR-MoveState)**
$$\frac{\Gamma \vdash \text{MoveStateSigma}(p, \sigma) \Downarrow \sigma'}{\text{ExecIRSigma}(\text{MoveStateIR}(p), \sigma) \Downarrow (ok, \sigma')}$$

**(ExecIR-Return)**
$$\frac{}{ \text{ExecIRSigma}(\text{ReturnIR}(v), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v)), \sigma)}$$

**(ExecIR-Result)**
$$\frac{}{ \text{ExecIRSigma}(\text{ResultIR}(v), \sigma) \Downarrow (\text{Ctrl}(\text{Result}(v)), \sigma)}$$

**(ExecIR-Break)**
$$\frac{}{ \text{ExecIRSigma}(\text{BreakIR}(v_{opt}), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{opt})), \sigma)}$$

**(ExecIR-Continue)**
$$\frac{}{ \text{ExecIRSigma}(\text{ContinueIR}, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma)}$$

**(ExecIR-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\text{ExecIRSigma}(\text{DeferIR}(b), \sigma) \Downarrow (ok, \sigma')}$$

$$\text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma) \Downarrow (out, \sigma') \iff \text{ExecIRSigma}(IR_s, \sigma) \Downarrow (sout, \sigma_1) \land \Big((sout = ok \land IR_t = \epsilon \land out = \text{Val}(()) \land \sigma' = \sigma_1)\ \lor\ (sout = ok \land \text{ExecIRSigma}(IR_t, \sigma_1) \Downarrow (out, \sigma'))\ \lor\ (sout = \text{Ctrl}(\text{Result}(v)) \land out = \text{Val}(v) \land \sigma' = \sigma_1)\ \lor\ (sout = \text{Ctrl}(\kappa) \land \kappa \ne \text{Result}(\_) \land out = \text{Ctrl}(\kappa) \land \sigma' = \sigma_1)\Big)$$
$$\Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma, scope) \Downarrow (out, \sigma') \iff \text{CurrentScopeId}(\sigma) = scope \land \text{ExecIRSigma}(IR_b, \sigma) \Downarrow (out, \sigma')$$
$$\Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (out', \sigma'') \iff \text{BindPatternVal}(pat, v) \Downarrow B \land \text{BindOrder}(pat, B) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

**(ExecIR-If-True)**
$$\frac{v_c = \text{true} \quad \text{ExecIRSigma}(IR_t, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-If-False)**
$$\frac{v_c = \text{false} \quad \text{ExecIRSigma}(IR_f, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-Block)**
$$\frac{\text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope) \quad \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{BlockIR}(IR_s, IR_t, v_t), \sigma) \Downarrow (out', \sigma_3)}$$

**(ExecIR-Match)**
$$\frac{\Gamma \vdash \text{MatchArmsSigma}(arms, v_s, \sigma) \Downarrow (out, \sigma')}{\text{ExecIRSigma}(\text{MatchIR}(v_s, arms), \sigma) \Downarrow (out, \sigma')}$$

**(ExecIR-Loop-Infinite-Step)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Infinite-Continue)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Infinite-Break)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_1) \quad v = \text{BreakVal}(v_{\text{opt}})}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(ExecIR-Loop-Infinite-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Loop-Cond-False)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(ExecIR-Loop-Cond-True-Step)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma_2) \Downarrow (out, \sigma_3)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (out, \sigma_3)}$$

**(ExecIR-Loop-Cond-Continue)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_2) \quad \text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma_2) \Downarrow (out, \sigma_3)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (out, \sigma_3)}$$

**(ExecIR-Loop-Cond-Break)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_2) \quad v = \text{BreakVal}(v_{\text{opt}})}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(ExecIR-Loop-Cond-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Loop-Cond-Body-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_c, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \text{ExecIRSigma}(IR_b, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

$$\text{LoopIterIRJudg} = \{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma')\}$$

**(ExecIR-Loop-Iter)**
$$\frac{\text{ExecIRSigma}(IR_i, \sigma) \Downarrow (\text{Val}(v_{\text{iter}}), \sigma_1) \quad \text{IterInit}(v_{\text{iter}}) \Downarrow it \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma_1) \Downarrow (out, \sigma_2)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), \sigma) \Downarrow (out, \sigma_2)}$$

**(ExecIR-Loop-Iter-Ctrl)**
$$\frac{\text{ExecIRSigma}(IR_i, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\text{ExecIRSigma}(\text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(LoopIterIR-Done)**
$$\frac{\text{IterNext}(it) \Downarrow (\bot, it')}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Val}(()), \sigma)}$$

**(LoopIterIR-Step-Val)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIterIR-Step-Continue)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIterIR-Step-Break)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v_{\text{opt}})), \sigma_1) \quad v' = \text{BreakVal}(v_{\text{opt}})}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(LoopIterIR-Step-Ctrl)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{ExecBlockBindIRSigma}(pat, v, IR_b, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{LoopIterExecIRSigma}(pat, IR_b, it, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecIR-Region)**
$$\frac{\text{RegionNew}(\sigma, v_o) \Downarrow (\sigma_1, r, scope) \quad \text{BindRegionAlias}(\sigma_1, alias\_opt, r) \Downarrow \sigma_2 \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_2, scope) \Downarrow (out, \sigma_3) \quad \text{RegionRelease}(\sigma_3, r, scope, out) \Downarrow (out', \sigma_4)}{\text{ExecIRSigma}(\text{RegionIR}(v_o, alias\_opt, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_4)}$$

**(ExecIR-Frame-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r, scope, mark, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{FrameIR}(\bot, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**(ExecIR-Frame-Explicit)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{ExecInScopeIRSigma}(IR_b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r_t, scope, mark, out) \Downarrow (out', \sigma_3)}{\text{ExecIRSigma}(\text{FrameIR}(v_r, IR_b, v_b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**Lowering Helpers.**

**(LowerList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerList}([]) \Downarrow \langle \epsilon, [] \rangle }$$

**(LowerList-Cons)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR_s, \vec{v} \rangle}{\Gamma \vdash \text{LowerList}(e::es) \Downarrow \langle \text{SeqIR}(IR_e, IR_s), [v] \mathbin{+\!\!+} \vec{v} \rangle}$$

**(LowerFieldInits-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerFieldInits}([]) \Downarrow \langle \epsilon, [] \rangle }$$

**(LowerFieldInits-Cons)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerFieldInits}(fs) \Downarrow \langle IR_s, \vec{f} \rangle}{\Gamma \vdash \text{LowerFieldInits}([\langle f, e \rangle] \mathbin{+\!\!+} fs) \Downarrow \langle \text{SeqIR}(IR_e, IR_s), [\langle f, v \rangle] \mathbin{+\!\!+} \vec{f} \rangle}$$

**(LowerOpt-None)**
$$\frac{}{ \Gamma \vdash \text{LowerOpt}(\bot) \Downarrow \langle \epsilon, \bot \rangle }$$

**(LowerOpt-Some)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerOpt}(e) \Downarrow \langle IR_e, v \rangle}$$

$$\text{IsRangeExpr}(e) \iff \text{ExprType}(e) = \text{TypeRange}$$

**Expression Lowering.** The rules below define `LowerExpr`.

**(Lower-Expr-Literal)**
$$\frac{T = \text{ExprType}(\text{Literal}(\ell)) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{LowerExpr}(\text{Literal}(\ell)) \Downarrow \langle \epsilon, v \rangle}$$

**(Lower-Expr-PtrNull)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{PtrNullExpr}) \Downarrow \langle \epsilon, \text{Ptr@Null}(0x0) \rangle }$$

**(Lower-Expr-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot \quad \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(x)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path}{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(x)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle}$$

**(Lower-Expr-Path)**
$$\frac{}{\Gamma \vdash \text{LowerExpr}(\text{Path}(path, name)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle}$$

**(Lower-Expr-Error)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{ErrorExpr}(span)) \Downarrow \langle \text{LowerPanic}(\text{ErrorExpr}(span)), v_{\text{unreach}} \rangle }$$

**(Lower-Expr-Tuple)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{TupleExpr}(es)) \Downarrow \langle IR, (v_1,\ldots,v_n) \rangle}$$

**(Lower-Expr-Array)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{ArrayExpr}(es)) \Downarrow \langle IR, [v_1,\ldots,v_n] \rangle}$$

**(Lower-Expr-Record)**
$$\frac{\Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR, \vec{f} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{RecordExpr}(tr, fields)) \Downarrow \langle IR, \text{RecordValue}(tr, \vec{f}) \rangle}$$

**(Lower-Expr-Enum-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \bot)) \Downarrow \langle \epsilon, \text{EnumValue}(path, \bot) \rangle }$$

**(Lower-Expr-Enum-Tuple)**
$$\frac{\Gamma \vdash \text{LowerList}(es) \Downarrow \langle IR, \vec{v} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \text{Paren}(es))) \Downarrow \langle IR, \text{EnumValue}(path, \text{TuplePayload}(\vec{v})) \rangle}$$

**(Lower-Expr-Enum-Record)**
$$\frac{\Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR, \vec{f} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{EnumLiteral}(path, \text{Brace}(fields))) \Downarrow \langle IR, \text{EnumValue}(path, \text{RecordPayload}(\vec{f})) \rangle}$$

**(Lower-Expr-FieldAccess)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \text{FieldValue}(v_b, f) = v_f}{\Gamma \vdash \text{LowerExpr}(\text{FieldAccess}(base, f)) \Downarrow \langle IR_b, v_f \rangle}$$

**(Lower-Expr-TupleAccess)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \text{TupleValue}(v_b, i) = v_i}{\Gamma \vdash \text{LowerExpr}(\text{TupleAccess}(base, i)) \Downarrow \langle IR_b, v_i \rangle}$$

**(Lower-Expr-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_b), v_i) \Downarrow ok \quad \text{IndexValue}(v_b, v_i) = v_e}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i), v_e \rangle}$$

**(Lower-Expr-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_b)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_b), v_r) \Downarrow ok \quad \text{SliceValue}(v_b, v_r) = v_s}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i), v_s \rangle}$$

**(Lower-Expr-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerExpr}(base) \Downarrow \langle IR_b, v_b \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_b)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerExpr}(\text{IndexAccess}(base, idx)) \Downarrow \langle \text{SeqIR}(IR_b, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Call-PanicOut)**
$$\frac{\Gamma \vdash \text{LowerExpr}(callee) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerArgs}(\text{Params}(\text{Call}(callee, args)), args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \text{NeedsPanicOut}(callee)}{\Gamma \vdash \text{LowerExpr}(\text{Call}(callee, args)) \Downarrow \langle \text{SeqIR}(IR_c, IR_a, \text{CallIR}(v_c, \vec{v} \mathbin{+\!\!+} [\text{PanicOutName}]), \text{PanicCheck}), v_{\text{call}} \rangle}$$

**(Lower-Expr-Call-NoPanicOut)**
$$\frac{\Gamma \vdash \text{LowerExpr}(callee) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerArgs}(\text{Params}(\text{Call}(callee, args)), args) \Downarrow \langle IR_a, \vec{v} \rangle \quad \neg \text{NeedsPanicOut}(callee)}{\Gamma \vdash \text{LowerExpr}(\text{Call}(callee, args)) \Downarrow \langle \text{SeqIR}(IR_c, IR_a, \text{CallIR}(v_c, \vec{v})), v_{\text{call}} \rangle}$$

**(Lower-Expr-MethodCall)**
$$\frac{\Gamma \vdash \text{LowerMethodCall}(\text{MethodCall}(base, name, args)) \Downarrow \langle IR, v_{\text{call}} \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MethodCall}(base, name, args)) \Downarrow \langle IR, v_{\text{call}} \rangle}$$

**(Lower-Expr-Unary)**
$$\frac{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Unary}(op, e)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Bin-And)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(\texttt{"&&"}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, \text{IfIR}(v_1, IR_2, v_2, \epsilon, \text{false})), v_{\text{and}} \rangle}$$

**(Lower-Expr-Bin-Or)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(\texttt{"||"}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, \text{IfIR}(v_1, \epsilon, \text{true}, IR_2, v_2)), v_{\text{or}} \rangle}$$

**(Lower-Expr-Binary)**
$$\frac{op \notin \{\texttt{"&&"},\ \texttt{"||"}\} \quad \Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Binary}(op, e_1, e_2)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Cast)**
$$\frac{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Cast}(e, T)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Transmute)**
$$\frac{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{TransmuteExpr}(T_1, T_2, e)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Propagate-Success)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_s, v_s \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Propagate}(e)) \Downarrow \langle IR_e, v_s \rangle}$$

**(Lower-Expr-Propagate-Return)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_e, v_e \rangle \quad T_e \ne T_s}{\Gamma \vdash \text{LowerExpr}(\text{Propagate}(e)) \Downarrow \langle \text{SeqIR}(IR_e, \text{ReturnIR}(v_e)), v_{\text{unreach}} \rangle}$$

**(Lower-Expr-Range)**
$$\frac{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(kind, lo\_opt, hi\_opt)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Range}(kind, lo\_opt, hi\_opt)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-If)**
$$\frac{\Gamma \vdash \text{LowerExpr}(cond) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerBlock}(b_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerBlock}(b_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerExpr}(\text{IfExpr}(cond, b_1, b_2)) \Downarrow \langle \text{SeqIR}(IR_c, \text{IfIR}(v_c, IR_1, v_1, IR_2, v_2)), v_{\text{if}} \rangle}$$

**(Lower-Expr-Match)**
$$\frac{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MatchExpr}(scrut, arms)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopInf)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopInfinite}(body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopInfinite}(body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopCond)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopConditional}(cond, body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopConditional}(cond, body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-LoopIter)**
$$\frac{\Gamma \vdash \text{LowerLoop}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Block)**
$$\frac{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{BlockExpr}(stmts, tail\_opt)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{UnsafeBlockExpr}(b)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-Move)**
$$\frac{\Gamma \vdash \text{LowerMovePlace}(p) \Downarrow \langle IR, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{MoveExpr}(p)) \Downarrow \langle IR, v \rangle}$$

**(Lower-Expr-AddressOf)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR, addr \rangle}{\Gamma \vdash \text{LowerExpr}(\text{AddressOf}(p)) \Downarrow \langle IR, \text{Ptr@Valid}(addr) \rangle}$$

**(Lower-Expr-Deref)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v_{ptr} \rangle \quad \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_d, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{Deref}(e)) \Downarrow \langle \text{SeqIR}(IR_e, IR_d), v \rangle}$$

**(Lower-Expr-Alloc)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerExpr}(\text{AllocExpr}(r\_opt, e)) \Downarrow \langle \text{SeqIR}(IR_e, \text{AllocIR}(r\_opt, v)), v_{\text{alloc}} \rangle}$$

**Operator and Cast Lowering.**

$$\text{OpPanicReason}(op, v) = r$$
$$\text{OpPanicReason}(op, v_1, v_2) = r$$
$$\text{OpPanicReason}(op, v) =
\begin{cases}
\text{Overflow} & op = \texttt{"-"}\\
\text{Other} & \text{otherwise}
\end{cases}$$
$$\text{OpPanicReason}(op, v_1, v_2) =
\begin{cases}
\text{DivZero} & op \in \{\texttt{"/"},\ \texttt{"%"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land v_2 = 0\\
\text{Overflow} & op \in \{\texttt{"/"},\ \texttt{"%"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land v_2 \ne 0\\
\text{Shift} & op \in \text{ShiftOps}\\
\text{Overflow} & op \in \{\texttt{"+"},\ \texttt{"-"},\ \texttt{"*"},\ \texttt{"**"}\} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t)\\
\text{Other} & \text{otherwise}
\end{cases}$$

**(Lower-UnOp-Ok)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{UnOp}(op, v) \Downarrow v'}{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle IR_e, v' \rangle}$$

**(Lower-UnOp-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{UnOp}(op, v)\ \text{undefined} \quad \text{OpPanicReason}(op, v) = r \quad \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR_k}{\Gamma \vdash \text{LowerUnOp}(op, e) \Downarrow \langle \text{SeqIR}(IR_e, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-BinOp-Ok)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle \quad \text{BinOp}(op, v_1, v_2) \Downarrow v}{\Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), v \rangle}$$

**(Lower-BinOp-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle \quad \text{BinOp}(op, v_1, v_2)\ \text{undefined} \quad \text{OpPanicReason}(op, v_1, v_2) = r \quad \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR_k}{\Gamma \vdash \text{LowerBinOp}(op, e_1, e_2) \Downarrow \langle \text{SeqIR}(IR_1, IR_2, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-Cast)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle IR, v' \rangle}$$

**(Lower-Cast-Panic)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v)\ \text{undefined} \quad \Gamma \vdash \text{LowerPanic}(\text{Cast}) \Downarrow IR_k}{\Gamma \vdash \text{LowerCast}(e, T) \Downarrow \langle \text{SeqIR}(IR, IR_k), v_{\text{unreach}} \rangle}$$

$$\text{PlaceForms0} = \{\text{Identifier}(\_),\ \text{FieldAccess}(\_,\_),\ \text{TupleAccess}(\_,\_),\ \text{IndexAccess}(\_,\_),\ \text{Deref}(\_)\}$$
$$\text{LowerPlaceTotal}(\Gamma) \iff \forall p.\ p \in \text{PlaceForms0} \Rightarrow \exists l.\ \Gamma \vdash \text{LowerPlace}(p) \Downarrow l$$
$$\text{LowerPlacePreserve}(\Gamma) \iff \forall p,l.\ \Gamma \vdash \text{LowerPlace}(p) \Downarrow l \Rightarrow (\forall \sigma, out, \sigma'.\ \Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (out, \sigma') \Rightarrow \Gamma \vdash \text{ReadPlaceSigma}(l, \sigma) \Downarrow (out, \sigma')) \land (\forall \sigma, v, sout, \sigma'.\ \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma) \Downarrow (sout, \sigma') \Rightarrow \Gamma \vdash \text{WritePlaceSigma}(l, v, \sigma) \Downarrow (sout, \sigma'))$$

**Place Lowering Rules.**

**(Lower-Place-Ident)**
$$\frac{}{ \Gamma \vdash \text{LowerPlace}(\text{Identifier}(x)) \Downarrow \text{Identifier}(x) }$$

**(Lower-Place-Field)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{FieldAccess}(p, f)) \Downarrow \text{FieldAccess}(l, f) }$$

**(Lower-Place-Tuple)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{TupleAccess}(p, i)) \Downarrow \text{TupleAccess}(l, i) }$$

**(Lower-Place-Index)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{IndexAccess}(p, idx)) \Downarrow \text{IndexAccess}(l, idx) }$$

**(Lower-Place-Deref)**
$$\frac{\Gamma \vdash \text{LowerPlace}(p) \Downarrow l}{ \Gamma \vdash \text{LowerPlace}(\text{Deref}(p)) \Downarrow \text{Deref}(l) }$$

**Place Access Lowering.**

$$\text{DropOnAssignRoot}(p) \iff \text{PlaceRoot}(p) = x \land \Big((\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land ent.\text{origin\_opt} = \bot \land \text{BindInfo}(x).\text{mov} = \text{immov} \land \text{BindInfo}(x).\text{resp} = \text{resp}) \ \lor$$
$$\qquad (\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \land path = \text{PathOfModule}(mp) \land \text{StaticBindInfo}(path, name).\text{mov} = \text{immov} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp})\Big)$$

**(Lower-ReadPlace-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle \text{ReadVarIR}(x), v \rangle }$$

**(Lower-ReadPlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path}{ \Gamma \vdash \text{LowerReadPlace}(\text{Identifier}(x)) \Downarrow \langle \text{ReadPathIR}(path, name), v \rangle }$$

**(Lower-ReadPlace-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldValue}(v_p, f) = v_f}{\Gamma \vdash \text{LowerReadPlace}(\text{FieldAccess}(p, f)) \Downarrow \langle IR_p, v_f \rangle}$$

**(Lower-ReadPlace-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleValue}(v_p, i) = v_i}{\Gamma \vdash \text{LowerReadPlace}(\text{TupleAccess}(p, i)) \Downarrow \langle IR_p, v_i \rangle}$$

**(Lower-ReadPlace-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexValue}(v_p, v_i) = v_e}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i), v_e \rangle}$$

**(Lower-ReadPlace-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-ReadPlace-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceValue}(v_p, v_r) = v_s}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i), v_s \rangle}$$

**(Lower-ReadPlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerReadPlace}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-ReadPlace-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_d, v \rangle}{\Gamma \vdash \text{LowerReadPlace}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_d), v \rangle}$$

**(Lower-AddrOf-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerAddrOf}(\text{Identifier}(x)) \Downarrow \langle \epsilon, \text{AddrOfBind}(x) \rangle }$$

**(Lower-AddrOf-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad \text{StaticAddr}(path, name) = addr \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerAddrOf}(\text{Identifier}(x)) \Downarrow \langle IR_p, addr \rangle }$$

**(Lower-AddrOf-Field)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad T_b = \text{ExprType}(p) \quad \text{FieldAddr}(T_b, addr, f) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{FieldAccess}(p, f)) \Downarrow \langle IR_p, addr' \rangle}$$

**(Lower-AddrOf-Tuple)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad T_b = \text{ExprType}(p) \quad \text{TupleAddr}(T_b, addr, i) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{TupleAccess}(p, i)) \Downarrow \langle IR_p, addr' \rangle}$$


**(Lower-AddrOf-Index)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_r, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad T_b = \text{ExprType}(p) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexAddr}(T_b, addr, v_i) = addr'}{\Gamma \vdash \text{LowerAddrOf}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_r, IR_i), addr' \rangle}$$

**(Lower-AddrOf-Index-OOB)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_r, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{IndexAccess}(p, idx)) \Downarrow \langle \text{SeqIR}(IR_p, IR_r, IR_i, IR_k), v_{\text{unreach}} \rangle}$$

**(Lower-AddrOf-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid}) \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle IR_p, addr \rangle}$$

**(Lower-AddrOf-Deref-Null)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \text{PtrAddr}(v_{ptr}) = addr \quad \Gamma \vdash \text{LowerPanic}(\text{NullDeref}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_k), addr \rangle}$$

**(Lower-AddrOf-Deref-Expired)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \text{PtrAddr}(v_{ptr}) = addr \quad \Gamma \vdash \text{LowerPanic}(\text{ExpiredDeref}) \Downarrow IR_k}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle \text{SeqIR}(IR_p, IR_k), addr \rangle}$$

**(Lower-AddrOf-Deref-Raw)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle \quad \text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T) \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{LowerAddrOf}(\text{Deref}(p)) \Downarrow \langle IR_p, addr \rangle}$$

**(Lower-WritePlace-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerWritePlace}(\text{Identifier}(x), v) \Downarrow \text{StoreVarIR}(x, v) }$$

**(Lower-WritePlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases} \quad IR_d = \begin{cases}\text{EmitDrop}(\text{StaticType}(path, name), \text{Load}(@sym, \text{StaticType}(path, name))) & \text{if } \text{StaticBindInfo}(path, name).\text{resp} = \text{resp} \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerWritePlace}(\text{Identifier}(x), v) \Downarrow \text{SeqIR}(IR_p, IR_d, \text{StoreGlobal}(sym, v)) }$$

**(Lower-WritePlace-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldValue}(v_p, f) = v_f \quad T_f = \text{ExprType}(\text{FieldAccess}(p, f)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_f, v_f) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{FieldAccess}(p, f), v) \Downarrow \text{SeqIR}(IR_p, IR_d, IR_w)}$$

**(Lower-WritePlace-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleValue}(v_p, i) = v_i \quad T_i = \text{ExprType}(\text{TupleAccess}(p, i)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_i, v_i) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{TupleAccess}(p, i), v) \Downarrow \text{SeqIR}(IR_p, IR_d, IR_w)}$$

**(Lower-WritePlace-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexValue}(v_p, v_i) = v_e \quad T_e = \text{ExprType}(\text{IndexAccess}(p, idx)) \quad IR_d = \begin{cases}\text{EmitDrop}(T_e, v_e) & \text{if } \text{DropOnAssignRoot}(p) \\ \epsilon & \text{otherwise}\end{cases} \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_d, IR_w)}$$

**(Lower-WritePlace-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(Lower-WritePlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlace}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(Lower-WritePlace-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle}{\Gamma \vdash \text{LowerWritePlace}(\text{Deref}(p), v) \Downarrow \text{SeqIR}(IR_p, \text{WritePtrIR}(v_{ptr}, v))}$$

**Write-Subplace Lowering.**

**(LowerWriteSub-Ident-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot}{ \Gamma \vdash \text{LowerWritePlaceSub}(\text{Identifier}(x), v) \Downarrow \text{StoreVarNoDropIR}(x, v) }$$

**(LowerWriteSub-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym \quad IR_p = \begin{cases}\text{CheckPoison}(m) & \text{if } \text{ProcModule}(sym)=m \\ \epsilon & \text{otherwise}\end{cases}}{ \Gamma \vdash \text{LowerWritePlaceSub}(\text{Identifier}(x), v) \Downarrow \text{SeqIR}(IR_p, \text{StoreGlobal}(sym, v)) }$$

**(LowerWriteSub-Field)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{FieldAccess}(p, f), v) \Downarrow \text{SeqIR}(IR_p, IR_w)}$$

**(LowerWriteSub-Tuple)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{TupleAccess}(p, i), v) \Downarrow \text{SeqIR}(IR_p, IR_w)}$$

**(LowerWriteSub-Index-Scalar)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \Gamma \vdash \text{CheckIndex}(\text{Len}(v_p), v_i) \Downarrow ok \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(LowerWriteSub-Index-Scalar-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_i \rangle \quad \text{ExprType}(idx) = \text{TypePrim}(\texttt{"usize"}) \quad \neg(0 \le v_i < \text{Len}(v_p)) \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Index-Range)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \Gamma \vdash \text{CheckRange}(\text{Len}(v_p), v_r) \Downarrow ok \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{LowerWritePlaceSub}(p, v_p') \Downarrow IR_w}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_w)}$$

**(LowerWriteSub-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(idx) \Downarrow \langle IR_i, v_r \rangle \quad \text{IsRangeExpr}(idx) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start \quad \Gamma \vdash \text{LowerPanic}(\text{Bounds}) \Downarrow IR_k}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{IndexAccess}(p, idx), v) \Downarrow \text{SeqIR}(IR_p, IR_i, IR_k)}$$

**(LowerWriteSub-Deref)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v_{ptr} \rangle}{\Gamma \vdash \text{LowerWritePlaceSub}(\text{Deref}(p), v) \Downarrow \text{SeqIR}(IR_p, \text{WritePtrIR}(v_{ptr}, v))}$$

**(Lower-MovePlace)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v \rangle}{\Gamma \vdash \text{LowerMovePlace}(p) \Downarrow \langle \text{SeqIR}(IR_p, \text{MoveStateIR}(p)), v \rangle}$$

### 6.5. Statement and Block Lowering

$$\text{LowerStmtJudg} = \{\text{LowerStmt},\ \text{LowerStmtList},\ \text{LowerBlock},\ \text{LowerLoop}\}$$

**(Lower-Stmt-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (sout, \sigma')}{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR}$$

**(Lower-Block-Correctness)**
$$\frac{\forall \sigma,\ out,\ \sigma'.\ \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma') \Rightarrow \left(\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land (out=\text{Val}(v') \Rightarrow v=v')\right)}{\Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle}$$

**(Lower-Loop-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(loop, \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{LowerLoop}(loop) \Downarrow \langle IR, v \rangle}$$

$$\text{StmtForms0} = \{\text{LetStmt}(\_),\ \text{VarStmt}(\_),\ \text{ShadowLetStmt}(\_,\_,\_),\ \text{ShadowVarStmt}(\_,\_,\_),\ \text{AssignStmt}(\_,\_),\ \text{CompoundAssignStmt}(\_,\_,\_),\ \text{ExprStmt}(\_),\ \text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_),\ \text{ReturnStmt}(\_),\ \text{ResultStmt}(\_),\ \text{BreakStmt}(\_),\ \text{ContinueStmt},\ \text{UnsafeBlockStmt}(\_),\ \text{ErrorStmt}(\_)\}$$
$$\text{LowerStmtTotal}(\Gamma) \iff \forall s.\ s \in \text{StmtForms0} \Rightarrow \exists IR.\ \Gamma \vdash \text{LowerStmt}(s) \Downarrow IR$$

**(Lower-StmtList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerStmtList}([]) \Downarrow \epsilon }$$

**(Lower-StmtList-Cons)**
$$\frac{\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR_s \quad \Gamma \vdash \text{LowerStmtList}(ss) \Downarrow IR_r}{\Gamma \vdash \text{LowerStmtList}(s::ss) \Downarrow \text{SeqIR}(IR_s, IR_r)}$$

$$\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle$$

**(Lower-Stmt-Let)**
$$\frac{\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle \quad \Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR_b}{\Gamma \vdash \text{LowerStmt}(\text{LetStmt}(binding)) \Downarrow \text{SeqIR}(IR_i, IR_b)}$$

**(Lower-Stmt-Var)**
$$\frac{\text{BindingParts}(binding) = \langle pat, ty\_opt, op, init, span \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle \quad \Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR_b}{\Gamma \vdash \text{LowerStmt}(\text{VarStmt}(binding)) \Downarrow \text{SeqIR}(IR_i, IR_b)}$$

**(Lower-Stmt-ShadowLet)**
$$\frac{\Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ShadowLetStmt}(x, ty\_opt, init)) \Downarrow \text{SeqIR}(IR_i, \text{BindVarIR}(x, v))}$$

**(Lower-Stmt-ShadowVar)**
$$\frac{\Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_i, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ShadowVarStmt}(x, ty\_opt, init)) \Downarrow \text{SeqIR}(IR_i, \text{BindVarIR}(x, v))}$$

**(Lower-Stmt-Assign)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{LowerWritePlace}(place, v) \Downarrow IR_w}{\Gamma \vdash \text{LowerStmt}(\text{AssignStmt}(place, expr)) \Downarrow \text{SeqIR}(IR_e, IR_w)}$$

**(Lower-Stmt-CompoundAssign)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(place) \Downarrow \langle IR_p, v_p \rangle \quad \Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v_e \rangle \quad \text{BinOp}(op, v_p, v_e) \Downarrow v \quad \Gamma \vdash \text{LowerWritePlace}(place, v) \Downarrow IR_w}{\Gamma \vdash \text{LowerStmt}(\text{CompoundAssignStmt}(place, op, expr)) \Downarrow \text{SeqIR}(IR_p, IR_e, IR_w)}$$


**(Lower-Stmt-Expr)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ExprStmt}(expr)) \Downarrow IR_e}$$

**(Lower-Stmt-Defer)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{DeferStmt}(block)) \Downarrow \text{DeferIR}(block) }$$

**(Lower-Stmt-Region)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{LowerExpr}(opts) \Downarrow \langle IR_o, v_o \rangle \quad \Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{RegionStmt}(opts\_opt, alias\_opt, block)) \Downarrow \text{SeqIR}(IR_o, \text{RegionIR}(v_o, alias\_opt, IR_b, v_b))}$$

**(Lower-Stmt-Frame-Implicit)**
$$\frac{\Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{FrameStmt}(\bot, block)) \Downarrow \text{FrameIR}(\bot, IR_b, v_b)}$$

**(Lower-Stmt-Frame-Explicit)**
$$\frac{\Gamma \vdash \text{LowerExpr}(\text{Identifier}(r)) \Downarrow \langle IR_r, v_r \rangle \quad \Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerStmt}(\text{FrameStmt}(r, block)) \Downarrow \text{SeqIR}(IR_r, \text{FrameIR}(v_r, IR_b, v_b))}$$

**(Lower-Stmt-Return)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(e)) \Downarrow \text{SeqIR}(IR_e, \text{ReturnIR}(v))}$$

**(Lower-Stmt-Return-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(\bot)) \Downarrow \text{ReturnIR}(()) }$$

**(Lower-Stmt-Result)**
$$\frac{\Gamma \vdash \text{LowerExpr}(expr) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{ResultStmt}(expr)) \Downarrow \text{SeqIR}(IR_e, \text{ResultIR}(v))}$$

**(Lower-Stmt-Break)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(e)) \Downarrow \text{SeqIR}(IR_e, \text{BreakIR}(v))}$$

**(Lower-Stmt-Break-Unit)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(\bot)) \Downarrow \text{BreakIR}(\bot) }$$

**(Lower-Stmt-Continue)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ContinueStmt}) \Downarrow \text{ContinueIR} }$$

**(Lower-Stmt-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{LowerBlock}(block) \Downarrow \langle IR_b, v \rangle}{\Gamma \vdash \text{LowerStmt}(\text{UnsafeBlockStmt}(block)) \Downarrow IR_b}$$

**(Lower-Stmt-Error)**
$$\frac{}{ \Gamma \vdash \text{LowerStmt}(\text{ErrorStmt}(span)) \Downarrow \text{LowerPanic}(\text{ErrorStmt}(span)) }$$

**Temporary Cleanup in Lowering.**

Let $\text{TempDropOrder}(s) = [e_1,\ldots,e_k]$. For each $i$, let
$\Gamma \vdash \text{LowerExpr}(e_i) \Downarrow \langle IR_i, v_i \rangle$
denote the unique invocation of $\text{LowerExpr}(e_i)$ in the derivation of
$\Gamma \vdash \text{LowerStmt}(s) \Downarrow IR_s$, and let $\text{ExprType}(e_i)=T_i$.

$$\text{TempCleanupIR}(s) =
\begin{cases}
\epsilon & \text{if } k = 0\\
\text{SeqIRList}([\text{EmitDrop}(T_k, v_k),\ldots,\text{EmitDrop}(T_1, v_1)]) & \text{otherwise}
\end{cases}$$

For $s \notin \{\text{ReturnStmt}(\_),\ \text{ResultStmt}(\_),\ \text{BreakStmt}(\_),\ \text{ContinueStmt}\}$, the lowering MUST produce
$$\Gamma \vdash \text{LowerStmt}(s) \Downarrow \text{SeqIR}(IR_s,\ \text{TempCleanupIR}(s)).$$

For control-flow statements, the lowering MUST emit temporary cleanup immediately before the control transfer:

$$\Gamma \vdash \text{LowerStmt}(\text{ReturnStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{ReturnIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{ResultStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{ResultIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(e)) \Downarrow \text{SeqIR}(IR_e,\ \text{TempCleanupIR}(s),\ \text{BreakIR}(v))$$
$$\Gamma \vdash \text{LowerStmt}(\text{BreakStmt}(\bot)) \Downarrow \text{SeqIR}(\text{TempCleanupIR}(s),\ \text{BreakIR}(\bot))$$
$$\Gamma \vdash \text{LowerStmt}(\text{ContinueStmt}) \Downarrow \text{SeqIR}(\text{TempCleanupIR}(s),\ \text{ContinueIR})$$

$$\text{BlockForms0} = \{\text{BlockExpr}(\_,\_)\}$$
$$\text{LoopForms0} = \{\text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}$$
$$\text{LowerBlockTotal}(\Gamma) \iff \forall b.\ b \in \text{BlockForms0} \Rightarrow \exists IR,v.\ \Gamma \vdash \text{LowerBlock}(b) \Downarrow \langle IR, v \rangle$$
$$\text{LowerLoopTotal}(\Gamma) \iff \forall l.\ l \in \text{LoopForms0} \Rightarrow \exists IR,v.\ \Gamma \vdash \text{LowerLoop}(l) \Downarrow \langle IR, v \rangle$$

**(Lower-Block-Tail)**
$$\frac{tail \ne \bot \quad \Gamma \vdash \text{LowerStmtList}(stmts) \Downarrow IR_s \quad \Gamma \vdash \text{LowerExpr}(tail) \Downarrow \langle IR_t, v_t \rangle}{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, tail)) \Downarrow \langle \text{BlockIR}(IR_s, IR_t, v_t), v_{\text{block}} \rangle}$$

**(Lower-Block-Unit)**
$$\frac{\Gamma \vdash \text{LowerStmtList}(stmts) \Downarrow IR_s}{\Gamma \vdash \text{LowerBlock}(\text{BlockExpr}(stmts, \bot)) \Downarrow \langle \text{BlockIR}(IR_s, \epsilon, ()), v_{\text{block}} \rangle}$$

**(Lower-Loop-Infinite)**
$$\frac{\Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopInfinite}(body)) \Downarrow \langle \text{LoopIR}(\text{LoopInfinite}, IR_b, v_b), v_{\text{loop}} \rangle}$$

**(Lower-Loop-Cond)**
$$\frac{\Gamma \vdash \text{LowerExpr}(cond) \Downarrow \langle IR_c, v_c \rangle \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopConditional}(cond, body)) \Downarrow \langle \text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b), v_{\text{loop}} \rangle}$$

**(Lower-Loop-Iter)**
$$\frac{\Gamma \vdash \text{LowerExpr}(iter) \Downarrow \langle IR_i, v_{\text{iter}} \rangle \quad \Gamma \vdash \text{LowerBlock}(body) \Downarrow \langle IR_b, v_b \rangle}{\Gamma \vdash \text{LowerLoop}(\text{LoopIter}(pat, ty\_opt, iter, body)) \Downarrow \langle \text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b), v_{\text{loop}} \rangle}$$


### 6.6. Pattern Matching Lowering

$$\text{PatternLowerJudg} = \{\text{LowerBindPattern},\ \text{LowerBindList},\ \text{LowerMatch},\ \text{TagOf}\}$$

**(Lower-Pat-Correctness)**
$$\frac{\forall v,\ \Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (ok, \sigma')}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR}$$
$$\text{MatchValueCorrect}(\Gamma, scrut, arms, v) \iff \forall \sigma, v', \sigma'.\ \Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrut, arms), \sigma) \Downarrow (\text{Val}(v'), \sigma') \Rightarrow v = v'$$

**(Lower-Match-Correctness)**
$$\frac{\forall \sigma,\ \Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrut, arms), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \quad \text{MatchValueCorrect}(\Gamma, scrut, arms, v)}{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle IR, v \rangle}$$

$$\text{EnumValuePath}(v) = path \iff v = \text{EnumValue}(path, payload)$$
$$\text{VariantIndex}(E, name) = i \iff \text{Variants}(E) = [v_0,\ldots,v_k] \land v_i.\text{name} = name$$
$$\text{EnumDisc}(E, name) = d \iff \text{EnumDiscriminants}(E) \Downarrow ds \land \text{VariantIndex}(E, name) = i \land ds[i] = d$$
$$\text{StateIndex}(M, S) = i \iff \text{States}(M) = [S_0,\ldots,S_k] \land S_i = S$$

**(TagOf-Enum)**
$$\frac{\text{EnumValuePath}(v) = path \quad \text{EnumPath}(path) = p \quad T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{VariantName}(path) = name \quad \text{EnumDisc}(E, name) = d}{\Gamma \vdash \text{TagOf}(v, T) \Downarrow d}$$

**(TagOf-Modal)**
$$\frac{v = \langle S, v_S \rangle \quad T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{StateIndex}(M, S) = i}{\Gamma \vdash \text{TagOf}(v, T) \Downarrow i}$$

$$\text{LowerBindJudg} = \{\text{LowerBindList},\ \text{LowerBindPattern},\ \text{LowerMatch}\}$$

**(Lower-BindList-Empty)**
$$\frac{}{ \Gamma \vdash \text{LowerBindList}([]) \Downarrow \epsilon }$$

**(Lower-BindList-Cons)**
$$\frac{\Gamma \vdash \text{LowerBindList}(bs) \Downarrow IR_r}{\Gamma \vdash \text{LowerBindList}([\langle x, v \rangle] \mathbin{+\!\!+} bs) \Downarrow \text{SeqIR}(\text{BindVarIR}(x, v), IR_r)}$$

**(Lower-Pat-General)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \Gamma \vdash \text{LowerBindList}(binds) \Downarrow IR}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Downarrow IR}$$

**(Lower-Pat-Err)**
$$\frac{\text{MatchPattern}(pat, v)\ \text{undefined}}{\Gamma \vdash \text{LowerBindPattern}(pat, v) \Uparrow}$$

**(Lower-Match)**
$$\frac{\Gamma \vdash \text{LowerExpr}(scrut) \Downarrow \langle IR_s, v_s \rangle}{\Gamma \vdash \text{LowerMatch}(scrut, arms) \Downarrow \langle \text{SeqIR}(IR_s, \text{MatchIR}(v_s, arms)), v_{\text{match}} \rangle}$$


### 6.7. Globals and Initialization

$$\text{GlobalsJudg} = \{\text{EmitGlobal},\ \text{InitFn},\ \text{DeinitFn},\ \text{Lower-StaticInit},\ \text{Lower-StaticInitItem},\ \text{Lower-StaticInitItems},\ \text{InitCallIR},\ \text{Lower-StaticDeinit},\ \text{Lower-StaticDeinitNames},\ \text{Lower-StaticDeinitItem},\ \text{Lower-StaticDeinitItems},\ \text{DeinitCallIR},\ \text{EmitInitPlan},\ \text{EmitDeinitPlan},\ \text{EmitStringLit},\ \text{EmitBytesLit},\ \text{InitPanicHandle}\}$$

$$\text{ConstInitJudg} = \{\text{ConstInit}\}$$

$$\Gamma \vdash \text{ConstInit}(e) \Downarrow bytes \iff e = \text{Literal}(lit) \land \Gamma \vdash \text{EncodeConst}(\text{ExprType}(e), lit) \Downarrow bytes$$

$$\text{StaticName}(binding) =
\begin{cases}
name & binding = \langle \text{IdentifierPattern}(name), ty\_opt, op, init, span \rangle\\
name & binding = \langle \text{TypedPattern}(name, \_), ty\_opt, op, init, span \rangle\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{StaticBindTypes}(binding) = B \iff binding = \langle pat, ty\_opt, op, init, \_ \rangle \land \Gamma \vdash pat \Leftarrow \text{BindType}(binding) \dashv B$$

$$\text{StaticBindList}(binding) = \text{PatNames}(pat) \iff binding = \langle pat, \_, \_, \_, \_ \rangle$$

$$\text{StaticBinding} : \text{StaticDecl} \times \text{Name} \to \text{StaticDecl}$$

$$\text{StaticSym}(\text{StaticDecl}(\_,\_, binding,\_,\_), x) = \begin{cases}
\text{Mangle}(\text{StaticDecl}(\_,\_, binding,\_,\_)) & \text{if } \text{StaticName}(binding)=x \\
\text{Mangle}(\text{StaticBinding}(\text{StaticDecl}(\_,\_, binding,\_,\_), x)) & \text{otherwise}
\end{cases}$$

**(Emit-Static-Const)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = name \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{ConstInit}(init) \Downarrow bytes \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalConst}(sym, bytes)]}$$

**(Emit-Static-Init)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = name \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{ConstInit}(init) \Uparrow \quad T = \text{ExprType}(init) \quad \Gamma \vdash \text{Mangle}(\text{item}) \Downarrow sym}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalZero}(sym, \text{sizeof}(T))]}$$

**(Emit-Static-Multi)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad \text{StaticName}(binding) = \bot \quad \text{StaticBindTypes}(binding) = B \quad \text{StaticBindList}(binding) = [x_1,\ldots,x_k] \quad \forall i,\ \Gamma \vdash \text{Mangle}(\text{StaticBinding}(\text{item}, x_i)) \Downarrow sym_i}{\Gamma \vdash \text{EmitGlobal}(\text{item}) \Downarrow [\text{GlobalZero}(sym_1, \text{sizeof}(B[x_1])),\ldots,\text{GlobalZero}(sym_k, \text{sizeof}(B[x_k]))]}$$

$$\text{InitSym}(m) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"init"}] \mathbin{+\!\!+} \text{PathOfModule}(m))$$

**(InitFn)**
$$\frac{\text{InitSym}(m) = sym}{\Gamma \vdash \text{InitFn}(m) \Downarrow sym}$$

$$\text{DeinitSym}(m) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"deinit"}] \mathbin{+\!\!+} \text{PathOfModule}(m))$$

**(DeinitFn)**
$$\frac{\text{DeinitSym}(m) = sym}{\Gamma \vdash \text{DeinitFn}(m) \Downarrow sym}$$

$$\text{StaticItems}(P, m) = [\ item \mid item \in \text{ASTModule}(P, m).\text{items} \land item = \text{StaticDecl}(\_,\_,\_,\_,\_)\ ]$$

$$\text{StaticItemOf}(path, name) = item \iff m = path \land item \in \text{StaticItems}(\text{Project}(\Gamma), m) \land item = \text{StaticDecl}(\_,\_, binding,\_,\_) \land name \in \text{StaticBindList}(binding) \land \forall item'.\ (item' \in \text{StaticItems}(\text{Project}(\Gamma), m) \land item' = \text{StaticDecl}(\_,\_, binding',\_,\_) \land name \in \text{StaticBindList}(binding')) \Rightarrow item' = item$$

$$\text{StaticSymPath}(path, name) = \text{StaticSym}(item, name) \iff \text{StaticItemOf}(path, name) = item$$

$$\text{StaticAddr}(path, name) = addr \iff \exists sym.\ \text{StaticSymPath}(path, name) = sym \land \text{AddrOfSym}(sym) = addr$$

$$\text{AddrOfSym} : \text{Symbol} \to \text{Addr}$$

$$\text{StaticType}(path, name) = \text{StaticBindTypes}(binding)[name] \iff \text{StaticItemOf}(path, name) = \text{StaticDecl}(\_, mut, binding,\_,\_)$$

$$\text{StaticBindInfo}(path, name) = \text{BindInfoMap}(\lambda U.\ \text{RespOfInit}(init),\ \text{StaticBindTypes}(binding),\ \text{MovOf}(op),\ mut)[name] \iff \text{StaticItemOf}(path, name) = \text{StaticDecl}(\_, mut, binding,\_,\_) \land binding = \langle \_, \_, op, init, \_ \rangle$$

$$\text{SeqIRList}([]) = \epsilon$$
$$\text{SeqIRList}([IR] \mathbin{+\!\!+} IRs) = \text{SeqIR}(IR, \text{SeqIRList}(IRs))$$

$$\text{StaticStoreIR}(item, []) = \epsilon$$
$$\text{StaticStoreIR}(item, [\langle x, v \rangle] \mathbin{+\!\!+} bs) = \text{SeqIR}(\text{StoreGlobal}(\text{StaticSym}(item, x), v), \text{StaticStoreIR}(item, bs))$$

**(Lower-StaticInit-Item)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad binding = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{LowerExpr}(init) \Downarrow \langle IR_e, v \rangle \quad \Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \Gamma \vdash \text{InitPanicHandle}(m) \Downarrow IR_p}{\Gamma \vdash \text{Lower-StaticInitItem}(m, item) \Downarrow \text{SeqIR}(IR_e, \text{StaticStoreIR}(item, binds), IR_p)}$$

**(Lower-StaticInitItems-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticInitItems}(m, []) \Downarrow \epsilon}$$

**(Lower-StaticInitItems-Cons)**
$$\frac{\Gamma \vdash \text{Lower-StaticInitItem}(m, item) \Downarrow IR_i \quad \Gamma \vdash \text{Lower-StaticInitItems}(m, items) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticInitItems}(m, [item] \mathbin{+\!\!+} items) \Downarrow \text{SeqIR}(IR_i, IR_r)}$$

**(Lower-StaticInit)**
$$\frac{\text{StaticItems}(\text{Project}(\Gamma), m) = items \quad \Gamma \vdash \text{Lower-StaticInitItems}(m, items) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticInit}(m) \Downarrow IR}$$

**(InitCallIR)**
$$\frac{\Gamma \vdash \text{InitFn}(m) \Downarrow sym}{\Gamma \vdash \text{InitCallIR}(m) \Downarrow \text{SeqIR}(\text{CallIR}(sym, [\text{PanicOutName}]), \text{PanicCheck})}$$

$$\text{Rev}([]) = []$$
$$\text{Rev}([x] \mathbin{+\!\!+} xs) = \text{Rev}(xs) \mathbin{+\!\!+} [x]$$

**(Lower-StaticDeinitNames-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, []) \Downarrow \epsilon}$$

**(Lower-StaticDeinitNames-Cons-Resp)**
$$\frac{\text{StaticBindInfo}(path, x).\text{resp} = \text{resp} \quad sym = \text{StaticSym}(item, x) \quad \Gamma \vdash \text{EmitDrop}(\text{StaticType}(path, x), \text{Load}(@sym, \text{StaticType}(path, x))) \Downarrow IR_d \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, xs) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, [x] \mathbin{+\!\!+} xs) \Downarrow \text{SeqIR}(IR_d, IR_r)}$$

**(Lower-StaticDeinitNames-Cons-NoResp)**
$$\frac{\text{StaticBindInfo}(path, x).\text{resp} \ne \text{resp} \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, xs) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitNames}(path, item, [x] \mathbin{+\!\!+} xs) \Downarrow IR_r}$$

**(Lower-StaticDeinit-Item)**
$$\frac{\text{item} = \text{StaticDecl}(vis, mut, binding, span, doc) \quad binding = \langle pat, \_, \_, \_, \_ \rangle \quad xs = \text{Rev}(\text{StaticBindList}(binding)) \quad \Gamma \vdash \text{Lower-StaticDeinitNames}(\text{PathOfModule}(m), item, xs) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticDeinitItem}(m, item) \Downarrow IR}$$

**(Lower-StaticDeinitItems-Empty)**
$$\frac{}{\Gamma \vdash \text{Lower-StaticDeinitItems}(m, []) \Downarrow \epsilon}$$

**(Lower-StaticDeinitItems-Cons)**
$$\frac{\Gamma \vdash \text{Lower-StaticDeinitItem}(m, item) \Downarrow IR_i \quad \Gamma \vdash \text{Lower-StaticDeinitItems}(m, items) \Downarrow IR_r}{\Gamma \vdash \text{Lower-StaticDeinitItems}(m, [item] \mathbin{+\!\!+} items) \Downarrow \text{SeqIR}(IR_i, IR_r)}$$

**(Lower-StaticDeinit)**
$$\frac{\text{StaticItems}(\text{Project}(\Gamma), m) = items \quad \Gamma \vdash \text{Lower-StaticDeinitItems}(m, \text{Rev}(items)) \Downarrow IR}{\Gamma \vdash \text{Lower-StaticDeinit}(m) \Downarrow IR}$$

**(DeinitCallIR)**
$$\frac{\Gamma \vdash \text{DeinitFn}(m) \Downarrow sym}{\Gamma \vdash \text{DeinitCallIR}(m) \Downarrow \text{SeqIR}(\text{CallIR}(sym, [\text{PanicOutName}]), \text{PanicCheck})}$$

**(EmitInitPlan)**
$$\frac{\text{InitOrder} = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{InitCallIR}(m_i) \Downarrow IR_i \quad IR_{\text{init}} = \text{SeqIRList}([IR_1,\ldots,IR_k])}{\Gamma \vdash \text{EmitInitPlan}(P) \Downarrow IR_{\text{init}}}$$

**(EmitInitPlan-Err)**
$$\frac{\exists m \in \text{InitOrder}.\ \Gamma \vdash \text{InitFn}(m) \Uparrow}{\Gamma \vdash \text{EmitInitPlan}(P) \Uparrow}$$

**(EmitDeinitPlan)**
$$\frac{\text{InitOrder} = [m_1,\ldots,m_k] \quad \forall i,\ \Gamma \vdash \text{DeinitCallIR}(m_i) \Downarrow IR_i \quad IR_{\text{deinit}} = \text{SeqIRList}(\text{Rev}([IR_1,\ldots,IR_k]))}{\Gamma \vdash \text{EmitDeinitPlan}(P) \Downarrow IR_{\text{deinit}}}$$

**(EmitDeinitPlan-Err)**
$$\frac{\exists m \in \text{InitOrder}.\ \Gamma \vdash \text{DeinitFn}(m) \Uparrow}{\Gamma \vdash \text{EmitDeinitPlan}(P) \Uparrow}$$

### 6.8. Cleanup, Drop, and Unwinding

$$\text{CleanupJudg} = \{\text{EmitDrop},\ \text{CleanupPlan},\ \text{LowerPanic},\ \text{PanicSym},\ \text{ClearPanic},\ \text{PanicCheck}\}$$

**(CleanupPlan)**
$$\frac{cs = \text{CleanupList}(scope)}{\Gamma \vdash \text{CleanupPlan}(scope) \Downarrow cs}$$

$$\text{EmitDropSpec}(\Gamma, T, v, IR) \iff \forall \sigma,\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow \sigma'.$$
$$\Gamma \vdash \text{EmitDrop}(T, v) \Downarrow IR \iff \text{EmitDropSpec}(\Gamma, T, v, IR).$$

$$\text{PanicOutAddr}(\sigma) = addr \iff \text{LookupVal}(\sigma, \text{PanicOutName}) = \text{RawPtr}(\texttt{mut}, addr)$$

$$\text{PanicRecordOf}(\sigma) = \langle p, c \rangle \iff \text{PanicOutAddr}(\sigma) = addr \land \text{ReadAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, addr, \texttt{"panic"})) = p \land \text{ReadAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, addr, \texttt{"code"})) = c$$

$$\text{WritePanicRecord}(\sigma, p, c) \Downarrow \sigma' \iff \text{WriteAddr}(\sigma, \text{FieldAddr}(\text{PanicRecord}, \text{PanicOutAddr}(\sigma), \texttt{"panic"}), p) \Downarrow \sigma_1 \land \text{WriteAddr}(\sigma_1, \text{FieldAddr}(\text{PanicRecord}, \text{PanicOutAddr}(\sigma), \texttt{"code"}), c) \Downarrow \sigma'$$

$$\Gamma \vdash \text{InitPanicHandle}(m) \Downarrow IR \iff \forall \sigma.\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{true}, c \rangle \Rightarrow \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{ExecIRSigma}(\text{SeqIR}(\text{SetPoison}(m), \text{LowerPanic}(\text{InitPanic}(m))), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')\right) \land \left(\text{PanicRecordOf}(\sigma) = \langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right)$$

**(PanicSym)**
$$\frac{}{ \Gamma \vdash \text{PanicSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"panic"}]) }$$

$$\text{PanicReason} = \{\text{ErrorExpr}(span),\ \text{ErrorStmt}(span),\ \text{DivZero},\ \text{Overflow},\ \text{Shift},\ \text{Bounds},\ \text{Cast},\ \text{NullDeref},\ \text{ExpiredDeref},\ \text{InitPanic}(m),\ \text{Other}\}.$$

$$\text{PanicCode}(\text{ErrorExpr}(\_)) = 0x0001$$
$$\text{PanicCode}(\text{ErrorStmt}(\_)) = 0x0002$$
$$\text{PanicCode}(\text{DivZero}) = 0x0003$$
$$\text{PanicCode}(\text{Overflow}) = 0x0004$$
$$\text{PanicCode}(\text{Shift}) = 0x0005$$
$$\text{PanicCode}(\text{Bounds}) = 0x0006$$
$$\text{PanicCode}(\text{Cast}) = 0x0007$$
$$\text{PanicCode}(\text{NullDeref}) = 0x0008$$
$$\text{PanicCode}(\text{ExpiredDeref}) = 0x0009$$
$$\text{PanicCode}(\text{InitPanic}(\_)) = 0x000A$$
$$\text{PanicCode}(\text{Other}) = 0x00FF.$$

$$\text{PanicSite} = \{\text{DivZeroCheck},\ \text{OverflowCheck},\ \text{ShiftCheck},\ \text{BoundsCheck},\ \text{CastCheck},\ \text{NullDerefCheck},\ \text{ExpiredDerefCheck},\ \text{ErrorExprSite}(span),\ \text{ErrorStmtSite}(span),\ \text{InitPanicSite}(m),\ \text{OtherSite}\}.$$
$$\text{PanicReasonOf}(\text{DivZeroCheck}) = \text{DivZero}$$
$$\text{PanicReasonOf}(\text{OverflowCheck}) = \text{Overflow}$$
$$\text{PanicReasonOf}(\text{ShiftCheck}) = \text{Shift}$$
$$\text{PanicReasonOf}(\text{BoundsCheck}) = \text{Bounds}$$
$$\text{PanicReasonOf}(\text{CastCheck}) = \text{Cast}$$
$$\text{PanicReasonOf}(\text{NullDerefCheck}) = \text{NullDeref}$$
$$\text{PanicReasonOf}(\text{ExpiredDerefCheck}) = \text{ExpiredDeref}$$
$$\text{PanicReasonOf}(\text{ErrorExprSite}(span)) = \text{ErrorExpr}(span)$$
$$\text{PanicReasonOf}(\text{ErrorStmtSite}(span)) = \text{ErrorStmt}(span)$$
$$\text{PanicReasonOf}(\text{InitPanicSite}(m)) = \text{InitPanic}(m)$$
$$\text{PanicReasonOf}(\text{OtherSite}) = \text{Other}$$

$$\Gamma \vdash \text{ClearPanic} \Downarrow IR \iff \forall \sigma,\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \text{WritePanicRecord}(\sigma, \text{false}, 0) \Downarrow \sigma'.$$

$$\Gamma \vdash \text{PanicCheck} \Downarrow IR \iff \forall \sigma,\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma) = \langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right).$$

$$\Gamma \vdash \text{LowerPanic}(reason) \Downarrow IR \iff \forall \sigma.\ \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{WritePanicRecord}(\sigma, \text{true}, \text{PanicCode}(reason)) \Downarrow \sigma'$$

### 6.9. Built-ins Runtime Interface

$$\text{RuntimeIfcJudg} = \{\text{RegionLayout},\ \text{RegionSym},\ \text{BuiltinSym}\}$$

**(RegionLayout)**
$$\frac{\text{ModalLayout}(\texttt{Region}) \Downarrow \langle size, align, disc, payload \rangle}{\Gamma \vdash \text{RegionLayout} \Downarrow \langle size, align, [\langle \texttt{disc}, disc \rangle, \langle \texttt{payload}, payload \rangle] \rangle}$$

**(RegionSym-NewScoped)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::new_scoped}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"new_scoped"}]) }$$

**(RegionSym-Alloc)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::alloc}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"alloc"}]) }$$

**(RegionSym-ResetUnchecked)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::reset_unchecked}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"reset_unchecked"}]) }$$

**(RegionSym-Freeze)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::freeze}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"freeze"}]) }$$

**(RegionSym-Thaw)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::thaw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"thaw"}]) }$$

**(RegionSym-FreeUnchecked)**
$$\frac{}{ \Gamma \vdash \text{RegionSym}(\texttt{Region::free_unchecked}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"region"}, \texttt{"free_unchecked"}]) }$$

**(BuiltinSym-FileSystem-OpenRead)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_read}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_read"}]) }$$

**(BuiltinSym-FileSystem-OpenWrite)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_write}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_write"}]) }$$

**(BuiltinSym-FileSystem-OpenAppend)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_append}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_append"}]) }$$

**(BuiltinSym-FileSystem-CreateWrite)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::create_write}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"create_write"}]) }$$

**(BuiltinSym-FileSystem-ReadFile)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::read_file}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"read_file"}]) }$$

**(BuiltinSym-FileSystem-ReadBytes)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::read_bytes}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"read_bytes"}]) }$$

**(BuiltinSym-FileSystem-WriteFile)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_file}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_file"}]) }$$

**(BuiltinSym-FileSystem-WriteStdout)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_stdout}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_stdout"}]) }$$

**(BuiltinSym-FileSystem-WriteStderr)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::write_stderr}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"write_stderr"}]) }$$

**(BuiltinSym-FileSystem-Exists)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::exists}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"exists"}]) }$$

**(BuiltinSym-FileSystem-Remove)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::remove}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"remove"}]) }$$

**(BuiltinSym-FileSystem-OpenDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::open_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"open_dir"}]) }$$

**(BuiltinSym-FileSystem-CreateDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::create_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"create_dir"}]) }$$

**(BuiltinSym-FileSystem-EnsureDir)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::ensure_dir}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"ensure_dir"}]) }$$

**(BuiltinSym-FileSystem-Kind)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::kind}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"kind"}]) }$$

**(BuiltinSym-FileSystem-Restrict)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{FileSystem::restrict}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"fs"}, \texttt{"restrict"}]) }$$

**(BuiltinSym-HeapAllocator-WithQuota)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::with_quota}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"with_quota"}]) }$$

**(BuiltinSym-HeapAllocator-AllocRaw)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::alloc_raw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"alloc_raw"}]) }$$

**(BuiltinSym-HeapAllocator-DeallocRaw)**
$$\frac{}{ \Gamma \vdash \text{BuiltinSym}(\texttt{HeapAllocator::dealloc_raw}) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"heap"}, \texttt{"dealloc_raw"}]) }$$

### 6.10. Dynamic Dispatch

$$\text{DynDispatchJudg} = \{\text{VTable},\ \text{VSlot},\ \text{DynPack},\ \text{LowerDynCall}\}$$

$$\text{VTableEligible}(Cl) = [\ m \in \text{EffMethods}(Cl) \mid \text{vtable\_eligible}(m)\ ].$$

**(DispatchSym-Impl)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = m' \quad \text{Sig}_T(T, m') = \text{Sig}_T(T, m) \quad \Gamma \vdash \text{Mangle}(m') \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(DispatchSym-Default-None)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = \bot \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(DispatchSym-Default-Mismatch)**
$$\frac{\text{LookupClassMethod}(Cl, name) = m \quad \text{MethodByName}(T, name) = m' \quad \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m) \quad m.\text{body\_opt} \ne \bot \quad \Gamma \vdash \text{Mangle}(\text{DefaultImpl}(T, m)) \Downarrow sym}{\Gamma \vdash \text{DispatchSym}(T, Cl, name) \Downarrow sym}$$

**(VTable-Order)**
$$\frac{\text{VTableEligible}(Cl) = [m_1,\ldots,m_k] \quad \forall i,\ \text{DispatchSym}(T, Cl, m_i.\text{name}) = sym_i}{\Gamma \vdash \text{VTable}(T, Cl) \Downarrow [sym_1,\ldots,sym_k]}$$

**(VSlot-Entry)**
$$\frac{\text{VTableEligible}(Cl) = [m_0,\ldots,m_{k-1}] \quad m_i.\text{name} = method.\text{name}}{\Gamma \vdash \text{VSlot}(Cl, method) \Downarrow i}$$

**(Lower-Dynamic-Form)**
$$\frac{\text{IsPlace}(e) \quad \Gamma \vdash \text{LowerAddrOf}(e) \Downarrow \langle IR, addr \rangle \quad T_e = \text{ExprType}(e) \quad T = \text{StripPerm}(T_e) \quad \Gamma \vdash T <: Cl}{\Gamma \vdash \text{DynPack}(T, e) \Downarrow \langle \text{RawPtr}(\texttt{imm}, addr), \text{VTable}(T, Cl) \rangle}$$

**(Lower-DynCall)**
$$\frac{\text{VSlot}(Cl, name) \Downarrow i}{\Gamma \vdash \text{LowerDynCall}(base, name, args) \Downarrow \text{SeqIR}(\text{CallVTable}(base, i, args), \text{PanicCheck})}$$

### 6.11. Checks and Panic

$$\text{ChecksJudg} = \{\text{LowerRangeExpr},\ \text{CheckIndex},\ \text{CheckRange},\ \text{LowerTransmute},\ \text{LowerRawDeref}\}$$

**(Lower-Range-Full)**
$$\frac{}{ \Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Full}, \bot, \bot)) \Downarrow \langle \epsilon, \text{RangeVal}(\texttt{Full}, \bot, \bot) \rangle }$$
  
**(Lower-Range-To)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{To}, \bot, e)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{To}, \bot, v) \rangle}$$

**(Lower-Range-ToInclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{ToInclusive}, \bot, e)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{ToInclusive}, \bot, v) \rangle}$$
  
**(Lower-Range-From)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{From}, e, \bot)) \Downarrow \langle IR_e, \text{RangeVal}(\texttt{From}, v, \bot) \rangle}$$
  
**(Lower-Range-Inclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Inclusive}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), \text{RangeVal}(\texttt{Inclusive}, v_1, v_2) \rangle}$$
  
**(Lower-Range-Exclusive)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e_1) \Downarrow \langle IR_1, v_1 \rangle \quad \Gamma \vdash \text{LowerExpr}(e_2) \Downarrow \langle IR_2, v_2 \rangle}{\Gamma \vdash \text{LowerRangeExpr}(\text{Range}(\texttt{Exclusive}, e_1, e_2)) \Downarrow \langle \text{SeqIR}(IR_1, IR_2), \text{RangeVal}(\texttt{Exclusive}, v_1, v_2) \rangle}$$

**(Check-Index-Ok)**
$$\frac{\text{IndexNum}(v_i)=i \quad 0 \le i < L}{\Gamma \vdash \text{CheckIndex}(L, v_i) \Downarrow ok}$$

**(Check-Index-Err)**
$$\frac{\text{IndexNum}(v_i)=i \quad \neg(0 \le i < L)}{\Gamma \vdash \text{CheckIndex}(L, v_i) \Uparrow}$$

**(Check-Range-Ok)**
$$\frac{\text{SliceBounds}(r, L)\ \text{defined}}{\Gamma \vdash \text{CheckRange}(L, r) \Downarrow ok}$$

**(Check-Range-Err)**
$$\frac{\text{SliceBounds}(r, L)\ \text{undefined}}{\Gamma \vdash \text{CheckRange}(L, r) \Uparrow}$$

**(Lower-Transmute)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{TransmuteVal}(T_1, T_2, v) \Downarrow v'}{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Downarrow \langle IR_e, v' \rangle}$$

**(Lower-Transmute-Err)**
$$\frac{\Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR_e, v \rangle \quad \text{TransmuteVal}(T_1, T_2, v)\ \text{undefined}}{\Gamma \vdash \text{LowerTransmute}(T_1, T_2, e) \Uparrow}$$

**Raw Dereference Lowering.**

**(Lower-RawDeref-Safe)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle \text{ReadPtrIR}(v_{ptr}), v \rangle }$$

**(Lower-RawDeref-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T)}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle \text{ReadPtrIR}(v_{ptr}), v \rangle }$$

**(Lower-RawDeref-Null)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \Gamma \vdash \text{LowerPanic}(\text{NullDeref}) \Downarrow IR_k}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_k, v_{\text{unreach}} \rangle }$$

**(Lower-RawDeref-Expired)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \Gamma \vdash \text{LowerPanic}(\text{ExpiredDeref}) \Downarrow IR_k}{ \Gamma \vdash \text{LowerRawDeref}(v_{ptr}) \Downarrow \langle IR_k, v_{\text{unreach}} \rangle }$$

### 6.12. LLVM 21 Backend Requirements

#### 6.12.1. LLVM Module Header

$$\text{LLVMHeader} = [\text{TargetDataLayout}(\text{LLVMDataLayout}),\ \text{TargetTriple}(\text{LLVMTriple})]$$

#### 6.12.2. Opaque Pointer Model (LLVM 21)

$$\text{AddrSpace}(T) =
\begin{cases}
0 & T = \text{TypePtr}(U, s)\\
0 & T = \text{TypeRawPtr}(q, U)\\
0 & T = \text{TypeFunc}(params, R)\\
\text{AddrSpace}(U) & T = \text{TypePerm}(p, U) \land \text{AddrSpace}(U)\ \text{defined}\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{LLVMPtrTy}(T) = \texttt{ptr addrspace(AddrSpace(T))}\ \text{when }\text{AddrSpace}(T)\ \text{defined}$$

#### 6.12.3. LLVM Attribute Mapping (Permissions and Pointer State)

$$\text{LLVMAttrJudg} = \{\text{PtrStateOf}(T) = s,\ \text{LLVMPtrAttrs}(T) \Downarrow A,\ \text{LLVMArgAttrs}(T) \Downarrow A\}$$

**(PtrStateOf-Perm)**
$$\frac{\text{PtrStateOf}(T) = s}{\text{PtrStateOf}(\text{TypePerm}(p,T)) = s}$$

**(LLVM-PtrAttrs-Valid)**
$$\frac{\text{StripPerm}(T) = \text{TypePtr}(U, \texttt{Valid})}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \{\texttt{nonnull},\ \texttt{dereferenceable}(\text{sizeof}(U)),\ \texttt{align}(\text{alignof}(U)),\ \texttt{noundef}\}}$$

**(LLVM-PtrAttrs-Other)**
$$\frac{\text{StripPerm}(T) = \text{TypePtr}(U, s) \quad s \in \{\bot,\ \texttt{Null},\ \texttt{Expired}\}}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-PtrAttrs-RawPtr)**
$$\frac{\text{StripPerm}(T) = \text{TypeRawPtr}(q, U)}{\Gamma \vdash \text{LLVMPtrAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-ArgAttrs-Ptr)**
$$\text{LLVMArgAttrsPtr}(T) = (\text{PermOf}(T)=\texttt{unique} Sigma \{\texttt{noalias}\} : \emptyset) \cup (\text{PermOf}(T)=\texttt{const} Sigma \{\texttt{readonly}\} : \emptyset)$$
$$\frac{\text{StripPerm}(T) \in \{\text{TypePtr}(\_,\_),\ \text{TypeFunc}(\_,\_)\}}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \text{LLVMArgAttrsPtr}(T)}$$

**(LLVM-ArgAttrs-RawPtr)**
$$\frac{\text{StripPerm}(T) = \text{TypeRawPtr}(\_,\_)}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \emptyset}$$

**(LLVM-ArgAttrs-NonPtr)**
$$\frac{\text{StripPerm}(T) \notin \{\text{TypePtr}(\_,\_),\ \text{TypeRawPtr}(\_,\_),\ \text{TypeFunc}(\_,\_)\}}{\Gamma \vdash \text{LLVMArgAttrs}(T) \Downarrow \emptyset}$$

$$\text{NoEscapeParam}(x)\ \text{predicate}$$
$$\text{NoEscapeParam}(x) \iff \text{false}$$
$$\text{OptArgAttrs}(x) \subseteq \{\texttt{nocapture}\} \land (\texttt{nocapture} \in \text{OptArgAttrs}(x) \Rightarrow \text{NoEscapeParam}(x))$$
$$\text{LLVMArgAttrsExt}(x, T) = \text{LLVMArgAttrs}(T) \cup \text{OptArgAttrs}(x)$$

#### 6.12.4. UB and Poison Avoidance (LLVM 21)

$$\text{LLVMInstrs}(LLVMIR) = [i_0,\ldots,i_n]$$
$$\text{Opcode}(i) = op$$
$$\text{UsesOpcode}(LLVMIR, op) \iff \exists i \in \text{LLVMInstrs}(LLVMIR).\ \text{Opcode}(i)=op$$
$$\text{Intrinsic}(i) = name$$
$$\text{UsesIntrinsic}(LLVMIR, name) \iff \exists i \in \text{LLVMInstrs}(LLVMIR).\ \text{Intrinsic}(i)=name$$
$$\text{NoUndefPoison}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{undef}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{poison})$$
$$\text{NoNSWNUW}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{nsw}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{nuw})$$
$$\text{CheckedOverflow}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{add}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{sub}) \land \neg \text{UsesOpcode}(LLVMIR, \texttt{mul}) \land \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.*.with.overflow})$$
$$\text{CheckedDivRem}(LLVMIR) \iff \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.sdiv.with.check}) \land \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.udiv.with.check})$$
$$\text{CheckedShifts}(LLVMIR) \iff \text{UsesIntrinsic}(LLVMIR, \texttt{llvm.shift.with.check})$$
$$\text{FrozenPoisonUses}(LLVMIR) \iff \text{UsesOpcode}(LLVMIR, \texttt{freeze})$$
$$\text{InboundsGEP}(LLVMIR) \iff \neg \text{UsesOpcode}(LLVMIR, \texttt{getelementptr inbounds}) \lor \text{UsesOpcode}(LLVMIR, \texttt{gep.inbounds.checked})$$
$$\text{LLVMUBSafe}(LLVMIR) \iff \text{NoUndefPoison}(LLVMIR) \land \text{CheckedOverflow}(LLVMIR) \land \text{CheckedDivRem}(LLVMIR) \land \text{CheckedShifts}(LLVMIR) \land \text{FrozenPoisonUses}(LLVMIR) \land \text{InboundsGEP}(LLVMIR) \land \text{NoNSWNUW}(LLVMIR)$$

#### 6.12.5. Memory Intrinsics

$$\text{Memmove}(dst, src, n) = [\texttt{call}\ \texttt{llvm.memmove}(dst, src, n)]$$
$$\text{MemcpyOverlapUnknown}(dst, src, n)\ \text{predicate}$$
$$\text{MemcpyOverlapUnknown}(dst, src, n) \iff \text{true}$$
$$\text{MemcpyAllowed}(dst, src, n) \iff \neg \text{MemcpyOverlapUnknown}(dst, src, n)$$
$$\text{AggMemcpy}(dst, src, n) =
\begin{cases}
\text{Memcpy}(dst, src, n) & \text{MemcpyAllowed}(dst, src, n)\\
\text{Memmove}(dst, src, n) & \text{otherwise}
\end{cases}$$
$$\text{AggZero}(dst, n) = \text{Memset}(dst, 0, n)$$
$$\text{LifetimeOpt}(T) \subseteq \{\texttt{llvm.lifetime.start}(\text{sizeof}(T)),\ \texttt{llvm.lifetime.end}(\text{sizeof}(T))\}$$

#### 6.12.6. Runtime and Builtâ€‘in Declarations

$$\text{RuntimeDeclJudg} = \{\text{RuntimeSig}(sym) \Downarrow \langle params, ret \rangle,\ \text{BuiltinSig}(method) \Downarrow \langle params, ret \rangle,\ \text{RuntimeDecls}(S) \Downarrow decls\}$$

$$\text{BuiltinSig}(\texttt{FileSystem}::name) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\text{CapRecv}(\texttt{FileSystem}, name),\ \text{TypeDynamic}(\texttt{FileSystem})) \rangle] \mathbin{+\!\!+} params,\ ret \rangle \iff \text{CapMethodSig}(\texttt{FileSystem}, name) = \langle params, ret \rangle$$
$$\text{BuiltinSig}(\texttt{HeapAllocator}::name) = \langle [\langle \bot,\ \texttt{self},\ \text{TypePerm}(\text{CapRecv}(\texttt{HeapAllocator}, name),\ \text{TypeDynamic}(\texttt{HeapAllocator})) \rangle] \mathbin{+\!\!+} params,\ ret \rangle \iff \text{CapMethodSig}(\texttt{HeapAllocator}, name) = \langle params, ret \rangle$$
$$\text{BuiltinSig}(method) = \langle params, ret \rangle \iff \text{StringBytesBuiltinSig}(method) = \langle params, ret \rangle$$

$$\text{RuntimeSig}(\text{PanicSym}) = \langle [\langle \bot,\ \texttt{code},\ \text{TypePrim}(\texttt{"u32"}) \rangle],\ \text{TypePrim}(\texttt{"!"}) \rangle$$
$$\text{RuntimeSig}(\text{ContextInitSym}) = \langle [],\ \text{TypePath}([\texttt{"Context"}]) \rangle$$
$$\text{RuntimeSig}(\text{StringDropSym}) = \langle [\langle \texttt{move},\ \texttt{value},\ \text{TypeString}(\texttt{@Managed}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle$$
$$\text{RuntimeSig}(\text{BytesDropSym}) = \langle [\langle \texttt{move},\ \texttt{value},\ \text{TypeBytes}(\texttt{@Managed}) \rangle],\ \text{TypePrim}(\texttt{"()"}) \rangle$$
$$\text{RuntimeSig}(sym) = \langle params, ret \rangle \iff sym = \text{RegionSym}(proc) \land \text{RegionProcSig}(proc) = \langle params, ret \rangle$$
$$\text{RuntimeSig}(sym) = \langle params, ret \rangle \iff sym = \text{BuiltinSym}(method) \land \text{BuiltinSig}(method) = \langle params, ret \rangle$$

$$\text{LLVMDecl} : \text{Symbol} \times \text{Sig} \to \text{LLVMDecl}$$

**(RuntimeDecls)**
$$\frac{\forall sym \in S,\ \text{RuntimeSig}(sym) = \langle params, ret \rangle \quad \text{LLVMCallSig}(params, ret) \Downarrow sig}{\Gamma \vdash \text{RuntimeDecls}(S) \Downarrow [\text{LLVMDecl}(sym, sig) \mid sym \in S]}$$
$$\text{DeclAttrs} : \text{Symbol} \to \text{AttrSet}$$
$$\text{DeclSyms}(LLVMIR) = \{ sym \mid \text{LLVMDecl}(sym,\_) \in LLVMIR \lor \text{LLVMDefine}(sym,\_,\_) \in LLVMIR \}$$
$$\text{DeclAttrsOk}(sym) \iff (sym=\text{PanicSym} \Rightarrow \{\texttt{noreturn},\ \texttt{nounwind}\} \subseteq \text{DeclAttrs}(sym)) \land (sym\ne\text{PanicSym} \Rightarrow \texttt{nounwind} \in \text{DeclAttrs}(sym))$$
$$\text{RuntimeDeclsOk}(decls) \iff \forall sym \in \text{DeclSyms}(decls).\ \text{DeclAttrsOk}(sym)$$
$$\text{RuntimeDeclsCover}(LLVMIR, IR) \iff \text{RuntimeRefs}(IR) \subseteq \text{DeclSyms}(LLVMIR)$$

#### 6.12.7. LLVM Toolchain Version

$$\text{LLVMToolchain} = \texttt{"21.1.8"}$$

#### 6.12.8. LLVM Type Mapping

$$\text{LLVMTyJudg} = \{\text{LLVMTy}(T) \Downarrow \tau\}$$

$$\text{LLVMZST} = \{\}$$
$$\text{Pad}(n) =
\begin{cases}
[] & n = 0\\
[n \times i8] & n \ne 0
\end{cases}$$

$$\text{LLVMPrim}(name) =
\begin{cases}
i8 & name \in \{i8,\ u8\}\\
i16 & name \in \{i16,\ u16\}\\
i32 & name \in \{i32,\ u32\}\\
i64 & name \in \{i64,\ u64\}\\
i128 & name \in \{i128,\ u128\}\\
\texttt{half} & name = f16\\
\texttt{float} & name = f32\\
\texttt{double} & name = f64\\
i8 & name = \texttt{bool}\\
i32 & name = \texttt{char}\\
i64 & name \in \{\texttt{usize},\ \texttt{isize}\}\\
\text{LLVMZST} & name \in \{\texttt{()},\ \texttt{!}\}\\
\bot & \text{otherwise}
\end{cases}$$

$$\text{LLVMStruct}([t_1,\ldots,t_k]) = \{ t_1, \ldots, t_k \}$$
$$\text{LLVMArray}(n, t) = [n \times t]$$
$$\text{LLVMArrayConst}(n, t, elems)\ \text{constructor}$$
$$\text{SlicePtrTy}(T) = \text{LLVMPtrTy}(\text{TypeRawPtr}(\texttt{imm}, T))$$

$$\text{StructElems}([], [], 0) = []$$
$$\text{StructElems}([\langle f_1, T_1 \rangle,\ldots,\langle f_n, T_n \rangle], [o_1,\ldots,o_n], size) = \text{Pad}(pad_1) \mathbin{+\!\!+} [\tau_1] \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} \text{Pad}(pad_n) \mathbin{+\!\!+} [\tau_n] \mathbin{+\!\!+} \text{Pad}(pad_{\text{tail}})$$
$$pad_1 = o_1$$
$$pad_i = o_i - (o_{i-1} + \text{sizeof}(T_{i-1}))\ \text{for } i=2..n$$
$$pad_{\text{tail}} = size - (o_n + \text{sizeof}(T_n))$$
$$\tau_i = \text{LLVMTy}(T_i)$$

$$\text{TaggedElems}(disc, payload\_size, payload\_align, size) = [\text{LLVMTy}(disc)] \mathbin{+\!\!+} \text{Pad}(pad_{\text{mid}}) \mathbin{+\!\!+} [\text{LLVMArray}(payload\_size, i8)] \mathbin{+\!\!+} \text{Pad}(pad_{\text{tail}})$$
$$disc\_size = \text{sizeof}(disc)$$
$$payload\_off = \text{AlignUp}(disc\_size, payload\_align)$$
$$pad_{\text{mid}} = payload\_off - disc\_size$$
$$pad_{\text{tail}} = size - (payload\_off + payload\_size)$$

**(LLVMTy-Prim)**
$$\frac{T = \text{TypePrim}(name) \quad \text{LLVMPrim}(name) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Perm)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(\text{TypePerm}(p, T)) \Downarrow \tau}$$

**(LLVMTy-Ptr)**
$$\frac{T = \text{TypePtr}(U, s) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-RawPtr)**
$$\frac{T = \text{TypeRawPtr}(q, U) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Func)**
$$\frac{T = \text{TypeFunc}(params, R) \quad \text{LLVMPtrTy}(T) = \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Alias)**
$$\frac{T = \text{TypePath}(p) \quad \text{AliasBody}(p) = ty \quad \Gamma \vdash \text{LLVMTy}(ty) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Record)**
$$\frac{T = \text{TypePath}(p) \quad \text{RecordDecl}(p) = R \quad \text{Fields}(R) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(fields, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Tuple)**
$$\frac{\text{TupleLayout}([T_1,\ldots,T_n]) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}([\langle 0,T_1\rangle,\ldots,\langle n-1,T_n\rangle], offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(\text{TypeTuple}([T_1,\ldots,T_n])) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Array)**
$$\frac{T = \text{TypeArray}(T_0, e) \quad \Gamma \vdash \text{ConstLen}(e) \Downarrow n \quad \Gamma \vdash \text{LLVMTy}(T_0) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMArray}(n, \tau)}$$

**(LLVMTy-Slice)**
$$\frac{T = \text{TypeSlice}(T_0) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{SlicePtrTy}(T_0), \tau_u])}$$

**(LLVMTy-Range)**
$$\frac{\Gamma \vdash \text{RangeLayout}() \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(\text{RangeFields}, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(\text{TypeRange}) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Enum)**
$$\frac{T = \text{TypePath}(p) \quad \text{EnumDecl}(p) = E \quad \text{EnumLayout}(E) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad payload\_align = \text{PayloadAlign}(E) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Union-Niche)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{NicheApplies}(T) \quad \text{PayloadMember}(T) = T_p \quad \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Union-Tagged)**
$$\frac{T = \text{TypeUnion}([T_1,\ldots,T_n]) \quad \text{UnionLayout}(T) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad disc \ne \bot \quad payload\_align = \text{PayloadAlign}(T) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Modal-Niche)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{NicheApplies}(M) \quad \text{PayloadState}(M) = S_p \quad \text{SingleFieldPayload}(M, S_p) = T_p \quad \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}$$

**(LLVMTy-Modal-Tagged)**
$$\frac{T = \text{TypePath}(p) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad \text{ModalLayout}(M) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad disc \ne \bot \quad payload\_align = \max_{S \in \text{States}(M)}(\text{StateAlign}(M, S)) \quad \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Modal-StringBytes)**
$$\text{BaseModal}(\text{TypeString}(\bot)) = \texttt{string}$$
$$\text{BaseModal}(\text{TypeBytes}(\bot)) = \texttt{bytes}$$
$$\frac{T \in \{\text{TypeString}(\bot),\ \text{TypeBytes}(\bot)\} \quad \text{ModalLayout}(\text{BaseModal}(T)) \Downarrow \langle size, \_, disc, payload\_size \rangle \quad (disc = \bot \Rightarrow \text{PayloadState}(\text{BaseModal}(T)) = S_p \land \text{SingleFieldPayload}(\text{BaseModal}(T), S_p) = T_p \land \Gamma \vdash \text{LLVMTy}(T_p) \Downarrow \tau) \quad (disc \ne \bot \Rightarrow payload\_align = \max_{S \in \text{States}(\text{BaseModal}(T))}(\text{StateAlign}(\text{BaseModal}(T), S)) \land \text{TaggedElems}(disc, payload\_size, payload\_align, size) = elems)}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow (\tau\ \text{if } disc=\bot\ \text{else }\text{LLVMStruct}(elems))}$$

**(LLVMTy-ModalState)**
$$\frac{T = \text{TypeModalState}(p, S) \quad \Sigma.\text{Types}[p] = \texttt{modal } M \quad S \in \text{States}(M) \quad \text{Payload}(M, S) = fields \quad \text{RecordLayout}(fields) \Downarrow \langle size, \_, offsets \rangle \quad \text{StructElems}(fields, offsets, size) = elems}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}(elems)}$$

**(LLVMTy-Dynamic)**
$$\frac{\text{DynLayout}(Cl) \Downarrow \langle \_,\_,[\langle \texttt{data}, T_d \rangle,\langle \texttt{vtable}, T_v \rangle] \rangle \quad \Gamma \vdash \text{LLVMTy}(T_d) \Downarrow \tau_d \quad \Gamma \vdash \text{LLVMTy}(T_v) \Downarrow \tau_v}{\Gamma \vdash \text{LLVMTy}(\text{TypeDynamic}(Cl)) \Downarrow \text{LLVMStruct}([\tau_d,\tau_v])}$$

**(LLVMTy-StringView)**
$$\frac{T = \text{TypeString}(\texttt{@View}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid})), \tau_u])}$$

**(LLVMTy-StringManaged)**
$$\frac{T = \text{TypeString}(\texttt{@Managed}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid})), \tau_u, \tau_u])}$$

**(LLVMTy-BytesView)**
$$\frac{T = \text{TypeBytes}(\texttt{@View}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, \text{TypePrim}(\texttt{"u8"})), \texttt{Valid})), \tau_u])}$$

**(LLVMTy-BytesManaged)**
$$\frac{T = \text{TypeBytes}(\texttt{@Managed}) \quad \Gamma \vdash \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})) \Downarrow \tau_u}{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \text{LLVMStruct}([\text{LLVMPtrTy}(\text{TypePtr}(\text{TypePrim}(\texttt{"u8"}), \texttt{Valid})), \tau_u, \tau_u])}$$

**(LLVMTy-Err)**
$$\frac{\text{LLVMTy}(T)\ \text{undefined}}{\Gamma \vdash \text{LLVMTy}(T) \Uparrow}$$

#### 6.12.9. LLVM IR Emission Pipeline

$$\text{LLVMEmitJudg} = \{\text{LowerIR}(ModuleIR) \Downarrow LLVMIR,\ \text{EmitLLVM}(LLVMIR) \Downarrow bytes,\ \text{EmitObj}(LLVMIR) \Downarrow bytes\}$$

$$\text{RuntimeSyms} = \{\text{PanicSym},\ \text{StringDropSym},\ \text{BytesDropSym},\ \text{ContextInitSym}\} \cup \{\text{RegionSym}(proc) \mid proc \in \text{RegionProcs}\} \cup \{\text{BuiltinSym}(method) \mid method \in \text{BuiltinMethods}\}$$
$$\text{BuiltinMethods} = \text{StringBuiltins} \cup \text{BytesBuiltins} \cup \{\texttt{FileSystem}::name \mid \langle name,\ recv,\ params,\ ret \rangle \in \text{FileSystemInterface}\} \cup \{\texttt{HeapAllocator}::name \mid \langle name,\ recv,\ params,\ ret \rangle \in \text{HeapAllocatorInterface}\}$$
$$\text{RefSyms} : IR \to \mathcal{P}(\text{Symbol})$$
$$\text{RefSyms}([]) = \emptyset$$
$$\text{RefSyms}([d] \mathbin{+\!\!+} ds) = \text{RefSyms}(d) \cup \text{RefSyms}(ds)$$
$$\text{RefSyms}(\text{ProcIR}(\_,\_,\_, IR)) = \text{RefSyms}(IR)$$
$$\text{RefSyms}(\text{GlobalConst}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{GlobalZero}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{GlobalVTable}(\_, header, slots)) = \{ s \mid s \in header \land s \in \text{Symbol} \} \cup \{ s \mid s \in slots \land s \in \text{Symbol} \}$$
$$\text{RefSyms}(\text{EmitVTable}(T, Cl)) = \text{RefSyms}(d) \iff \Gamma \vdash \text{EmitVTable}(T, Cl) \Downarrow d$$
$$\text{RefSyms}(\text{EmitDropGlue}(T)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR$$
$$\text{RefSyms}(\text{EmitLiteralData}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\epsilon) = \emptyset$$
$$\text{RefSyms}(\text{SeqIR}(IR_1, IR_2)) = \text{RefSyms}(IR_1) \cup \text{RefSyms}(IR_2)$$
$$\text{RefSyms}(\text{ReadVarIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{StoreVarIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{StoreVarNoDropIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{BindVarIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReadPtrIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{WritePtrIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{AllocIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{MoveStateIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReturnIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ResultIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{BreakIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ContinueIR}) = \emptyset$$
$$\text{RefSyms}(\text{DeferIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{ReadPathIR}(path, name)) = \{\text{PathSym}(path, name)\} \cup \{ sym \mid \text{StaticSymPath}(path, name) = sym \}$$
$$\text{RefSyms}(\text{StoreGlobal}(sym, \_)) = \{sym\}$$
$$\text{RefSyms}(\text{CallIR}(callee, \_)) = \{ callee \mid callee \in \text{Symbol} \}$$
$$\text{RefSyms}(\text{IfIR}(\_, IR_t,\_, IR_f,\_)) = \text{RefSyms}(IR_t) \cup \text{RefSyms}(IR_f)$$
$$\text{RefSyms}(\text{BlockIR}(IR_s, IR_t,\_)) = \text{RefSyms}(IR_s) \cup \text{RefSyms}(IR_t)$$
$$\text{RefSyms}(\text{MatchIR}(\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopInfinite}, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopConditional}, IR_c,\_, IR_b,\_)) = \text{RefSyms}(IR_c) \cup \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{LoopIR}(\text{LoopIter},\_,\_, IR_i,\_, IR_b,\_)) = \text{RefSyms}(IR_i) \cup \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{RegionIR}(\_,\_, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{FrameIR}(\_, IR_b,\_)) = \text{RefSyms}(IR_b)$$
$$\text{RefSyms}(\text{BranchIR}(\_)) = \emptyset$$
$$\text{RefSyms}(\text{BranchIR}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{PhiIR}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{CallVTable}(\_,\_,\_)) = \emptyset$$
$$\text{RefSyms}(\text{AddrOfIR}(p)) = \text{RefSyms}(IR_p) \iff \Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle$$
$$\text{RefSyms}(\text{ClearPanic}) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{ClearPanic} \Downarrow IR$$
$$\text{RefSyms}(\text{PanicCheck}) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{PanicCheck} \Downarrow IR$$
$$\text{RefSyms}(\text{CheckPoison}(m)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{CheckPoison}(m) \Downarrow IR$$
$$\text{RefSyms}(\text{LowerPanic}(r)) = \text{RefSyms}(IR) \iff \Gamma \vdash \text{LowerPanic}(r) \Downarrow IR$$
$$\text{RuntimeRefs}(IR) = \text{RefSyms}(IR) \cap \text{RuntimeSyms}$$
$$\text{LiteralRef}(IR, kind, bytes)\ \text{predicate}$$
$$\text{LiteralRef}(IR, kind, bytes) \iff \text{LiteralDataSym}(kind, bytes) \in \text{RefSyms}(IR)$$
$$\text{LiteralRefs}(IR) = \{\langle kind, bytes \rangle \mid \text{LiteralRef}(IR, kind, bytes)\}$$
$$\text{VTableRefs}(IR) = \{(T, Cl) \mid \text{DynPack}(T,\_) \in IR \lor \text{CallVTable}(\_,\_,\_) \in IR\}$$

$$\text{ExpandIR}(IR) = IR \mathbin{+\!\!+} \left(\mathbin{+\!\!+}_{(T,Cl) \in \text{VTableRefs}(IR)} [\text{EmitDropGlue}(T),\ \text{EmitVTable}(T,Cl)]\right) \mathbin{+\!\!+} \left(\mathbin{+\!\!+}_{\langle kind,bytes \rangle \in \text{LiteralRefs}(IR)} [\text{EmitLiteralData}(kind, bytes)]\right)$$

$$\text{EmitKey}(d) = \begin{cases}
\langle \texttt{vtable}, T, Cl \rangle & d = \text{EmitVTable}(T, Cl)\\
\langle \texttt{drop}, T \rangle & d = \text{EmitDropGlue}(T)\\
\langle \texttt{lit}, kind, bytes \rangle & d = \text{EmitLiteralData}(kind, bytes)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{EmitKeys}(IR) = [\text{EmitKey}(d) \mid d \in IR \land \text{EmitKey}(d) \ne \bot]$$
$$\text{UniqueEmits}(IR) \iff \text{NoDup}(\text{EmitKeys}(IR))$$

**(LowerIR-Module)**
$$\frac{
IR' = \text{ExpandIR}(IR) \quad
IR' = [d_1,\ldots,d_k] \quad
\forall i,\ \Gamma \vdash \text{LowerIRDecl}(d_i) \Downarrow ll_i \quad
\text{RuntimeDecls}(\text{RuntimeRefs}(IR')) = ds \quad
\text{RuntimeDeclsOk}(ds) \quad
LLVMIR = LLVMHeader \mathbin{+\!\!+} ds \mathbin{+\!\!+} ll_1 \mathbin{+\!\!+} \cdots \mathbin{+\!\!+} ll_k \quad
\text{LLVMUBSafe}(LLVMIR) \quad
\text{RuntimeDeclsCover}(LLVMIR, IR') \quad
\text{UniqueEmits}(IR')
}{\Gamma \vdash \text{LowerIR}(IR) \Downarrow LLVMIR}$$

**(LowerIR-Err)**
$$\frac{\exists i,\ \Gamma \vdash \text{LowerIRDecl}(d_i) \Uparrow}{\Gamma \vdash \text{LowerIR}(IR) \Uparrow}$$

**(EmitLLVM-Ok)**
$$\frac{\text{RenderLLVM}(LLVMIR) = bytes}{\Gamma \vdash \text{EmitLLVM}(LLVMIR) \Downarrow bytes}$$

$$\text{LLVMText}_{21} = \{ bytes \mid \texttt{llvm-as}\_{21}\ \text{accepts}\ bytes \}$$
$$\text{RenderLLVM}(LLVMIR) = bytes \Rightarrow bytes \in \text{LLVMText}_{21}$$

**(EmitLLVM-Err)**
$$\frac{\text{RenderLLVM}(LLVMIR) \Uparrow}{\Gamma \vdash \text{EmitLLVM}(LLVMIR) \Uparrow}$$

**(EmitObj-Ok)**
$$\frac{\text{LLVMEmitObj}_{21}(LLVMIR) = bytes}{\Gamma \vdash \text{EmitObj}(LLVMIR) \Downarrow bytes}$$
$$\text{LLVMEmitObj}_{21}(LLVMIR) = bytes \iff \text{LLVMObj}_{21}(LLVMIR, \text{LLVMHeader}) = bytes$$

**(EmitObj-Err)**
$$\frac{\text{LLVMEmitObj}_{21}(LLVMIR) \Uparrow}{\Gamma \vdash \text{EmitObj}(LLVMIR) \Uparrow}$$

#### 6.12.10. IR Operation Lowering

$$\text{LowerIRJudg} = \{\text{LowerIRDecl}(d) \Downarrow ll,\ \text{LowerIRInstr}(op) \Downarrow ll\}$$

$$\text{LLVMInstrList} = [\text{LLVMInstr}]$$
$$\text{Label}(l) \in \text{LLVMInstr}$$
$$\text{Br}(l) \in \text{LLVMInstr}$$
$$\text{BrCond}(v, l_t, l_f) \in \text{LLVMInstr}$$
$$\text{Phi}(\tau, inc, v) \in \text{LLVMInstr}$$
$$\text{HasLabel}(I, l) \iff \text{Label}(l) \in I$$
$$\text{HasBrCond}(I, v) \iff \exists l_t,l_f.\ \text{BrCond}(v, l_t, l_f) \in I$$
$$\text{HasPhi}(I, v) \iff \exists \tau,inc.\ \text{Phi}(\tau, inc, v) \in I$$
$$\text{FreshLabel}(\Gamma)\ \text{predicate}$$
$$\text{FreshSSA}(\Gamma)\ \text{predicate}$$
$$\text{LLVMSSA} = \text{Name}$$
$$\text{LLVMLabel} = \text{Name}$$
$$\text{FreshLabel}(\Gamma) \in \text{LLVMLabel} \setminus \text{dom}(\Gamma)$$
$$\text{FreshSSA}(\Gamma) \in \text{LLVMSSA} \setminus \text{dom}(\Gamma)$$

$$\text{IfLabels}(\Gamma) = \langle l_t,\ l_f,\ l_m \rangle \land \text{Distinct}([l_t,l_f,l_m])$$

$$\text{LLResult} = \{\langle I, v \rangle \mid I \in \text{LLVMInstrList} \land v \in \text{LLVMSSA} \cup \{\bot\}\}$$
$$\text{SeqLL}(\langle I_1, v_1 \rangle, \langle I_2, v_2 \rangle) = \langle I_1 \mathbin{+\!\!+} I_2, v_2 \rangle$$

**(LowerIRInstr-Empty)**
$$\frac{}{\Gamma \vdash \text{LowerIRInstr}(\epsilon) \Downarrow \langle [], \bot \rangle}$$

**(LowerIRInstr-Seq)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(IR_1) \Downarrow ll_1 \quad \Gamma \vdash \text{LowerIRInstr}(IR_2) \Downarrow ll_2}{\Gamma \vdash \text{LowerIRInstr}(\text{SeqIR}(IR_1, IR_2)) \Downarrow \text{SeqLL}(ll_1, ll_2)}$$

$$\text{Load}(slot, T) = [\texttt{load}\ \text{LLVMTy}(T),\ slot : \text{LLVMPtrTy}(T)]$$
$$\text{Store}(slot, v, T) = [\texttt{store}\ \text{LLVMTy}(T)\ v,\ slot : \text{LLVMPtrTy}(T)]$$
$$\text{Memcpy}(dst, src, n) = [\texttt{call}\ \texttt{llvm.memcpy}(dst, src, n)]$$
$$\text{Memset}(dst, 0, n) = [\texttt{call}\ \texttt{llvm.memset}(dst, 0, n)]$$
$$\text{LoadVal}(slot, T) \Downarrow \langle \text{Load}(slot, T), v \rangle$$

$$\text{LEValue}(bytes) = \sum_{i=0}^{|bytes|-1} bytes[i] \cdot 256^i$$
$$\text{ByteInt}(bytes) = i\{8|bytes|\}\ \text{LEValue}(bytes)$$

$$\text{AllZero}(bytes) \iff \forall b \in bytes.\ b = 0x00$$
$$\text{ByteArray}(bytes) = \text{LLVMArrayConst}(|bytes|, i8, bytes)$$
$$\text{ConstBytes}(\tau, bytes) = c \iff \exists T.\ \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land |bytes| = \text{sizeof}(T) \land c = \text{ConstBytesCase}(\tau, bytes)$$
$$\text{ConstBytesCase}(\tau, bytes) =
\begin{cases}
\texttt{zeroinitializer} & |bytes| = 0\\
\text{ByteArray}(bytes) & \tau = \text{LLVMArray}(|bytes|, i8)\\
\text{ByteInt}(bytes) & \tau = i\{8|bytes|\}\\
\texttt{bitcast}(\text{ByteInt}(bytes) \text{ to } \tau) & \tau \in \{\texttt{half},\ \texttt{float},\ \texttt{double}\}\\
\texttt{null} & \tau = \text{LLVMPtrTy}(U) \land \text{AllZero}(bytes)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{LLVMGlobalZero}(sym, \tau, align) = \text{LLVMGlobalConst}(sym, \tau, \texttt{zeroinitializer}, align)$$

$$\text{LenLit}(n) = \text{IntLiteral}(\text{IntValue}=n)$$
$$\text{StaticType}(sym) =
\begin{cases}
\text{TypeArray}(\text{TypePrim}(\texttt{"u8"}), \text{LenLit}(|bytes|)) & sym = \text{Mangle}(\text{LiteralData}(kind, bytes))\\
\text{StaticBindTypes}(sym) & \text{otherwise}
\end{cases}$$
$$\text{ProcModule}(sym) = m \iff \exists item, p.\ item = \text{ProcedureDecl}(\_,\_,\_,\_,\_,\_,\_) \land \text{ItemPath}(item) = p \land sym = \text{ScopedSym}(item) \land \text{ModuleOfPath}(p) = m$$
$$\text{SigOf}(callee) =
\begin{cases}
\langle params, ret \rangle & callee = \text{Mangle}(d)\ \land d \in \{\text{ProcedureDecl}, \text{MethodDecl}, \text{DefaultImpl}\} \land \text{Sig}(d)=\langle params, ret \rangle\\
\text{RuntimeSig}(sym) & callee = sym \land \text{RuntimeSig}(sym)\ \text{defined}\\
\langle params, ret \rangle & \text{ExprType}(callee) = \text{TypeFunc}(params, ret)\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{LoweredSigOf}(callee) = \langle params', ret \rangle \iff \langle params, ret \rangle = \text{SigOf}(callee) \land params' = ( \text{NeedsPanicOut}(callee) Sigma params \mathbin{+\!\!+} [\text{PanicOutParam}] : params )$$

$$\text{ParamInitIR}(sig, params) = \mathbin{+\!\!+}_{\langle mode, x, T \rangle \in params} \text{ParamInit}(sig, params, x, mode, T)$$
$$\text{ZeroValue}(T) = \texttt{zeroinitializer} \quad\text{if } \text{sizeof}(T)=0$$
$$\text{ParamInit}(sig, params, x, mode, T) =
\begin{cases}
\text{Store}(\text{BindSlot}(x), \text{LLVMParam}(sig, params, x), T) & \text{ABIParam}(mode, T) = \texttt{ByValue} \land \text{sizeof}(T) > 0\\
\text{Store}(\text{BindSlot}(x), \text{ZeroValue}(T), T) & \text{ABIParam}(mode, T) = \texttt{ByValue} \land \text{sizeof}(T) = 0\\
\epsilon & \text{ABIParam}(mode, T) = \texttt{ByRef}
\end{cases}$$
$$\text{ParamOrder}(params) = [x_i \mid \langle mode_i, x_i, T_i \rangle \in params \land (\text{ABIParam}(mode_i, T_i)=\texttt{ByRef} \lor \text{sizeof}(T_i) > 0)]$$
$$\text{ParamIndex}(params, x) = i \iff \text{ParamOrder}(params)[i] = x$$
$$\text{LLVMArgs}(sig) = sig.\text{llvm\_params}$$
$$\text{LLVMArg}(sig, i) = \text{LLVMArgs}(sig)[i]$$
$$i' = (\text{sig}.\text{sretSigma} Sigma \text{ParamIndex}(params, x) + 1 : \text{ParamIndex}(params, x))$$
$$\text{LLVMParam}(sig, params, x) = \text{LLVMArg}(sig, i')$$

**(LowerIRDecl-Proc-User)**
$$\frac{
\text{LLVMCallSig}(params, R) \Downarrow sig \quad
\text{ProcModule}(sym) = m \quad
IR_p = \text{ParamInitIR}(sig, params) \quad
IR_0 = (\text{NeedsPanicOut}(sym) Sigma \text{SeqIR}(\text{ClearPanic}, IR) : IR) \quad
IR' = \text{SeqIR}(IR_p, \text{CheckPoison}(m), IR_0) \quad
\Gamma \vdash \text{LowerIRInstr}(IR') \Downarrow ll
}{\Gamma \vdash \text{LowerIRDecl}(\text{ProcIR}(sym, params, R, IR)) \Downarrow \text{LLVMDefine}(sym, sig, ll)}$$

**(LowerIRDecl-Proc-Gen)**
$$\frac{
\text{LLVMCallSig}(params, R) \Downarrow sig \quad
\text{ProcModule}(sym)\ \text{undefined} \quad
IR_p = \text{ParamInitIR}(sig, params) \quad
\Gamma \vdash \text{LowerIRInstr}(\text{SeqIR}(IR_p, (\text{NeedsPanicOut}(sym) Sigma \text{SeqIR}(\text{ClearPanic}, IR) : IR))) \Downarrow ll
}{\Gamma \vdash \text{LowerIRDecl}(\text{ProcIR}(sym, params, R, IR)) \Downarrow \text{LLVMDefine}(sym, sig, ll)}$$

**(LowerIRDecl-GlobalConst)**
$$\frac{
T = \text{StaticType}(sym) \quad
\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad
\text{ConstBytes}(\tau, bytes) = c
}{\Gamma \vdash \text{LowerIRDecl}(\text{GlobalConst}(sym, bytes)) \Downarrow \text{LLVMGlobalConst}(sym, \tau, c, \text{alignof}(T))}$$

**(LowerIRDecl-GlobalZero)**
$$\frac{
T = \text{StaticType}(sym) \quad
\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad
size = \text{sizeof}(T)
}{\Gamma \vdash \text{LowerIRDecl}(\text{GlobalZero}(sym, size)) \Downarrow \text{LLVMGlobalZero}(sym, \tau, \text{alignof}(T))}$$

**(LowerIRDecl-VTable)**
$$\frac{\text{GlobalVTable}(sym, header, slots) = d}{\Gamma \vdash \text{LowerIRDecl}(d) \Downarrow \text{LLVMGlobalVTable}(sym, header, slots)}$$

**(Lower-AllocIR)**
$$\frac{
\text{RegionSym}(\texttt{Region::alloc}) \Downarrow sym \quad
r = \begin{cases}
\text{InnermostActiveRegion}(\Gamma) & r_{opt} = \bot\\
r_{opt} & \text{otherwise}
\end{cases} \quad
\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(sym, [r, v])) \Downarrow ll
}{\Gamma \vdash \text{LowerIRInstr}(\text{AllocIR}(r_{opt}, v)) \Downarrow ll}$$

**(Lower-BindVarIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x}{\Gamma \vdash \text{LowerIRInstr}(\text{BindVarIR}(x, v)) \Downarrow \langle [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-ReadVarIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x \quad \Gamma \vdash \text{BindValid}(x) \Downarrow \text{Valid}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadVarIR}(x)) \Downarrow \langle [\text{Load}(slot, T_x)], v \rangle}$$

**(Lower-ReadVarIR-Err)**
$$\frac{\Gamma \vdash \text{BindValid}(x) \Downarrow s \quad s \ne \text{Valid}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadVarIR}(x)) \Uparrow}$$

$$\text{PathSym}(path, name) = \text{PathSig}(path \mathbin{+\!\!+} [name])$$
$$\text{ProcSymbol}(sym) \iff \exists item.\ item \in \{\text{ProcedureDecl}, \text{MethodDecl}, \text{ClassMethodDecl}, \text{StateMethodDecl}, \text{TransitionDecl}, \text{DefaultImpl}\} \land \Gamma \vdash \text{Mangle}(item) \Downarrow sym$$

**(Lower-ReadPathIR-Static-User)**
$$\frac{\text{StaticSymPath}(path, name) = sym \quad \text{ProcModule}(sym) = m \quad T = \text{StaticType}(sym) \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p \mathbin{+\!\!+} [\text{Load}(@sym, T)], v \rangle}$$

**(Lower-ReadPathIR-Static-Gen)**
$$\frac{\text{StaticSymPath}(path, name) = sym \quad \text{ProcModule}(sym)\ \text{undefined} \quad T = \text{StaticType}(sym)}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle [\text{Load}(@sym, T)], v \rangle}$$

**(Lower-ReadPathIR-Proc-User)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{ProcSymbol}(sym) \quad \text{ProcModule}(sym) = m \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p, sym \rangle}$$

**(Lower-ReadPathIR-Proc-Gen)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{ProcSymbol}(sym) \quad \text{ProcModule}(sym)\ \text{undefined}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle \epsilon, sym \rangle}$$

**(Lower-ReadPathIR-Runtime)**
$$\frac{sym = \text{PathSym}(path, name) \quad \text{RuntimeSig}(sym)\ \text{defined}}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle \epsilon, sym \rangle}$$

**(Lower-ReadPathIR-Record)**
$$\frac{p = path \mathbin{+\!\!+} [name] \quad \text{RecordDecl}(p) = R \quad \text{ModuleOfPath}(p) = m \quad \Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow \langle I_p, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPathIR}(path, name)) \Downarrow \langle I_p, \text{RecordCtor}(p) \rangle}$$

**(Lower-StoreVarIR)**
$$\frac{
\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad
\text{TypeOf}(x) = T_x \quad
\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow IR_d
}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreVarIR}(x, v)) \Downarrow \langle IR_d \mathbin{+\!\!+} [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-StoreVarNoDropIR)**
$$\frac{\Gamma \vdash \text{BindSlot}(x) \Downarrow slot \quad \text{TypeOf}(x) = T_x}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreVarNoDropIR}(x, v)) \Downarrow \langle [\text{Store}(slot, v, T_x)], \bot \rangle}$$

**(Lower-MoveStateIR)**
$$\frac{x = \text{PlaceRoot}(p) \quad \Gamma \vdash \text{UpdateValid}(x, \text{MoveStateIR}(p)) \Downarrow v'}{\Gamma \vdash \text{LowerIRInstr}(\text{MoveStateIR}(p)) \Downarrow \langle \epsilon, \bot \rangle}$$

**(Lower-StoreGlobal)**
$$\frac{T = \text{StaticType}(sym) \quad \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LowerIRInstr}(\text{StoreGlobal}(sym, v)) \Downarrow \langle [\text{Store}(@sym, v, T)], \bot \rangle}$$

**(Lower-ReadPlaceIR)**
$$\frac{\Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR_p, v \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPlaceIR}(p)) \Downarrow ll}$$

**(Lower-WritePlaceIR)**
$$\frac{\Gamma \vdash \text{LowerWritePlace}(p, v) \Downarrow IR_w \quad \Gamma \vdash \text{LowerIRInstr}(IR_w) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePlaceIR}(p, v)) \Downarrow ll}$$

$$\text{PtrType}(v) = T \iff (\exists e, IR.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \land T = \text{ExprType}(e)) \lor (\exists p, IR.\ \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR, v \rangle \land T = \text{ExprType}(p))$$
$$\text{ValueType}(v) = \text{TypePrim}(\texttt{"bool"}) \iff \exists b.\ v=\text{BoolVal}(b)$$
$$\text{ValueType}(v) = \text{TypePrim}(\texttt{"char"}) \iff \exists u.\ v=\text{CharVal}(u)$$
$$\text{ValueType}(\text{UnitVal}) = \text{TypePrim}(\texttt{"()"})$$
$$\text{ValueType}(\text{IntVal}(t, x)) = \text{TypePrim}(t)$$
$$\text{ValueType}(\text{FloatVal}(t, v)) = \text{TypePrim}(t)$$
$$\text{ValueType}(\text{PtrVal}(s, addr)) = \text{TypePtr}(T, s) \iff T \in \text{Type}$$
$$\text{ValueType}(\text{RawPtr}(q, addr)) = \text{TypeRawPtr}(q, T) \iff T \in \text{Type}$$
$$\text{ValueType}((v_1,\ldots,v_n)) = \text{TypeTuple}([T_1,\ldots,T_n]) \iff \forall i.\ \text{ValueType}(v_i) = T_i$$
$$\text{ValueType}([v_1,\ldots,v_n]) = \text{TypeArray}(T, \text{Literal}(\text{IntLiteral}(n))) \iff \forall i.\ \text{ValueType}(v_i) = T$$
$$\text{ValueType}(\text{SliceValue}(v, r)) = \text{TypeSlice}(T) \iff \text{ValueType}(v) = \text{TypeArray}(T,\_) \lor \text{ValueType}(v) = \text{TypeSlice}(T)$$
$$\text{ValueType}(\text{RecordValue}(\text{TypePath}(p), fs)) = \text{TypePath}(p)$$
$$\text{ValueType}(\text{RecordValue}(\text{ModalStateRef}(p, S), fs)) = \text{TypeModalState}(p, S)$$
$$\text{ValueType}(\text{EnumValue}(path, payload)) = \text{TypePath}(p) \iff \text{EnumPath}(path) = p$$
$$\text{ValueType}(\text{RangeVal}(k, lo, hi)) = \text{TypeRange}$$
$$\text{ValueType}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)) = \text{TypeDynamic}(Cl)$$
$$\text{ValueType}(v) = \text{TypeString}(\texttt{@View}) \iff v \in \texttt{string@View}$$
$$\text{ValueType}(v) = \text{TypeString}(\texttt{@Managed}) \iff v \in \texttt{string@Managed}$$
$$\text{ValueType}(v) = \text{TypeBytes}(\texttt{@View}) \iff v \in \texttt{bytes@View}$$
$$\text{ValueType}(v) = \text{TypeBytes}(\texttt{@Managed}) \iff v \in \texttt{bytes@Managed}$$
$$\text{ValueType}(v) = \text{TypeString}(\bot) \iff \text{ValueType}(v) = \text{TypeString}(\texttt{@View}) \lor \text{ValueType}(v) = \text{TypeString}(\texttt{@Managed})$$
$$\text{ValueType}(v) = \text{TypeBytes}(\bot) \iff \text{ValueType}(v) = \text{TypeBytes}(\texttt{@View}) \lor \text{ValueType}(v) = \text{TypeBytes}(\texttt{@Managed})$$
$$\text{ValueType}(v) = \text{TypePath}(p) \iff \exists S, M.\ \text{ValueType}(v) = \text{TypeModalState}(p, S) \land \Sigma.\text{Types}[p] = \texttt{modal } M \land S \in \text{States}(M)$$
$$\text{ValueType}(v) = U \iff \exists T.\ \text{ValueType}(v) = T \land \text{Member}(T, U)$$

**(Lower-ReadPtrIR)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPtrIR}(v_{ptr})) \Downarrow \langle [\text{Load}(\text{PtrAddr}(v_{ptr}), T)], v \rangle}$$

**(Lower-ReadPtrIR-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(q, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{ReadPtrIR}(v_{ptr})) \Downarrow \langle [\text{Load}(\text{PtrAddr}(v_{ptr}), T)], v \rangle}$$

**(Lower-WritePtrIR)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Valid})}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow \langle [\text{Store}(\text{PtrAddr}(v_{ptr}), v, T)], \bot \rangle}$$

**(Lower-WritePtrIR-Null)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Null}) \quad \Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(\text{NullDeref})) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow ll}$$

**(Lower-WritePtrIR-Expired)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypePtr}(T, \texttt{Expired}) \quad \Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(\text{ExpiredDeref})) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow ll}$$

**(Lower-WritePtrIR-Raw)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(\texttt{mut}, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Downarrow \langle [\text{Store}(\text{PtrAddr}(v_{ptr}), v, T)], \bot \rangle}$$

**(Lower-WritePtrIR-Raw-Err)**
$$\frac{\text{PtrType}(v_{ptr}) = \text{TypeRawPtr}(\texttt{imm}, T)}{\Gamma \vdash \text{LowerIRInstr}(\text{WritePtrIR}(v_{ptr}, v)) \Uparrow}$$

**(Lower-AddrOfIR)**
$$\frac{\Gamma \vdash \text{LowerAddrOf}(p) \Downarrow \langle IR_p, addr \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{AddrOfIR}(p)) \Downarrow ll}$$

**(Lower-CallIR-RecordCtor)**
$$\frac{\text{CallTarget}(callee) = \text{RecordCtor}(p) \quad args = [] \quad \text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{LowerFieldInits}(fields) \Downarrow \langle IR_f, \vec{f} \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(callee, args)) \Downarrow \langle IR_f, \text{RecordValue}(\text{TypePath}(p), \vec{f}) \rangle}$$

$$\text{CallPoison}(f) =
\begin{cases}
\text{CheckPoison}(m) & \text{ProcModule}(f)=m\\
\epsilon & \text{ProcModule}(f)\ \text{undefined}
\end{cases}$$

$$\text{SRetAlloc}(R) \Downarrow \langle [\texttt{alloca}\ \text{LLVMTy}(R)], p \rangle$$

$$\text{CallArgs}(sig, params, args, R) \Downarrow \langle I_a, \vec{a}, p_{ret} \rangle \iff
\begin{cases}
I_a = \epsilon \land \vec{a} = args \land p_{ret} = \bot & sig.\text{sretSigma} = \text{false}\\
\exists p.\ \text{SRetAlloc}(R) \Downarrow \langle I_s, p \rangle \land I_a = I_s \land \vec{a} = [p] \mathbin{+\!\!+} args \land p_{ret} = p & sig.\text{sretSigma} = \text{true}
\end{cases}$$

$$\text{CallInstr}(sig, f, \vec{a}) \Downarrow \langle [\texttt{call}\ sig\ f(\vec{a})], v_c \rangle \iff
v_c = (\text{sig}.\text{llvm\_ret} = \texttt{void} Sigma \bot : \text{call\_result})$$

$$\text{CallResult}(sig, R, p_{ret}, v_c) \Downarrow \langle I_r, v \rangle \iff
\begin{cases}
I_r = \epsilon \land v = v_c & sig.\text{sretSigma} = \text{false}\\
\text{LoadVal}(p_{ret}, R) \Downarrow \langle I_r, v \rangle & sig.\text{sretSigma} = \text{true}
\end{cases}$$

**(Lower-CallIR-Func)**
$$\frac{
\text{CallTarget}(callee) = f \quad
\text{LoweredSigOf}(f) = \langle params, ret \rangle \quad
\text{LLVMCallSig}(params, ret) \Downarrow sig \quad
\text{CallPoison}(f) = IR_p \quad
\Gamma \vdash \text{LowerIRInstr}(IR_p) \Downarrow \langle I_p, \bot \rangle \quad
\text{CallArgs}(sig, params, args, ret) \Downarrow \langle I_a, \vec{a}, p_{ret} \rangle \quad
\text{CallInstr}(sig, f, \vec{a}) \Downarrow \langle I_c, v_c \rangle \quad
\text{CallResult}(sig, ret, p_{ret}, v_c) \Downarrow \langle I_r, v_{\text{call}} \rangle
}{\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(callee, args)) \Downarrow \langle I_p \mathbin{+\!\!+} I_a \mathbin{+\!\!+} I_c \mathbin{+\!\!+} I_r, v_{\text{call}} \rangle}$$

$$\text{DynType}(v) = \text{TypeDynamic}(Cl) \iff (\exists e, IR.\ \Gamma \vdash \text{LowerExpr}(e) \Downarrow \langle IR, v \rangle \land \text{ExprType}(e)=\text{TypeDynamic}(Cl)) \lor (\exists p, IR.\ \Gamma \vdash \text{LowerReadPlace}(p) \Downarrow \langle IR, v \rangle \land \text{ExprType}(p)=\text{TypeDynamic}(Cl))$$
$$\text{DynData}(v) = \text{FieldValue}(v, \texttt{data}) \quad\text{and}\quad \text{DynVTable}(v) = \text{FieldValue}(v, \texttt{vtable})$$
$$\text{VTableSlotIndex}(i) = i + 3$$
$$\text{GEP}(ptr, [i_0,\ldots,i_k]) = v_{gep}$$
$$\text{VTableSlotAddr}(vt, i) = \text{GEP}(vt, [0,\ \text{VTableSlotIndex}(i)])$$
$$\text{VTableSlot}(vt, i) = \text{Load}(\text{VTableSlotAddr}(vt, i), \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})))$$

**(Lower-CallVTable)**
$$\frac{
\text{DynType}(base) = \text{TypeDynamic}(Cl) \quad
v_d = \text{DynData}(base) \quad
v_t = \text{DynVTable}(base) \quad
v_s = \text{VTableSlot}(v_t, i) \quad
\Gamma \vdash \text{LowerIRInstr}(\text{CallIR}(v_s, [v_d] \mathbin{+\!\!+} args)) \Downarrow ll
}{\Gamma \vdash \text{LowerIRInstr}(\text{CallVTable}(base, i, args)) \Downarrow ll}$$

**(LowerIRInstr-ClearPanic)**
$$\frac{\Gamma \vdash \text{ClearPanic} \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{ClearPanic}) \Downarrow ll}$$

**(LowerIRInstr-PanicCheck)**
$$\frac{\Gamma \vdash \text{PanicCheck} \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{PanicCheck}) \Downarrow ll}$$

**(LowerIRInstr-CheckPoison)**
$$\frac{\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{CheckPoison}(m)) \Downarrow ll}$$

**(LowerIRInstr-LowerPanic)**
$$\frac{\Gamma \vdash \text{LowerPanic}(r) \Downarrow IR \quad \Gamma \vdash \text{LowerIRInstr}(IR) \Downarrow ll}{\Gamma \vdash \text{LowerIRInstr}(\text{LowerPanic}(r)) \Downarrow ll}$$

$$\text{IfPhi}(v_t, v_f, l_t, l_f) \Downarrow \langle I_\phi, v_\phi \rangle \iff
\begin{cases}
I_\phi = \epsilon \land v_\phi = \bot & v_t=\bot \lor v_f=\bot\\
\exists T,\tau,inc.\ \text{ValueType}(v_t)=T \land \text{ValueType}(v_f)=T \land \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land inc = [\langle v_t, l_t \rangle,\ \langle v_f, l_f \rangle] \land I_\phi = [\text{Phi}(\tau, inc, v_\phi)] & v_t\ne\bot \land v_f\ne\bot
\end{cases}$$

$$\text{IfLowerForm}(I, v_c, v_t, v_f, v) \iff \text{HasBrCond}(I, v_c) \land ((v_t=\bot \lor v_f=\bot) \Rightarrow v=\bot) \land ((v_t\ne\bot \land v_f\ne\bot) \Rightarrow \text{HasPhi}(I, v))$$

**(Lower-IfIR)**
$$\frac{\text{IfLabels}(\Gamma) = \langle l_t,l_f,l_m \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_t) \Downarrow \langle I_t, v_t' \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_f) \Downarrow \langle I_f, v_f' \rangle \quad v_t'=v_t \quad v_f'=v_f \quad \text{IfPhi}(v_t, v_f, l_t, l_f) \Downarrow \langle I_\phi, v \rangle \quad I = [\text{BrCond}(v_c, l_t, l_f),\ \text{Label}(l_t)] \mathbin{+\!\!+} I_t \mathbin{+\!\!+} [\text{Br}(l_m),\ \text{Label}(l_f)] \mathbin{+\!\!+} I_f \mathbin{+\!\!+} [\text{Br}(l_m),\ \text{Label}(l_m)] \mathbin{+\!\!+} I_\phi \quad \text{IfLowerForm}(I, v_c, v_t, v_f, v)}{\Gamma \vdash \text{LowerIRInstr}(\text{IfIR}(v_c, IR_t, v_t, IR_f, v_f)) \Downarrow \langle I, v \rangle}$$

$$\text{BlockScope}(IR_s, IR_t) = scope$$
$$\text{BlockScope}(IR_s, IR_t) = scope \iff \left(\exists \sigma,\sigma_1,\sigma_2,out,scope_0.\ \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope_0) \land \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2)\right) \land \left(\forall \sigma,\sigma_1,\sigma_2,out,scope_0.\ \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope_0) \land \text{ExecBlockBodyIRSigma}(IR_s, IR_t, \sigma_1) \Downarrow (out, \sigma_2) \Rightarrow \text{CurrentScope}(\sigma_2) = scope\right)$$
$$\text{EmitCleanupSpec}(cs, IR) \iff \forall \sigma,\ \Gamma \vdash \text{Cleanup}(cs, \sigma) \Downarrow (c, \sigma') \Rightarrow (\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land ((c=\text{panic}) \Rightarrow out=\text{Ctrl}(\text{Panic})) \land ((c=\text{ok}) \Rightarrow out=\text{Val}(())))$$
$$\Gamma \vdash \text{EmitCleanup}(cs) \Downarrow IR \iff \text{EmitCleanupSpec}(cs, IR)$$

**(Lower-BlockIR)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(IR_s) \Downarrow \langle I_s, \bot \rangle \quad \Gamma \vdash \text{LowerIRInstr}(IR_t) \Downarrow \langle I_t, v_t' \rangle \quad v_t'=v_t \quad \text{BlockScope}(IR_s, IR_t) = scope \quad \Gamma \vdash \text{CleanupPlan}(scope) \Downarrow cs \quad \Gamma \vdash \text{EmitCleanup}(cs) \Downarrow IR_c \quad \Gamma \vdash \text{LowerIRInstr}(IR_c) \Downarrow \langle I_c, \bot \rangle}{\Gamma \vdash \text{LowerIRInstr}(\text{BlockIR}(IR_s, IR_t, v_t)) \Downarrow \langle I_s \mathbin{+\!\!+} I_t \mathbin{+\!\!+} I_c, v_t \rangle}$$

$$\text{LoopLowerForm}(I, loop, v)\ \text{predicate}$$
$$\text{LoopIRForm}(loop)\ \text{predicate}$$
$$\text{MatchLowerForm}(I, match, v)\ \text{predicate}$$
$$\text{MatchIRForm}(match)\ \text{predicate}$$
$$\text{RegionLowerForm}(I, region, v)\ \text{predicate}$$
$$\text{RegionIRForm}(region)\ \text{predicate}$$
$$\text{FrameLowerForm}(I, frame, v)\ \text{predicate}$$
$$\text{FrameIRForm}(frame)\ \text{predicate}$$
$$\text{LoopLowerForm}(I, loop, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{MatchLowerForm}(I, match, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{RegionLowerForm}(I, region, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{FrameLowerForm}(I, frame, v) \iff \langle I, v \rangle \in \text{LLResult}$$
$$\text{LoopIRForm}(loop) \iff (\exists IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopInfinite}, IR_b, v_b)) \lor (\exists IR_c, v_c, IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopConditional}, IR_c, v_c, IR_b, v_b)) \lor (\exists pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b.\ loop = \text{LoopIR}(\text{LoopIter}, pat, ty\_opt, IR_i, v_{\text{iter}}, IR_b, v_b))$$
$$\text{MatchIRForm}(match) \iff \exists v_s, arms.\ match = \text{MatchIR}(v_s, arms)$$
$$\text{RegionIRForm}(region) \iff \exists v_o, alias\_opt, IR_b, v_b.\ region = \text{RegionIR}(v_o, alias\_opt, IR_b, v_b)$$
$$\text{FrameIRForm}(frame) \iff \exists v_r, IR_b, v_b.\ frame = \text{FrameIR}(v_r, IR_b, v_b)$$

**(Lower-LoopIR)**
$$\frac{\text{LoopIRForm}(loop) \quad \text{LoopLowerForm}(I, loop, v)}{\Gamma \vdash \text{LowerIRInstr}(loop) \Downarrow \langle I, v \rangle}$$

**(Lower-MatchIR)**
$$\frac{\text{MatchIRForm}(match) \quad \text{MatchLowerForm}(I, match, v)}{\Gamma \vdash \text{LowerIRInstr}(match) \Downarrow \langle I, v \rangle}$$

**(Lower-RegionIR)**
$$\frac{\text{RegionIRForm}(region) \quad \text{RegionLowerForm}(I, region, v)}{\Gamma \vdash \text{LowerIRInstr}(region) \Downarrow \langle I, v \rangle}$$

**(Lower-FrameIR)**
$$\frac{\text{FrameIRForm}(frame) \quad \text{FrameLowerForm}(I, frame, v)}{\Gamma \vdash \text{LowerIRInstr}(frame) \Downarrow \langle I, v \rangle}$$

$$\text{BranchLowerForm}(I, target) \iff \text{Br}(target) \in I$$
$$\text{BranchLowerForm}(I, v_c, t, f) \iff \text{BrCond}(v_c, t, f) \in I$$

**(Lower-BranchIR)**
$$\frac{\text{BranchLowerForm}(I, target)}{\Gamma \vdash \text{LowerIRInstr}(\text{BranchIR}(target)) \Downarrow \langle I, \bot \rangle}$$
$$\frac{\text{BranchLowerForm}(I, v_c, t, f)}{\Gamma \vdash \text{LowerIRInstr}(\text{BranchIR}(v_c, t, f)) \Downarrow \langle I, \bot \rangle}$$

$$\text{PhiLowerForm}(I, T, inc, v) \iff \Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \land I = [\text{Phi}(\tau, inc, v)]$$

**(Lower-PhiIR)**
$$\frac{\text{PhiLowerForm}(I, T, inc, v)}{\Gamma \vdash \text{LowerIRInstr}(\text{PhiIR}(T, inc, v)) \Downarrow \langle I, v \rangle}$$

**(LowerIRDecl-Err)**
$$\frac{\Gamma \vdash \text{LowerIRDecl}(d) \Uparrow}{\Gamma \vdash \text{LowerIRDecl}(d) \Uparrow}$$

**(LowerIRInstr-Err)**
$$\frac{\Gamma \vdash \text{LowerIRInstr}(op) \Uparrow}{\Gamma \vdash \text{LowerIRInstr}(op) \Uparrow}$$

#### 6.12.11. Binding Storage and Validity

$$\text{BindStorageJudg} = \{\text{BindSlot}(x) \Downarrow slot,\ \text{BindValid}(x) \Downarrow v,\ \text{UpdateValid}(x, op) \Downarrow v',\ \text{DropOnAssign}(x, slot) \Downarrow IR\}$$
$$\text{TypeOf}(x) = T \iff \Gamma; R; L \vdash \text{Identifier}(x) : T$$
$$\text{BindInfo}(x) = info \iff \text{BindState}(\Gamma) = \mathcal{B} \land \text{Lookup}_B(\mathcal{B}, x) = info$$

$$\text{ProcParams}(\Gamma) = params \iff \Gamma\ \text{is lowering}\ \text{ProcIR}(\_, params, \_, \_)$$
$$\text{ProcRet}(\Gamma) = R \iff \Gamma\ \text{is lowering}\ \text{ProcIR}(\_, \_, R, \_)$$
$$\text{ProcSig}(\Gamma) = sig \iff \Gamma \vdash \text{LLVMCallSig}(\text{ProcParams}(\Gamma), \text{ProcRet}(\Gamma)) \Downarrow sig$$
$$\text{ParamEntry}(params, x) = \langle mode, T \rangle \iff \langle mode, x, T \rangle \in params$$
$$\text{AllocaSlot}(T) = \text{LLVMAlloca}(\text{LLVMTy}(T))$$
$$\text{BindState}(\Gamma) = \Gamma.\text{bind\_state}$$

**(BindValid-Sigma)**
$$\frac{\text{BindState}(\Gamma) = \mathcal{B} \quad \text{Lookup}_B(\mathcal{B}, x) = \langle s,\_,\_,\_ \rangle}{\Gamma \vdash \text{BindValid}(x) \Downarrow s}$$

**(BindSlot-Param-ByValue)**
$$\frac{\text{ProcParams}(\Gamma) = params \quad \text{ParamEntry}(params, x) = \langle mode, T \rangle \quad \Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByValue}}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{AllocaSlot}(T)}$$

**(BindSlot-Param-ByRef)**
$$\frac{\text{ProcParams}(\Gamma) = params \quad \text{ParamEntry}(params, x) = \langle mode, T \rangle \quad \Gamma \vdash \text{ABIParam}(mode, T) \Downarrow \texttt{ByRef} \quad \text{ProcSig}(\Gamma) = sig}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{LLVMParam}(sig, params, x)}$$

**(BindSlot-Local)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = \bot \quad \text{ParamEntry}(\text{ProcParams}(\Gamma), x)\ \text{undefined}}{\Gamma \vdash \text{BindSlot}(x) \Downarrow \text{AllocaSlot}(\text{TypeOf}(x))}$$

**(BindSlot-Static)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticSymPath}(path, name) = sym}{\Gamma \vdash \text{BindSlot}(x) \Downarrow @sym}$$

**(UpdateValid-BindVar)**
$$\frac{}{\Gamma \vdash \text{UpdateValid}(x, \text{BindVarIR}(x, v)) \Downarrow \text{Valid}}$$

**(UpdateValid-StoreVar)**
$$\frac{}{\Gamma \vdash \text{UpdateValid}(x, \text{StoreVarIR}(x, v)) \Downarrow \text{Valid}}$$

**(UpdateValid-StoreVarNoDrop)**
$$\frac{\Gamma \vdash \text{BindValid}(x) \Downarrow s}{\Gamma \vdash \text{UpdateValid}(x, \text{StoreVarNoDropIR}(x, v)) \Downarrow s}$$

**(UpdateValid-MoveRoot)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = \bot}{\Gamma \vdash \text{UpdateValid}(x, op) \Downarrow \text{Moved}}$$

**(UpdateValid-PartialMove-Init)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{BindValid}(x) \Downarrow \text{Valid}}{\text{UpdateValid}(x, op) \Downarrow \text{PartiallyMoved}(\{f\})}$$

**(UpdateValid-PartialMove-Step)**
$$\frac{op = \text{MoveStateIR}(p) \quad \text{PlaceRoot}(p) = x \quad \text{FieldHead}(p) = f \quad \text{BindValid}(x) \Downarrow \text{PartiallyMoved}(F)}{\text{UpdateValid}(x, op) \Downarrow \text{PartiallyMoved}(F \cup \{f\})}$$

$$\text{DropOnAssignApplicable}(x) \iff \text{BindInfo}(x).\text{mov} = \text{immov} \land \text{BindInfo}(x).\text{resp} = \text{resp}$$
$$\text{AddrAdd}(addr, n) = addr + n$$
$$\text{ElemType}(T_b) = T \iff \text{StripPerm}(T_b) = \text{TypeArray}(T, \_) \lor \text{StripPerm}(T_b) = \text{TypeSlice}(T)$$
$$\text{FieldAddr}(T, addr, f) = \text{AddrAdd}(addr, \text{FieldOffset}(\text{Fields}(R), f)) \quad\text{when } \text{StripPerm}(T)=\text{TypePath}(p)\ \text{and } \text{RecordDecl}(p)=R$$
$$\text{TupleAddr}(T, addr, i) = \text{AddrAdd}(addr, \text{FieldOffset}(\text{TupleFields}([T_1,\ldots,T_n]), i)) \quad\text{when } \text{StripPerm}(T)=\text{TypeTuple}([T_1,\ldots,T_n])$$

**(DropOnAssign-NotApplicable)**
$$\frac{\neg \text{DropOnAssignApplicable}(x)}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

$$\text{FieldsRev}(R) = \text{rev}(\text{Fields}(R))$$
$$\text{FieldDropIR}(slot, p, f, T) = \text{EmitDrop}(T, \text{Load}(\text{FieldAddr}(\text{TypePath}(p), slot, f), T))$$
$$\text{FieldDropSeq}(slot, p, F) = \mathbin{+\!\!+}_{\langle f_i, T_i \rangle \in \text{FieldsRev}(\text{RecordDecl}(p)),\ f_i \notin F}\ \text{FieldDropIR}(slot, p, f_i, T_i)$$

**(DropOnAssign-Record-Valid)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{Valid}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{EmitDrop}(\text{TypePath}(p), \text{Load}(slot, \text{TypePath}(p)))}$$

**(DropOnAssign-Record-Partial)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{PartiallyMoved}(F)}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{FieldDropSeq}(slot, p, F)}$$

**(DropOnAssign-Record-Moved)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) = \text{TypePath}(p) \quad \text{RecordDecl}(p)=R \quad \text{BindValid}(x) \Downarrow \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

**(DropOnAssign-Aggregate-Ok)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) \in \{\text{TypeArray}(\_,\_),\ \text{TypeTuple}(\_),\ \text{TypeUnion}(\_),\ \text{TypeModalState}(\_,\_)\} \quad \text{BindValid}(x) \Downarrow s \quad s \ne \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \text{EmitDrop}(\text{TypeOf}(x), \text{Load}(slot, \text{TypeOf}(x)))}$$

**(DropOnAssign-Aggregate-Moved)**
$$\frac{\text{DropOnAssignApplicable}(x) \quad TypeOf(x) \in \{\text{TypeArray}(\_,\_),\ \text{TypeTuple}(\_),\ \text{TypeUnion}(\_),\ \text{TypeModalState}(\_,\_)\} \quad \text{BindValid}(x) \Downarrow \text{Moved}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Downarrow \epsilon}$$

**(BindSlot-Err)**
$$\frac{\text{BindSlot}(x)\ \text{undefined}}{\Gamma \vdash \text{BindSlot}(x) \Uparrow}$$

**(BindValid-Err)**
$$\frac{\text{BindValid}(x)\ \text{undefined}}{\Gamma \vdash \text{BindValid}(x) \Uparrow}$$

**(UpdateValid-Err)**
$$\frac{\text{UpdateValid}(x, op)\ \text{undefined}}{\Gamma \vdash \text{UpdateValid}(x, op) \Uparrow}$$

**(DropOnAssign-Err)**
$$\frac{\text{DropOnAssign}(x, slot)\ \text{undefined}}{\Gamma \vdash \text{DropOnAssign}(x, slot) \Uparrow}$$

#### 6.12.12. Call ABI Mapping

$$\text{LLVMCallJudg} = \{\text{LLVMCallSig}(params, ret) \Downarrow sig,\ \text{LLVMArgLower}(x, T, k) \Downarrow ll,\ \text{LLVMRetLower}(T, k) \Downarrow ll\}$$

$$\text{SigLLVMParams}(sig) = llvm\_params$$
$$\text{SigLLVMRet}(sig) = llvm\_ret$$
$$\text{SigLLVMAttrs}(sig) = attrs$$
$$\text{SigSRet}(sig) = sretSigma$$

**(LLVMArgLower-ByValue-PtrValid)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{StripPerm}(T) = \text{TypePtr}(U, \texttt{Valid})}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByValue}) \Downarrow \langle \tau, \text{LLVMArgAttrsExt}(x, T) \cup \text{LLVMPtrAttrs}(T) \rangle}$$

**(LLVMArgLower-ByValue-Other)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{StripPerm}(T) \ne \text{TypePtr}(\_, \texttt{Valid})}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByValue}) \Downarrow \langle \tau, \text{LLVMArgAttrsExt}(x, T) \rangle}$$

**(LLVMArgLower-ByRef)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMArgLower}(x, T, \texttt{ByRef}) \Downarrow \langle \text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, T), \texttt{Valid})), \text{LLVMPtrAttrs}(\text{TypePtr}(\text{TypePerm}(\texttt{const}, T), \texttt{Valid})) \cup \text{LLVMArgAttrsExt}(x, T) \rangle}$$

**(LLVMRetLower-ByValue-ZST)**
$$\frac{\text{sizeof}(T)=0}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{ByValue}) \Downarrow \texttt{void}}$$

**(LLVMRetLower-ByValue)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau \quad \text{sizeof}(T)>0}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{ByValue}) \Downarrow \tau}$$

**(LLVMRetLower-SRet)**
$$\frac{\Gamma \vdash \text{LLVMTy}(T) \Downarrow \tau}{\Gamma \vdash \text{LLVMRetLower}(T, \texttt{SRet}) \Downarrow \texttt{void}}$$

$$\text{ArgInclude}(k, T) \iff (k = \texttt{ByRef}) \lor (k = \texttt{ByValue} \land \text{sizeof}(T) > 0)$$
$$\text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]) = [\tau_i \mid \text{ArgInclude}(k_i, T_i) \land \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle]$$
$$\text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]) = [A_i \mid \text{ArgInclude}(k_i, T_i) \land \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle]$$

**(LLVMCall-ByValue)**
$$\frac{\langle [k_1,\ldots,k_n], k_r, sretSigma \rangle = \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad k_r = \texttt{ByValue} \quad \forall i,\ \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle \quad \Gamma \vdash \text{LLVMRetLower}(R, \texttt{ByValue}) \Downarrow \tau_r}{\Gamma \vdash \text{LLVMCallSig}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle], R) \Downarrow \langle \text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \tau_r, \text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \text{false} \rangle}$$

**(LLVMCall-SRet)**
$$\frac{\langle [k_1,\ldots,k_n], k_r, sretSigma \rangle = \text{ABICall}([\langle m_1, T_1 \rangle,\ldots,\langle m_n, T_n \rangle], R) \quad k_r = \texttt{SRet} \quad sret\_param = \text{LLVMPtrTy}(\text{TypePtr}(\text{TypePerm}(\texttt{unique}, R), \texttt{Valid})) \quad A_{\text{sret}} = \{ \texttt{sret}, \texttt{noalias} \} \cup \text{LLVMPtrAttrs}(\text{TypePtr}(\text{TypePerm}(\texttt{unique}, R), \texttt{Valid})) \quad \forall i,\ \Gamma \vdash \text{LLVMArgLower}(x_i, T_i, k_i) \Downarrow \langle \tau_i, A_i \rangle \quad \Gamma \vdash \text{LLVMRetLower}(R, \texttt{SRet}) \Downarrow \texttt{void}}{\Gamma \vdash \text{LLVMCallSig}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle], R) \Downarrow \langle [sret\_param] \mathbin{+\!\!+} \text{LLVMArgList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \texttt{void}, [A_{\text{sret}}] \mathbin{+\!\!+} \text{LLVMAttrList}([\langle m_1,x_1,T_1\rangle,\ldots,\langle m_n,x_n,T_n\rangle],[k_1,\ldots,k_n]), \text{true} \rangle}$$

$$\text{ByRefAccess}(T) =
\begin{cases}
\texttt{rw} & \text{PermOf}(T)=\texttt{unique}\\
\texttt{ro} & \text{otherwise}
\end{cases}$$

**(LLVMArgLower-Err)**
$$\frac{\text{LLVMArgLower}(x, T, k)\ \text{undefined}}{\Gamma \vdash \text{LLVMArgLower}(x, T, k) \Uparrow}$$

**(LLVMRetLower-Err)**
$$\frac{\text{LLVMRetLower}(T, k)\ \text{undefined}}{\Gamma \vdash \text{LLVMRetLower}(T, k) \Uparrow}$$

**(LLVMCall-Err)**
$$\frac{\text{LLVMCallSig}(params, ret)\ \text{undefined}}{\Gamma \vdash \text{LLVMCallSig}(params, ret) \Uparrow}$$

#### 6.12.13. VTable Emission

$$\text{VTableJudg} = \{\text{EmitVTable}(T, Cl) \Downarrow IRDecl,\ \text{EmitDropGlue}(T) \Downarrow IRDecl,\ \text{DropGlueSym}(T) \Downarrow sym\}$$

$$\text{DropGlueSym}(T) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"drop"}] \mathbin{+\!\!+} \text{PathOfType}(T))$$
$$\text{VTableHeader}(T) = [\text{sizeof}(T),\ \text{alignof}(T),\ \text{DropGlueSym}(T)]$$
$$\text{PtrTy} = \text{LLVMPtrTy}(\text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})))$$
$$k = |\text{VTable}(T,Cl)|$$
$$\text{VTableTy}(Cl) = \text{LLVMStruct}([\text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})),\ \text{LLVMTy}(\text{TypePrim}(\texttt{"usize"})),\ \text{PtrTy}] \mathbin{+\!\!+} [\text{PtrTy}]^k)$$
$$\text{GlobalVTable} : \text{Symbol} \times \text{Header} \times \text{Slots} \to \text{IRDecl}$$
$$\text{LLVMGlobalVTable} : \text{Symbol} \times \text{Header} \times \text{Slots} \to \text{LLVMDecl}$$

**(EmitVTable-Decl)**
$$\frac{\text{Mangle}(\text{VTableDecl}(T, Cl)) \Downarrow sym}{\Gamma \vdash \text{EmitVTable}(T, Cl) \Downarrow \text{GlobalVTable}(sym, \text{VTableHeader}(T), \text{VTable}(T, Cl))}$$

$$\text{VTableSlots}(T, Cl) = [\text{DispatchSym}(T, Cl, m.\text{name}) \mid m \in \text{VTableEligible}(Cl)]$$

$$\text{DropGlueSpec}(T, IR) \iff \forall \sigma, addr, v.\ \text{LookupVal}(\sigma, \texttt{"data"}) = \text{RawPtr}(\texttt{imm}, addr) \land \text{ReadAddr}(\sigma, addr) = v \Rightarrow (\text{ExecIRSigma}(IR, \sigma) \Downarrow (out, \sigma') \land \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow \sigma')$$
$$\Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR \iff \text{DropGlueSpec}(T, IR)$$

**(EmitDropGlue-Decl)**
$$\frac{\Gamma \vdash \text{DropGlueSym}(T) \Downarrow sym \quad \Gamma \vdash \text{DropGlueIR}(T) \Downarrow IR_{\text{drop}}}{\Gamma \vdash \text{EmitDropGlue}(T) \Downarrow \text{ProcIR}(sym, [\langle \texttt{move}, \texttt{data}, \text{TypeRawPtr}(\texttt{imm}, \text{TypePrim}(\texttt{"()"})) \rangle,\ \text{PanicOutParam}], \text{TypePrim}(\texttt{"()"}), IR_{\text{drop}})}$$

**(EmitVTable-Err)**
$$\frac{\text{EmitVTable}(T, Cl)\ \text{undefined}}{\Gamma \vdash \text{EmitVTable}(T, Cl) \Uparrow}$$

#### 6.12.14. Literal Data Emission

$$\text{LiteralEmitJudg} = \{\text{EmitLiteralData}(kind, bytes) \Downarrow IRDecl,\ \text{EmitStringLit}(lit) \Downarrow sym,\ \text{EmitBytesLit}(lit) \Downarrow sym\}$$

$$\text{LiteralDataSym}(kind, bytes) = \text{Mangle}(\text{LiteralData}(kind, bytes))$$
$$\text{StringBytes}(lit)\ \text{function}$$
$$\text{EscapeBytes}(e) =
\begin{cases}
\text{EscapeValue}(e) & e = \texttt{"\\u\{"}h_1\ldots h_n\texttt{"\}"}\\
[\text{EscapeValue}(e)] & \text{otherwise}
\end{cases}$$
$$\text{StringBytesFrom}(T, p, q) =
\begin{cases}
[] & p = q\\
\text{EscapeBytes}(\text{Lexeme}(T,p,r)) \mathbin{+\!\!+} \text{StringBytesFrom}(T,r,q) & p < q \land T[p]=\texttt{"\\"} \land \text{EscapeMatch}(T,p,r)\\
\text{EncodeUTF8}(T[p]) \mathbin{+\!\!+} \text{StringBytesFrom}(T,p+1,q) & p < q \land T[p]\ne\texttt{"\\"}
\end{cases}$$
$$\text{StringBytes}(lit) = bytes \iff lit.\text{kind} = \text{StringLiteral} \land T=\text{Lexeme}(lit) \land \text{StringBytesFrom}(T, 1, |T|-1) = bytes$$
$$\text{RawBytes}(lit) = bytes \iff lit.\text{kind} = \text{BytesLiteral} \land lit.\text{payload} = bytes$$
$$\text{RawBytes}(lit) = \text{StringBytes}(lit) \iff lit.\text{kind} = \text{StringLiteral}$$

**(EmitLiteralData-Decl)**
$$\frac{\Gamma \vdash \text{Mangle}(\text{LiteralData}(kind, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitLiteralData}(kind, bytes) \Downarrow \text{GlobalConst}(sym, bytes)}$$

**(EmitLiteral-String)**
$$\frac{\text{StringBytes}(lit) = bytes \quad \Gamma \vdash \text{Mangle}(\text{LiteralData}(\texttt{"string"}, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitStringLit}(lit) \Downarrow sym}$$
$$\text{StringBytes}(lit) = bytes \Rightarrow \text{Utf8Valid}(bytes)$$

**(EmitLiteral-Bytes)**
$$\frac{\text{RawBytes}(lit) = bytes \quad \Gamma \vdash \text{Mangle}(\text{LiteralData}(\texttt{"bytes"}, bytes)) \Downarrow sym}{\Gamma \vdash \text{EmitBytesLit}(lit) \Downarrow sym}$$
$$\text{RawBytes}(lit)\ \text{undefined} \Rightarrow \text{EmitBytesLit}(lit)\ \text{undefined}$$

**(EmitLiteral-Char)**
$$\frac{T = \text{TypePrim}(\texttt{"char"}) \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"char"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"char"}, bytes)), bytes)}$$

**(EmitLiteral-Int)**
$$\frac{T = \text{TypePrim}(t) \quad t \in \text{IntTypes} \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"int"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"int"}, bytes)), bytes)}$$

**(EmitLiteral-Float)**
$$\frac{T = \text{TypePrim}(t) \quad t \in \text{FloatTypes} \quad \Gamma \vdash \text{EncodeConst}(T, lit) \Downarrow bytes}{\Gamma \vdash \text{EmitLiteralData}(\texttt{"float"}, bytes) \Downarrow \text{GlobalConst}(\text{Mangle}(\text{LiteralData}(\texttt{"float"}, bytes)), bytes)}$$

**(EmitLiteral-Err)**
$$\frac{\text{EmitLiteralData}(kind, bytes)\ \text{undefined}}{\Gamma \vdash \text{EmitLiteralData}(kind, bytes) \Uparrow}$$

#### 6.12.15. String/Bytes Built-ins

$$\text{BuiltinSymJudg} = \{\text{BuiltinSym}(method) \Downarrow sym\}$$

$$\text{StringBuiltins} = \{\texttt{string::from},\ \texttt{string::as\_view},\ \texttt{string::to\_managed},\ \texttt{string::clone\_with},\ \texttt{string::append},\ \texttt{string::length},\ \texttt{string::is\_empty}\}$$
$$\text{BytesBuiltins} = \{\texttt{bytes::with\_capacity},\ \texttt{bytes::from\_slice},\ \texttt{bytes::as\_view},\ \texttt{bytes::to\_managed},\ \texttt{bytes::view},\ \texttt{bytes::view\_string},\ \texttt{bytes::append},\ \texttt{bytes::length},\ \texttt{bytes::is\_empty}\}$$
$$\text{StringMethod}(method) \iff \exists name.\ method = \texttt{string::}name$$
$$\text{BytesMethod}(method) \iff \exists name.\ method = \texttt{bytes::}name$$

$$\text{BuiltinSym}(\texttt{string::from}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"from"}])$$
$$\text{BuiltinSym}(\texttt{string::as\_view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"as\_view"}])$$
$$\text{BuiltinSym}(\texttt{string::to\_managed}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"to\_managed"}])$$
$$\text{BuiltinSym}(\texttt{string::clone\_with}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"clone\_with"}])$$
$$\text{BuiltinSym}(\texttt{string::append}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"append"}])$$
$$\text{BuiltinSym}(\texttt{string::length}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"length"}])$$
$$\text{BuiltinSym}(\texttt{string::is\_empty}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"is\_empty"}])$$

$$\text{BuiltinSym}(\texttt{bytes::with\_capacity}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"with\_capacity"}])$$
$$\text{BuiltinSym}(\texttt{bytes::from\_slice}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"from\_slice"}])$$
$$\text{BuiltinSym}(\texttt{bytes::as\_view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"as\_view"}])$$
$$\text{BuiltinSym}(\texttt{bytes::to\_managed}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"to\_managed"}])$$
$$\text{BuiltinSym}(\texttt{bytes::view}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"view"}])$$
$$\text{BuiltinSym}(\texttt{bytes::view\_string}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"view\_string"}])$$
$$\text{BuiltinSym}(\texttt{bytes::append}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"append"}])$$
$$\text{BuiltinSym}(\texttt{bytes::length}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"length"}])$$
$$\text{BuiltinSym}(\texttt{bytes::is\_empty}) = \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"is\_empty"}])$$

**(BuiltinSym-String-Err)**
$$\frac{\text{StringMethod}(method) \quad method \notin \text{StringBuiltins}}{\Gamma \vdash \text{BuiltinSym}(\text{method}) \Uparrow}$$

**(BuiltinSym-Bytes-Err)**
$$\frac{\text{BytesMethod}(method) \quad method \notin \text{BytesBuiltins}}{\Gamma \vdash \text{BuiltinSym}(\text{method}) \Uparrow}$$

#### 6.12.16. Managed String/Bytes Drop Hooks

$$\text{DropHookJudg} = \{\text{StringDropSym} \Downarrow sym,\ \text{BytesDropSym} \Downarrow sym\}$$

**(StringDropSym-Decl)**
$$\frac{}{ \Gamma \vdash \text{StringDropSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"string"}, \texttt{"drop_managed"}]) }$$

**(BytesDropSym-Decl)**
$$\frac{}{ \Gamma \vdash \text{BytesDropSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"bytes"}, \texttt{"drop_managed"}]) }$$

**(StringDropSym-Err)**
$$\frac{\text{StringDropSym}\ \text{undefined}}{\Gamma \vdash \text{StringDropSym} \Uparrow}$$

**(BytesDropSym-Err)**
$$\frac{\text{BytesDropSym}\ \text{undefined}}{\Gamma \vdash \text{BytesDropSym} \Uparrow}$$

#### 6.12.17. Entrypoint and Context Construction

$$\text{EntryJudg} = \{\text{EntrySym} \Downarrow sym,\ \text{ContextInitSym} \Downarrow sym,\ \text{EntryStub}(P) \Downarrow IRDecl\}$$

**(EntrySym-Decl)**
$$\frac{}{\Gamma \vdash \text{EntrySym} \Downarrow \text{PathSig}([\texttt{"main"}])}$$

**(ContextInitSym-Decl)**
$$\frac{}{\Gamma \vdash \text{ContextInitSym} \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"context_init"}])}$$

$$\text{PanicRecordInit}(\sigma) \iff \text{PanicRecordOf}(\sigma) = \langle \text{false}, 0 \rangle$$
$$\text{EntryStubSpec}(P, IR_{\text{entry}}) \iff \text{Executable}(P) \land \exists d,\ main\_sym.\ \text{MainDecls}(P)=[d] \land \Gamma \vdash \text{Mangle}(d) \Downarrow main\_sym \land \forall \sigma.\ \exists ctx,\ ret,\ c,\ \sigma_1,\sigma_2,\sigma_3,\sigma_4.\ \text{ExecIRSigma}(\text{CallIR}(\text{ContextInitSym}, []), \sigma) \Downarrow (\text{Val}(ctx), \sigma_1)\ \land\ \text{PanicRecordInit}(\sigma_2)\ \land\ \text{ExecIRSigma}(\text{CallIR}(main\_sym, [ctx,\ \text{PanicOutName}]), \sigma_2) \Downarrow (\text{Val}(ret), \sigma_3)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(\text{CallIR}(\text{PanicSym}, [c]), \sigma_3) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{false}, c \rangle \Rightarrow \exists IR_d.\ \Gamma \vdash \text{EmitDeinitPlan}(P) \Downarrow IR_d \land \text{ExecIRSigma}(IR_d, \sigma_3) \Downarrow (\text{Val}(()), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{true}, c \rangle \Rightarrow \text{ExecIRSigma}(IR_{\text{entry}}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_4)\right)\ \land\ \left(\text{PanicRecordOf}(\sigma_3)=\langle \text{false}, c \rangle \Rightarrow \text{ExecIRSigma}(IR_{\text{entry}}, \sigma) \Downarrow (\text{Val}(ret), \sigma_4)\right)$$

**(EntryStub-Decl)**
$$\frac{\Gamma \vdash \text{EntrySym} \Downarrow sym \quad \text{EntryStubSpec}(P, IR_{\text{entry}})}{\Gamma \vdash \text{EntryStub}(P) \Downarrow \text{ProcIR}(sym, [], \text{TypePrim}(\texttt{"i32"}), IR_{\text{entry}})}$$

**(EntrySym-Err)**
$$\frac{\text{EntrySym}\ \text{undefined}}{\Gamma \vdash \text{EntrySym} \Uparrow}$$

**(EntryStub-Err)**
$$\frac{\text{EntryStub}(P)\ \text{undefined}}{\Gamma \vdash \text{EntryStub}(P) \Uparrow}$$

#### 6.12.18. Poisoning Instrumentation

$$\text{PoisonJudg} = \{\text{PoisonFlag}(m) \Downarrow sym,\ \text{CheckPoison}(m) \Downarrow IR,\ \text{SetPoison}(m) \Downarrow IR\}$$

$$\text{PoisonSet}(m) = \{m\} \cup \{x \mid \text{Reachable}(x, m, E_{val}^{eager})\}$$

**(PoisonFlag-Decl)**
$$\frac{}{\Gamma \vdash \text{PoisonFlag}(m) \Downarrow \text{PathSig}([\texttt{"cursive"}, \texttt{"runtime"}, \texttt{"poison"}] \mathbin{+\!\!+} \text{PathOfModule}(m))}$$

$$\text{PoisonFlagDecl}(m) = \text{GlobalZero}(\text{PoisonFlag}(m), \text{sizeof}(\text{TypePrim}(\texttt{"bool"})))$$
$$\text{StaticType}(\text{PoisonFlag}(m)) = \text{TypePrim}(\texttt{"bool"})$$

**(CheckPoison-Use)**
$$\frac{\text{PoisonFlag}(m) \Downarrow sym}{\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR}$$
$$\Gamma \vdash \text{CheckPoison}(m) \Downarrow IR \iff \forall \sigma.\ \left(\text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) \ne 0 \Rightarrow \exists \sigma'.\ \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \land \text{ExecIRSigma}(\text{LowerPanic}(\text{InitPanic}(m)), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')\right)\ \land\ \left(\text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) = 0 \Rightarrow \text{ExecIRSigma}(IR, \sigma) \Downarrow (\text{Val}(()), \sigma)\right)$$

**(SetPoison-OnInitFail)**
$$\frac{\text{PoisonSet}(m) = \{m_1,\ldots,m_k\} \quad \forall i,\ \text{PoisonFlag}(m_i) \Downarrow sym_i}{\Gamma \vdash \text{SetPoison}(m) \Downarrow \text{SeqIR}(\text{StoreGlobal}(sym_1, 1),\ldots,\text{StoreGlobal}(sym_k, 1))}$$

**(PoisonFlag-Err)**
$$\frac{\text{PoisonFlag}(m)\ \text{undefined}}{\Gamma \vdash \text{PoisonFlag}(m) \Uparrow}$$

**(CheckPoison-Err)**
$$\frac{\text{CheckPoison}(m)\ \text{undefined}}{\Gamma \vdash \text{CheckPoison}(m) \Uparrow}$$

**(SetPoison-Err)**
$$\frac{\text{SetPoison}(m)\ \text{undefined}}{\Gamma \vdash \text{SetPoison}(m) \Uparrow}$$

## 7. Dynamic Semantics

### 7.1. Initialization Order and Poisoning

$$\text{Vertices}(G_e) = V \iff G_e = \langle V,\ E \rangle$$
$$\text{Edges}(G_e) = E \iff G_e = \langle V,\ E \rangle$$
$$\text{Index}(L, x) = i \iff 0 \le i < |L| \land L[i] = x$$
$$\text{TopoOrder}(G_e, L) \iff \text{Distinct}(L) \land \text{Set}(L)=\text{Vertices}(G_e) \land \forall (u,v) \in \text{Edges}(G_e).\ \text{Index}(L,u) < \text{Index}(L,v)$$
$$\text{Incomparable}_{G_e}(u,v) \iff \neg \text{Reachable}(u,v,\text{Edges}(G_e)) \land \neg \text{Reachable}(v,u,\text{Edges}(G_e))$$
$$\text{TopoTieBreak}(G_e, L, P) \iff \forall u,v \in \text{Vertices}(G_e).\ \text{Incomparable}_{G_e}(u,v) \land \text{Index}(P.\text{modules}, u) < \text{Index}(P.\text{modules}, v) \Rightarrow \text{Index}(L,u) < \text{Index}(L,v)$$
$$\text{Cycle}(G_e) \iff \exists v \in \text{Vertices}(G_e).\ \text{Reachable}(v,v,\text{Edges}(G_e))$$

**(Topo-Ok)**
$$\frac{\text{Project}(\Gamma)=P \quad \Gamma \vdash G_e : \text{DAG} \quad \text{TopoOrder}(G_e, L) \quad \text{TopoTieBreak}(G_e, L, P)}{\Gamma \vdash \text{Topo}(G_e) \Downarrow L}$$

**(Topo-Cycle)**
$$\frac{\text{Cycle}(G_e) \quad c = \text{Code}(\text{Topo-Cycle})}{\Gamma \vdash \text{Topo}(G_e) \Uparrow c}$$

$$P = \text{Project}(\Gamma)$$
$$\text{StaticInitOf}(\text{item}) = init \iff \text{item}=\text{StaticDecl}(vis,mut,binding,span,doc) \land binding=\langle pat,ty\_opt,op,init,sp \rangle$$
$$\text{StaticInitOf}(\text{item}) = \bot \iff \text{item} \notin \text{StaticDecl}(\_,\_,\_,\_,\_)$$
$$\text{InitList}(m) = [\ init \mid \text{item} \in \text{Items}(P, m) \land \text{StaticInitOf}(\text{item}) = init\ ]$$

$$\text{InitOrder}(G_e) = L \iff \Gamma \vdash \text{Topo}(G_e) \Downarrow L$$
$$\text{InitPlan}(G_e) = \mathbin{+\!\!+}_{m \in \text{InitOrder}(G_e)} \text{InitList}(m)$$

$$\text{DeinitOrder}(G_e) = \text{rev}(\text{InitOrder}(G_e))$$

$$\text{StaticBindOrder}(m) = \mathbin{+\!\!+}_{\text{item} \in \text{StaticItems}(P, m),\ \text{item}=\text{StaticDecl}(vis,mut,binding,span,doc)} [\langle \text{PathOfModule}(m), x \rangle \mid x \in \text{StaticBindList}(\text{binding})]$$

$$\text{GlobalStaticOrder} = \mathbin{+\!\!+}_{m \in \text{InitOrder}(G_e)} \text{StaticBindOrder}(m)$$

$$\text{DeinitList}(P) = \text{rev}([\ \text{DropStatic}(path, name)\ \mid\ \langle path, name \rangle \in \text{GlobalStaticOrder} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp}\ ])$$

$$\Gamma \vdash \text{Eval}(e, \sigma) \Downarrow v \iff \exists \sigma'.\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma')$$
$$\Gamma \vdash \text{Eval}(e, \sigma) \Uparrow \text{panic} \iff \exists \sigma'.\ \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma')$$

**Initialization (Small-Step).**

$$\text{InitState} = \{\text{InitStart}(G_e, L, \sigma),\ \text{InitMod}(L, mi, ii, P, \sigma),\ \text{InitDone}(\sigma),\ \text{InitPanic}(P, \sigma)\}$$
$$\text{InitItem}(L, mi, ii) = e \iff mi < |L| \land L[mi]=m \land \text{InitList}(m)[ii]=e$$
$$\text{InitLen}(L, mi) = k \iff mi < |L| \land L[mi]=m \land |\text{InitList}(m)|=k$$

**(Init-Start)**
$$\frac{}{ \langle \text{InitStart}(G_e, L, \sigma) \rangle \to \langle \text{InitMod}(L, 0, 0, \emptyset, \sigma) \rangle }$$

**(Init-Step)**
$$\frac{\text{InitItem}(L, mi, ii) = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma')}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitMod}(L, mi, ii{+}1, P, \sigma') \rangle}$$

**(Init-Next-Module)**
$$\frac{\text{InitLen}(L, mi) = k \quad ii = k}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitMod}(L, mi{+}1, 0, P, \sigma) \rangle}$$

**(Init-Panic)**
$$\frac{\text{InitItem}(L, mi, ii) = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma') \quad L[mi]=m \quad P' = P \cup \{m\} \cup \{x \mid \text{Reachable}(x, m, E_{val}^{eager})\}}{\langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitPanic}(P', \sigma') \rangle}$$

**(Init-Done)**
$$\frac{mi = |L|}{ \langle \text{InitMod}(L, mi, ii, P, \sigma) \rangle \to \langle \text{InitDone}(\sigma) \rangle }$$

**Initialization (Big-Step).**

**(Init-Ok)**
$$\frac{\langle \text{InitStart}(G_e, \text{InitOrder}(G_e), \sigma) \rangle \to^* \langle \text{InitDone}(\sigma') \rangle}{\Gamma \vdash \text{Init}(G_e, \sigma) \Downarrow \sigma'}$$

**(Init-Fail)**
$$\frac{\langle \text{InitStart}(G_e, \text{InitOrder}(G_e), \sigma) \rangle \to^* \langle \text{InitPanic}(P, \sigma') \rangle}{\Gamma \vdash \text{Init}(G_e, \sigma) \Uparrow \text{panic}(P)}$$

**Deinitialization (Big-Step).**

**(Deinit-Ok)**
$$\frac{\Gamma \vdash \text{Cleanup}(\text{DeinitList}(P), \sigma) \Downarrow (\text{ok}, \sigma')}{\Gamma \vdash \text{Deinit}(P, \sigma) \Downarrow \sigma'}$$

**(Deinit-Panic)**
$$\frac{\Gamma \vdash \text{Cleanup}(\text{DeinitList}(P), \sigma) \Downarrow (\text{panic}, \sigma')}{\Gamma \vdash \text{Deinit}(P, \sigma) \Uparrow \text{panic}}$$

### 7.2. Modal Layout (Dynamic Semantics)

$$\text{layout}(M@S) = \text{layout}(\texttt{record}\ \{\text{Payload}(M, S)\})$$
$$\text{Payload}(M, S)=\emptyset \Rightarrow \text{sizeof}(M@S)=0$$
$$\text{layout}(M) =
\begin{cases}
\text{layout}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\text{layout}(\texttt{enum}\ \{S_1(\text{Payload}(M, S_1)),\ldots,S_n(\text{Payload}(M, S_n))\}) & \text{otherwise}
\end{cases}$$
$$\text{sizeof}(M) =
\begin{cases}
\text{sizeof}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\text{sizeof}(\text{Discriminant})+\max_{S \in \text{States}(M)}(\text{sizeof}(M@S))+\text{Padding} & \text{otherwise}
\end{cases}$$
$$\text{alignof}(M) =
\begin{cases}
\text{alignof}(T_p) & \text{NicheApplies}(M) \land \text{PayloadState}(M)=S_p \land \text{SingleFieldPayload}(M, S_p)=T_p\\
\max(\text{alignof}(\text{Discriminant}),\ \max_{S \in \text{States}(M)}(\text{alignof}(M@S))) & \text{otherwise}
\end{cases}$$
$$\text{ValueBits}(M,\ \langle S, v \rangle) = bits \iff \text{ModalBits}(M, S, v) = bits$$

### 7.3. Modal Pattern Matching

$$\text{MatchModalJudg} = \{\text{MatchModal}(p, v) \Downarrow B\}$$

**(Match-Modal-Empty)**
$$\frac{}{ \Gamma \vdash \text{MatchModal}(\texttt{@}S,\ \langle S, v \rangle) \Downarrow \emptyset }$$

**(Match-Modal-Record)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchModal}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}$$

$$\text{BindEnv} = \text{Ident} \rightharpoonup \text{Value}$$
$$\text{Dom}(B) = \{x \mid x \in \text{Ident} \land B[x]\ \text{defined}\}$$
$$B_1 \uplus B_2 = B \iff \text{Dom}(B_1) \cap \text{Dom}(B_2) = \emptyset \land \forall x.\ (x \in \text{Dom}(B_1) \Rightarrow B[x]=B_1[x]) \land (x \in \text{Dom}(B_2) \Rightarrow B[x]=B_2[x])$$
$$\text{MatchPatJudg} = \{\text{MatchPattern}(p, v) \Downarrow B\}$$
$$\text{PatType}(\text{LiteralPattern}(lit)) =
\begin{cases}
\text{TypePrim}(t) & lit.\text{kind}=\text{IntLiteral} \land \text{IntSuffix}(lit)=t\\
\text{TypePrim}(\texttt{"i32"}) & lit.\text{kind}=\text{IntLiteral} \land \text{IntSuffix}(lit)=\bot\\
\text{TypePrim}(t) & lit.\text{kind}=\text{FloatLiteral} \land \text{FloatSuffix}(lit)=t\\
\text{TypePrim}(\texttt{"f64"}) & lit.\text{kind}=\text{FloatLiteral} \land \text{FloatSuffix}(lit)=\bot\\
\text{TypePrim}(\texttt{"bool"}) & lit.\text{kind}=\text{BoolLiteral}\\
\text{TypePrim}(\texttt{"char"}) & lit.\text{kind}=\text{CharLiteral}\\
\text{TypeString}(\texttt{@View}) & lit.\text{kind}=\text{StringLiteral}\\
\bot & lit.\text{kind}=\text{NullLiteral}
\end{cases}$$

**(Match-Wildcard)**
$$\frac{}{\Gamma \vdash \text{MatchPattern}(\_,\ v) \Downarrow \emptyset}$$

**(Match-Ident)**
$$\frac{}{\Gamma \vdash \text{MatchPattern}(x,\ v) \Downarrow \{x \mapsto v\}}$$

**(Match-Typed)**
$$\frac{\text{UnionCase}(v) = \langle T', v' \rangle}{ \Gamma \vdash \text{MatchPattern}(x : T, v) \Downarrow \{ x \mapsto v' \}\quad \text{if } \Gamma \vdash T' \equiv T \text{ else } \bot }$$

**(Match-Literal)**
$$\frac{T = \text{PatType}(\ell) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{MatchPattern}(\ell,\ v) \Downarrow \emptyset}$$

**(Match-Tuple)**
$$\frac{v = (v_1,\ldots,v_n) \quad \forall i,\ \Gamma \vdash \text{MatchPattern}(p_i, v_i) \Downarrow B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{MatchPattern}((p_1,\ldots,p_n),\ v) \Downarrow B}$$

**(Match-Record)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(R\{fs\},\ v) \Downarrow B}$$

**(Match-Enum-Unit)**
$$\frac{v = \text{EnumValue}(path', \bot) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \bot),\ v) \Downarrow \emptyset}$$

**(Match-Enum-Tuple)**
$$\frac{v = \text{EnumValue}(path', \text{TuplePayload}(\vec{v})) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name \quad \forall i,\ \Gamma \vdash \text{MatchPattern}(p_i, v_i) \Downarrow B_i \quad B = \biguplus_i B_i}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \text{TuplePayloadPattern}([p_1,\ldots,p_n])),\ v) \Downarrow B}$$

**(Match-Enum-Record)**
$$\frac{v = \text{EnumValue}(path', \text{RecordPayload}(\vec{f})) \quad \text{EnumPath}(path') = path \quad \text{VariantName}(path') = name \quad \Gamma \vdash \text{MatchRecord}(fs,\ \text{RecordPayload}(\vec{f})) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\text{EnumPattern}(path, name, \text{RecordPayloadPattern}(fs)),\ v) \Downarrow B}$$

**(Match-Modal-General)**
$$\frac{\Gamma \vdash \text{MatchModal}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\texttt{@}S\{fs\},\ \langle S, v \rangle) \Downarrow B}$$

**(Match-Modal-State)**
$$\frac{\Gamma \vdash \text{MatchRecord}(fs,\ v) \Downarrow B}{\Gamma \vdash \text{MatchPattern}(\texttt{@}S\{fs\},\ v) \Downarrow B}$$

**(Match-Range)**
$$\frac{\text{ConstPat}(p_l) = v_l \quad \text{ConstPat}(p_h) = v_h \quad v_l \le v \le v_h}{\Gamma \vdash \text{MatchPattern}(p_l\ \texttt{..=}\ p_h,\ v) \Downarrow \emptyset}$$

$$\frac{\text{ConstPat}(p_l) = v_l \quad \text{ConstPat}(p_h) = v_h \quad v_l \le v < v_h}{\Gamma \vdash \text{MatchPattern}(p_l\ \texttt{..}\ p_h,\ v) \Downarrow \emptyset}$$

### 7.4. Deterministic Destruction and Unwinding (Cursive0)

$$\text{Responsible}(b) \iff \text{BindInfo}(b).\text{resp} = \text{resp}$$

$$\text{CleanupItem} ::= \text{DropBinding}(b) \mid \text{DropStatic}(path, name) \mid \text{DeferBlock}(b)$$
$$\text{DropStatus} = \{\text{ok},\ \text{panic}\}$$
$$\text{DropJudg} = \{\text{DropAction}(b) \Downarrow \sigma',\ \text{DropValue}(T, v, F) \Downarrow \sigma',\ \text{DropStaticAction}(path, name) \Downarrow \sigma',\ \text{DropActionOut}(b) \Downarrow (c, \sigma'),\ \text{DropValueOut}(T, v, F) \Downarrow (c, \sigma'),\ \text{DropStaticActionOut}(path, name) \Downarrow (c, \sigma')\}$$
$$\text{DropAction}(b) \Downarrow \sigma' \iff \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma')$$
$$\text{DropValue}(T, v, F) \Downarrow \sigma' \iff \text{DropValueOut}(T, v, F) \Downarrow (\text{ok}, \sigma')$$
$$\text{DropStaticAction}(path, name) \Downarrow \sigma' \iff \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma')$$
$$\text{RecordType}(T) \iff \exists p.\ T=\text{TypePath}(p) \land \text{RecordDecl}(p)\ \text{defined}$$
$$\text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma') \ \text{relation}$$
$$\neg \text{ImplementsDrop}(T) \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma)$$
$$\text{ImplementsDrop}(T) \land \text{BuiltinDropType}(T) \land T=\text{TypeString}(\texttt{@Managed}) \land \Gamma \vdash \text{StringDropSym} \Downarrow sym \land \text{ExecIRSigma}(\text{CallIR}(sym, [v]), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma')$$
$$\text{ImplementsDrop}(T) \land \text{BuiltinDropType}(T) \land T=\text{TypeBytes}(\texttt{@Managed}) \land \Gamma \vdash \text{BytesDropSym} \Downarrow sym \land \text{ExecIRSigma}(\text{CallIR}(sym, [v]), \sigma) \Downarrow (out, \sigma') \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma')$$
$$\text{ImplementsDrop}(T) \land \neg \text{BuiltinDropType}(T) \land \text{LookupMethod}(\text{StripPerm}(T), \texttt{"drop"}) = m \land \text{BindParams}(\text{MethodParamsDecl}(\text{StripPerm}(T), m), [v]) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \Gamma \vdash \text{EvalBlockBodySigma}(m.\text{body}, \sigma_1) \Downarrow (out_1, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out_1) \Downarrow (out_2, \sigma_3) \land \text{ReturnOut}(out_2) = out \Rightarrow \text{DropCall}(T, v, \sigma) \Downarrow (out, \sigma_3)$$
$$\text{ReleaseValue}(T, v, \sigma) \Downarrow \sigma' \ \text{relation}$$
$$\text{ReleaseValue}(T, v, \sigma) \Downarrow \sigma' \iff \sigma' = \sigma$$
$$\text{DropChildren}(T, v, F) =
\begin{cases}
[\ \langle T_i, v_i \rangle \mid \langle f_i, T_i \rangle \in \text{FieldsRev}(R),\ f_i \notin F,\ \text{FieldValue}(v, f_i)=v_i\ ] & T=\text{TypePath}(p) \land \text{RecordDecl}(p)=R\\
[\ \langle T_i, v_i \rangle \mid T=\text{TypeTuple}([T_0,\ldots,T_{n-1}]),\ i \in \text{rev}([0,\ldots,n{-}1]),\ \text{TupleValue}(v,i)=v_i\ ] & T=\text{TypeTuple}(\_)\\
[\ \langle T_e, v_i \rangle \mid T=\text{TypeArray}(T_e, n),\ i \in \text{rev}([0,\ldots,n{-}1]),\ \text{IndexValue}(v,i)=v_i\ ] & T=\text{TypeArray}(\_,\_)\\
[\ \langle T', v' \rangle \mid \text{UnionCase}(v)=\langle T', v' \rangle\ ] & T=\text{TypeUnion}(\_)\\
[\ \langle \text{TypeModalState}(p, S), v_s \rangle \mid v=\langle S, v_s \rangle\ ] & T=\text{TypePath}(p)\ \land\ \Sigma.\text{Types}[p]=\texttt{modal }M\\
[\ \langle T_i, v_i \rangle \mid \langle f_i, T_i \rangle \in \text{Payload}(M, S),\ \text{FieldValue}(v, f_i)=v_i\ ] & T=\text{TypeModalState}(p,S)\ \land\ \Sigma.\text{Types}[p]=\texttt{modal }M\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DropList}([], \sigma) \Downarrow (\text{ok}, \sigma)$$
$$\text{DropList}([\langle T, v \rangle] \mathbin{+\!\!+} xs,\ \sigma) \Downarrow (c, \sigma'') \iff \text{DropValueOut}(T, v, \emptyset) \Downarrow (c_1, \sigma') \land (c_1=\text{panic} \Rightarrow c=\text{panic} \land \sigma''=\sigma') \land (c_1=\text{ok} \Rightarrow \text{DropList}(xs, \sigma') \Downarrow (c, \sigma''))$$

**(DropAction-Moved)**
$$\frac{\text{BindState}(\sigma, b) = \text{Moved}}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma)}$$

**(DropAction-Partial)**
$$\frac{\text{BindState}(\sigma, b) = \text{PartiallyMoved}(F) \quad \Gamma \vdash \text{DropValueOut}(\text{TypeOf}(b), \text{BindingValue}(\sigma, b), F) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (c, \sigma')}$$

**(DropAction-Valid)**
$$\frac{\text{BindState}(\sigma, b) = \text{Valid} \quad \Gamma \vdash \text{DropValueOut}(\text{TypeOf}(b), \text{BindingValue}(\sigma, b), \emptyset) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (c, \sigma')}$$

**(DropStaticAction)**
$$\frac{\text{StaticAddr}(path, name) = addr \quad \text{ReadAddr}(\sigma, addr) = v \quad \Gamma \vdash \text{DropValueOut}(\text{StaticType}(path, name), v, \emptyset) \Downarrow (c, \sigma')}{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (c, \sigma')}$$

$$\text{NonRecordFOk}(T, F) \iff \text{RecordType}(T) \lor F=\emptyset$$

**(DropValueOut-DropPanic)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{panic}, \sigma_1)}$$

**(DropValueOut-ChildPanic)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma_1) \quad \text{DropList}(\text{DropChildren}(T, v, F), \sigma_1) \Downarrow (\text{panic}, \sigma_2)}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{panic}, \sigma_2)}$$

**(DropValueOut-Ok)**
$$\frac{\text{NonRecordFOk}(T, F) \quad \text{DropCall}(T, v, \sigma) \Downarrow (\text{Val}(()), \sigma_1) \quad \text{DropList}(\text{DropChildren}(T, v, F), \sigma_1) \Downarrow (\text{ok}, \sigma_2) \quad \text{ReleaseValue}(T, v, \sigma_2) \Downarrow \sigma_3}{\Gamma \vdash \text{DropValueOut}(T, v, F) \Downarrow (\text{ok}, \sigma_3)}$$

**Cleanup (Small-Step).**

$$\text{CleanupFlag} = \{\text{ok},\ \text{panic}\}$$
$$\text{CleanupState} = \{\text{CleanupLoop}(scope, \sigma, c) \mid c \in \text{CleanupFlag}\} \cup \{\text{ExitDone}(c, \sigma) \mid c \in \text{CleanupFlag}\} \cup \{\text{Abort}\}$$

**(Cleanup-Start)**
$$\frac{}{\langle \text{ExitScope}(scope, \sigma) \rangle \to \langle \text{CleanupLoop}(scope, \sigma, \text{ok}) \rangle}$$

**(Cleanup-Step-Drop-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-Drop-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-Drop-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropBinding}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Step-DropStatic-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-DropStatic-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-DropStatic-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DropStatic}(path, name)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Step-Defer-Ok)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2)}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, c) \rangle}$$

**(Cleanup-Step-Defer-Panic)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2) \quad c = \text{ok}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{CleanupLoop}(scope, \sigma_2, \text{panic}) \rangle}$$

**(Cleanup-Step-Defer-Abort)**
$$\frac{\text{CleanupList}(scope) = rest \mathbin{+\!\!+} [\text{DeferBlock}(b)] \quad \sigma_1 = \text{SetCleanupList}(scope, rest, \sigma) \quad \Gamma \vdash \text{EvalSigma}(b, \sigma_1) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2) \quad c = \text{panic}}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{Abort} \rangle}$$

**(Cleanup-Done)**
$$\frac{\text{CleanupList}(scope) = []}{\langle \text{CleanupLoop}(scope, \sigma, c) \rangle \to \langle \text{ExitDone}(c, \sigma) \rangle}$$

**Destruction (Big-Step).**

**(Destroy-Empty)**
$$\frac{}{\Gamma \vdash \text{Destroy}([], \sigma) \Downarrow \sigma}$$

**(Destroy-Cons)**
$$\frac{\Gamma \vdash \text{DropAction}(b) \Downarrow \sigma_1 \quad \Gamma \vdash \text{Destroy}(bs, \sigma_1) \Downarrow \sigma_2}{\Gamma \vdash \text{Destroy}(b::bs, \sigma) \Downarrow \sigma_2}$$

**Cleanup (Big-Step).**

$$\text{CleanupJudg}_{\text{Dyn}} = \{\text{Cleanup}(cs, \sigma) \Downarrow (c, \sigma')\}$$

**(Cleanup-Empty)**
$$\frac{}{\Gamma \vdash \text{Cleanup}([], \sigma) \Downarrow (\text{ok}, \sigma)}$$

**(Cleanup-Cons-Drop)**
$$\frac{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{ok}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropBinding}(b)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-Drop-Panic)**
$$\frac{\Gamma \vdash \text{DropActionOut}(b) \Downarrow (\text{panic}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropBinding}(b)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**(Cleanup-Cons-DropStatic)**
$$\frac{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{ok}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropStatic}(path, name)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-DropStatic-Panic)**
$$\frac{\Gamma \vdash \text{DropStaticActionOut}(path, name) \Downarrow (\text{panic}, \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DropStatic}(path, name)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**(Cleanup-Cons-Defer-Ok)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DeferBlock}(b)::cs, \sigma) \Downarrow (c, \sigma_2)}$$

**(Cleanup-Cons-Defer-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1) \quad \Gamma \vdash \text{Cleanup}(cs, \sigma_1) \Downarrow (c, \sigma_2)}{\Gamma \vdash \text{Cleanup}(\text{DeferBlock}(b)::cs, \sigma) \Downarrow (\text{panic}, \sigma_2)}$$

**Cleanup Scope (Big-Step).**

$$\text{CleanupScopeJudg} = \{\text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma')\}$$

**(CleanupScope-From-SmallStep)**
$$\frac{\langle \text{ExitScope}(scope, \sigma) \rangle \to^* \langle \text{ExitDone}(c, \sigma') \rangle}{\Gamma \vdash \text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma')}$$

**Unwinding.**

**(Unwind-Step)**
$$\frac{\Gamma \vdash \text{CleanupScope}(f_1.\text{scope}, \sigma) \Downarrow (\text{ok}, \sigma')}{\langle \text{Unwind}(f_1::fs, \sigma) \rangle \to \langle \text{Unwind}(fs, \sigma') \rangle}$$

**(Unwind-Abort)**
$$\frac{\Gamma \vdash \text{CleanupScope}(f_1.\text{scope}, \sigma) \Downarrow (\text{panic}, \sigma')}{\langle \text{Unwind}(f_1::fs, \sigma) \rangle \to \langle \text{Abort} \rangle}$$

**Region, Frame, and Allocation Semantics (Cursive0).**

**Dynamic Scope Stack.**

$$\text{ScopeEntry} = \langle \text{scope\_id},\ \text{cleanup},\ \text{names},\ \text{vals},\ \text{states} \rangle$$
$$\text{ScopeId}(\langle sid, cleanup, names, vals, states \rangle) = sid$$
$$\text{ScopeCleanup}(\langle sid, cleanup, names, vals, states \rangle) = cleanup$$
$$\text{ScopeNames}(\langle sid, cleanup, names, vals, states \rangle) = names$$
$$\text{ScopeVals}(\langle sid, cleanup, names, vals, states \rangle) = vals$$
$$\text{ScopeStates}(\langle sid, cleanup, names, vals, states \rangle) = states$$
$$\text{ScopeStack}(\sigma) \in [\text{ScopeEntry}]$$
$$\text{CurrentScope}(\sigma) = scope \iff \text{ScopeStack}(\sigma) = scope :: ss$$
$$\text{CurrentScopeId}(\sigma) = \text{ScopeId}(\text{CurrentScope}(\sigma))$$
$$\text{ScopeEmpty}(sid) = \langle sid,\ [],\ \emptyset,\ \emptyset,\ \emptyset \rangle$$
$$\text{FreshScopeId}(\sigma) = sid \Rightarrow \forall s \in \text{ScopeStack}(\sigma).\ \text{ScopeId}(s) \ne sid$$
$$\text{UpdateScopeStack}(\sigma, ss) = \sigma' \iff \text{ScopeStack}(\sigma') = ss \land \text{AddrTags}(\sigma') = \text{AddrTags}(\sigma) \land \text{RegionStack}(\sigma') = \text{RegionStack}(\sigma) \land \text{PoisonedModules}(\sigma') = \text{PoisonedModules}(\sigma)$$
$$\text{PushScope}_\sigma(\sigma) \Downarrow (\sigma', scope) \iff scope = \text{ScopeEmpty}(sid) \land \text{FreshScopeId}(\sigma) = sid \land \text{UpdateScopeStack}(\sigma, scope :: \text{ScopeStack}(\sigma)) = \sigma'$$
$$\text{PopScope}_\sigma(\sigma) \Downarrow (\sigma', scope) \iff \text{ScopeStack}(\sigma) = scope :: ss \land \text{UpdateScopeStack}(\sigma, ss) = \sigma'$$
$$\text{AppendCleanup}(\sigma, item) \Downarrow \sigma' \iff \text{ScopeStack}(\sigma) = scope :: ss \land scope = \langle sid, cleanup, names, vals, states \rangle \land scope' = \langle sid, cleanup \mathbin{+\!\!+} [item], names, vals, states \rangle \land \text{UpdateScopeStack}(\sigma, scope' :: ss) = \sigma'$$
$$\text{CleanupList}(scope) = \text{ScopeCleanup}(scope)$$
$$\text{ScopeById}([], sid) = \bot$$
$$\text{ScopeById}(scope :: ss, sid) = \begin{cases} scope & \text{if } \text{ScopeId}(scope) = sid \\ \text{ScopeById}(ss, sid) & \text{otherwise} \end{cases}$$
$$\text{ReplaceScopeById}([], sid, scope') = \bot$$
$$\text{ReplaceScopeById}(scope :: ss, sid, scope') = \begin{cases} scope' :: ss & \text{if } \text{ScopeId}(scope) = sid \\ scope :: \text{ReplaceScopeById}(ss, sid, scope') & \text{otherwise} \end{cases}$$
$$\text{SetCleanupList}(scope, xs, \sigma) \Downarrow \sigma' \iff sid = \text{ScopeId}(scope) \land scope' = \langle sid, xs, \text{ScopeNames}(scope), \text{ScopeVals}(scope), \text{ScopeStates}(scope) \rangle \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'$$

**Poisoned Modules.**

$$\text{PoisonedModule}(\sigma, path) \iff \exists m.\ \text{PathOfModule}(m) = path \land \text{ReadAddr}(\sigma, \text{AddrOfSym}(\text{PoisonFlag}(m))) \ne 0$$
$$\text{PoisonedModules}(\sigma) = \{ path \mid \text{PoisonedModule}(\sigma, path) \}$$

**Dynamic Value Environment.**

$$\text{Binding} = \langle \text{scope\_id},\ \text{bind\_id},\ \text{name} \rangle$$
$$\text{BindingValue} = \text{Value} \cup \{\text{Alias}(addr) \mid addr \in \text{Addr}\}$$
$$\text{FreshBindId}(\sigma) = b \Rightarrow \forall x.\ \text{ScopeNames}(\text{CurrentScope}(\sigma))[x]\ \text{defined} \Rightarrow b \notin \text{ScopeNames}(\text{CurrentScope}(\sigma))[x]$$
$$\text{Last}([a]) = a$$
$$\text{Last}(a::as) = \text{Last}(as) \quad (|as|>0)$$
$$\text{NearestScope}([], x) = \bot$$
$$\text{NearestScope}(scope :: ss, x) = \begin{cases} scope & \text{if } \text{ScopeNames}(scope)[x]\ \text{defined} \\ \text{NearestScope}(ss, x) & \text{otherwise} \end{cases}$$
$$\text{LookupBind}(\sigma, x) = \langle \text{ScopeId}(scope), b, x \rangle \iff \text{NearestScope}(\text{ScopeStack}(\sigma), x) = scope \land b = \text{Last}(\text{ScopeNames}(scope)[x])$$
$$\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) = v \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land \text{ScopeVals}(scope)[bind\_id] = v$$
$$\text{BindState}(\sigma, \langle sid, bind\_id, x \rangle) = s \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land \text{ScopeStates}(scope)[bind\_id] = s$$

**(LookupVal-Bind-Value)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{BindingValue}(\sigma, b) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-Bind-Alias)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{BindingValue}(\sigma, b) = \text{Alias}(addr) \quad \text{ReadAddr}(\sigma, addr) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-Path)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \neg \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp)) \quad \text{LookupValPath}(\sigma, \text{PathOfModule}(mp), name) = v}{\text{LookupVal}(\sigma, x) = v}$$

**(LookupVal-RecordCtor)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad \Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \neg \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp)) \quad \text{RecordDecl}(\text{FullPath}(\text{PathOfModule}(mp), name)) = R}{\text{LookupVal}(\sigma, x) = \text{RecordCtor}(\text{FullPath}(\text{PathOfModule}(mp), name))}$$

**(LookupValPath-Static)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad path' = \text{PathOfModule}(mp) \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \neg \text{PoisonedModule}(\sigma, path') \quad \text{StaticAddr}(path', name') = addr \quad \text{ReadAddr}(\sigma, addr) = v}{\text{LookupValPath}(\sigma, path, name) = v}$$

**(LookupValPath-Proc)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad path' = \text{PathOfModule}(mp) \quad name' = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ name) \quad \neg \text{PoisonedModule}(\sigma, path') \quad \text{DeclOf}(path', name') = proc}{\text{LookupValPath}(\sigma, path, name) = \text{ProcRef}(proc)}$$

**(LookupValPath-RecordCtor)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, \_) \quad \neg \text{PoisonedModule}(\sigma, mp)}{\text{LookupValPath}(\sigma, path, name) = \text{RecordCtor}(p)}$$

$$\text{LookupBind}(\sigma, x)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{LookupBind}(\sigma, x))$$
$$\text{LookupVal}(\sigma, x)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{LookupVal}(\sigma, x))$$

$$\text{ScopeValsUpdate}(\langle sid, cleanup, names, vals, states \rangle, bind\_id, v) = \langle sid, cleanup, names, vals[bind\_id \mapsto v], states \rangle$$
$$\text{ScopeStatesUpdate}(\langle sid, cleanup, names, vals, states \rangle, bind\_id, s) = \langle sid, cleanup, names, vals, states[bind\_id \mapsto s] \rangle$$

$$\text{UpdateVal}(\sigma, \langle sid, bind\_id, x \rangle, v) \Downarrow \sigma' \iff \left(\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) = \text{Alias}(addr) \land \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'\right) \lor \left(\text{BindingValue}(\sigma, \langle sid, bind\_id, x \rangle) \ne \text{Alias}(\_) \land \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land scope' = \text{ScopeValsUpdate}(scope, bind\_id, v) \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'\right)$$
$$\text{SetState}(\sigma, \langle sid, bind\_id, x \rangle, s) \Downarrow \sigma' \iff \text{ScopeById}(\text{ScopeStack}(\sigma), sid) = scope \land scope' = \text{ScopeStatesUpdate}(scope, bind\_id, s) \land \text{ReplaceScopeById}(\text{ScopeStack}(\sigma), sid, scope') = ss' \land \text{UpdateScopeStack}(\sigma, ss') = \sigma'$$

$$\text{TypeOf}(\langle sid, bind\_id, x \rangle) = \text{TypeOf}(x)$$
$$\text{BindInfo}(\langle sid, bind\_id, x \rangle) = \text{BindInfo}(x)$$

$$\text{BindVal}(\sigma, x, v) \Downarrow (\sigma', b) \iff \text{ScopeStack}(\sigma) = scope :: ss \land scope = \langle sid, cleanup, names, vals, states \rangle \land bind\_id = \text{FreshBindId}(\sigma) \land names' = names[x \mapsto (names[x]\ \text{if present else}\ []) \mathbin{+\!\!+} [bind\_id]] \land vals' = vals[bind\_id \mapsto v] \land states' = states[bind\_id \mapsto \text{Valid}] \land scope' = \langle sid, cleanup, names', vals', states' \rangle \land \text{UpdateScopeStack}(\sigma, scope' :: ss) = \sigma_1 \land b = \langle sid, bind\_id, x \rangle \land \left((\text{BindInfo}(b).\text{resp} = \text{resp} \land \text{AppendCleanup}(\sigma_1, \text{DropBinding}(b)) \Downarrow \sigma') \lor (\text{BindInfo}(b).\text{resp} \ne \text{resp} \land \sigma' = \sigma_1)\right)$$

$$\text{BindPatternVal}(p, v) \Downarrow B \iff \Gamma \vdash \text{MatchPattern}(p, v) \Downarrow B$$
$$\text{BindOrder}(p, B) = [\ \langle x, B[x] \rangle \mid x \in \text{PatNames}(p)\ ]$$

**(BindList-Empty)**
$$\frac{}{\text{BindList}(\sigma, []) \Downarrow (\sigma, [])}$$

**(BindList-Cons)**
$$\frac{\text{BindVal}(\sigma, x, v) \Downarrow (\sigma_1, b) \quad \text{BindList}(\sigma_1, xs) \Downarrow (\sigma_2, bs)}{\text{BindList}(\sigma, [\langle x, v \rangle] \mathbin{+\!\!+} xs) \Downarrow (\sigma_2, b::bs)}$$

$$\text{BindPattern}(\sigma, p, v) \Downarrow (\sigma', bs) \iff \text{BindPatternVal}(p, v) \Downarrow B \land \text{BindOrder}(p, B) = binds \land \text{BindList}(\sigma, binds) \Downarrow (\sigma', bs)$$

**Runtime Region Stack.**

$$\text{RegionEntry} = \langle \text{tag},\ \text{target},\ \text{scope},\ \text{mark\_opt} \rangle$$
$$\text{RegionTagOf}(\langle tag, target, scope, mark\_opt \rangle) = tag$$
$$\text{RegionTargetOf}(\langle tag, target, scope, mark\_opt \rangle) = target$$
$$\text{RegionScopeOf}(\langle tag, target, scope, mark\_opt \rangle) = scope$$
$$\text{RegionMarkOf}(\langle tag, target, scope, mark\_opt \rangle) = mark\_opt$$
$$\text{RuntimeTag} = \{\text{RegionTag}(tag),\ \text{ScopeTag}(sid)\}$$
$$\text{RegionStack}(\sigma) \in [\text{RegionEntry}]$$
$$\text{AddrTags}(\sigma) : \text{Addr} \rightharpoonup \text{RuntimeTag}$$

**Region Values.**

$$\text{RegionValue}(S, h) = \text{RecordValue}(\text{ModalStateRef}([\texttt{Region}], S), [\langle \texttt{handle}, \text{IntVal}(\texttt{"usize"}, h) \rangle])$$
$$\text{RegionHandleOf}(v) = h \iff v = \text{RecordValue}(\text{ModalStateRef}([\texttt{Region}], S), fs) \land \langle \texttt{handle}, \text{IntVal}(\texttt{"usize"}, h) \rangle \in fs$$
$$\text{RegionHandleOf}(v)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{RegionHandleOf}(v))$$

$$\text{ResolveEntry}([], r) = \bot$$
$$\text{ResolveEntry}(e::es, r) = \begin{cases} e & \text{if } \text{RegionTargetOf}(e) = r \\ \text{ResolveEntry}(es, r) & \text{otherwise} \end{cases}$$
$$\text{ActiveEntry}(\sigma) = e \iff \text{RegionStack}(\sigma) = e :: es$$
$$\text{ActiveTarget}(\sigma) = target \iff \text{ActiveEntry}(\sigma) = e \land \text{RegionTargetOf}(e) = target$$
$$\text{ResolveTarget}(\sigma, r) = target \iff \text{ResolveEntry}(\text{RegionStack}(\sigma), r) = e \land \text{RegionTargetOf}(e) = target$$
$$\text{ResolveTag}(\sigma, r) = tag \iff \text{ResolveEntry}(\text{RegionStack}(\sigma), r) = e \land \text{RegionTagOf}(e) = tag$$
$$\text{FreshTag}(\sigma) = tag \Rightarrow \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTagOf}(e) \ne tag$$
$$\text{FreshArena}(\sigma) = r \Rightarrow \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTargetOf}(e) \ne r$$

$$\text{ActiveTarget}(\sigma)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{ActiveTarget}(\sigma))$$
$$\text{ResolveTarget}(\sigma, r)\ \text{undefined} \Rightarrow \text{IllFormed}(\text{ResolveTarget}(\sigma, r))$$

$$\text{UpdateRegionStack}(\sigma, rs) = \sigma' \iff \text{RegionStack}(\sigma') = rs \land \text{ScopeStack}(\sigma') = \text{ScopeStack}(\sigma) \land \text{AddrTags}(\sigma') = \text{AddrTags}(\sigma) \land \text{PoisonedModules}(\sigma') = \text{PoisonedModules}(\sigma)$$

$$\text{RegionNew}(\sigma, opts) \Downarrow (\sigma', r, scope) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land \text{FreshArena}(\sigma) = r \land \text{UpdateRegionStack}(\sigma_1, \langle r, r, scope, \bot \rangle :: \text{RegionStack}(\sigma_1)) = \sigma'$$

$$\text{RegionOpen}(\sigma, opts) \Downarrow (\sigma', r) \iff \text{FreshArena}(\sigma) = r \land \text{UpdateRegionStack}(\sigma, \langle r, r, \text{CurrentScopeId}(\sigma), \bot \rangle :: \text{RegionStack}(\sigma)) = \sigma'$$

$$\text{FrameEnter}(\sigma, r) \Downarrow (\sigma', F, scope, mark) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land F = \text{FreshTag}(\sigma) \land mark = \text{FrameMark}(\sigma_1, r) \land \text{UpdateRegionStack}(\sigma_1, \langle F, r, scope, mark \rangle :: \text{RegionStack}(\sigma_1)) = \sigma'$$

$$\text{BindRegionAlias}(\sigma, \bot, r) \Downarrow \sigma$$
$$\text{BindRegionAlias}(\sigma, x, r) \Downarrow \sigma' \iff \text{BindVal}(\sigma, x, \text{RegionValue}(\texttt{@Active}, r)) \Downarrow (\sigma', b)$$

$$\text{DynPayloadAddr}(v, addr) \iff v = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)$$
$$\text{RegionAlloc}(\sigma, r, v) \Downarrow (\sigma', v') \Rightarrow \left(\text{ResolveTag}(\sigma, r) = tag \land \forall addr.\ \text{DynPayloadAddr}(v', addr) \Rightarrow \text{AddrTags}(\sigma')(addr) = \text{RegionTag}(tag)\right)$$

$$\text{FreshTags}(\sigma, tags) \iff \text{Distinct}(tags) \land \forall tag \in \text{Set}(tags).\ \forall e \in \text{RegionStack}(\sigma).\ \text{RegionTagOf}(e) \ne tag$$

$$\text{RetagRegions}([], r, tags) = [] \iff tags = []$$
$$\text{RetagRegions}(e::es, r, tags) = \begin{cases} e' :: \text{RetagRegions}(es, r, tags') & \text{if } \text{RegionTargetOf}(e) = r \land tags = tag :: tags' \land e' = \langle tag, \text{RegionTargetOf}(e), \text{RegionScopeOf}(e), \text{RegionMarkOf}(e) \rangle \\ e :: \text{RetagRegions}(es, r, tags) & \text{otherwise} \end{cases}$$

$$\text{RegionReset}(\sigma, r) \Downarrow \sigma' \iff \text{FreshTags}(\sigma, tags) \land \text{RetagRegions}(\text{RegionStack}(\sigma), r, tags) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

$$\text{PopRegions}([], r) = []$$
$$\text{PopRegions}(e::es, r) = \begin{cases} \text{PopRegions}(es, r) & \text{if } \text{RegionTargetOf}(e) = r \\ e :: \text{PopRegions}(es, r) & \text{otherwise} \end{cases}$$
$$\text{RegionFree}(\sigma, r) \Downarrow \sigma' \iff \text{PopRegions}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

**Region Procedures.**

$$\text{RegionProcJudg} = \{\text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v),\ \text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v'),\ \text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma', v'),\ \text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')\}$$

**(Region-New-Scoped)**
$$\frac{\text{RegionOpen}(\sigma, opts) \Downarrow (\sigma', r) \quad v = \text{RegionValue}(\texttt{@Active}, r)}{\text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v)}$$

**(Region-Alloc-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{RegionAlloc}(\sigma, r_t, v) \Downarrow (\sigma', v')}{\text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v')}$$

**(Region-Reset-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{RegionReset}(\sigma, h) \Downarrow \sigma' \quad v' = \text{RegionValue}(\texttt{@Active}, h)}{\text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v')}$$

**(Region-Freeze-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad v' = \text{RegionValue}(\texttt{@Frozen}, h)}{\text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma, v')}$$

**(Region-Thaw-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad v' = \text{RegionValue}(\texttt{@Active}, h)}{\text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma, v')}$$

**(Region-Free-Proc)**
$$\frac{\text{RegionHandleOf}(v_r) = h \quad \text{RegionFree}(\sigma, h) \Downarrow \sigma' \quad v' = \text{RegionValue}(\texttt{@Freed}, h)}{\text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')}$$

$$\text{PopRegion}([], r) = \bot$$
$$\text{PopRegion}(e::es, r) = \begin{cases} es & \text{if } \text{RegionTargetOf}(e) = r \\ e :: \text{PopRegion}(es, r) & \text{otherwise} \end{cases}$$
$$\text{ReleaseArena}(\sigma, r) \Downarrow \sigma' \iff \text{PopRegion}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$
$$\text{ResetArena}(\sigma, r, mark) \Downarrow \sigma' \iff \text{PopRegion}(\text{RegionStack}(\sigma), r) = rs' \land \text{UpdateRegionStack}(\sigma, rs') = \sigma'$$

$$\text{FrameMark}(\sigma, r) = |\text{RegionStack}(\sigma)|$$

**Control Outcomes.**

$$\text{Ctrl} = \{\text{Return}(v),\ \text{Result}(v),\ \text{Break}(v_{opt}),\ \text{Continue},\ \text{Panic},\ \text{Abort}\}$$
$$\text{StmtOut} = \{\text{ok}\} \cup \{\text{Ctrl}(\kappa) \mid \kappa \in \text{Ctrl}\}$$
$$\text{Outcome} = \{\text{Val}(v)\} \cup \{\text{Ctrl}(\kappa) \mid \kappa \in \text{Ctrl}\}$$
$$\text{StmtOutOf}(\text{Val}(v)) = \text{ok}$$
$$\text{StmtOutOf}(\text{Ctrl}(\kappa)) = \text{Ctrl}(\kappa)$$
$$\text{BreakVal}(\bot) = ()$$
$$\text{BreakVal}(v) = v$$

**Block Evaluation Helpers.**

$$\text{BlockEnter}(\sigma, binds) \Downarrow (\sigma', scope) \iff \text{PushScope}_\sigma(\sigma) \Downarrow (\sigma_1, scope) \land \exists bs.\ \text{BindList}(\sigma_1, binds) \Downarrow (\sigma', bs)$$

$$\text{ExitOutcome}(out, \text{ok}) = out$$
$$\text{ExitOutcome}(\text{Ctrl}(\text{Abort}), c) = \text{Ctrl}(\text{Abort})$$
$$\text{ExitOutcome}(\text{Ctrl}(\text{Panic}), \text{panic}) = \text{Ctrl}(\text{Abort})$$
$$\text{ExitOutcome}(out, \text{panic}) = \text{Ctrl}(\text{Panic}) \quad (out \ne \text{Ctrl}(\text{Panic}) \land out \ne \text{Ctrl}(\text{Abort}))$$

$$\text{BlockExit}(\sigma, scope, out) \Downarrow (out', \sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, \sigma) \Downarrow (c, \sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land \sigma' = \sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{PopScope}_\sigma(\sigma_1) \Downarrow (\sigma', scope)))$$

$$\text{EvalBlockBodySigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma') \iff \Gamma \vdash \text{ExecSeqSigma}(stmts, \sigma) \Downarrow (sout, \sigma_1) \land \Big((sout = ok \land tail\_opt = e \land \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (out, \sigma')) \ \lor$$
$$\qquad (sout = ok \land tail\_opt = \bot \land out = \text{Val}(()) \land \sigma' = \sigma_1) \ \lor\ (sout = \text{Ctrl}(\text{Result}(v)) \land out = \text{Val}(v) \land \sigma' = \sigma_1) \ \lor$$
$$\qquad (sout = \text{Ctrl}(\kappa) \land \kappa \ne \text{Result}(\_) \land out = \text{Ctrl}(\kappa) \land \sigma' = \sigma_1)\Big)$$

$$\text{EvalBlockSigma}(b, \sigma) \Downarrow (out', \sigma'') \iff \text{BlockEnter}(\sigma, []) \Downarrow (\sigma_1, scope) \land \text{EvalBlockBodySigma}(b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

$$\text{EvalBlockBindSigma}(p, v, b, \sigma) \Downarrow (out', \sigma'') \iff \text{BindPatternVal}(p, v) \Downarrow B \land \text{BindOrder}(p, B) = binds \land \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \land \text{EvalBlockBodySigma}(b, \sigma_1) \Downarrow (out, \sigma_2) \land \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma'')$$

$$\text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma') \iff \text{CurrentScopeId}(\sigma) = scope \land \text{EvalBlockBodySigma}(b, \sigma) \Downarrow (out, \sigma')$$

**Place Evaluation Helpers.**

**PlaceJudg.**
$$\text{PlaceJudg} = \{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{WritePlaceSubSigma}(p, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (out, \sigma')\}$$

$$\text{DropOnAssign}(b) \iff \text{BindInfo}(b).\text{mov} = \text{immov} \land \text{BindInfo}(b).\text{resp} = \text{resp}$$

$$\text{DropOnAssignStatic}(path, name) \iff \text{StaticBindInfo}(path, name).\text{mov} = \text{immov} \land \text{StaticBindInfo}(path, name).\text{resp} = \text{resp}$$

$$\text{RootBinding}(Sigma, p) = \begin{cases}
\text{Local}(b) & \text{if } \text{LookupBind}(Sigma, \text{PlaceRoot}(p)) = b \\
\text{Static}(path, name) & \text{if } \text{LookupBind}(Sigma, \text{PlaceRoot}(p))\ \text{undefined} \land \Gamma \vdash \text{ResolveValueName}(\text{PlaceRoot}(p)) \Downarrow ent \land ent.\text{origin\_opt} = mp \land name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ \text{PlaceRoot}(p)) \land path = \text{PathOfModule}(mp)
\end{cases}$$

$$\text{DropOnAssignRoot}(Sigma, p) \iff (\text{RootBinding}(Sigma, p) = \text{Local}(b) \land \text{DropOnAssign}(b)) \lor (\text{RootBinding}(Sigma, p) = \text{Static}(path, name) \land \text{DropOnAssignStatic}(path, name))$$

$$\text{RootMoved}(Sigma, p) \iff \text{RootBinding}(Sigma, p) = \text{Local}(b) \land \text{BindState}(Sigma, b) = \text{Moved}$$

**DropSubvalueJudg.**
$$\text{DropSubvalueJudg} = \{\Gamma \vdash \text{DropSubvalue}(p, T, v, \sigma) \Downarrow \sigma'\}$$

**(DropSubvalue-Do)**
$$\frac{\text{DropOnAssignRoot}(Sigma, p) \quad \neg \text{RootMoved}(Sigma, p) \quad \Gamma \vdash \text{DropValue}(T, v, \emptyset) \Downarrow Sigma'}{\Gamma \vdash \text{DropSubvalue}(p, T, v, Sigma) \Downarrow Sigma'}$$

**(DropSubvalue-Skip)**
$$\frac{\neg \text{DropOnAssignRoot}(Sigma, p) \ \lor\ \text{RootMoved}(Sigma, p)}{\Gamma \vdash \text{DropSubvalue}(p, T, v, Sigma) \Downarrow Sigma}$$


**(ReadPlace-Ident)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ReadPlace-Ident-Poison)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePlace-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad (\text{DropOnAssign}(b) \Rightarrow \Gamma \vdash \text{DropAction}(b) \Downarrow \sigma_1) \quad (\neg \text{DropOnAssign}(b) \Rightarrow \sigma_1 = \sigma) \quad \text{UpdateVal}(\sigma_1, b, v) \Downarrow \sigma_2 \quad \text{SetState}(\sigma_2, b, \text{Valid}) \Downarrow \sigma_3}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma_3)}$$

**(WritePlace-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePlace-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr \quad (\text{DropOnAssignStatic}(path, name) \Rightarrow \Gamma \vdash \text{DropStaticAction}(path, name) \Downarrow \sigma_1) \quad (\neg \text{DropOnAssignStatic}(path, name) \Rightarrow \sigma_1 = \sigma) \quad \text{WriteAddr}(\sigma_1, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

$$\text{TupleValue}((v_0,\ldots,v_{n-1}), i) = v_i \quad (0 \le i < n)$$
$$\text{TupleUpdate}((v_0,\ldots,v_{n-1}), i, v') = (v_0,\ldots,v_{i-1}, v', v_{i+1},\ldots,v_{n-1}) \quad (0 \le i < n)$$
$$\text{FieldValue}(\text{RecordValue}(tr, fs), f) = v \iff \langle f, v \rangle \in fs$$
$$\text{FieldUpdate}(\text{RecordValue}(tr, fs), f, v') = \text{RecordValue}(tr, fs') \quad \text{where } fs' = [\langle f_i, v_i' \rangle \mid \langle f_i, v_i \rangle \in fs \land v_i' = \begin{cases}v' & f_i = f \\ v_i & f_i \ne f \end{cases}]$$

$$\text{Len}([v_0,\ldots,v_{n-1}]) = n$$
$$\text{Len}(\text{SliceValue}(v, r)) = end - start \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end))$$
$$\text{IndexNum}(v) = i \iff v=\text{IntVal}(\texttt{"usize"}, i)$$
$$\text{IndexValue}([v_0,\ldots,v_{n-1}], i) = v_i \quad (0 \le i < n)$$
$$\text{IndexValue}(\text{SliceValue}(v, r), i) = \text{IndexValue}(v, start+i) \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end) \land 0 \le i < end-start)$$
$$\text{IndexValue}(v, v_i) = v_e \iff \text{IndexNum}(v_i)=i \land \text{IndexValue}(v, i) = v_e$$
$$\text{IndexUpdate}([v_0,\ldots,v_{n-1}], i, v_e) = [v_0,\ldots,v_{i-1}, v_e, v_{i+1},\ldots,v_{n-1}] \quad (0 \le i < n)$$
$$\text{IndexUpdate}(\text{SliceValue}(v_b, r), i, v_e) = \text{SliceValue}(v_b', r) \quad (\text{SliceBounds}(r, \text{Len}(v_b)) = (start, end) \land 0 \le i < end-start \land \text{IndexUpdate}(v_b, start+i, v_e) = v_b')$$
$$\text{IndexUpdate}(v, v_i, v_e) = v' \iff \text{IndexNum}(v_i)=i \land \text{IndexUpdate}(v, i, v_e)=v'$$
$$\text{SliceValue}(v, r)\ \text{defined} \iff \text{SliceBounds}(r, \text{Len}(v))\ \text{defined}$$
$$\text{SliceLen}([v_0,\ldots,v_{n-1}]) = n$$
$$\text{SliceLen}(\text{SliceValue}(v, r)) = end - start \quad (\text{SliceBounds}(r, \text{Len}(v)) = (start, end))$$
$$\text{SliceElem}(v, i) = \text{IndexValue}(v, i) \quad (\text{IndexValue}(v, i)\ \text{defined})$$
$$\text{SliceUpdate}(v, start, v_{rhs}) \Downarrow v' \iff n = \text{SliceLen}(v_{rhs}) \land \exists v_0,\ldots,v_n.\ v_0 = v \land \forall i \in [0,n{-}1].\ v_{i+1} = \text{IndexUpdate}(v_i, start+i, \text{SliceElem}(v_{rhs}, i)) \land v' = v_n$$

**PtrAddrJudg.**
$$\text{PtrAddrJudg} = \{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (out, \sigma')\}$$

$$\text{AddrPrimJudg} = \{\text{ReadAddr}(\sigma, addr) = v,\ \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma',\ \text{FieldAddr}(T, addr, f) = addr',\ \text{TupleAddr}(T, addr, i) = addr',\ \text{IndexAddr}(T_b, addr, i) = addr'\}$$
$$\text{IndexLen}(Sigma, addr) = \text{Len}(v) \quad (\text{ReadAddr}(Sigma, addr) = v \land \text{Len}(v)\ \text{defined})$$
$$\text{IndexAddr}(T_b, addr, i) = \text{AddrAdd}(addr, i \times \text{sizeof}(\text{ElemType}(T_b))) \quad (\text{ElemType}(T_b)\ \text{defined})$$
$$\text{IndexAddr}(T_b, addr, v_i) = addr' \iff \text{IndexNum}(v_i)=i \land \text{IndexAddr}(T_b, addr, i) = addr'$$
$$\text{SliceLenFromAddr}(\sigma, addr) = n \iff \text{ReadAddr}(\sigma, addr) = v \land \text{SliceLen}(v) = n$$

$$\text{PtrStateSet} = \{\texttt{Valid}, \texttt{Null}, \texttt{Expired}\}$$
$$\text{RawQual} = \{\texttt{imm}, \texttt{mut}\}$$
$$\text{PtrAddr}(\text{Ptr@Valid}(addr)) = addr$$
$$\text{PtrAddr}(\text{Ptr@Null}(addr)) = addr$$
$$\text{PtrAddr}(\text{Ptr@Expired}(addr)) = addr$$
$$\text{PtrAddr}(\text{RawPtr}(q, addr)) = addr$$

$$\text{AddrTag}(Sigma, addr) = \begin{cases}
\text{ScopeTag}(sid) & addr = \text{BindAddr}(\langle sid, bind\_id, x \rangle) \\
\text{RegionTag}(tag) & \text{AddrTags}(Sigma)(addr) = \text{RegionTag}(tag) \\
\bot & \text{otherwise}
\end{cases}$$
$$\text{TagActive}(Sigma, \text{RegionTag}(tag)) \iff \exists e \in \text{RegionStack}(Sigma).\ \text{RegionTagOf}(e) = tag$$
$$\text{TagActive}(Sigma, \text{ScopeTag}(sid)) \iff \exists e \in \text{ScopeStack}(Sigma).\ \text{ScopeId}(e) = sid$$
$$\text{PtrState}(Sigma, \text{Ptr@Null}(\_)) = \texttt{Null}$$
$$\text{PtrState}(Sigma, \text{Ptr@Expired}(\_)) = \texttt{Expired}$$
$$\text{PtrState}(Sigma, \text{Ptr@Valid}(addr)) = \texttt{Valid}$$
$$\text{DynAddrState}(Sigma, addr) = \begin{cases}
\texttt{Valid} & \text{AddrTag}(Sigma, addr) = \bot \\
\texttt{Valid} & \text{AddrTag}(Sigma, addr) = tag \ne \bot \land \text{TagActive}(Sigma, tag) \\
\texttt{Expired} & \text{AddrTag}(Sigma, addr) = tag \ne \bot \land \neg \text{TagActive}(Sigma, tag)
\end{cases}$$
$$\text{BindAddr}(\langle sid, bind\_id, x \rangle) \in \text{Addr}$$
$$\text{AddrOfBind}(b) = \begin{cases}
addr & \text{BindingValue}(Sigma, b) = \text{Alias}(addr) \\
\text{BindAddr}(b) & \text{BindingValue}(Sigma, b) \ne \text{Alias}(\_)
\end{cases}$$
$$\text{AddrOfBind}(x) = addr \iff \exists b.\ \text{LookupBind}(\sigma, x) = b \land \text{AddrOfBind}(b) = addr$$

**(ReadPtr-Safe)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr \quad \text{ReadAddr}(\sigma, addr) = v}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(WritePtr-Safe)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (ok, \sigma')}$$

**(ReadPtr-Null)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(ReadPtr-Expired)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePtr-Null)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WritePtr-Expired)**
$$\frac{\text{PtrState}(\sigma, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(ReadPtr-Raw)**
$$\frac{v_{ptr} = \text{RawPtr}(q, addr) \quad \text{ReadAddr}(\sigma, addr) = v}{\Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(WritePtr-Raw)**
$$\frac{v_{ptr} = \text{RawPtr}(\texttt{mut}, addr) \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma) \Downarrow (ok, \sigma')}$$

$$\text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)\ \text{undefined} \iff \text{ReadAddr}(\sigma, addr)\ \text{undefined}$$
$$\text{WritePtrSigma}(\text{RawPtr}(\texttt{imm}, addr), v, \sigma)\ \text{undefined}$$
$$\text{DynamicUndefined}(\text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)) \iff \text{ReadPtrSigma}(\text{RawPtr}(q, addr), \sigma)\ \text{undefined}$$
$$\text{DynamicUndefined}(\text{WritePtrSigma}(\text{RawPtr}(\texttt{imm}, addr), v, \sigma))$$


**(AddrOf-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{AddrOfBind}(b) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(addr), \sigma)}$$

**(AddrOf-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(AddrOf-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(addr), \sigma)}$$

**(AddrOf-Field)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_b = \text{ExprType}(p) \quad \text{FieldAddr}(T_b, addr, f) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Val}(addr'), \sigma_1)}$$

**(AddrOf-Field-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Tuple)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_b = \text{ExprType}(p) \quad \text{TupleAddr}(T_b, addr, i) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Val}(addr'), \sigma_1)}$$

**(AddrOf-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Index)**
**(AddrOfSigma-Index-Ok)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexLen}(\sigma_2, addr) = L \quad \Gamma \vdash \text{CheckIndex}(L, v_i) \Downarrow ok \quad T_b = \text{ExprType}(p) \quad \text{IndexAddr}(T_b, addr, v_i) = addr'}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(addr'), \sigma_2)}$$

**(AddrOfSigma-Index-OOB)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{IndexLen}(\sigma_2, addr))}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(AddrOf-Index-Ctrl-Base)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(AddrOf-Index-Ctrl-Idx)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{AddrOfSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(AddrOf-Deref-Safe)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Valid} \quad \text{PtrAddr}(v_{ptr}) = addr}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}$$

**(AddrOf-Deref-Null)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Null}}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(AddrOf-Deref-Expired)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \text{PtrState}(\sigma_1, v_{ptr}) = \texttt{Expired}}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(AddrOf-Deref-Raw)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(\text{RawPtr}(q, addr)), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}$$

**(AddrOf-Deref-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{AddrOfSigma}(\text{Deref}(p), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ReadPlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldValue}(v_p, f) = v_f}{\Gamma \vdash \text{ReadPlaceSigma}(\text{FieldAccess}(p, f), \sigma) \Downarrow (\text{Val}(v_f), \sigma_1)}$$

**(ReadPlace-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleValue}(v_p, i) = v_i}{\Gamma \vdash \text{ReadPlaceSigma}(\text{TupleAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_i), \sigma_1)}$$

**(ReadPlace-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_p, v_i) = v_e}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_e), \sigma_2)}$$

**(ReadPlace-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(ReadPlace-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceValue}(v_p, v_r) = v_s}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Val}(v_s), \sigma_2)}$$

**(ReadPlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{ReadPlaceSigma}(\text{IndexAccess}(p, i), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(ReadPlace-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{ReadPlaceSigma}(\text{Deref}(p), \sigma) \Downarrow (out, \sigma_2)}$$

**(WritePlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldValue}(v_p, f) = v_f \quad T_f = \text{ExprType}(\text{FieldAccess}(p, f)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_f, v_f, \sigma_1) \Downarrow \sigma_1' \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1') \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{FieldAccess}(p, f), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WritePlace-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleValue}(v_p, i) = v_i \quad T_i = \text{ExprType}(\text{TupleAccess}(p, i)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_i, v_i, \sigma_1) \Downarrow \sigma_1' \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1') \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{TupleAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WritePlace-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_p, v_i) = v_e \quad T_e = \text{ExprType}(\text{IndexAccess}(p, i)) \quad \Gamma \vdash \text{DropSubvalue}(p, T_e, v_e, \sigma_2) \Downarrow \sigma_2' \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2') \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WritePlace-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WritePlace-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start}{\Gamma \vdash \text{WritePlaceSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WritePlace-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSigma}(\text{Deref}(p), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Ident)**
$$\frac{\text{LookupBind}(\sigma, x) = b \quad \text{UpdateVal}(\sigma, b, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

**(WriteSub-Ident-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(WriteSub-Ident-Path)**
$$\frac{\Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad name = (\text{ent}.\text{target\_opt}\ \text{if present, else}\ x) \quad \text{PathOfModule}(mp) = path \quad \text{StaticAddr}(path, name) = addr \quad \text{WriteAddr}(\sigma, addr, v) \Downarrow \sigma'}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Identifier}(x), v, \sigma) \Downarrow (ok, \sigma')}$$

**(WriteSub-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{FieldUpdate}(v_p, f, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{FieldAccess}(p, f), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Tuple)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \text{TupleUpdate}(v_p, i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{TupleAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(WriteSub-Index)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexUpdate}(v_p, v_i, v) = v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WriteSub-Index-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \neg(0 \le v_i < \text{Len}(v_p))}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Index-Range)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n = end - start \quad \text{SliceUpdate}(v_p, start, v) \Downarrow v_p' \quad \Gamma \vdash \text{WritePlaceSubSigma}(p, v_p', \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (sout, \sigma_3)}$$

**(WriteSub-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = \bot}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Index-Range-Len)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(i, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_p)) = (start, end) \quad \text{SliceLen}(v) = n \quad n \ne end - start}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{IndexAccess}(p, i), v, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(WriteSub-Deref)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{WritePtrSigma}(v_{ptr}, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{WritePlaceSubSigma}(\text{Deref}(p), v, \sigma) \Downarrow (sout, \sigma_2)}$$

**(MovePlace-Whole)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{FieldHead}(p) = \bot \quad \text{LookupBind}(\sigma_1, \text{PlaceRoot}(p)) = b \quad \text{BindInfo}(b).\text{mov} = \text{mov} \quad \text{SetState}(\sigma_1, b, \text{Moved}) \Downarrow \sigma_2}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(MovePlace-Field)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{FieldHead}(p) = f \quad \text{LookupBind}(\sigma_1, \text{PlaceRoot}(p)) = b \quad \text{BindInfo}(b).\text{mov} = \text{mov} \quad \text{BindState}(\sigma_1, b) = s \quad \text{PM}(s, f) = s' \quad \text{SetState}(\sigma_1, b, s') \Downarrow \sigma_2}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(MovePlace-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$


**Stateful Expression Evaluation.**

**EvalJudg.**
$$\text{EvalJudg} = \{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma')\}$$

**Range Helpers.**

$$\text{RangeVal} = \{\text{RangeVal}(k, lo\_opt, hi\_opt) \mid k \in \text{RangeKind}\}$$
$$\text{Inc}(v) = v' \iff v=\text{IntVal}(t, x) \land x'=x+1 \land \text{InRange}(x', t) \land v'=\text{IntVal}(t, x')$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Exclusive}, s, e), L) = (start, end) \iff \text{IndexNum}(s)=start \land \text{IndexNum}(e)=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Inclusive}, s, e), L) = (start, end) \iff \text{IndexNum}(s)=start \land \text{Inc}(e)=e' \land \text{IndexNum}(e')=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{From}, s, \bot), L) = (start, L) \iff \text{IndexNum}(s)=start$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{To}, \bot, e), L) = (0, end) \iff \text{IndexNum}(e)=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{ToInclusive}, \bot, e), L) = (0, end) \iff \text{Inc}(e)=e' \land \text{IndexNum}(e')=end$$
$$\text{SliceBoundsRaw}(\text{RangeVal}(\text{Full}, \bot, \bot), L) = (0, L)$$
$$\text{SliceBounds}(r, L) = (start, end) \iff \text{SliceBoundsRaw}(r, L) = (start, end) \land 0 \le start \le end \le L$$
$$\text{SliceBounds}(r, L) = \bot \iff \text{SliceBoundsRaw}(r, L) = \bot \lor (\exists start,end.\ \text{SliceBoundsRaw}(r, L) = (start, end) \land \neg(0 \le start \le end \le L))$$

**EvalOptJudg.**
$$\text{EvalOptJudg} = \{\Gamma \vdash \text{EvalOptSigma}(e\_opt, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalOptSigma-None)**
$$\frac{}{\Gamma \vdash \text{EvalOptSigma}(\bot, \sigma) \Downarrow (\text{Val}(\bot), \sigma)}$$

**(EvalOptSigma-Some)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{EvalOptSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(EvalOptSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalOptSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Range)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Val}(v_{lo}), \sigma_1) \quad \Gamma \vdash \text{EvalOptSigma}(hi\_opt, \sigma_1) \Downarrow (\text{Val}(v_{hi}), \sigma_2) \quad r = \text{RangeVal}(kind, v_{lo}, v_{hi})}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Val}(r), \sigma_2)}$$

**(EvalSigma-Range-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Range-Ctrl-Hi)**
$$\frac{\Gamma \vdash \text{EvalOptSigma}(lo\_opt, \sigma_0) \Downarrow (\text{Val}(v_{lo}), \sigma_1) \quad \Gamma \vdash \text{EvalOptSigma}(hi\_opt, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Range}(kind, lo\_opt, hi\_opt), \sigma_0) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**Value Constructors and Accessors.**

**Values.**
$$\text{BoolVal}(b) = b \iff b \in \{\text{true},\ \text{false}\}$$
$$\text{CharVal}(u) = u \iff u \in \text{UnicodeScalar}$$
$$\text{UnitVal} = ()$$
$$\text{IntVal}(t, x)\ \text{defined} \iff t \in \text{IntTypes} \land \text{InRange}(x, t)$$
$$\text{IntValType}(\text{IntVal}(t, x)) = t$$
$$\text{IntValValue}(\text{IntVal}(t, x)) = x$$
$$\text{FloatVal}(t, v)\ \text{defined} \iff t \in \text{FloatTypes} \land v \in \text{FloatValueSet}(t)$$
$$\text{FloatValType}(\text{FloatVal}(t, v)) = t$$
$$\text{FloatValValue}(\text{FloatVal}(t, v)) = v$$
$$\text{PtrVal}(s, addr)\ \text{defined} \iff s \in \text{PtrStateSet}$$
$$\text{Ptr@Valid}(addr) = \text{PtrVal}(\texttt{Valid}, addr)$$
$$\text{Ptr@Null}(addr) = \text{PtrVal}(\texttt{Null}, addr)$$
$$\text{Ptr@Expired}(addr) = \text{PtrVal}(\texttt{Expired}, addr)$$
$$\text{TupleVal} = \{(v_1,\ldots,v_n) \mid n \ge 0\}$$
$$\text{ArrayVal} = \{[v_1,\ldots,v_n] \mid n \ge 0\}$$
$$\text{ModalVal}(S, v) = \langle S, v \rangle$$
$$\text{Value} = \{\text{BoolVal}(b) \mid b \in \{\text{true},\ \text{false}\}\} \cup \{\text{CharVal}(u) \mid u \in \text{UnicodeScalar}\} \cup \{\text{UnitVal}\} \cup \{\text{IntVal}(t, x) \mid \text{IntVal}(t, x)\ \text{defined}\} \cup \{\text{FloatVal}(t, v) \mid \text{FloatVal}(t, v)\ \text{defined}\} \cup \{\text{PtrVal}(s, addr) \mid \text{PtrVal}(s, addr)\ \text{defined}\} \cup \{\text{RawPtr}(q, addr)\} \cup \text{TupleVal} \cup \text{ArrayVal} \cup \{\text{RecordValue}(tr, fs)\} \cup \{\text{EnumValue}(path, payload)\} \cup \text{RangeVal} \cup \{\text{SliceValue}(v, r) \mid \text{SliceValue}(v, r)\ \text{defined}\} \cup \{\text{ModalVal}(S, v)\} \cup \{\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)\} \cup \texttt{string@Managed} \cup \texttt{string@View} \cup \texttt{bytes@Managed} \cup \texttt{bytes@View}$$

**EvalListJudg.**
$$\text{EvalListJudg} = \{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalListSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalListSigma}([], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalListSigma-Cons)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalListSigma}(es, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalListSigma}(e::es, \sigma) \Downarrow (\text{Val}([v] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalListSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalListSigma}(e::es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalFieldInitsSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalFieldInitsSigma}([], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalFieldInitsSigma-Cons)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fs, \sigma_1) \Downarrow (\text{Val}(\vec{f}), \sigma_2)}{\Gamma \vdash \text{EvalFieldInitsSigma}([\langle f, e \rangle] \mathbin{+\!\!+} fs, \sigma) \Downarrow (\text{Val}([\langle f, v \rangle] \mathbin{+\!\!+} \vec{f}), \sigma_2)}$$

**(EvalFieldInitsSigma-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalFieldInitsSigma}([\langle f, e \rangle] \mathbin{+\!\!+} fs, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{BoolValue}(lit) = \text{true} \iff lit.\text{kind}=\text{BoolLiteral} \land \text{Lexeme}(lit)=\texttt{"true"}$$
$$\text{BoolValue}(lit) = \text{false} \iff lit.\text{kind}=\text{BoolLiteral} \land \text{Lexeme}(lit)=\texttt{"false"}$$
$$\text{CharValue}(lit) = u \iff lit.\text{kind}=\text{CharLiteral} \land T=\text{Lexeme}(lit) \land \text{StringBytesFrom}(T,1,|T|-1)=bytes \land \text{DecodeUTF8}(bytes)=[u]$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(\texttt{"bool"})) = \text{BoolVal}(b) \iff \ell.\text{kind} = \text{BoolLiteral} \land \text{BoolValue}(\ell) = b$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(\texttt{"char"})) = \text{CharVal}(c) \iff \ell.\text{kind} = \text{CharLiteral} \land \text{CharValue}(\ell) = c$$
$$\text{LiteralValue}(\ell, \text{TypeString}(\texttt{@View})) = v \iff \ell.\text{kind} = \text{StringLiteral} \land \text{ViewBytes}(v) = \text{StringBytes}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(t)) = \text{IntVal}(t, x) \iff \ell.\text{kind} = \text{IntLiteral} \land t \in \text{IntTypes} \land x = \text{IntValue}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypePrim}(t)) = \text{FloatVal}(t, v) \iff \ell.\text{kind} = \text{FloatLiteral} \land t \in \text{FloatTypes} \land v = \text{FloatValue}(\ell)$$
$$\text{LiteralValue}(\ell, \text{TypeRawPtr}(q, U)) = \text{RawPtr}(q, 0x0) \iff \ell.\text{kind} = \text{NullLiteral}$$
$$\text{EnumPayloadVal} = \{\bot,\ \text{TuplePayload}(\vec{v}),\ \text{RecordPayload}(\vec{f})\}$$
$$\text{RecordValue}(tr, fs)\ \text{defined}$$
$$\text{EnumValue}(path, payload)\ \text{defined} \iff payload \in \text{EnumPayloadVal}$$

**(EvalSigma-Literal)**
$$\frac{T = \text{ExprType}(\text{Literal}(\ell)) \quad \text{LiteralValue}(\ell, T) = v}{\Gamma \vdash \text{EvalSigma}(\text{Literal}(\ell), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-Ident-Poison)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Ident-Poison-RecordCtor)**
$$\frac{\text{LookupBind}(\sigma, x)\ \text{undefined} \quad \Gamma \vdash \text{ResolveValueName}(x) \Uparrow \quad \Gamma \vdash \text{ResolveTypeName}(x) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Ident)**
$$\frac{\text{LookupVal}(\sigma, x) = v}{\Gamma \vdash \text{EvalSigma}(\text{Identifier}(x), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-Path-Poison)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Downarrow ent \quad ent.\text{origin\_opt} = mp \quad \text{PoisonedModule}(\sigma, \text{PathOfModule}(mp))}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Path-Poison-RecordCtor)**
$$\frac{\Gamma \vdash \text{ResolveQualified}(path, name, \text{ValueKind}) \Uparrow \quad \Gamma \vdash \text{ResolveRecordPath}(path, name) \Downarrow p \quad \text{SplitLast}(p) = (mp, \_) \quad \text{PoisonedModule}(\sigma, mp)}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Path)**
$$\frac{\text{LookupValPath}(\sigma, path, name) = v}{\Gamma \vdash \text{EvalSigma}(\text{Path}(path, name), \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(EvalSigma-ErrorExpr)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{ErrorExpr}(\_), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**(EvalSigma-Tuple)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleExpr}(es), \sigma) \Downarrow (\text{Val}((v_1,\ldots,v_n)), \sigma_1)}$$

**(EvalSigma-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleExpr}(es), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Array)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{ArrayExpr}(es), \sigma) \Downarrow (\text{Val}([v_1,\ldots,v_n]), \sigma_1)}$$

**(EvalSigma-Array-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{ArrayExpr}(es), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Record)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{RecordExpr}(tr, fields), \sigma) \Downarrow (\text{Val}(\text{RecordValue}(tr, \vec{f})), \sigma_1)}$$

**(EvalSigma-Record-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{RecordExpr}(tr, fields), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Enum-Unit)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \bot), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \bot)), \sigma)}$$

**(EvalSigma-Enum-Tuple)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Val}(\vec{v}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Paren}(es)), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \text{TuplePayload}(\vec{v}))), \sigma_1)}$$

**(EvalSigma-Enum-Tuple-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalListSigma}(es, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Paren}(es)), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Enum-Record)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Brace}(fields)), \sigma) \Downarrow (\text{Val}(\text{EnumValue}(path, \text{RecordPayload}(\vec{f}))), \sigma_1)}$$

**(EvalSigma-Enum-Record-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{EnumLiteral}(path, \text{Brace}(fields)), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-FieldAccess)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \text{FieldValue}(v_b, f) = v_f}{\Gamma \vdash \text{EvalSigma}(\text{FieldAccess}(base, f), \sigma) \Downarrow (\text{Val}(v_f), \sigma_1)}$$

**(EvalSigma-FieldAccess-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{FieldAccess}(base, f), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-TupleAccess)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \text{TupleValue}(v_b, i) = v_i}{\Gamma \vdash \text{EvalSigma}(\text{TupleAccess}(base, i), \sigma) \Downarrow (\text{Val}(v_i), \sigma_1)}$$

**(EvalSigma-TupleAccess-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TupleAccess}(base, i), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Index)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexValue}(v_b, v_i) = v_e}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Val}(v_e), \sigma_2)}$$

**(EvalSigma-Index-OOB)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_i), \sigma_2) \quad \text{IndexNum}(v_i)=i \quad \neg(0 \le i < \text{Len}(v_b))}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Index-Range)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceValue}(v_b, v_r) = v_s}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Val}(v_s), \sigma_2)}$$

**(EvalSigma-Index-Range-OOB)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Val}(v_r), \sigma_2) \quad \text{SliceBounds}(v_r, \text{Len}(v_b)) = \bot}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Index-Ctrl-Base)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Index-Ctrl-Idx)**
$$\frac{\Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(idx, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IndexAccess}(base, idx), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**Unary, Binary, Cast, Transmute, Propagate.**

$$\text{RetType}(\Gamma) \in \text{Type}$$
$$\text{OpJudg} = \{\text{UnOp}(op, v) \Downarrow v',\ \text{BinOp}(op, v_1, v_2) \Downarrow v\}$$
$$\text{NumericValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{NumericTypes}$$
$$\text{IntValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{IntTypes}$$
$$\text{FloatValue}(v, t) \iff \text{ValueType}(v) = \text{TypePrim}(t) \land t \in \text{FloatTypes}$$
$$\text{SignedIntValue}(v) \iff \exists t.\ t \in \text{SignedIntTypes} \land \text{ValueType}(v) = \text{TypePrim}(t)$$
$$\text{SignedTypeOf}(v) = t \iff t \in \text{SignedIntTypes} \land \text{ValueType}(v) = \text{TypePrim}(t)$$
$$\text{U32Value}(v) \iff \text{ValueType}(v) = \text{TypePrim}(\texttt{"u32"})$$
$$\text{EqValue}(v_1, v_2) \iff \exists T.\ \text{ValueType}(v_1) = T \land \text{ValueType}(v_2) = T \land \text{EqType}(T)$$
$$\text{OrdValue}(v_1, v_2) \iff \exists T.\ \text{ValueType}(v_1) = T \land \text{ValueType}(v_2) = T \land \text{OrdType}(T)$$
$$\text{IsNaN}(t, v) \iff t \in \text{FloatTypes} \land v=\text{FloatVal}(t, x) \land \text{IEEE754Encode}(t, x) = \text{CanonicalNaNBits}(t)$$
$$\text{OrdScalar}(v) = x \iff (\exists t.\ v=\text{IntVal}(t, x) \land t \in \text{IntTypes}) \lor (\exists u.\ v=\text{CharVal}(u) \land x=u)$$
$$\text{Cmp}(\texttt{"=="}, v_1, v_2) = b \iff \text{EqValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg \exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=(v_1=v_2)))$$
$$\text{Cmp}(\texttt{"!="}, v_1, v_2) = b \iff \text{EqValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{true}) \lor (\neg \exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land (\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=(v_1\ne v_2)))$$
$$\text{Cmp}(\texttt{"<"}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 < x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 < x_2)))$$
$$\text{Cmp}(\texttt{"<="}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 \le x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 \le x_2)))$$
$$\text{Cmp}(\texttt{">"}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 > x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 > x_2)))$$
$$\text{Cmp}(\texttt{">="}, v_1, v_2) = b \iff \text{OrdValue}(v_1, v_2) \land ((\exists t.\ \text{FloatValue}(v_1, t) \land \text{FloatValue}(v_2, t) \land ((\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land b=\text{false}) \lor (\neg(\text{IsNaN}(t, v_1) \lor \text{IsNaN}(t, v_2)) \land x_1=\text{FloatValValue}(v_1) \land x_2=\text{FloatValValue}(v_2) \land b=(x_1 \ge x_2)))) \lor (\exists x_1,x_2.\ \text{OrdScalar}(v_1)=x_1 \land \text{OrdScalar}(v_2)=x_2 \land b=(x_1 \ge x_2)))$$
$$\text{BitAt}(u, i) = b \iff b \in \{0,1\} \land \exists q,r.\ u = q\cdot 2^{i+1} + b\cdot 2^i + r \land 0 \le r < 2^i$$
$$\text{BitNot}(v) = v' \iff \exists t,x,w,u,u'.\ v=\text{IntVal}(t, x) \land w=\text{IntWidth}(t) \land u=\text{ToUnsigned}(w, x) \land u' = (2^w-1)-u \land ((t \in \text{SignedIntTypes} \land v'=\text{IntVal}(t, \text{ToSigned}(w, u'))) \lor (t \in \text{UnsignedIntTypes} \land v'=\text{IntVal}(t, u')) )$$
$$\text{BitOp}(op, t, v_1, v_2) = v \iff v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(t, x_2) \land w=\text{IntWidth}(t) \land u_1=\text{ToUnsigned}(w, x_1) \land u_2=\text{ToUnsigned}(w, x_2) \land u=\sum_{i=0}^{w-1} b_i 2^i \land \forall i.\ 0 \le i < w \Rightarrow ((op=\texttt{"&"} \land b_i=\text{BitAt}(u_1,i)\cdot \text{BitAt}(u_2,i)) \lor (op=\texttt{"|"} \land b_i=\max(\text{BitAt}(u_1,i),\text{BitAt}(u_2,i))) \lor (op=\texttt{"^"} \land b_i=(\text{BitAt}(u_1,i)+\text{BitAt}(u_2,i)) \bmod 2)) \land ((t \in \text{SignedIntTypes} \land v=\text{IntVal}(t, \text{ToSigned}(w, u))) \lor (t \in \text{UnsignedIntTypes} \land v=\text{IntVal}(t, u)))$$
$$\text{ShiftOp}(op, t, v_1, v_2) = v \iff v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(\texttt{"u32"}, n) \land w=\text{IntWidth}(t) \land 0 \le n < w \land u_1=\text{ToUnsigned}(w, x_1) \land ((op=\texttt{"<<"} \land u=(u_1 \cdot 2^n) \bmod 2^w) \lor (op=\texttt{">>"} \land u=\lfloor u_1 / 2^n \rfloor)) \land ((t \in \text{SignedIntTypes} \land v=\text{IntVal}(t, \text{ToSigned}(w, u))) \lor (t \in \text{UnsignedIntTypes} \land v=\text{IntVal}(t, u)))$$
$$\text{PowInt}(x, n) = y \iff n \in \mathbb{N} \land ((n=0 \land y=1) \lor (n>0 \land y = x \cdot \text{PowInt}(x, n-1)))$$
$$\text{PowFloat}(t, x_1, x_2) = x \iff t \in \text{FloatTypes} \land x_1 \in \text{FloatValueSet}(t) \land x_2 \in \text{FloatValueSet}(t) \land x\ \text{is the IEEE 754-2019 pow result of}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)$$
$$\text{IEEEArith}(op, t, v_1, v_2) = v \iff v_1=\text{FloatVal}(t, x_1) \land v_2=\text{FloatVal}(t, x_2) \land op \in \text{ArithOps} \land ((op \in \{\texttt{"+"},\texttt{"-"},\texttt{"*"},\texttt{"/"}\} \land x\ \text{is the IEEE 754-2019 result of applying}\ op\ \text{to}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)) \lor (op=\texttt{"%"} \land x\ \text{is the IEEE 754-2019 remainder of}\ x_1,\ x_2\ \text{in format}\ \text{FloatFormat}(t)) \lor (op=\texttt{"**"} \land \text{PowFloat}(t, x_1, x_2)=x)) \land v=\text{FloatVal}(t, x)$$
$$\forall t \in \text{FloatTypes}, v_1, v_2, op \in \text{ArithOps}.\ \exists v.\ \text{IEEEArith}(op, t, v_1, v_2) = v$$
$$\text{UnOp}(\texttt{"!"}, \text{false}) \Downarrow \text{true}$$
$$\text{UnOp}(\texttt{"!"}, \text{true}) \Downarrow \text{false}$$
$$\text{UnOp}(\texttt{"!"}, v) \Downarrow v' \iff \text{IntValue}(v, t) \land v' = \text{BitNot}(v)$$
$$\text{UnOp}(\texttt{"-"}, v) \Downarrow v' \iff v=\text{IntVal}(t, x) \land t \in \text{SignedIntTypes} \land x'=-x \land \text{InRange}(x', t) \land v'=\text{IntVal}(t, x')$$
$$\text{UnOp}(\texttt{"-"}, v) \Downarrow v' \iff v=\text{FloatVal}(t, x) \land v'=\text{FloatVal}(t, -x)$$
$$\text{UnOp}(\texttt{"widen"}, v) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{ArithOps} \land \text{NumericValue}(v_1, t) \land \text{NumericValue}(v_2, t) \land \text{ArithEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{BitOps} \land \text{IntValue}(v_1, t) \land \text{IntValue}(v_2, t) \land \text{BitEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \text{ShiftOps} \land \text{IntValue}(v_1, t) \land \text{U32Value}(v_2) \land \text{ShiftEval}(op, t, v_1, v_2) \Downarrow v$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \{\texttt{"=="},\texttt{"!="}\} \land \text{EqValue}(v_1, v_2) \land v = \text{Cmp}(op, v_1, v_2)$$
$$\text{BinOp}(op, v_1, v_2) \Downarrow v \iff op \in \{\texttt{"<"},\texttt{"<="},\texttt{">"},\texttt{">="}\} \land \text{OrdValue}(v_1, v_2) \land v = \text{Cmp}(op, v_1, v_2)$$
$$\text{ArithEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v_1=\text{IntVal}(t, x_1) \land v_2=\text{IntVal}(t, x_2) \land ((op \in \{\texttt{"+"},\texttt{"-"},\texttt{"*"}\} \land x = x_1\ \text{op}\ x_2) \lor (op \in \{\texttt{"/"},\texttt{"%"}\} \land x_2 \ne 0 \land x = x_1\ \text{op}\ x_2) \lor (op=\texttt{"**"} \land x_2 \ge 0 \land \text{PowInt}(x_1, x_2)=x)) \land \text{InRange}(x, t) \land v=\text{IntVal}(t, x)$$
$$\text{ArithEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{FloatTypes} \land v = \text{IEEEArith}(op, t, v_1, v_2)$$
$$\text{BitEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v = \text{BitOp}(op, t, v_1, v_2)$$
$$\text{ShiftEval}(op, t, v_1, v_2) \Downarrow v \iff t \in \text{IntTypes} \land v = \text{ShiftOp}(op, t, v_1, v_2)$$

**(EvalSigma-Unary)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{UnOp}(op, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Unary-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{UnOp}(op, v)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalSigma-Unary-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Unary}(op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Bin-And-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"&&"}, e_1, e_2), \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}$$

**(EvalSigma-Bin-And-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"&&"}, e_1, e_2), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Bin-Or-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"||"}, e_1, e_2), \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1)}$$

**(EvalSigma-Bin-Or-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(\texttt{"||"}, e_1, e_2), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Binary)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Val}(v_2), \sigma_2) \quad \text{BinOp}(op, v_1, v_2) \Downarrow v}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(EvalSigma-Binary-Panic)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Val}(v_2), \sigma_2) \quad \text{BinOp}(op, v_1, v_2)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_2)}$$

**(EvalSigma-Bin-Ctrl-L)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Bin-Ctrl-R)**
$$\frac{op \notin \{\texttt{"&&"}, \texttt{"||"}\} \quad \Gamma \vdash \text{EvalSigma}(e_1, \sigma) \Downarrow (\text{Val}(v_1), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e_2, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Binary}(op, e_1, e_2), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

$$\text{ExprType} : \text{Expr} \to \text{Type}$$
$$R = \text{RetType}(\Gamma)$$

$$\text{CastValJudg} = \{\text{CastVal}(S, T, v) \Downarrow v'\}$$
$$\text{UnsignedIntTypes} = \{\texttt{u8},\ \texttt{u16},\ \texttt{u32},\ \texttt{u64},\ \texttt{u128},\ \texttt{usize}\}$$
$$\text{IntWidth}(\texttt{i8})=8 \quad \text{IntWidth}(\texttt{i16})=16 \quad \text{IntWidth}(\texttt{i32})=32 \quad \text{IntWidth}(\texttt{i64})=64 \quad \text{IntWidth}(\texttt{i128})=128$$
$$\text{IntWidth}(\texttt{u8})=8 \quad \text{IntWidth}(\texttt{u16})=16 \quad \text{IntWidth}(\texttt{u32})=32 \quad \text{IntWidth}(\texttt{u64})=64 \quad \text{IntWidth}(\texttt{u128})=128$$
$$\text{IntWidth}(\texttt{isize})=8 \times \text{PointerSize} \quad \text{IntWidth}(\texttt{usize})=8 \times \text{PointerSize}$$
$$\text{Mod}_w(x) = x \bmod 2^w$$
$$\text{ToSigned}(w, x) = y \iff y \in [-2^{w-1}, 2^{w-1}-1] \land y \equiv x \pmod{2^w}$$
$$\text{ToUnsigned}(w, x) = y \iff y \in [0, 2^w-1] \land y \equiv x \pmod{2^w}$$
$$\text{CodePoint} : \texttt{char} \to \mathbb{N}$$
$$\text{IsScalar}(u) \iff u \in \text{CharValueRange}$$
$$\text{IntToFloat}(t, x)\ \text{function}$$
$$\text{FloatToFloat}(s, t, v)\ \text{function}$$
$$\text{Trunc}(v)\ \text{function}$$
$$\text{CharOf}(u) = u \iff \text{IsScalar}(u)$$
$$\text{CodePoint}(\text{CharOf}(u)) = u \quad (\text{IsScalar}(u))$$
$$\text{IEEE754Bits}(t, v) = bits \iff v \in \text{FloatValueSet}(t) \land \text{IEEE754Encode}(t, v) = bits$$
$$\text{IntToFloat}(t, x) = v \iff v \in \text{NonNaNValueSet}(t) \land \forall v' \in \text{NonNaNValueSet}(t).\ |v-x| < |v'-x| \lor (|v-x|=|v'-x| \land \text{EvenSignificandLSB}(t, v))$$
$$\text{FloatToFloat}(s, t, v) = v' \iff \text{IEEE754Encode}(s, v) = \text{CanonicalNaNBits}(s) \land v' = \text{CanonicalNaN}(t)$$
$$\text{FloatToFloat}(s, t, v) = v' \iff \text{IEEE754Encode}(s, v) \ne \text{CanonicalNaNBits}(s) \land v' \in \text{NonNaNValueSet}(t) \land \forall u \in \text{NonNaNValueSet}(t).\ |v'-v| < |u-v| \lor (|v'-v|=|u-v| \land \text{EvenSignificandLSB}(t, v'))$$
$$\text{Trunc}(v) = \begin{cases}
\lfloor v \rfloor & v \ge 0\\
\lceil v \rceil & v < 0
\end{cases}$$

**(CastVal-Id)**
$$\frac{\text{StripPerm}(S) = \text{StripPerm}(T)}{\text{CastVal}(S, T, v) \Downarrow v}$$

**(CastVal-Int-Int-Signed)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{SignedIntTypes} \quad v=\text{IntVal}(s, x) \quad w=\text{IntWidth}(t) \quad x'=\text{ToSigned}(w, x) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Int-Unsigned)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{UnsignedIntTypes} \quad v=\text{IntVal}(s, x) \quad w=\text{IntWidth}(t) \quad x'=\text{ToUnsigned}(w, x) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Float)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{IntTypes} \quad t \in \text{FloatTypes} \quad v=\text{IntVal}(s, x) \quad v'=\text{FloatVal}(t, \text{IntToFloat}(t, x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Float-Float)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{FloatTypes} \quad t \in \text{FloatTypes} \quad v=\text{FloatVal}(s, x) \quad v'=\text{FloatVal}(t, \text{FloatToFloat}(s, t, x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Float-Int)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(s) \quad T'=\text{TypePrim}(t) \quad s \in \text{FloatTypes} \quad t \in \text{IntTypes} \quad v=\text{FloatVal}(s, x) \quad x'=\text{Trunc}(x) \quad \text{InRange}(x', t) \quad v'=\text{IntVal}(t, x')}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Bool-Int)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"bool"}) \quad T'=\text{TypePrim}(t) \quad t \in \text{IntTypes} \quad v'=\begin{cases}\text{IntVal}(t, 0) & v=\text{false} \\ \text{IntVal}(t, 1) & v=\text{true}\end{cases}}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Int-Bool)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(t) \quad t \in \text{IntTypes} \quad T'=\text{TypePrim}(\texttt{"bool"}) \quad v=\text{IntVal}(t, x) \quad v'=\begin{cases}\text{false} & x=0 \\ \text{true} & x\ne 0\end{cases}}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-Char-U32)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"char"}) \quad T'=\text{TypePrim}(\texttt{"u32"}) \quad v'=\text{IntVal}(\texttt{"u32"}, \text{CodePoint}(v))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(CastVal-U32-Char)**
$$\frac{S'=\text{StripPerm}(S) \quad T'=\text{StripPerm}(T) \quad S'=\text{TypePrim}(\texttt{"u32"}) \quad T'=\text{TypePrim}(\texttt{"char"}) \quad v=\text{IntVal}(\texttt{"u32"}, x) \quad \text{IsScalar}(x) \quad v'=\text{CharVal}(\text{CharOf}(x))}{\text{CastVal}(S, T, v) \Downarrow v'}$$

**(EvalSigma-Cast)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Cast-Panic)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = \text{ExprType}(e) \quad \text{CastVal}(S, T, v)\ \text{undefined}}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalSigma-Cast-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Cast}(e, T), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{TransmuteVal}(S, T, v) \Downarrow v' \iff \text{ValueBits}(S, v) = bits \land \text{ValueBits}(T, v') = bits$$

**(EvalSigma-Transmute)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad S = t_1 \quad T = t_2 \quad \text{TransmuteVal}(S, T, v) \Downarrow v'}{\Gamma \vdash \text{EvalSigma}(\text{TransmuteExpr}(t_1, t_2, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(EvalSigma-Transmute-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{TransmuteExpr}(t_1, t_2, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{UnionCaseJudg} = \{\text{UnionCase}(v) = \langle T, v_T \rangle\}$$
$$\text{UnionCase}(v) = \langle T, v_T \rangle \iff \exists U,\ bits.\ \text{ValueBits}(\text{TypeUnion}(U), v) = bits \land \text{UnionBits}(U, T, v_T) = bits$$

**(EvalSigma-Propagate-Success)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_s, v_s \rangle}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Val}(v_s), \sigma_1)}$$

**(EvalSigma-Propagate-Error)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad U = \text{ExprType}(e) \quad \text{SuccessMember}(\text{RetType}(\Gamma), U) = T_s \quad \text{UnionCase}(v) = \langle T_e, v_e \rangle \quad T_e \ne T_s}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v_e)), \sigma_1)}$$

**(EvalSigma-Propagate-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Propagate}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Conditionals and Match.**

**(EvalSigma-If-True)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(then\_block, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-If-False-None)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad else\_opt = \bot}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(EvalSigma-If-False-Some)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1) \quad else\_opt = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-If-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{IfExpr}(cond, then\_block, else\_opt), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{ArmResult} = \{\text{Match}(out),\ \text{NoMatch}\}$$
$$\text{MatchArmJudg} = \{\Gamma \vdash \text{MatchArmSigma}(arm, v, \sigma) \Downarrow (res, \sigma')\}$$

**(EvalArmBody-Block)**
$$\frac{body = b \quad \Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalArmBodySigma}(body, \sigma) \Downarrow (out, \sigma')}$$

**(EvalArmBody-Expr)**
$$\frac{body = e \quad \Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalArmBodySigma}(body, \sigma) \Downarrow (out, \sigma')}$$

**(MatchArm-Fail)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v)\ \text{undefined}}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{NoMatch}, \sigma)}$$

**(MatchArm-Guard-False)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Val}(\text{false}), \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, \text{Val}(())) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{NoMatch}, \sigma_3)}$$

**(MatchArm-Guard-True)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Val}(\text{true}), \sigma_2) \quad \Gamma \vdash \text{EvalArmBodySigma}(body, \sigma_2) \Downarrow (out, \sigma_3) \quad \text{BlockExit}(\sigma_3, scope, out) \Downarrow (out', \sigma_4)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_4)}$$

**(MatchArm-NoGuard)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = \bot \quad \Gamma \vdash \text{EvalArmBodySigma}(body, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_3)}$$

**(MatchArm-Ctrl)**
$$\frac{\Gamma \vdash \text{MatchPattern}(pat, v) \Downarrow B \quad \text{BindOrder}(pat, B) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad guard\_opt = g \quad \Gamma \vdash \text{EvalSigma}(g, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, \text{Ctrl}(\kappa)) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{MatchArmSigma}(\langle pat, guard\_opt, body \rangle, v, \sigma) \Downarrow (\text{Match}(out'), \sigma_3)}$$

**(MatchArms-Head)**
$$\frac{\Gamma \vdash \text{MatchArmSigma}(a, v, \sigma) \Downarrow (\text{Match}(out), \sigma_1)}{\Gamma \vdash \text{MatchArmsSigma}(a::as, v, \sigma) \Downarrow (out, \sigma_1)}$$

**(MatchArms-Tail)**
$$\frac{\Gamma \vdash \text{MatchArmSigma}(a, v, \sigma) \Downarrow (\text{NoMatch}, \sigma_1) \quad \Gamma \vdash \text{MatchArmsSigma}(as, v, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{MatchArmsSigma}(a::as, v, \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Match)**
$$\frac{\Gamma \vdash \text{EvalSigma}(scrutinee, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{MatchArmsSigma}(arms, v, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrutinee, arms), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Match-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(scrutinee, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MatchExpr}(scrutinee, arms), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Pointer and Move Expressions.**

**(EvalSigma-PtrNull)**
$$\frac{}{\Gamma \vdash \text{EvalSigma}(\text{PtrNullExpr}, \sigma) \Downarrow (\text{Val}(\text{Ptr@Null}(0x0)), \sigma)}$$

**(EvalSigma-AddressOf)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Val}(addr), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AddressOf}(p), \sigma) \Downarrow (\text{Val}(\text{Ptr@Valid}(addr)), \sigma_1)}$$

**(EvalSigma-AddressOf-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AddressOf}(p), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Deref)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v_{ptr}), \sigma_1) \quad \Gamma \vdash \text{ReadPtrSigma}(v_{ptr}, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Deref}(e), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Deref-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Deref}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Move)**
$$\frac{\Gamma \vdash \text{MovePlaceSigma}(p, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MoveExpr}(p), \sigma) \Downarrow (out, \sigma_1)}$$

**Call and Method Application.**

$$\text{CallJudg} = \{\Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (out, \sigma')\}$$
$$\text{CallTarget}(\text{ProcRef}(proc)) = proc$$
$$\text{CallTarget}(\text{RecordCtor}(p)) = \text{RecordCtor}(p)$$
$$\text{MethodTarget}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T), name) = \text{Dispatch}(T, Cl, name)$$
$$\text{MethodTarget}(v_{\text{self}}, name) = m \land m.\text{body} = \bot \land \neg \exists \vec{v}, v.\ \Gamma \vdash \text{PrimCall}(\text{MethodOwner}(m), \text{MethodName}(m), v_{\text{self}}, \vec{v}) \Downarrow v \Rightarrow \text{IllFormed}(\text{MethodTarget}(v_{\text{self}}, name))$$
$$\text{ArgVal} = \{v,\ \text{Alias}(addr)\}$$
$$\text{BindParams}([\langle mode_1, x_1, T_1 \rangle,\ldots,\langle mode_n, x_n, T_n \rangle], [v_1,\ldots,v_n]) = [\langle x_1, v_1 \rangle,\ldots,\langle x_n, v_n \rangle]$$
$$\text{RecordDefaultInits}(p) = [\langle f_1, e_1 \rangle,\ldots,\langle f_n, e_n \rangle] \iff \text{RecordDecl}(p) = R \land \text{Fields}(R) = [\langle vis_1, f_1, T_1, e_1, span_1, doc_1 \rangle,\ldots,\langle vis_n, f_n, T_n, e_n, span_n, doc_n \rangle] \land \forall i.\ e_i \ne \bot$$
$$\text{ReturnOut}(\text{Val}(v)) = \text{Val}(v)$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Return}(v))) = \text{Val}(v)$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Panic})) = \text{Ctrl}(\text{Panic})$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Abort})) = \text{Ctrl}(\text{Abort})$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Break}(v\_opt))) = \bot$$
$$\text{ReturnOut}(\text{Ctrl}(\text{Continue})) = \bot$$
$$\text{ReturnOut}(out)=\bot \Rightarrow \text{IllFormed}(\text{ReturnOut}(out))$$
$$\text{RecvArgMode}(base) = \texttt{move} \iff \exists p.\ base = \text{MoveExpr}(p)$$
$$\text{RecvArgMode}(base) = \bot \iff \neg \exists p.\ base = \text{MoveExpr}(p)$$

**(EvalArgsSigma-Empty)**
$$\frac{}{\Gamma \vdash \text{EvalArgsSigma}([], [], \sigma) \Downarrow (\text{Val}([]), \sigma)}$$

**(EvalArgsSigma-Cons-Move)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\text{MovedArg}(moved, e), \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}(ps, as, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Val}([v] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalArgsSigma-Cons-Ref)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}(ps, as, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Val}([\text{Alias}(addr)] \mathbin{+\!\!+} \vec{v}), \sigma_2)}$$

**(EvalArgsSigma-Ctrl-Move)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\text{MovedArg}(moved, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \texttt{move}, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalArgsSigma-Ctrl-Ref)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalArgsSigma}([\langle \bot, x, T_p \rangle] \mathbin{+\!\!+} ps,\ [\langle moved, e, \_ \rangle] \mathbin{+\!\!+} as, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalRecvSigma-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Val}(v_{\text{self}}), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{self}} \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ref-Dyn)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T) \quad \text{DynAddrState}(\sigma_1, addr_d) = \texttt{Valid}}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T), \text{Alias}(addr_d) \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ref-Dyn-Expired)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T) \quad \text{DynAddrState}(\sigma_1, addr_d) = \texttt{Expired}}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma_1)}$$

**(EvalRecvSigma-Ref)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad \text{ReadAddr}(\sigma_1, addr) = v_{\text{self}} \quad \neg(\exists Cl, addr_d, T.\ v_{\text{self}} = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr_d), T))}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, \text{Alias}(addr) \rangle), \sigma_1)}$$

**(EvalRecvSigma-Ctrl-Move)**
$$\frac{mode = \texttt{move} \quad \Gamma \vdash \text{EvalSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalRecvSigma-Ctrl-Ref)**
$$\frac{mode = \bot \quad \Gamma \vdash \text{AddrOfSigma}(base, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{RegionProcParams}(name) = params \iff \text{RegionProcSig}(\texttt{Region::}name) = \langle params, ret \rangle$$

**(ApplyRegionProc-NewScoped)**
$$\frac{name = \texttt{new\_scoped} \quad \vec{v} = [opts] \quad \text{RegionNewScoped}(\sigma, opts) \Downarrow (\sigma', v)}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v), \sigma')}$$

**(ApplyRegionProc-Alloc)**
$$\frac{name = \texttt{alloc} \quad \vec{v} = [v_r, v] \quad \text{RegionAllocProc}(\sigma, v_r, v) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Reset)**
$$\frac{name = \texttt{reset\_unchecked} \quad \vec{v} = [v_r] \quad \text{RegionResetProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Freeze)**
$$\frac{name = \texttt{freeze} \quad \vec{v} = [v_r] \quad \text{RegionFreezeProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Thaw)**
$$\frac{name = \texttt{thaw} \quad \vec{v} = [v_r] \quad \text{RegionThawProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyRegionProc-Free)**
$$\frac{name = \texttt{free\_unchecked} \quad \vec{v} = [v_r] \quad \text{RegionFreeProc}(\sigma, v_r) \Downarrow (\sigma', v')}{\Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma) \Downarrow (\text{Val}(v'), \sigma')}$$

**(ApplyProcSigma)**
$$\frac{\text{BindParams}(proc.\text{params}, \vec{v}) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad \Gamma \vdash \text{EvalBlockBodySigma}(proc.\text{body}, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma) \Downarrow (\text{ReturnOut}(out'), \sigma_3)}$$

**(ApplyRecordCtorSigma)**
$$\frac{\text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Val}(\vec{f}), \sigma_1)}{\Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (\text{Val}(\text{RecordValue}(\text{TypePath}(p), \vec{f})), \sigma_1)}$$

**(ApplyRecordCtorSigma-Ctrl)**
$$\frac{\text{RecordDefaultInits}(p) = fields \quad \Gamma \vdash \text{EvalFieldInitsSigma}(fields, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ApplyMethodSigma-Prim)**
$$\frac{m = \text{MethodTarget}(v_{\text{self}}, name) \quad \text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{\text{self}}, \vec{v}) \Downarrow v}{\Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (\text{Val}(v), \sigma)}$$

**(ApplyMethodSigma)**
$$\frac{m = \text{MethodTarget}(v_{\text{self}}, name) \quad \text{BindParams}(\text{RecvParams}(base, name), [v_{\text{arg}}] \mathbin{+\!\!+} \vec{v}) = binds \quad \text{BlockEnter}(\sigma, binds) \Downarrow (\sigma_1, scope) \quad \Gamma \vdash \text{EvalBlockBodySigma}(m.\text{body}, \sigma_1) \Downarrow (out, \sigma_2) \quad \text{BlockExit}(\sigma_2, scope, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma) \Downarrow (\text{ReturnOut}(out'), \sigma_3)}$$

**(EvalSigma-Call-RegionProc)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(\text{ProcRef}([\texttt{Region}], name)), \sigma_1) \quad \text{RegionProcParams}(name) = params \quad \Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyRegionProc}(name, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-RegionProc-Ctrl-Args)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(\text{ProcRef}([\texttt{Region}], name)), \sigma_1) \quad \text{RegionProcParams}(name) = params \quad \Gamma \vdash \text{EvalArgsSigma}(params, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Call-Proc)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad proc = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{EvalArgsSigma}(proc.\text{params}, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyProcSigma}(proc, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-Record)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad \Gamma \vdash \text{EvalArgsSigma}([], args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \vec{v} = [] \quad \text{RecordCtor}(p) = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{ApplyRecordCtorSigma}(p, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Call-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Call-Ctrl-Args)**
$$\frac{\Gamma \vdash \text{EvalSigma}(callee, \sigma) \Downarrow (\text{Val}(v_c), \sigma_1) \quad proc = \text{CallTarget}(v_c) \quad \Gamma \vdash \text{EvalArgsSigma}(proc.\text{params}, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{Call}(callee, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-MethodCall)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{arg}} \rangle), \sigma_1) \quad m = \text{MethodTarget}(v_{\text{self}}, name) \quad \Gamma \vdash \text{EvalArgsSigma}(m.\text{params}, args, \sigma_1) \Downarrow (\text{Val}(\vec{v}), \sigma_2) \quad \Gamma \vdash \text{ApplyMethodSigma}(base, name, v_{\text{self}}, v_{\text{arg}}, \vec{v}, \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-MethodCall-Ctrl)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-MethodCall-Ctrl-Args)**
$$\frac{mode = \text{RecvArgMode}(base) \quad \Gamma \vdash \text{EvalRecvSigma}(base, mode, \sigma) \Downarrow (\text{Val}(\langle v_{\text{self}}, v_{\text{arg}} \rangle), \sigma_1) \quad m = \text{MethodTarget}(v_{\text{self}}, name) \quad \Gamma \vdash \text{EvalArgsSigma}(m.\text{params}, args, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{MethodCall}(base, name, args), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Alloc-Implicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ActiveTarget}(\sigma_1) = r \quad \text{RegionAlloc}(\sigma_1, r, v) \Downarrow (\sigma_2, v')}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(\bot, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_2)}$$

**(EvalSigma-Alloc-Implicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(\bot, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Alloc-Explicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{LookupVal}(\sigma_1, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma_1, h) = r_t \quad \text{RegionAlloc}(\sigma_1, r_t, v) \Downarrow (\sigma_2, v')}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(r, e), \sigma) \Downarrow (\text{Val}(v'), \sigma_2)}$$

**(EvalSigma-Alloc-Explicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{AllocExpr}(r, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Block)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}$$

**(EvalSigma-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\Gamma \vdash \text{EvalSigma}(\text{UnsafeBlockExpr}(b), \sigma) \Downarrow (out, \sigma')}$$

**Loop Iteration Helpers.**

$$\text{IterJudg} = \{\text{IterInit}(v) \Downarrow it,\ \text{IterNext}(it) \Downarrow (opt(v), it')\}$$
$$\text{Iter} = \{\langle v, i \rangle \mid \text{Len}(v)\ \text{defined} \land i \in \mathbb{N}\}$$
$$\text{IterInit}(v) \Downarrow \langle v, 0 \rangle \iff \text{Len}(v)\ \text{defined}$$
$$\text{IterNext}(\langle v, i \rangle) \Downarrow (\bot, \langle v, i \rangle) \iff \neg(0 \le i < \text{Len}(v))$$
$$\text{IterNext}(\langle v, i \rangle) \Downarrow (v_i, \langle v, i+1 \rangle) \iff 0 \le i < \text{Len}(v) \land \text{IndexValue}(v, i) = v_i$$

$$\text{LoopIterJudg} = \{\Gamma \vdash \text{LoopIterExec}(p, b, it, \sigma) \Downarrow (out, \sigma')\}$$

**(EvalSigma-Loop-Infinite-Step)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Infinite-Continue)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Infinite-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_1) \quad v = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (\text{Val}(v), \sigma_1)}$$

**(EvalSigma-Loop-Infinite-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(body, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{EvalSigma}(\text{LoopInfinite}(body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Loop-Cond-False)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{false}), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Val}(()), \sigma_1)}$$

**(EvalSigma-Loop-Cond-True-Step)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Loop-Cond-Continue)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_2) \quad \Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma_2) \Downarrow (out, \sigma_3)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (out, \sigma_3)}$$

**(EvalSigma-Loop-Cond-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_2) \quad v = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Val}(v), \sigma_2)}$$

**(EvalSigma-Loop-Cond-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(EvalSigma-Loop-Cond-Body-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(cond, \sigma) \Downarrow (\text{Val}(\text{true}), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(body, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{EvalSigma}(\text{LoopConditional}(cond, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(EvalSigma-Loop-Iter)**
$$\frac{\Gamma \vdash \text{EvalSigma}(iter, \sigma) \Downarrow (\text{Val}(v\_{\text{iter}}), \sigma_1) \quad \text{IterInit}(v\_{\text{iter}}) \Downarrow it \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{EvalSigma}(\text{LoopIter}(pat, ty\_opt, iter, body), \sigma) \Downarrow (out, \sigma_2)}$$

**(EvalSigma-Loop-Iter-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(iter, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(\text{LoopIter}(pat, ty\_opt, iter, body), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(LoopIter-Done)**
$$\frac{\text{IterNext}(it) \Downarrow (\bot, it')}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Val}(()), \sigma)}$$

**(LoopIter-Step-Val)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Val}(v_b), \sigma_1) \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIter-Step-Continue)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma_1) \quad \Gamma \vdash \text{LoopIterExec}(pat, body, it', \sigma_1) \Downarrow (out, \sigma_2)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (out, \sigma_2)}$$

**(LoopIter-Step-Break)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v\_opt)), \sigma_1) \quad v' = \text{BreakVal}(v\_opt)}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Val}(v'), \sigma_1)}$$

**(LoopIter-Step-Ctrl)**
$$\frac{\text{IterNext}(it) \Downarrow (v, it') \quad \Gamma \vdash \text{EvalBlockBindSigma}(pat, v, body, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1) \quad \kappa \in \{\text{Return}(\_),\ \text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{LoopIterExec}(pat, body, it, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Stateful Small-Step (Expressions).**

$$\text{ExprState} = \{\langle e, \sigma \rangle,\ \langle \text{Val}(v), \sigma \rangle,\ \langle \text{Ctrl}(\kappa), \sigma \rangle\}$$
$$\text{TerminalExpr}(\langle \text{Val}(v), \sigma \rangle)$$
$$\text{TerminalExpr}(\langle \text{Ctrl}(\kappa), \sigma \rangle)$$

**(StepSigma-Pure)**
$$\frac{\langle e \rangle \to \langle e' \rangle}{\langle e, \sigma \rangle \to \langle e', \sigma \rangle}$$

**(StepSigma-Alloc-Implicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{ActiveTarget}(\sigma_1) = r \quad \text{RegionAlloc}(\sigma_1, r, v) \Downarrow (\sigma_2, v')}{\langle \text{AllocExpr}(\bot, e), \sigma \rangle \to \langle \text{Val}(v'), \sigma_2 \rangle}$$

**(StepSigma-Alloc-Implicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{AllocExpr}(\bot, e), \sigma \rangle \to \langle \text{Ctrl}(\kappa), \sigma_1 \rangle}$$

**(StepSigma-Alloc-Explicit)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{LookupVal}(\sigma_1, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma_1, h) = r_t \quad \text{RegionAlloc}(\sigma_1, r_t, v) \Downarrow (\sigma_2, v')}{\langle \text{AllocExpr}(r, e), \sigma \rangle \to \langle \text{Val}(v'), \sigma_2 \rangle}$$

**(StepSigma-Alloc-Explicit-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{AllocExpr}(r, e), \sigma \rangle \to \langle \text{Ctrl}(\kappa), \sigma_1 \rangle}$$

**(StepSigma-Block)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(\text{BlockExpr}(stmts, tail\_opt), \sigma) \Downarrow (out, \sigma')}{\langle \text{BlockExpr}(stmts, tail\_opt), \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-UnsafeBlock)**
$$\frac{\Gamma \vdash \text{EvalBlockSigma}(b, \sigma) \Downarrow (out, \sigma')}{\langle \text{UnsafeBlockExpr}(b), \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-Loop)**
$$\frac{\Gamma \vdash \text{EvalSigma}(\ell, \sigma) \Downarrow (out, \sigma') \quad \ell \in \{\text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}}{\langle \ell, \sigma \rangle \to \langle out, \sigma' \rangle}$$

**(StepSigma-Stateful-Other)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma') \quad e \notin \{\text{AllocExpr}(\_,\_),\ \text{BlockExpr}(\_,\_),\ \text{UnsafeBlockExpr}(\_),\ \text{LoopInfinite}(\_),\ \text{LoopConditional}(\_,\_),\ \text{LoopIter}(\_,\_,\_,\_)\}}{\langle e, \sigma \rangle \to \langle out, \sigma' \rangle}$$

**Statement Execution (Cursive0).**

$$\text{ExecJudg} = \{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (sout, \sigma'),\ \Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (sout, \sigma')\}$$

**(ExecSeq-Empty)**
$$\frac{}{\Gamma \vdash \text{ExecSeqSigma}([], \sigma) \Downarrow (ok, \sigma)}$$

**(ExecSeq-Cons-Ok)**
$$\frac{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (ok, \sigma_1) \quad \Gamma \vdash \text{ExecSeqSigma}(ss, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{ExecSeqSigma}(s::ss, \sigma) \Downarrow (sout, \sigma_2)}$$

**(ExecSeq-Cons-Ctrl)**
$$\frac{\Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSeqSigma}(s::ss, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle$$

**(ExecSigma-Let)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindPattern}(\sigma_1, pat, v) \Downarrow (\sigma_2, bs)}{\Gamma \vdash \text{ExecSigma}(\text{LetStmt}(binding), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-Let-Ctrl)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{LetStmt}(binding), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Var)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindPattern}(\sigma_1, pat, v) \Downarrow (\sigma_2, bs)}{\Gamma \vdash \text{ExecSigma}(\text{VarStmt}(binding), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-Var-Ctrl)**
$$\frac{\text{BindingForm}(binding) = \langle pat, ty\_opt, op, init, \_ \rangle \quad \Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{VarStmt}(binding), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-ShadowLet)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindVal}(\sigma_1, x, v) \Downarrow (\sigma_2, b)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowLetStmt}(x, ty\_opt, init), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-ShadowLet-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowLetStmt}(x, ty\_opt, init), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-ShadowVar)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \text{BindVal}(\sigma_1, x, v) \Downarrow (\sigma_2, b)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowVarStmt}(x, ty\_opt, init), \sigma) \Downarrow (ok, \sigma_2)}$$

**(ExecSigma-ShadowVar-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(init, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ShadowVarStmt}(x, ty\_opt, init), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Assign)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1) \quad \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma_1) \Downarrow (sout, \sigma_2)}{\Gamma \vdash \text{ExecSigma}(\text{AssignStmt}(p, e), \sigma) \Downarrow (sout, \sigma_2)}$$

**(ExecSigma-Assign-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{AssignStmt}(p, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$


**(ExecSigma-CompoundAssign)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (\text{Val}(v_e), \sigma_2) \quad \text{BinOp}(op, v_p, v_e) \Downarrow v \quad \Gamma \vdash \text{WritePlaceSigma}(p, v, \sigma_2) \Downarrow (sout, \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (sout, \sigma_3)}$$

**(ExecSigma-CompoundAssign-Left-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-CompoundAssign-Right-Ctrl)**
$$\frac{\Gamma \vdash \text{ReadPlaceSigma}(p, \sigma) \Downarrow (\text{Val}(v_p), \sigma_1) \quad \Gamma \vdash \text{EvalSigma}(e, \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}{\Gamma \vdash \text{ExecSigma}(\text{CompoundAssignStmt}(p, op, e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(ExecSigma-ExprStmt)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ExprStmt}(e), \sigma) \Downarrow (\text{StmtOutOf}(out), \sigma_1)}$$

**(ExecSigma-UnsafeStmt)**
$$\frac{\Gamma \vdash \text{EvalSigma}(b, \sigma) \Downarrow (out, \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{UnsafeBlockStmt}(b), \sigma) \Downarrow (\text{StmtOutOf}(out), \sigma_1)}$$

**(ExecSigma-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\Gamma \vdash \text{ExecSigma}(\text{DeferStmt}(b), \sigma) \Downarrow (ok, \sigma')}$$

$$opts = \text{RegionOptsExpr}(opts\_opt)$$

**(ExecSigma-Region)**
$$\frac{\Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Val}(v_o), \sigma_1) \quad \text{RegionNew}(\sigma_1, v_o) \Downarrow (\sigma_2, r, scope) \quad \text{BindRegionAlias}(\sigma_2, alias\_opt, r) \Downarrow \sigma_3 \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_3, scope) \Downarrow (out, \sigma_4) \quad \text{RegionRelease}(\sigma_4, r, scope, out) \Downarrow (out', \sigma_5)}{\Gamma \vdash \text{ExecSigma}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_5)}$$

**(ExecSigma-Region-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

$$\text{RegionRelease}(Sigma, r, scope, out) \Downarrow (out', Sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, Sigma) \Downarrow (c, Sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land Sigma' = Sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{ReleaseArena}(Sigma_1, r) \Downarrow Sigma_2 \land \text{PopScope}_\sigma(Sigma_2) \Downarrow (Sigma', scope)))$$

**(ExecSigma-Frame-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r, scope, mark, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{FrameStmt}(\bot, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

**(ExecSigma-Frame-Explicit)**
$$\frac{\text{LookupVal}(\sigma, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark) \quad \Gamma \vdash \text{EvalInScopeSigma}(b, \sigma_1, scope) \Downarrow (out, \sigma_2) \quad \text{FrameReset}(\sigma_2, r_t, scope, mark, out) \Downarrow (out', \sigma_3)}{\Gamma \vdash \text{ExecSigma}(\text{FrameStmt}(r, b), \sigma) \Downarrow (\text{StmtOutOf}(out'), \sigma_3)}$$

$$\text{FrameReset}(Sigma, r, scope, mark, out) \Downarrow (out', Sigma') \iff \Gamma \vdash \text{CleanupScope}(scope, Sigma) \Downarrow (c, Sigma_1) \land out' = \text{ExitOutcome}(out, c) \land ((out' = \text{Ctrl}(\text{Abort}) \land Sigma' = Sigma_1)\ \lor\ (out' \ne \text{Ctrl}(\text{Abort}) \land \text{ResetArena}(Sigma_1, r, mark) \Downarrow Sigma_2 \land \text{PopScope}_\sigma(Sigma_2) \Downarrow (Sigma', scope)))$$

**(ExecSigma-Return)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(v)), \sigma_1)}$$

**(ExecSigma-Return-Unit)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(\bot), \sigma) \Downarrow (\text{Ctrl}(\text{Return}(())), \sigma)}$$

**(ExecSigma-Return-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ReturnStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Result)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ResultStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Result}(v)), \sigma_1)}$$

**(ExecSigma-Result-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{ResultStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Break)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Val}(v), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(v)), \sigma_1)}$$

**(ExecSigma-Break-Unit)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(\bot), \sigma) \Downarrow (\text{Ctrl}(\text{Break}(\bot)), \sigma)}$$

**(ExecSigma-Break-Ctrl)**
$$\frac{\Gamma \vdash \text{EvalSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{ExecSigma}(\text{BreakStmt}(e), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**(ExecSigma-Continue)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ContinueStmt}, \sigma) \Downarrow (\text{Ctrl}(\text{Continue}), \sigma)}$$

**(ExecSigma-Error)**
$$\frac{}{\Gamma \vdash \text{ExecSigma}(\text{ErrorStmt}(\_), \sigma) \Downarrow (\text{Ctrl}(\text{Panic}), \sigma)}$$

**Stateful Small-Step (Statements).**

$$\text{ExecState} = \{\text{Exec}(s, \sigma),\ \text{ExecSeq}(ss, \sigma),\ \text{ExecCtrl}(\kappa, \sigma),\ \text{ExecDone}(\sigma),\ \text{RegionBody}(r, scope, b, \sigma),\ \text{RegionExit}(r, scope, out, \sigma),\ \text{FrameBody}(r, scope, mark, b, \sigma),\ \text{FrameExit}(r, scope, mark, out, \sigma)\}$$

**(Step-Exec-Other-Ok)**
$$\frac{s \notin \{\text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_)\} \quad \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (ok, \sigma')}{\langle \text{Exec}(s, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Other-Ctrl)**
$$\frac{s \notin \{\text{DeferStmt}(\_),\ \text{RegionStmt}(\_,\_,\_),\ \text{FrameStmt}(\_,\_)\} \quad \Gamma \vdash \text{ExecSigma}(s, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')}{\langle \text{Exec}(s, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-ExecSeq-Ok)**
$$\frac{\Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (ok, \sigma')}{\langle \text{ExecSeq}(ss, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-ExecSeq-Ctrl)**
$$\frac{\Gamma \vdash \text{ExecSeqSigma}(ss, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma')}{\langle \text{ExecSeq}(ss, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-Exec-Defer)**
$$\frac{\text{AppendCleanup}(\sigma, \text{DeferBlock}(b)) \Downarrow \sigma'}{\langle \text{Exec}(\text{DeferStmt}(b), \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Region-Enter)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Val}(v_o), \sigma_1) \quad \text{RegionNew}(\sigma_1, v_o) \Downarrow (\sigma_2, r, scope) \quad \text{BindRegionAlias}(\sigma_2, alias\_opt, r) \Downarrow \sigma_3}{\langle \text{Exec}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \rangle \to \langle \text{RegionBody}(r, scope, b, \sigma_3) \rangle}$$

**(Step-Exec-Region-Enter-Ctrl)**
$$\frac{opts = \text{RegionOptsExpr}(opts\_opt) \quad \Gamma \vdash \text{EvalSigma}(opts, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\langle \text{Exec}(\text{RegionStmt}(opts\_opt, alias\_opt, b), \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma_1) \rangle}$$

**(Step-Exec-Region-Body)**
$$\frac{\Gamma \vdash \text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma_1)}{\langle \text{RegionBody}(r, scope, b, \sigma) \rangle \to \langle \text{RegionExit}(r, scope, out, \sigma_1) \rangle}$$

**(Step-Exec-Region-Exit-Ok)**
$$\frac{\text{RegionRelease}(\sigma, r, scope, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = ok}{\langle \text{RegionExit}(r, scope, out, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Region-Exit-Ctrl)**
$$\frac{\text{RegionRelease}(\sigma, r, scope, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = \text{Ctrl}(\kappa)}{\langle \text{RegionExit}(r, scope, out, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

**(Step-Exec-Frame-Enter-Implicit)**
$$\frac{\text{ActiveTarget}(\sigma) = r \quad \text{FrameEnter}(\sigma, r) \Downarrow (\sigma_1, F, scope, mark)}{\langle \text{Exec}(\text{FrameStmt}(\bot, b), \sigma) \rangle \to \langle \text{FrameBody}(r, scope, mark, b, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Enter-Explicit)**
$$\frac{\text{LookupVal}(\sigma, r) = v_r \quad \text{RegionHandleOf}(v_r) = h \quad \text{ResolveTarget}(\sigma, h) = r_t \quad \text{FrameEnter}(\sigma, r_t) \Downarrow (\sigma_1, F, scope, mark)}{\langle \text{Exec}(\text{FrameStmt}(r, b), \sigma) \rangle \to \langle \text{FrameBody}(r_t, scope, mark, b, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Body)**
$$\frac{\Gamma \vdash \text{EvalInScopeSigma}(b, \sigma, scope) \Downarrow (out, \sigma_1)}{\langle \text{FrameBody}(r, scope, mark, b, \sigma) \rangle \to \langle \text{FrameExit}(r, scope, mark, out, \sigma_1) \rangle}$$

**(Step-Exec-Frame-Exit-Ok)**
$$\frac{\text{FrameReset}(\sigma, r, scope, mark, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = ok}{\langle \text{FrameExit}(r, scope, mark, out, \sigma) \rangle \to \langle \text{ExecDone}(\sigma') \rangle}$$

**(Step-Exec-Frame-Exit-Ctrl)**
$$\frac{\text{FrameReset}(\sigma, r, scope, mark, out) \Downarrow (out', \sigma') \quad \text{StmtOutOf}(out') = \text{Ctrl}(\kappa)}{\langle \text{FrameExit}(r, scope, mark, out, \sigma) \rangle \to \langle \text{ExecCtrl}(\kappa, \sigma') \rangle}$$

$$\text{ConstPat}(p) = v \iff p = \text{LiteralPattern}(\ell) \land v = \text{LiteralValue}(\ell, \text{PatType}(p))$$

**MatchRecord.**
$$\text{MatchRecordJudg} = \{\Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B\}$$

**(MatchRecord-Empty)**
$$\frac{}{\Gamma \vdash \text{MatchRecord}([], v) \Downarrow \emptyset}$$

**(MatchRecord-Cons-Implicit)**
$$\frac{\text{FieldValue}(v, f) = v_f \quad \Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B}{\Gamma \vdash \text{MatchRecord}([f] \mathbin{+\!\!+} fs,\ v) \Downarrow (B \uplus \{f \mapsto v_f\})}$$

**(MatchRecord-Cons-Explicit)**
$$\frac{\text{FieldValue}(v, f) = v_f \quad \Gamma \vdash \text{MatchPattern}(p, v_f) \Downarrow B_1 \quad \Gamma \vdash \text{MatchRecord}(fs, v) \Downarrow B_2}{\Gamma \vdash \text{MatchRecord}([\langle f, p \rangle] \mathbin{+\!\!+} fs,\ v) \Downarrow (B_1 \uplus B_2)}$$

### 7.5. String Literal Semantics

$$\text{StringLiteralVal}(lit) = v \iff \text{LiteralValue}(lit, \text{TypeString}(\texttt{@View})) = v$$

**String Literal Storage.**
For any string literal `lit`, evaluation MUST allocate `StringBytes(lit)` in static, read-only storage. The resulting `string@View` value MUST reference that storage and MUST have length `|StringBytes(lit)|`. The backing storage MUST have static duration and MUST NOT be deallocated. See Â§6.1.5 for the `string@View` layout.
<!-- Source: "Literal content is allocated in static, read-only memory at compilation ... A string@View value is constructed with pointer to static memory and byte length ... String literals have static storage duration; backing memory is never deallocated." -->

### 7.6. Dynamic Class Objects

$$\text{DynValue}(Cl, addr, T) = \text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)$$
$$\text{DynLayout}(Cl, addr, T) = \langle \text{RawPtr}(\texttt{imm}, addr), \text{VTable}(T, Cl) \rangle$$

**(Eval-Dynamic-Form)**
$$\frac{\text{IsPlace}(e) \quad \Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Val}(addr), \sigma_1) \quad T_e = \text{ExprType}(e) \quad T = \text{StripPerm}(T_e) \quad \Gamma \vdash T <: Cl}{\Gamma \vdash \text{EvalSigma}(e\ \texttt{as}\ \text{TypeDynamic}(Cl), \sigma) \Downarrow (\text{Val}(\text{Dyn}(Cl, \text{RawPtr}(\texttt{imm}, addr), T)), \sigma_1)}$$

**(Eval-Dynamic-Form-Ctrl)**
$$\frac{\Gamma \vdash \text{AddrOfSigma}(e, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}{\Gamma \vdash \text{EvalSigma}(e\ \texttt{as}\ \text{TypeDynamic}(Cl), \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_1)}$$

**Dynamic Dispatch.**

$$\text{Dispatch}(T, Cl, name) = m' \iff m = \text{LookupClassMethod}(Cl, name) \land \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') = \text{Sig}_T(T, m)$$
$$\text{Dispatch}(T, Cl, name) = m \iff m = \text{LookupClassMethod}(Cl, name) \land (\text{MethodByName}(T, name) = \bot \lor (\exists m'.\ \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m))) \land m.\text{body} \ne \bot$$
$$\text{Dispatch}(T, Cl, name) = \bot \iff m = \text{LookupClassMethod}(Cl, name) \land (\text{MethodByName}(T, name) = \bot \lor (\exists m'.\ \text{MethodByName}(T, name) = m' \land \text{Sig}_T(T, m') \ne \text{Sig}_T(T, m))) \land m.\text{body} = \bot$$


### 7.7. FileSystem and File Operations

**Primitive Relations.**

$$\text{FSJudg} = \{\text{FSOpenRead}(fs, path) \Downarrow r,\ \text{FSOpenWrite}(fs, path) \Downarrow r,\ \text{FSOpenAppend}(fs, path) \Downarrow r,\ \text{FSCreateWrite}(fs, path) \Downarrow r,\ \text{FSReadFile}(fs, path) \Downarrow r,\ \text{FSReadBytes}(fs, path) \Downarrow r,\ \text{FSWriteFile}(fs, path, data) \Downarrow r,\ \text{FSWriteStdout}(fs, data) \Downarrow r,\ \text{FSWriteStderr}(fs, data) \Downarrow r,\ \text{FSExists}(fs, path) \Downarrow b,\ \text{FSRemove}(fs, path) \Downarrow r,\ \text{FSOpenDir}(fs, path) \Downarrow r,\ \text{FSCreateDir}(fs, path) \Downarrow r,\ \text{FSEnsureDir}(fs, path) \Downarrow r,\ \text{FSKind}(fs, path) \Downarrow r,\ \text{FSRestrict}(fs, path) \Downarrow fs',\ \text{FileReadAll}(handle) \Downarrow r,\ \text{FileReadAllBytes}(handle) \Downarrow r,\ \text{FileWrite}(handle, data) \Downarrow r,\ \text{FileFlush}(handle) \Downarrow r,\ \text{FileClose}(handle) \Downarrow ok,\ \text{DirNext}(handle) \Downarrow r,\ \text{DirClose}(handle) \Downarrow ok\}$$
$$\text{FSResType}(\text{FSOpenRead}) = \texttt{File@Read} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenWrite}) = \texttt{File@Write} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenAppend}) = \texttt{File@Append} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSCreateWrite}) = \texttt{File@Write} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSReadFile}) = \texttt{string@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSReadBytes}) = \texttt{bytes@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteFile}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteStdout}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSWriteStderr}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSExists}) = \texttt{bool}$$
$$\text{FSResType}(\text{FSRemove}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSOpenDir}) = \texttt{DirIter@Open} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSCreateDir}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSEnsureDir}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSKind}) = \texttt{FileKind} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FSRestrict}) = \texttt{$FileSystem}$$
$$\text{FSResType}(\text{FileReadAll}) = \texttt{string@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileReadAllBytes}) = \texttt{bytes@Managed} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileWrite}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileFlush}) = \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{FileClose}) = \texttt{ok}$$
$$\text{FSResType}(\text{DirNext}) = \texttt{DirEntry} \mid \texttt{()} \mid \texttt{IoError}$$
$$\text{FSResType}(\text{DirClose}) = \texttt{ok}$$

$$\text{Handle} = \mathbb{N}$$
$$\text{Entry} ::= \text{FileEntry}(bytes) \mid \text{DirEntry}(names) \mid \text{OtherEntry}$$
$$\text{FSState} = \langle \text{entries},\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle$$
$$\text{Entries}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = entries$$
$$\text{Handles}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = handles$$
$$\text{DirIters}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = diriters$$
$$\text{FlushedSet}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = flushed$$
$$\text{FailMap}(\langle entries,\ \text{handles},\ \text{diriters},\ \text{flushed},\ \text{failmap} \rangle) = failmap$$
$$\text{EntryKind}(\omega, path) =
\begin{cases}
\texttt{File} & \text{if }\text{Entries}(\omega)[path]=\text{FileEntry}(\_)\\
\texttt{Dir} & \text{if }\text{Entries}(\omega)[path]=\text{DirEntry}(\_)\\
\texttt{Other} & \text{if }\text{Entries}(\omega)[path]=\text{OtherEntry}\\
\texttt{Other} & \text{if }\text{Entries}(\omega)[path]\ \text{undefined}
\end{cases}$$
$$\text{FileBytes}(\omega, path) = bytes \iff \text{Entries}(\omega)[path]=\text{FileEntry}(bytes)$$
$$\text{DirNames}(\omega, path) = names \iff \text{Entries}(\omega)[path]=\text{DirEntry}(names)$$
$$\text{HandleStateOf}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{state} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
\texttt{Closed} & \text{otherwise}
\end{cases}$$
$$\text{HandlePos}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{pos} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{HandleLen}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{len} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{HandlePath}(\omega, h) = \begin{cases}
\text{Handles}(\omega)[h].\text{path} & \text{if }\text{Handles}(\omega)[h]\ \text{defined}\\
\texttt{"\""} & \text{otherwise}
\end{cases}$$
$$\text{DirIterFS}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{fs} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
\bot & \text{otherwise}
\end{cases}$$
$$\text{DirIterPath}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{path} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
\texttt{"\""} & \text{otherwise}
\end{cases}$$
$$\text{DirIterEntries}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{entries} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DirIterPos}(\omega, h) = \begin{cases}
\text{DirIters}(\omega)[h].\text{pos} & \text{if }\text{DirIters}(\omega)[h]\ \text{defined}\\
0 & \text{otherwise}
\end{cases}$$
$$\text{DirIterOpen}(\omega, h) \iff \text{DirIters}(\omega)[h]\ \text{defined}$$
$$\text{Flushed}(\omega, h) \iff h \in \text{FlushedSet}(\omega)$$
$$\text{FSJudg}_\omega = \{\text{FSOpenRead}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenWrite}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenAppend}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSCreateWrite}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSWriteFile}(fs, path, data, \omega) \Downarrow (r, \omega'),\ \text{FSWriteStdout}(fs, data, \omega) \Downarrow (r, \omega'),\ \text{FSWriteStderr}(fs, data, \omega) \Downarrow (r, \omega'),\ \text{FSExists}(fs, path, \omega) \Downarrow (b, \omega'),\ \text{FSRemove}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSOpenDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSCreateDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSEnsureDir}(fs, path, \omega) \Downarrow (r, \omega'),\ \text{FSKind}(fs, path, \omega) \Downarrow (r, \omega')\}$$
$$\text{FileJudg}_\omega = \{\text{FileReadAll}(h, \omega) \Downarrow (r, \omega'),\ \text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega'),\ \text{FileWrite}(h, data, \omega) \Downarrow (r, \omega'),\ \text{FileFlush}(h, \omega) \Downarrow (r, \omega'),\ \text{FileClose}(h, \omega) \Downarrow (ok, \omega')\}$$
$$\text{DirJudg}_\omega = \{\text{DirNext}(h, \omega) \Downarrow (r, \omega'),\ \text{DirClose}(h, \omega) \Downarrow (ok, \omega')\}$$

$$\text{FSOpenRead}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenWrite}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenWrite}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenAppend}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenAppend}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSCreateWrite}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSCreateWrite}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSReadFile}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSReadBytes}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteFile}(fs, path, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteFile}(fs, path, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteStdout}(fs, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteStdout}(fs, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSWriteStderr}(fs, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSWriteStderr}(fs, data, \omega) \Downarrow (r, \omega')$$
$$\text{FSExists}(fs, path) \Downarrow b \iff \exists \omega,\omega'.\ \text{FSExists}(fs, path, \omega) \Downarrow (b, \omega')$$
$$\text{FSRemove}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSRemove}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSOpenDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSOpenDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSCreateDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSCreateDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSEnsureDir}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSEnsureDir}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FSKind}(fs, path) \Downarrow r \iff \exists \omega,\omega'.\ \text{FSKind}(fs, path, \omega) \Downarrow (r, \omega')$$
$$\text{FileReadAll}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileReadAll}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileReadAllBytes}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileWrite}(h, data) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileWrite}(h, data, \omega) \Downarrow (r, \omega')$$
$$\text{FileFlush}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{FileFlush}(h, \omega) \Downarrow (r, \omega')$$
$$\text{FileClose}(h) \Downarrow ok \iff \exists \omega,\omega'.\ \text{FileClose}(h, \omega) \Downarrow (ok, \omega')$$
$$\text{DirNext}(h) \Downarrow r \iff \exists \omega,\omega'.\ \text{DirNext}(h, \omega) \Downarrow (r, \omega')$$
$$\text{DirClose}(h) \Downarrow ok \iff \exists \omega,\omega'.\ \text{DirClose}(h, \omega) \Downarrow (ok, \omega')$$

**Restriction Semantics.**

$$\text{RestrictPath}(base, path) = p \iff \neg \text{AbsPath}(path) \land b = \text{Canon}(\text{Normalize}(base)) \land b \ne \bot \land p = \text{Canon}(\text{Normalize}(\text{Join}(b, path))) \land p \ne \bot \land \text{prefix}(p, b)$$
$$\text{RestrictPath}(base, path) = \bot \iff \text{AbsPath}(path) \lor \text{Canon}(\text{Normalize}(base)) = \bot \lor \text{Canon}(\text{Normalize}(\text{Join}(\text{Canon}(\text{Normalize}(base)), path))) = \bot \lor \neg \text{prefix}(\text{Canon}(\text{Normalize}(\text{Join}(\text{Canon}(\text{Normalize}(base)), path))), \text{Canon}(\text{Normalize}(base)))$$
$$\text{FSOp} = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSCreateWrite},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSWriteFile},\ \text{FSWriteStdout},\ \text{FSWriteStderr},\ \text{FSExists},\ \text{FSRemove},\ \text{FSOpenDir},\ \text{FSCreateDir},\ \text{FSEnsureDir},\ \text{FSKind}\}$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land Op \in \text{FSOp} \land \text{RestrictPath}(base, p) = q \Rightarrow Op(fs', p) = Op(fs, q)$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land Op \in \text{FSOp} \land \text{RestrictPath}(base, p) = \bot \land Op \ne \text{FSExists} \Rightarrow Op(fs', p) = \text{IoError::InvalidPath}$$
$$\text{FSRestrict}(fs, base) \Downarrow fs' \land \text{RestrictPath}(base, p) = \bot \Rightarrow \text{FSExists}(fs', p) = \text{false}$$

**IoError Mapping.**

$$\text{FSPathOp}_0 = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSCreateWrite},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSExists},\ \text{FSRemove},\ \text{FSOpenDir},\ \text{FSCreateDir},\ \text{FSEnsureDir},\ \text{FSKind}\}$$
$$\text{FSPathOp}_1 = \{\text{FSWriteFile}\}$$
$$\text{FSRequiresExisting} = \{\text{FSOpenRead},\ \text{FSOpenWrite},\ \text{FSOpenAppend},\ \text{FSReadFile},\ \text{FSReadBytes},\ \text{FSOpenDir},\ \text{FSKind},\ \text{FSRemove}\}$$
$$\text{PathInvalid}(fs, path, \omega) \iff \text{Canon}(\text{Normalize}(path)) = \bot$$
$$\text{EntryExists}(\omega, path) \iff \text{Entries}(\omega)[path]\ \text{defined}$$
$$\text{EntryKind}(\omega, path) \in \{\texttt{File},\ \texttt{Dir},\ \texttt{Other}\}$$
$$\text{PermissionDenied}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::PermissionDenied}$$
$$\text{Busy}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::Busy}$$
$$\text{OtherFailure}(fs, path, Op, \omega) \iff \text{FailMap}(\omega)[\langle Op, path\rangle] = \text{IoError::IoFailure}$$

$$Op \in \text{FSPathOp}_0 \land \text{PathInvalid}(fs, path, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$Op \in \text{FSPathOp}_1 \land \text{PathInvalid}(fs, path, \omega) \Rightarrow Op(fs, path, data, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$Op \in \text{FSRequiresExisting} \land \neg \text{EntryExists}(\omega, path) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::NotFound}, \omega)$$
$$\text{PermissionDenied}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::PermissionDenied}, \omega)$$
$$Op = \text{FSCreateWrite} \land \text{EntryExists}(\omega, path) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::AlreadyExists}, \omega)$$
$$Op \in \{\text{FSCreateDir},\ \text{FSEnsureDir}\} \land \text{EntryExists}(\omega, path) \land \text{EntryKind}(\omega, path) \ne \texttt{Dir} \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::AlreadyExists}, \omega)$$
$$Op = \text{FSOpenDir} \land \text{EntryExists}(\omega, path) \land \text{EntryKind}(\omega, path) \ne \texttt{Dir} \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::InvalidPath}, \omega)$$
$$\text{Busy}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::Busy}, \omega)$$
$$\text{OtherFailure}(fs, path, Op, \omega) \Rightarrow Op(fs, path, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$

$$\text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega') \land \text{FSReadBytes}(fs, path, \omega) \Downarrow (bytes, \omega'') \land \neg \text{Utf8Valid}(bytes) \Rightarrow r = \text{IoError::IoFailure}$$
$$\text{FileReadAll}(h, \omega) \Downarrow (r, \omega') \land \text{FileReadAllBytes}(h, \omega) \Downarrow (bytes, \omega'') \land \neg \text{Utf8Valid}(bytes) \Rightarrow r = \text{IoError::IoFailure}$$

$$\text{FSExists}(fs, path, \omega) \Downarrow (\text{true}, \omega') \Rightarrow \text{EntryExists}(\omega, path) \land \neg \text{PathInvalid}(fs, path, \omega)$$
$$\text{FSExists}(fs, path, \omega) \Downarrow (\text{false}, \omega') \Rightarrow \text{PathInvalid}(fs, path, \omega)\ \lor\ \neg \text{EntryExists}(\omega, path)$$

**File and Directory Operation Semantics.**

$$\text{HandleState} = \{\texttt{OpenRead},\ \texttt{OpenWrite},\ \texttt{OpenAppend},\ \texttt{Closed}\}$$
$$\text{HandleOpen}(\omega, h) \iff \text{HandleStateOf}(\omega, h) \ne \texttt{Closed}$$
$$\text{HandleMode}(\omega, h) = \begin{cases}
\texttt{Read} & \text{HandleStateOf}(\omega, h) = \texttt{OpenRead} \\
\texttt{Write} & \text{HandleStateOf}(\omega, h) = \texttt{OpenWrite} \\
\texttt{Append} & \text{HandleStateOf}(\omega, h) = \texttt{OpenAppend}
\end{cases}$$
$$\text{FileLenAt}(\omega, path) = \begin{cases}
\text{ByteLen}(bytes) & \text{if }\text{Entries}(\omega)[path]=\text{FileEntry}(bytes)\\
0 & \text{otherwise}
\end{cases}$$
$$\text{ByteLen}(data) = \begin{cases}
|data| & data \in \text{Bytes}\\
|\text{Utf8}(data)| & data \in \text{String}\\
0 & \text{otherwise}
\end{cases}$$

$$\text{LexBytes}(b_1, b_2) \iff (\exists k.\ 0 \le k < \min(|b_1|,|b_2|) \land (\forall i<k.\ b_1[i]=b_2[i]) \land b_1[k] < b_2[k]) \lor (|b_1| < |b_2| \land \forall i<|b_1|.\ b_1[i]=b_2[i])$$
$$\text{EntryKey}(name) = \text{CaseFold}(\text{NFC}(name))$$
$$\text{EntryOrder}(a, b) \iff \text{LexBytes}(\text{Utf8}(\text{EntryKey}(a)), \text{Utf8}(\text{EntryKey}(b))) \lor (\text{EntryKey}(a) = \text{EntryKey}(b) \land \text{LexBytes}(\text{Utf8}(a), \text{Utf8}(b)))$$
$$\text{DirSnapshot}(fs, path, \omega) = \begin{cases}
\text{DirNames}(\omega, path) & \text{Entries}(\omega)[path]=\text{DirEntry}(\_)\\
[] & \text{otherwise}
\end{cases}$$
$$\text{DirEntries}(fs, path, \omega) = \text{sort}_{\text{EntryOrder}}(\text{DirSnapshot}(fs, path, \omega))$$
$$\forall name \in \text{DirSnapshot}(fs, path, \omega).\ name \ne \texttt{"."} \land name \ne \texttt{".."}$$

$$\text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenRead} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSOpenWrite}(fs, path, \omega) \Downarrow (\texttt{File@Write}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenWrite} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSOpenAppend}(fs, path, \omega) \Downarrow (\texttt{File@Append}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenAppend} \land \text{HandlePos}(\omega', h) = \text{FileLenAt}(\omega, path) \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = \text{FileLenAt}(\omega, path)$$
$$\text{FSCreateWrite}(fs, path, \omega) \Downarrow (\texttt{File@Write}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{OpenWrite} \land \text{HandlePos}(\omega', h) = 0 \land \text{HandlePath}(\omega', h) = path \land \text{HandleLen}(\omega', h) = 0$$

$$\text{FSReadFile}(fs, path, \omega) \Downarrow (r, \omega') \iff \exists h,\omega_1,\omega_2.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega_1) \land \text{FileReadAll}(h, \omega_1) \Downarrow (r, \omega_2) \land \text{FileClose}(h, \omega_2) \Downarrow (ok, \omega')$$
$$\text{FSReadBytes}(fs, path, \omega) \Downarrow (r, \omega') \iff \exists h,\omega_1,\omega_2.\ \text{FSOpenRead}(fs, path, \omega) \Downarrow (\texttt{File@Read}\{\texttt{handle}: h\}, \omega_1) \land \text{FileReadAllBytes}(h, \omega_1) \Downarrow (r, \omega_2) \land \text{FileClose}(h, \omega_2) \Downarrow (ok, \omega')$$

$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileReadAll}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileReadAllBytes}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileWrite}(h, data, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\neg \text{HandleOpen}(\omega, h) \Rightarrow \text{FileFlush}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$

$$\text{FileReadAll}(h, \omega) \Downarrow (r, \omega') \land r \ne \text{IoError::IoFailure} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h)$$
$$\text{FileReadAllBytes}(h, \omega) \Downarrow (r, \omega') \land r \ne \text{IoError::IoFailure} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h)$$

$$\text{FileWrite}(h, data, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleOpen}(\omega, h) \land (\text{HandleMode}(\omega, h) = \texttt{Append} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandleLen}(\omega, h) + \text{ByteLen}(data)) \land (\text{HandleMode}(\omega, h) \ne \texttt{Append} \Rightarrow \text{HandlePos}(\omega', h) = \text{HandlePos}(\omega, h) + \text{ByteLen}(data))$$
$$\text{FileWrite}(h, data, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleLen}(\omega', h) = \max(\text{HandleLen}(\omega, h),\ \text{HandlePos}(\omega', h))$$

$$\text{FileFlush}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \text{Flushed}(\omega', h)$$
$$\text{FileClose}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \text{HandleStateOf}(\omega', h) = \texttt{Closed}$$

$$\text{FSOpenDir}(fs, path, \omega) \Downarrow (\texttt{DirIter@Open}\{\texttt{handle}: h\}, \omega') \Rightarrow \text{DirIterOpen}(\omega', h) \land \text{DirIterFS}(\omega', h) = fs \land \text{DirIterPath}(\omega', h) = path \land \text{DirIterEntries}(\omega', h) = \text{DirEntries}(fs, path, \omega) \land \text{DirIterPos}(\omega', h) = 0$$

$$\neg \text{DirIterOpen}(\omega, h) \Rightarrow \text{DirNext}(h, \omega) \Downarrow (\text{IoError::IoFailure}, \omega)$$
$$\text{DirIterOpen}(\omega, h) \land \text{DirIterPos}(\omega, h) = i \land i \ge |\text{DirIterEntries}(\omega, h)| \Rightarrow \text{DirNext}(h, \omega) \Downarrow ((), \omega)$$
$$\text{DirIterOpen}(\omega, h) \land \text{DirIterPos}(\omega, h) = i \land i < |\text{DirIterEntries}(\omega, h)| \land name = \text{DirIterEntries}(\omega, h)[i] \land path = \text{Join}(\text{DirIterPath}(\omega, h), name) \land \text{FSKind}(\text{DirIterFS}(\omega, h), path, \omega) \Downarrow (k, \omega_1) \Rightarrow \text{DirNext}(h, \omega) \Downarrow (\texttt{DirEntry}\{\texttt{path}: path,\ \texttt{name}: name,\ \texttt{kind}: k\}, \omega_2) \land \text{DirIterPos}(\omega_2, h) = i+1$$

$$\text{DirClose}(h, \omega) \Downarrow (ok, \omega') \Rightarrow \neg \text{DirIterOpen}(\omega', h)$$

**Handle Extraction.**

$$\text{HandleOf}(v) = h \iff v = \texttt{File@Read}\{\texttt{handle}: h\} \lor v = \texttt{File@Write}\{\texttt{handle}: h\} \lor v = \texttt{File@Append}\{\texttt{handle}: h\}$$
$$\text{DirHandleOf}(v) = h \iff v = \texttt{DirIter@Open}\{\texttt{handle}: h\}$$

**Primitive Method Application.**

$$\text{MethodName}(\text{MethodDecl}(\_,\_,name,\_,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{ClassMethodDecl}(\_,name,\_,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{StateMethodDecl}(\_,name,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodName}(\text{TransitionDecl}(\_,name,\_,\_,\_,\_,\_)) = name$$
$$\text{MethodOwner}(m) = owner \iff \exists T.\ \text{MethodByName}(T, \text{MethodName}(m)) = m \land owner = T$$
$$\text{PrimCallJudg} = \{\text{PrimCall}(Owner, name, v_{\text{self}}, args) \Downarrow v\}$$

**(Prim-FS-OpenRead)**
$$\frac{\Gamma \vdash \text{FSOpenRead}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_read}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenWrite)**
$$\frac{\Gamma \vdash \text{FSOpenWrite}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_write}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenAppend)**
$$\frac{\Gamma \vdash \text{FSOpenAppend}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_append}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-CreateWrite)**
$$\frac{\Gamma \vdash \text{FSCreateWrite}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{create_write}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-ReadFile)**
$$\frac{\Gamma \vdash \text{FSReadFile}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{read_file}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-ReadBytes)**
$$\frac{\Gamma \vdash \text{FSReadBytes}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{read_bytes}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-WriteFile)**
$$\frac{\Gamma \vdash \text{FSWriteFile}(v_{fs}, p, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_file}, v_{fs}, [p, d]) \Downarrow r}$$

**(Prim-FS-WriteStdout)**
$$\frac{\Gamma \vdash \text{FSWriteStdout}(v_{fs}, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_stdout}, v_{fs}, [d]) \Downarrow r}$$

**(Prim-FS-WriteStderr)**
$$\frac{\Gamma \vdash \text{FSWriteStderr}(v_{fs}, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{write_stderr}, v_{fs}, [d]) \Downarrow r}$$

**(Prim-FS-Exists)**
$$\frac{\Gamma \vdash \text{FSExists}(v_{fs}, p) \Downarrow b}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{exists}, v_{fs}, [p]) \Downarrow b}$$

**(Prim-FS-Remove)**
$$\frac{\Gamma \vdash \text{FSRemove}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{remove}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-OpenDir)**
$$\frac{\Gamma \vdash \text{FSOpenDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{open_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-CreateDir)**
$$\frac{\Gamma \vdash \text{FSCreateDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{create_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-EnsureDir)**
$$\frac{\Gamma \vdash \text{FSEnsureDir}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{ensure_dir}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-Kind)**
$$\frac{\Gamma \vdash \text{FSKind}(v_{fs}, p) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{kind}, v_{fs}, [p]) \Downarrow r}$$

**(Prim-FS-Restrict)**
$$\frac{\Gamma \vdash \text{FSRestrict}(v_{fs}, p) \Downarrow v_{fs}'}{\Gamma \vdash \text{PrimCall}(\texttt{FileSystem}, \texttt{restrict}, v_{fs}, [p]) \Downarrow v_{fs}'}$$

**(Prim-File-ReadAll)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileReadAll}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{read_all}, v, []) \Downarrow r}$$

**(Prim-File-ReadAllBytes)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileReadAllBytes}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{read_all_bytes}, v, []) \Downarrow r}$$

**(Prim-File-Write)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileWrite}(h, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{write}, v, [d]) \Downarrow r}$$

**(Prim-File-Flush)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileFlush}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{flush}, v, []) \Downarrow r}$$

**(Prim-File-Write-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileWrite}(h, d) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{write}, v, [d]) \Downarrow r}$$

**(Prim-File-Flush-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileFlush}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{flush}, v, []) \Downarrow r}$$

**(Prim-File-Close-Read)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Read}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-File-Close-Write)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Write}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-File-Close-Append)**
$$\frac{\text{HandleOf}(v) = h \quad \Gamma \vdash \text{FileClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{File@Append}, \texttt{close}, v, []) \Downarrow \texttt{File@Closed}\{\}}$$

**(Prim-Dir-Next)**
$$\frac{\text{DirHandleOf}(v) = h \quad \Gamma \vdash \text{DirNext}(h) \Downarrow r}{\Gamma \vdash \text{PrimCall}(\texttt{DirIter@Open}, \texttt{next}, v, []) \Downarrow r}$$

**(Prim-Dir-Close)**
$$\frac{\text{DirHandleOf}(v) = h \quad \Gamma \vdash \text{DirClose}(h) \Downarrow ok}{\Gamma \vdash \text{PrimCall}(\texttt{DirIter@Open}, \texttt{close}, v, []) \Downarrow \texttt{DirIter@Closed}\{\}}$$

**(ApplyMethod-Prim)**
$$\frac{\text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{self}, \vec{v}) \Downarrow v}{\Gamma \vdash \text{ApplyMethod}(m, v_{self}, \vec{v}) \Downarrow v}$$

**(ApplyMethod-Prim-Step)**
$$\frac{\text{MethodOwner}(m) = owner \quad \text{MethodName}(m) = name \quad \Gamma \vdash \text{PrimCall}(owner, name, v_{self}, \vec{v}) \Downarrow v}{\langle \text{ApplyMethod}(m, v_{self}, \vec{v}) \rangle \to \langle v \rangle}$$

### 7.8. Interpreter Entrypoint (Project-Level)

**Interpreter Judgments.**

$$\text{InterpJudg} = \{ \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma'),\ \Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (out, \sigma'),\ \Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}(P_s) \}$$
$$\text{ContextValue}(v) \iff \exists bits.\ \text{ValueBits}(\text{TypePath}([\texttt{"Context"}]), v) = bits$$

**(ContextInitSigma)**
$$\frac{\text{ContextValue}(v_{ctx})}{\Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma)}$$

**(Interpret-Project-Ok)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{Deinit}(P, \sigma_2) \Downarrow \sigma_3}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (\text{Val}(v), \sigma_3)}$$

**(Interpret-Project-Init-Panic)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Uparrow \text{panic}(P_s)}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}(P_s)}$$

**(Interpret-Project-Main-Ctrl)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Ctrl}(\kappa), \sigma_2) \quad \kappa \in \{\text{Panic},\ \text{Abort}\}}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Downarrow (\text{Ctrl}(\kappa), \sigma_2)}$$

**(Interpret-Project-Deinit-Panic)**
$$\frac{\text{Executable}(P) \quad \text{MainDecls}(P)=[d] \quad \text{MainSigOk}(d) \quad \Gamma \vdash \text{ContextInitSigma}(\sigma) \Downarrow (\text{Val}(v_{ctx}), \sigma_0) \quad \Gamma \vdash \text{Init}(G_e, \sigma_0) \Downarrow \sigma_1 \quad \Gamma \vdash \text{ApplyProcSigma}(d, [v_{ctx}], \sigma_1) \Downarrow (\text{Val}(v), \sigma_2) \quad \Gamma \vdash \text{Deinit}(P, \sigma_2) \Uparrow \text{panic}}{\Gamma \vdash \text{InterpretProject}(P, \sigma) \Uparrow \text{panic}}$$
## 8. Appendix A - Diagnostic Codes

### 8.0. DiagIdâ€“Code Map

$$\text{DiagTable} = \{\texttt{E-PRJ},\ \texttt{E-MOD},\ \texttt{E-OUT},\ \texttt{E-SRC},\ \texttt{E-CNF},\ \texttt{E-UNS},\ \texttt{E-MEM},\ \texttt{W-MOD},\ \texttt{W-SRC},\ \texttt{E-TYP},\ \texttt{W-SYS},\ \texttt{E-SEM},\ \texttt{W-SEM}\}$$
$$\text{DiagRow} = \langle \text{code},\ \text{sev},\ \text{det},\ \text{cond},\ \text{ids} \rangle$$
$$\text{RowCode}(\langle code, sev, det, cond, ids \rangle) = code$$
$$\text{RowSev}(\langle code, sev, det, cond, ids \rangle) = sev$$
$$\text{RowDet}(\langle code, sev, det, cond, ids \rangle) = det$$
$$\text{RowCond}(\langle code, sev, det, cond, ids \rangle) = cond$$
$$\text{RowIds}(\langle code, sev, det, cond, ids \rangle) = ids$$
$$\text{SeverityColumn}(c) = sev \iff \exists row \in \text{DiagRows}.\ \text{RowCode}(row)=c \land \text{RowSev}(row)=sev$$
$$\text{ConditionColumn}(c) = cond \iff \exists row \in \text{DiagRows}.\ \text{RowCode}(row)=c \land \text{RowCond}(row)=cond$$
$$\text{TableRows}(t) = \{ row \mid row\ \text{appears in table}\ t \}$$
$$\text{DiagRows} = \bigcup_{t \in \text{DiagTable}} \text{TableRows}(t)$$
$$\text{C0Code}(id) = c \iff \exists row \in \text{DiagRows}.\ id \in \text{RowIds}(row) \land \text{RowCode}(row)=c$$
$$\text{C0Code}(id) = \bot \iff \neg \exists row \in \text{DiagRows}.\ id \in \text{RowIds}(row)$$

### 8.1. E-PRJ (Project)

| Code         | Severity | Detection    | Condition                                                                            | DiagId                                                                                             |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| `E-PRJ-0101` | Error    | Compile-time | `Cursive.toml` not found at project root                                             | Parse-Manifest-Missing                                                                             |
| `E-PRJ-0102` | Error    | Compile-time | `Cursive.toml` is not valid TOML                                                     | Parse-Manifest-Err                                                                                 |
| `E-PRJ-0103` | Error    | Compile-time | Missing required `assembly` table, empty assembly list, required keys, or required key type | WF-Assembly-Table-Err, WF-Assembly-Count-Err, WF-Assembly-Required-Types-Err                       |
| `E-PRJ-0104` | Error    | Compile-time | Unknown key in `assembly` table or unknown top-level key                             | WF-Assembly-Keys-Err, WF-TopKeys-Err                                                               |
| `E-PRJ-0201` | Error    | Compile-time | `assembly.kind` is not in `{ "executable", "library" }`                              | WF-Assembly-Kind-Err                                                                               |
| `E-PRJ-0202` | Error    | Compile-time | Duplicate `assembly.name` values                                                     | WF-Assembly-Name-Dup                                                                               |
| `E-PRJ-0203` | Error    | Compile-time | `assembly.name` is not a valid identifier                                            | WF-Assembly-Name-Err                                                                               |
| `E-PRJ-0204` | Error    | Compile-time | `emit_ir` has invalid value or type                                                  | WF-Assembly-EmitIR-Err, WF-Assembly-EmitIRType-Err                                                 |
| `E-PRJ-0205` | Error    | Compile-time | Assembly selection failed (missing target or target not found)                       | Assembly-Select-Err                                                                                |
| `E-PRJ-0301` | Error    | Compile-time | `assembly.root` or `out_dir` has invalid type, is absolute, or resolves outside root | WF-Assembly-Root-Path-Err, WF-Assembly-OutDir-Path-Err, WF-Assembly-OutDirType-Err, WF-RelPath-Err |
| `E-PRJ-0302` | Error    | Compile-time | `assembly.root` does not exist or is not a directory                                 | WF-Source-Root-Err                                                                                 |
| `E-PRJ-0303` | Error    | Compile-time | Relative path derivation failed during deterministic ordering (file or directory)    | FileOrder-Rel-Fail, DirSeq-Rel-Fail                                                                |
| `E-PRJ-0304` | Error    | Compile-time | Path canonicalization or module path derivation failed due to filesystem error       | Disc-Rel-Fail, Resolve-Canonical-Err                                                               |
| `E-PRJ-0305` | Error    | Compile-time | Directory enumeration failed during module discovery                                 | DirSeq-Read-Err                                                                                    |

### 8.2. E-MOD (Module)

| Code         | Severity | Detection    | Condition                                                       | DiagId                                                                                                                                 |
| ------------ | -------- | ------------ | --------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `E-MOD-1104` | Error    | Compile-time | Module path collision after NFC + case folding                  | WF-Module-Path-Collision, Disc-Collision                                                                                               |
| `E-MOD-1105` | Error    | Compile-time | Module path component is a reserved keyword                     | WF-Module-Path-Reserved                                                                                                                |
| `E-MOD-1106` | Error    | Compile-time | Module path component is not a valid identifier                 | WF-Module-Path-Ident-Err                                                                                                               |
| `E-MOD-1204` | Error    | Compile-time | Using path does not resolve to a module or item                 | Resolve-Using-None                                                                                                                     |
| `E-MOD-1205` | Error    | Compile-time | Attempt to `public using` a non-public item                     | Using-Path-Item-Public-Err, Using-List-Public-Err                                                                                      |
| `E-MOD-1206` | Error    | Compile-time | Duplicate item in a `using` list                                | Using-List-Dup                                                                                                                         |
| `E-MOD-1207` | Error    | Compile-time | Cannot access a `protected` item from this scope                | Access-Err                                                                                                                             |
| `E-MOD-1208` | Error    | Compile-time | Using path is ambiguous between module and item                 | Resolve-Using-Ambig                                                                                                                    |
| `E-MOD-1301` | Error    | Compile-time | Unresolved name: identifier not found in any accessible scope   | ResolveExpr-Ident-Err, ResolveQual-Name-Err, ResolveQual-Apply-Err, ResolveQual-Apply-Brace-Err, Expr-Unresolved-Err                   |
| `E-MOD-1302` | Error    | Compile-time | Duplicate declaration in module scope                           | Collect-Dup, Names-Step-Dup                                                                                                            |
| `E-MOD-1303` | Error    | Compile-time | Shadowing without `shadow` keyword                              | Intro-Shadow-Required                                                                                                                  |
| `E-MOD-1304` | Error    | Compile-time | Unresolved module: path prefix did not resolve to a module      | ResolveModulePath-Err                                                                                                                  |
| `E-MOD-1306` | Error    | Compile-time | Unnecessary `shadow` keyword: no binding is being shadowed      | Shadow-Unnecessary                                                                                                                     |
| `E-MOD-1307` | Error    | Compile-time | Ambiguous method resolution; disambiguation required            | LookupMethod-Ambig                                                                                                                     |
| `E-MOD-1401` | Error    | Compile-time | Cyclic module dependency detected in eager initializers         | Topo-Cycle                                                                                                                             |
| `E-MOD-2401` | Error    | Compile-time | Reassignment of immutable `let` binding                         | Assign-Immutable-Err                                                                                                                   |
| `E-MOD-2402` | Error    | Compile-time | Type annotation incompatible with inferred type                 | WF-StaticDecl-Ann-Mismatch, T-LetStmt-Ann-Mismatch, T-VarStmt-Ann-Mismatch, T-ShadowLetStmt-Ann-Mismatch, T-ShadowVarStmt-Ann-Mismatch |
| `E-MOD-2411` | Error    | Compile-time | Missing move expression at call site for transferring parameter | B-ArgPass-Move-Missing                                                                                                                 |
| `E-MOD-2430` | Error    | Compile-time | Multiple `main` procedures defined                              | Main-Multiple                                                                                                                          |
| `E-MOD-2431` | Error    | Compile-time | Invalid `main` signature                                        | Main-Signature-Err                                                                                                                     |
| `E-MOD-2432` | Error    | Compile-time | `main` is generic (has type parameters)                         | Main-Generic-Err                                                                                                                       |
| `E-MOD-2433` | Error    | Compile-time | Module-scope `var` declaration with `public` visibility         | StaticVisOk-Err                                                                                                                        |
| `E-MOD-2434` | Error    | Compile-time | Missing `main` procedure                                        | Main-Missing                                                                                                                           |
| `E-MOD-2440` | Error    | Compile-time | `protected` used on top-level declaration                       | Protected-TopLevel-Err                                                                                                                 |

### 8.3. E-OUT (Output and Linking)

| Code         | Severity | Detection    | Condition                                                                | DiagId                                                                           |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| `E-OUT-0401` | Error    | Compile-time | Failed to create output directory                                        | Out-Dirs-Err                                                                     |
| `E-OUT-0402` | Error    | Compile-time | Failed to emit object file (codegen or write)                            | Out-Obj-Err, EmitObj-Err                                                         |
| `E-OUT-0403` | Error    | Compile-time | Failed to emit IR/bitcode (codegen, assemble, tool resolution, or write) | Out-IR-Err, EmitLLVM-Err                                                         |
| `E-OUT-0404` | Error    | Compile-time | Linker invocation failed                                                 | Out-Link-Fail                                                                    |
| `E-OUT-0405` | Error    | Compile-time | Required linker tool not found                                           | Out-Link-NotFound                                                                |
| `E-OUT-0406` | Error    | Compile-time | Output path collision detected                                           | Out-Obj-Collision, Out-IR-Collision                                              |
| `E-OUT-0407` | Error    | Compile-time | Runtime library missing or unreadable                                    | Out-Link-Runtime-Missing                                                         |
| `E-OUT-0408` | Error    | Compile-time | Runtime library missing required symbol(s)                               | Out-Link-Runtime-Incompatible                                                    |
| `E-OUT-0410` | Error    | Compile-time | LLVM type mapping failed                                                 | LLVMTy-Err                                                                       |
| `E-OUT-0411` | Error    | Compile-time | LLVM IR lowering failed                                                  | LowerIR-Err, LowerIRDecl-Err, LowerIRInstr-Err                                   |
| `E-OUT-0412` | Error    | Compile-time | Binding storage/validity lowering failed                                 | BindSlot-Err, BindValid-Err, UpdateValid-Err, DropOnAssign-Err                   |
| `E-OUT-0413` | Error    | Compile-time | LLVM call ABI lowering failed                                            | LLVMCall-Err, LLVMArgLower-Err, LLVMRetLower-Err                                 |
| `E-OUT-0414` | Error    | Compile-time | VTable emission failed                                                   | EmitVTable-Err                                                                   |
| `E-OUT-0415` | Error    | Compile-time | Literal data emission failed                                             | EmitLiteral-Err                                                                  |
| `E-OUT-0416` | Error    | Compile-time | Runtime built-in symbol resolution failed                                | BuiltinSym-String-Err, BuiltinSym-Bytes-Err, StringDropSym-Err, BytesDropSym-Err |
| `E-OUT-0417` | Error    | Compile-time | Entrypoint or context construction lowering failed                       | EntrySym-Err, EntryStub-Err, EmitInitPlan-Err, EmitDeinitPlan-Err                |
| `E-OUT-0418` | Error    | Compile-time | Poisoning instrumentation failed                                         | PoisonFlag-Err, CheckPoison-Err, SetPoison-Err                                   |

### 8.4. E-SRC (Source)

| Code         | Severity | Detection    | Condition                                                    | DiagId                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------ | ---------------------------------------- |
| `E-SRC-0101` | Error    | Compile-time | Invalid UTF-8 byte sequence                                  | Step-Decode-Err                          |
| `E-SRC-0102` | Error    | Compile-time | Failed to read source file                                   | ReadBytes-Err                            |
| `E-SRC-0103` | Error    | Compile-time | Embedded BOM found after the first position                  | Step-EmbeddedBOM-Err                     |
| `E-SRC-0104` | Error    | Compile-time | Forbidden control character or null byte                     | Step-Prohibited-Err                      |
| `E-SRC-0301` | Error    | Compile-time | Unterminated string literal                                  | Lex-String-Unterminated                  |
| `E-SRC-0302` | Error    | Compile-time | Invalid escape sequence                                      | Lex-String-BadEscape, Lex-Char-BadEscape |
| `E-SRC-0303` | Error    | Compile-time | Invalid character literal                                    | Lex-Char-Invalid, Lex-Char-Unterminated  |
| `E-SRC-0304` | Error    | Compile-time | Malformed numeric literal                                    | Lex-Numeric-Err                          |
| `E-SRC-0306` | Error    | Compile-time | Unterminated block comment                                   | Block-Comment-Unterminated               |
| `E-SRC-0307` | Error    | Compile-time | Invalid Unicode in identifier                                | Lex-Ident-InvalidUnicode                 |
| `E-SRC-0308` | Error    | Compile-time | Lexically sensitive Unicode character outside `unsafe` block | LexSecure-Err                            |
| `E-SRC-0309` | Error    | Compile-time | Tokenization failed to classify a character sequence         | Max-Munch-Err                            |
| `E-SRC-0510` | Error    | Compile-time | Missing statement terminator                                 | Missing-Terminator-Err                   |
| `E-SRC-0520` | Error    | Compile-time | Generic syntax error (unexpected token)                      | Parse-Syntax-Err                         |

### 8.5. E-CNF (Conformance / Limits)

| Code         | Severity | Detection    | Condition                                                                                   | DiagId                                                                                    |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `E-CNF-0401` | Error    | Compile-time | Reserved keyword used as identifier                                                         | Validate-Module-Keyword-Err                                                               |
| `E-CNF-0402` | Error    | Compile-time | Reserved namespace `cursive.*` used by user code                                            | Validate-ModulePath-Reserved-Err, Intro-Reserved-Cursive-Err, Shadow-Reserved-Cursive-Err |
| `E-CNF-0403` | Error    | Compile-time | Primitive type name shadowed at module scope                                                | Validate-Module-Prim-Shadow-Err                                                           |
| `E-CNF-0404` | Error    | Compile-time | Shadowing of `Self`, `Drop`, `Bitcopy`, `Clone`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, or `Context`    | Validate-Module-Special-Shadow-Err                                                        |
| `E-CNF-0405` | Error    | Compile-time | Shadowing of async type alias (`Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`) | Validate-Module-Async-Shadow-Err                                                          |
| `E-CNF-0406` | Error    | Compile-time | User declaration uses `gen_` prefix                                                         | Intro-Reserved-Gen-Err, Shadow-Reserved-Gen-Err                                           |

### 8.6. E-UNS (Unsupported Constructs)

| Code         | Severity | Detection    | Condition                                              | DiagId                   |
| ------------ | -------- | ------------ | ------------------------------------------------------ | ------------------------ |
| `E-UNS-0101` | Error    | Compile-time | Unsupported construct in Cursive0 subset               | Unsupported-Construct    |
| `E-UNS-0102` | Error    | Compile-time | Array index must be a compile-time constant            | Index-Array-NonConst-Err |
| `E-UNS-0103` | Error    | Compile-time | Array index out of bounds                              | Index-Array-OOB-Err      |
| `E-UNS-0104` | Error    | Compile-time | `transmute` source and target alignments differ        | T-Transmute-AlignEq      |
| `E-UNS-0105` | Error    | Compile-time | `override` used with no concrete procedure to override | Override-NoConcrete      |
| `E-UNS-0106` | Error    | Compile-time | Conflicting procedure signatures from multiple classes | EffMethods-Conflict      |
| `E-UNS-0107` | Error    | Compile-time | Non-`Bitcopy` place expression used as value           | ValueUse-NonBitcopyPlace |
| `E-UNS-0108` | Error    | Compile-time | Range expression used as index in Cursive0 subset      | Range-NonIndex-Err       |
| `E-UNS-0110` | Error    | Compile-time | `import` declaration used                              | WF-Import-Unsupported    |
| `E-UNS-0111` | Error    | Compile-time | `[[unwind]]` attribute used                            | WF-Unwind-Unsupported    |
| `E-UNS-0112` | Error    | Compile-time | `extern` block or foreign declaration used             | Parse-Extern-Unsupported |
| `E-UNS-0113` | Error    | Compile-time | Attribute syntax used                                  | WF-Attr-Unsupported      |

### 8.7. E-MEM (Memory)

| Code         | Severity | Detection    | Condition                                                            | DiagId                                                                                   |
| ------------ | -------- | ------------ | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| `E-MEM-1206` | Error    | Compile-time | Named region not found for allocation                                | Alloc-Region-NotFound-Err                                                                |
| `E-MEM-1207` | Error    | Compile-time | `frame` used with no active region in scope                          | Frame-NoActiveRegion-Err                                                                 |
| `E-MEM-1208` | Error    | Compile-time | `r.frame` target is not in `Region@Active` state                     | Frame-Target-NotActive-Err                                                               |
| `E-MEM-3001` | Error    | Compile-time | Read or move of a binding in Moved or PartiallyMoved state           | B-Place-Moved-Err, B-Move-Whole-Moved-Err, B-Move-Field-Moved-Err                        |
| `E-MEM-3003` | Error    | Compile-time | Reassignment of immutable binding                                    | B-Assign-Immutable-Err                                                                   |
| `E-MEM-3004` | Error    | Compile-time | Partial move from binding without `unique` permission                | B-Move-Field-NonUnique-Err                                                               |
| `E-MEM-3005` | Error    | Compile-time | Explicit call to `Drop::drop` method                                 | Drop-Call-Err, Drop-Call-Err-Dyn                                                         |
| `E-MEM-3006` | Error    | Compile-time | Attempt to move from immovable binding (`:=`)                        | B-Move-Whole-Immovable-Err, B-Move-Field-Immovable-Err                                   |
| `E-MEM-3007` | Error    | Compile-time | `unique` binding from place expression requires explicit `move`      | B-LetVar-UniqueNonMove-Err, B-ShadowLet-UniqueNonMove-Err, B-ShadowVar-UniqueNonMove-Err |
| `E-MEM-3020` | Error    | Compile-time | Value with shorter-lived provenance escapes to longer-lived location | Prov-Escape-Err                                                                          |
| `E-MEM-3021` | Error    | Compile-time | Region allocation `^` outside region scope                           | Alloc-Implicit-NoRegion-Err                                                              |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Transmute-Unsafe-Err                                                                     |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | AllocRaw-Unsafe-Err                                                                      |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | DeallocRaw-Unsafe-Err                                                                    |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Region-Unchecked-Unsafe-Err                                                              |

### 8.8. W-MOD (Module Warnings)

| Code         | Severity | Detection    | Condition                                                      |
| ------------ | -------- | ------------ | -------------------------------------------------------------- |
| `W-MOD-1101` | Warning  | Compile-time | Potential module path collision on case-insensitive filesystem |

### 8.9. W-SRC (Source Warnings)

| Code         | Severity | Detection    | Condition                                                   |
| ------------ | -------- | ------------ | ----------------------------------------------------------- |
| `W-SRC-0101` | Warning  | Compile-time | UTF-8 BOM present at the start of the file                  |
| `W-SRC-0301` | Warning  | Compile-time | Leading zeros in decimal literal                            |
| `W-SRC-0308` | Warning  | Compile-time | Lexically sensitive Unicode character within `unsafe` block |

### 8.10. E-TYP (Types)

| Code         | Severity | Detection    | Condition                                                                                              | DiagId                                                                                                                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `E-TYP-1101` | Error    | Compile-time | `shared` permission not supported in Cursive0                                                          | Perm-Shared-Unsupported                                                                                                                  |
| `E-TYP-1505` | Error    | Compile-time | Missing required type annotation at module scope                                                       | WF-StaticDecl-MissingType, WF-ProcedureDecl-MissingReturnType                                                                            |
| `E-TYP-1530` | Error    | Compile-time | Type inference failed; unable to determine type                                                        | T-LetStmt-Infer-Err, T-VarStmt-Infer-Err, T-ShadowLetStmt-Infer-Err, T-ShadowVarStmt-Infer-Err, PtrNull-Infer-Err, NullLiteral-Infer-Err |
| `E-TYP-1506` | Error    | Compile-time | Type alias cycle detected                                                                              | TypeAlias-Recursive-Err                                                                                                                  |
| `E-TYP-1507` | Error    | Compile-time | Procedure with non-unit return type requires explicit return statement                                 | WF-ProcBody-ExplicitReturn-Err                                                                                                           |
| `E-TYP-1601` | Error    | Compile-time | Mutation through `const` path                                                                          | B-Assign-Const-Err                                                                                                                       |
| `E-TYP-1602` | Error    | Compile-time | `unique` exclusion violation (aliasing or inactive use)                                                | B-Place-Unique-Err                                                                                                                       |
| `E-TYP-1603` | Error    | Compile-time | Non-`move` argument must be a place expression                                                         | Call-Arg-NotPlace                                                                                                                        |
| `E-TYP-1605` | Error    | Compile-time | Receiver permission incompatible with caller                                                           | MethodCall-RecvPerm-Err                                                                                                                  |
| `E-TYP-1801` | Error    | Compile-time | Tuple index out of bounds                                                                              | TupleIndex-OOB                                                                                                                           |
| `E-TYP-1802` | Error    | Compile-time | Tuple index is not a compile-time constant integer literal                                             | TupleIndex-NonConst                                                                                                                      |
| `E-TYP-1803` | Error    | Compile-time | Tuple arity mismatch in assignment or pattern                                                          | Pat-Tuple-Arity-Err, Pat-Tuple-R-Arity-Err                                                                                               |
| `E-TYP-1810` | Error    | Compile-time | Array length is not a compile-time constant                                                            | ConstLen-Err                                                                                                                             |
| `E-TYP-1812` | Error    | Compile-time | Array index expression has non-`usize` type                                                            | Index-Array-NonUsize, AddrOf-Index-Array-NonUsize                                                                                        |
| `E-TYP-1820` | Error    | Compile-time | Slice index expression has non-`usize` type                                                            | Index-Slice-NonUsize, AddrOf-Index-Slice-NonUsize                                                                                        |
| `E-TYP-1821` | Error    | Compile-time | Direct slice indexing not permitted in Cursive0 subset                                                 | Index-Slice-Direct-Err                                                                                                                   |
| `E-TYP-1901` | Error    | Compile-time | Duplicate field name in record declaration                                                             | WF-Record-DupField                                                                                                                       |
| `E-TYP-1902` | Error    | Compile-time | Missing field initializer in record literal                                                            | Record-FieldInit-Missing                                                                                                                 |
| `E-TYP-1903` | Error    | Compile-time | Duplicate field initializer in record literal                                                          | Record-FieldInit-Dup                                                                                                                     |
| `E-TYP-1904` | Error    | Compile-time | Access to nonexistent field                                                                            | FieldAccess-Unknown, Record-Field-Unknown                                                                                                |
| `E-TYP-1905` | Error    | Compile-time | Access to field not visible in current scope                                                           | FieldAccess-NotVisible, Record-Field-NotVisible                                                                                          |
| `E-TYP-1906` | Error    | Compile-time | Field visibility exceeds record visibility                                                             | FieldVisOk-Err                                                                                                                           |
| `E-TYP-1907` | Error    | Compile-time | Non-`Bitcopy` field requires move source expression                                                    | Record-Field-NonBitcopy-Move                                                                                                             |
| `E-TYP-1911` | Error    | Compile-time | Default record construction requires default initializer for every field                               | Record-Default-Init-Err                                                                                                                  |
| `E-TYP-1912` | Error    | Compile-time | Explicit receiver type must be `Self` for record methods                                               | Record-Method-RecvSelf-Err                                                                                                               |
| `E-TYP-1920` | Error    | Compile-time | Enum discriminant is not an integer literal                                                            | Enum-Disc-NotInt                                                                                                                         |
| `E-TYP-1921` | Error    | Compile-time | Enum discriminant literal is invalid                                                                   | Enum-Disc-Invalid                                                                                                                        |
| `E-TYP-1922` | Error    | Compile-time | Enum discriminant must be non-negative                                                                 | Enum-Disc-Negative                                                                                                                       |
| `E-TYP-1923` | Error    | Compile-time | Duplicate enum discriminant value                                                                      | Enum-Disc-Dup                                                                                                                            |
| `E-TYP-2050` | Error    | Compile-time | Modal type declares zero states                                                                        | Modal-NoStates-Err                                                                                                                       |
| `E-TYP-2051` | Error    | Compile-time | Duplicate state name within modal type                                                                 | Modal-DupState-Err                                                                                                                       |
| `E-TYP-2052` | Error    | Compile-time | Field access for field not present in current state's payload                                          | Modal-Field-Missing                                                                                                                      |
| `E-TYP-2053` | Error    | Compile-time | Method invocation for method not available in current state                                            | Modal-Method-NotFound                                                                                                                    |
| `E-TYP-2054` | Error    | Compile-time | State name collides with modal type name                                                               | Modal-StateName-Err                                                                                                                      |
| `E-TYP-2055` | Error    | Compile-time | Transition body returns value not matching declared target state                                       | Transition-Body-Err                                                                                                                      |
| `E-TYP-2056` | Error    | Compile-time | Transition invoked on value not of declared source state                                               | Transition-Source-Err                                                                                                                    |
| `E-TYP-2057` | Error    | Compile-time | Direct field access on general modal type without pattern matching                                     | Modal-Field-General-Err                                                                                                                  |
| `E-TYP-2058` | Error    | Compile-time | Duplicate field name in modal state payload                                                            | Modal-Payload-DupField                                                                                                                   |
| `E-TYP-2059` | Error    | Compile-time | Transition target state not declared in modal type                                                     | Transition-Target-Err                                                                                                                    |
| `E-TYP-2060` | Error    | Compile-time | Non-exhaustive match on general modal type                                                             | Match-Modal-NonExhaustive                                                                                                                |
| `E-TYP-2061` | Error    | Compile-time | Duplicate method name in modal state                                                                   | StateMethod-Dup                                                                                                                          |
| `E-TYP-2062` | Error    | Compile-time | Duplicate transition name in modal state                                                               | Transition-Dup                                                                                                                           |
| `E-TYP-2063` | Error    | Compile-time | State member visibility exceeds modal visibility                                                       | StateMemberVisOk-Err                                                                                                                     |
| `E-TYP-2064` | Error    | Compile-time | State member not visible in current scope                                                              | Modal-Field-NotVisible, Transition-NotVisible, Modal-Method-NotVisible                                                                   |
| `E-TYP-2070` | Error    | Compile-time | Implicit widening on non-niche-layout-compatible type                                                  | Chk-Subsumption-Modal-NonNiche                                                                                                           |
| `E-TYP-2071` | Error    | Compile-time | `widen` applied to non-modal type                                                                      | Widen-NonModal                                                                                                                           |
| `E-TYP-2072` | Error    | Compile-time | `widen` applied to already-general modal type                                                          | Widen-AlreadyGeneral                                                                                                                     |
| `E-TYP-2073` | Error    | Compile-time | Record literal whose type is `File@S` or `DirIter@S` for any state `S` in the corresponding modal type | Record-FileDir-Err                                                                                                                       |
| `E-TYP-2101` | Error    | Compile-time | Dereference of pointer in `@Null` state                                                                | Deref-Null                                                                                                                               |
| `E-TYP-2102` | Error    | Compile-time | Dereference of pointer in `@Expired` state                                                             | Deref-Expired                                                                                                                            |
| `E-TYP-2103` | Error    | Compile-time | Dereference of raw pointer outside `unsafe`                                                            | Deref-Raw-Unsafe                                                                                                                         |
| `E-TYP-2104` | Error    | Compile-time | Address-of applied to non-place expression                                                             | AddrOf-NonPlace                                                                                                                          |
| `E-MEM-3031` | Error    | Compile-time | `transmute` source and target sizes differ                                                             | T-Transmute-SizeEq                                                                                                                       |
| `E-TYP-2201` | Error    | Compile-time | Union type has fewer than two member types                                                             | WF-Union-TooFew                                                                                                                          |
| `E-TYP-2202` | Error    | Compile-time | Direct access on union value without pattern matching                                                  | Union-DirectAccess-Err                                                                                                                   |
| `E-TYP-2402` | Error    | Compile-time | Implementing type missing required field                                                               | Impl-Field-Missing                                                                                                                       |
| `E-TYP-2404` | Error    | Compile-time | Implementing field has incompatible type                                                               | Impl-Field-Type-Err                                                                                                                      |
| `E-TYP-2406` | Error    | Compile-time | Conflicting field names from multiple classes                                                          | EffFields-Conflict                                                                                                                       |
| `E-TYP-2408` | Error    | Compile-time | Duplicate abstract field name in class                                                                 | Class-AbstractField-Dup                                                                                                                  |
| `E-TYP-2500` | Error    | Compile-time | Duplicate procedure name in class                                                                      | Class-Method-Dup                                                                                                                         |
| `E-TYP-2501` | Error    | Compile-time | `override` used on abstract procedure implementation                                                   | Override-Abstract-Err                                                                                                                    |
| `E-TYP-2502` | Error    | Compile-time | Missing `override` on concrete procedure replacement                                                   | Override-Missing-Err                                                                                                                     |
| `E-TYP-2503` | Error    | Compile-time | Type does not implement required procedure from class or has incompatible signature                    | Impl-Missing-Method, Impl-Sig-Err, Impl-Sig-Err-Concrete                                                                                 |
| `E-TYP-2505` | Error    | Compile-time | Name conflict among class members                                                                      | Class-Name-Conflict                                                                                                                      |
| `E-TYP-2506` | Error    | Compile-time | Coherence violation: duplicate class implementation                                                    | Impl-Dup, Impl-Duplicate-Class-Err                                                                                                       |
| `E-TYP-2508` | Error    | Compile-time | Cyclic superclass dependency detected                                                                  | Superclass-Cycle                                                                                                                         |
| `E-TYP-2509` | Error    | Compile-time | Superclass bound refers to undefined class                                                             | Superclass-Undefined                                                                                                                     |
| `E-TYP-2541` | Error    | Compile-time | Dynamic class type created from non-dispatchable class                                                 | Dynamic-NonDispatchable                                                                                                                  |
| `E-TYP-2621` | Error    | Compile-time | Type implements both `Bitcopy` and `Drop`                                                              | BitcopyDrop-Conflict                                                                                                                     |
| `E-TYP-2622` | Error    | Compile-time | `Bitcopy` type has non-`Bitcopy` field                                                                 | Bitcopy-Field-NonBitcopy                                                                                                                 |
| `E-TYP-2623` | Error    | Compile-time | Type implementing `Bitcopy` does not implement `Clone`                                                              | Bitcopy-Clone-Missing                                                                                                                    |

### 8.11. W-SYS (System Warnings)

| Code         | Severity | Detection    | Condition                                               |
| ------------ | -------- | ------------ | ------------------------------------------------------- |
| `W-SYS-4010` | Warning  | Compile-time | Modal widening involves large payload copy (>256 bytes) |

### 8.12. E-SEM (Semantics)

| Code         | Severity | Detection    | Condition                                            | DiagId                                            |
| ------------ | -------- | ------------ | ---------------------------------------------------- | ------------------------------------------------- |
| `E-SEM-2524` | Error    | Compile-time | Tuple access on non-tuple                            | TupleAccess-NotTuple                              |
| `E-SEM-2527` | Error    | Compile-time | Indexing applied to non-indexable type               | Index-NonIndexable                                |
| `E-SEM-2531` | Error    | Compile-time | Callee expression is not of FUNCTION type            | Call-Callee-NotFunc                               |
| `E-SEM-2532` | Error    | Compile-time | Argument count mismatch                              | Call-ArgCount-Err                                 |
| `E-SEM-2533` | Error    | Compile-time | Argument type incompatible with parameter type       | Call-ArgType-Err                                  |
| `E-SEM-2534` | Error    | Compile-time | `move` argument required but not provided            | Call-Move-Missing                                 |
| `E-SEM-2535` | Error    | Compile-time | `move` argument provided but parameter is not `move` | Call-Move-Unexpected                              |
| `E-SEM-2536` | Error    | Compile-time | Method not found for receiver type                   | LookupMethod-NotFound, LookupClassMethod-NotFound |
| `E-SEM-2705` | Error    | Compile-time | `match` expression is not exhaustive for union type  | Match-Union-NonExhaustive                         |
| `E-SEM-2711` | Error    | Compile-time | Refutable pattern in irrefutable context (`let`)     | Let-Refutable-Pattern-Err                         |
| `E-SEM-2713` | Error    | Compile-time | Duplicate binding identifier within single pattern   | Pat-Dup-Err, Pat-Dup-R-Err                        |
| `E-SEM-2721` | Error    | Compile-time | Range pattern bounds are not compile-time constants  | RangePattern-NonConst                             |
| `E-SEM-2722` | Error    | Compile-time | Range pattern start exceeds end (empty range)        | RangePattern-Empty                                |
| `E-SEM-2731` | Error    | Compile-time | Record pattern references non-existent field         | RecordPattern-UnknownField                        |
| `E-SEM-3011` | Error    | Compile-time | Method defined outside of type context               | Method-Context-Err                                |
| `E-SEM-3012` | Error    | Compile-time | Duplicate method name in type                        | Record-Method-Dup                                 |
| `E-SEM-3131` | Error    | Compile-time | Assignment target is not a place expression          | Assign-NotPlace                                   |
| `E-SEM-3132` | Error    | Compile-time | Assignment through `const` permission                | Assign-Const-Err                                  |
| `E-SEM-3133` | Error    | Compile-time | Assignment type mismatch                             | Assign-Type-Err                                   |
| `E-SEM-3151` | Error    | Compile-time | Defer block has non-unit type                        | Defer-NonUnit-Err                                 |
| `E-SEM-3152` | Error    | Compile-time | Non-local control flow in defer block                | Defer-NonLocal-Err                                |
| `E-SEM-3161` | Error    | Compile-time | `return` type mismatch with procedure                | Return-Type-Err                                   |
| `E-SEM-3162` | Error    | Compile-time | `break` outside `loop`                               | Break-Outside-Loop                                |
| `E-SEM-3163` | Error    | Compile-time | `continue` outside `loop`                            | Continue-Outside-Loop                             |
| `E-SEM-3164` | Error    | Compile-time | `result` type mismatch with block                    | BlockInfo-Res-Err                                 |
| `E-SEM-3165` | Error    | Compile-time | `return` at module scope                             | Return-At-Module-Err                              |

### 8.13. W-SEM (Semantic Warnings)

| Code         | Severity | Detection    | Condition                               | DiagId                  |
| ------------ | -------- | ------------ | --------------------------------------- | ----------------------- |
| `W-SEM-1001` | Warning  | Compile-time | Unreachable code after result statement | Warn-Result-Unreachable |

## 9. Appendix B - Notation and Glossary

### 9.1. Notation Conventions
$$F(x_1,\ldots,x_n) = F^{(n)}(x_1,\ldots,x_n)$$
$$n \ne m \Rightarrow F^{(n)} \ne F^{(m)}$$

### 9.2. Helper Functions and Relations
$$\text{UnicodeNFC}_{15.0.0}\ \text{and}\ \text{UnicodeCaseFold}_{15.0.0}\ \text{are defined by the Unicode Standard 15.0.0 and are normative for this document}$$
$$\text{LLVMText}_{21}\ \text{and}\ \text{LLVMObj}_{21}\ \text{are defined by LLVM 21 tool acceptance for textual IR and object emission respectively}$$

**HelperRef.**
$$\text{HelperRef}(\text{Fold}) = \texttt{"2.3.2"}$$
$$\text{HelperRef}(\text{DirSeq}) = \texttt{"2.3.3"}$$
$$\text{HelperRef}(\text{Modules}) = \texttt{"2.4"}$$
$$\text{HelperRef}(\text{ModuleList}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{OutputRoot}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{OutputPaths}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{SearchDirs}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{ResolveTool}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{AssembleIR}) = \texttt{"2.6"}$$
$$\text{HelperRef}(\text{IdKey}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{IdEq}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{CaseFold}) = \texttt{"3.1.6"}$$
$$\text{HelperRef}(\text{Span}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{SpanOf}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{ClampSpan}) = \texttt{"1.6"}$$
$$\text{HelperRef}(\text{AliasExpand}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ModulePrefix}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{Reachable}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsTy}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsRef}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsExpr}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{TypeRefsPat}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefs}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefsArgs}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{ValueRefsFields}) = \texttt{"5.12"}$$
$$\text{HelperRef}(\text{Topo}) = \texttt{"7.1"}$$
$$\text{HelperRef}(\text{EntryKey}) = \texttt{"7.7"}$$
$$\text{HelperRef}(\text{PathOrderKey}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{TypeKey}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\prec_{\text{type}}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{Members}) = \texttt{"5.2.7"}$$
$$\text{HelperRef}(\text{MemberList}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{DistinctMembers}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{SingleFieldPayload}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{PayloadState}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{EmptyState}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheSet}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheCount}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheOrder}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{NicheApplies}) = \texttt{"6.1.4.1"}$$
$$\text{HelperRef}(\text{StaticJudgments}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{PremisesHold}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{PermSyntax}) = \texttt{"5.2.2"}$$
$$\text{HelperRef}(\text{Behavior}) = \texttt{"1.2"}$$
$$\text{HelperRef}(\text{ResourceExhaustion}) = \texttt{"1.3"}$$
$$\text{HelperRef}(\text{OutsideConformance}) = \texttt{"1.3"}$$
$$\text{HelperRef}(\text{SpanRange}) = \texttt{"1.6.1"}$$
$$\text{HelperRef}(\text{SeverityColumn}) = \texttt{"8"}$$
$$\text{HelperRef}(\text{ConditionColumn}) = \texttt{"8"}$$
$$\text{HelperRef}(\text{HasError}) = \texttt{"1.6.3"}$$
$$\text{HelperRef}(\text{CompileStatus}) = \texttt{"1.6.3"}$$
$$\text{HelperRef}(\text{NoDiag}) = \texttt{"1.6.4"}$$
$$\text{HelperRef}(\text{HostPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{FSPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{FilePrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{DirPrim}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{MapsToDiagOrRuntime}) = \texttt{"1.7"}$$
$$\text{HelperRef}(\text{WinSep}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{AbsPath}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{DriveRooted}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{UNC}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{RootRelative}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{FoldPath}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{FileKey}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{DirKey}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{Basename}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{FileExt}) = \texttt{"2.1"}$$
$$\text{HelperRef}(\text{Utf8LexLess}) = \texttt{"2.3"}$$
$$\text{HelperRef}(\text{BMap}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Hex2}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Concat}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{Overwrites}) = \texttt{"2.5"}$$
$$\text{HelperRef}(\text{IsDir}) = \texttt{"2.5"}$$
$$\text{Overwrites}(p,b) \iff \exists fs,\omega,\omega'.\ \text{FSWriteFile}(fs,p,b,\omega) \Downarrow (ok,\omega')$$
$$\text{IsDir}(p) \iff \exists fs,\omega,\omega'.\ \text{FSKind}(fs,p,\omega) \Downarrow (\texttt{Dir},\omega')$$

**Auxiliary String/Sequence Operators.**
$$\text{At}(s,i) = s[i]$$
$$\text{StartsWith}(s,p) \iff s[0..|p|) = p$$
$$\text{EndsWith}(s,p) \iff s[|s|-|p|..|s|) = p$$
$$\text{Remove}(s,c) = [\ s[i]\ \mid\ 0 \le i < |s|\ \land\ s[i] \ne c\ ]$$
$$\text{Concat}([]) = \texttt{"\""}$$
$$\text{Concat}([s]) = s$$
$$\text{Concat}(s::ss) = s \mathbin{+\!\!+} \text{Concat}(ss) \quad (|ss|>0)$$
$$\text{HexDigit}(0)=\texttt{"0"}\ \ldots\ \text{HexDigit}(9)=\texttt{"9"}\ \ldots\ \text{HexDigit}(15)=\texttt{"f"}$$
$$\text{Hex2}(b) = \text{HexDigit}(\lfloor b/16 \rfloor) \mathbin{+\!\!+} \text{HexDigit}(b \bmod 16)$$


**Hex Values.**
$$\text{HexDigitValue}(\texttt{'0'})=0 \quad \text{HexDigitValue}(\texttt{'1'})=1 \quad \text{HexDigitValue}(\texttt{'2'})=2 \quad \text{HexDigitValue}(\texttt{'3'})=3 \quad \text{HexDigitValue}(\texttt{'4'})=4 \quad \text{HexDigitValue}(\texttt{'5'})=5 \quad \text{HexDigitValue}(\texttt{'6'})=6 \quad \text{HexDigitValue}(\texttt{'7'})=7 \quad \text{HexDigitValue}(\texttt{'8'})=8 \quad \text{HexDigitValue}(\texttt{'9'})=9$$
$$\text{HexDigitValue}(\texttt{'a'})=10 \quad \text{HexDigitValue}(\texttt{'b'})=11 \quad \text{HexDigitValue}(\texttt{'c'})=12 \quad \text{HexDigitValue}(\texttt{'d'})=13 \quad \text{HexDigitValue}(\texttt{'e'})=14 \quad \text{HexDigitValue}(\texttt{'f'})=15$$
$$\text{HexDigitValue}(\texttt{'A'})=10 \quad \text{HexDigitValue}(\texttt{'B'})=11 \quad \text{HexDigitValue}(\texttt{'C'})=12 \quad \text{HexDigitValue}(\texttt{'D'})=13 \quad \text{HexDigitValue}(\texttt{'E'})=14 \quad \text{HexDigitValue}(\texttt{'F'})=15$$
$$\text{HexValue}(h_1\ldots h_n) = \sum_{k=1}^{n} \text{HexDigitValue}(h_k) \cdot 16^{n-k}$$
$$\text{DecDigitValue}(\texttt{'0'})=0 \quad \text{DecDigitValue}(\texttt{'1'})=1 \quad \text{DecDigitValue}(\texttt{'2'})=2 \quad \text{DecDigitValue}(\texttt{'3'})=3 \quad \text{DecDigitValue}(\texttt{'4'})=4 \quad \text{DecDigitValue}(\texttt{'5'})=5 \quad \text{DecDigitValue}(\texttt{'6'})=6 \quad \text{DecDigitValue}(\texttt{'7'})=7 \quad \text{DecDigitValue}(\texttt{'8'})=8 \quad \text{DecDigitValue}(\texttt{'9'})=9$$
$$\text{OctDigitValue}(\texttt{'0'})=0 \quad \text{OctDigitValue}(\texttt{'1'})=1 \quad \text{OctDigitValue}(\texttt{'2'})=2 \quad \text{OctDigitValue}(\texttt{'3'})=3 \quad \text{OctDigitValue}(\texttt{'4'})=4 \quad \text{OctDigitValue}(\texttt{'5'})=5 \quad \text{OctDigitValue}(\texttt{'6'})=6 \quad \text{OctDigitValue}(\texttt{'7'})=7$$
$$\text{BinDigitValue}(\texttt{'0'})=0 \quad \text{BinDigitValue}(\texttt{'1'})=1$$
$$\text{DecValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{DecDigitValue}(d_k) \cdot 10^{n-k}$$
$$\text{OctValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{OctDigitValue}(d_k) \cdot 8^{n-k}$$
$$\text{BinValue}(d_1\ldots d_n) = \sum_{k=1}^{n} \text{BinDigitValue}(d_k) \cdot 2^{n-k}$$

**Rule-Section Map.**
$$\text{SectionId}(r) \in \text{String}$$
$$\text{RulesIn}(\Sigma) = \{ r \mid \text{SectionId}(r) \in \Sigma \}$$

**EmitList.**
$$\text{EmitList}([]) = \text{ok}$$
$$\text{EmitList}([d] \mathbin{+\!\!+} ds) = (\Gamma \vdash \text{Emit}(d)) \land \text{EmitList}(ds)$$

**ArgMax.**
$$\arg\max_{x \in C} g(x) = x^\ast \iff x^\ast \in C \land \forall y \in C.\ g(x^\ast) \ge g(y) \land (\forall z \in C.\ g(z)=g(x^\ast) \Rightarrow z=x^\ast)$$








