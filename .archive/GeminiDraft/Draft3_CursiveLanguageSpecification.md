## Clause 1: General Principles and Conformance

### 1.1 Conformance Obligations

**<u>Definition</u>**

  * **Conforming Implementation**: An implementation of the Cursive language that satisfies all normative requirements defined in this specification.
  * **Conforming Program**: A Cursive program that is **well-formed** according to the static semantics of the language and relies only on defined behaviors (excluding Unverifiable Behavior unless attested).
  * **Conformance Dossier**: A machine-readable JSON artifact generated by the compiler that documents the specific safety characteristics, active attestations, and implementation-defined choices of a build.

**<u>Constraints & Legality</u>**

  * **Implementation Requirements**: A conforming implementation **MUST**:
    1.  Accept any program that is well-formed according to this specification.
    2.  Reject any program that is ill-formed (violates syntax or static semantics), issuing at least one error diagnostic, unless the violation is classified as **IFNDR** (¬ß1.3.1).
    3.  Support both **Permissive** and **Strict** conformance modes (¬ß1.2).
    4.  Generate a **Conformance Dossier** matching the schema defined in **Appendix C** for every compilation, regardless of mode.
  * **Program Requirements**: A program is conforming if and only if it is accepted by a conforming implementation in **Strict Mode**.

### 1.2 Conformance Modes

**<u>Definition</u>**

**Conformance Modes** are distinct compilation configurations that govern the strictness of safety enforcement regarding `unsafe` code usage.

**<u>Static Semantics</u>**

  * **Permissive Mode**:
      * Intended for development and transitional states.
      * The compiler **MUST** issue a **warning** (diagnostic `W-MEM-3030`) for any `unsafe` block that lacks a valid `[[attestation]]` attribute.
      * The compiler **MUST** record these unattested blocks in the `unattested_violations` section of the Conformance Dossier.
  * **Strict Mode**:
      * Intended for production and verification.
      * The compiler **MUST** issue an **error** (diagnostic `E-MEM-3030`) for any `unsafe` block that lacks a valid `[[attestation]]` attribute.
      * The compilation **MUST** fail if any unattested `unsafe` blocks are present.

### 1.3 Behavior Classifications

**<u>Definition</u>**

The execution semantics of Cursive programs are categorized into four classes:

1.  **Defined Behavior**: The specification prescribes the exact behavior.
2.  **Implementation-Defined Behavior (IDB)**: The specification permits a range of behaviors, and the implementation **MUST** document its choice.
3.  **Unspecified Behavior (USB)**: The specification permits a set of outcomes; the implementation **MAY** choose any from the set without documentation.
4.  **Unverifiable Behavior (UVB)**: Operations where the language model cannot enforce safety (e.g., FFI, raw pointers).

**<u>Constraints & Legality</u>**

  * **UVB Containment**: Unverifiable Behavior **MUST** occur only within `unsafe` blocks or `extern` procedure calls.
  * **IDB Documentation**: All IDB choices (e.g., size of `usize`, layout of non-C records) **MUST** be explicitly recorded in the `implementation_defined_behavior` section of the Conformance Dossier.
  * **Safety Boundary**: Neither USB nor IDB **MAY** result in memory corruption or type safety violations in `safe` code. Their effects **MUST** be bounded by the language's safety guarantees.

#### 1.3.1 Ill-Formed, No Diagnostic Required (IFNDR)

**<u>Definition</u>**

**IFNDR** refers to a category of program errors where detecting the violation is computationally infeasible or undecidable (e.g., Halting Problem constraints), exempting the compiler from the requirement to emit a diagnostic.

**<u>Constraints & Legality</u>**

  * **Safety Boundary**: An IFNDR program has unspecified behavior (USB), but even in the presence of IFNDR, the implementation **MUST NOT** introduce Unverifiable Behavior (UVB) in `safe` code. The runtime effects **MUST** be bounded (e.g., predictable termination or panic rather than memory corruption).
  * **Tracking Requirement**: Implementations **MUST** track instances where IFNDR logic is triggered during compilation (e.g., constant evaluation steps hitting a limit without a definitive error proof).
  * **Reporting Requirement**: All encountered IFNDR instances **MUST** be reported in the `ifndr_instances` list of the Conformance Dossier.
  * **Instance Data**: Each reported IFNDR instance **MUST** include the location (file, line, module) and a category identifier (e.g., "Recursion Limits").

**<u>Examples</u>**

  * **OOB in Const Eval**: Index out of bounds during constant evaluation where the index is not a static constant.
  * **Recursion Limits**: Exceeding implementation limits in complex template/macro expansions.

### 1.4 The Attestation System

**<u>Definition</u>**

The **Attestation System** is an attribute-based mechanism used to formally justify and audit the usage of `unsafe` code.

**<u>Syntax & Declaration</u>**

The `[[attestation]]` attribute **MUST** conform to the following schema:

```cursive
[[attestation(
    method: "...",  // Verification method (e.g., "Manual Audit")
    auditor: "...", // Identifier of the verifier
    date: "...",    // Date of verification (YYYY-MM-DD)
    proof: "...",   // URI or reference to evidence
    comment: "..."  // Explanation of safety
)]]
```

**<u>Constraints & Legality</u>**

  * **Mandatory Fields**: The attribute **MUST** contain all five fields: `method`, `auditor`, `date`, `proof`, `comment`. Missing fields **MUST** trigger diagnostic `E-DEC-2450`.
  * **Placement**: The attribute **MUST** immediately precede an `unsafe` block.
  * **Strict Mode Enforcement**: In `strict` mode, any `unsafe` block not preceded by a valid `[[attestation]]` **MUST** trigger diagnostic `E-MEM-3030` (Error).
  * **Permissive Mode Enforcement**: In `permissive` mode, missing attestations **MUST** trigger diagnostic `W-MEM-3030` (Warning).

### 1.5 Implementation Limits

**<u>Definition</u>**

**Implementation Limits** are the boundaries of resource consumption or complexity that an implementation supports.

**<u>Constraints & Legality</u>**

  * **Minimum Limits**: All conforming implementations **MUST** support at least the following limits. Programs within these limits **MUST** be accepted.
      * **Source File Size**: $1$ MiB ($2^{20}$ bytes).
      * **Line Length**: $16,384$ ($2^{14}$) characters.
      * **Logical Lines**: $65,535$ ($2^{16} - 1$).
      * **Syntactic Nesting**: $256$ levels (blocks, expressions).
      * **Identifier Length**: $1,023$ characters.
      * **Declarations**: $255$ parameters per procedure, $1,024$ fields per record.
  * **Documentation**: Implementations **MUST** document their actual supported limits in the Conformance Dossier.

### 1.6 Language Evolution

**<u>Definition</u>**
The language evolution model defines how changes to the specification are versioned and adopted.

**<u>Constraints & Legality</u>**

  * **Versioning**: The language version **MUST** follow the format `MAJOR.MINOR.PATCH`. Implementations **MUST** reject programs declaring an incompatible `MAJOR` version.
  * **Editions**:
      * Editions are optional mechanisms for grouping incompatible changes.
      * Semantics from different editions **MUST NOT** be mixed within a single compilation unit.
  * **Stability Classes**: Features **MUST** be classified as:
      * **Stable**: Available by default. Breaking changes restricted to MAJOR versions.
      * **Preview**: Requires explicit opt-in via feature flag. Semantics **MAY** change in MINOR versions.
      * **Experimental**: Requires opt-in. **MAY** be removed or changed at any time.
  * **Deprecation**: Deprecated features **MUST** remain functional for at least one full MINOR version following deprecation and **MUST** trigger a warning upon use.
  * **Feature Flags**: Preview/Experimental features **MUST** be enabled via flags. Usage without the flag **MUST** trigger an error. Unknown flags **MUST** trigger an error.
  * **Vendor Extensions**: Vendor-specific attributes or features **MUST** use a reverse-domain namespace (e.g., `com.vendor.feature`). The `cursive.*` namespace is reserved.

---

## Clause 2: Lexical Structure and Source

### 2.1 Source Text & Encoding

**<u>Definition</u>**

  * **Source Byte Stream**: The raw, uninterpreted sequence of octets ($b_0, b_1, \dots, b_n$) provided as input to the compiler from a file, stream, or other storage medium.
  * **Normalized Source File**: A finite sequence of Unicode Scalar Values ($S = [c_0, c_1, \dots, c_m]$) resulting from the successful execution of the Preprocessing Pipeline. This sequence serves as the input to the Lexical Analysis phase.
  * **Unicode Scalar Value**: Any Unicode code point in the range `U+0000` to `U+D7FF` inclusive or `U+E000` to `U+10FFFF` inclusive.
  * **Byte Order Mark (BOM)**: The Unicode character `U+FEFF`.

**<u>Static Semantics</u>**

**The Preprocessing Pipeline**
A conforming implementation **MUST** transform a Source Byte Stream into a Normalized Source File by executing the following six operations in the strict order defined below. Failure at any step **MUST** terminate the pipeline and reject the compilation unit.

1.  **Size Validation**:
    The implementation **MUST** determine the length of the Source Byte Stream in bytes. If the length exceeds the implementation-defined maximum limit $L_{max}$, the implementation **MUST** emit `E-SRC-0102`.

2.  **UTF-8 Decoding**:
    The stream **MUST** be decoded according to the UTF-8 encoding scheme defined in RFC 3629.

      * The input is a sequence of octets.
      * The output is a sequence of Unicode Scalar Values.
      * Any byte sequence that is not well-formed UTF-8 (e.g., overlong encodings, surrogate code points, invalid start bytes) **MUST** trigger `E-SRC-0101`. The diagnostic **MUST** report the byte offset of the first invalid octet.

3.  **BOM Stripping**:
    If the first scalar value of the decoded sequence is `U+FEFF` (BOM), it **MUST** be removed from the sequence.

      * If a BOM is present, the implementation **SHOULD** emit warning `W-SRC-0101`.
      * If a `U+FEFF` scalar value appears at any position other than the first (post-decoding), the implementation **MUST** emit `E-SRC-0103`.

4.  **Line Normalization**:
    The sequence **MUST** be transformed to normalize line endings to the canonical Line Feed (`U+000A`).
    Let $S_{in}$ be the input sequence and $S_{out}$ be the output. The transformation is defined recursively:

      * Sequence `CR` `LF` (`U+000D` `U+000A`) $\rightarrow$ `LF` (`U+000A`).
      * Standalone `CR` (`U+000D`) not followed by `LF` $\rightarrow$ `LF` (`U+000A`).
      * Standalone `LF` (`U+000A`) $\rightarrow$ Unchanged.

5.  **Control Character Validation**:
    The sequence **MUST** be scanned for prohibited code points. A code point $c$ is prohibited if:

      * $c = \text{U+0000}$ (Null).
      * Category$(c) = \text{Cc}$ (Control), AND $c \notin \{ \text{U+0009 (TAB)}, \text{U+000A (LF)}, \text{U+000C (FF)} \}$.
      * **Exception**: This validation **MUST NOT** reject control characters occurring within the syntactic boundaries of string or character literals (see ¬ß2.6). However, since Tokenization (Phase 3) has not yet occurred, implementations **MUST** perform this check either (a) conservatively on all text, or (b) during a combined scan-and-lex pass, provided the reported location refers to the pre-lexing coordinate.
      * Violation **MUST** trigger `E-SRC-0104`.

6.  **Physical Structure Validation**:
    The resulting sequence **MUST** conform to the EBNF grammar defined in **Syntax & Declaration**. Failure to conform is an ill-formed source file.

**Unicode Normalization**

  * **General Source**: Normalization (e.g., NFC, NFD) of the source text generally is **Implementation-Defined Behavior (IDB)**.
  * **Identifiers**: Regardless of general source normalization, identifiers and module paths **MUST** be normalized to **NFC** (Normalization Form C) prior to any comparison, hashing, or symbol table insertion.
  * **Stability**: Normalization **MUST NOT** alter the byte offsets or logical coordinates used for diagnostic reporting. Diagnostics **MUST** reference positions in the original Source Byte Stream (accounting for BOM stripping and line normalization adjustments inversely if necessary).

**<u>Syntax & Declaration</u>**

The normalized source file **MUST** conform to the following physical grammar:

```ebnf
source_file     ::= normalized_line*
normalized_line ::= code_point* line_terminator?
line_terminator ::= U+000A
code_point      ::= /* Any Unicode Scalar Value excluding U+000A and Prohibited Chars */
```

**<u>Constraints & Legality</u>**

  * **Encoding Mandate**: Sources **MUST** be valid UTF-8. Other encodings (ASCII, Latin-1, UTF-16) **MUST** be rejected if they produce byte sequences invalid in UTF-8.
  * **BOM Placement**: The Byte Order Mark **MUST** only appear at the start of the file (offset 0). Embedded BOMs are forbidden.
  * **Line Count Limit**: The number of logical lines (defined by `line_terminator`) **MUST NOT** exceed the implementation limit $Limit_{lines}$.
  * **Line Length Limit**: The number of scalar values in any single `normalized_line` **MUST NOT** exceed the implementation limit $Limit_{col}$.

**Diagnostic Table**

| Code         | Severity | Condition                                                                                        |
| :----------- | :------- | :----------------------------------------------------------------------------------------------- |
| `E-SRC-0101` | Error    | Invalid UTF-8 byte sequence encountered in source stream.                                        |
| `E-SRC-0102` | Error    | Source file byte size exceeds implementation limit.                                              |
| `E-SRC-0103` | Error    | `U+FEFF` (BOM) found at a position other than the start of the file.                             |
| `E-SRC-0104` | Error    | Prohibited control character (e.g., null, vertical tab) or surrogate found outside of a literal. |
| `E-SRC-0105` | Error    | Maximum logical line count ($Limit_{lines}$) exceeded.                                           |
| `E-SRC-0106` | Error    | Maximum line length ($Limit_{col}$) exceeded.                                                    |
| `W-SRC-0101` | Warning  | Source file contains a valid UTF-8 BOM (stripped by compiler).                                   |

**<u>Complexity & Limits</u>**

  * **File Size**: Implementations **MUST** accept files up to at least 1 MiB ($2^{20}$ bytes).
  * **Line Length**: Implementations **MUST** accept lines up to at least 16,384 ($2^{14}$) scalar values.
  * **Line Count**: Implementations **MUST** accept sources with up to at least 65,535 ($2^{16}-1$) logical lines.
  * **Complexity**: The Preprocessing Pipeline **MUST** be performable in $O(N)$ time relative to the source byte length.

**<u>Examples</u>**

  * **Valid Input**: A file containing `0x61 0x0A` (`a\n`).

      * *Pipeline*: Size OK -> UTF-8 OK -> No BOM -> No CR -> No Controls -> Grammar OK.
      * *Result*: `[U+0061, U+000A]`.

  * **Invalid Input (Encoding)**: A file containing `0xFF` (Invalid UTF-8 start byte).

      * *Result*: `E-SRC-0101` at offset 0.

  * **Invalid Input (Control)**: A file containing `0x00` (Null byte) in code.

      * *Result*: `E-SRC-0104`.

  * **Warning Input (BOM)**: A file starting with `0xEF 0xBB 0xBF` (UTF-8 BOM).

      * *Result*: `W-SRC-0101` emitted; BOM stripped; compilation proceeds.

### 2.2 Translation Phases

**<u>Definition</u>**

The **Translation Pipeline** is the strictly ordered sequence of transformations applied by the implementation to convert a set of **Compilation Units** into an executable artifact or library.

*   **Compilation Unit**: The aggregate of all Normalized Source Files ($S_{norm}$) belonging to a single module, as defined in ¬ß5.1.
*   **Global Symbol Table ($\Sigma$)**: The aggregate mapping of all identifiers to declarations across all compilation units in the program closure.
*   **Abstract Syntax Tree (AST)**: The tree-structured intermediate representation of the program structure, devoid of lexical artifacts like whitespace or comments.

**<u>Static Semantics</u>**

**The Four-Phase Pipeline**

A conforming implementation **MUST** execute the following four phases in the exact order specified. The transition between phases represents a strict synchronization barrier; Phase $N$ **MUST** complete for **all** compilation units in the program closure before Phase $N+1$ begins for **any** compilation unit.

1.  **Phase 1: Parsing & Canonicalization**
    *   **Input**: Normalized Source Files ($S_{norm}$).
    *   **Operation**: The implementation parses the source text according to the grammar defined in Appendix A.
    *   **Macro Expansion**: Syntactic macros and `quote` interpolations are expanded.
    *   **Symbol Discovery**: All top-level declarations (procedures, types, globals) are identified and recorded in the Global Symbol Table ($\Sigma$).
    *   **Output**: Raw Abstract Syntax Trees (AST).

2.  **Phase 2: Compile-Time Execution**
    *   **Input**: Raw AST and Global Symbol Table ($\Sigma$).
    *   **Operation**: `comptime` blocks and procedures are executed.
    *   **Metaprogramming**: Code emission intrinsics (`emit`) inject new nodes into the AST.
    *   **Output**: Expanded AST.

3.  **Phase 3: Semantic Analysis**
    *   **Input**: Expanded AST.
    *   **Operation**:
        *   **Name Resolution**: Identifiers are resolved to entities in $\Sigma$.
        *   **Type Checking**: Types are inferred and checked against the rules in Clause 4.
        *   **Verification**: Permissions, lifetimes, and contract obligations are verified.
    *   **Output**: Validated, Type-Decorated AST (TAST).

4.  **Phase 4: Code Generation**
    *   **Input**: Validated TAST.
    *   **Operation**: Optimization and lowering to target machine code or intermediate bytecode.
    *   **Output**: Final Artifact (Executable or Library).

**<u>Constraints & Legality</u>**

**1. The Two-Phase Invariant**
*   Implementations **MUST** guarantee that Phase 1 (Parsing) is completed for every compilation unit in the project before Phase 2 (Compile-Time Execution) or Phase 3 (Semantic Analysis) begins for any unit.
*   **Rationale**: This invariant ensures that the Global Symbol Table $\Sigma$ is fully populated with all top-level declarations before any name resolution occurs.

**2. Forward Reference Support**
*   As a consequence of the Two-Phase Invariant, implementations **MUST** accept **Forward References** to declarations within the same compilation unit or project.
*   An implementation **MUST NOT** reject a program solely because a symbol is referenced textually before its declaration.
*   Resolution failures (symbols not found in $\Sigma$ after Phase 1) **MUST** trigger diagnostic `E-NAM-1301` during Phase 3.

**3. Prohibition of Textual Preprocessing**
*   Cursive defines **no** textual inclusion mechanism (e.g., C-style `#include`).
*   Implementations **MUST NOT** perform file inclusion or text substitution prior to Phase 1. All code reuse **MUST** occur via the Module System (Clause 5).

**Diagnostic Table**

| Code         | Severity | Condition                                                      |
| :----------- | :------- | :------------------------------------------------------------- |
| `E-NAM-1301` | Error    | Symbol referenced in Phase 3 not found in Global Symbol Table. |

**<u>Examples</u>**

**Valid Forward Reference**
Because Phase 1 records `helper` before Phase 3 resolves the call in `main`, the following is valid:

```cursive
public procedure main(ctx: Context): i32 {
    // Call to 'helper' appears before its declaration.
    // Valid because 'helper' is recorded in Phase 1.
    helper(ctx)
    result 0
}

procedure helper(ctx: Context) {
    // ... implementation ...
}
```

**Invalid Phase Ordering (Hypothetical)**
If an implementation attempted to type-check `main` before parsing `helper`, it would incorrectly reject the valid program above. Such an implementation is **non-conforming**.
  

### 2.3 Lexical Elements

**<u>Definition</u>**

**Lexical Analysis** is the transformation of the Normalized Source File ($S_{norm}$) into a stream of **Tokens**.

*   **Token**: An atomic unit of the language syntax, defined by the tuple $(Kind, Lexeme, Span)$.
    *   **Kind**: The category of the token (e.g., `Keyword`, `Identifier`, `Operator`).
    *   **Lexeme**: The exact sequence of scalar values from $S_{norm}$ constituting the token.
    *   **Span**: The start and end coordinates (line, column) in the source text.
*   **Whitespace**: A sequence of scalar values acting as token separators.
*   **Comment**: A sequence of scalar values ignored by the parser but potentially preserved for documentation.

**<u>Syntax & Declaration</u>**

The lexical grammar defines the categorization of scalar value sequences.

**1. Whitespace**
The **only** scalar values permitted as whitespace outside of string/character literals are:
*   Space (`U+0020`)
*   Horizontal Tab (`U+0009`)
*   Form Feed (`U+000C`)
*   Line Feed (`U+000A`)

**2. Comments**
*   **Line Comment**: Begins with `//` and terminates at the next `U+000A`.
*   **Block Comment**: Begins with `/*` and terminates with `*/`. Block comments **MUST** nest recursively.
*   **Doc Comment**: Line comments beginning with `///` or `//!`.

**3. Operators and Punctuators**
The following sequences are reserved as operator or punctuator tokens:
`+`, `-`, `*`, `/`, `%`, `**`, `!`, `&`, `|`, `^`, `~`, `<<`, `>>`, `&&`, `||`, `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`, `==`, `!=`, `<`, `>`, `<=`, `>=`, `(`, `)`, `[`, `]`, `{`, `}`, `.`, `,`, `:`, `;`, `->`, `=>`, `::`, `..`, `..=`

**<u>Constraints & Legality</u>**

**1. Whitespace Restriction**
Any Unicode scalar value with the property `White_Space=Yes` that is **not** in the permitted list above (e.g., Non-Breaking Space `U+00A0`, Vertical Tab `U+000B`) **MUST** be rejected if it appears outside of a string or character literal.
*   **Diagnostic**: `E-SRC-0104` (Invalid whitespace/control character).

**2. Comment Nesting**
Implementations **MUST** maintain a nesting counter $D_{comment}$ for block comments.
*   Encountering `/*` increments $D_{comment}$.
*   Encountering `*/` decrements $D_{comment}$.
*   A block comment terminates only when `*/` is encountered while $D_{comment} = 1$.
*   If the end of $S_{norm}$ is reached while $D_{comment} > 0$, the implementation **MUST** emit diagnostic `E-SRC-0306`.

**3. Lexical Security (Bidi and Zero-Width)**
To prevent source code spoofing (Trojan Source attacks), implementations **MUST** restrict the usage of lexically sensitive characters.
*   **Restricted Set**:
    *   Bidirectional Formatting: `U+202A` through `U+202E`, `U+2066` through `U+2069`.
    *   Zero-Width Joiners: `U+200C` (ZWNJ), `U+200D` (ZWJ).
*   **Rule**: These characters **MUST NOT** appear in identifiers, operators, or punctuators. They are permitted **only** within string and character literals.
*   **Enforcement**:
    *   In **Permissive Mode**, violation **MUST** trigger warning `W-SRC-0308`.
    *   In **Strict Mode**, violation **MUST** trigger error `E-SRC-0308`.

**Diagnostic Table**

| Code         | Severity | Condition                                                               |
| :----------- | :------- | :---------------------------------------------------------------------- |
| `E-SRC-0104` | Error    | Illegal whitespace character detected (e.g., U+00A0).                   |
| `E-SRC-0305` | Error    | Usage of a reserved keyword as an identifier.                           |
| `E-SRC-0306` | Error    | Unterminated block comment (EOF reached).                               |
| `E-SRC-0308` | Error    | Lexically sensitive character in non-literal context (Strict Mode).     |
| `W-SRC-0308` | Warning  | Lexically sensitive character in non-literal context (Permissive Mode). |

**<u>Static Semantics</u>**

**1. Maximal Munch Rule**
When tokenizing the input stream, the implementation **MUST** match the longest possible sequence of characters that forms a valid token.
*   *Example*: `>>=` is tokenized as a single `RightShiftAssign` operator, not `>` and `>=`.

**2. The Generic Argument Exception**
The sequence `>>` represents a context-sensitive ambiguity between the Right Shift Operator (`>>`) and two closing Generic Argument delimiters (`>` and `>`).
*   **Rule**: When parsing a generic argument list (e.g., `List<List<T>>`), the lexer or parser **MUST** resolve the sequence `>>` as two distinct `>` tokens.
*   This exception overrides the Maximal Munch rule in that specific grammatical context.

**<u>Complexity & Limits</u>**

*   **Comment Nesting Depth**: Implementations **MUST** support a block comment nesting depth of at least 256 levels.
*   **Lookahead**: The lexical grammar is designed to be tokenizable with finite lookahead (typically 1-3 characters), with the exception of the context-sensitive Generic Argument rule which may require parser state feedback.

**<u>Examples</u>**

**Valid Lexical Structure**
```cursive
// Line comment
/* Block comment
   /* Nested block comment */
*/
let x = 10; // Whitespace (U+0020) acts as separator
```

**Invalid Whitespace**
```cursive
let x = 10;¬† // Error: U+00A0 (NBSP) after semicolon triggers E-SRC-0104
```

**Invalid Comment Nesting**
```cursive
/* Start comment
   /* Nested starts
   Nested ends */
// EOF reached here -> E-SRC-0306 (Depth is 1)
```

**Lexical Security Violation**
```cursive
// Strict Mode
let admin‚ÄÆ = false; // Error E-SRC-0308: Bidi override char used to hide variable
```

### 2.4 Identifiers

**<u>Definition</u>**

An **Identifier** is a sequence of Unicode Scalar Values used to name entities (such as variables, types, procedures, and modules) within a Cursive program.

*   **Equivalence Class**: Two identifiers are defined as **equivalent** if and only if their Unicode Normalization Form C (NFC) representations are identical sequences of code points.
*   **Namespace**: Identifiers exist within the unified namespace defined in Clause 5.

**<u>Syntax & Declaration</u>**

Identifiers **MUST** conform to the profile of **UAX #31 (Unicode Identifier and Pattern Syntax)** defined below. The grammar is defined in terms of Unicode character properties.

```ebnf
identifier    ::= ident_start ident_continue*
ident_start   ::= <Code point with property XID_Start>
                | U+005F ('_')
ident_continue::= <Code point with property XID_Continue>
```

*   **`XID_Start`**: Derived property defined in UAX #31. Generally includes letters and ideographs.
*   **`XID_Continue`**: Derived property defined in UAX #31. Generally includes `XID_Start`, digits, and combining marks.
*   **`_` (U+005F)**: The Low Line character is explicitly permitted as a start character.

**<u>Constraints & Legality</u>**

**1. Character Validity**
*   Every character in an identifier **MUST** satisfy the grammar rules defined above.
*   Identifiers **MUST NOT** contain any character prohibited by ¬ß2.1.3 (e.g., control characters), surrogate code points, or non-characters.
*   **Diagnostic**: Any violation of the identifier grammar (e.g., starting with a digit or emoji) **MUST** trigger diagnostic `E-SRC-0307`.

**2. Reserved Keywords**
*   The sequence of characters constituting an identifier **MUST NOT** match any Reserved Keyword defined in ¬ß9.2.1 of Draft 2 (e.g., `procedure`, `let`, `true`).
*   Matching is determined by case-sensitive comparison of the source lexeme against the keyword list.
*   **Diagnostic**: Usage of a keyword where an identifier is required **MUST** trigger diagnostic `E-SRC-0305`.

**3. Reserved Patterns**
*   Identifiers beginning with the sequence `__` (double underscore) are **reserved** for implementation-specific intrinsics and internal usage.
*   Conforming programs **SHOULD NOT** declare identifiers matching this pattern. Implementations **MAY** issue a warning or reject such identifiers in strict modes.

**Diagnostic Table**

| Code         | Severity | Condition                                                   |
| :----------- | :------- | :---------------------------------------------------------- |
| `E-SRC-0305` | Error    | Reserved keyword used as an identifier.                     |
| `E-SRC-0307` | Error    | Invalid Unicode character in identifier (violates UAX #31). |

**<u>Static Semantics</u>**

**1. Normalization (NFC)**
*   Implementations **MUST** normalize all identifiers to **Unicode Normalization Form C (NFC)** immediately upon tokenization.
*   This normalized form **MUST** be used for all subsequent operations, including:
    *   Equality comparison (e.g., does variable `A` shadow variable `B`?).
    *   Symbol table lookups.
    *   Hash computation.
    *   Export to metadata or object files.
*   **Stability**: Normalization **MUST NOT** alter the source location spans reported in diagnostics; these must refer to the original source text positions.

**2. Case Sensitivity**
*   Cursive identifiers are **case-sensitive**. `MyVar`, `myVar`, and `myvar` are distinct identifiers.
*   However, see ¬ß5.3 regarding module path collisions on case-insensitive filesystems.

**<u>Complexity & Limits</u>**

**1. Length Limit**
*   Implementations **MUST** accept identifiers with a length of at least **1,023** Unicode Scalar Values.
*   Implementations **MUST** document their maximum supported identifier length in the Conformance Dossier.
*   Identifiers exceeding the implementation's documented limit **MUST** be rejected as ill-formed.

**<u>Examples</u>**

**Valid Identifiers**
```cursive
x
variable_name
_ignored
Œ±Œ≤Œ≥           // Greek characters (XID_Start)
–ú–æ—Å–∫–≤–∞        // Cyrillic characters
i32_value     // Alphanumeric with underscore
```

**Invalid Identifiers**
```cursive
1stPlace      // Error E-SRC-0307: Starts with digit
my-var        // Parsed as 'my' '-' 'var' (operator subtraction)
procedure     // Error E-SRC-0305: Reserved keyword
true          // Error E-SRC-0305: Reserved keyword (boolean literal)
üí©            // Error E-SRC-0307: Emoji are not XID_Start
```

### 2.5 Reserved Namespaces & Patterns

**<u>Definition</u>**

**Reserved Namespaces and Patterns** are subsets of syntactically valid identifiers (¬ß2.4) that are semantically restricted by the specification. These identifiers are reserved to ensure future language evolution, ABI stability, and preventing collisions with implementation intrinsics.

*   **Reserved Namespace**: A specific identifier or module path prefix reserved for the language specification.
*   **Reserved Pattern**: A lexical structure (e.g., a prefix) reserved for implementation-defined use.
*   **Universe Scope Bindings**: Identifiers defined in the implicit Universe Scope (e.g., primitive types) that serve as the foundation of the language.

**<u>Constraints & Legality</u>**

**1. The `cursive` Namespace**
*   The identifier `cursive` is strictly reserved for use by the language specification (e.g., `cursive::std`, `cursive::reflect`).
*   A conforming program **MUST NOT** declare a module, type, variable, or procedure named `cursive` at the top level.
*   A conforming program **MUST NOT** declare a package or assembly named `cursive` in the Project Manifest.
*   **Diagnostic**: Violation **MUST** trigger diagnostic `E-NAM-1307`.

**2. Implementation Patterns (`__`)**
*   Identifiers beginning with two underscores (`__`) are reserved for implementation intrinsics, compiler-generated artifacts, and ABI stability mechanisms.
*   Conforming programs **SHOULD NOT** declare identifiers matching the regular expression `^__.*`.
*   **Diagnostic**:
    *   In **Permissive Mode**, declaring an identifier starting with `__` **SHOULD** trigger warning `W-NAM-1307`.
    *   In **Strict Mode**, declaring an identifier starting with `__` **MUST** trigger error `E-NAM-1307`.

**3. Universe Scope Shadowing**
*   The Core Type Identifiers defined in the Universe Scope (Clause 4) are protected. These include, but are not limited to:
    *   Integer types: `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `isize`, `usize`.
    *   Floating-point types: `f16`, `f32`, `f64`.
    *   Boolean type: `bool`.
    *   Character type: `char`.
    *   Aliases: `int`, `uint`, `float`, `double`, `half`.
*   A declaration **MUST NOT** introduce a binding with the same name as a Core Type Identifier in any scope.
*   **Diagnostic**: Violation **MUST** trigger diagnostic `E-NAM-1302` (Duplicate declaration), as these identifiers are considered implicitly declared in the global scope.

**Diagnostic Table**

| Code         | Severity | Condition                                                            |
| :----------- | :------- | :------------------------------------------------------------------- |
| `E-NAM-1302` | Error    | Declaration shadows a Core Type Identifier (e.g., `struct i32`).     |
| `E-NAM-1307` | Error    | Usage of reserved namespace `cursive` or pattern `__` (Strict Mode). |
| `W-NAM-1307` | Warning  | Usage of reserved pattern `__` (Permissive Mode).                    |

**<u>Static Semantics</u>**

**1. Reservation Precedence**
*   Reservations apply **after** tokenization. A sequence of characters that lexes as a keyword (e.g., `true`) fails at the lexical stage (`E-SRC-0305`). A sequence that lexes as a valid identifier but matches a reserved pattern (e.g., `__init`) fails at the declaration stage (this section).

**2. Vendor Extensions**
*   As defined in ¬ß7.3.2, vendor-specific extensions **MUST** use a reverse-domain namespace (e.g., `com.vendor.feature`).
*   Vendors **MUST NOT** introduce extensions within the `cursive` namespace or using the `__` pattern unless explicitly authorized by the specification for ABI purposes.

**<u>Examples</u>**

**Valid Declarations**
```cursive
let my_variable = 10;
record UserData { ... }
```

**Invalid Declarations**
```cursive
// Error E-NAM-1307: 'cursive' is a reserved namespace
module cursive { ... }

// Error E-NAM-1302: Shadowing core type 'i32'
record i32 { val: int }

// Warning W-NAM-1307 (Permissive) or Error E-NAM-1307 (Strict)
procedure __internal_method() { ... }
```

### 2.6 Literals

**<u>Definition</u>**

A **Literal** is a token that represents a fixed, compile-time constant value directly in the source text.

*   **Value Category**: All literals are **Value Expressions** (r-values).
*   **Type**: Every literal has a static type determined by its syntax, its suffix (if present), or the context in which it appears (bidirectional inference).

**<u>Syntax & Declaration</u>**

Literals **MUST** conform to the following grammar rules. The lexical analysis **MUST** maximize the length of the token (Maximal Munch) before validating its internal structure.

```ebnf
literal ::= integer_lit | float_lit | string_lit | char_lit | bool_lit | unit_lit

/* Integers */
integer_lit  ::= ( dec_lit | hex_lit | oct_lit | bin_lit ) [ int_suffix ]
dec_lit      ::= dec_digit ( ( "_" | dec_digit )* dec_digit )?
hex_lit      ::= "0x" hex_digit ( ( "_" | hex_digit )* hex_digit )?
oct_lit      ::= "0o" oct_digit ( ( "_" | oct_digit )* oct_digit )?
bin_lit      ::= "0b" bin_digit ( ( "_" | bin_digit )* bin_digit )?

/* Floats */
float_lit    ::= ( fraction | exponent ) [ float_suffix ]
fraction     ::= dec_lit "." dec_lit [ exponent_part ]
exponent     ::= dec_lit exponent_part
exponent_part::= ( "e" | "E" ) [ "+" | "-" ] dec_lit

/* Suffixes */
int_suffix   ::= "i8" | "i16" | "i32" | "i64" | "i128" | "isize"
               | "u8" | "u16" | "u32" | "u64" | "u128" | "usize"
float_suffix ::= "f16" | "f32" | "f64"

/* Text */
string_lit   ::= '"' ( escape_seq | ^( "\" | '"' | U+000A ) )* '"'
char_lit     ::= "'" ( escape_seq | ^( "\" | "'" | U+000A ) ) "'"
escape_seq   ::= "\" ( "n" | "r" | "t" | "\" | "'" | '"' | "0" )
               | "\x" hex_digit hex_digit
               | "\u{" hex_digit+ "}"

/* Constants */
bool_lit     ::= "true" | "false"
unit_lit     ::= "(" ")"
```

**<u>Constraints & Legality</u>**

**1. Numeric Formatting**
*   **Underscores**: The underscore character `_` **MUST** be treated as a visual separator and ignored during value evaluation. Underscores **MUST NOT** appear:
    *   At the start of the literal (e.g., `_100`).
    *   Immediately after a base prefix (e.g., `0x_FF`).
    *   Immediately before or after a dot `.` or exponent marker `e`/`E`.
    *   Immediately before a type suffix.
    *   At the end of the literal.
*   **Leading Zeros**: A decimal integer literal beginning with `0` (e.g., `0123`) **MUST** be parsed as a decimal value, not octal. Implementations **MUST** issue diagnostic `W-SRC-0301` to warn against potential ambiguity with C-style octal.
*   **Float Structure**: A floating-point literal containing a decimal point `.` **MUST** contain at least one digit following the dot (e.g., `1.0` is valid, `1.` is invalid). This ensures unambiguous parsing relative to method calls (e.g., `1.to_string()`).

**2. Textual Validity**
*   **String Termination**: A string literal **MUST** be terminated by a double quote `"` on the same logical line. If a line terminator (`U+000A`) or EOF is encountered before the closing quote, the implementation **MUST** emit `E-SRC-0301`.
*   **Char Length**: A character literal **MUST** represent exactly one Unicode Scalar Value after escape resolution. Empty literals (`''`) or literals containing multiple scalars (`'ab'`) **MUST** trigger `E-SRC-0303`.
*   **Escape Sequences**: The only permitted escape sequences are those listed in the grammar above. Any other sequence starting with `\` (e.g., `\a`, `\v`) **MUST** trigger `E-SRC-0302`.

**3. Value Validity**
*   **Numeric Suffix Overflow**: A numeric literal with a type suffix **MUST** represent a value strictly within the representable range of that type. Overflow **MUST** trigger `E-SRC-0304`.
*   **Float Precision Loss**: If a floating-point literal cannot be exactly represented in the target format, it **MUST** be rounded according to IEEE 754 roundTiesToEven. If the value overflows to infinity, it **MUST** be accepted as infinity (or rejected, if strict).

**Diagnostic Table**

| Code         | Severity | Condition                                                             |
| :----------- | :------- | :-------------------------------------------------------------------- |
| `E-SRC-0301` | Error    | Unterminated string literal (newline or EOF found).                   |
| `E-SRC-0302` | Error    | Invalid escape sequence in string or char literal.                    |
| `E-SRC-0303` | Error    | Invalid character literal (empty or multiple scalars).                |
| `E-SRC-0304` | Error    | Malformed numeric literal (e.g., invalid underscore placement, `1.`). |
| `W-SRC-0301` | Warning  | Decimal literal with leading zeros (ambiguous octal).                 |

**<u>Static Semantics</u>**

**1. Type Inference and Coercion**
The type of a literal is determined by the following ordered rules:

1.  **Explicit Suffix**: If a literal has a suffix (e.g., `10u8`), its type is strictly the suffixed type.
2.  **Contextual Checking (Downward)**: If the literal has no suffix and appears in a context expecting a specific type $T$:
      * **Integers**: If the literal is an integer and its value is representable in $T$ (where $T$ is an integer type), the literal has type $T$.
      * **Floats**: If the literal is a float and its value is representable in $T$ (where $T$ is a float type), the literal has type $T$.
3.  **Default Synthesis (Upward)**: If neither suffix nor context provides a type:
      * Integer literals default to `i32`.
      * Float literals default to `f64`.
      * Boolean literals have type `bool`.
      * Character literals have type `char`.
      * String literals have type `string@View`.

**2. String and Char Types**
*   **String Literals**: Have the type `string@View`. They refer to statically allocated, read-only memory containing valid UTF-8.
*   **Char Literals**: Have the type `char`. They represent a 32-bit Unicode Scalar Value.

**<u>Memory & Layout</u>**

*   **String Storage**: String literals **MUST** be encoded as UTF-8. They are **not** null-terminated by default (though implementations may add a null byte for implementation convenience, it is not part of the `string@View` length).
*   **Numeric Precision**:
    *   Integer literals **MUST** be evaluated at compile-time using arbitrary-precision arithmetic to check for overflow against the target type.
    *   Floating-point literals **MUST** be parsed according to IEEE 754 rules (e.g., correctly rounding to nearest even).

**<u>Examples</u>**

**Valid Literals**
```cursive
let a = 123;          // i32 (default)
let b = 1_000_000;    // i32 (underscores ignored)
let c: u8 = 255;      // u8 (contextual inference)
let d = 100u16;       // u16 (explicit suffix)
let e = 0xDEAD_BEEF;  // i32 (hex)
let f = 1.5;          // f64 (default)
let g = 1.0e-10;      // f64 (scientific)
let h = "Hello\n";    // string@View
let i = '\u{1F4A9}';  // char (üí©)
```

**Invalid Literals**
```cursive
let a = 0123;         // Warning W-SRC-0301 (Parsed as decimal 123)
let b = 1.;           // Error E-SRC-0304 (Missing digit after dot)
let c = 100_;         // Error E-SRC-0304 (Trailing underscore)
let d = "\y";         // Error E-SRC-0302 (Invalid escape)
let e = '';           // Error E-SRC-0303 (Empty char)
let f = "
";                    // Error E-SRC-0301 (Unterminated string)
```

### 2.7 Syntactic Stability

**<u>Definition</u>**

**Syntactic Stability** is the property of the language whereby the classification of a sequence of characters into a specific Token Kind (¬ß2.3) is determined solely by the characters themselves and the immediate lexical state (e.g., inside a string literal), without reference to the surrounding syntactic context or parser state.

This property ensures that Cursive source code can be reliably tokenized, syntax-highlighted, and analyzed by tools (including AI models) that lack a full recursive-descent parser.

**<u>Constraints & Legality</u>**

**1. Context-Insensitive Keywords**
*   The classification of a lexeme as a `<keyword>` (¬ß9.2.1) **MUST** be invariant across all syntactic contexts.
*   A Reserved Keyword **MUST NOT** be reclassified as an `<identifier>` based on its position in the grammar (i.e., "soft keywords" are prohibited).
*   **Example**: The lexeme `procedure` is always a keyword. It **MUST NOT** be used as a variable name, even in contexts where a procedure declaration is syntactically impossible.
*   **Enforcement**: Violation of this rule (usage of a keyword as an identifier) **MUST** trigger diagnostic `E-SRC-0305`.

**2. Lexical Determinism**
*   The token stream produced for a given $S_{norm}$ **MUST** be identical regardless of the compilation phase or the presence of semantic errors later in the file.
*   Implementations **MUST NOT** use feedback from the parser or semantic analyzer to alter the behavior of the lexer, with the single normative exception defined below.

**3. The Generic Argument Exception**
*   The **only** permitted deviation from context-free lexing is the handling of the `>>` sequence within generic argument lists (e.g., `List<List<T>>`).
*   As defined in ¬ß2.3, the lexer **MUST** resolve `>>` as two distinct `>` tokens when parsing generic parameters. This is a specific, bounded exception to the Maximal Munch rule.

**Diagnostic Table**

| Code         | Severity | Condition                                                              |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier (Context-insensitive enforcement). |

**<u>Static Semantics</u>**

**Stable Ordering**
To ensure deterministic compilation and consistent behavior across tools:
*   The order of tokens in the output stream **MUST** correspond strictly to the order of their lexemes in $S_{norm}$.
*   Implementations **MUST NOT** reorder, inject, or suppress tokens during lexical analysis (except for the removal of comments and non-token whitespace as defined in ¬ß2.3).

**<u>Complexity & Limits</u>**

*   **Lookahead**: The lexical grammar **MUST** be resolvable with a fixed, finite lookahead (typically $k=1$ or $k=2$ characters). Infinite lookahead or backtracking in the lexer is prohibited to guarantee linear-time performance $O(n)$ relative to the source length.

**<u>Examples</u>**

**Valid Stability**
```cursive
// 'type' is a keyword. It cannot be a variable name.
// This allows syntax highlighters to color 'type' correctly without parsing.
let my_var: i32 = 0; 
```

**Invalid (Hypothetical "Soft Keyword")**
```cursive
// If 'type' were a soft keyword, this would be ambiguous or require parsing:
let type: i32 = 0; // Forbidden by E-SRC-0305
```

### 2.8 Statement Termination

**<u>Definition</u>**

**Statement Termination** is the syntactic mechanism used to delimit the end of one statement and the beginning of the next within a `block` or compilation unit. Cursive supports both **explicit** termination via semicolons and **implicit** termination via newlines.

*   **Terminator**: A token that signals the end of a statement.
*   **Logical Line**: A sequence of tokens terminated by a valid Statement Terminator.

**<u>Static Semantics</u>**

**Termination Rules**

A statement is considered terminated if and only if one of the following conditions is met:

1.  **Explicit Termination**: The parser encounters a Semicolon token (`;`).
2.  **Implicit Termination**: The parser encounters a Newline token (`<newline>`) that is **not** disqualified by the **Line Continuation Rules** defined below.
3.  **End of Input**: The parser encounters the End-of-File (EOF) or the closing brace `}` of an enclosing block (which terminates the preceding statement without requiring a separator).

**Line Continuation Rules**

A `<newline>` token **MUST** be treated as whitespace (ignored) and **MUST NOT** terminate the statement if **any** of the following conditions hold true at the point where the newline is encountered:

1.  **Open Delimiter Context**: The newline occurs while the **Delimiter Nesting Depth** ($D_{nest}$) is greater than zero.
    *   $D_{nest}$ is incremented by `(`, `[`, `{`.
    *   $D_{nest}$ is decremented by `)`, `]`, `}`.
    *   *Note*: Block delimiters `{}` appearing in expression position (e.g., closures, struct literals) contribute to nesting. Blocks appearing in statement position (e.g., `if` bodies) handle termination via their closing brace.

2.  **Trailing Operator**: The token immediately **preceding** the newline ($T_{prev}$) is a binary operator (e.g., `+`, `&&`, `=`) or a separator (`,`).
    *   **Set**: All operators defined in ¬ß2.3 except postfix operators (if any) and closing delimiters.

3.  **Leading Dot**: The first non-comment, non-newline token immediately **following** the newline ($T_{next}$) is a dot (`.`) or scope resolution operator (`::`).
    *   This rule enables fluent method chaining (e.g., builder patterns) where the dot is placed at the start of the continuation line.

**<u>Syntax & Declaration</u>**

The grammar for statements (see Appendix A) formally incorporates these rules. The `statement` production is effectively:

```ebnf
statement ::= <statement_body> ( ";" | <valid_newline> | "}" | EOF )
```

**<u>Constraints & Legality</u>**

**1. Ambiguity Resolution**
*   If a newline is not disqualified by the Line Continuation Rules, it **MUST** be treated as a terminator.
*   If a statement is grammatically incomplete at a newline (and the newline is treated as a terminator), the implementation **MUST** issue a syntax error (e.g., `E-SYN-0201` "Unexpected end of statement").

**2. Empty Statements**
*   A semicolon appearing where a statement is expected, or multiple consecutive semicolons, **MUST** be parsed as an **Empty Statement** (a no-op).
*   Multiple consecutive newlines **MUST** be treated as a single implicit terminator (subsequent newlines are ignored).

**<u>Examples</u>**

**Valid Termination**
```cursive
let x = 10;       // Explicit semicolon
let y = 20        // Implicit newline
return            // Implicit newline
```

**Valid Line Continuation (Delimiters)**
```cursive
let list = [
    1,
    2,
    3
] // Newlines inside [] are ignored
```

**Valid Line Continuation (Trailing Operator)**
```cursive
let sum = x +
          y       // '+' is a binary operator; newline ignored
```

**Valid Line Continuation (Leading Dot)**
```cursive
let result = query
    .filter(x => x > 0)  // Leading '.' keeps the statement open
    .map(x => x * 2)
```

**Invalid Termination (Ambiguous)**
```cursive
// This is parsed as two statements:
// 1. let f = get_func()
// 2. (x) // Expression statement (tuple or grouping)
let f = get_func()
(x) 

// To fix, use a trailing operator or explicit line continuation is not supported; 
// structure the code to rely on open delimiters or operators.
```

---

## Clause 3: The Object & Memory Model
### 3.1 The Object Model

#### Definition

**Formal Object Definition**
An **Object** $\Omega$ within the Cursive abstract machine is defined as a 4-tuple:
$$\Omega = (\sigma, \tau, \lambda, \nu)$$
Where:

  * $\sigma$ (**Storage**): A contiguous sequence of bytes in memory, uniquely identified by a starting address $A \in \mathbb{N}$ and a size $N \in \mathbb{N}$.
  * $\tau$ (**Type**): A static classification that defines the interpretation of $\sigma$, the alignment requirement $\alpha$, and the set of valid operations.
  * $\lambda$ (**Lifetime**): A temporal interval $[t_{alloc}, t_{dealloc})$ during execution for which $\sigma$ is valid and reserved exclusively for $\Omega$.
  * $\nu$ (**Value**): The specific bit-pattern contained within $\sigma$, which must constitute a valid representation for $\tau$ **and satisfy the Type Invariant predicate $I(\tau)$ defined in Clause 7**.

**Memory Safety Principles**
The Cursive memory model enforces safety through two orthogonal axes. A conforming implementation **MUST** enforce both:

1.  **Liveness:** The property that a pointer or binding always refers to allocated, initialized storage ($\lambda$ is active). This is enforced via Responsibility (RAII), Modal Pointers (`Ptr<T>@State`), and Region Escape Analysis.
2.  **Aliasing:** The property that concurrent or reentrant access to $\sigma$ does not violate data integrity. This is enforced via Permissions (`unique`, `concurrent`, `const`) and the Lens System (¬ß12.6).
      * **Spatial Disjointness:** Enforced by Linear Lenses (¬ß12.6) and Static Field Lenses (¬ß12.7).
      * **Temporal Synchronization:** Enforced by `concurrent` (requires concurrent-safe type).

**Architectural Constraints**

  * **Explicit-Over-Implicit:** Memory operations affecting ownership, allocation, or synchronization **MUST** be syntactically explicit (e.g., `^` for region allocation, `move` for ownership transfer).
  * **Zero Runtime Overhead:** All memory safety checks defined in this Clause, excluding dynamic bounds checks and explicit `[[verify(dynamic)]]` contracts, **MUST** be resolved at compile time. Implementations **MUST NOT** insert runtime reference counting, garbage collection barriers, or dynamic lifetime tracking.

#### Dynamic Semantics

**Object Lifecycle**
The lifecycle of an object $\Omega$ consists of three strictly ordered phases:

1.  **Allocation & Initialization ($t_{alloc}$):** Storage $\sigma$ is reserved satisfying the alignment $\alpha$ of $\tau$, and a valid initial value $\nu$ is written. **The implementation MUST verify $I(\tau)(\nu)$ holds before establishing $\lambda$.** This establishes the start of $\lambda$.
2.  **Usage:** The value $\nu$ is read or modified via valid bindings or pointers.
3.  **Destruction & Deallocation ($t_{dealloc}$):** The object's cleanup logic (via `Drop::drop`) is executed, and $\sigma$ is released. This establishes the end of $\lambda$.

**Liveness Enforcement**
Accessing $\sigma$ when the current execution time $t \notin \lambda$ is **Undefined Behavior**. The Cursive type system ensures this cannot occur in **Conforming Programs** (Safe Code).

#### Memory & Layout

**Storage Duration Categories**
Every object has a storage duration that determines its lifetime $\lambda$ and provenance $\pi$.

1.  **Static Storage Duration**:

      * **Allocation**: Prior to the execution of the program entry point (`main`).
      * **Deallocation**: After program termination.
      * **Provenance**: $\pi_{Global}$.
      * **Applicability**: Module-level bindings and `static` items.

2.  **Automatic Storage Duration (Stack)**:

      * **Allocation**: Upon entry to the lexical scope defining the binding.
      * **Deallocation**: Upon exit from the lexical scope (LIFO order).
      * **Provenance**: $\pi_{Stack}$.
      * **Applicability**: Local variables (`let`, `var`) and temporaries.

3.  **Region Storage Duration (Arena)**:

      * **Allocation**: Upon evaluation of the region allocation operator `^` (¬ß24.4.5).
      * **Deallocation**: Upon exit of the lexically enclosing `region` block. All objects in a region are deallocated simultaneously (bulk deallocation).
      * **Provenance**: $\pi_{Region(ID)}$, where $ID$ uniquely identifies the region instance.
      * **Applicability**: Objects created via `^`.

4.  **Dynamic Storage Duration (Heap)**:

      * **Allocation**: Upon explicit invocation of an allocator capability (e.g., `heap.alloc`). Requires `witness HeapAllocator`; unavailable in module initializers (¬ß5.5).
      * **Deallocation**: Upon explicit invocation of `heap.free` or via RAII types managing the allocation.
      * **Provenance**: $\pi_{Heap}$.
      * **Applicability**: Objects managed by `HeapAllocator`.

**General Layout Rules**

  * **Size**: Every type $T$ has a static size $S = \text{sizeof}(T)$ in bytes.
  * **Alignment**: Every type $T$ has an alignment $A = \text{alignof}(T)$. $A$ **MUST** be a power of two.
  * **Address Constraint**: The starting address of any object of type $T$ **MUST** be a multiple of $A$.
  * **Padding**: Implementations **MAY** insert padding bytes between fields of composite types to satisfy alignment requirements, unless constrained by `[[repr(C)]]`.

**Primitive Type Layouts**
Implementations **MUST** provide the following mandatory layouts (size/alignment in bytes):

  * **1 byte / 1 byte**: `i8`, `u8`, `bool`.
  * **2 bytes / 2 bytes**: `i16`, `u16`, `f16`.
  * **4 bytes / 4 bytes**: `i32`, `u32`, `f32`, `char`.
  * **8 bytes / 8 bytes**: `i64`, `u64`, `f64`.
  * **16 bytes / (8 or 16) bytes**: `i128`, `u128` (alignment is platform-dependent).
  * **Platform word size**: `usize`, `isize`, `*imm T`, `*mut T`, `Ptr<T>@State` - size and alignment equal to target pointer width (4 bytes on 32-bit, 8 bytes on 64-bit platforms).

**Composite Type Layouts**

  * **Arrays (`[T; N]`)**:
      * Size: $\text{sizeof}([T; N]) = \text{sizeof}(T) \times N$.
      * Alignment: $\text{alignof}([T; N]) = \text{alignof}(T)$.
      * No padding between elements (contiguous storage).

  * **Records (`record`)**:
      * Alignment: Maximum alignment of all fields.
      * Default layout: Implementation **MAY** reorder fields to minimize padding.
      * C-compatible layout (`[[repr(C)]]`): Fields **MUST** be stored in declaration order with padding inserted per target C ABI.

  * **Dense Pointers (Slices and Witnesses)**:
      * Slices (`[T]`): Represented as `struct { ptr: *imm T, len: usize }`.
      * Witnesses (`witness Trait`): Represented as `struct { data: *imm T, vtable: *imm VTable }`.
      * Size: $2 \times \text{sizeof}(\text{usize})$ (16 bytes on 64-bit platforms).
      * Alignment: $\text{alignof}(\text{usize})$.

  * **Zero-Sized Types**:
      * Unit type `()`: $\text{sizeof}(()) = 0$, $\text{alignof}(()) = 1$.
      * Never type `!`: $\text{sizeof}(!) = 0$, $\text{alignof}(!) = 1$.
      * Objects of zero size do not occupy unique storage but **MAY** have distinct addresses for identity comparison purposes.

#### **Constraints & Legality**

**Safety Boundaries**

  * **Garbage Collection Prohibition**: Implementations **MUST NOT** utilize a garbage collector. Reliance on implicit reclamation is non-conforming.
  * **Implicit Locking Prohibition**: Implementations **MUST NOT** inject implicit synchronization locks (e.g., Java `synchronized` methods) to satisfy Aliasing rules. Synchronization must be exposed via types (e.g., `Mutex<T>`).
  * **Padding Bytes**: The contents of padding bytes are **Unspecified**. Accessing padding via unsafe pointer arithmetic is **Undefined Behavior**.

**Diagnostic Table**
| Code         | Severity | Condition                                                                             |
| :----------- | :------- | :------------------------------------------------------------------------------------ |
| `E-MEM-3030` | Error    | Unsafe operation (e.g., raw pointer dereference) performed outside of `unsafe` block. |

#### **Examples**

**Valid Object Lifecycle**

```cursive
procedure example() {
    // Automatic storage (Stack)
    // Allocated at declaration.
    let x: i32 = 10; 
    
    region r {
        // Region storage (Arena)
        // Allocated via '^'. Lifetime bound to 'r'.
        let y: *imm i32 = ^20; 
    } // 'y' content deallocated here.
} // 'x' deallocated here.
```

**Invalid Lifecycle (Conceptual)**

```cursive
// If Cursive allowed returning references to automatic storage (it does not):
procedure invalid() -> *imm i32 {
    let x = 10;
    // Error: 'x' is deallocated when 'invalid' returns. 
    // The pointer would be dangling (Liveness violation).
    return &x; 
}
```
### 3.2 Responsibility & Move Semantics

#### Definition

**Responsible Binding**
A **Responsible Binding** $b$ is a named identifier within a lexical scope that holds the exclusive duty to manage the lifetime of an object $\Omega$. A binding assumes responsibility upon initialization via the assignment operator (`=`) or when accepted as a parameter marked with `move`.

**Binding States**
The compiler maintains a static state $\sigma(b)$ for every responsible binding $b$ throughout its scope. The domain of $\sigma$ is:

$$\sigma(b) \in \{ \text{Valid}, \text{Moved}, \text{PartiallyMoved}(\{f_1, \dots, f_n\}) \}$$

  * **Valid**: The binding refers to a live object. Usage is permitted.
  * **Moved**: The object's responsibility has been transferred. Usage is forbidden.
  * **PartiallyMoved($F$)**: Responsibility for specific fields $F$ has been transferred. Usage of $b$ as a whole or fields in $F$ is forbidden.

**RAII (Resource Acquisition Is Initialization)**
Cursive enforces a strict RAII model. Every resource (memory, file handle, lock) corresponds to exactly one responsible binding at any point in execution. When that binding's lifetime ends, the resource **MUST** be released deterministically via the `Drop` trait.

#### Syntax & Declaration

**Move Operator**
The `move` operator explicitly transfers responsibility.

```ebnf
move_expression ::= "move" identifier ( "." identifier )*
```

**Initialization**
Responsibility is established via variable declaration:

```ebnf
variable_decl ::= ( "let" | "var" ) identifier [ ":" type ] "=" expression
```

#### Static Semantics

**Move Semantics**
Evaluating `move b` transfers responsibility of the object from $b$ to the consuming context.
The compiler **MUST** apply the following state transition to $b$:

$$
\frac{\sigma_{pre}(b) = \text{Valid}}{\Gamma \vdash \text{move } b \Rightarrow \sigma_{post}(b) = \text{Moved}}
$$

Any subsequent attempt to read, write, or move $b$ while $\sigma(b) = \text{Moved}$ **MUST** be rejected.

**Partial Move Semantics**
A partial move transfers responsibility of a field `b.f` while retaining responsibility for the rest of `b`.
Partial moves are permitted **IF AND ONLY IF** $b$ satisfies one of the following:

1.  $b$ is a mutable binding (`var`).
2.  $b$ has the `unique` permission type.

Attempts to partially move from a `const` **or `concurrent`** binding **MUST** be rejected (`E-MEM-3001`), as this would violate the integrity of aliases.

Upon `move b.f`, the state transitions:

$$
\sigma_{post}(b) = \begin{cases}
\text{PartiallyMoved}({f}) & \text{if } \sigma_{pre}(b) = \text{Valid} \\
\text{PartiallyMoved}(F \cup {f}) & \text{if } \sigma_{pre}(b) = \text{PartiallyMoved}(F)
\end{cases}
$$

**Reinitialization**
A binding $b$ declared with `var` (mutable) in the `Moved` **or `PartiallyMoved`** state **MAY** be reinitialized **as a whole unit** via assignment.

$$
\frac{b \text{ is var} \quad \sigma_{pre}(b) = \text{Moved}}{\Gamma \vdash b = e \Rightarrow \sigma_{post}(b) = \text{Valid}}
$$

A binding declared with `let` (immutable) **MUST NOT** be reinitialized.

#### Dynamic Semantics

**Deterministic Destruction**
When a scope exits, the runtime **MUST** destroy all local responsible bindings in strict **LIFO (Last-In, First-Out)** order relative to their declaration.
For each binding $b$:

1.  If $\sigma(b) = \text{Moved}$, no action is taken.
2.  If $\sigma(b) = \text{Valid}$, `Drop::drop` is invoked on the object.
3.  If $\sigma(b) = \text{PartiallyMoved}(F)$, destructors are generated only for the fields $f \notin F$. The top-level `Drop::drop` for $b$ **MUST NOT** be called.

**Panic Unwinding**
If the program terminates abnormally (panics), the runtime **MUST** execute destructors for all live bindings in the current stack frame before unwinding.

*   **Destructor Panic Boundary**: If `Drop::drop` panics during normal execution (non-unwinding), the program **MUST** immediately abort. Destructors are `noexcept` boundaries.
*   **Double Panic Constraint**: If a destructor panics while the thread is already unwinding due to a previous panic, the runtime **MUST** immediately **Abort** the process (terminate without cleanup).

#### Constraints & Legality

**Negative Constraints**

* **Manual Drop Forbidden**: Explicit calls to `Drop::drop(x)` are prohibited. Users **MUST** use the intrinsic `mem::drop(move x)` or let the variable go out of scope.
* **Move from Borrow**: It is impossible to move out of a reference (`&T`, `*imm T`, `*mut T`). Responsibility can only be moved from a binding that holds it.

**Diagnostic Table**
| Code         | Severity | Condition                                     |
| :----------- | :------- | :-------------------------------------------- |
| `E-MEM-3001` | Error    | Use of a moved or partially moved value.      |
| `E-MEM-3005` | Error    | Explicit call to `Drop::drop`.                |
| `E-TRS-2920` | Error    | Direct invocation of destructor trait method. |

#### Examples

**Valid: Full and Partial Moves**

```cursive
record Player { name: string@Managed, score: i32 }

procedure main(ctx: Context) {
let p1 = Player { ... }

// Full Move
consume_player(move p1);
// p1 is now Moved. Access is illegal.

let p2: unique = Player { ... }
// Partial Move (allowed because p2 is unique)
let n = move p2.name; 
// p2 is PartiallyMoved.
// use(p2) -> Error
// use(p2.score) -> OK
}
```

**Invalid: Use After Move**

```cursive
procedure test() {
let x = string::from("hello");
let y = move x; // x transitions to Moved

// Error E-MEM-3001: Use of moved value 'x'
print(x); 
}
```

-----

#### 3.2.1 Temporary Values

##### Definition

**Formal Definition**
A **Temporary Value** $\tau$ is an object result of an expression evaluation that is not immediately bound to a named identifier in the source text.

##### Dynamic Semantics

**Scope and Lifetime**
The lifetime of a temporary value $\tau$ extends from its creation until the end of the strictly lexically enclosing statement (the "statement boundary").

**Promotion**
If $\tau$ is used to initialize a `let` or `var` binding, it ceases to be temporary; its storage and lifetime are promoted to that of the binding.

**Cleanup**
At the statement boundary, the compiler **MUST** generate cleanup code for all temporaries created within that statement that have not been consumed via `move`.

* The destruction order of temporaries within a single statement is **Implementation-Defined Behavior (IDB)**. The chosen order **MUST** be consistent across all executions for a given compilation configuration.
* Implementations **MUST** document their temporary destruction order in the Conformance Dossier.

##### Examples

**Temporary Scope**

```cursive
// 'string::from' creates a temporary.
// It is passed to 'print', then destroyed at the semicolon.
print(string::from("temporary")); 

// Nested temporaries
// The temporary from 'get_prefix()' lives until the end of the statement.
let s = get_prefix() + "_suffix"; 
```

### 3.3 Memory Management (Regions)

#### Definition

**Formal Definition**
A **Region** is a lexically scoped memory arena that provides deterministic, bulk deallocation for a set of objects. It is backed by the built-in modal type `Arena`.

**The Arena Modal Type**
The `Arena` type manages the underlying memory block for a region. It is defined as:

```cursive
modal Arena {
    // The arena is live and accepts new allocations.
    @Active { ... }

    // The arena is live but prohibits new allocations.
    // Existing objects remain valid.
    @Frozen { ... }

    // The arena backing store has been deallocated.
    // No objects within it are valid.
    @Freed { ... }

    // Transitions
    procedure new() -> @Active;
    procedure freeze(self: unique Self@Active) -> @Frozen;
    procedure free(self: unique Self); // Transitions to @Freed
}
```

**Provenance ($\pi$)**
Every pointer type `Ptr<T>` and reference binding carries a compile-time **Provenance Tag** $\pi$, which identifies the storage duration of the pointee.
$$\pi \in \{ \pi_{Global}, \pi_{Stack}, \pi_{Heap}, \pi_{Region(ID)} \}$$
Where $ID$ is a unique identifier for a specific `region` block instance.

#### Syntax & Declaration

**Region Block**
The `region` statement creates a new scope associated with a specific `Arena` instance.

```ebnf
region_statement ::= "region" identifier block
```

**Allocation Operator (`^`)**
The caret operator performs allocation within an active region.

```ebnf
allocation_expression ::= "^"+ expression
```

**Desugaring**
The statement `region r { s }` desugars to:

```cursive
{
    let r: unique Arena@Active = Arena::new();
    defer { r.free(); }
    // 's' executes here with 'r' as the active region context
}
```

#### Static Semantics

**Lifetime Partial Order ($\le$)**
The compiler **MUST** maintain a partial order over provenances based on their lifetimes.

1.  **Nesting:** If region $A$ lexically encloses region $B$, then $\pi_{Region(B)} < \pi_{Region(A)}$.
2.  **Hierarchy:** $\forall ID, \pi_{Region(ID)} < \pi_{Stack} < \pi_{Heap}$.
3.  **Transitivity:** If $\pi_A < \pi_B$ and $\pi_B < \pi_C$, then $\pi_A < \pi_C$.

**Non-strict Ordering ($\le$)**

The provenances may have equivalent lifetimes in specific cases. Specifically, $\pi_{Heap} \le \pi_{Global}$ because heap-allocated storage with static lifetime (e.g., intentional memory leaks, process-lifetime allocations) may persist until program termination, matching global storage duration.

**Heap Pointers in Global Bindings**

Theoretically, a heap pointer stored in a global binding that is subsequently deallocated would create a dangling pointer‚Äîa soundness violation. However, this situation **cannot occur in safe Cursive code** due to the capability system:

1.  **Heap allocation requires a capability**: All heap allocation operations require `witness HeapAllocator` (¬ß3.1).
2.  **Capabilities are injected at `main()`**: The `HeapAllocator` capability is provided exclusively through the `Context` record passed to `main()` (¬ß5.6).
3.  **Module initialization precedes `main()`**: Module-level binding initializers execute before `main()` is invoked (¬ß5.5).
4.  **No Ambient Authority**: There are no global functions for heap allocation; the capability must be explicitly passed (¬ß5.6).

**Conclusion:** Because `HeapAllocator` is unavailable during module initialization, heap allocation cannot occur in module-level initializers. Therefore, module-level bindings cannot contain heap pointers, and the dangling global problem cannot arise in safe code.

**Static Enforcement:**

| Context                               | HeapAllocator Available? | Heap Allocation Permitted? |
| :------------------------------------ | :----------------------- | :------------------------- |
| Module-level initializer              | No                       | No                         |
| Procedure body (with capability)      | Yes                      | Yes                        |
| `main()` body                         | Yes (from Context)       | Yes                        |

**`unsafe` Code:**

In `unsafe` code, the programmer may obtain pointers through mechanisms outside the capability system (e.g., FFI, raw memory manipulation). If such a pointer is:
1.  Stored in a module-level binding, AND
2.  Later deallocated

This constitutes Unverifiable Behavior (UVB). The programmer assumes responsibility for ensuring heap pointers accessible via global bindings are not deallocated during program execution.

> **Cross-Reference:** The No Ambient Authority principle (¬ß5.6) and module initialization order (¬ß5.5) together provide the static enforcement mechanism for this constraint.

**Provenance Assignment**

  * The expression `^expr` evaluates to a value with provenance $\pi_{Region(Current)}$.
  * The expression `^^expr` evaluates to a value with provenance $\pi_{Region(Parent)}$, where Parent is the region enclosing Current.

**Escape Analysis**
For every assignment `target = source` (or function return), the compiler **MUST** verify that the target's location does not outlive the source's provenance.

$$
\frac{\lambda(target) \le \pi(source)}{\Gamma \vdash target = source : \text{OK}}
$$

If $\lambda(target) > \pi(source)$, the assignment is ill-formed (`E-MEM-3020`).

**State Transition on Exit**
Upon exit from a `region` block with ID $R$:

1.  The `Arena` transitions to `@Freed`.
2.  All pointers with provenance $\pi_{Region(R)}$ statically transition to the `Ptr<T>@Expired` state.
3.  Any subsequent attempt to dereference such a pointer is a compile-time error (`E-TYP-2002`).

#### Dynamic Semantics

**Allocation**
Evaluating `^expr` copies the result of `expr` into the contiguous memory managed by the active `Arena`.

* **Efficiency:** Implementations **SHOULD** use a bump-pointer allocator for $O(1)$ allocation.
* **Capacity:** If the arena is exhausted, the implementation **MUST** either extend the arena (if supported) or panic (OOM).

**Deallocation**
When the `region` block exits, the `defer`red `free()` transition is invoked. The entire memory block backing the arena is released to the system (or parent allocator) in a single operation. Individual destructors for objects within the region are **NOT** called. **Allocating a type $T$ that implements `Drop` (or contains fields that do) into a region constitutes a Resource Leak.** Implementations **MUST** accept this as Defined Behavior (Safe but Leaky).

#### Constraints & Legality

**Negative Constraints**

* **Scope:** Usage of the allocation operator `^` outside of a lexically enclosing `region` block is prohibited.
* **Escape:** It is impossible to return a pointer to a region-allocated object from the function that defined the region (since the region dies on return).

**Diagnostic Table**
| Code         | Severity | Condition                                             |
| :----------- | :------- | :---------------------------------------------------- |
| `E-MEM-3020` | Error    | Region pointer escape (Target outlives Source).       |
| `E-MEM-3021` | Error    | Region allocation `^` used outside of a region scope. |

#### Examples

**Valid: Local Region Usage**

```cursive
procedure process() {
region temporary {
// Allocates '10' inside 'temporary'
// 'ptr' has provenance Region(temporary)
let ptr = &^10; 

// Allocates Point inside 'temporary'
let p = ^Point { x: 1, y: 2 };
} 
// 'temporary' is freed. 'ptr' and 'p' are invalid.
}
```

**Invalid: Escape Attempt**

```cursive
procedure escape_attempt() -> Ptr<i32>@Valid {
region local {
let val = ^100;
// Error E-MEM-3020: Return type expects caller lifetime, 
// but 'val' has Region(local) provenance.
result &val 
}
}
```

### 3.4 [RESERVED]

This section is reserved.

> **Migration Note:** The Partitioning System has been superseded by the Lens system (¬ß12.6 Linear Lenses, ¬ß12.7 Static Field Lenses), which provides simpler compile-time guarantees for spatial disjointness without requiring complex linear form analysis or the `partitioned` permission.
>
> Code using `partition` statements and the former `partitioned` permission should migrate to Linear Lenses. See Migration Guide (Appendix M).

### 3.5 Unsafe Semantics

#### Definition

**Formal Definition**
**Unsafe Semantics** refers to the relaxation of specific static safety constraints within a bounded lexical scope.
Let $C_{safe}$ be the set of static constraints enforced by the Cursive compiler (Liveness, Aliasing, Type Safety).
Let $C_{unsafe}$ be the subset of constraints enforced within an `unsafe` block.
The relationship is strictly: $C_{unsafe} \subset C_{safe}$.

**The Unsafe Assertion**
The presence of an `unsafe` block constitutes a normative assertion by the programmer that the code contained within satisfies all dynamic safety requirements of the abstract machine, despite the absence of static verification. If this assertion is false, the program exhibits **Unverifiable Behavior (UVB)**.

#### Syntax & Declaration

**Unsafe Block**
The `unsafe` keyword introduces a block where unsafe operations are permitted.

```ebnf
unsafe_block ::= "unsafe" block
```

**Unsafe Procedure Attribute**
Procedures may be marked `unsafe` to indicate that their callers must uphold preconditions that cannot be checked by the compiler.

```ebnf
procedure_decl ::= "unsafe"? "procedure" identifier ...
```

#### Static Semantics

**Suspension of Constraints**
Within the lexical scope of an `unsafe` block, the following static checks are **DISABLED**:

1.  **Liveness:** The compiler does not verify that raw pointers refer to valid, initialized memory.
2.  **Aliasing:** The compiler does not enforce exclusivity **or synchronization** for raw pointers. Multiple mutable raw pointers to the same address are permitted.
3.  **Partitioning:** The compiler does not verify disjointness for raw pointer access.

**Enabled Operations**
The following operations are classified as **Unsafe Operations**. They **MUST** appear only within an `unsafe` block. Attempting to use them in safe code **MUST** trigger diagnostic `E-MEM-3030`.

1.  **Raw Dereference:** Applying the dereference operator `*` to a raw pointer (`*imm T` or `*mut T`).
2.  **Unsafe Call:** Invoking a procedure declared with `unsafe` or `extern`.
3.  **Transmute:** Invoking the `transmute` intrinsic.
4.  **Pointer Arithmetic:** Using additive operators (`+`, `-`) on raw pointers.

**Transmute Intrinsic**
The `transmute` intrinsic reinterprets the bits of a value of type $S$ as a value of type $T$.

$$
\frac{\text{sizeof}(S) = \text{sizeof}(T)}{\Gamma \vdash \text{transmute}<S, T>(e: S) : T}
$$

If $\text{sizeof}(S) \neq \text{sizeof}(T)$, the compiler **MUST** emit `E-MEM-3031`.

#### Constraints & Legality

**UVB Containment**
Unverifiable Behavior **MUST** be contained. The compiler **MUST NOT** allow safe code to violate memory safety as a result of unsafe code, provided the unsafe code adheres to its contract.

**Diagnostic Table**
| Code         | Severity | Condition                                          |
| :----------- | :------- | :------------------------------------------------- |
| `E-MEM-3030` | Error    | Unsafe operation performed outside `unsafe` block. |
| `E-MEM-3031` | Error    | `transmute` size mismatch.                         |

#### Examples

**Valid: Unsafe Operations**

```cursive
let x: i32 = 42;
let ptr: *imm i32 = &x as *imm i32;

unsafe {
// 1. Raw Dereference
let val = *ptr;

// 2. Transmute (i32 -> u32) - Size matches (4 bytes)
let bits = transmute<i32, u32>(val);

// 3. Pointer Arithmetic
let next_ptr = ptr + 1; 
}
```

**Invalid: Size Mismatch**

```cursive
unsafe {
// Error E-MEM-3031: sizeof(u8) != sizeof(u32)
let bad = transmute<u8, u32>(10u8); 
}
```

---

## Clause 4: Types, Declarations, and Generics
### 4.1 Foundations

#### Definition

**Formal Definition**
The Cursive Type System is formally defined as a tuple $(\mathcal{T}, \Gamma, \vdash)$, where:

  * $\mathcal{T}$ is the set of all valid types constructed from primitive types, composite types, and type constructors defined in this Clause.
  * $\Gamma$ is the **Type Context**, an ordered mapping of identifiers to types ($\text{Id} \to \mathcal{T}$), representing the compile-time knowledge of bindings in scope.
  * $\vdash$ is the ternary derivation relation used in typing judgments (e.g., $\Gamma \vdash e : T$).

**Prose Definition**
Cursive is a **statically typed** language. Every expression in a well-formed program has a type determined at compile time. The type system employs a hybrid classification strategy:

1.  **Nominal Typing:** Applied to `record`, `enum`, and `modal` types. Equivalence is determined by the unique identity of the type's declaration.
2.  **Structural Typing:** Applied to `tuple`, `union`, and `function` types. Equivalence is determined by the structure and types of their components.
3.  **Permission Typing:** Applied to references. Types are qualified by permissions (`unique`, `partitioned`, `concurrent`, `const`) which determine valid operations (mutation, aliasing) rather than value representation.

#### Static Semantics

**Typing Judgments**
The implementation **MUST** implement type checking based on the following fundamental judgments:

  * **Well-Formed Type:** $\Gamma \vdash T : \text{Type}$
    Asserts that $T$ is a valid type in context $\Gamma$.
  * **Type Assignment:** $\Gamma \vdash e : T$
    Asserts that expression $e$ evaluates to a value of type $T$ in context $\Gamma$.
  * **Type Equivalence:** $\Gamma \vdash T \equiv U$
    Asserts that types $T$ and $U$ are interchangeable in all contexts (reflexive, symmetric, transitive).
  * **Subtyping:** $\Gamma \vdash T <: U$
    Asserts that a value of type $T$ can be used where type $U$ is required (reflexive, transitive, antisymmetric).

**Equivalence Rules ($\equiv$)**
Implementations **MUST** enforce type equivalence according to the classification of the type:

1.  **Nominal Equivalence:** Two nominal types are equivalent if and only if they refer to the same declaration definition.
    $$
    \frac{\text{Decl}(A) = \text{Decl}(B)}{\Gamma \vdash A \equiv B}
    $$

2.  **Structural Equivalence (Tuples):** Two tuple types are equivalent if they have the same arity and their corresponding elements are equivalent.
    $$
    \frac{n = m \quad \forall i \in 1..n, \Gamma \vdash T_i \equiv U_i}{\Gamma \vdash (T_1, \dots, T_n) \equiv (U_1, \dots, U_m)}
    $$

3.  **Permission Equivalence:** Two permission-qualified types are equivalent only if both the permission and the underlying type match exactly.
    $$
    \frac{P_1 = P_2 \quad \Gamma \vdash T \equiv U}{\Gamma \vdash P_1~T \equiv P_2~U}
    $$

    *Note: `unique T` is **not** equivalent to `const T`.*

**Subtyping Rules ($<:$)**
Subtyping defines the valid implicit coercions in the language. The implementation **MUST** support the following subtyping relationships:

1.  **The Bottom Type (\!):** The never type `!` is a subtype of all types.

    $$
    \frac{\Gamma \vdash T : \text{Type}}{\Gamma \vdash \text{!} <: T}
    $$


2.  **Permission Subtyping:** A stronger permission is a subtype of a weaker permission (see ¬ß4.3).

    $$
    \frac{}{\Gamma \vdash \text{unique } T <: \text{partitioned } T} \quad \frac{}{\Gamma \vdash \text{partitioned } T <: \text{const } T}
    $$
    $$
    \frac{}{\Gamma \vdash \text{unique } T <: \text{concurrent } T} \quad \frac{}{\Gamma \vdash \text{concurrent } T <: \text{const } T}
    $$

3.  **Trait Implementation:** A concrete type $T$ is a subtype of any trait $Tr$ it implements.

    $$
    \frac{T \text{ implements } Tr}{\Gamma \vdash T <: Tr}
    $$
    
    **Bidirectional Type Inference**
    The compiler **MUST** implement a bidirectional type checking algorithm consisting of two modes:

1.  **Synthesis Mode ($\Rightarrow$):** The compiler determines the type of an expression $e$ based solely on its structure.

      * Example: $\Gamma \vdash \text{10} \Rightarrow \text{i32}$

2.  **Checking Mode ($\Leftarrow$):** The compiler verifies that expression $e$ matches an expected type $T$ provided by the context (e.g., function arguments, annotated variables).

      * Example: $\Gamma \vdash \text{10} \Leftarrow \text{u8}$ (Valid, because 10 fits in u8).

#### Memory & Layout

**Representation**
The physical layout of types in memory is classified as follows:

  * **Implementation-Defined Behavior (IDB):** By default, the size, alignment, and field ordering of `record` and `enum` types are implementation-defined. The implementation **MAY** reorder fields to minimize padding.
  * **Defined Behavior (Primitive):** The layout of primitive types is strictly defined by ¬ß4.4.
  * **Defined Behavior (C-Compatible):** When the `[[repr(C)]]` attribute is applied to a `record` or `enum`, the implementation **MUST** utilize a layout compatible with the target platform's C ABI (no field reordering, standard padding).

**Documentation Requirement**
Conforming implementations **MUST** document their default layout strategy in the **Conformance Dossier**.

#### Constraints & Legality

**Negative Constraints**

  * **Inference Boundary:** Type inference **MUST NOT** operate across procedure boundaries. All top-level declarations (procedures, globals) **MUST** have fully explicit type annotations.
  * **Missing Annotation:** Omission of a required type annotation at the top level **MUST** result in a compile-time error.
  * **Recursive Types**: Recursive types **MUST** be broken by a pointer, reference, or boxing. Direct structural recursion **MUST** be rejected with `E-DEC-2420`.

**Diagnostic Table**
| Code         | Severity | Condition                                                                   |
| :----------- | :------- | :-------------------------------------------------------------------------- |
| `E-TYP-1501` | Error    | Type mismatch: Expression type does not match expected type ($T \not<: U$). |
| `E-TYP-1505` | Error    | Missing required type annotation on top-level declaration.                  |

#### Examples

**Valid: Inference and Subtyping**

```cursive
// Explicit top-level signature (Required)
procedure process(input: i32) -> i32 {
    // Inference (Synthesis): 'x' inferred as i32 from 'input'
    let x = input + 1; 
    
    // Inference (Checking): '100' (i32) checked against u8
    // Valid because 100 fits in u8
    let y: u8 = 100; 

    // Subtyping: 'panic' returns '!', which is a subtype of i32
    if x < 0 {
        panic("Error");
    }

    result x;
}
```

**Invalid: Inference Boundary Violation**

```cursive
// Error E-TYP-1505: Missing return type and parameter type
// The compiler will not infer these from usage.
procedure invalid_decl(x) { 
    result x;
}
```

### 4.2 Variance & Polarity

#### Definition

**Polarity** is a property of a generic type parameter $T$ within a type definition $C<T>$ that describes how the subtyping relationship of the resulting type $C$ relates to the subtyping relationship of its parameter $T$.

Let $\mathcal{P}$ be the set of polarities $\{+, -, =, *\}$.

  * $+$ (**Covariant**): Preserves subtyping direction.
  * $-$ (**Contravariant**): Reverses subtyping direction.
  * $=$ (**Invariant**): Requires type equivalence (disables subtyping).
  * $*$ (**Bivariant**): Ignores type relationship (rare, used for phantom data).

Variance defines how generic types behave with respect to subtyping.

  * If `Dog <: Animal`, and `List<T>` is **Covariant**, then `List<Dog> <: List<Animal>`.
  * If `List<T>` is **Contravariant**, then `List<Animal> <: List<Dog>`.
  * If `List<T>` is **Invariant**, then there is no subtyping relationship between `List<Dog>` and `List<Animal>`.

In Cursive, variance is **inferred** from the usage of the parameter within the type definition. Explicit variance annotations (e.g., `out T`, `in T`) are not supported.

#### Static Semantics

**Polarity Inference**
The compiler **MUST** compute the polarity for every generic parameter $T$ of a type $C<T>$ by analyzing all positions where $T$ appears in the definition of $C$.

The polarity is determined by combining the usage contexts using the following lattice operations, starting with **Bivariant (\*)** as the bottom element.

1.  **Output Positions (+):**
      * Return types of methods.
      * Types of immutable (`let`) fields.
      * Types of `const` fields.
2.  **Input Positions (-):**
      * Parameter types of methods.
3.  **Mutable Positions (=):**
      * Types of mutable (`var`) fields.
      * Types of fields accessed via `unique` or `partitioned` paths in the type's implementation.

**Composition Rules:**

  * $+$ combined with $+$ $\to$ $+$
  * $-$ combined with $-$ $\to$ $+$ (Double negative is positive)
  * $+$ combined with $-$ $\to$ $-$
  * Any usage combined with $=$ $\to$ $=$ (Invariance is absorbing)

**Inference Algorithm:**

1.  Initialize $P(T) = *$.
2.  For each usage of $T$ in declaration $C$:
      * Let $P_{usage}$ be the polarity of the position.
      * Update $P(T) = P(T) \sqcap P_{usage}$ (where $\sqcap$ is the meet operation in the variance lattice where $=$ is top).

**Subtyping Rules**
The compiler **MUST** enforce the following subtyping judgments for generic types.

Let $C<T>$ be a generic nominal type where parameter $T$ has inferred polarity $P_T$.

$$
\frac{P_T = + \quad \Gamma \vdash A <: B}{\Gamma \vdash C<A> <: C<B>}
\tag{T-Sub-Covar}
$$

$$
\frac{P_T = - \quad \Gamma \vdash B <: A}{\Gamma \vdash C<A> <: C<B>}
\tag{T-Sub-Contra}
$$

$$
\frac{P_T = = \quad \Gamma \vdash A \equiv B}{\Gamma \vdash C<A> <: C<B>}
\tag{T-Sub-Invar}
$$

**The `const` Permission Exception**
A crucial feature of the Cursive type system is that `const` permission effectively "freezes" mutation, allowing Invariant types to behave Covariantly.

If a type $C<T>$ is **Invariant** with respect to $T$ solely due to mutable fields or methods, a `const` reference to $C<T>$ **MUST** treat $T$ as **Covariant**.

$$
\frac{\Gamma \vdash A <: B}{\Gamma \vdash \text{const } C<A> <: \text{const } C<B>}
\tag{T-Sub-Const-Covar}
$$

**Rationale:** If $C<T>$ is immutable (`const`), the methods/fields that caused invariance (writers) are inaccessible. Therefore, it is safe to treat the type as a producer of $T$ (Covariant).

#### Constraints & Legality

**Negative Constraints**

  * **Explicit Annotations:** Users **MUST NOT** provide explicit variance keywords (e.g., `in`, `out`). Variance is strictly inferred.
  * **Conflict:** It is impossible to create a "conflict" error because the inference simply degrades to Invariant (=) if a parameter is used in both input and output positions.

#### Examples

**Valid: Inferred Covariance**

```cursive
// T is used only in output position (field is effectively read-only in this context)
// Inference: T is Covariant (+)
record Producer<T> {
    value: T
}

let p_dog: Producer<Dog> = ...
let p_animal: Producer<Animal> = p_dog // OK: Producer<Dog> <: Producer<Animal>
```

**Valid: Inferred Invariance**

```cursive
// T is used in mutable position (var field)
// Inference: T is Invariant (=)
record Container<T> {
    var item: T
}

let c_dog: Container<Dog> = ...
// let c_animal: Container<Animal> = c_dog // Error E-TYP-1501: Invariant mismatch

// BUT, allowed via const permission:
let c_view: const Container<Animal> = c_dog // OK: const makes it Covariant
```

**Valid: Contravariance**

```cursive
// T is used only in input position
// Inference: T is Contravariant (-)
trait Handler<T> {
    procedure handle(item: T);
}

let h_animal: Handler<Animal> = ...
let h_dog: Handler<Dog> = h_animal // OK: Handler<Animal> <: Handler<Dog>
// (A handler that can handle any Animal can certainly handle a Dog)
```

### Assessment of Previous Draft (Section 4.3)

**Verdict: Insufficient.**

While the previous draft successfully defined the lattice semantics and the syntax of permissions, it failed to define **Permission Projection** (also known as *View Adaptation*).

**Critical Deficiencies:**

1.  **Missing Projection Rules:** The draft defined `unique T` but did not define the type of `unique_binding.field`. Without a formal rule stating that permissions flow transitively to fields (e.g., `unique T` $\to$ `unique T.field`), the type checker cannot validate member access. This is a fatal gap for a clean-room implementer.
2.  **Vague "Interior Mutability" Semantics:** The draft stated `concurrent` allows mutation via APIs but did not define the underlying mechanism (intrinsics or `UnsafeCell`) that makes those APIs legal. A hostile reader could argue that `concurrent` mutation is impossible to implement because the spec forbids "direct field assignment" without offering an alternative primitive.
3.  **Undefined "Downgrading":** The term "Downgrading" was used without defining its mechanics (Reborrowing). It must be explicitly defined as creating a new binding with a shorter lifetime.

**Corrective Action:**
I will rewrite **Section 4.3** immediately to include the **Permission Projection Rules** and explicitly define the **Interior Mutability Primitive** boundary.

### 4.3 Permission Types

#### Definition

**Formal Definition**
The **Permission System** is a type qualification framework defined by the set $\mathcal{P} = \{ \texttt{unique}, \texttt{concurrent}, \texttt{const} \}$.

A permission $P \in \mathcal{P}$ is a modifier applied to a base type $T$, denoted $P~T$. It determines the **Aliasing XOR Mutation** invariant for that reference:

1.  **`unique`**: **Exclusive Ownership.** $\text{Aliases} = 0$, $\text{Mutation} = \text{Allowed}$.
2.  **`concurrent`**: **Shared Aliasing.** $\text{Aliases} > 0$, $\text{Mutation} = \text{Allowed}$ (Synchronized only).
3.  **`const`**: **Immutable Aliasing.** $\text{Aliases} > 0$, $\text{Mutation} = \text{Forbidden}$.

> **Note:** Spatial partitioning (formerly the `partitioned` permission) is now achieved through the Lens system (¬ß12.6), which provides `unique` views of disjoint portions without requiring a separate permission.

**The Permission Lattice**
Permissions form a bounded partial order $(\mathcal{P}, \preceq)$ where $A \preceq B$ implies $A$ is a subtype of $B$ (can be coerced to $B$).

  * $\text{Top} = \text{const}$ (Weakest guarantees)
  * $\text{Bottom} = \text{unique}$ (Strongest guarantees)

#### Syntax & Declaration

**Grammar**

```ebnf
permission_type ::= permission type
permission      ::= "unique" | "concurrent" | "const"
```

  * If the `permission` token is omitted from a type reference, it defaults to **`const`**.
  * Exceptions: `let` bindings inferred from initialization (`let x = y`) inherit the permission of the source expression.

**Receiver Shorthands**
Method parameters named `self` **MUST** support the following shorthands, which desugar to explicit permission types:

| Shorthand | Desugared Type           | Semantics                    |
| :-------- | :----------------------- | :--------------------------- |
| `~`       | `self: const Self`       | Read-Only view.              |
| `~!`      | `self: unique Self`      | Exclusive Read/Write view.   |
| `~\|`     | `self: concurrent Self`  | Synchronized/Atomic view.    |

#### Static Semantics

**1. The Subtyping Lattice**
The compiler **MUST** enforce the following coercion rules. The three permissions form a **linear lattice**:

$$\texttt{unique} \preceq \texttt{concurrent} \preceq \texttt{const}$$

```
    unique        (exclusive read-write)
       |
  concurrent      (synchronized shared mutable)
       |
     const        (shared read-only)
```

* **Transitivity:** $\text{unique} \preceq \text{const}$ holds by transitivity.
* The `unique` permission can be downgraded to `concurrent` (by wrapping in `Mutex`) or to `const` (by taking a read-only view).

**2. The Concurrent-Safety Constraint**
The `concurrent` permission is well-formed **if and only if** the base type $T$ is **concurrent-safe**.

$$
\frac{T \text{ is concurrent-safe}}{\Gamma \vdash \text{concurrent } T : \text{Type}}
$$

**Concurrent-Safety Determination (Layered Verification):**

A type $T$ is **concurrent-safe** if any of the following conditions hold:

1.  **Primitive Types**: $T \in \{ \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64}, \texttt{i128}, \texttt{isize}, \texttt{u8}, \texttt{u16}, \texttt{u32}, \texttt{u64}, \texttt{u128}, \texttt{usize}, \texttt{bool} \}$. These have built-in atomic intrinsics.

2.  **Built-in Synchronization Types**: $T \in \{ \texttt{Mutex<U>}, \texttt{RwLock<U>}, \texttt{Condvar}, \texttt{Task<U>}, \texttt{Channel<U>} \}$. These are compiler-provided.

3.  **User Types with Verified `~|` Methods**: $T$ has one or more methods with `~|` receiver, AND all such methods pass the `~|` Method Verification Rules (see ¬ß9.1.2).

4.  **Transitive Safety**: $T$ has NO methods with `~|` receiver, AND all fields of $T$ are themselves concurrent-safe.

Attempting to form `concurrent T` where $T$ is not concurrent-safe **MUST** trigger `E-TYP-1604`.

**3. Permission Projection (Field Access)**
Permissions are transitive. When accessing a field `f` of type $T_f$ from a parent object `p` with permission $P_p$, the resulting permission of the field access $P_{res}$ is determined by the **Projection Function** $\Phi(P_p, T_f)$:

$$
\Gamma \vdash p.f : \Phi(P_p, T_f)~T_f
$$

The projection logic is defined as:

1.  **Unique Parent (`unique`)**:
* Fields inherit `unique`.
* $\Phi(\text{unique}, T) = \text{unique}$
2.  **Const Parent (`const`)**:
* Fields inherit `const`.
* $\Phi(\text{const}, T) = \text{const}$
3.  **Concurrent Parent (`concurrent`)**:
* **Constraint:** Direct field access on `concurrent` types typically yields `const` to prevent data races, **UNLESS** the field access is inside an `unsafe` block or the field is specifically marked safe for concurrent access (e.g., Atomic intrinsics).
* Standard Rule: $\Phi(\text{concurrent}, T) = \text{const}$ (Conservative Default).
* *Note: Interior mutability for concurrent types is handled via methods, not direct field assignment.*

**4. Downgrading**
A binding $b$ with permission $P_{strong}$ **MAY** be downgraded as $P_{weak}$ (where $P_{strong} \preceq P_{weak}$) for a bounded lexical scope.

* During the downgrade scope, $b$ is **statically invalidated**.
* Upon scope exit, $b$ is restored to $P_{strong}$.

#### Memory & Layout

**Representation**
Permissions are purely static attributes. They have **zero size** and do not affect the object's runtime representation.

$$\text{sizeof}(P~T) \equiv \text{sizeof}(T)$$

**ABI Guarantees**
For FFI purposes:

* `unique T`, `const T`, and `concurrent T` are all ABI-equivalent to a standard pointer to $T$ (or value $T$ if represented directly).

#### Constraints & Legality

**Negative Constraints**

1.  **Mutation Restriction:**
Assignment (`x = y`) or mutable binding (`var x = ...`) requires the target place to have `unique` permission.
$$\frac{\Gamma \vdash \text{place} : \text{const } T}{\Gamma \nvdash \text{place} = \text{val}}$$
**Diagnostic:** `E-TYP-1601`.

2.  **Concurrent Field Assignment:**
Direct assignment to a field of a `concurrent` reference is **Forbidden** in safe code, even if the underlying type is mutable. Mutation of `concurrent` data **MUST** occur via methods with `~|` receiver (e.g., atomic intrinsics like `i64.fetch_add()`, or synchronization primitives like `Mutex.lock()`).

**Diagnostic Table**

| Code         | Severity | Condition                                                |
| :----------- | :------- | :------------------------------------------------------- |
| `E-TYP-1601` | Error    | Attempt to mutate data via a `const` reference.          |
| `E-TYP-1602` | Error    | Violation of `unique` exclusion (aliasing detected).     |
| `E-TYP-1604` | Error    | `concurrent` permission used on type that is not concurrent-safe. |

#### Examples

**Valid: Projection and Coercion**

```cursive
record Point { x: i32, y: i32 }

procedure main() {
let u: unique Point = Point { x: 1, y: 2 };

// Projection: u.x is 'unique i32'
u.x = 5; 

// Coercion: unique -> const
// 'c' borrows 'u'. 'u' is invalidated.
let c: const Point = u; 

// Projection: c.x is 'const i32'
// c.x = 10; // Error E-TYP-1601
} // 'c' expires, 'u' is valid again.
```

**Invalid: Mutation via const**

```cursive
procedure fail(p: const Point) {
// Error: cannot mutate through const permission.
// p.x = 10;  // E-TYP-1601
}
```

### 4.4 Primitive Types

#### 4.4.1 Integer Types

#### Definition

**Formal Definition**
The set of **Integer Types** $\mathcal{T}_{int}$ is defined as the union of **Signed Types** $\mathcal{T}_{signed}$ and **Unsigned Types** $\mathcal{T}_{unsigned}$.

  * **Signed Types:** $\mathcal{T}_{signed} = \{ \texttt{i8}, \texttt{i16}, \texttt{i32}, \texttt{i64}, \texttt{i128}, \texttt{isize} \}$
  * **Unsigned Types:** $\mathcal{T}_{unsigned} = \{ \texttt{u8}, \texttt{u16}, \texttt{u32}, \texttt{u64}, \texttt{u128}, \texttt{usize} \}$

**Prose Definition**
Integer types represent finite subsets of the mathematical integers $\mathbb{Z}$.

  * **Fixed-Width:** Types with explicit bit-widths (`i8`..`i128`, `u8`..`u128`) have a constant range across all target platforms.
  * **Architecture-Dependent:** The types `isize` and `usize` are sized to match the target platform's pointer width (address space).

#### Syntax & Declaration

**Grammar**

```ebnf
integer_type ::= "i8" | "i16" | "i32" | "i64" | "i128" | "isize"
               | "u8" | "u16" | "u32" | "u64" | "u128" | "usize"
               | "int" | "uint"
```

**Aliases**
The following keywords are transparent aliases. They **MUST** be treated as semantically identical to their canonical counterparts in all contexts (declarations, inference, layout).

| Keyword | Canonical Type |
| :------ | :------------- |
| `int`   | `i32`          |
| `uint`  | `u32`          |

#### Static Semantics

**Domain Limits**
For a type $T$ with bit-width $N$:

  * If $T \in \mathcal{T}_{unsigned}$, the valid value range is $[0, 2^N - 1]$.
  * If $T \in \mathcal{T}_{signed}$, the valid value range is $[-2^{N-1}, 2^{N-1} - 1]$.

**Type Checking**
Integers of different widths or signs are **distinct types**. There is no implicit coercion between integer types. Conversions **MUST** be performed using the explicit cast operator `as`.

#### Dynamic Semantics

**Representation Requirement**

  * **Signed Integers:** Implementations **MUST** use **Two's Complement** representation.
  * **Unsigned Integers:** Implementations **MUST** use standard binary representation.

**Overflow Behavior**
The behavior of arithmetic operations (`+`, `-`, `*`) that result in a value outside the type's domain is dependent on the compilation mode.

  * **Strict/Debug Mode:** The implementation **MUST** check for overflow. If overflow occurs, the program **MUST** panic.
  * **Release/Optimized Mode:** The implementation **MAY** allow arithmetic to wrap via two's complement modular arithmetic (Definition: **Implementation-Defined Behavior**). The specific behavior chosen **MUST** be documented in the Conformance Dossier.

#### Memory & Layout

**Mandatory Layouts**
Conforming implementations **MUST** strictly adhere to the following size and alignment requirements.

| Type             | Size (bytes)  | Alignment (bytes)            |
| :--------------- | :------------ | :--------------------------- |
| `i8`, `u8`       | 1             | 1                            |
| `i16`, `u16`     | 2             | 2                            |
| `i32`, `u32`     | 4             | 4                            |
| `i64`, `u64`     | 8             | 8                            |
| `i128`, `u128`   | 16            | Platform-dependent (8 or 16) |
| `isize`, `usize` | Pointer Width | Pointer Alignment            |

**Pointer Width:** Defined by the target architecture (typically 4 bytes for 32-bit, 8 bytes for 64-bit).

#### Constraints & Legality

**Negative Constraints**

  * **Implicit Coercion:** An expression of type `i32` **MUST NOT** be passed to a context expecting `i64` (or any other mismatch) without an explicit cast.

#### Examples

**Valid: Explicit Typing and Casting**

```cursive
let a: i32 = 10;
let b: u32 = 10; // Explicit annotation
let c: i64 = a as i64; // Explicit cast
```

**Invalid: Mixing Types**

```cursive
let x: i32 = 10;
let y: i64 = x; // Error E-TYP-1501: Type mismatch (i32 vs i64)
```

#### 4.4.2 Floating-Point Types

#### Definition

**Formal Definition**
The set of **Floating-Point Types** $\mathcal{T}_{float} = \{ \texttt{f16}, \texttt{f32}, \texttt{f64} \}$.

**Prose Definition**
Floating-point types represent approximate real numbers using the IEEE 754 standard formats.

#### Syntax & Declaration

**Grammar**

```ebnf
float_type ::= "f16" | "f32" | "f64"
             | "half" | "float" | "double"
```

**Aliases**
The following keywords are transparent aliases:

| Keyword  | Canonical Type | Standard Reference |
| :------- | :------------- | :----------------- |
| `half`   | `f16`          | IEEE 754 binary16  |
| `float`  | `f32`          | IEEE 754 binary32  |
| `double` | `f64`          | IEEE 754 binary64  |

#### Static Semantics

**IEEE 754 Conformance**
Implementations **MUST** support the value sets defined by IEEE 754 for binary16, binary32, and binary64, including signed zeros, signed infinities (`+inf`, `-inf`), and Not-a-Number (`NaN`) values.

#### Dynamic Semantics

**Operation Semantics**
Arithmetic operations **MUST** adhere to IEEE 754 rules for rounding (default: roundTiesToEven) and exception handling (e.g., division by zero produces `inf` or `NaN`, it does not panic).

**f16 Emulation**
Because `f16` (half-precision) is often emulated in software on general-purpose CPUs, operations on `f16` values **SHOULD** trigger warning `W-TYP-1701` unless the target hardware supports native execution or the user explicitly suppresses the warning.

#### Memory & Layout

**Mandatory Layouts**

| Type  | Size (bytes) | Alignment (bytes) |
| :---- | :----------- | :---------------- |
| `f16` | 2            | 2                 |
| `f32` | 4            | 4                 |
| `f64` | 8            | 8                 |

#### Constraints & Legality

**Diagnostic Table**

| Code         | Severity | Condition                                                                        |
| :----------- | :------- | :------------------------------------------------------------------------------- |
| `W-TYP-1701` | Warning  | `f16` arithmetic usage detected (potential software emulation performance trap). |

#### Examples

**Valid: Float Usage**

```cursive
let pi: f64 = 3.14159;
let big_pi: double = pi; // Alias usage
```

**Valid: f16 with Warning**

```cursive
// Triggers W-TYP-1701
let h: f16 = 1.0;
let h2 = h + h; 
```

#### 4.4.3 Boolean Type

#### Definition

**Formal Definition**
The Boolean Type $\mathbb{B} = \{ \texttt{true}, \texttt{false} \}$.

**Prose Definition**
The type `bool` represents a truth value used for logical operations and control flow.

#### Syntax & Declaration

**Grammar**

```ebnf
bool_type ::= "bool"
bool_literal ::= "true" | "false"
```

#### Memory & Layout

**Representation**

  * **Size:** 1 byte.
  * **Alignment:** 1 byte.
  * **Bit Pattern:**
      * `false` **MUST** be represented as `0x00`.
      * `true` **MUST** be represented as `0x01`.
      * Any other byte value (e.g., `0x02`, `0xFF`) is an **Invalid Representation**. Creating such a value (e.g., via `unsafe` transmute) is **Undefined Behavior**.

#### Constraints & Legality

**Negative Constraints**

  * **No Numeric Coercion:** `bool` **MUST NOT** be implicitly coerced to integer types, nor integers to `bool`. Explicit `match` or `if` constructs must be used.
  * **Invalid Bit Patterns**: Any byte value for a `bool` other than `0x00` or `0x01` is an **Invalid Representation**. Creating such a value constitutes Undefined Behavior.

#### Examples

**Valid**

```cursive
let flag: bool = true;
if flag { ... }
```

**Invalid**

```cursive
let x: i32 = true; // Error: Type mismatch
```

#### 4.4.4 Character Type

#### Definition

**Formal Definition**
The Character Type `char` represents a single **Unicode Scalar Value**.
The domain of `char` is $\mathcal{D}_{char} = \{ c \in \mathbb{N} \mid (0 \le c \le \text{0xD7FF}) \lor (\text{0xE000} \le c \le \text{0x10FFFF}) \}$.

**Prose Definition**
A `char` is a 32-bit value representing a valid Unicode character. It explicitly excludes Surrogate Pair code points.

#### Syntax & Declaration

**Grammar**

```ebnf
char_type ::= "char"
```

#### Memory & Layout

**Representation**

  * **Size:** 4 bytes.
  * **Alignment:** 4 bytes.
  * **Invariant:** The stored 32-bit integer **MUST** always be within $\mathcal{D}_{char}$.

#### Constraints & Legality

**Validity Constraint**
It is **Undefined Behavior** to construct a `char` with a value outside $\mathcal{D}_{char}$ (e.g., `0xD800` or `0x110000`) via `unsafe` mechanisms. A character literal representing a surrogate code point **MUST** be rejected with `E-SRC-0303`.

#### Examples

**Valid**

```cursive
let c1: char = 'a';
let c2: char = 'üöÄ'; // U+1F680
```

#### 4.4.5 Unit Type

#### Definition

**Formal Definition**
The Unit Type is the singleton set containing exactly one value: `()`.

**Prose Definition**
The type `()` (pronounced "unit") indicates the absence of meaningful data. It is the default return type for procedures that do not return a value.

#### Syntax & Declaration

**Grammar**

```ebnf
unit_type ::= "(" ")"
unit_literal ::= "(" ")"
```

#### Memory & Layout

**Representation**

  * **Size:** 0 bytes.
  * **Alignment:** 1 byte (minimum alignment for addressability, though it occupies no space).

#### Examples

**Valid**

```cursive
procedure do_nothing() {
    // Implicitly returns ()
}
let x: () = do_nothing();
```

#### 4.4.6 Never Type

#### Definition

**Formal Definition**
The Never Type, denoted `!`, is the **Uninhabited Set** $\emptyset$.

**Prose Definition**
The type `!` represents a computation that never resolves to a value (e.g., it always panics, exits the process, or loops forever).

#### Static Semantics

**Subtyping Rule (Bottom Type)**
The type `!` is a subtype of all types $T$.

$$
\frac{\Gamma \vdash T : \text{Type}}{\Gamma \vdash \texttt{!} <: T}
$$

This allows expressions of type `!` (like `panic()`) to be used in any context.

#### Memory & Layout

**Representation**

* **Size:** 0 bytes.
* **Alignment:** 1 byte.
* **Existence:** Because the set of values is empty, no instance of `!` can ever exist at runtime. Code paths attempting to instantiate `!` are predominantly dead code or terminate execution before instantiation.

#### Examples

**Valid: Divergence**

```cursive
let x: i32 = if valid {
10
} else {
panic("Error") // Type is !, which coerces to i32
};
```

### 4.5 Composite Types & Declarations

#### 4.5.1 Tuples (Anonymous Products)

#### Definition

**Formal Definition**
A **Tuple Type** $T$ is an ordered, finite sequence of $n$ component types $(t_0, t_1, \dots, t_{n-1})$ where $n \ge 0$.
The **Arity** of the tuple is $n$.
The **Unit Type** `()` defined in ¬ß4.4.5 is the tuple of arity 0.

**Prose Definition**
A tuple is a structural product type that aggregates a fixed number of heterogeneous values. Tuples are identified solely by the sequence of their component types; they have no name. Access to tuple elements is positional (index-based).

#### Syntax & Declaration

**Grammar**

```ebnf
tuple_type    ::= "(" ( type ( "," type )* ","? )? ")"
tuple_literal ::= "(" ( expression ( "," expression )* ","? )? ")"
tuple_access  ::= expression "." integer_literal
```

**Desugaring**

  * A parenthesized expression `(e)` with no commas is a grouping expression, not a tuple.
  * A single-element tuple requires a trailing comma: `(e,)`.

#### Static Semantics

**Typing Rules**
The type of a tuple literal is the tuple of its element types.

$$
\frac{\forall i \in 0..n-1, \quad \Gamma \vdash e_i : T_i}{\Gamma \vdash (e_0, \dots, e_{n-1}) : (T_0, \dots, T_{n-1})}
$$

**Element Access**
Accessing an element requires a constant integer index $k$ within the bounds $[0, n)$.

$$
\frac{\Gamma \vdash e : (T_0, \dots, T_{n-1}) \quad 0 \le k < n}{\Gamma \vdash e.k : T_k}
$$

If $k \ge n$ or $k < 0$, the compiler **MUST** emit `E-TYP-1801`.

**Equivalence**
Two tuple types are equivalent if they have the same arity and their corresponding component types are equivalent (¬ß4.1).

#### Memory & Layout

**Representation**

  * **Size**: At least $\sum \text{sizeof}(T_i)$.
  * **Alignment**: $\max(\{\text{alignof}(T_i)\})$.
  * **Ordering**: Fields **MUST** be stored in the order defined (index 0 to $n-1$).
  * **Padding**: Implementation-Defined Behavior (IDB). The compiler **MAY** insert padding between elements to satisfy alignment requirements.

#### Constraints & Legality

**Diagnostic Table**
| Code         | Severity | Condition                                                    |
| :----------- | :------- | :----------------------------------------------------------- |
| `E-TYP-1801` | Error    | Tuple index out of bounds (compile-time constant violation). |

#### Examples

**Valid**

```cursive
let pair: (i32, bool) = (10, true);
let val = pair.0; // i32
```

**Invalid**

```cursive
let single = (10); // Error: Grouping, type is i32, not (i32,)
let pair = (10, 20);
let bad = pair.2;  // Error E-TYP-1801: Index 2 out of bounds for arity 2
```

-----

#### 4.5.2 Arrays and Slices

#### Definition

**Formal Definition**

  * **Array Type**: $A = [T; N]$ is a homogeneous sequence of $N$ elements of type $T$, where $N \in \mathbb{N}$.
  * **Slice Type**: $S = [T]$ is a dynamically-sized view into a contiguous sequence of type $T$.

**Prose Definition**

  * **Arrays** are fixed-size values owning their data. They are allocated inline (stack, region, or within a record).
  * **Slices** are "dense pointers" (fat pointers) consisting of a pointer to the data and a length. They do not own the underlying storage.

#### Syntax & Declaration

**Grammar**

```ebnf
array_type    ::= "[" type ";" constant_expression "]"
slice_type    ::= "[" type "]"

array_literal ::= "[" expression ( "," expression )* ","? "]"
                | "[" expression ";" constant_expression "]"

indexing      ::= expression "[" expression "]"
```

#### Static Semantics

**Array Typing**

$$
\frac{\Gamma \vdash N : \text{usize} \quad \text{is\_const}(N) \quad \forall i, \Gamma \vdash e_i : T}{\Gamma \vdash [e_0, \dots, e_{N-1}] : [T; N]}
$$

**Indexing**
Indexing is valid for both arrays and slices. The index must be a `usize`.

$$
\frac{\Gamma \vdash arr : [T; N] \lor \Gamma \vdash arr : [T] \quad \Gamma \vdash idx : \text{usize}}{\Gamma \vdash arr[idx] : T}
$$

**Coercion**
An array $[T; N]$ can be implicitly coerced to a slice $[T]$ with permission $P$ if the array binding has permission $P$.

$$
\frac{}{\Gamma \vdash [T; N] <: [T]}
$$

#### Dynamic Semantics

**Bounds Checking**
Every indexing operation `arr[i]` **MUST** be verified against the length of `arr`.

1.  **Static Check**: If `i` and the length are compile-time constants, the check **MUST** be performed at compile time. Failure triggers `E-TYP-1801`.
2.  **Dynamic Check**: Otherwise, the compiler **MUST** insert a runtime check. If `i >= length`, the program **MUST** panic.

#### Memory & Layout

**Array Representation**

* **Size**: $\text{sizeof}(T) \times N$.
* **Alignment**: $\text{alignof}(T)$.
* **Padding**: None between elements.

**Slice Representation**

* **Structure**: A record equivalent to `struct { ptr: *imm T, len: usize }`.
* **Size**: $2 \times \text{sizeof}(\text{usize})$.
* **Alignment**: $\text{alignof}(\text{usize})$.

#### Constraints & Legality

**Diagnostic Table**
| Code         | Severity | Condition                                            |
| :----------- | :------- | :--------------------------------------------------- |
| `E-TYP-1801` | Error    | Index out of bounds (Static check).                  |
| `E-TYP-1802` | Error    | Array length constant is not a valid `usize`.        |
| `E-TYP-1803` | Error    | Repeat count in `[val; N]` is not constant or valid. |

#### Examples

**Valid**

```cursive
let arr: [i32; 3] = [1, 2, 3];
let slice: [i32] = arr; // Implicit coercion
let x = slice[1];       // Dynamic check
```

**Invalid**

```cursive
let arr = [1, 2];
let y = arr[5]; // Error E-TYP-1801 (Static check known failure)
```

-----

#### 4.5.3 Records

#### Definition

**Formal Definition**
A **Record Type** is a nominal product type $R$ defined by a unique declaration $D_R$. It consists of a set of named fields $\{(id_1, T_1), \dots, (id_n, T_n)\}$.

**Prose Definition**
Records are the primary mechanism for defining named, composite data structures. They support named fields, methods, and trait implementations.

#### Syntax & Declaration

**Grammar**

```ebnf
record_decl ::= [ visibility ] "record" identifier [ generic_params ]
                [ "<:" trait_implementations ]
                "{" record_body "}"
                [ "where" "{" predicate "}" ]

record_body ::= partition_decl*
                field_decl*
                procedure_decl*

field_decl  ::= [ visibility ] identifier ":" type
```

**Semantics**

* **Visibility**: Fields default to `private` (module-local) unless marked `public` or `internal`.
* **Partitions**: Defined in ¬ß3.4.

**Type Invariants**

Records may declare a **type invariant** using the `where` clause. The invariant predicate is evaluated on every instance of the record, and the compiler statically verifies that every constructor and method preserves the invariant.

Within the predicate, the **record name** serves as the binding variable, allowing access to fields via dot notation.

**Example**

```cursive
record Fraction {
    numerator: i32,
    denominator: i32
} where { Fraction.denominator != 0 }
```

In this example, `Fraction` binds to the record instance being constrained. The invariant ensures `denominator` is never zero for any valid `Fraction` value.

**Well-Formedness (WF-Type-Invariant)**

$$
\frac{
  \Gamma, R : R \vdash P : \text{bool} \quad \text{pure}(P)
}{
  \Gamma \vdash \textbf{record } R\ \{\ \ldots\ \}\ \textbf{where}\ \{\ P\ \} \text{ wf}
}
$$

**Invariant Preservation**

For any constructor or method that produces a value of record type $R$ with invariant $P$:

$$
\frac{
  \Gamma \vdash e : R \quad \text{invariant}(R) = P
}{
  \Gamma \vdash P[R \mapsto e]
}
$$

The compiler must statically verify that the predicate holds for the constructed value.

See ¬ß7.4 for complete refinement type semantics and predicate binding rules.

#### Static Semantics

**Typing**
Record literals must provide values for all fields.

$$
\frac{R \text{ has fields } f_i: T_i \quad \forall i, \Gamma \vdash e_i : T_i}{\Gamma \vdash R { f_1: e_1, \dots } : R}
$$

**Field Access**

$$
\frac{\Gamma \vdash r : R \quad f \in \text{fields}(R) \quad \text{visible}(f, \Gamma)}{\Gamma \vdash r.f : \text{type}(f)}
$$

Accessing a non-existent or invisible field triggers `E-NAM-1305`.

#### Memory & Layout

**Default Layout**

* **Policy**: Implementation-Defined Behavior (IDB).
* **Optimization**: Implementations **MAY** reorder fields to minimize padding.

**C-Compatible Layout (`[[repr(C)]]`)**

* **Constraint**: When annotated with `[[repr(C)]]`, the implementation **MUST NOT** reorder fields.
* **Padding**: Padding **MUST** be inserted according to the target C ABI to ensure proper alignment of subsequent fields.

#### Constraints & Legality

**Recursive Definition**
A record cannot contain itself directly as a field (infinite size), but may contain pointers to itself.

$$
\frac{\text{field } f : R \text{ inside } R}{\text{Error: Infinite Size}}
$$

**Diagnostic Table**
| Code         | Severity | Condition                                      |
| :----------- | :------- | :--------------------------------------------- |
| `E-NAM-1305` | Error    | Access to private or non-existent field.       |
| `E-DEC-2421` | Error    | Recursive type definition without indirection. |
| `E-DEC-2422` | Error    | Duplicate field name in record declaration.    |

-----

#### 4.5.4 Enums

#### Definition

**Formal Definition**
An **Enum Type** is a nominal sum type $E$ defined by a unique declaration $D_E$. It consists of a set of named variants $V = \{v_1, \dots, v_n\}$. Each variant $v_i$ may optionally carry a payload $P_i$.

**Prose Definition**
Enums represent a value that can be one of several distinct forms (variants). They are "tagged unions".

#### Syntax & Declaration

**Grammar**

```ebnf
enum_decl ::= [ visibility ] "enum" identifier [ generic_params ]
              [ "<:" trait_implementations ]
              "{" variant_list "}"
              [ "where" "{" predicate "}" ]

variant_list ::= variant ( "," variant )* ","?
variant      ::= identifier [ payload ] [ "=" integer_constant ]
payload      ::= "(" type_list ")" | "{" field_list "}"
```

**Type Invariants**

Enums may declare a **type invariant** using the `where` clause. The invariant predicate constrains all valid instances of the enum type, and the compiler statically verifies that every constructor preserves the invariant.

Within the predicate, the **enum name** serves as the binding variable. The predicate may use the method-call syntax `~>` to invoke pure methods on the enum value.

**Example**

```cursive
enum Tree<T> {
    Leaf(T),
    Node { left: ^Tree<T>, right: ^Tree<T>, height: i32 }
} where { Tree~>is_balanced() }
```

In this example, `Tree` binds to the enum instance being constrained. The invariant ensures that every `Tree` value satisfies the `is_balanced()` predicate.

**Well-Formedness (WF-Type-Invariant)**

$$
\frac{
  \Gamma, E : E \vdash P : \text{bool} \quad \text{pure}(E\texttt{\textasciitilde>}P)
}{
  \Gamma \vdash \textbf{enum } E\ \{\ \ldots\ \}\ \textbf{where}\ \{\ P\ \} \text{ wf}
}
$$

**Invariant Preservation**

For any constructor that produces a value of enum type $E$ with invariant $P$:

$$
\frac{
  \Gamma \vdash e : E \quad \text{invariant}(E) = P
}{
  \Gamma \vdash P[E \mapsto e]
}
$$

The compiler must statically verify that the predicate holds for every constructed variant.

See ¬ß7.4 for complete refinement type semantics and predicate binding rules.

#### Static Semantics

**Discriminant Values**

  * Each variant has an associated integer discriminant.
  * **Explicit**: If `= N` is provided, $N$ **MUST** be a compile-time constant integer.
  * **Implicit**: If omitted, the value is $0$ (for the first variant) or $Previous + 1$.
  * **Uniqueness**: Discriminant values MUST be unique within the enum. Duplicate values trigger `E-DEC-2423`.

**Pattern Matching**
Accessing the payload of an enum **MUST** be performed via pattern matching (¬ß8.4). Direct field access is not supported.

#### Memory & Layout

**Representation**
An enum value consists of:

1.  **Discriminant (Tag)**: An integer identifying the active variant.
      * Default size: Smallest integer type that fits all discriminant values.
      * Overridable via `[[repr(Type)]]` (e.g., `[[repr(u8)]]`).
2.  **Payload Union**: Storage sufficient to hold the largest variant payload.
      * Size: $\max(\{\text{sizeof}(P_i)\})$.
      * Alignment: $\max(\{\text{alignof}(P_i)\})$.

**Total Size**: `sizeof(Tag) + sizeof(Payload) + Padding`.

#### Constraints & Legality

**Diagnostic Table**
| Code         | Severity | Condition                             |
| :----------- | :------- | :------------------------------------ |
| `E-DEC-2423` | Error    | Duplicate discriminant value in enum. |
| `E-DEC-2424` | Error    | Enum variant payload syntax error.    |

#### Examples

**Valid**

```cursive
enum Shape {
    Circle { radius: f64 },
    Rectangle(f64, f64),
    Point = 100
}
```

#### 4.5.5 Type Aliases

#### Definition

**Formal Definition**
A **Type Alias** declares a new identifier $A$ that is semantically equivalent to an existing type $T$.

$$
\Gamma \vdash A \equiv T
$$

#### Syntax & Declaration

**Grammar**

```ebnf
type_alias ::= [ visibility ] "type" identifier [ generic_params ] "=" type ";"
```

#### Static Semantics

**Transparency**
Type aliases are **transparent**. The compiler **MUST** resolve the alias to its underlying type for all semantic checks (subtyping, overload resolution). $A$ and $T$ are interchangeable.

**Recursion Constraint**
A type alias **MUST NOT** refer to itself, directly or indirectly, in a way that creates an infinite expansion.

* `type Node = (i32, Node);` -\> **Error** `E-DEC-2420`.
* `type List = (i32, Ptr<List>);` -\> **Valid** (Recursion broken by pointer).

#### Constraints & Legality

**Diagnostic Table**
| Code         | Severity | Condition                                           |
| :----------- | :------- | :-------------------------------------------------- |
| `E-DEC-2420` | Error    | Recursive type alias detected (infinite expansion). |

#### Examples

**Valid**

```cursive
type ID = u64;
let x: ID = 100; // Equivalent to u64
```

### 4.6 Union Types

#### Definition

**Formal Definition**
A **Union Type** $U$ is a structural sum type defined by a finite set of component types $\Sigma = \{T_1, \dots, T_n\}$.
The value domain of $U$ is the tagged disjoint union of the value domains of its components:

$$
\mathcal{V}(U) = \{ (k, v) \mid 1 \le k \le n, v \in \mathcal{V}(T_k) \}
$$

Where $k$ is the **Discriminant** (Tag) identifying the active type.

**Prose Definition**
A Union Type represents a value that is one of several distinct types. Unlike Enums, Unions are **structural**: they are defined by the set of types they allow, not by a name. Cursive Unions are **Tagged**: the runtime always stores a discriminant to identify which type is currently active, ensuring type safety.

*Note: Cursive Unions correspond to "Sum Types" or "Tagged Unions". They are distinct from C-style `union`s, which are untagged and unsafe.*

#### Syntax & Declaration

**Grammar**

```ebnf
union_type ::= type ( "|" type )+
```

**Desugaring (Set Semantics)**
The compiler **MUST** canonicalize the component list of a union type as a set:

1.  **Flattening:** Nested unions are flattened. `A | (B | C)` $\rightarrow$ `A | B | C`.
2.  **Equivalence Collapsing:** If a component type $T_i$ is equivalent to $T_j$ (per ¬ß15.2), they are treated as a single component. `i32 | i32` $\rightarrow$ `i32`.
3.  **Unit Simplification:** The unit type `()` is a valid component. `T | ()` is the idiomatic "Option" type.

#### Static Semantics

**Typing Rules**
A value $e$ of type $T$ can be implicitly coerced to the union $U$ if $T$ is an element of the component set of $U$.

$$
\frac{T \in \text{Components}(U)}{\Gamma \vdash T <: U}
\tag{T-Coerce-Union-Inj}
$$

**Equivalence**
Two union types are equivalent if their canonical component sets are equivalent.

$$
\frac{\forall t \in A, \exists u \in B : t \equiv u \quad \land \quad \forall u \in B, \exists t \in A : u \equiv t}{\Gamma \vdash A \equiv B}
$$

**Subtyping**
Union $A$ is a subtype of Union $B$ if the component set of $A$ is a subset of the component set of $B$.

$$
\frac{\text{Components}(A) \subseteq \text{Components}(B)}{\Gamma \vdash A <: B}
$$

#### Memory & Layout

**Representation**
A Union value is stored as a tuple `(Tag, Payload)`.

1.  **Tag (Discriminant):** An integer identifying the active component type.
      * **Mapping:** The mapping from Type to Tag ID is **Implementation-Defined Behavior (IDB)**. It **MUST** be deterministic for a given compilation unit.
      * **Size:** The implementation **SHOULD** choose the smallest integer type capable of representing all variants (e.g., `u8` for \< 256 types).
2.  **Payload:** Storage for the active value.
      * **Size:** $\max_{T \in U}(\text{sizeof}(T))$.
      * **Alignment:** $\max_{T \in U}(\text{alignof}(T))$.

**Optimization (Niches)**
Implementations **MUST** apply **Niche Optimization** (see ¬ß19.5.1) to Union types where possible.

  * *Mandate:* For the specific case of `Ptr<T>@Valid | ()`, the implementation **MUST** represent `()` using the null pointer address (`0x0`). The size of `Ptr<T> | ()` **MUST** be equal to `sizeof(Ptr<T>)`.

#### Constraints & Legality

**Negative Constraints**

1.  **Direct Access:** A program **MUST NOT** attempt to access the payload of a union directly or reinterpret it as a specific type without checking the tag. Access **MUST** be performed via Pattern Matching (¬ß27) or safe casts.
2.  **Recursion:** A Union Type **MUST NOT** contain itself directly as a component (e.g., `type U = i32 | U`). Recursive definitions must be broken by a pointer or nominal type.

**Diagnostic Table**
| Code         | Severity | Condition                                          |
| :----------- | :------- | :------------------------------------------------- |
| `E-TYP-1805` | Error    | Direct access of union payload (must use `match`). |
| `E-DEC-2420` | Error    | Recursive type definition (infinite size).         |

#### Examples

**Valid**

```cursive
// 'x' holds an i32. Tag = 0 (impl-defined).
let x: i32 | bool = 10;

// 'y' holds a bool. Tag = 1.
let y: i32 | bool = true;

// 'z' holds a 'None' (unit).
// Optimized to 0x0 if Niche Opt applies to 'string'.
let z: string | () = (); 
```

**Invalid**

```cursive
let x: i32 | bool = 10;

// Error E-TYP-1805: Cannot assume 'x' is i32.
// let i = x + 1; 

// Correct usage:
match x {
    val: i32 => val + 1,
    _ => 0
}
```

### 4.7 Range Types {Source: Draft 2 ¬ß18.7}

  <u>Definition</u>
    Structural record types produced by range expressions (`..`).
  
  <u>Syntax & Declaration</u>
    Implementations MUST provide generic records with **public fields**:
    *   `start`, `end`: `Range`, `RangeInclusive`.
    *   `start`: `RangeFrom`.
    *   `end`: `RangeTo`, `RangeToInclusive`.
    *   (None): `RangeFull`.
    Desugaring of `..` expressions MUST map strictly to these types/fields.
  
  <u>Constraints & Legality</u>
    *   **Copy**: Range types MUST implement `Copy` if and only if `T` implements `Copy`.
  

### 4.8 Modal Types {Source: Draft 2 ¬ß19, ¬ß23.3}

  <u>Definition</u>
    Nominal types with compile-time states (`Type@State`) and state transitions. Two type forms:
    *   State-specific types (`M@S`): Zero-overhead, tag-free at runtime (state known statically)
    *   General modal type (`M`): Tagged union holding any state (state determined at runtime)

  <u>Syntax & Declaration</u>
    *   **Declaration**: `modal Name { @State { fields... } { methods... } ... }`.
    *   **Payload Visibility**: Fields defined within a `@State` block are implicitly `protected` (accessible only to the modal type's implementation).
    *   **Transition Signature**: `transition name(...) -> @TargetState` (declared in source state block).
    *   **Transition Impl**: `transition Type::name(self: SourceState, ...) -> TargetState { ... }`.
    *   At least one state required; duplicate state names forbidden (E-TYP-1911).

  <u>Memory & Layout</u>
    *   **State-Specific Type (`M@S`)**: Layout equivalent to record with state payload fields (zero size if empty payload).
    *   **General Modal Type (`M`)**: Tagged union (enum-like) containing:
        - Discriminant tag (identifies active state)
        - Union of all state payloads
    *   **Niche Optimization** (STRONGLY RECOMMENDED):
        - Implementations SHOULD elide separate discriminant if states distinguishable by payload bit-patterns
    *   **MANDATE** (Normative):
        - Implementations MUST apply niche optimization when any state payload contains invalid bit patterns
        - **Example**: `Ptr<T>` has `@Null` (0x0) and `@Valid` (non-zero). The general `Ptr<T>` type MUST have same size/alignment as raw pointer (one machine word), NOT size of pointer + discriminant.
        - This requirement ensures zero-cost abstraction for nullable pointers

  <u>Static Semantics</u>
    *   **Incomparability**: `T@A` is NOT compatible with `T@B` (different states are distinct types).
    *   **Widening/Coercion**: `T@State` implicitly coerces to `T` (general type).
    *   **Transition Desugaring**: 
        - Transition keyword MUST be used (not `procedure`)
        - Receiver type determined by enclosing state block
        - Return type MUST be target state type
        - Signature: `(self: SourceState, params...) -> TargetState`

  <u>Dynamic Semantics</u>
    *   **Pattern Matching**:
        - **General Type (`M`)**: Runtime dispatch on discriminant/niche; match MUST be exhaustive (E-TYP-1920)
        - **Specific Type (`M@S`)**: Irrefutable payload destructuring (state statically known)
  
  <u>Examples</u>
    Provide complete modal type example showing states, transitions, and pattern matching.
  

### 4.9 String Types {Source: Draft 2 ¬ß20}

  <u>Definition</u>
    Built-in modal type: `string@Managed` (owned) and `string@View` (slice).

  <u>Constraints & Legality</u>
    *   UTF-8 guaranteed.
    *   **Indexing**: Direct indexing (`s[i]`) on any string type is forbidden (`E-TYP-1902`).
    *   **Slicing**: 
        - Indices interpreted as **byte offsets**.
        - Boundaries MUST fall on valid UTF-8 character starts; failure triggers panic (`E-TYP-1901`).
    *   `string@Managed` MUST NOT implement `Copy` (ownership) or `Clone` (requires capability).

  <u>Memory & Layout</u>
    *   **Representation**: `string@View` is a fat pointer `(ptr: *u8, len: usize)`.
    *   **Storage**: Not null-terminated. content MUST be valid UTF-8.
  

### 4.10 Pointer Types {Source: Draft 2 ¬ß21}

  <u>Definition</u>
    *   **Safe**: `Ptr<T>@Valid`, `@Null`, `@Expired`.
    *   **Raw**: `*imm T`, `*mut T` (Unsafe).

  <u>Constraints & Legality</u>
    Dereferencing `@Null`/`@Expired` is compile-time error.

  <u>Memory & Layout</u>
    *   **Size**: Matches target platform word size (`usize`).
    *   **Alignment**: Matches target platform word alignment.
  

### 4.11 Function Types & Procedures {Source: Draft 2 ¬ß22, ¬ß23.2}

  <u>Syntax & Declaration</u>
    **Procedures**: `procedure name(params): ret [[contract]] <body>`
    
    **Body Forms** (three variants MUST be supported):
    *   **Block body**: `{ statements }` - Standard implementation
    *   **Expression body**: `= expression;` - Pure function shorthand
    *   **Extern declaration**: `;` - No body (FFI import from external library)
    *   **Function Types**:

```ebnf
function_type ::= "(" [ param_type_list ] ")" "->" type
param_type_list ::= param_type ("," param_type)*
param_type ::= [ "move" ] type
```
        A function type‚Äôs identity includes:
        - The full ordered list of parameter types (including any capability types and the presence or absence of the `move` modifier on each parameter), and
        - The return type.
        Parameter names and the `[[...]]` contract sequent are **not** part of the function type.
  
  <u>Definition</u>
    *   **Sparse**: `(T) -> U` (Function pointer).
    *   **Dense**: `witness (T) -> U` (Closure).
  
  <u>Memory & Layout</u>
    *   **Sparse function pointers (`(T) -> U`)**:
       - Represented as a single machine-word code pointer.
       - FFI-safe and ABI-compatible with C function pointers (see Clause 12).
    *   **Witness closures (`witness (T) -> U`)**:
       - Represented as a dense two-word pointer `(env_ptr, code_ptr)`, where `env_ptr` points to the captured environment and `code_ptr` points to the closure‚Äôs code.
       - **Not** FFI-safe and MUST NOT appear in `extern` signatures.
    *   **Subtyping relation**:
       - For the same parameter and return types, a sparse function pointer `(T) -> U` MAY be widened to a witness closure `witness (T) -> U` by pairing the code pointer with an empty or implementation-defined environment representation.
  
  <u>Static Semantics</u>
    *   **Variance**: Parameters are Contravariant. Return type is Covariant.
    *   **Move**: `move` modifier is part of the type identity.
    *   **Parameters**: `move` indicates responsibility transfer (Consuming).
    *   **Call Site**: Arguments for `move` parameters MUST be prefixed with `move` keyword (`E-DEC-2411`).
    *   **Receiver Shorthands**:
        | Shorthand | Desugared Form           | Permission              | Meaning                                              |
        | :-------- | :----------------------- | :---------------------- | :--------------------------------------------------- |
        | `~`       | `self: const Self`       | `const`                 | **Immutable**. Pure read access.                     |
        | `~        | `                        | `self: concurrent Self` | `concurrent`                                         | **Synchronized**. Shared mutation via locks/atomics. |
        | `~%`      | `self: partitioned Self` | `partitioned`           | **Disjoint**. Aliased mutation via static splitting. |
        | `~!`      | `self: unique Self`      | `unique`                | **Exclusive**. Full ownership/mutation.              |
    *   **Function type equivalence**:
        Two function types are equivalent if and only if:
        - They have the same number of parameters,
        - Each corresponding pair of parameters has equivalent types and matching presence/absence of `move`, and
        - Their return types are equivalent.
    *   **Function type subtyping**:
        Let `T = (T1, ..., Tn) -> Tret` and `U = (U1, ..., Un) -> Uret`. Then `T` is a subtype of `U` if and only if:
        - `Tret` is a subtype of `Uret` (covariant result), and
        - For every parameter index `i`, `Ui` is a subtype of `Ti` (contravariant parameters), including the treatment of `move` in the parameter position.
    *   **Pointer vs closure subtyping**:
        For the same parameter and return types, `(T) -> U` is a subtype of `witness (T) -> U`. Non-capturing procedures and closures may be used where a witness closure is expected, but not vice versa.
  

### 4.12 Static Polymorphism (Generics) {Source: Draft 2 ¬ß28.3}

  <u>Definition</u>
    Path 1. Monomorphization. Zero overhead. Polymorphism on *inputs* resolved at compile time.

  <u>Syntax & Declaration</u>
    *   **Declaration**: `<T <: Trait>` (Generic Constraints).
    *   **Instantiation**: Implicit at call site.

  <u>Static Semantics</u>
    *   **Monomorphization**: Implementations MUST generate specialized code for each concrete type combination.
    *   **Zero Overhead**: Generic calls MUST resolve to direct static calls; no vtable lookup permitted.
    *   **Resolution**: Generic parameters are invariant types within the procedure body unless bounded otherwise.

  <u>Constraints & Legality</u>
    *   **Extern**: Generic parameters are PROHIBITED in `extern` procedures.
    *   **Recursion**: Infinite monomorphization recursion (e.g., `f<T>() { f<Option<T>>() }`) MUST be detected and rejected (Implementation Limit).
  

### 4.13 Attributes {Source: Draft 2 ¬ß23.5}

  <u>Syntax & Declaration</u>
    `[[ attribute_spec ("," attribute_spec)* ]]`
    
    **Attribute Spec**: `name [ "(" argument_list ")" ]`
    **Argument List**: Comma-separated list of:
    *   `literal` (Value)
    *   `identifier` (Flag)
    *   `identifier ":" literal` (Key-Value Pair)

  <u>Definition</u>
    **Normative Attribute Registry**:
    *   `[[attestation(...)]]`: Unsafe justification (¬ß1.4).
    *   `[[repr(C)]]`: Layout control (¬ß12.3).
    *   `[[link_name("...")]]`: FFI symbol naming (¬ß12.1).
    *   `[[unwind(...)]]`: FFI panic handling (¬ß12.1).
    *   `[[deprecated("...")]]`: Warn on usage (¬ß1.6).
    *   `[[verify(...)]]`: Contract mode selection (¬ß7.3).

  <u>Constraints & Legality</u>
    *   **Validation**: Unknown attributes trigger `E-DEC-2451`.
    *   **Targeting**: Attributes must match the target declaration type (e.g., `[[repr(C)]]` on `record`/`enum` only).
  

### 4.14 Global Bindings {Source: Draft 2 ¬ß23.1, ¬ß14}

  <u>Definition</u>
    Module-level variable declarations with static storage duration.

  <u>Syntax & Declaration</u>
    *   `[visibility] static let name: type = expr`
    *   `[visibility] static var name: type = expr`

  <u>Constraints & Legality</u>
    *   **Initialization**: 
        - **Static Init**: Expressions evaluable at compile-time (constants) are baked into the data section.
        - **Dynamic Init**: Expressions requiring runtime execution are permitted but **MUST** adhere to the **Acyclic Eager Subgraph** rule defined in ¬ß5.5 (Initialization).
    *   **Safety**: Accessing `static var` (mutable global) is `unsafe` unless synchronized.



---

## Clause 5: Modules and Resolution
### 5.1 Compilation Units {Source: Draft 2 ¬ß8.3, ¬ß10.1}

  <u>Definition</u>
    A collection of source files constituting a single module ("Folder-as-Module").
    Each compilation unit defines exactly one module. Empty modules (only whitespace/comments) are valid.
  
  <u>Syntax & Declaration</u>
    **Top-Level Items** - Only these declaration kinds permitted at module scope:
    *   `import` declaration
    *   `use` declaration
    *   `variable` declaration (`static let`, `static var`)
    *   `procedure` declaration
    *   `type` declaration (`record`, `enum`, `modal`, `type`)
    *   `trait` declaration
    
    **Forbidden**: Control-flow constructs (`if`, `loop`) and expression statements MUST NOT appear at top level.
  
  <u>Constraints & Legality</u>
    *   **Visibility Default**: Top-level items without explicit visibility modifier default to `internal`.
    *   **Uniqueness**: Each identifier MUST be unique within module scope (unified namespace).
  

### 5.2 Project Manifest {Source: Draft 2 ¬ß11}

  <u>Definition</u>
    `Cursive.toml` structure.
  
  <u>Constraints & Legality</u>
    Required tables: `[project]`, `[language]`, `[paths]`, `[[assembly]]`. Missing manifest is `E-MOD-1101`.
  
  <u>Syntax & Declaration</u>
    *   `[project]`: MUST declare `name` (identifier) and `version` (SemVer). Missing keys trigger `E-MOD-1107`.
    *   `[language]`: MUST declare a `version` compatible with the compiler‚Äôs supported MAJOR; incompatible entries trigger `E-MOD-1109`.
    *   `[paths]`: MUST contain at least one key/value pair. Values are normalized, relative paths; absence or invalid entries trigger `E-MOD-1102`.
    *   `[[assembly]]`: Each entry MUST provide `name`, `root` (key from `[paths]`), and `path`. Duplicate `name` emits `E-MOD-1108`; unknown `root` emits `E-MOD-1103`.
  
  <u>Static Semantics</u>
    *   The manifest judgment `‚ä¢ M : WF` holds only if `[project]`, `[language]`, `[paths]`, and every `[[assembly]]` satisfy their formation rules.
    *   Assemblies inherit visibility from the referenced `root`; unresolved tables render the entire manifest ill-formed.
  
  <u>Examples</u>
  ```toml
  [project]
  name = "acme.cli"
  version = "1.2.3"

  [language]
  version = "1.2.0"

  [paths]
  core = "src"
  vendor = "deps/vendor"

  [[assembly]]
  name = "core"
  root = "core"
  path = "."
  ```

### 5.3 Module Discovery & Paths {Source: Draft 2 ¬ß11.2, ¬ß11.4}

  <u>Definition</u>
    *   **Derivation**: Project root-relative directory path.
    *   **Separator Replacement**: OS separators MUST be replaced by `::`.
    *   **Folder-as-Module**: Directory contains the module; files contribute to the namespace.
  
  <u>Constraints & Legality</u>
    Case-sensitivity collisions (`E-MOD-1104`). Reserved keywords in paths (`E-MOD-1105`).
  

### 5.4 Names, Imports, and Resolution {Source: Draft 2 ¬ß12, ¬ß13}

  <u>Definition</u>
    Modifiers: `public`, `internal` (default), `private`, `protected`.
    Unified namespace per scope.
    
    **Scope Context Formal Structure**:
    *   Scope context $\Gamma$ is an ordered list of mappings: $\Gamma = [S_{local}, S_{proc}, S_{module}, S_{universe}]$
    *   Each scope $S$ maps identifiers to entities (terms, types, modules)
    *   Resolution proceeds from innermost (local) to outermost (universe)
  
  <u>Syntax & Declaration</u>
    *   `import_decl ::= "import" <module_path>`
    *   `use_decl ::= "use" <module_path> ["as" <identifier>]`
    *   `module_path ::= <identifier> ("::" <identifier>)*`
  
  <u>Static Semantics</u>
    *   **Import**: `import path` (Assembly dependency).
    *   **Use**: `use path::item` (Scope alias).
    *   **Re-export**: `public use`.
    *   **Protected**: Accessible only within the defining type and `trait` implementations for that type **within the same assembly**. MUST NOT be used on top-level items.
    *   **Resolution**: Lexical lookup (innermost to outermost).
    *   **Universe Scope**: The resolution chain MUST terminate in the implicit "Universe" scope, which contains all primitive types (`i32`, `bool`), core literals (`true`, `false`), and the `cursive.*` namespace.
    *   **Shadowing**: Explicit `shadow` keyword required (`E-NAM-1303`).
    *   **Unqualified Lookup**: Scope stack is searched from innermost to outermost (`Œì ‚ä¢ x ‚áí entity`). Failure emits `E-NAM-1301`.
    *   **Qualified Lookup**: Prefix module resolves first, then the member; visibility enforced per Chapter 12. Missing prefix emits `E-NAM-1304`; inaccessible members emit `E-NAM-1305`.
  
  <u>Constraints & Legality</u>
    *   **Unified Namespace**: Terms (variables, procedures) and Types (records, enums) share a single namespace. Declaring a type and a term with the same name in the same scope is forbidden (`E-NAM-1302`).
    *   **Shadowing**: 
        - **Strict Mode**: Explicit `shadow` keyword required to shadow (`E-NAM-1303`). Using `shadow` when NO binding is shadowed is an error (`E-NAM-1306`).
        - **Permissive Mode**: Implicit shadowing triggers warning (`W-NAM-1303`).
  
  <u>Examples</u>
  ```cursive
  import core::io
  use io::File as shadow File

  shadow File = io::File // explicit keyword required to redeclare
  ```
  

### 5.5 Initialization {Source: Draft 2 ¬ß14}

  <u>Definition</u>
    *   **Two-Stage Process**: (1) Static (compile-time constants), (2) Dynamic (runtime execution).
    *   **Edge Classification**:
        *   **Value-Level Edge**: Dependency on a value (e.g., function call, global read).
            *   **Eager**: A Value-Level edge originating from a **module-level initializer**.
            *   **Lazy**: A Value-Level edge occurring **only** within procedure bodies (and not reachable from initializers), OR a Type-Level edge.
        *   **Type-Level Edge**: Dependency on a type signature or constant definition only (Always Lazy).
  
  <u>Dynamic Semantics</u>
    *   **Graph**: Dependency graph of modules.
    *   **Cycles**: The subgraph of **Eager (Value-Level) edges** MUST be Acyclic (`E-MOD-1401`). Lazy (Type-Level) cycles are permitted.
    *   **Execution**:
        1. **Inter-Module**: Topological sort of Eager graph.
        2. **Intra-Module**: Initializers executed in strictly sequential lexical order within the source file.
    *   **Failure**: Panic poisons module.

  <u>Capability Unavailability During Initialization</u>

Because module initialization occurs before `main()` is invoked, system capabilities (`FileSystem`, `Network`, `HeapAllocator`, etc.) are **not available** during module-level initializer execution. Module-level initializers:

*   **MUST NOT** perform heap allocation (requires `HeapAllocator`)
*   **MUST NOT** perform file I/O (requires `FileSystem`)
*   **MUST NOT** perform network operations (requires `Network`)
*   **MUST NOT** invoke any procedure requiring a capability parameter

Module-level initializers are restricted to:

*   Literal values and constant expressions
*   Pure computations on other module-level bindings (respecting initialization order)
*   Construction of types that do not require capabilities

This restriction is a direct consequence of the No Ambient Authority principle (¬ß5.6): capabilities are injected exclusively through `main()`, which has not yet been called during module initialization.

  <u>Constraints & Legality</u>

| Code         | Severity | Condition                                              |
| :----------- | :------- | :----------------------------------------------------- |
| `E-MOD-1402` | Error    | Capability-requiring operation in module initializer   |


### 5.6 Program Entry Point {Source: Draft 2 ¬ß30.1, ¬ß30.2}

  <u>Definition</u>

**No Ambient Authority Principle**

Cursive enforces the principle of **No Ambient Authority**: all procedures that produce observable external effects (I/O, networking, threading, heap allocation) **MUST** receive the required capability explicitly. There are no global functions for these operations.

This principle has a critical consequence for program structure:

1.  **Capabilities originate at `main()`**: The `Context` parameter to `main()` is the sole source of system capabilities in a Cursive program.
2.  **Capabilities must be threaded explicitly**: Any procedure requiring a capability must receive it as a parameter from its caller, forming a capability chain rooted at `main()`.
3.  **Module initialization is capability-free**: Because `main()` has not yet been invoked during module initialization (¬ß5.5), no capabilities are available. Module-level bindings cannot perform capability-requiring operations such as heap allocation.

This design ensures that:

*   All effectful operations are traceable to explicit capability grants
*   Module-level state cannot contain heap pointers (preventing dangling global pointers)
*   The program's authority is fully determined by what capabilities `main()` propagates

  <u>Syntax & Declaration</u>
    `public procedure main(ctx: Context): i32`
    **Context Record**: The `Context` record MUST define the following fields:
    *   `fs`: `witness FileSystem`
    *   `net`: `witness Network`
    *   `sys`: `System` (implements `Time`)
    *   `heap`: `witness HeapAllocator`
  
  <u>Static Semantics</u>
    *   `Context` contains `fs`, `net`, `sys`, `heap`.
    *   **Return Semantics**: `main` returns `0` for success, non-zero for failure.
  
  <u>Constraints & Legality</u>
    Global mutable state is prohibited.
    *   **Signature**: Must be `main(ctx: Context): i32` (`E-DEC-2431`).
    *   **Uniqueness**: Only one `main` permitted (`E-DEC-2430`).
  

---

## Clause 6: Traits
### 6.1 Trait Definitions {Source: Draft 2 ¬ß28.1}

  <u>Syntax & Declaration</u>
    `trait Name { ... }`.
    *   **Associated Types**: `type Name;` (Abstract) or `type Name = T;` (Concrete).
    *   **Procedures**: `abstract(...);` or `concrete(...) { ... }`.
    *   **Self**: `Self` type refers to the implementing type.

  <u>Definition</u>
    Defines a set of behaviors (procedures) and types (associated types) that a type must provide.

  <u>Static Semantics</u>
    *   **Coherence**: A type may implement a trait at most once.
    *   **Orphan Rule**: Either the Type or the Trait MUST be local to the assembly.
  

### 6.2 Implementation {Source: Draft 2 ¬ß28.2}

  <u>Static Semantics</u>
    *   **Definition-Site Only**: Trait implementation (`record T <: Trait`) MUST occur as part of the `record` or `enum` declaration. "Extension" implementations (implementing a trait for a type defined elsewhere) are PROHIBITED.
    *   **Completeness**: Type MUST implement all abstract procedures declared in the trait (`E-TRS-2903`).
    *   **Overrides**: Concrete trait methods MAY be overridden; abstract methods MUST be implemented.
    *   **Keyword**: `override` keyword required when replacing a concrete method (`E-TRS-2902`). Forbidden when implementing an abstract method (`E-TRS-2901`).
  

### 6.3 Dynamic Polymorphism (Witnesses) {Source: Draft 2 ¬ß28.4}

  <u>Definition</u>
    Path 2: Dynamic dispatch via virtual table (vtable). Enables runtime polymorphism over trait bounds.
  
  <u>Syntax & Declaration</u>
    `witness Trait` - creates trait object (fat pointer: data pointer + vtable pointer).
  
  <u>Memory & Layout</u>
    **Dense Pointer Layout**: Two-word structure containing:
    1. Data pointer: `*imm T` to concrete instance
    2. VTable pointer: `*imm VTable` to trait's virtual method table
    
    **Stable VTable Layout** (MANDATED ORDER - ABI stability requirement):
    VTable entries MUST appear in this exact order:
    1. **Size** (`usize`): Size of concrete type in bytes
    2. **Alignment** (`usize`): Alignment requirement of concrete type
    3. **Destructor** (`*imm fn`): Drop glue function pointer (may be null if no Drop)
    4. **Methods**: Function pointers for trait methods, in declaration order
    
    **Rationale**: Fixed layout enables separate compilation and FFI vtables.
  
  <u>Constraints & Legality</u>
    *   **Witness Safety**: Trait MUST be "witness-safe" (object-safe).
    *   **VTable Eligibility** - Method eligible for vtable if ALL true:
        1. Has receiver parameter (`self`)
        2. Has NO generic type parameters
        3. Does NOT return `Self` by value (except as `box Self` or `witness Self`)
        4. Does NOT use `Self` in parameter/return types except via pointer indirection
    *   **Exclusion Mechanism**: Ineligible methods MUST be marked `where Self: Sized` to exclude from vtable.
    *   **Diagnostic**: Attempting to call excluded method on witness triggers `E-TRS-2940`.
  
  <u>Static Semantics</u>
    *   **Concrete-to-Witness Coercion** (¬ß28.4.5): Value of concrete type `T` implementing witness-safe trait `Tr` MAY be implicitly coerced to `witness Tr`. Coercion MUST construct dense pointer (data + vtable) for `T`/`Tr` pair.
    *   **Dispatch**: Calls on witness perform runtime vtable lookup (one indirect call cost).
  

### 6.4 Opaque Polymorphism {Source: Draft 2 ¬ß28.5}

  <u>Definition</u>
    Path 3. Abstract return types.
  
  <u>Syntax & Declaration</u>
    `-> opaque Trait`.
  
  <u>Constraints & Legality</u>
    *   **Erasure**: Accessing members of the concrete underlying type is forbidden (`E-TRS-2910`). Only trait interface methods are visible.
  

### 6.5 Standard Traits {Source: Draft 2 Appx D.1}

  <u>Definition</u>
    Normative semantics for `Drop`, `Copy`, `Clone`, and `Iterator`.
    *   **Drop**: `procedure drop(~!)` (Required unique receiver).
    *   **Clone**: `procedure clone(~): Self` (Explicit deep copy).
    *   **Iterator**: 
        - `type Item` (Associated type).
        - `procedure next(~!): Option<Item>` (Stateful advancement).

  <u>Constraints & Legality</u>
    *   **Direct Calls**: Direct calls to `Drop::drop` are forbidden (`E-TRS-2920`).
    *   **Compiler Insertion**: The compiler automatically inserts `drop` calls for responsible bindings at scope exit.
    *   **Mutual Exclusion**: A type MUST NOT implement both `Copy` and `Drop` (`E-TRS-2921`).
    *   **Copy Fields**: `Copy` types MUST NOT contain non-`Copy` fields (`E-TRS-2922`).
    *   **Loop Protocol**: Types used in `loop ... in` MUST implement `Iterator`. The loop desugars to repeated calls to `next()`.
  

---

## Clause 7: Contracts
### 7.1 Contract Clauses {Source: Draft 2 ¬ß27.1-¬ß27.5}

  <u>Syntax & Declaration</u>
    `[[ must => will ]]`. `where` invariants.
  
  <u>Constraints & Legality</u>
    **Purity**: Expressions in contracts MUST be pure (`E-CON-2802`).
  
  <u>Static Semantics</u>
    *   **Preconditions** (`must`): Caller obligation. Failure attributed to caller.
    *   **Postconditions** (`will`): Callee obligation. Failure attributed to callee.
    *   **Invariants** (`where`): Enforced at **Boundary Points**:
        1.  Post-Construction (Constructor/Literal).
        2.  Pre-Call (Public methods).
        3.  Post-Call (Methods taking `unique`/`partitioned` self).
    *   **Type Invariants**: Desugared as postcondition conjunction: `EffectivePost(P) = Post ‚àß Inv(self)`
    *   **Loop Invariants**: MUST hold at initialization, every iteration start, and termination.
    *   **Contract Intrinsics**:
        - `@result`: Available in `will` clause and return type refinement constraints. Refers to procedure's return value. Type matches return type. Cannot be shadowed. For return type constraints (e.g., `-> i32 where { @result >= 0 }`), `@result` is the binding variable within the refinement predicate. See ¬ß7.4 for refinement type predicate binding rules.
        - `@entry(expr)`: Available in `will` clause. Evaluates `expr` at procedure entry (after param binding, before body). Expression MUST be pure, depend only on inputs, and evaluate to `Copy` or `Clone` type (`E-CON-2805`).
        - Usage of `@result` outside `will` clause or return type constraint triggers `E-CON-2806`.
    *   **Liskov Substitution**: Implementations may weaken preconditions ($P_{trait} \implies P_{impl}$) and strengthen postconditions ($Q_{impl} \implies Q_{trait}$). Violations are errors (`E-CON-2803`, `E-CON-2804`).
  

### 7.2 Verification Facts (Flow-Sensitive Typing) {Source: Draft 2 ¬ß27.7}

  <u>Definition</u>
    Virtual zero-size records of proved predicates used by the verifier.

  <u>Static Semantics</u>
    *   **Fact Dominance**: Fact $F(P, L)$ satisfies requirement at $S$ iff $L$ dominates $S$.
    *   **Fact Generation**: Control flow structures (`if`, `match`, `loop`) generate Verification Facts (¬ß27.7.1).
    *   **Type Narrowing**: If a Fact $F(P, L)$ is active for a binding `x`, the type of `x` at location $L$ is effectively refined to `typeof(x) where { P }`.
    *   **Automatic Coercion**: The compiler **MUST** automatically coerce a binding to a refined subtype if the required invariant is satisfied by the active Verification Facts.
    *   **Dynamic Injection**: In `dynamic` mode, the compiler MUST synthesize facts by inserting runtime checks (panic guards) that dominate the requirement.
    *   **Optimizer Integration**: Implementations SHOULD use facts as assumptions for optimization (e.g., dead code elimination).
  

### 7.3 Verification Modes {Source: Draft 2 ¬ß27.6}

  <u>Definition</u>
    Three verification strategies for contract clauses:
    *   `static`: Require compile-time proof
    *   `dynamic`: Insert runtime checks  
    *   `trusted`: Assume without verification (UVB)
  
  <u>Constraints & Legality</u>
    *   **static mode**: Compiler MUST discharge every `must`/`will`/`where` clause via static proof.
        - Failure to prove: `E-CON-2801` (program is ill-formed)
        - No runtime overhead (checks proven at compile time)
    *   **dynamic mode**: Compiler MUST synthesize runtime checks at procedure boundaries.
        - Checks inserted at prologue (preconditions) and epilogue (postconditions)
        - Impure predicates MUST still be rejected (same purity rules as static)
        - Runtime check failure: panic
    *   **trusted mode**: NO verification performed; compiler assumes predicates true.
        - Violations produce Unverifiable Behavior (UVB)
        - MUST be explicitly requested via `[[verify(trusted)]]` attribute
        - Shifts responsibility entirely to programmer
    *   **Hybrid Default**: If no `[[verify(mode)]]` specified:
        1. Compiler first attempts static proof
        2. If proof fails, automatically falls back to dynamic checks
        3. Provides best effort static verification with dynamic safety net
  
  <u>Dynamic Semantics</u>
    *   **Runtime Check Behavior**: Checks evaluating to `false` MUST:
        1. Trigger panic in current thread
        2. Poison the current task state
        3. Prevent further execution of verified code region
    *   **Fact Injection**: Successful runtime checks synthesize verification facts:
        - Facts are inserted into CFG at check location
        - Facts dominate all program points reachable from check
        - Enables optimizer to use contract as assumption (e.g., dead code elimination)
  
  <u>Verification & Invariants</u>
    *   Static mode provides strongest guarantees (no runtime cost)
    *   Dynamic mode provides runtime safety without proof burden
    *   Trusted mode enables interfacing with external invariants not expressible in contract language
  
  <u>Examples</u>
  ```cursive
  // Dynamic verification example
  [[verify(dynamic)]]
  procedure pop(~! stack: Stack) [[must => stack.len > 0]] {
      // Runtime check: if stack.len <= 0, panic
      // Otherwise, synthesize fact (stack.len > 0) for this scope
  }

  // Trusted verification example (UVB)
  [[verify(trusted)]]
  procedure ffi_bridge(~ ctx: Context) [[must => external_invariant_holds()]] {
      // NO checks emitted
      // Programmer guarantees external_invariant_holds() is true
  }
  ```


### 7.4 Refinement Types and Invariants {Source: Draft 2 ¬ß27.4}

#### Definition

**Formal Definition**
A **Refinement Type** is a type $T$ paired with a predicate $P$ that constrains the set of valid values. A value $v$ inhabits the refinement type $(T \text{ where } \{P\})$ if and only if $v : T$ and $P[v]$ evaluates to `true`.

**Prose Definition**
Refinement types allow programmers to express constraints on values directly in the type system. This enables static verification of invariants that would otherwise require runtime checks or documentation.

**Classification**
*   **Nominal Invariants**: Defined on `record`/`enum` declarations via a `where` clause after the declaration body.
*   **Type Alias Refinements**: Defined on type aliases via `type N = T where { P }`.
*   **Parameter Constraints**: Defined inline on procedure parameters via `x: T where { P }`.
*   **Return Constraints**: Defined inline on procedure return types via `-> T where { P }`.

#### Syntax & Declaration

**Grammar**

```ebnf
refinement_type       ::= type "where" "{" predicate "}"

type_alias_refine     ::= "type" identifier "=" type "where" "{" predicate "}"

param_with_constraint ::= identifier ":" type "where" "{" predicate "}"

return_constraint     ::= "->" type "where" "{" predicate "}"

predicate             ::= expression
```

**Predicate Binding**

Within a refinement predicate, the **binding variable** refers to the value being constrained. The identity of the binding variable is determined by the syntactic context:

| Context | Binding Variable | Example |
| :------ | :--------------- | :------ |
| Type alias `type N = T where { P }` | `N` (the declared name) | `type Positive = i32 where { Positive > 0 }` |
| Record invariant `record R { ... } where { P }` | `R` (the record name) | `record Frac { n: i32, d: i32 } where { Frac.d != 0 }` |
| Enum invariant `enum E { ... } where { P }` | `E` (the enum name) | `enum Tree { ... } where { Tree~>is_balanced() }` |
| Parameter constraint `x : T where { P }` | `x` (the parameter name) | `procedure f(x: i32 where { x > 0 })` |
| Return constraint `-> T where { P }` | `@result` (intrinsic) | `procedure abs(x: i32) -> i32 where { @result >= 0 }` |

**Shadowing Rule**

Within the predicate scope, the binding variable is bound as a **value** of the constrained type. In type alias and type invariant contexts, this shadows any type of the same name for the duration of the predicate.

**Rationale**

This design follows the principle: *if a name exists, use it; otherwise, use the standard intrinsic*. Type declarations introduce names (the declared identifier). Parameters have names. Return values use the `@result` intrinsic, consistent with procedure postconditions (¬ß7.1). The implicit `self` keyword is eliminated to avoid overloading `self` (which elsewhere refers to the method receiver) and to make bindings syntactically visible.

#### Static Semantics

**Binding Variable Resolution**

Let $\text{BindVar}(C)$ denote the binding variable for syntactic context $C$:

$$\text{BindVar}(C) = \begin{cases}
N & \text{if } C = \texttt{type } N = T \text{ where } \{P\} \\
R & \text{if } C = \texttt{record } R\ \{\ldots\} \text{ where } \{P\} \\
E & \text{if } C = \texttt{enum } E\ \{\ldots\} \text{ where } \{P\} \\
x & \text{if } C = x : T \text{ where } \{P\} \text{ (parameter)} \\
\texttt{@result} & \text{if } C = \to T \text{ where } \{P\} \text{ (return)}
\end{cases}$$

**Well-Formedness (WF-Refine-Type-Alias)**

A type alias refinement `type N = T where { P }` is well-formed when the base type is well-formed and the predicate is a valid pure expression of type `bool` under a context extended with `N : T`:

$$\frac{
    \Gamma \vdash T\ \text{wf} \quad
    \Gamma, N : T \vdash P : \texttt{bool} \quad
    \text{Pure}(P)
}{
    \Gamma \vdash (\texttt{type } N = T \text{ where } \{P\})\ \text{wf}
} \quad \text{(WF-Refine-Type-Alias)}$$

**Well-Formedness (WF-Type-Invariant)**

A type invariant `record R { ... } where { P }` or `enum E { ... } where { P }` is well-formed when the predicate is a valid pure expression of type `bool` under a context extended with the type name bound to the type:

$$\frac{
    \Gamma \vdash R\ \text{wf} \quad
    \Gamma, R : R \vdash P : \texttt{bool} \quad
    \text{Pure}(P)
}{
    \Gamma \vdash (\texttt{record } R\ \{\ldots\} \text{ where } \{P\})\ \text{wf}
} \quad \text{(WF-Type-Invariant)}$$

**Well-Formedness (WF-Param-Constraint)**

A parameter constraint `x: T where { P }` is well-formed when the base type is well-formed and the predicate is a valid pure expression of type `bool` under a context extended with `x : T`:

$$\frac{
    \Gamma \vdash T\ \text{wf} \quad
    \Gamma, x : T \vdash P : \texttt{bool} \quad
    \text{Pure}(P)
}{
    \Gamma \vdash (x : T \text{ where } \{P\})\ \text{wf}
} \quad \text{(WF-Param-Constraint)}$$

**Well-Formedness (WF-Return-Constraint)**

A return constraint `-> T where { P }` is well-formed when the return type is well-formed and the predicate is a valid pure expression of type `bool` under a context extended with `@result : T`:

$$\frac{
    \Gamma \vdash T\ \text{wf} \quad
    \Gamma, \texttt{@result} : T \vdash P : \texttt{bool} \quad
    \text{Pure}(P)
}{
    \Gamma \vdash (\to T \text{ where } \{P\})\ \text{wf}
} \quad \text{(WF-Return-Constraint)}$$

**Typing Rules**

**(T-Refine-Intro)**

A value of base type `T` has refinement type `T where { P }` when a Verification Fact (¬ß7.2) establishes that `P` holds for that value. The binding variable $v$ is substituted with the expression $e$:

$$\frac{
    \Gamma \vdash e : T \quad
    v = \text{BindVar}(C) \quad
    \Gamma \vdash F(P[e/v], L) \quad
    L \text{ dominates current location}
}{
    \Gamma \vdash e : T \text{ where } \{P\}
} \quad \text{(T-Refine-Intro)}$$

where $C$ is the syntactic context of the refinement and $P[e/v]$ denotes substitution of $e$ for $v$ in $P$.

**(T-Refine-Elim)**

A value of refinement type can always be used where the base type is expected:

$$\frac{
    \Gamma \vdash e : T \text{ where } \{P\}
}{
    \Gamma \vdash e : T
} \quad \text{(T-Refine-Elim)}$$

**Subtyping**

*   **Invariant Subtyping**: Type `T where { P }` is a subtype of `T where { Q }` if and only if the compiler can prove $P \implies Q$.
*   **Intersection**: `(T where { P }) where { Q }` is equivalent to `T where { P && Q }`.

#### Parameter and Return Constraints

**Parameter Constraint Syntax**

When a refinement type constrains a **procedure parameter**, the predicate uses the **parameter name** as the binding variable. Other in-scope parameters declared earlier in the parameter list MAY be referenced, enabling dependent constraints between parameters.

```cursive
// Single parameter constraint
procedure sqrt(x: f64 where { x >= 0.0 }) -> f64

// Dependent constraint: 'idx' references earlier parameter 'arr'
procedure get<T>(arr: [T], idx: usize where { idx < arr~>len() }) -> T

// Multiple dependent constraints
procedure copy_range<T>(
    src: [T],
    dst: ~! [T] where { dst~>len() >= src~>len() },
    start: usize where { start <= src~>len() },
    end: usize where { end >= start && end <= src~>len() }
)
```

**Method Receiver Constraints**

In methods, the receiver parameter is named `self`. Constraints on the receiver use `self` as the binding variable because `self` is the parameter name:

```cursive
record Buffer {
    data: [u8],
    capacity: usize

    // 'self' is the parameter name, so 'self' is the binding variable
    procedure push(self: ~! where { self.data~>len() < self.capacity }, byte: u8)
}
```

This is consistent with the general rule: the binding variable is the parameter name.

**Return Type Constraint Syntax**

When a refinement type constrains a **return type**, the predicate uses `@result` as the binding variable. This is consistent with postcondition syntax (¬ß7.1).

```cursive
// Return constraint using @result
procedure abs(x: i32) -> i32 where { @result >= 0 }

// Constraint referencing parameters and return value
procedure clamp(x: i32, lo: i32, hi: i32) -> i32 where {
    @result >= lo && @result <= hi
}

// Combined parameter and return constraints
procedure divide(
    a: i32,
    b: i32 where { b != 0 }
) -> i32 where { @result * b <= a && @result * b > a - b }
```

**Desugaring**

A parameter with an inline constraint is semantically equivalent to an unrefined parameter with a procedure-level precondition. A return type with an inline constraint is semantically equivalent to a postcondition. The following declarations are equivalent:

```cursive
// Inline constraint forms
procedure get<T>(arr: [T], idx: usize where { idx < arr~>len() }) -> T
procedure abs(x: i32) -> i32 where { @result >= 0 }

// Procedure where-clause forms (equivalent)
procedure get<T>(arr: [T], idx: usize) -> T
    [[ must => idx < arr~>len() ]]
procedure abs(x: i32) -> i32
    [[ will => @result >= 0 ]]
```

The inline form is preferred when the constraint concerns a single parameter or is a simple return constraint. The procedure contract clause (¬ß7.1) is preferred for multi-parameter relationships, complex postconditions, or predicates that benefit from separate formatting.

#### Type Alias Examples

```cursive
// The declared name 'Byte' is the binding variable
type Byte = usize where { Byte < 256 }

// The declared name 'Positive' is the binding variable
type Positive = i32 where { Positive > 0 }

// The declared name 'NonEmpty' is the binding variable
type NonEmpty<T> = [T] where { NonEmpty~>len() > 0 }

// Complex predicate with method calls
type ValidEmail = string where {
    ValidEmail~>contains("@") && ValidEmail~>len() <= 254
}
```

**Inline Refinement Type Expressions**

When a refinement type appears inline (not as a named type alias), it MUST be wrapped in a type alias or used as a parameter/return constraint. Standalone anonymous refinement types are not permitted because no binding variable exists.

```cursive
// INVALID: No binding variable for anonymous refinement
let x: i32 where { ??? > 0 } = 5;  // ERROR: E-TYP-1960

// VALID: Use a type alias
type Positive = i32 where { Positive > 0 }
let x: Positive = 5;

// VALID: Use as parameter constraint (parameter name is binding)
procedure f(x: i32 where { x > 0 })
```

#### Predicate Scope and Purity

The predicate `P` in a refinement type `T where { P }`:

1. MUST be a pure expression as defined in ¬ß7.1 (no side effects, no I/O, no allocation, no capability invocation).
2. MUST evaluate to type `bool`.
3. MUST use the binding variable determined by syntactic context (see Binding Variable Resolution above).
4. In type alias and type invariant contexts, the binding variable (the declared name) shadows any type of the same name within the predicate scope.
5. MAY reference other in-scope bindings, including earlier parameters in procedure signatures.
6. In return constraints, MAY reference `@result` and all procedure parameters.

#### Constraints & Legality

**Negative Constraints**

The following constraints apply to refinement types:

1. A refinement predicate MUST be a pure expression. Impure expressions (those performing I/O, allocation, mutation, or capability invocation) are forbidden.

2. A refinement predicate MUST evaluate to type `bool`. Predicates of other types are forbidden.

3. The implicit `self` keyword MUST NOT appear in refinement predicates. Use the declared name (for type aliases and invariants), the parameter name (for parameter constraints), or `@result` (for return constraints).

4. Anonymous inline refinement types (refinements not attached to a named declaration or parameter) are ill-formed. Refinement types require a binding variable, which is provided by the declaration context.

5. The `@result` intrinsic MUST NOT appear in refinement predicates outside of return type constraints. In return constraints, `@result` is the only valid binding variable.

6. Refinement predicates MUST NOT create circular type dependencies. A predicate that references a type alias containing the refinement being defined is ill-formed.

7. For `static` verification mode, if the implementation's proof system cannot decide the predicate, the program is ill-formed. The programmer MAY use `dynamic` mode as a fallback.

**Diagnostic Table**

| Code         | Severity | Condition                                                       | Detection    | Effect    |
| :----------- | :------- | :-------------------------------------------------------------- | :----------- | :-------- |
| `E-TYP-1950` | Error    | `self` used in refinement predicate (use declared name instead) | Compile-time | Rejection |
| `E-TYP-1951` | Error    | Refinement predicate is not of type `bool`                      | Compile-time | Rejection |
| `E-TYP-1952` | Error    | Circular type dependency in refinement predicate                | Compile-time | Rejection |
| `E-TYP-1960` | Error    | Anonymous inline refinement type (no binding variable)          | Compile-time | Rejection |
| `E-TYP-1961` | Error    | `@result` used outside return type constraint                   | Compile-time | Rejection |
| `E-TYP-1962` | Error    | Binding variable does not match declared name                   | Compile-time | Rejection |
| `E-CON-2801` | Error    | Static verification failed in `static` mode                     | Compile-time | Rejection |
| `E-CON-2802` | Error    | Impure expression in refinement predicate                       | Compile-time | Rejection |
| `P-TYP-1953` | Panic    | Refinement predicate evaluated to `false` at runtime            | Runtime      | Panic     |

**Example Diagnostics**

```
error[E-TYP-1950]: `self` is not valid in refinement predicates
  --> src/types.cursive:1:32
   |
 1 | type Positive = i32 where { self > 0 }
   |                             ^^^^ help: use the declared name: `Positive`
   |
   = note: refinement predicates use the declared name as the binding variable
```

```
error[E-TYP-1960]: anonymous inline refinement types are not permitted
  --> src/main.cursive:5:12
   |
 5 |     let x: i32 where { ??? > 0 } = 5;
   |            ^^^^^^^^^^^^^^^^^^^^
   |
   = note: refinement types require a binding variable from a named declaration
   = help: define a type alias: `type Positive = i32 where { Positive > 0 }`
```

#### Cross-References

| Term               | Section | Description                                                    |
| :----------------- | :------ | :------------------------------------------------------------- |
| Predicate          | ¬ß7.4    | Boolean expression constraining refinement type                |
| Binding Variable   | ¬ß7.4    | Identifier bound to constrained value in predicate             |
| Verification Fact  | ¬ß7.2    | Virtual record of proved predicates used by the verifier       |
| Verification Mode  | ¬ß7.3    | Strategy for contract verification (static/dynamic/trusted)    |
| Contract Intrinsic | ¬ß7.1    | Special identifiers in contracts (@result, @entry)             |


---

## Clause 8: Expressions & Statements
### 8.1 Fundamentals {Source: Draft 2 ¬ß24.1-¬ß24.2}

  <u>Definition</u>
    **Value Categories**:
    *   **Place Expression** (l-value): An expression representing a persistent, addressable memory location. Includes variable bindings, dereferences (`*p`), and field access (`x.f`) on places. Can be target of assignment (`=`) and address-of (`&`).
    *   **Value Expression** (r-value): An expression representing a temporary value without a persistent location. Includes literals, arithmetic results, and function return values.
    
    **Evaluation Order**: Left-to-Right.

  <u>Static Semantics</u>
    **Precedence & Associativity Table** (Highest to Lowest):
    1.  **Postfix** (Left): `()`, `[]`, `.`, `~>`, `::`
    2.  **Pipeline** (Left): `=>`
    3.  **Unary** (Right): `!`, `-`, `&`, `*`, `^`, `move`
    4.  **Power** (Right): `**`
    5.  **Multiplicative** (Left): `*`, `/`, `%`
    6.  **Additive** (Left): `+`, `-`
    7.  **Shift** (Left): `<<`, `>>`
    8.  **BitAnd** (Left): `&`
    9.  **BitXor** (Left): `^`
    10. **BitOr** (Left): `|`
    11. **Compare** (Left): `==`, `!=`, `<`, `<=`, `>`, `>=`
    12. **LogAnd** (Left): `&&`
    13. **LogOr** (Left): `||`
    14. **Assign** (Right): `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`

  <u>Constraints & Legality</u>
    *   **Bitwise NOT**: The `!` operator functions as Bitwise NOT when applied to integers (reusing the Logical NOT token).


### 8.2 Primary Expressions {Source: Draft 2 ¬ß24.3}

  <u>Syntax & Declaration</u>
    *   **Field Access**: `x.f`.
    *   **Indexing**: `x[i]`.
    *   **Method Calls**: `x~>m()` (Instance) vs `T::m()` (Static/Disambiguated).
    *   **Pipeline**: `x => f`.
    *   **Closure Literal**: `|params| body_expr` or `|params| { body_stmts }`.

  <u>Static Semantics</u>
    **Receiver Dispatch Algorithm (`~>`)**:
    1.  Search for method `m` in type `T` of receiver `x`.
    2.  If not found, search for method `m` in all Traits implemented by `T` that are visible in scope.
    3.  If ambiguous (multiple traits provide `m`), trigger `E-NAM-1305` (require disambiguation via `Trait::m(x)`).
    4.  Auto-dereference/Auto-reference `x` to match method receiver (`self`, `*self`, `&self`) is NOT performed (strict matching required).

  <u>Constraints & Legality</u>
    `~>` requires receiver. `::` requires type/trait.
  

### 8.3 Operators {Source: Draft 2 ¬ß24.4}

  <u>Syntax & Declaration</u>
    *   **Logical**: `&&`, `||`, `!` (Not).
    *   **Arithmetic**: `+`, `-`, `*`, `/`, `%`, `**`.
    *   **Bitwise**: `&`, `|`, `^` (Xor), `<<`, `>>`, `!` (Not - Overloaded).
    *   **Comparison**: `==`, `!=`, `<`, `<=`.
    *   **Address**: `&` (Ref), `*` (Deref), `^` (Alloc).
    *   **Conversion**: `as` (Explicit Cast).

  <u>Static Semantics</u>
    *   **Short-Circuiting**: Logical `&&` and `||` MUST implement short-circuit evaluation (right operand not evaluated if result determined by left).
    *   **Bitwise NOT**: The `!` operator acts as Bitwise NOT when applied to integer operands.

  <u>Constraints & Legality</u>
    *   **Pointer Arithmetic**: Restricted to `unsafe`.
        - **Offset**: `Ptr + Int` / `Ptr - Int` -> `Ptr` (scaled by sizeof type).
        - **Distance**: `Ptr - Ptr` -> `isize` (returns number of elements between pointers).
    *   **Cast Safety**: 
        - Numeric casts (truncating/extending) are Safe.
        - **Truncation**: High-order bits discarded.
        - **Extension**: Zero-extension for `uN`, Sign-extension for `iN`.
        - Raw pointer casts are Safe.
        - `transmute` is a separate `unsafe` intrinsic, NOT an operator.

  <u>Dynamic Semantics</u>
    *   **Overflow**: Integer arithmetic (`+`, `-`, `*`) MUST panic on overflow in `strict` mode. Wrap-around behavior in `release` mode is IDB.
    *   **Division**: Division by zero MUST panic in all modes.
  

### 8.4 Control Flow & Patterns {Source: Draft 2 ¬ß24.5-¬ß24.8, ¬ß26}

  <u>Definition</u>
    *   **Move**: `move x` (Invalidation).
    *   **If**: `if cond { } else { }`.
    *   **Loop Forms**: 
        - **Infinite**: `loop { ... }`
        - **Conditional**: `loop condition { ... }` (Desugars to `loop { if !condition break; ... }`)
        - **Iterator**: `loop pattern in iterator { ... }` (Desugars to `match iterator.next()`)
    *   **Labels**: `'label: loop ...` (Labeled statement).
    *   **Control**: `break 'label`, `continue 'label`.
    *   **Match**: `match x { ... }`. Destructuring. Irrefutable vs Refutable.
  
  <u>Syntax & Declaration</u>
    **Patterns**: Literal, Wildcard, Tuple, Record, Enum, Modal State.

  <u>Static Semantics</u>
    **Matching Logic**:
    1.  **Literal Pattern**: Matches if `scrutinee == literal`.
    2.  **Wildcard (`_`)**: Matches any value; binds nothing.
    3.  **Identifier Pattern (`x`)**: Matches any value; binds to `x` (Move semantics unless `ref` keyword used).
    4.  **Variant Pattern (`Enum::Variant(p...)`)**: Matches if scrutinee discriminant equals Variant; recursively matches fields against `p...`.
    5.  **Range Pattern (`start..end`)**: Matches if `start <= scrutinee < end`.
    6.  **Type Pattern (`x: Type`)**: (Required for Unions) Matches if scrutinee's runtime type matches `Type`. Binds `x` with that specific type.
    7.  **Modal Pattern (`@State { ... }`)**: Matches if scrutinee's active state is `@State`. Destructures state payload.
    
    **Pattern Binding Scopes**:
    *   **Let statement**: Bindings introduced into current scope. Requires `shadow` keyword if shadowing outer binding.
    *   **Match arm**: Bindings introduced into arm-local scope. Implicitly shadow outer bindings (NO `shadow` keyword required - special case).
  
  <u>Constraints & Legality</u>
    *   **Exhaustiveness**: Exhaustiveness checking is MANDATORY for `enum`, `modal`, and `bool` scrutinees (`E-PAT-2741`).
    *   **Type Consistency**: All arms of a `match` expression MUST produce values of the equivalent type. This common type is the type of the match expression (`E-EXP-2571`).
    *   **Unreachability**: Match arms MUST NOT be unreachable. An arm is unreachable if its pattern covers only values already covered by preceding arms (`E-PAT-2751`).
    *   **Loop Break**: All `break` expressions within a single loop MUST produce values of the same type.
  
  <u>Dynamic Semantics</u>
    *   **If-Expression**: Evaluates condition; if `true` executes `then` block; otherwise executes `else` block (if present) or produces `()` (unit).
    *   **Loop**: Executes body indefinitely until `break` is encountered.
    *   **Break**: Terminates the nearest enclosing loop and yields the break-value to the loop expression's result.
    *   **Match**: Evaluates scrutinee once, then tests patterns in declaration order. Executes the arm of the *first* matching pattern.
  

### 8.5 Structured Expressions {Source: Draft 2 ¬ß24.9}

  <u>Definition</u>
    Expressions that introduce new lexical scopes or execution contexts.

  <u>Syntax & Declaration</u>
    *   **Block**: `{ stmt*; [result expr] }`.
    *   **Unsafe**: `unsafe { ... }`.
    *   **Region**: `region name { ... }` (See ¬ß3.3).
    *   **Parallel**: `parallel(bindings) { ... }` (See ¬ß9.1).
    *   **Comptime**: `comptime { ... }` (See ¬ß11.1).

  <u>Dynamic Semantics</u>
    *   **Block Evaluation**:
        1.  Executes statements sequentially.
        2.  Returns the value of the explicit `result` statement, OR the value of the final expression if unterminated.
        3.  If empty or terminated by `;`, returns `()`.
    *   **Unsafe Expression**: Evaluates body with safety checks suspended (See ¬ß3.5).
  

### 8.6 Statement Kinds {Source: Draft 2 ¬ß25}

  <u>Syntax & Declaration</u>
    *   **Declaration**: `let`/`var`.
    *   **Assignment**: `x = y` and Compound (`+=`, `-=`, `*=`, etc.).
    *   **Expression Stmt**: `expr;`.
    *   **Defer**: `defer { }`.
    *   **Control**: `return`, `result`.
    *   **Partition**: `partition ...`.
  
  <u>Definition</u>
    **Control Flow Statements**:
    *   **`return`**: Terminates the enclosing procedure and returns control to the caller. The return value (if any) becomes the procedure's result.
    *   **`result`**: Terminates the enclosing block expression and yields its value as the block's result. Used within block expressions to produce a value; does not exit the procedure.
    *   **Distinction**: `return` exits the procedure scope; `result` exits only the immediate block scope.
  
  <u>Constraints & Legality</u>
    *   `defer`: No non-local jumps.
    *   `return`: Prohibited at top-level scope.
    *   **Assignment**: Target must be mutable place.
  
  <u>Dynamic Semantics</u>
    *   **Defer**: Executed LIFO at scope exit.
    *   **Assignment Drop**: If the target `place` refers to an initialized responsible binding, the implementation MUST invoke `Drop::drop` on the existing value before or immediately after installation.
  

### 8.7 Variable Declaration {Source: Draft 2 ¬ß23.1}

  <u>Syntax & Declaration</u>
    `let pattern [: type] = expr` or `var pattern [: type] = expr`. (Type optional if inferable).
  
  <u>Static Semantics</u>
    *   **Binding Mutability**: `let` is immutable binding; `var` is mutable binding.
    *   **Orthogonality**: Binding mutability is distinct from data permission (`unique`, `const`).
    *   **Responsibility**: `=` operator establishes cleanup responsibility.
  
  <u>Constraints & Legality</u>
    *   **Irrefutability**: Patterns in `let` and `var` declarations MUST be irrefutable (`E-PAT-2711`).
  

### 8.8 Statement Termination {Source: Draft 2 ¬ß10.3}

  <u>Definition</u>
    Rules for delimiting statements via semicolons or newlines.
  
  <u>Static Semantics</u>
    *   **Terminators**: `;` or `<newline>`.
    *   **Continuation**: Newline ignored if inside delimiters `()`, `[]`, `{}` or after binary operators.

### 8.9 Special Contract Statements {Source: Draft 2 ¬ß25.7}

  <u>Syntax & Declaration</u>
    *   **Partition Statement**:
        ```ebnf
        partition_stmt ::= 
            [ "[[" "verify" "(" ("static" | "dynamic") ")" "]]" ]
            "partition" collection "by" "(" indices ")"
            [ "where" "(" proof_expr ")" ]
            block
        ```
  
  <u>Constraints & Legality</u>
    *   **Static Mode**: `proof_expr` MUST be provable by the linear verifier (`E-MEM-3012` on failure).
    *   **Dynamic Mode**: `proof_expr` (if present) and disjointness of `indices` are checked at runtime.
    *   **Consistency**: `[[verify(trusted)]]` is permitted (UVB) but requires `unsafe`.
  

---

## Clause 9: Concurrency

This clause defines the Cursive concurrency model based on **Execution Regions**‚Äîa unified abstraction for memory management and parallel task execution.

---

### 9.1 Concurrency Model Foundations

#### Definition

**The Unified Region Model**

Cursive provides a single unified model for concurrent execution based on **Execution Regions**. Regions serve as both memory arenas and execution scopes, eliminating the distinction between "data parallelism" and "stateful coordination."

**Core Principles**

1. **Structured Concurrency**: All tasks complete before their spawning region exits
2. **No Ambient Authority**: All capabilities are explicit
3. **Permission-Based Safety**: Data race freedom via the permission system
4. **Zero-Cost Abstractions**: Compile-time enforcement, minimal runtime overhead

**Formal Definition**

Let $\mathcal{R}$ denote the set of region types:
$$\mathcal{R} = \{\text{Sequential}, \text{Pool}(n), \text{Async}(r), \text{GPU}(d), \text{SIMD}, \text{Interrupt}\}$$

A concurrent operation $op$ is valid if and only if:
1. $op$ occurs within an appropriate region type
2. $op$ respects the permission constraints of captured bindings

**Thread Safety via Permissions**

Thread safety is derived from the Permission System (¬ß4.3):

| Permission | Share Safety | Transfer Safety |
|------------|--------------|-----------------|
| `const` | Safe | Safe |
| `unique` | Unsafe (exclusive) | Safe (via move) |
| `concurrent` | Safe (synchronized) | Safe |

#### Static Semantics

**Typing Rules**

**(Safe-Const):** A `const` binding is always safe to share.
$$\frac{}{\Gamma \vdash \text{ShareSafe}(x : \text{const } T)}$$

**(Safe-Unique-Transfer):** A `unique` binding may be transferred via move.
$$\frac{}{\Gamma \vdash \text{TransferSafe}(\text{move } x : \text{unique } T)}$$

**(Safe-Concurrent):** A `concurrent` binding is safe for synchronized sharing.
$$\frac{}{\Gamma \vdash \text{ShareSafe}(x : \text{concurrent } T)}$$

---

### 9.2 Execution Regions

#### Definition

An **Execution Region** combines memory lifetime with task lifetime. The region modifier determines execution semantics.

#### 9.2.1 Sequential Regions

The default region provides sequential execution and arena allocation:

```cursive
region as r {
    let data = r^make_data()
    process(data)
}  // data freed
```

Sequential regions do not support `spawn`.

#### 9.2.2 Pool Regions

Pool regions provide parallel execution via a thread pool:

```cursive
region pool(4) as r {
    let data = r^load_data()
    spawn { process_a(data) }
    spawn { process_b(data) }
}  // All tasks complete, then data freed
```

**Pool Configuration Options**

| Option | Type | Description |
|--------|------|-------------|
| `.stack_size(bytes)` | `usize` | Stack size per worker |
| `.affinity(cores)` | `[CoreId]` | CPU affinity mask |
| `.priority(p)` | `Priority` | Scheduling priority |
| `.name(s)` | `string@View` | Thread name prefix |
| `.collect_errors()` | ‚Äî | Collect vs fail-fast |

**Example:**
```cursive
region pool(2)
    .stack_size(1024 * 1024)
    .affinity([CoreId(0), CoreId(1)])
    .priority(Priority::High)
as r {
    spawn { latency_critical() }
}
```

**Priority Levels:**
```cursive
enum Priority {
    Low,       // Background
    Normal,    // Default
    High,      // Elevated
    Realtime,  // Requires RealtimeScheduling capability
}
```

#### 9.2.3 Async Regions

Async regions provide non-blocking I/O via an executor:

```cursive
region async(ctx.runtime) as r {
    let response = fetch(url).await
    spawn { cache.store(response).await }
}
```

**The Suspend Capability**

Async regions provide the `Suspend` capability authorizing suspension points:

```cursive
trait Suspend {
    procedure suspend<T>(~, future: Future<T>) -> T
}
```

The `await` keyword is sugar for `__suspend.suspend(future)`.

**Async Functions:**
```cursive
async procedure fetch_data(url: Url) -> Data {
    http_get(url).await
}
// Equivalent to:
procedure fetch_data(url: Url, witness Suspend) -> Data { ... }
```

#### 9.2.4 GPU Regions

GPU regions target compute devices:

```cursive
region gpu(ctx.gpu) as r {
    let input = r^[0f32; 1_000_000]
    input.copy_from_host(host_data)

    dispatch idx in 0..input.len() {
        output[idx] = input[idx] * 2.0
    }

    output.copy_to_host(result)
}
```

#### 9.2.5 Interrupt Regions

Interrupt regions enforce ISR-safe constraints:

```cursive
region interrupt {
    // Allowed: stack variables, atomic ops, volatile access
    // Forbidden: sync, ^, await, spawn, heap allocation
}
```

**Constraints:**

| Operation | Status | Error Code |
|-----------|--------|------------|
| Stack variables | Allowed | ‚Äî |
| `atomic match` | Allowed | ‚Äî |
| Volatile access | Allowed | ‚Äî |
| `#[interrupt_safe]` calls | Allowed | ‚Äî |
| `sync` blocks | Forbidden | E-REG-1210 |
| `^` allocation | Forbidden | E-REG-1211 |
| `.await` | Forbidden | E-REG-1212 |
| `spawn` | Forbidden | E-REG-1213 |
| Heap allocation | Forbidden | E-REG-1214 |

**Interrupt-Safe Functions:**
```cursive
#[interrupt_safe]
procedure acknowledge_irq(ctrl: Volatile<u32>) {
    ctrl.write(EOI_BIT)
}
```

The `#[interrupt_safe]` attribute is checked transitively.

---

### 9.3 The `spawn` Expression

#### Definition

The `spawn` keyword creates a task within a parallel region.

#### Syntax

```ebnf
spawn_expr ::= "spawn" block_expr
              | expr "." "spawn" "(" closure_expr ")"
```

#### Static Semantics

**(T-Spawn)**
$$\frac{\Gamma \vdash e : T \quad \text{InParallelRegion}(\Gamma) \quad \text{CapturesValid}(\Gamma, e)}{\Gamma \vdash \texttt{spawn } \{ e \} : \texttt{TaskHandle}<T>}$$

**Capture Rules:**
- `const` bindings: Captured by shared reference
- `unique` bindings: MUST be explicitly moved
- `concurrent` bindings: Captured by shared reference

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-REG-1201` | Error | `spawn` outside parallel region |
| `E-CON-3203` | Error | Invalid capture in spawn closure |

---

### 9.4 Mutex<T> and Synchronized Access

#### Definition

`Mutex<T>` is a modal type providing synchronized mutable access to shared data.
Access to mutex-protected data occurs **exclusively** through `sync` blocks.

#### Modal States

| State | Description |
|-------|-------------|
| `@Unlocked` | Mutex free; data inaccessible |
| `@Locked` | Mutex held; data accessible |

#### Ranked Mutexes

Mutexes may optionally have compile-time ranks for static deadlock prevention:

```cursive
// Unranked (dynamic ordering)
type DynMutex<T> = Mutex<T>

// Ranked (static deadlock prevention)
const RANK_DB: u32 = 100
const RANK_CACHE: u32 = 50
let db: Mutex<Db, RANK_DB> = ...
let cache: Mutex<Cache, RANK_CACHE> = ...
```

See ¬ß9.8.4 for lock rank rules.

---

### 9.5 Atomic<T> and Lock-Free Operations

#### Definition

`Atomic<T>` provides lock-free operations for types satisfying `AtomicCompatible`.

#### AtomicCompatible Trait

```cursive
trait AtomicCompatible {
    const SIZE: usize
    const ALIGNMENT: usize
    const LOCK_FREE: bool
}
```

**Architecture Limits:**

| Architecture | Native Size | Lock-Free Types |
|--------------|-------------|-----------------|
| 32-bit | 32 bits | bool, i8-i32, u8-u32 |
| 64-bit | 64 bits | + i64, u64, usize |
| 64-bit + CMPXCHG16B | 128 bits | + i128, u128 |

Types exceeding native size produce `W-ATM-4010` (lock-based fallback) or
`E-ATM-4005` (no fallback available).

---

### 9.6 Linear Lenses

#### Definition

A **Linear Lens** splits a `unique` resource into multiple disjoint `unique` views,
using a **linear ticket** to track reconstruction rights.

#### Core Mechanism

```cursive
// Split consumes 'data', returns views AND a linear ticket
let (left, right, ticket) = data~>split_at(500)

// Use views freely
region pool(2) as r {
    spawn { process(move left) }
    spawn { process(move right) }
}

// Reconstruct OR discard
let data = ticket~>rejoin(left, right)
// OR: ticket~>discard()
```

#### Lens Traits

```cursive
modal LensTicket<Parent, const N: usize> {
    @Valid { }
    @Consumed { }
}

trait SplitAt {
    type View
    procedure split_at(self: unique Self, index: usize)
        -> (unique Self::View, unique Self::View, linear LensTicket<Self, 2>)
}

trait Chunked {
    procedure chunks(self: unique Self, size: usize)
        -> (ChunkIter<Self::View>, linear LensTicket<Self, Dynamic>)
}

trait Strided {
    procedure stride_split(self: unique Self, stride: usize, offsets: [usize])
        -> ([unique StridedView<Self::Item>], linear LensTicket<Self, Dynamic>)
}
```

#### Ticket Operations

```cursive
impl<P, const N: usize> LensTicket<P, N> {
    transition rejoin(self: linear Self@Valid, views: ...) -> unique P
    to Self@Consumed

    transition discard(self: linear Self@Valid)
    to Self@Consumed
}
```

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-LEN-2001` | Error | Ticket not consumed |
| `E-LEN-2002` | Error | View used after rejoin |
| `E-LEN-2003` | Error | Rejoin with missing views |
| `E-LEN-2004` | Error | Ticket consumed twice |

---

### 9.7 Static Field Lenses

#### Definition

Fields of a `unique` record are implicitly lensable. Moving a field into a
parallel task creates a **static lens**‚Äîthe compiler tracks which fields are
"out" and restores the parent when all fields return.

#### Syntax

No new syntax required. Behavior emerges from structured regions:

```cursive
record Player {
    pos: Vector3,
    health: f32,
    inventory: Inventory,
}

procedure update(p: unique Player) {
    region pool(2) as r {
        spawn { physics_step(move p.pos) }
        spawn { sort_items(move p.inventory) }

        // p.health still accessible (not moved)
        p.health = 100.0
    }
    // p fully restored
    log(p.pos)  // OK
}
```

#### Partial Move Tracking

| State | Accessible Fields | Parent Accessible |
|-------|-------------------|-------------------|
| `@Whole` | All | Yes |
| `@PartiallyMoved{f1, f2}` | All except f1, f2 | No |

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-FLD-3001` | Error | Union field projection (aliased memory) |
| `E-FLD-3002` | Error | Packed record field projection |
| `E-FLD-3003` | Error | Concurrent record field split |

---

### 9.8 Sync Blocks

#### Definition

A **sync block** provides temporary `unique` access to data protected by a `Mutex`,
transforming `concurrent Mutex<T>` into `unique T`.

#### 9.8.1 Basic Syntax

```cursive
sync (binding = mutex_expr) {
    // binding has type `unique T`
}
```

#### 9.8.2 Multiple Locks

```cursive
sync (a = mutex_a, b = mutex_b) {
    transfer(a, b, amount)
}
```

#### 9.8.3 Lock Ordering Options

**Declaration Order (default):**
```cursive
sync (a = m1, b = m2) { ... }  // Acquires m1, then m2
```

**Explicit Ordering:**
```cursive
sync(ordered: a.id < b.id) (a = acc_a, b = acc_b) { ... }
```

**Address-Based Sorting:**
```cursive
sync(address_sorted) (a = m1, b = m2) { ... }  // Runtime sorts by address
```

#### 9.8.4 Lock Ranks

Ranked mutexes enable static deadlock prevention:

```cursive
const RANK_DB: u32 = 100
const RANK_CACHE: u32 = 50

let db: Mutex<Db, RANK_DB> = ...
let cache: Mutex<Cache, RANK_CACHE> = ...

// Valid: higher rank first
sync (d = db) {
    sync (c = cache) { ... }  // OK: 50 < 100
}

// Invalid: rank violation
sync (c = cache) {
    sync (d = db) { ... }  // ERROR E-SYN-3010
}
```

**Rules:**
1. Can only acquire locks with rank **lower** than currently held
2. Same-rank locks must be acquired together, not nested

#### 9.8.5 Try-Sync

```cursive
if sync? (map = shared) {
    map.insert(key, value)
} else {
    handle_contention()
}

if sync?(timeout: 100.ms) (map = shared) { ... }
if sync?(spin: 1000) (map = shared) { ... }
```

#### 9.8.6 Condition Variables

```cursive
sync (queue = mutex, wait cond) {
    cond~>wait_while(|| queue.is_empty())
    let item = queue.pop()
}

sync (queue = mutex, notify cond) {
    queue.push(item)
    cond~>notify_one()
}
```

**Permission Flow During Wait:**
1. Before wait: `unique` permission held
2. During wait: Permission suspended, lock released
3. After wait: Lock re-acquired, permission restored

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-SYN-3004` | Error | Nested sync on same mutex |
| `W-SYN-3003` | Warning | Inconsistent lock ordering |
| `E-SYN-3010` | Error | Lock rank violation |
| `E-SYN-3011` | Error | Same-rank nested sync |

---

### 9.9 Atomic Matching

#### Definition

**Atomic matching** combines pattern matching with compare-and-swap, expressing
lock-free state machines declaratively.

#### Syntax

```cursive
atomic match status {
    @Idle => set @Running { started: now() },
    @Running { started } => { log("Running since {started}") },
    @Error { code } => set @Idle,
}
```

#### Compiled Form

Transforms to CAS loop:
```cursive
loop {
    let current = status.load(Acquire)
    match current {
        @Idle => {
            if status.cas(current, @Running{...}, AcqRel).is_ok() { break }
        }
        ...
    }
}
```

#### Memory Ordering

```cursive
atomic(acquire_release) match counter { n => set n + 1 }
```

| Ordering | Load | Store | CAS |
|----------|------|-------|-----|
| `relaxed` | Relaxed | Relaxed | Relaxed |
| `acquire` | Acquire | Relaxed | Acquire |
| `release` | Relaxed | Release | Release |
| `acquire_release` | Acquire | Release | AcqRel |
| `sequential` (default) | SeqCst | SeqCst | SeqCst |

#### Control Flow

**Read-only arms:** May use any control flow.
**Arms with `set`:** Early exit forbidden. Use `then` for post-CAS logic:

```cursive
atomic match status {
    @Idle => set @Running then { return true },
    _ => return false
}
```

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-ATM-4001` | Error | Non-exhaustive atomic match |
| `E-ATM-4006` | Error | Early exit from `set` arm |
| `W-ATM-4003` | Warning | Side effects in `set` expression |

---

### 9.10 Dispatch

#### Definition

**Dispatch** is a high-level parallel iteration primitive.

#### Syntax

```cursive
region pool(8) as r {
    dispatch elem in data {
        elem.process()
    }
}
```

#### Variants

**Indexed:**
```cursive
dispatch (i, elem) in data.enumerate() {
    output[i] = transform(elem)
}
```

**Reduction:**
```cursive
let sum = dispatch elem in data reduce(0, |acc, x| acc + x)
```

**Filter:**
```cursive
let valid = dispatch elem in data filter(|e| e.is_valid())
```

#### Constraints

| Code | Severity | Condition |
|------|----------|-----------|
| `E-DSP-6001` | Error | `dispatch` outside parallel region |
| `E-DSP-6002` | Error | Cross-iteration dependency |

---

### 9.11 Select

#### Definition

**Select** waits on multiple concurrent events.

#### Async Select

```cursive
region async(runtime) as r {
    select {
        val = t1.join() => handle(val),
        _ = timeout(5.seconds) => handle_timeout(),
    }
}
```

#### Blocking Select

```cursive
select_blocking {
    msg = chan_a.recv_blocking() => handle_a(msg),
    msg = chan_b.recv_blocking() => handle_b(msg),
}
```

#### Biased Select

```cursive
select_biased {
    urgent = high_priority.recv() => ...,
    normal = regular.recv() => ...,
}
```

#### Default Arm

```cursive
select {
    msg = channel.recv() => handle(msg),
    default => no_message(),
}
```

---

### 9.12 Using Declarations

#### Definition

**Using** creates lexically-scoped aliases for capabilities.

#### Syntax

```cursive
using <operator> = <expr> { <block> }
```

#### Examples

```cursive
procedure build_tree(r: witness Region) -> Tree {
    using ^ = r {
        let node = ^Node {
            left: ^Node { value: 1 },
            right: ^Node { value: 2 },
        }
        result node
    }
}
```

---

### 9.13 Memory Model

Cursive provides a **Sequential Consistency for Data-Race-Free programs (SC-DRF)** memory model.

#### 9.13.1 Happens-Before Relationships

| Operation A | Operation B | A happens-before B |
|-------------|-------------|-------------------|
| `sync` block exit | `sync` block entry (same mutex) | Yes |
| `x.store(_, Release)` | `x.load(Acquire)` (same location) | Yes |
| `spawn` expression | Spawned task begins | Yes |
| Task ends | Region exit (structured concurrency) | Yes |
| Region entry | All spawned tasks begin | Yes |
| All tasks end | Region exit | Yes |

#### 9.13.2 Data Race Freedom Guarantee

**Guarantee:** A well-formed Cursive program **cannot have data races** because the permission system prevents unsynchronized concurrent access to shared mutable state.

Specifically:
*   `unique` permission ‚Üí must be moved to share (transfer of ownership)
*   `concurrent` permission ‚Üí requires `~|` methods (verified synchronized)
*   `const` permission ‚Üí immutable (read-only)
*   Linear Lenses ‚Üí disjoint unique views (no overlap)

---

### 9.14 Diagnostics Summary

| Code | Severity | Description |
|------|----------|-------------|
| `E-REG-1201` | Error | `spawn` outside parallel region |
| `E-REG-1205` | Error | `^` with no named region |
| `E-REG-1210` | Error | `sync` in interrupt region |
| `E-REG-1211` | Error | `^` in interrupt region |
| `E-REG-1212` | Error | `await` in interrupt region |
| `E-REG-1213` | Error | `spawn` in interrupt region |
| `E-REG-1214` | Error | Heap allocation in interrupt |
| `E-REG-1215` | Error | Non-interrupt-safe call |
| `E-LEN-2001` | Error | Ticket not consumed |
| `E-LEN-2002` | Error | View used after rejoin |
| `E-LEN-2003` | Error | Rejoin with missing views |
| `E-LEN-2004` | Error | Ticket consumed twice |
| `E-FLD-3001` | Error | Union field projection |
| `E-FLD-3002` | Error | Packed record projection |
| `E-FLD-3003` | Error | Concurrent record split |
| `E-SYN-3004` | Error | Nested sync same mutex |
| `W-SYN-3003` | Warning | Inconsistent lock order |
| `E-SYN-3010` | Error | Lock rank violation |
| `E-SYN-3011` | Error | Same-rank nested sync |
| `E-ATM-4001` | Error | Non-exhaustive atomic match |
| `E-ATM-4006` | Error | Early exit from `set` arm |
| `W-ATM-4003` | Warning | Side effects in `set` |
| `E-DSP-6001` | Error | `dispatch` outside parallel region |
| `E-DSP-6002` | Error | Cross-iteration dependency |
| `E-CON-3203` | Error | Invalid capture in spawn |
| `E-ASY-5001` | Error | `await` outside async context |

---

## Clause 10TMP: The Capability System

The `Mutex<T>` type provides exclusive access to protected data through a locking protocol. It is **compiler-provided** and automatically concurrent-safe.

```cursive
modal Mutex<T> {
    @Unlocked {}
    @Locked {}
    @Poisoned {}

    @Unlocked {
        // Block until lock acquired, transition to Locked
        transition lock(~|) -> Mutex<T>@Locked

        // Attempt to acquire lock without blocking
        transition try_lock(~|) -> Mutex<T>@Locked | Mutex<T>@Unlocked
    }

    @Locked {
        // Read access to protected data
        procedure get(~) -> const T

        // Write access to protected data
        procedure get_mut(~!) -> unique T

        // Release the lock, transition back to Unlocked
        transition unlock(self: unique Mutex<T>@Locked) -> Mutex<T>@Unlocked
    }

    @Poisoned {
        // Recover from a poisoned mutex (thread panicked while holding lock)
        transition recover(self: unique Mutex<T>@Poisoned) -> T
    }
}
```

  *   **Poisoning** (`E-CON-3213`): If a thread panics while holding a `Mutex<T>@Locked`, the mutex transitions to `@Poisoned`. Subsequent `lock()` calls MUST handle the `@Poisoned` state.
  *   **RAII Pattern**: The `@Locked` state acts as a guard; dropping a `Mutex<T>@Locked` automatically invokes `unlock()`.

#### 9.2.2 `RwLock<T>` ‚Äî Reader-Writer Lock

The `RwLock<T>` type allows multiple concurrent readers OR a single exclusive writer.

```cursive
modal RwLock<T> {
    @Unlocked {}
    @ReadLocked { reader_count: usize }
    @WriteLocked {}

    @Unlocked {
        // Acquire shared read access (multiple readers allowed)
        transition read_lock(~|) -> RwLock<T>@ReadLocked

        // Acquire exclusive write access
        transition write_lock(~|) -> RwLock<T>@WriteLocked
    }

    @ReadLocked {
        // Read access to protected data
        procedure get(~) -> const T

        // Release read lock
        transition read_unlock(self: unique RwLock<T>@ReadLocked) -> RwLock<T>@Unlocked | RwLock<T>@ReadLocked
    }

    @WriteLocked {
        // Write access to protected data
        procedure get_mut(~!) -> unique T

        // Release write lock
        transition write_unlock(self: unique RwLock<T>@WriteLocked) -> RwLock<T>@Unlocked
    }
}
```

  *   **Read Coalescing**: Multiple `read_lock()` calls on `@Unlocked` or `@ReadLocked` increment the reader count.
  *   **Write Exclusivity**: `write_lock()` blocks until all readers release.

#### 9.2.3 `Condvar` ‚Äî Condition Variable

The `Condvar` type enables threads to wait for a condition while releasing a held mutex.

```cursive
record Condvar {
    // Wait on condition, atomically releasing mutex and blocking
    procedure wait<T>(~|, guard: Mutex<T>@Locked) -> Mutex<T>@Locked

    // Wake one waiting thread
    procedure notify_one(~|)

    // Wake all waiting threads
    procedure notify_all(~|)
}
```

  *   **Spurious Wakeups**: `wait()` may return spuriously; callers MUST re-check the condition in a loop.
  *   **Atomic Release-Wait**: The mutex is atomically released before blocking and re-acquired before returning.

#### 9.2.4 `Channel<T>` ‚Äî Message Passing

The `Channel<T>` type provides typed message passing between concurrent contexts.

```cursive
modal Channel<T> {
    @Open {}
    @Closed {}

    @Open {
        // Send a message (may block if bounded and full)
        procedure send(~|, value: T)

        // Receive a message (blocks until available)
        transition recv(~|) -> T | Channel<T>@Closed

        // Try to receive without blocking
        procedure try_recv(~|) -> T?

        // Close the channel
        transition close(~|) -> Channel<T>@Closed
    }
}
```

  <u>Concurrency & Safety</u>
    *   **Deadlocks**: Allowed (Safe). Accessing a locked Mutex blocks the thread.
    *   **Ordering**: `lock()` and `unlock()` imply release/acquire memory barriers.

### 9.3 Atomic Intrinsics

Primitive integer types and `bool` have **compiler-provided atomic intrinsics** available via `~|` methods. These are the foundation for building concurrent-safe user types.

#### 9.3.1 Memory Ordering

```cursive
enum Ordering {
    Relaxed,   // No synchronization guarantees
    Acquire,   // Subsequent reads see writes before matching Release
    Release,   // Prior writes visible to threads with matching Acquire
    AcqRel,    // Both Acquire and Release
    SeqCst,    // Total ordering across all SeqCst operations
}
```

#### 9.3.2 Integer Atomic Operations

Available on `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`:

```cursive
// Atomic load
procedure load(~|, order: Ordering) -> Self

// Atomic store
procedure store(~|, value: Self, order: Ordering)

// Atomic swap, returns old value
procedure swap(~|, value: Self, order: Ordering) -> Self

// Atomic add, returns old value
procedure fetch_add(~|, value: Self, order: Ordering) -> Self

// Atomic subtract, returns old value
procedure fetch_sub(~|, value: Self, order: Ordering) -> Self

// Atomic bitwise AND, returns old value
procedure fetch_and(~|, value: Self, order: Ordering) -> Self

// Atomic bitwise OR, returns old value
procedure fetch_or(~|, value: Self, order: Ordering) -> Self

// Atomic bitwise XOR, returns old value
procedure fetch_xor(~|, value: Self, order: Ordering) -> Self

// Compare and exchange: if current == expected, set to desired
// Returns (old_value, success)
procedure compare_exchange(~|, expected: Self, desired: Self,
                           success: Ordering, failure: Ordering) -> (Self, bool)
```

#### 9.3.3 Boolean Atomic Operations

Available on `bool`:

```cursive
procedure load(~|, order: Ordering) -> bool
procedure store(~|, value: bool, order: Ordering)
procedure swap(~|, value: bool, order: Ordering) -> bool
```

**Example: Basic Atomic Counter**
```cursive
let counter: concurrent i64 = 0

parallel {
    fork || { counter.fetch_add(1, SeqCst) }
    fork || { counter.fetch_add(1, SeqCst) }
}
// counter == 2
```

### 9.4 Memory Model

Cursive provides a **Sequential Consistency for Data-Race-Free programs (SC-DRF)** memory model.

#### 9.4.1 Happens-Before Relationships

| Operation A | Operation B | A happens-before B |
|-------------|-------------|-------------------|
| `Mutex::unlock()` | `Mutex::lock()` (same mutex) | Yes |
| `x.store(_, Release)` | `x.load(Acquire)` (same location) | Yes |
| `fork` expression | Forked task begins | Yes |
| Task ends | `Task::join()` returns | Yes |
| `parallel` entry | All forked tasks begin | Yes |
| All tasks end | `parallel` exit | Yes |

#### 9.4.2 Data Race Freedom Guarantee

**Guarantee:** A well-formed Cursive program **cannot have data races** because the permission system prevents unsynchronized concurrent access to shared mutable state.

Specifically:
*   `unique` permission ‚Üí downgraded to `const` in parallel contexts (no mutation)
*   `concurrent` permission ‚Üí requires `~|` methods (verified synchronized)
*   `partitioned` permission ‚Üí disjoint regions (no overlap)
*   `const` permission ‚Üí immutable (read-only)

### 9.5 Thread Safety Rules

  <u>Constraints & Legality</u>
    *   `const`: Safe to share across threads.
    *   `unique`: Safe to transfer between threads (becomes `const` in parallel).
    *   `concurrent`: Safe to share with synchronized access.
    *   `partitioned`: Safe to share when partitions are thread-local.
  

---

## Clause 10: The Capability System
### 10.1 Capability Mechanics {Source: Draft 2 ¬ß30.4‚Äì¬ß30.6}

  <u>Definition</u>
    Rules for managing authority distribution beyond the root.
  
  <u>Static Semantics</u>
    *   **Attenuation**: Capabilities must provide methods to derive restricted subsets (e.g., `fs.restrict(path)`).
    *   **Propagation**: Capabilities must be passed as explicit parameters; no ambient authority.
    *   **User-Defined**: Wrappers around system capabilities permitted.
  

### 10.2 System Capabilities {Source: Draft 2 Appx D.2; Amendment 1}

  <u>Definition</u>
    System capabilities are **Synchronized Resources**.
    *   **Traits**: `FileSystem`, `Network`, `HeapAllocator`, `Time`.
    *   **System Record**: Must provide `exit(code)` and `get_env(key)`.

  <u>Constraints & Legality</u>
    *   **Concurrent-Safety**: All System Capability traits (`FileSystem`, `Network`, `HeapAllocator`) MUST be concurrent-safe (all mutating methods use `~|` receiver).
    *   **Method Signatures**: Methods on these traits that perform side effects (IO, allocation) MUST accept `self` as **`concurrent`** (`~|`).
    *   **Const Purity**: Methods accepting `const` (`~`) MUST guarantee ZERO logical state changes to the resource (e.g., `time.now()` is const, but `file.write()` is concurrent).
  

---

## Clause 11: Metaprogramming
### 11.1 Compile-Time Execution {Source: Draft 2 ¬ß33.1, ¬ß33.6}

  <u>Definition</u>
    `comptime` blocks and procedures.
  
  <u>Constraints & Legality</u>
    Sandboxed (no runtime side effects). Resource limits (`E-MET-3402`).
    *   **Prohibitions**: `unsafe` blocks and FFI calls are STRICTLY FORBIDDEN in `comptime` context.
    *   **Caching**: Implementations **SHOULD** cache the result of `comptime` blocks and procedures annotated with the `[[cache]]` attribute.
        - **Cache Key**: Must include the AST of the block, the values of all captured identifiers, and the compiler version.
        - **Determinism**: Blocks marked `[[cache]]` MUST be purely deterministic; reliance on non-deterministic compiler state (e.g., memory addresses of AST nodes) in cached blocks is **Unspecified Behavior**.
    *   **Parameters**: Parameters to `comptime` procedures MUST be:
        - Primitive types (`iN`, `uN`, `fN`, `bool`, `char`)
        - `string` (literals)
        - `Type` (introspection handles)
        - `Expr`, `Stmt`, `Decl` (AST nodes)
        - Composites of the above.
        - **Prohibited**: Capabilities, Handles, Raw Pointers.
  
  <u>Complexity & Limits</u>
    Minimums: Recursion (256), Steps (1M), Memory (64MiB), AST Depth (1024).
  

### 11.2 Introspection {Source: Draft 2 ¬ß33.2}

  <u>Definition</u>
    `reflect_type<T>()` intrinsic returns metadata about T.

  <u>Syntax & Declaration</u>
    **Mandatory `TypeInfo` Structure**:
    *   `kind`: Enum (`Primitive`, `Record`, `Enum`, `Pointer`, etc.)
    *   `name`: Fully qualified string name.
    *   `fields`: List of `FieldInfo` (name, type, offset, attributes) [Records only].
    *   `variants`: List of `VariantInfo` (name, discriminant, payload) [Enums only].
    *   `layout`: Size and alignment.
  
  <u>Constraints & Legality</u>
    *   **Completeness**: `reflect_type<T>` MUST only be invoked on types `T` that are fully defined at the point of invocation.
    *   **Recursion**: Recursive type dependencies that prevent layout resolution during introspection MUST be diagnosed as errors.

### 11.3 Quasiquoting and Emission {Source: Draft 2 ¬ß33.3-¬ß33.5}

  <u>Definition</u>
    **The AST Model**:
    *   `Node`: Base trait for all syntax elements.
    *   `Expr`: Tagged union of expression nodes (Binary, Call, Literal, etc.).
    *   `Stmt`: Tagged union of statement nodes (Let, Return, ExprStmt, etc.).
    *   `Decl`: Tagged union of declaration nodes (Proc, Record, Enum, etc.).
    *   `Type`: Representation of resolved types.

  <u>Syntax & Declaration</u>
    *   **Quote**: `quote { ... }`.
    *   **Splice**: `$(...)`. Supports values, identifiers, ASTs.
    *   **Emit**: `cg.emit(ast)`. Injects code into module scope.
  
  <u>Static Semantics</u>
    *   **Quote Result**: `quote { ... }` evaluates to `QuotedExpr` or `QuotedBlock`.
    *   **Hygiene Algorithm** (prevents identifier capture bugs):
        - **Captured Variables**: Free variables in quote use lexical scope at `quote` definition site
        - **New Bindings**: Identifiers introduced within quote generate fresh, unique names to prevent collision with splice-site bindings
        - **Rationale**: Prevents accidental variable capture when spliced AST introduces bindings
    *   **Emission Requirement**: The `emit` operation requires the `ComptimeCodegen` capability.
        - `cg.emit(ast)` where `cg` is `witness ComptimeCodegen`.
        - This capability is provided only to `comptime` entry points.
    *   **Value Splicing**: Literals interpolated as values.
    *   **Identifier Splicing**: Strings interpolated as identifiers (`$(str_var)`). Validates identifier syntax (`E-MET-3403`).
    *   **AST Splicing**: `QuotedBlock`/`QuotedExpr` interpolated structurally.
  

---

## Clause 12: Interoperability
### 12.1 Extern Declarations {Source: Draft 2 ¬ß32.1, ¬ß32.5.2}

  <u>Syntax & Declaration</u>
    *   **Import**: `extern "ABI" procedure name(params): ret;` (No body).
    *   **Export**: `extern "ABI" procedure name(params): ret { body }`.
    *   **Attributes**: `[[link_name]]`, `[[no_mangle]]`, `[[unwind]]`.
  
  <u>Constraints & Legality</u>
    *   **Variadics**: Variadic arguments (`...`) are prohibited (`E-FFI-3304`).
    *   **Unwind Attribute Values**: `abort` (default) or `catch`.
    *   **Export Constraints**: Procedures exported to FFI (defined with a body):
        1. MUST be `public`.
        2. MUST NOT capture environment (no closures).
        3. MUST use FFI-safe types in signature.

  <u>Dynamic Semantics</u>
    **Unwind Behavior** (critical for panic safety across FFI boundary):
    
    *   `[[unwind(abort)]]` (DEFAULT):
        - If Cursive code panics while executing within extern procedure call
        - Process MUST immediately abort (no unwinding across FFI boundary)
        - Rationale: Foreign code may not be exception-safe
    
    *   `[[unwind(catch)]]`:
        - Panic is caught at FFI boundary
        - Procedure returns failure value to caller instead of unwinding
        - **REQUIREMENT**: Procedure return type MUST be capable of representing failure state
        - Examples: `T | Error` (Union), `Option<T>`, nullable pointer
        - Undefined behavior if return type cannot represent failure
    
    *   **Safety Rationale**: Prevents unwinding through foreign stack frames which may violate RAII assumptions of C/C++ code.
  
  <u>Dynamic Semantics</u>
    *   **Unwind**: `[[unwind(abort)]]` (default) terminates process on panic. `[[unwind(catch)]]` returns failure value.
    *   **Catch Requirement**: Procedures marked `[[unwind(catch)]]` MUST return a type capable of representing a failure state (undefined behavior otherwise).
  

### 12.2 FFI Safety {Source: Draft 2 ¬ß32.2, ¬ß32.4}

  <u>Definition</u>
    **FFI-Safe Catalog**:
    *   **Primitives**: Integers (`i8`..`i128`, `u8`..`u128`), Floats (`f16`..`f64`), Unit `()`.
    *   **Raw Pointers**: `*imm T`, `*mut T` (where `T` is FFI-Safe).
    *   **Function Pointers**: `extern` ABI function pointers.
    *   **Composites**: `record` and `enum` types marked `[[repr(C)]]` containing only FFI-Safe types.
    
    **ABI String Literals** (calling conventions):
    *   **Mandatory**: Implementations MUST support `"C"` (default C convention) and `"system"` (OS syscall convention: stdcall on Win32, C on Linux)
    *   **Optional**: MAY support platform-specific conventions (e.g., `"stdcall"`, `"fastcall"`)
  
  <u>Constraints & Legality</u>
    *   **UVB**: Calls are UVB, require `unsafe`.
    *   **Variadics**: `...` arguments prohibited (`E-FFI-3304`).
    *   **Types**: Only FFI-Safe types (primitives, raw ptrs, repr-C) allowed (`E-FFI-3301`).
  

### 12.3 Representation {Source: Draft 2 ¬ß32.3}

  <u>Static Semantics</u>
    *   `[[repr(C)]]`: Standard C layout.
    *   Default: Unspecified layout.
  

---

## Appendices
### Appendix A: Formal Grammar (ANTLR) {Source: Draft 2 Appx A}

  <u>Definition</u>
    Complete normative grammar for Cursive in ANTLR4 format. This grammar defines all lexical and syntactic productions required to parse valid Cursive source code.
  
  <u>Syntax & Declaration</u>
    **Grammar Structure**:
    *   **Lexer Rules**: Keywords, identifiers (XID_START/XID_Continue), literals (integer/float/string/char), operators, comments
    *   **Parser Rules**: All declarations (record, enum, modal, trait, procedure), expressions (precedence-encoded), statements, patterns
    *   **Operator Precedence**: Encoded in grammar hierarchy (14 levels from Postfix to Assignment)
    *   **Comment Nesting**: Block comments (`/* ... */`) MUST nest recursively; lexer maintains nesting counter
    *   **Maximal Munch Exception**: Sequence `>>` inside generic argument list MUST be split into two `>` tokens (context-sensitive lexing)
    
  <u>Constraints & Legality</u>
    *   Keywords are reserved context-insensitively
    *   Receiver shorthands (`~`, `~%`, `~!`) MUST appear only as first parameter in type method declarations
    *   All lexical rules MUST conform to preprocessing pipeline output (¬ß2.1)
  
  <u>Examples</u>
    Complete ANTLR4 grammar suitable for parser generators. Includes all production rules from top-level `sourceFile` to terminal tokens.

### Appendix B: Diagnostic Code Taxonomy {Source: Draft 2 Appx B}

This appendix defines the normative taxonomy for compiler diagnostics. All conforming implementations **MUST** use these codes when reporting the corresponding conditions to ensure consistent error reporting across toolchains.

#### B.1 Diagnostic Code Format

Diagnostic codes follow the format `K-CAT-FFNN`:

*   **K (Kind/Severity):**
    *   `E`: **Error**. A violation of a normative requirement. Compilation cannot proceed to codegen.
    *   `W`: **Warning**. Code is well-formed but contains potential issues (e.g., deprecated usage).
    *   `N`: **Note**. Informational message attached to an error or warning.
*   **CAT (Category):** A three-letter code identifying the language subsystem.
*   **FF (Feature Bucket):** Two digits identifying the specific feature area or chapter within the category.
*   **NN (Number):** Two digits uniquely identifying the specific condition within the bucket.

#### B.2 Feature Buckets (FF Values)

The following tables define the "Feature Bucket" (`FF`) values for each Category (`CAT`). These values generally align with the specification chapters but are grouped for diagnostic utility.

##### B.2.1 Source, Syntax, & Modules

| Category | FF   | Feature Name         | Relevant Chapters |
| :------- | :--- | :------------------- | :---------------- |
| **SRC**  | 01   | Encoding & Structure | ¬ß8.1, ¬ß8.2        |
|          | 02   | Resource Limits      | ¬ß6.5, ¬ß8.2.2      |
|          | 03   | Lexical Elements     | ¬ß9                |
| **SYN**  | 01   | Recursive Limits     | ¬ß10.2             |
|          | 02   | General Grammar      | Appx A            |
| **MOD**  | 11   | Manifest & Projects  | ¬ß11               |
|          | 12   | Imports & Visibility | ¬ß12               |
|          | 14   | Initialization       | ¬ß14               |
| **NAM**  | 13   | Scopes & Shadowing   | ¬ß13               |

##### B.2.2 Type System

| Category | FF   | Feature Name               | Relevant Chapters |
| :------- | :--- | :------------------------- | :---------------- |
| **TYP**  | 15   | Foundations                | ¬ß15               |
|          | 16   | Permissions                | ¬ß16               |
|          | 17   | Primitives                 | ¬ß17               |
|          | 18   | Composites                 | ¬ß18               |
|          | 19   | Modal Types (incl. String) | ¬ß19, ¬ß20          |
|          | 20   | Pointers                   | ¬ß21               |
|          | 23   | Function Types             | ¬ß22               |

##### B.2.3 Logic & Semantics

| Category | FF   | Feature Name     | Relevant Chapters |
| :------- | :--- | :--------------- | :---------------- |
| **DEC**  | 24   | Declarations     | ¬ß24               |
| **EXP**  | 25   | Expressions      | ¬ß25               |
| **STM**  | 26   | Statements       | ¬ß26               |
| **PAT**  | 27   | Pattern Matching | ¬ß27               |
| **CON**  | 28   | Contracts        | ¬ß28               |
|          | 32   | Concurrency      | ¬ß32               |

##### B.2.4 Systems & Metaprogramming

| Category | FF   | Feature Name        | Relevant Chapters |
| :------- | :--- | :------------------ | :---------------- |
| **TRS**  | 29   | Traits              | ¬ß29               |
| **MEM**  | 30   | Memory Model        | ¬ß30               |
|          | 31   | Object Capabilities | ¬ß31               |
| **FFI**  | 33   | FFI & ABI           | ¬ß33               |
| **MET**  | 34   | Metaprogramming     | ¬ß34               |

#### B.3 Normative Diagnostic Catalog

**IMPORTANT NOTE FOR WRITERS**: This section MUST enumerate EVERY diagnostic code from EVERY chapter's "Diagnostics Summary" section in Draft2. The catalog below is illustrative structure only.

**Requirements**:
- Each code entry MUST include: Code identifier, Severity, Description
- Codes MUST be organized by Category (SRC, SYN, MOD, NAM, TYP, DEC, EXP, STM, PAT, CON, TRS, MEM, FFI, MET)
- Writers MUST cross-reference each chapter's diagnostic summary to ensure no codes omitted
- Every diagnostic triggered in specification text must have entry here

The following tables list all diagnostic codes required by this specification, organized by their Category and Feature Bucket.

##### B.3.1 SRC (Source)

| Code         | Severity | Description                                                                  |
| :----------- | :------- | :--------------------------------------------------------------------------- |
| `E-SRC-0101` | Error    | Invalid UTF-8 byte sequence in source file.                                  |
| `E-SRC-0102` | Error    | Source file exceeds implementation-defined maximum size.                     |
| `E-SRC-0103` | Error    | UTF-8 Byte Order Mark (BOM) found after the first byte.                      |
| `E-SRC-0104` | Error    | Source contains prohibited control character or null byte.                   |
| `E-SRC-0105` | Error    | Maximum logical line count exceeded.                                         |
| `E-SRC-0106` | Error    | Maximum line length exceeded.                                                |
| `W-SRC-0101` | Warning  | Source file begins with UTF-8 BOM (should be stripped).                      |
| `E-SRC-0204` | Error    | String literal length exceeds implementation limit during compile-time eval. |
| `E-SRC-0301` | Error    | Unterminated string literal.                                                 |
| `E-SRC-0302` | Error    | Invalid escape sequence in literal.                                          |
| `E-SRC-0303` | Error    | Invalid character literal (empty, multiple chars).                           |
| `E-SRC-0304` | Error    | Malformed numeric literal.                                                   |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier.                                         |
| `E-SRC-0306` | Error    | Unterminated block comment.                                                  |
| `E-SRC-0307` | Error    | Invalid Unicode in identifier (violates UAX31).                              |
| `E-SRC-0308` | Error    | Lexically sensitive Unicode character in identifier (Strict Mode).           |
| `W-SRC-0301` | Warning  | Integer literal has leading zeros (interpreted as decimal, not octal).       |
| `W-SRC-0308` | Warning  | Lexically sensitive Unicode character in identifier (Permissive Mode).       |

##### B.3.2 SYN (Syntax)

| Code         | Severity | Description                                             |
| :----------- | :------- | :------------------------------------------------------ |
| `E-SYN-0101` | Error    | Block nesting depth exceeded implementation limit.      |
| `E-SYN-0102` | Error    | Expression nesting depth exceeded implementation limit. |
| `E-SYN-0103` | Error    | Delimiter nesting depth exceeded implementation limit.  |

##### B.3.3 MOD (Modules) & NAM (Naming)

| Code         | Severity | Description                                           |
| :----------- | :------- | :---------------------------------------------------- |
| `E-MOD-1101` | Error    | `Cursive.toml` missing or syntactically malformed.    |
| `E-MOD-1102` | Error    | Manifest `[paths]` table missing or invalid.          |
| `E-MOD-1103` | Error    | Assembly references undefined root in `[paths]`.      |
| `E-MOD-1104` | Error    | Module path collision on case-insensitive filesystem. |
| `E-MOD-1105` | Error    | Module path component is a reserved keyword.          |
| `E-MOD-1106` | Error    | Module path component is not a valid identifier.      |
| `E-MOD-1107` | Error    | Manifest `[project]` table missing required keys.     |
| `E-MOD-1108` | Error    | Duplicate assembly name in manifest.                  |
| `E-MOD-1109` | Error    | Incompatible language version in manifest.            |
| `E-MOD-1201` | Error    | `import` path does not resolve to external module.    |
| `E-MOD-1202` | Error    | `use` path does not resolve to accessible module.     |
| `E-MOD-1203` | Error    | Name conflict in `use` or `import as`.                |
| `E-MOD-1204` | Error    | Item in `use` path not found or not visible.          |
| `E-MOD-1205` | Error    | Attempt to `public use` a non-public item.            |
| `E-MOD-1206` | Error    | Duplicate item in `use` list.                         |
| `E-MOD-1207` | Error    | Access to `protected` item denied.                    |
| `E-MOD-1401` | Error    | Cyclic dependency in eager module initialization.     |
| `E-MOD-1402` | Error    | Capability-requiring operation in module initializer. Capabilities are unavailable during module initialization because `main()` has not yet been invoked. |
| `W-MOD-1101` | Warning  | Potential module path collision (case-sensitivity).   |
| `W-MOD-1201` | Warning  | Wildcard `use` (`*`) usage.                           |
| `E-NAM-1301` | Error    | Unresolved name.                                      |
| `E-NAM-1302` | Error    | Duplicate name declaration in same scope.             |
| `E-NAM-1303` | Error    | Shadowing existing binding without `shadow` keyword.  |
| `E-NAM-1304` | Error    | Unresolved module in qualified path.                  |
| `E-NAM-1305` | Error    | Unresolved or inaccessible member in path.            |
| `E-NAM-1306` | Error    | Unnecessary use of `shadow` keyword.                  |
| `W-NAM-1303` | Warning  | Implicit shadowing (Permissive Mode).                 |

##### B.3.4 TYP (Type System)

| Code         | Severity | Description                                             |
| :----------- | :------- | :------------------------------------------------------ |
| `E-TYP-1501` | Error    | Type mismatch or other type checking failure.           |
| `E-TYP-1505` | Error    | Missing required top-level type annotation.             |
| `E-TYP-1601` | Error    | Attempt to mutate data via a `const` reference.         |
| `E-TYP-1602` | Error    | Violation of `unique` exclusion (aliasing detected).    |
| `E-TYP-1603` | Error    | Partitioning system violation.                          |
| `W-TYP-1701` | Warning  | `f16` arithmetic may be emulated and slow.              |
| `E-TYP-1801` | Error    | Tuple or Array index out of bounds.                     |
| `E-TYP-1901` | Panic    | String slice boundary is not a valid `char` boundary.   |
| `E-TYP-1902` | Error    | Direct indexing of `string` is forbidden.               |
| `E-TYP-1910` | Error    | Modal type declares no states.                          |
| `E-TYP-1911` | Error    | Duplicate state in modal declaration.                   |
| `E-TYP-1912` | Error    | Accessing field existing only in specific modal state.  |
| `E-TYP-1913` | Error    | Accessing method existing only in specific modal state. |
| `E-TYP-1914` | Error    | Missing implementation for modal transition.            |
| `E-TYP-1915` | Error    | Transition body does not return target state type.      |
| `E-TYP-1920` | Error    | Non-exhaustive match on modal type.                     |
| `E-TYP-2001` | Error    | Dereference of `Ptr<T>@Null`.                           |
| `E-TYP-2002` | Error    | Dereference of `Ptr<T>@Expired`.                        |
| `E-TYP-2003` | Error    | Dereference of raw pointer outside `unsafe`.            |
| `E-TYP-2301` | Error    | Function argument count mismatch.                       |
| `E-TYP-2302` | Error    | Type mismatch (general).                                |
| `E-TYP-2304` | Error    | Control flow path missing `result` value.               |

##### B.3.5 DEC (Declarations), EXP (Expressions), STM (Statements)

| Code         | Severity | Description                                           |
| :----------- | :------- | :---------------------------------------------------- |
| `E-DEC-2401` | Error    | Re-assignment of immutable `let` binding.             |
| `E-DEC-2411` | Error    | `move` keyword mismatch at call site.                 |
| `E-DEC-2420` | Error    | Recursive type alias detected.                        |
| `E-DEC-2430` | Error    | Missing or duplicate `main` procedure.                |
| `E-DEC-2431` | Error    | Invalid signature for `main` (must accept `Context`). |
| `E-DEC-2450` | Error    | Malformed attribute syntax.                           |
| `E-DEC-2451` | Error    | Unknown attribute name.                               |
| `E-EXP-2501` | Error    | Expression type mismatch.                             |
| `E-EXP-2502` | Error    | `value` expression used where `place` required.       |
| `E-EXP-2511` | Error    | Identifier resolves to type/module in value context.  |
| `E-EXP-2531` | Error    | Invalid field/tuple access (not found or invisible).  |
| `E-EXP-2532` | Error    | Procedure call argument count mismatch.               |
| `E-EXP-2533` | Error    | Method call using `.` instead of `::`.                |
| `E-EXP-2535` | Error    | Invalid pipeline `=>` right-hand side.                |
| `E-EXP-2541` | Error    | Logical operator applied to non-bool.                 |
| `E-EXP-2542` | Error    | Invalid types for arithmetic/bitwise operator.        |
| `E-EXP-2545` | Error    | Address-of `&` applied to non-place.                  |
| `E-EXP-2561` | Error    | `if` without `else` in value context.                 |
| `E-EXP-2571` | Error    | Incompatible types in `match` arms.                   |
| `E-EXP-2582` | Error    | Mismatched types in `loop` `break` values.            |
| `E-EXP-2591` | Error    | Returning region-allocated value from `region` block. |
| `E-EXP-2592` | Error    | `parallel` result depends on invalidated binding.     |
| `E-STM-2631` | Error    | Assignment target is not a place.                     |
| `E-STM-2651` | Error    | `defer` block returns non-unit value.                 |
| `E-STM-2652` | Error    | Non-local control flow (return/break) in `defer`.     |
| `E-STM-2661` | Error    | `return` value type mismatch.                         |
| `E-STM-2662` | Error    | `break` used outside loop.                            |
| `E-STM-2663` | Error    | `continue` used outside loop.                         |
| `E-STM-2664` | Error    | `result` value mismatch with block type.              |
| `E-STM-2671` | Error    | `partition` proof verification failed.                |

##### B.3.6 PAT (Patterns)

| Code         | Severity | Description                                    |
| :----------- | :------- | :--------------------------------------------- |
| `E-PAT-2711` | Error    | Refutable pattern used in irrefutable context. |
| `E-PAT-2741` | Error    | Non-exhaustive pattern match.                  |
| `E-PAT-2751` | Error    | Unreachable match arm.                         |

##### B.3.7 CON (Contracts & Concurrency)

| Code         | Severity | Description                                                              |
| :----------- | :------- | :----------------------------------------------------------------------- |
| `E-CON-2801` | Error    | Static contract verification failed.                                     |
| `E-CON-2802` | Error    | Impure/Unsafe expression in contract.                                    |
| `E-CON-2803` | Error    | Liskov violation: Precondition strengthened.                             |
| `E-CON-2804` | Error    | Liskov violation: Postcondition weakened.                                |
| `E-CON-2805` | Error    | `@entry` applied to non-Copy/Clone type.                                 |
| `E-CON-2806` | Error    | `@result` used outside `will` clause.                                    |
| `E-CON-3201` | Error    | Thread Safety: Capturing `partitioned` binding in concurrency primitive. |
| `E-CON-3202` | Error    | Static Join violation: `Task` not joined in `parallel`.                  |
| `E-CON-3203` | Error    | Spawn capture violation (e.g. `unique` not moved).                       |
| `E-CON-3211` | Error    | `Task<T>@Pending` escapes `parallel` scope.                              |
| `E-CON-3212` | Warning  | Task dropped without explicit join (implicit join occurs).               |
| `E-CON-3213` | Error    | Mutex poisoned; must handle `@Poisoned` state.                           |
| `E-CON-3220` | Error    | Direct field assignment in `~\|` method. Use atomic intrinsics.          |
| `E-CON-3221` | Error    | Exclusive access (`~!`) to self in `~\|` method body.                    |
| `E-CON-3222` | Error    | Call to non-`~\|` mutating method in `~\|` method body.                  |
| `E-CON-3223` | Error    | Type is not concurrent-safe; cannot use `concurrent` permission.         |

##### B.3.8 TRS (Traits)

| Code         | Severity | Description                                            |
| :----------- | :------- | :----------------------------------------------------- |
| `E-TRS-2901` | Error    | Abstract implementation incorrectly marked `override`. |
| `E-TRS-2902` | Error    | Concrete override missing `override` keyword.          |
| `E-TRS-2903` | Error    | Missing implementation for required trait procedure.   |
| `E-TRS-2910` | Error    | Accessing non-trait member on opaque type.             |
| `E-TRS-2920` | Error    | Explicit call to `Drop::drop`.                         |
| `E-TRS-2921` | Error    | Type implements both `Copy` and `Drop`.                |
| `E-TRS-2922` | Error    | `Copy` implementation on type with non-Copy fields.    |
| `E-TRS-2940` | Error    | Calling `where Self: Sized` procedure on witness.      |

##### B.3.9 MEM (Memory & Safety)

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-MEM-3001` | Error    | Use of moved value.                         |
| `E-MEM-3005` | Error    | Explicit call to destructor.                |
| `E-MEM-3010` | Error    | Static record partition conflict.           |
| `E-MEM-3012` | Error    | Partition contract proof failed (Static).   |
| `P-MEM-3013` | Panic    | Dynamic partition check failed (Runtime).   |
| `E-MEM-3020` | Error    | Region pointer escape.                      |
| `E-MEM-3021` | Error    | Region allocation `^` outside region scope. |
| `E-MEM-3030` | Error    | Unsafe operation in safe code.              |
| `E-MEM-3031` | Error    | `transmute` size mismatch.                  |

##### B.3.10 FFI (Interoperability)

| Code         | Severity | Description                                        |
| :----------- | :------- | :------------------------------------------------- |
| `E-FFI-3301` | Error    | Non-FFI-Safe type in `extern` signature.           |
| `E-FFI-3302` | Error    | Call to `extern` procedure outside `unsafe` block. |
| `E-FFI-3303` | Error    | Invalid application of `[[repr(C)]]`.              |
| `E-FFI-3304` | Error    | Variadic arguments not supported.                  |

##### B.3.11 MET (Metaprogramming)

| Code         | Severity | Description                                       |
| :----------- | :------- | :------------------------------------------------ |
| `E-MET-3401` | Error    | `comptime` procedure called from runtime context. |
| `E-MET-3402` | Error    | Compile-time resource limit exceeded.             |
| `E-MET-3403` | Error    | Invalid identifier string in interpolation.       |
| `E-MET-3404` | Error    | Syntax error in `quote` block.                    |
| `E-MET-3405` | Error    | Emitted AST failed type checking.                 |
| `E-MET-3406` | Error    | `emit` called without capability.                 |

### Appendix C: Conformance Dossier Schema {Source: Draft 2 Appx C}

This appendix defines the normative JSON Schema for the Conformance Dossier. A conforming implementation **MUST** produce a JSON artifact matching this schema when the `dossier` emission phase is active.

#### C.1 File Format
The dossier **MUST** be a valid JSON document encoded in UTF-8.

#### C.2 Schema Definition
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Cursive Conformance Dossier",
  "type": "object",
  "required": ["metadata", "configuration", "safety_report", "implementation_limits"],
  "properties": {
    
    "metadata": {
      "type": "object",
      "description": "Information about the compiler and build environment.",
      "required": ["compiler_id", "compiler_version", "target_triple", "build_timestamp"],
      "properties": {
        "compiler_id": { "type": "string", "example": "cursive-ref-impl" },
        "compiler_version": { "type": "string", "pattern": "^\\d+\\.\\d+\\.\\d+$" },
        "target_triple": { "type": "string", "example": "x86_64-unknown-linux-gnu" },
        "build_timestamp": { "type": "string", "format": "date-time" }
      }
    },

    "configuration": {
      "type": "object",
      "description": "The conformance mode and settings used for this compilation.",
      "required": ["mode", "features"],
      "properties": {
        "mode": { 
          "type": "string", 
          "enum": ["strict", "permissive"],
          "description": "Strict mode rejects unsafe blocks without attestation." 
        },
        "features": {
          "type": "array",
          "items": { "type": "string" },
          "description": "List of enabled language feature flags."
        }
      }
    },

    "safety_report": {
      "type": "object",
      "description": "Inventory of unsafe usage and attestations.",
      "required": ["unsafe_blocks_count", "attestations", "ifndr_instances"],
      "properties": {
        "unsafe_blocks_count": { "type": "integer", "minimum": 0 },
        "attestations": {
          "type": "array",
          "description": "List of all attested unsafe blocks in the program closure.",
          "items": {
            "type": "object",
            "required": ["location", "mechanism", "auditor", "justification"],
            "properties": {
              "location": {
                "type": "object",
                "properties": {
                  "file": { "type": "string" },
                  "line": { "type": "integer" },
                  "module": { "type": "string" }
                }
              },
              "mechanism": { "type": "string", "example": "Manual Audit" },
              "auditor": { "type": "string" },
              "date": { "type": "string", "format": "date" },
              "justification": { "type": "string" },
              "proof_uri": { "type": "string", "format": "uri" }
            }
          }
        },
        "unattested_violations": {
          "type": "array",
          "description": "In Permissive mode, lists unsafe blocks missing attestation.",
          "items": {
            "type": "object",
            "properties": {
              "file": { "type": "string" },
              "line": { "type": "integer" }
            }
          }
        },
        "ifndr_instances": {
          "type": "array",
          "description": "List of all IFNDR (Ill-Formed, No Diagnostic Required) instances encountered during compilation.",
          "items": {
            "type": "object",
            "required": ["location", "category"],
            "properties": {
              "location": {
                "type": "object",
                "properties": {
                  "file": { "type": "string" },
                  "line": { "type": "integer" },
                  "module": { "type": "string" }
                }
              },
              "category": {
                "type": "string",
                "description": "IFNDR category (e.g., 'OOB in Const Eval', 'Recursion Limits')"
              },
              "description": {
                "type": "string",
                "description": "Optional additional context about the IFNDR condition"
              }
            }
          }
        }
      }
    },

    "implementation_defined_behavior": {
      "type": "object",
      "description": "Documentation of IDB choices made by this implementation.",
      "required": ["type_layout", "pointer_width"],
      "properties": {
        "pointer_width": { "type": "integer", "enum": [32, 64] },
        "type_layout": {
          "type": "object",
          "additionalProperties": {
             "type": "object",
             "properties": {
               "size": { "type": "integer" },
               "alignment": { "type": "integer" }
             }
          },
          "description": "Layout map for primitive types (i32, usize, etc)."
        }
      }
    },
    
    "implementation_limits": {
      "type": "object",
      "description": "Actual limits enforced by this implementation.",
      "required": ["max_recursion_depth", "max_identifier_length"],
      "properties": {
        "max_recursion_depth": { "type": "integer" },
        "max_identifier_length": { "type": "integer" },
        "max_source_size": { "type": "integer" }
      }
    }
  }
}
```

### Appendix D: Standard Trait Catalog {Source: Draft 2 Appx D}

This appendix provides normative definitions for foundational traits and system capability traits built into Cursive or its core library.

  <u>Definition</u>
    Normative definitions for foundational traits and system capability traits that are deeply integrated with language mechanics.
  
  <u>Syntax & Declaration</u>
    **Foundational Traits** (¬ßD.1):
    *   `Drop`: `procedure drop(~!)` - RAII cleanup, compiler-invoked only
    *   `Copy`: Marker trait for implicit bitwise duplication
    *   `Clone`: `procedure clone(~): Self` - explicit deep copy

    **Concurrent-Safety Determination** (¬ßD.1.1):
    A type is **concurrent-safe** (can be used with `concurrent` permission) based on layered verification:

    | Layer | Condition | Examples |
    |-------|-----------|----------|
    | 1. Primitives | Built-in atomic intrinsics | `i64`, `u32`, `bool` |
    | 2. Built-in Sync Types | Compiler-provided | `Mutex<T>`, `RwLock<T>`, `Condvar`, `Task<T>`, `Channel<T>` |
    | 3. Verified `~\|` Methods | All `~\|` methods pass verification rules (¬ß9.1.2) | User-defined concurrent types |
    | 4. Transitive Safety | No `~\|` methods AND all fields are concurrent-safe | Container types |
    | 5. Unsafe Escape | `~\|` method contains `unsafe` block | Lock-free structures |

    **Note**: There is NO `Sync` marker trait. Concurrent-safety is **verified** by the compiler, not declared.

    **System Capability Traits** (¬ßD.2):
    *   `FileSystem`:
        -   `open(path: string@View, mode: FileMode): FileHandle | IoError`
        -   `exists(path: string@View): bool`
        -   `restrict(path: string@View): witness FileSystem` (Attenuation)
    *   `Network`:
        -   `connect(addr: NetAddr): Stream | NetError`
        -   `bind(addr: NetAddr): Listener | NetError`
        -   `restrict_to_host(addr: NetAddr): witness Network` (Attenuation)
    *   `HeapAllocator`:
        -   `alloc<T>(count: usize): *mut T`
        -   `dealloc<T>(ptr: *mut T, count: usize)`
        -   `with_quota(size: usize): witness HeapAllocator` (Attenuation)
    *   `System`:
        -   `exit(code: i32): !`
        -   `get_env(key: string@View): string`
        -   `spawn<T>(closure: () -> T): Thread<T>@Spawned` (Concurrency Path 2)
        -   `create_mutex<T>(value: T): Mutex<T>@Unlocked` (Concurrency Path 2)
        -   `time(): Timestamp`
    *   `Time`: Monotonic time access with `now(): Timestamp` procedure
  
  <u>Constraints & Legality</u>
    *   `Drop::drop` MUST NOT be called directly by user code (E-TRS-2920)
    *   `Copy` and `Drop` are mutually exclusive on same type (E-TRS-2921)
    *   `Copy` requires all fields implement `Copy` (E-TRS-2922)
    *   `HeapAllocator::alloc` MUST panic on OOM (never return null)
    *   Variadic implementations across all trait types are prohibited
  
  <u>Static Semantics</u>
    *   Compiler automatically inserts `Drop::drop` calls at scope exit for responsible bindings
    *   `Copy` types are duplicated (not moved) on assignment/parameter passing
    *   Static invalidation applies to aliases when Drop is invoked on owner
    *   Capability traits enable attenuation patterns (e.g., `with_quota` on HeapAllocator)
  
  <u>Dynamic Semantics</u>
    *   Drop execution grants temporary exclusive (unique) access to self
    *   Drop during panic unwind: second panic causes process abort
    *   HeapAllocator failures cause panic (no null returns)
  
  <u>Examples</u>
    Complete trait signatures must be provided for: Drop, Copy, Clone, HeapAllocator, FileSystem, Network, Time, System (which implements Time and provides `exit`, `get_env`).

### Appendix E: Core Library Specification {Source: Draft 2 Appx E}

  <u>Definition</u>
    Minimal normative definitions for core types assumed to be available by the language without explicit import.
  
  <u>Syntax & Declaration</u>
    **Context Capability Record**:
    *   `Context` record structure (see ¬ß30.1, ¬ß30.2):
        - `fs: witness FileSystem`
        - `net: witness Network`
        - `sys: System` (implements Time)
        - `heap: witness HeapAllocator`

    *(Note: `Option` and `Result` are removed. Optionality is handled via Union Types e.g., `T | ()`, and failure via `T | Error`. Pointers handle nullability via `Ptr<T>@Null` states).*
  
  <u>Constraints & Legality</u>
    *   `Context` field types MUST match the capability trait witnesses defined in Appendix D
    *   Core library types (`Option`, `Result`, `Context`, primitives) MUST be available in the universe scope (no import required)
    *   `main` procedure MUST accept `Context` parameter as defined
  
  <u>Static Semantics</u>
    *   All context capabilities are passed explicitly (no ambient authority)
  


### Appendix F: Implementation Guide (Informative) {Source: Draft 2 Appx G}

**Note**: This appendix provides non-normative guidance for compiler implementers.

#### F.1 Control Flow Graph (CFG) for Verification

  <u>Static Semantics</u>
    Guidance for implementing Fact Injection (¬ß27.7, Clause 7.2) and Partitioning verification (¬ß29.4, Clause 3.4):
    *   **Dominator Trees**: Use Lengauer-Tarjan algorithm to build dominator tree
    *   **Verification Facts**: Facts are valid only if origin node strictly dominates consumption node
    *   **Loop Headers**: Synthesize entry facts for loop induction variables at loop header node
    *   **Example**: For loop `i in 0..N`, inject facts `i >= 0` and `i < N` dominating loop body
  
#### F.2 Niche Optimization for Modal Types

  <u>Memory & Layout</u>
    Strongly encouraged optimization to reduce modal type size:
    *   Use invalid bit-patterns (niches) in state payloads to encode discriminant
    *   **Example**: `Ptr<T>` uses address `0x0` for `@Null` state, non-zero for `@Valid` state
    *   **Result**: `Ptr<T>` general type occupies same space as raw pointer (64 bits, not 128)
    *   **General Algorithm**: Identify niches in payload types, map empty states to niche patterns
  
#### F.3 Canonical Formatting

  <u>Definition</u>
    Recommended formatting to satisfy syntactic stability goals (¬ß4.8, Clause 1.6):
    *   **Indentation**: 4 spaces (no tabs)
    *   **Brace Style**: 1TBS (One True Brace Style) - opening brace on same line as declaration
    *   **Import Ordering**: Alphabetically sorted
    *   **Declaration Ordering**: public declarations first, then internal, then private within each category

### Appendix G: Behavior Classification Index (Normative) {Source: Draft 2 Appx H}
**H.1 Unverifiable Behavior (UVB)**:
*   FFI Call (¬ß32.2)
*   Raw Deref (¬ß29.6.2)
*   Transmute (¬ß29.6.3)
*   Pointer Arithmetic (¬ß24.4.2)
*   Trusted Contracts (¬ß27.6.3)
*   Trusted Partitions (`[[verify(trusted)]]`)
*   Heap-in-Global Deallocation (`unsafe` only): In `unsafe` code, deallocating heap storage whose address was stored in a global binding via mechanisms outside the capability system (e.g., FFI). Cannot occur in safe code due to capability restrictions (¬ß3.3, ¬ß5.5).

**H.2 Implementation-Defined Behavior (IDB)**:
*   Type Layout (non-C)
*   Integer Overflow (Release)
*   Pointer Width
*   Resource Limits
*   Panic Abort Mechanism

### H.3 Unspecified Behavior (USB) {Source: Draft 2 Appx H.3}

The following behaviors are bounded by the language safety guarantees but are not documented or consistent between executions.

*   **Map Iteration**: Order of iteration for hash-based collections.
*   **Padding Bytes**: The values of padding bytes in non-`[[repr(C)]]` records.

### H.4 Defined Runtime Failure (Panics)

*   Integer Overflow (Checked Mode)
*   Array/Slice Bounds Check
*   **Dynamic Partition Overlap** (`[[verify(dynamic)]]`)

### Appendix H: Formal Core Semantics (Normative) {Source: Draft 2 Appx I}

This appendix defines the **Cursive Core Calculus**, a simplified formal model of the language's memory and permission system. Implementations **MUST** preserve the safety properties defined here.

#### H.1 Syntax of the Core

$$\begin{aligned} v &::= \ell \mid \text{const } \ell \mid \text{null} \\ e &::= v \mid \text{let } x = e \text{ in } e \mid x \mid x.f \mid x.f \leftarrow v \mid \text{fork}(e) \\ \tau &::= \text{const } T \mid \text{unique } T \mid \text{partitioned } T \end{aligned}$$

#### H.2 Operational Semantics (Small-Step)

State is defined as a pair $(H, e)$ where $H$ is the heap mapping locations $\ell$ to values.

**Read Rule:**

$$\frac{H(\ell) = v}{(H, \ell.f) \longrightarrow (H, v.f)}$$  
**Write Rule (Unique):**

$$\frac{H(\ell) \text{ is live}}{(H, \ell.f \leftarrow v') \longrightarrow (H[\ell.f \mapsto v'], ())}$$

#### H.3 Safety Theorems

##### Theorem 1: Progress
If $\vdash e : \tau$ and $e$ is not a value, then there exists a state $(H', e')$ such that $(H, e) \longrightarrow (H', e')$.  
Implication: A well-typed Cursive program never gets "stuck" (segfaults or undefined behavior).

##### Theorem 2: Preservation (Type Safety)
If $\vdash e : \tau$ and $(H, e) \longrightarrow (H', e')$, then $\vdash e' : \tau$.  
Implication: Operations never violate the permission rules defined in Part 4\.  

##### Theorem 3: Data Race Freedom
If $\Gamma \vdash e : \text{well-formed}$, and $e$ contains fork, no two threads can access location $\ell$ simultaneously unless both accesses are Reads.  
_Proof Sketch:_ The unique permission ($\ell$) cannot be duplicated. The const permission ($\text{const } \ell$) allows duplication but removes the Write Rule from the set of valid reductions for that value.

### Appendix I: Implementation Limits {Source: Draft 2 ¬ß6.5, Appx F}
**Minimum Guaranteed Limits**:
*   **Source Size**: 1 MiB
*   **Logical Lines**: 65,535
*   **Line Length**: 16,384 chars
*   **Nesting Depth**: 256
*   **Identifier Length**: 1,023 chars
*   **Parameters**: 255
*   **Fields**: 1,024
*   **Recursion Depth**: 256 (Comptime), Implementation-Defined (Runtime)
