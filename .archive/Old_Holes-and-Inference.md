# The Cursive Language Specification

**Part**: VIII - Holes and Inference  
**File**: 08_Holes-and-Inference.md  
**Previous**: [Contracts and Effects](07_Contracts-and-Effects.md) | **Next**: [Functions](09_Functions.md)

---

## Abstract

**Definition 8.0 (Holes and Inference System):** The Cursive holes and inference system comprises:

- The hole syntax `_?` and `@_?` for compile-time placeholders
- The constraint generation judgment `constraints(Γ;Δ;Σ ⊢ site) ⇒ S`
- The solving judgment `solve(S) = θ` producing principal substitutions
- The elaboration transformation replacing holes with solved values

This chapter specifies the formation, disambiguation, and resolution of holes across expressions, types, permissions, modal-states, and effects in Cursive. Holes are compile-time placeholders that request principal solutions derived from local constraints; there is no runtime behavior. The design follows Cursive principles (explicit over implicit, local reasoning, zero abstraction cost) and integrates with:

Notation: Function types are written with arrow syntax `(T₁, …, Tₙ) → U ! ε`.
- Part II (types, subtyping/equivalence, modals, generics),
- Part IV (permissions and moves),
- Part V (principal effects and expression typing), and
- Part VII (contracts and effect bounds).
Key innovations: principal solutions without defaulting, explicit prohibitions in required-annotation positions, and a complete solver with diagnostic precedence.

---

## 8.0 Conformance and Scope

### 8.0.1 Normative Status

This chapter is authoritative for hole syntax and inference. Implementations MUST reject any program containing an unresolved or ambiguous hole.

Holes MUST NOT weaken explicitness requirements specified elsewhere (e.g., required annotations on match result bindings, pipeline stages, and iterator bindings; see Part V §4.8.1, §4.5.9, §4.9.3).

### 8.0.2 Cross-Part Dependencies

Other chapters remain authoritative for the topics they introduce:

* **Part I (Foundations)** – Notation, metavariables, judgment forms, and inference rule format. See Part I §1.3 — Metavariables; §1.4 — Judgment Forms; §1.6 — Inference Rule Format.

* **Part II (Type System)** – Type formation, subtyping, equivalence, generics, modal types, effect polymorphism, and regions. See Part II §2.0.6 — Subtyping and Equivalence; §2.3.3 — Modal State Machines; §2.0.8.4 — Region Non-Escape.

* **Part IV (Lexical Permission System)** – Permission lattice, moves, and permission propagation. See Part IV §4.5 — Permission Propagation; §4.6 — Permission Lattice; §4.7 — Move Semantics.

* **Part V (Expressions and Operators)** – Effect composition, principal effects, and expression typing. Note: Part V retains §4.x internal numbering. See Part V §4.19.4 — Principal Effects; §4.8.1 — Match Bindings; §4.5.9 — Pipeline Stages; §4.9.3 — Iterator Bindings.

* **Part VII (Contracts and Effects)** – Contract obligations at boundaries and effect bounds. See Part VII §7.2 — Behavioral Contracts; §7.3 — Effect Clauses; §7.5 — Postconditions.

---

## 8.1 Overview and Terminology

**Definition 8.1 (Hole).** A hole is a placeholder token `_?` (or `@_?` in modal-state position) that denotes an unknown to be solved at compile time from constraints generated by the program.

Kinds of holes:

- Expression hole: `_?` or annotated `_?: T` in expression position.
- Type hole: `_?` in type position.
- Permission hole: `_?` in permission position (e.g., `let x: _? T = e`).
- Modal-state hole: `@_?` inside a modal type (e.g., `Modal@_?`).
- Effect hole: `_?` in effect position; see §8.9.

**Principal solution.** A solution is principal when it is unique up to type equivalence (Part II §2.0.6.2) and minimal with respect to the relevant lattice (types/effects/permissions/modals, as applicable). No defaulting is permitted. See Part II §2.0.6.2 — Type Equivalence.

---

## 8.2 Unified Syntax and Disambiguation

The grammar admits holes in specific syntactic categories (Appendix A gives the normative productions). See Appendix A — Grammar Reference.

```ebnf
ExprHole       ::= "_?" ( ":" Type )?
TypeHole       ::= "_?"
PermissionHole ::= "_?"              // only where a Permission is expected
PermissionHoleType ::= "_?" Type     // only where a Permission followed by a Type is expected
ModalStateHole ::= "@_?"             // only in modal type state position
EffectHole     ::= "_?"              // only in effect-set position (see §8.9)
```

Disambiguation is driven by position: the syntactic category at the site determines the hole kind. If a token `_?` could be parsed as more than one kind at the same position, the program is ill-formed.

```
[Hole-Disamb]
parse_category(site) = K is unique
------------------------------------
kind(site) = K

parse_category(site) ∈ {K₁, K₂}, K₁ ≠ K₂
------------------------------------
ERROR E4412 (ambiguous hole kind)
```

### 8.2.1 Grammar-Level Disambiguation Examples

The parser distinguishes `TypeHole` from `PermissionHoleType` (and from other hole kinds) by immediate token context/lookahead:

```cursive
// Type position, bare `_?` → TypeHole
let a: _? = 0

// Permission + Type position, `_?` immediately followed by a Type token → PermissionHoleType
let b: _? i32 = 0         // parses as PermissionHoleType, elaborates to perm⋆ i32 (see §8.7)

// Effect position → EffectHole (not a TypeHole)
let f: (i32) → i32 ! _? = |x| -> x

// Modal-state position → Modal-state hole (not a TypeHole)
let m: Modal@_? = make_modal()
```

If a site remains syntactically ambiguous after applying these rules, the program MUST be rejected with E4412.

### 8.2.2 Multiple and Nested Holes

Multiple holes MAY appear in a single expression or type. Each hole generates independent constraints and is solved separately.

```
[Multiple-Holes]
expression contains holes h₁, …, hₖ
∀i. constraints(Γ;Δ;Σ ⊢ hᵢ) ⇒ Sᵢ
∀i. solve(Sᵢ) = θᵢ is defined and principal
----------------------------------------
elaborate each hᵢ with θᵢ independently

[Multiple-Holes-Fail]
∃i. solve(Sᵢ) undefined or non-principal
----------------------------------------
ERROR E441x for hole hᵢ (by kind)
```

**Examples:**

```cursive
// Multiple holes in function type - OK
let f: (_?) → _? = |x| -> x + 1
// Both holes resolve to i32 from context

// Multiple holes in generic type - OK
let m: Map<_?, _?> = Map.new()
m.insert("key", 42)
// First hole resolves to string, second to i32

// Under-constrained multiple holes - ERROR
let g: (_?) → _? = |x| -> x
// ERROR E4411: both holes under-constrained (no expected type; no operations constrain type)

// Nested holes in permission position - OK
let v: _? Vec<i32> = Vec.new()
v.push(1)
// Permission hole resolves to mut from push operation

// Ambiguous nested holes - ERROR
let bad: _? _? = value
// ERROR E4412: ambiguous hole kind (cannot parse)
```

**Solving scope:** Constraints are collected once for the enclosing expression or declaration. Each hole is solved against the projection of that set that mentions it. Holes may be linked by unifications introduced by the surrounding code (for example, when a function’s parameter and result types relate a pair of holes).

**Elaboration order:** Implementations MAY elaborate holes in textual order (left-to-right, top-to-bottom). Order does not affect the result because solving is defined over the full constraint set and each hole’s projected constraints.

---

## 8.3 Constraint Generation

**Definition 8.2 (Constraint System).** The constraint system comprises the following forms gathered from a hole site and its context:

Ct - type equalities and subtypings; Cε - effect subset/equality; Cp - permission lattice requirements; Cm - modal reachability. Constraints are well-formed when all referenced types/effects/permissions/states are well-formed per Parts II/IV/V and Appendix A.

Let `constraints(Γ;Δ;Σ ⊢ site)` produce the set of constraints required to solve the hole at `site`, where `Γ` is the typing context, `Δ` the region stack, and `Σ` the modal-state context.

Constraint forms (complete):

```
Ct ::= τ₁ = τ₂ | τ₁ <: τ₂ | τ : Bound              // types. See Part II §2.0.6 — Subtyping
Cε ::= ε ⊆ ε' | ε = ε'                            // effects. See Part V §4.19 — Effect System
Cp ::= perm ≥ need | perm ∈ {imm, mut, own}       // permissions. See Part IV §4.6 — Permission Lattice
Cm ::= @S ∈ Reach(Modal, Uses)                    // modal reachability. See Part II §2.3.3 — Modal Types
```

Generation summary (by kind):

- Expression holes: emit Ct from expected type and surrounding operations; emit Cε from effectful subexpressions; emit Cp from mutation/receiver requirements; emit region non-escape obligations via `Δ`.
- Type holes: emit Ct from annotation context, parameter/field positions, and subtyping/equivalence.
- Permission holes: emit Cp from all use-sites reachable in the control-flow that observe the binding (writes require `mut` or `own`, moves require `own`).
- Modal-state holes: emit Cm by intersecting sets of states permitted by uses and transition preconditions.
- Effect holes: emit Cε per Part V §4.19.4 to compute the principal effect of the associated expression/type.

**Note on trivial cases:** Literals and variable references generate no constraints beyond their declared types. Compound expressions not explicitly listed in §8.3.1 compose constraints from their subexpressions per the general principles above. If/if-let expressions, loop expressions, record/enum construction, and array/tuple literals follow standard expression typing rules (Part V) with constraint composition from their constituent parts.

Auxiliary obligations:

- Region non-escape: if any candidate solution would embed a region-allocated value that outlives `Δ`, reject per Part II §2.0.8.4 and Part IV §4.13. See Part II §2.0.8.4 — Region Non-Escape; Part IV §4.13 — Region Lifetimes.
- Contract boundary consistency: for calls, unify callee signature `uses/must/will` with call-site obligations; infer holes cannot weaken declared clauses (Part VII §7.2-§7.5). See Part VII §7.2 — Behavioral Contracts; §7.5 — Postconditions.
 - Attribute and effect-gated regions: if substitution yields forbidden effects under active attributes or effect-gated branches (e.g., `[[no_panic]]`), reject with the corresponding diagnostics from Part VI. See Part VI — Attributes and Metaprogramming.

All constraints are gathered prior to solving (per expression/decl). Any insufficient context that yields an under-constrained variable is an error (§8.11).

### 8.3.1 Constraint Generation Rules (Normative)

<a id="08.3.1"></a>

The following rules specify how constraints are generated from common syntactic forms. Effect constraints always compose via union of subexpression effects and declared callee effects; permission notes summarize obligations and defer full semantics to Part IV.

```
[Constraint-Call]
Γ ⊢ f : (τ₁, …, τₙ) → τᵣ ! ε
∀i. synth(Γ, eᵢ) = σᵢ
--------------------------------------------
constraints(f(e₁,…,eₙ)) = { σᵢ <: τᵢ | i = 1..n } ∪ { result_type = τᵣ } ∪ { ε ⊆ ε_available }

[Constraint-Procedure]
Γ ⊢ recv : T
procedure m : (self: perm T, τ₁,…,τₙ) → τᵣ ! ε
∀i. synth(Γ, eᵢ) = σᵢ
--------------------------------------------
constraints(recv.m(e₁,…,eₙ)) = { σᵢ <: τᵢ } ∪ { result_type = τᵣ } ∪ { ε ⊆ ε_available } ∪ { supplied_perm(recv) ≥ perm }

[Constraint-Field]
Γ ⊢ e : R
field f : τ_f in R
--------------------------------------------
constraints(e.f) = { result_type = τ_f }

[Constraint-Tuple-Proj]
Γ ⊢ e : (τ₁, …, τₖ)
index j ∈ [1, k]
--------------------------------------------
constraints(e.j) = { result_type = τⱼ }

[Constraint-UnOp]
op : (τ_in) → τ_out
synth(Γ, e) = σ
--------------------------------------------
constraints(op e) = { σ <: τ_in, result_type = τ_out }

[Constraint-BinOp]
op : (τ_l, τ_r) → τ_out
synth(Γ, e₁) = σ₁    synth(Γ, e₂) = σ₂
--------------------------------------------
constraints(e₁ op e₂) = { σ₁ <: τ_l, σ₂ <: τ_r, result_type = τ_out }

[Constraint-Index]
synth(Γ, a) = [τ]
synth(Γ, i) = σ_i
--------------------------------------------
constraints(a[i]) = { σ_i <: usize, result_type = τ }

[Constraint-Assign]
target is lvalue of type τ_t with permission p_t
synth(Γ, rhs) = σ
--------------------------------------------
constraints(target = rhs) = { σ <: τ_t } ∪ { p_t ∈ {mut, own} }

[Constraint-Match]
synth(Γ, scrutinee) = σ
arms: (pᵢ [if gᵢ] => eᵢ)
∀i. match_constraints(σ, pᵢ) = Ctᵢ; synth(Γ, eᵢ) = σᵢ; (optional) synth(Γ, gᵢ) = bool
--------------------------------------------
constraints(match scrutinee { … }) = (⋃ᵢ Ctᵢ) ∪ { result_type = join({σᵢ}) }
```

Notes:
- Permission propagation for field/projection/index access follows Part IV §4.5; mutation adds Cp requirements.
- The `join` of branch result types is the least type consistent with all arms (see Part V typing rules for matches); ambiguity is diagnosed per Part V.

#### 8.3.1.1 Pipelines

```
[Constraint-Pipeline-Stage]
current : σ_in
stage e_s : declared type τ_s  (from required annotation)
synth(Γ, e_s) = σ_s
------------------------------------------------
constraints(stage) = { σ_s <: (σ_in) → τ_s ! ε_s, result_type = τ_s }

[Constraint-Pipeline]
e₀ => e₁ : τ₁ => e₂ : τ₂ => … => e_k : τ_k
synth(Γ, e₀) = σ₀
∀j. apply [Constraint-Pipeline-Stage] with input = σ_{j-1}
------------------------------------------------
constraints(pipeline) = \bigcup_j constraints(stage_j)
```

Notes:
- Each stage MUST have an explicit `: Type` annotation (Part V §4.5.9). Missing or mismatched annotations are diagnosed in Part V; holes in stage types are prohibited by §8.10.
- Effects accumulate by union over stages and inputs.

#### 8.3.1.2 Blocks, Labels, and Break Values

```
[Constraint-Block-Expr]
block { … result e }
synth(Γ, e) = σ
----------------------------
constraints(block) = { result_type = σ }

[Constraint-Block-Unit]
block { … }
----------------------------
constraints(block) = { result_type = () }

[Constraint-Labeled-Block]
'lbl: { body }
break sites produce values vᵢ : τᵢ
----------------------------------------
constraints('lbl: { … }) = { result_type = join({τᵢ}) }

[Constraint-Break]
break 'lbl e
synth(Γ, e) = σ
----------------------------
constraints(break) = { contributes 'lbl : σ }
```

Notes:
- The set of break values for a labeled block must have a well-defined join. If no value-producing breaks occur and there is no `result`, the block type is `()`.

#### 8.3.1.3 Closures and Captures

```
[Constraint-Closure]
closure |params| -> body
captures = {x₁,…,xₖ}
synth(Γ, body) = σ_body
effect(body) = ε_body ∪ ε_captures
----------------------------------------
constraints(closure) = { result_type = (param_types) → σ_body ! ε_total }
```

Notes:
- Effect aggregation for captures follows Part IV §4.10.3; any destructor effects of owned captures are included.
- Permission requirements on captured variables follow Part IV; region escape rules apply if the closure outlives captured regions.

#### 8.3.1.4 Ranges and Slices

```
[Constraint-Range]
range form e_l .. e_r (variants include ..=, prefix/suffix forms)
∀present endpoint e. synth(Γ, e) = σ_e
----------------------------------------
constraints(range) = { ∀e. σ_e <: index_domain }

[Constraint-Slice]
synth(Γ, a) = [τ]
range r well-typed by [Constraint-Range]
----------------------------------------
constraints(a[r]) = { result_type = [τ] }
```

Notes:
- Index domain is typically integer types accepted by the slicing operators (see Part V).

#### 8.3.1.5 Pointer Dereference

```
[Constraint-Deref-Raw]
synth(Γ, p) = *τ
----------------------------------------
constraints(*p) = { result_type = τ, effects_include(unsafe.ptr) }

[Constraint-Deref-RawMut]
synth(Γ, p) = *mut τ
----------------------------------------
constraints(*p) = { result_type = τ, effects_include(unsafe.ptr) }

[Constraint-Deref-Safe]
synth(Γ, p) = Ptr<τ>@_?
----------------------------------------
constraints(*p) = { result_type = τ }
```

Notes:
- Raw dereference requires the `unsafe.ptr` effect; safe pointers do not.

#### 8.3.1.6 Regions

```
[Constraint-Alloc-In-Region]
region r { … alloc_in<r>(v) … }
synth(Γ; Δ·r, v) = σ_v
----------------------------------------
constraints(alloc_in<r>(v)) = { result_type = own σ_v@r }

[Constraint-Region-NonEscape]
value w contains an allocation from region r
destination outlives r
----------------------------------------
constraints(use) include non-escape obligation; violation → E4014
```

Notes:
- Region obligations are enforced using the region stack Δ; any substitution yielding an escape is rejected.

#### 8.3.1.7 Helper Definitions

**supplied_perm(recv):** the strongest permission proven available for the receiver expression at the call site (Part IV §4.5 and §4.9).

**join({τᵢ}):** the least type consistent with all branch types τᵢ per Part V match typing; ambiguity is diagnosed in Part V.

---

## 8.4 Solving and Principal Solutions

**Definition 8.3 (Occurs-check).** During unification, reject any substitution of a type variable α with a type τ when α ∈ FreeVars(τ). This prevents construction of infinite types.

**Definition 8.4 (Principal Solution).** A substitution θ is principal for a constraint set S when (1) θ satisfies S and (2) for any other solution θ′ of S there exists a substitution ρ such that θ′ = ρ ∘ θ (factors through θ).

Implementations may employ Robinson's unification algorithm with occurs-check for the type component and must apply Part II §2.0.6 subtyping/equivalence laws during constraint normalization. See Part II §2.0.6 — Subtyping and Equivalence.

The solver operates per kind with a single pass that computes a principal, unique solution. Failure to find a unique principal solution is an error.

```
[Hole-Principal]
constraints(Γ;Δ;Σ ⊢ site) ⇒ S
solve(S) = θ is defined and principal
----------------------------------------
Γ;Δ;Σ ⊢ site elaborates to apply(θ)

[Hole-NoSolution]
solve(S) undefined or non-principal
----------------------------------------
ERROR E441x (by hole kind)
```

Solving sub-procedures (normative references to other Parts):

- Types: unification with occurs-check; respect subtyping/equivalence. Reject infinite types. See Part II §2.0.6 — Subtyping and Equivalence.
- Effects: compute ε⋆, the principal effect. If multiple incomparable minima exist, reject (see also E7C17 in Part VII). See Part V §4.19.4 — Principal Effects; Part VII §7.3 — Effect Clauses.
- Permissions: choose the least permission in the lattice `imm < mut < own` that satisfies all uses. No upgrades without explicit code. See Part IV §4.6 — Permission Lattice.
- Modal states: intersect reachable states from `Σ` and use-site preconditions; require a singleton result set. See Part II §2.3.3 — Modal State Machines.

Substitution and elaboration update the typed AST; substitutions do not introduce new runtime behavior.

**Definition 8.5 (Elaboration).** Elaboration is the replacement of holes by the components of the computed substitution θ within the typed AST at the corresponding sites.

### 8.4.1 Algorithm (Implementation-Ready)

```
solve_hole(Γ, Δ, Σ, site):
  S := constraints(Γ;Δ;Σ ⊢ site)

  // type part
  θt, ok_t := unify_types(S.Ct)        // occurs-check; deals with <: via constraints normalization
  if not ok_t: return error(E4412)

  // effect part
  ε⋆, ok_e := principal_effect(S.Cε)   // Part V §4.19.4 lattice minimization
  if not ok_e: return error(E7C17)

  // permission part
  p⋆, ok_p := least_permission(S.Cp)   // lattice imm < mut < own
  if not ok_p: return error(E4413)

  // modal part
  Sset := reachable_states(S.Cm)
  if |Sset| ≠ 1: return error(E4414)
  S⋆ := only_element(Sset)

  θ := {types = θt, effects = ε⋆, perm = p⋆, state = S⋆}
  return elaborate(site, θ)
```

Normalization obligations:

- Subtyping constraints are converted to equalities where variance allows; otherwise, they are preserved and checked post-unification.
- Effect constraints are minimized under idempotent, commutative, associative union (see Part V §4.19.4 and Appendix A.9); forbidden effects (negation) are handled by entailment checks at call-sites per Part VII.
- Permission constraints choose the minimum satisfying the set of uses; absence of writes/moves yields `imm`.
- Modal reachability is computed on the declared finite graph of the modal type (Part II §2.3.3). It MUST terminate.

### 8.4.2 Effect Polymorphism and Bounds

Effect holes that appear under effect quantification MUST respect bounds and calling context coverage.

Rules (normative):

```
[Eff-Hole-Bounded]
Type contains ∀ε where ε ⊆ B
hole !_? occurs within the quantified type
constraints ⇒ Cε with ε̂ ⊆ B
------------------------------------
solve(Cε) = ε⋆ and ε⋆ ⊆ B, else ERROR E7C17

[Eff-Hole-Call-Cover]
caller provides ε_call
ε⋆ ⊆ ε_call
------------------------------------
call permitted; else ERROR E4004
```

### 8.4.3 Diagnostic Precedence

When multiple conditions apply at the same site, report diagnostics in the following precedence:

1) Ambiguous hole kind (parsing cannot classify) → E4412  
2) Occurs-check failure / infinite type during unification → E4412  
3) Ambiguous minimal solution (effects/permissions/modal-state) → E7C17 (effects) or E441x (others)  
4) Unresolved/under-constrained hole → E4411

### 8.4.4 Subtyping Normalization (Implementation Notes)

Subtyping constraints SHOULD be normalized before unification:

```
(τ₁,…,τₙ) → τᵣ ! ε  <:  (σ₁,…,σₙ) → σᵣ ! ε'
------------------------------------------------------
Add σᵢ <: τᵢ (contravariant), τᵣ <: σᵣ (covariant), ε ⊆ ε' (covariant)

Tuple/Array/Record (invariant fields)
--------------------------------------
Decompose only when fields structurally match; otherwise keep <: and check post-unification
```

---

## 8.5 Expression Holes

### 8.5.1 Syntax

```
ExprHole ::= "_?" (":" Type)?
```

### 8.5.2 Static Semantics

```
[T-Hole-Expr-Ann]
Γ ⊢ T : Type
----------------------
Γ ⊢ (_?: T) : T

[T-Hole-Expr-Synth]
constraints(Γ;Δ;Σ ⊢ _?) ⇒ S  (includes expected-type constraints if any)
solve(S) = θ with θ(types) = T̂ principal
--------------------------------------------
Γ ⊢ _? : T̂
```

If synthesis lacks sufficient constraints to determine a principal type, emit E4411 (unresolved expression hole). Expression holes contribute no dynamic semantics.

### 8.5.3 Interaction with Effects and Permissions

- When `_?` appears within an expression whose type includes an effect annotation literal, effect constraints are gathered per Part V §4.19, and the principal effect is substituted where applicable (see §8.9). See Part V §4.19 — Effect System.
- Permission requirements stemming from uses of the synthesized value (e.g., passing to `mut` parameters) contribute to Cp; the presence of a hole does not bypass LPS rules. See Part IV — Lexical Permission System.

### 8.5.4 Examples

```cursive
// Contextual typing determines type
let y: i32 = _?            // OK → y = _? : i32 (context determines i32)

// With annotation
let z = _?: string         // OK → z: string

// Insufficient context
let a = _?                 // ERROR E4411: unresolved expression hole (no expected type)
```

---

## 8.6 Type Holes

### 8.6.1 Syntax

```
TypeHole ::= "_?"   // only in type position
```

### 8.6.2 Static Semantics

```
[T-Hole-Type]
constraints(Γ ⊢ _? : Type) ⇒ Ct
solve(Ct) = θt principal
----------------------------
Γ ⊢ _? elaborates to θt(_?)
```

Type holes are solved by type unification and subtyping under Part II rules. Occurs-check failure rejects with E4412 (note: “cannot construct infinite type”). See Part II §2.0.6 — Subtyping and Equivalence.

### 8.6.3 Examples

```cursive
// Type context fixes hole
let n: _? = 42            // OK → infers i32 in TypeHole (per literal typing rules)

// Generic bound drives solution
function id<T>(x: T): T { x }
let f: (i32) → i32 = id  // OK → contextual type fixes T = i32

// Infinite type
// type Bad = (Bad)       // via alias cycles elsewhere; occurs-check prevents here
let rec: _? = (rec)       // ERROR E4412 (infinite type via unification)
```

---

## 8.7 Permission Holes

### 8.7.1 Syntax

```
PermissionHole ::= "_?"   // where a Permission is expected
```

### 8.7.2 Static Semantics

```
[T-Hole-Perm]
uses_of(binding) ⇒ requirements R ⊆ {imm, mut, own}
perm⋆ = least p in (imm < mut < own) satisfying R
--------------------------------------------
choose p = perm⋆; otherwise ERROR E4413
```

Notes (normative):

- If any use demands `own`, then `perm⋆ = own` and subsequent uses must respect move semantics. See Part IV §4.7 — Move Semantics.
- Permission holes are illegal where permission is fixed by an API contract or signature.
- When the grammar form is `PermissionHoleType ::= "_?" Type`, the elaborated type is `perm⋆ Type` where `perm⋆` is chosen by [T-Hole-Perm]. See Part IV §4.6 — Permission Lattice.

### 8.7.3 Examples

```cursive
// Write requires at least mut
let p: _? Point = Point { x: 0.0, y: 0.0 }
procedure bump(pt: mut Point) { pt.x += 1.0 }
bump(mut p)                    // OK → _? resolves to mut

// Ownership consumption requires own
procedure take(v: own string) { /* consume */ }
let s: _? string = string.from("hi")
take(move s)                   // OK → _? resolves to own; s invalid after

// No writes/moves → imm
procedure read_only(txt: string) { println(txt) }
let t: _? string = "hi"
read_only(t)                   // OK → _? resolves to imm
```

---

## 8.8 Modal-State Holes

### 8.8.1 Syntax

```
ModalStateHole ::= "@_?"   // only within a modal type
```

### 8.8.2 Static Semantics

```
[T-Hole-Modal]
Reach = ⋂ constraints_from_uses_and_transitions
Reach = {@S}  (singleton)
----------------------------
choose state @S; otherwise ERROR E4414
```

The reachable set is computed from the declared modal graph and all use-site preconditions. Multiple candidates or none are both errors. See Part II §2.3.3 — Modal State Machines.

### 8.8.3 Examples

```cursive
modal File {
    @Closed { path: string }
    @Open   { path: string, handle: Handle }
    @Closed -> open()  -> @Open
    @Open   -> close() -> @Closed
}

// Unique state demanded by receiver procedure
let f: File@_? = File.new("x")  // Uses require @Closed for open(); resolves @Closed
let g = f.open()                 // OK

// Ambiguity
let h: File@_? = File.new("x")
// No subsequent use determines state uniquely → ERROR E4414

// Impossible state (empty intersection)
// Demands read() (requires @Open) before any open(); Reach = ∅ → E4414
modal Conn { @Closed { } @Open { } @Closed -> open() -> @Open }
let c: Conn@_? = Conn.new()
let data = c::read()        // ERROR E4414
```

---

## 8.9 Effect Holes

Effect holes request principal effect inference for expressions and function types. The complete specification of effect composition and principal effects is in Part V §4.19.4-§4.19.5. See Part V §4.19.4 — Principal Effects; §4.19.5 — Effect Inference.

### 8.9.1 Syntax

Effect holes appear in effect annotation positions:

```ebnf
EffectHole ::= "_?"    // in effect-set position only
```

Examples:
```cursive
let f: (i32) → i32 ! _? = |x| -> x + 1
procedure process<ε>() uses ε where ε ⊆ {io.write}
```

### 8.9.2 Static Semantics

Effect holes are solved by computing the principal effect of the associated expression or function body:

```
[T-Hole-Eff]
constraints(Γ;Δ ⊢ _? effects) ⇒ Cε
solve(Cε) = ε⋆ principal (Part V §4.19.4)
ε⋆ is unique and minimal w.r.t. effect lattice
----------------------------------------
substitute ε⋆; else ERROR E7C17/E441x
```

**Principal effect computation:** The principal effect ε⋆ is the minimal effect set that satisfies all constraints from:
- Effectful operations in the expression/body
- Effect bounds from where clauses
- Effect requirements from called functions
- Captured variables in closures

**Ambiguity and purity:** If multiple incomparable effect sets satisfy the constraints, the hole is ambiguous and MUST be rejected with E7C17 (see Part VII §7.3). If no effectful operations appear, the unique minimum is the empty set `{}`; substitute `{}` (this is not defaulting, but principality in the effect lattice).

### 8.9.3 Interaction with Effect Polymorphism

Effect holes interact with effect polymorphism (Part V §4.19.6) as follows:

```cursive
// Effect hole with polymorphic bound
procedure wrap<ε>(f: () → () ! _?) uses ε
    where ε ⊆ {io.write, io.read}
{
    f()  // Effect hole resolves to principal effect of f's body
}

// Effect hole in polymorphic context
function apply<T, ε>(x: T, f: (T) → T ! _?) -> T ! ε {
    f(x)  // Effect hole resolves from f's implementation
}
```

### 8.9.4 Examples

**Success cases:**

```cursive
// Simple effect inference
let f: (i32) → () ! _? = |x| -> println(x)
// Effect hole resolves to {io.write}

// Effect composition
let g: (i32) → () ! _? = |x| -> {
    println(x)
    write_file("log", x)
}
// Effect hole resolves to {io.write, fs.write}

// Effect with bounds (hole inside local function value)
procedure bounded<ε>() uses ε where ε ⊆ {io.write} {
    let h: () → () ! _? = || -> println("hello")
    h()
}
// Effect hole resolves to {io.write}, which is within bound ε
```

**Failure cases:**

```cursive
// Ambiguous principal effects (two incomparable candidates)
let f: (i32) → () ! _? = |x| -> {
    if unknown_predicate() {
        println(x)       // io.write
    } else {
        fs_delete(x)     // fs.delete
    }
}
// Candidates: {io.write} and {fs.delete} ⇒ no unique ε⋆ → E7C17
```

---

## 8.10 Prohibitions and Explicitness Guards

Holes MUST NOT appear in positions requiring explicit annotations:

- Match expression result binding types. See Part V §4.8.1.
- Pipeline stage result types. See Part V §4.5.9.
- Iterator loop binding types. See Part V §4.9.3.
- Public API signatures and contract items (Part II §2.*; Appendix A.6/A.7).

Violation: ERROR E4415. Implementations SHOULD provide fix-its pointing to the required annotation.

Scope (normative): “Public API signatures” include parameter and return types, permission wrappers, effect annotations, effect bounds (where clauses), generic parameter lists and bounds, and contract predicate blocks (`must`/`will`). Holes in any of these surfaces are prohibited.

**Clarification on scope:** The above prohibitions apply as follows:

**Always prohibited (regardless of visibility):**
- Match expression result binding types (Part V §4.8.1). See Part V §4.8.1 — Match Expression Bindings.
- Pipeline stage result types (Part V §4.5.9). See Part V §4.5.9 — Pipeline Stages.
- Iterator loop binding types (Part V §4.9.3). See Part V §4.9.3 — Iterator Bindings.

**Prohibited in public API surfaces only:**
- Public function/procedure parameter types, return types, permission annotations
- Public function/procedure effect annotations (uses clauses) and effect bounds (where clauses)
- Public function/procedure generic parameter bounds
- Public record field types
- Public enum variant payload types
- Public type alias definitions
- Contract declarations (all items, always public) and contract predicate blocks (must/will clauses)

**Permitted in private contexts:**
- Private function/procedure signatures within a module
- Private record fields
- Local variable bindings and local type aliases
- Private helper function signatures

**Rationale:** Public API surfaces require explicit types for documentation, separate compilation, and cross-module type checking. Private contexts allow holes for local convenience while maintaining type safety through constraint solving.

### 8.10.1 Holes in Special Contexts

**Comptime blocks:** Holes are PERMITTED. Constraints are solved at compile time using the comptime evaluation context.

**Unsafe blocks:** Holes are PERMITTED. Safety obligations are unchanged; the programmer remains responsible for upholding invariants.

**Defer blocks:** Holes are PERMITTED. Constraints include the deferred execution context.

**Attribute arguments:** Holes are PROHIBITED (E4415). Attributes require compile-time constant values.

### 8.10.2 Patterns

Modal-state holes are permitted in patterns via Appendix A.3 (ModalPatternState). Their static semantics mirror §8.8: the pattern contributes Cm constraints, requiring a unique state.

```
[T-Hole-Modal-Pat]
Pattern uses Modal@_?
Reach = ⋂ constraints_from_match_context
Reach = {@S}
----------------------------
pattern elaborates to Modal@S; else ERROR E4414
```

---

## 8.11 Diagnostics (E44xx Series)

- E4411 - Unresolved expression hole. Primary span on `_?`; note: “insufficient contextual constraints”.
- E4412 - Unresolved/ambiguous type hole (or ambiguous kind). Include occurs-check note when applicable. See §8.6 — Type Holes.
- E4413 - Unresolved/ambiguous permission hole. Note weakest satisfying permission if any. See §8.7 — Permission Holes.
- E4414 - Unresolved/ambiguous modal-state hole. Show candidate states. See §8.8 — Modal-State Holes.
- E4415 - Hole in explicitness-required position. Link to the relevant section. See §8.10 — Prohibitions and Explicitness Guards.
- Effect ambiguity tie-in - E7C17 when multiple incomparable principal effects would satisfy constraints. See Part VII §7.3 — Effect Clauses; §8.9 — Effect Holes.

---

## 8.12 Meta-theory (Informative)

**Theorem 8.1 (Principal Solutions).** For each well-formed hole site whose constraints are satisfiable, the solver yields a principal solution unique up to definitional equality (types) and lattice equivalence (effects/permissions).  
Sketch: Types-by standard unification with occurs-check; Effects-by effect lattice minimization (§4.19.4); Permissions-by total order lattice `imm < mut < own`; Modal states-by finite intersection over a finite graph (§2.3.3).

**Theorem 8.2 (Termination).** Constraint generation and solving terminate for any finite program.  
Sketch: Each constraint set is finite; unification strictly decreases unknown size; lattice minimization over finite bases terminates; modal reachability over finite state machines terminates.

**Corollary 8.3 (Substitution Preservation).** Applying the computed substitution to the typed AST preserves typing and effects.

---

## 8.13 Conformance Test Matrix (Informative)

Implementations SHOULD provide tests covering:

- Expression holes: contextual success, under-constrained failure.
- Type holes: alias expansion, occurs-check failure, subtyping contexts.
- Permission holes: reads only (imm), writes (mut), moves (own), contract-fixed permissions (rejection).
- Modal-state holes: unique vs ambiguous vs impossible states.
- Effect holes: principalization, ambiguity (E7C17), propagation through closures.
- Prohibitions: holes in match result binding, pipeline stage type, loop iterator binding, public API signatures.

Each test SHOULD specify the expected diagnostic IDs verbatim.

---

## 8.14 Change Tracking

This chapter is normative as of 2025-11-01. Any future amendments MUST update Appendix A productions and the diagnostics table in Part I.

---

**Previous**: [Contracts and Effects](07_Contracts-and-Effects.md) | **Next**: [Functions](09_Functions.md)
