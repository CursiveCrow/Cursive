# The Cursive Language Specification [the-cursive-language-specification]

# Part 1 - Conformance and Governance [part-1---conformance-and-governance]

## 6. Fundamental Conformance [conformance]

This chapter defines the language's behavior classifications, the conformance obligations for both implementations and programs, the rules for managing unverifiable operations through an attribute-based attestation system, minimum implementation limits, and rules for reserved identifiers.

### 6.1 Behavior Classifications [conformance.behavior]

This section defines categories of program behavior based on how this specification constrains outcomes and what an implementation is expected to verify.

#### 6.1.1 Unverifiable Behavior (UVB) [conformance.behavior.uvb]

Unverifiable Behavior (UVB) comprises operations whose runtime correctness depends on properties **external** to the language's semantic model. UVB is permitted only within `unsafe` blocks and Foreign Function Interface (FFI) calls. By using an `unsafe` block, the programmer asserts that they are upholding an external contract that the compiler cannot see or check. If this contract is violated, the behavior is UVB and out-of-scope for safety guarantees.

#### 6.1.2 Unspecified Behavior (USB) [conformance.behavior.usb]

Unspecified Behavior (USB) occurs when this specification permits a set of valid outcomes for a construct but does not require an implementation to document which outcome is chosen. The set of permitted outcomes is always constrained by this specification.

> **Permitted Variation**
>
> An implementation **MAY** choose any permitted outcome, and the choice **MAY** vary between executions.

**_Ill-Formed, No Diagnostic Required (IFNDR)_**

A program that violates a static-semantic rule of the language is ill-formed. When detecting a violation is computationally infeasible, an implementation is not required to issue a diagnostic. Such a program is considered **Ill-Formed, No Diagnostic Required (IFNDR)**.

> **Safety Boundary**
>
> The behavior of an IFNDR program is unspecified but, occurring in safe code, **MUST NOT** introduce UVB. Its effects are bounded by the language's safety guarantees.

#### 6.1.3 Implementation-Defined Behavior (IDB) [conformance.behavior.idb]

Implementation-Defined Behavior (IDB) occurs when this specification permits multiple valid outcomes and requires the implementation to document its choice.

> **Documentation Requirement**
>
> Conforming implementations **MUST** document all IDB choices (e.g., primitive type sizes, memory layout) in their conformance dossier.

### 6.2 Conformance Obligations [conformance.obligations]

This section defines the requirements for conforming implementations and programs, including the handling of `unsafe` code.

#### 6.2.1 Conforming Implementations [conformance.obligations.implementations]

> **Implementation Requirements**
>
> A conforming implementation:
>
> 1.  **MUST** satisfy all **MUST**-level requirements in this specification.
> 2.  **MUST** be capable of rejecting all ill-formed programs (except IFNDR) with at least one error diagnostic.
> 3.  **MUST** support an attribute-based attestation system for `unsafe` blocks as defined in §6.7.
> 4.  **MUST** support at least two conformance modes, `permissive` and `strict`, as defined in §6.3.
> 5.  **MUST** be capable of generating a conformance dossier as a build artifact, as defined in §6.4.

#### 6.2.2 Conforming Programs [conformance.obligations.programs]

A program is considered **conforming** if it is well-formed and meets all safety and documentation requirements when compiled in `strict` mode. A well-formed program that compiles in `permissive` mode but contains `unsafe` blocks without attestations is considered **non-conforming**, though it will still produce an executable artifact.

### 6.3 Conformance Modes [conformance.modes]

> **Mode Support**
>
> Conforming implementations **MUST** support at least two conformance modes:
>
> 1.  **`permissive` mode**: The default mode, intended for development. In this mode, missing attestations on `unsafe` blocks **MUST** generate a `warning`.
> 2.  **`strict` mode**: Intended for production builds and formal verification. In this mode, missing attestations on `unsafe` blocks **MUST** be treated as a compile-time `error`, causing the build to fail.

### 6.4 The Conformance Dossier [conformance.dossier]

The conformance dossier is a machine-readable document that serves as a summary report of the build's safety and implementation-defined characteristics.

> **Dossier Generation**
>
> This dossier **MUST** be a **build artifact generated by the compiler**, not a source file managed by the programmer. The compiler **MUST** gather all `[[attestation]]` attributes from across the codebase and compile them into the dossier. The dossier **MUST** also include a list of any `unsafe` blocks that were compiled without an attestation in `permissive` mode. The schema for the dossier is defined in Appendix C.

### 6.5 Implementation Limits [conformance.limits]

> **Minimum Limits**
>
> Conforming implementations **MUST** support at least the following minimum guaranteed limits and **MUST** document their actual limits. Exceeding these limits renders a program ill-formed.
>
> *   **Source text:** 1 MiB file size, 1,023 character identifier length.
> *   **Syntactic nesting:** 256 levels for blocks and expressions.
> *   **Declarations:** 255 procedure parameters, 1,024 record fields.
> *   **Compile-time evaluation:** 256 recursion depth.

### 6.6 Reserved Identifiers [conformance.reserved]

> **Reservation Policy**
>
> **Reserved Keywords:**
> The identifiers listed in the normative grammar (Appendix A) are reserved. They **MUST NOT** be used as user-defined identifiers.
>
> **Reserved Namespaces:**
> The `cursive.*` namespace prefix is reserved for specification-defined features. It **MUST NOT** be used by user programs or vendor extensions.
>
> **Implementation Reservations:**
> Implementations **MAY** reserve additional identifier patterns (e.g., those beginning with `__`). Such reservations **MUST** be documented. Conforming programs **SHOULD NOT** use these patterns.
>
> **Universe-Protected Bindings:**
> Core language identifiers, such as primitive type names (`i32`, `bool`), **MUST NOT** be shadowed by user declarations. Any attempt to do so **MUST** be diagnosed as an error.

### 6.7 The Attestation System [conformance.attestation]

Cursive provides an attribute-based attestation system to manage uses of `unsafe` code.

> **Attestation Placement**
>
> An `unsafe` block **SHOULD** be immediately preceded by an `[[attestation]]` attribute. This attribute co-locates the justification for the `unsafe` operation with the code itself.
>
> **Attribute Structure**
>
> The `[[attestation]]` attribute **MUST** support at least the following fields:
>
> *   `method`: A string describing the verification method (e.g., "Manual Audit", "Formal Proof").
> *   `auditor`: A string identifying the person or entity responsible for the verification.
> *   `date`: A string representing the date of the audit in ISO 8601 format (YYYY-MM-DD).
> *   `proof`: A string, typically a URL, pointing to the evidence of verification (e.g., a design document, audit report, or formal proof artifact).
> *   `comment`: A string containing a concise explanation of why the `unsafe` block is justified.

```cursive
[[attestation(
    method: "Manual Audit",
    auditor: "Jane Doe",
    date: "2025-11-16",
    proof: "https://internal-wiki/audit-report-XYZ",
    comment: "FFI call is safe because the buffer size is checked by the surrounding safe code."
)]]
unsafe {
    // Dangerous operation that is externally verified
}
```

---

## 7. Language Evolution and Governance [evolution]

This chapter defines the versioning model for the Cursive language, the lifecycle of language features, and the rules governing implementation-specific extensions.

### 7.1 Versioning Model [evolution.versioning]

The Cursive language version identifier follows semantic versioning.

> **Version Format**
>
> The version identifier **MUST** use the format `MAJOR.MINOR.PATCH`.
>
> *   **MAJOR** version increments indicate incompatible changes.
> *   **MINOR** version increments indicate backwards-compatible additions.
> *   **PATCH** version increments indicate backwards-compatible corrections.

Programs **MUST** declare their target language version in the project manifest.

> **Version Compatibility**
>
> An implementation **MUST** reject a program if the declared MAJOR version does not match a MAJOR version supported by the implementation.
>
> Implementations **MUST** maintain source-level backward compatibility for conforming programs across MINOR version increments within the same MAJOR version.

#### 7.1.1 Editions [evolution.versioning.editions]

Language editions may be used to manage groups of incompatible changes without incrementing the MAJOR version for every breaking change.

> **Edition Support**
>
> When editions are supported, an implementation **MUST** allow a program to declare its target edition. Semantics from different editions **MUST NOT** be mixed within a single compilation unit. An edition may introduce new keywords, alter syntax, or change semantic rules, but these changes only apply to code that has opted into that edition.

### 7.2 Feature Lifecycle [evolution.lifecycle]

Every language feature is classified by its stability.

#### 7.2.1 Stability Classes [evolution.lifecycle.stability]

> **Stability Classification**
>
> Every language feature **MUST** be classified into one of three stability classes:
>
> 1.  **Stable**: Features available by default. They **MUST NOT** introduce breaking changes except in MAJOR version increments or new editions.
> 2.  **Preview**: Features requiring explicit opt-in via a feature flag. They **MAY** change between MINOR versions.
> 3.  **Experimental**: Highly unstable features requiring explicit opt-in. They **MAY** be changed or removed in any version without following standard deprecation timelines.

#### 7.2.2 Deprecation [evolution.lifecycle.deprecation]

Features may be deprecated when better alternatives exist or they conflict with language design.

> **Deprecation Policy**
>
> Deprecated features **MUST** remain functional for at least one full MINOR version after the version in which they are deprecated.
>
> Implementations **SHOULD** issue a `warning` when a deprecated feature is used.
>
> Features, other than experimental ones, **MAY** be removed only in MAJOR version increments or new editions. Removal **MUST** result in an `error` diagnostic.
>
> Features with discovered security vulnerabilities **MAY** follow an expedited deprecation and removal timeline.

### 7.3 Extension System [evolution.extensions]

Implementations may provide language extensions beyond the core specification.

> **Extension Constraints**
>
> Extensions **MUST NOT** alter the meaning of conforming programs written without the extension. Extensions **MUST NOT** suppress required diagnostics.

#### 7.3.1 Feature Flags [evolution.extensions.flags]

> **Feature Flags**
>
> Extensions requiring opt-in **MUST** be controlled through feature flags. Feature flags for specification-defined preview features **MUST** use identifiers without vendor prefixes.
>
> An implementation **MUST** issue an `error` for an unknown feature flag identifier.
>
> Use of a feature that requires a flag, when that flag is not enabled, **MUST** be diagnosed as an `error`.

#### 7.3.2 Vendor Prefixes [evolution.extensions.vendor]

> **Vendor Namespace**
>
> Vendor-specific extensions **MUST** use a reverse-domain-style namespace (e.g., `com.vendor.feature`). The `cursive.*` namespace is reserved for specification-defined features.

---

# Part 2 - Lexical Structure and Translation [part-2---lexical-structure-and-translation]

(This part defines the language's grammar, from source text to tokens.)

## 8. Source Text and Encoding [source]

This chapter defines requirements for source file encoding, structure, and ingestion.

For the purposes of this part:

- A _source byte stream_ is the raw sequence of bytes read from a file or other input.
- A _normalized source file_ is the sequence of Unicode scalar values obtained from a source byte stream after the preprocessing pipeline in §8.1.0 (UTF-8 decoding, optional BOM removal, and line-ending normalization) has successfully completed.
- A _compilation unit_ is defined in §8.3.1 [source.inclusion.units].

> **Strict Conformance**
>
> Violations of any requirement in §8.1–§8.2 that result in an `SRC-01` error diagnostic (including `E-SRC-0101`–`E-SRC-0104` and errors for exceeding documented maximum file size, logical line count, or line length) **MUST** cause the affected compilation unit to be treated as ill-formed under §6.3.3. Such violations **MUST NOT** be classified as Unverifiable Behavior (UVB) or Unspecified Behavior (USB). Variation in behavior for this chapter is permitted only where this specification explicitly designates implementation-defined behavior (IDB), and those choices **MUST** be documented in the implementation’s conformance dossier (§6.1.4, §6.3.4).

### 8.1 Character Encoding [source.encoding]

#### 8.1.0 Preprocessing Pipeline [source.encoding.pipeline]

> **Pipeline Order**
>
> Source text preprocessing **MUST** execute in the following order:
>
> (1) **File size validation** (§8.2.2 [source.structure.size]): Implementations **MUST** enforce the implementation-defined maximum byte length for the source byte stream;
>
> (2) **UTF-8 decoding and validation** (§8.1.1 [source.encoding.utf8]): The byte stream **MUST** be decoded as UTF-8;
>
> (3) **BOM removal** (§8.1.2 [source.encoding.bom]): If the first decoded scalar value is U+FEFF, it **MUST** be stripped;
>
> (4) **Line ending normalization** (§8.2.1 [source.structure.lines]): CR, LF, and CRLF sequences **MUST** be normalized to LF;
>
> (5) **Prohibited code point validation** (§8.1.3 [source.encoding.invalid]): Control characters **MUST** be validated;
>
> (6) **Physical structure validation** (§8.2.3 [source.structure.physical]): The normalized stream **MUST** conform to the EBNF grammar.
>
> Unicode normalization (§8.1.4 [source.encoding.normalization]), being implementation-defined, **MAY** be applied only after UTF-8 decoding and line-ending normalization (steps (2)–(4)) and **MUST** be accounted for in a way that does not change the byte offsets or logical line/column coordinates used for diagnostics. Implementations **MAY** maintain a separate normalized view of the decoded scalar sequence for comparisons while computing all diagnostic locations with respect to the pre-normalized decoded sequence.

#### 8.1.1 UTF-8 Requirements [source.encoding.utf8]

> **UTF-8 Mandate**
>
> Cursive source input **MUST** be a sequence of Unicode scalar values encoded as UTF-8 as specified in ISO/IEC 10646 and The Unicode Standard, Version 14.0 or later.
>
> Implementations **MUST** accept only byte streams that decode to legal UTF-8 sequences conforming to the encoding scheme specified in RFC 3629. A byte sequence is a legal UTF-8 sequence if and only if it satisfies the following conditions:
>
> (a) Each code unit sequence correctly encodes a Unicode scalar value (U+0000 through U+D7FF and U+E000 through U+10FFFF);
>
> (b) The encoding uses the shortest possible representation for each scalar value (overlong encodings are forbidden);
>
> (c) No byte sequence encodes a surrogate code point (U+D800 through U+DFFF).
>
> Invalid byte sequences **MUST** trigger an error diagnostic. The diagnostic **MUST** identify the byte offset of the first invalid byte in the source file.

**_Diagnostic:_**

| Code         | Severity | Description                  |
| :----------- | :------- | :--------------------------- |
| `E-SRC-0101` | Error    | Invalid UTF-8 byte sequence. |

#### 8.1.2 BOM Handling [source.encoding.bom]

> **BOM Stripping**
>
> If a source file begins with the UTF-8 byte order mark (BOM, U+FEFF) as the first decoded scalar value, the implementation **MUST** strip the BOM before lexical analysis. A BOM appearing at any scalar value position after the first **MUST** trigger an error diagnostic.
>
> When a source file begins with a UTF-8 BOM and otherwise satisfies the constraints of §8.1 and §8.2, a conforming implementation **SHOULD** emit a warning diagnostic while still accepting the file.

**_Diagnostic:_**

| Code         | Severity | Description                                  |
| :----------- | :------- | :------------------------------------------- |
| `E-SRC-0103` | Error    | Embedded BOM found after the first position. |
| `W-SRC-0101` | Warning  | UTF-8 BOM present.                           |

#### 8.1.3 Invalid Sequences [source.encoding.invalid]

> **Prohibited Characters**
>
> Source files **MUST NOT** contain prohibited code points. After line ending normalization (§8.2.1 [source.structure.lines]), validation of prohibited code points **MUST** be performed on the normalized sequence of Unicode scalar values.
>
> Prohibited code points are:
>
> * The null character (U+0000); and
> * Any Unicode scalar value whose general category is `Cc` (control), **except**:
>     * Horizontal tab (U+0009)
>     * Line feed (U+000A)
>     * Form feed (U+000C)
>     * Carriage return (U+000D)
>
> These constraints **MUST** apply to all parts of the source file **except** for the contents of string literals (§9.4.2) and character literals (§9.4.3). The validation of code points *within* literals is handled by the lexical analyzer, which correctly processes valid escape sequences (such as `\0` or `\r`).
>
> Validation of prohibited code points **MUST** occur after UTF-8 decoding and line ending normalization but before lexical analysis. A source file that contains at least one prohibited code point *outside* of a string or character literal **MUST** trigger an error diagnostic and **MUST** be treated as an ill-formed compilation unit under §6.3.3.

**_Diagnostic:_**

| Code         | Severity | Description                               |
| :----------- | :------- | :---------------------------------------- |
| `E-SRC-0104` | Error    | Forbidden control character or null byte. |

#### 8.1.4 Normalization [source.encoding.normalization]

> **General Normalization**
>
> Unicode normalization of source text outside identifiers and module-path components is implementation-defined behavior (IDB). Implementations **SHOULD** accept source files in any Unicode normalization form (NFC, NFD, NFKC, or NFKD) and **MUST** document any normalization they perform in the conformance dossier (cf. §6.3 [conformance.obligations]), including the Unicode Standard version (and any Unicode Standard Annexes, such as UAX #31) used for validation and identifier classification.
>
> **Identifier Normalization**
>
> For identifier lexemes and module-path components, implementations **MUST** normalize the corresponding scalar sequences to Unicode Normalization Form C (NFC) prior to equality comparison, hashing, or name lookup, and **MUST** apply NFC consistently in all translation phases for these purposes.
>
> **Diagnostic Stability**
>
> Any normalization performed **MUST NOT** change logical line boundaries or the byte offsets used when reporting diagnostic locations, and **MUST NOT** be applied to the interior of string or character literal lexemes; the scalar values of literals are derived directly from the decoded source together with escape processing. Implementations that maintain both a pre-normalized and normalized view of the source **MUST** compute all diagnostic locations and spans with respect to the pre-normalized decoded sequence as produced by §8.1.0.

#### 8.1.5 Diagnostic Location Requirements [source.encoding.locations]

> **Location Reporting**
>
> Diagnostics in the `SRC-01` feature bucket **MUST** report locations as follows:
>
> (a) `E-SRC-0101` (invalid UTF-8 byte sequence) **MUST** report a source location whose byte offset corresponds to the first invalid byte in the source file as required by §8.1.1 [source.encoding.utf8].
>
> (b) `E-SRC-0102` (source file exceeds implementation-defined maximum size) **MUST** be associated with the offending source file; when the implementation does not read file contents, it **MAY** report a conventional line and column (for example, line 1, column 1) while still identifying the file path.
>
> (c) `E-SRC-0103` (embedded BOM) **MUST** reference the source location of the first U+FEFF scalar value that appears after the first position in the decoded scalar sequence.
>
> (d) `E-SRC-0104` (forbidden control character or null byte) **MUST** reference the first prohibited code point encountered in the normalized source file.
>
> (e) `E-SRC-0105` (maximum logical line count exceeded) and `E-SRC-0106` (maximum line length exceeded), which report exceeding an implementation-defined maximum logical line count or maximum line length (§8.2.2 [source.structure.size]), **MUST** be associated with the first logical line or column that violates the documented limit.
>
> The warning diagnostic `W-SRC-0101` (UTF-8 BOM present) **MUST** be associated with the first scalar position of the file (line 1, column 1).

### 8.2 Source File Structure [source.structure]

#### 8.2.1 Line Endings [source.structure.lines]

> **Line Ending Normalization**
>
> Implementations **MUST** recognize and normalize all three common line-ending sequences (LF, CR, CRLF) to a single canonical Line Feed character (U+000A) before tokenization. The normalization algorithm operates as follows:
>
> (a) Each occurrence of the two-character sequence CR LF (U+000D U+000A) **MUST** be replaced with a single LF (U+000A);
>
> (b) Each standalone CR (U+000D) not followed by LF **MUST** be replaced with a single LF (U+000A);
>
> (c) Each LF (U+000A) that does not follow a CR remains unchanged.
>
> Mixed line endings are permitted within a single source file.

#### 8.2.2 Maximum File Size [source.structure.size]

> **File Size Limit**
>
> Implementations **MUST** enforce an implementation-defined maximum byte length per source input. Conforming implementations **MUST** accept source files of at least 1 mebibyte (1 MiB = 2²⁰ bytes = 1,048,576 bytes). Each implementation **MUST** document its maximum in the conformance dossier (cf. §6.3 [conformance.obligations]); any choice of maximum above this minimum is implementation-defined behavior (IDB).
>
> **Pre-read Validation**
>
> For source inputs whose byte length is available prior to reading (for example, regular files), implementations **MUST** compare that length against the documented maximum before attempting UTF-8 decoding. If the length exceeds the documented maximum, the implementation **MUST** emit an error diagnostic and **MUST NOT** attempt to decode the file.
>
> **Streaming Validation**
>
> For source inputs whose length is not available in advance (for example, non-seekable streams), implementations **MUST** track the number of bytes read and **MUST** emit an error diagnostic as soon as the accumulated length exceeds the documented maximum. In all cases, a compilation unit that triggers this error **MUST** be treated as ill-formed in the sense of §6.3.3 and **MUST NOT** yield executable artifacts.

> **Line Limits**
>
> Implementations **MUST** also document an implementation-defined maximum logical line count and maximum line length (in Unicode scalar values) per source file. Conforming implementations **MUST** accept source files containing at least 65 536 logical lines and **MUST** accept lines containing at least 16 384 Unicode scalar values. Exceeding the documented maximum line count **MUST** be diagnosed as an error (Maximum logical line count exceeded), exceeding the documented maximum line length **MUST** be diagnosed as an error (Maximum line length exceeded), and either violation **MUST** render the affected compilation unit ill-formed.

**_Diagnostic:_**

| Code         | Severity | Description                                              |
| :----------- | :------- | :------------------------------------------------------- |
| `E-SRC-0102` | Error    | Source file exceeds implementation-defined maximum size. |
| `E-SRC-0105` | Error    | Maximum logical line count exceeded.                     |
| `E-SRC-0106` | Error    | Maximum line length exceeded.                            |

> [!tip] Rationale
> Explicit limits on line count and line length provide deterministic worst-case bounds for lexing and tooling while setting generous minima to preserve expressiveness for large or generated sources. Treating violations as `SRC-01` errors keeps these constraints consistent with other source-ingestion rules and ensures that resource-limit failures are diagnosed, not left to implementation-specific crashes or undefined behavior.

#### 8.2.3 Physical Structure [source.structure.physical]

> **Physical Grammar**
>
> A source file **MUST** conform to the following EBNF grammar after UTF-8 decoding, BOM removal, and line-ending normalization, but before tokenization:
>
> **_Syntax:_**
>
> ```ebnf
> <source_file>
>     ::= <normalized_line>*
>
> <normalized_line>
>     ::= <code_point>* <line_terminator>?
>
> <line_terminator>
>     ::= U+000A
>
> <code_point>
>     ::= /* any Unicode scalar value other than U+000A and those prohibited by §8.1.3 */
> ```
>
> The non-terminal `<code_point>` denotes any Unicode scalar value that satisfies the constraints specified in §8.1.3 [source.encoding.invalid] and is not U+000A. The non-terminal `<line_terminator>` represents the normalized line-ending character produced by §8.2.1 [source.structure.lines].

### 8.3 Source Inclusion Model [source.inclusion]

#### 8.3.1 Compilation Units [source.inclusion.units]

> **Compilation Unit Definition**
>
> A compilation unit is the collection of all normalized source files (.cursive files) that contribute to a single module, as defined by the "folder-as-module" rule in §11.2.1 [module.discovery].

While a source file is preprocessed individually, it is semantically analyzed as part of a larger compilation unit. The compilation unit, not the individual file, is the smallest unit of code that is compiled to produce a module artifact.

#### 8.3.2 No Textual Preprocessing or Inclusion [source.inclusion.noheaders]

> **No Textual Inclusion**
>
> Cursive provides no C-style textual inclusion (e.g., `#include`) or textual preprocessing (e.g., `#define`) mechanisms.
>
> **Metaprogramming Mechanism**
>
> All metaprogramming and code generation **MUST** be performed using the `comptime` execution, `quote` expressions, and `codegen::emit` intrinsic system (defined in Part 7, §34). This system operates on the Abstract Syntax Tree (AST) after parsing and **MUST NOT** operate on the raw source text.

### 8.4 Translation Phases [source.phases]

This section defines the mandatory, deterministic pipeline that all conforming implementations **MUST** follow to translate Cursive source text into an executable artifact.

#### 8.4.1 Deterministic Pipeline [source.phases.deterministic-pipeline]

> **Phase Ordering**
>
> Compilation **MUST** proceed through the following four (4) deterministic phases in this specific order.
>
> 1.  **Parsing:** The normalized source text (§8.1.0) is converted into an Abstract Syntax Tree (AST). All declarations (procedures, types, traits, etc.) are recorded in their respective scopes.
> 2.  **Compile-Time Execution:** `comptime` blocks and procedures are executed. This phase may programmatically generate new declarations, which are added to the AST (see Part 7, §34).
> 3.  **Type Checking:** The complete AST (including all original and generated declarations) is semantically validated. This phase enforces all rules from the type system (Part 4), memory model (Part 6, §30), and capability system (Part 6, §31).
> 4.  **Code Generation:** The validated AST is lowered to an intermediate representation and then to the target machine code.

#### 8.4.2 The Two-Phase Model and Forward References [source.phases.the-two-phase-model-and-forward-references]

> **Two-Phase Model**
>
> Cursive **MUST** be implemented using a **two-phase compilation model**.
>
> 1.  **Phase 1 (Parsing):** The implementation **MUST** parse all source files within a compilation unit (§10.1) and record all top-level declarations *before* proceeding to the second phase.
> 2.  **Phase 2 (Semantic Analysis):** The implementation **MUST** perform compile-time execution and type checking only *after* the parsing phase is complete.
>
> As a direct consequence of this model, forward references to declarations within the same compilation unit **MUST** be permitted. A procedure, type, or other top-level item may be used textually before its declaration appears in the source file.

***Example:***

```cursive
// This is a valid compilation unit.

// The `main` procedure can call `helper` before it is declared,
// because `helper` is recorded during the first phase (Parsing).
// Type checking of `main` is deferred until the second phase.
public procedure main(ctx: Context): i32 {
    helper(ctx)
    result 0
}

// The declaration for `helper` is found later in the file.
procedure helper(ctx: Context) {
    // ...
}
```
### 8.5 Diagnostics Summary [source.diagnostics]

This chapter introduces the following diagnostics in the `SRC` (Source) category.

| Code         | Severity | Description                                              |
| :----------- | :------- | :------------------------------------------------------- |
| `E-SRC-0101` | Error    | Invalid UTF-8 byte sequence.                             |
| `E-SRC-0102` | Error    | Source file exceeds implementation-defined maximum size. |
| `E-SRC-0103` | Error    | Embedded BOM found after the first position.             |
| `E-SRC-0104` | Error    | Forbidden control character or null byte.                |
| `E-SRC-0105` | Error    | Maximum logical line count exceeded.                     |
| `E-SRC-0106` | Error    | Maximum line length exceeded.                            |
| `W-SRC-0101` | Warning  | UTF-8 BOM present.                                       |

---

## 9. Lexical Structure [lexical]

This chapter defines tokenization and lexical elements.

### 9.1 Lexical Elements [lexical.elements]

#### 9.1.1 Token Categories [lexical.elements.tokens]

> **Tokenization Output**
>
> Lexical analysis **MUST** consume the normalized source file produced by §8.1 and §8.2 and **MUST** produce a finite, ordered sequence of tokens. Each token **MUST** record at least: a token kind, the exact source lexeme, and a source span (file, start line/column, end line/column).
>
> **Token Classification**
>
> The lexer **MUST** classify every non-comment, non-whitespace fragment of the normalized source as exactly one of the following token kinds:
>
> 1. `<identifier>` — an identifier satisfying §9.3
> 2. `<keyword>` — a reserved word listed in §9.2.1
> 3. `<literal>` — a numeric, string, or character literal as defined in §9.4
> 4. `<operator>` — an operator symbol as defined in §9.2.2
> 5. `<punctuator>` — a punctuation symbol as defined in §9.2.2
> 6. `<newline>` — a line terminator token corresponding to U+000A as defined in §8.2.1 and §9.1.2
>
> Any maximal character sequence that cannot be classified as one of these token kinds **MUST** cause the implementation to emit at least one error diagnostic in the `SRC-03` feature bucket (Appendix B) and **MUST** be treated as ill-formed source; the implementation **MUST NOT** silently split such a sequence into multiple tokens to avoid diagnostics.

```ebnf
<token>
    ::= <identifier>
     | <keyword>
     | <literal>
     | <operator>
     | <punctuator>
     | <newline>
```

> **Determinism**
>
> The tokenization process **MUST** be deterministic for a given normalized source file and compilation configuration: repeated compilations **MUST** produce the same token sequence, except where implementation-defined behavior explicitly permits variation that is documented in the conformance dossier (§6.1.4, Appendix C).

#### 9.1.2 Whitespace Handling [lexical.elements.whitespace]

> **Whitespace Definition**
>
> After line-ending normalization (§8.2.1), the only whitespace code points that lexical analysis **MUST** treat specially are: space (U+0020), horizontal tab (U+0009), form feed (U+000C), and line feed (U+000A). Space, horizontal tab, and form feed **MUST** act solely as token separators and **MUST NOT** be emitted as tokens.
>
> Each line feed (U+000A) that is not part of a line comment terminator (§9.1.3) **MUST** be represented in the token stream as a `<newline>` token. Implementations **MUST NOT** reorder, insert, or remove `<newline>` tokens relative to non-comment tokens, except when discarding entire ill-formed constructs that have already been diagnosed.
>
> Outside string and character literals (§9.4), implementations **MUST NOT** treat any additional Unicode whitespace or control characters as having special lexical meaning; code points not permitted by §8.1.3 **MUST** already have been rejected in the preprocessing pipeline (`E-SRC-0104`) and **MUST NOT** reach lexical analysis.
>
> Statement-termination and continuation behavior **MUST** be defined only in terms of `<newline>` tokens, semicolons, and delimiter/continuation predicates as specified in §10.2 and §11.4; implementations **MUST NOT** introduce additional implicit terminators based on other whitespace.
>
> The `<newline>` token kind described in this section corresponds to the `<newline>` lexical production in Appendix A, §A.1.2.

#### 9.1.3 Comments [lexical.elements.comments]

> **Line Comments**
>
> A line comment **MUST** begin with the two-character sequence `//` that is not inside a string or character literal and **MUST** extend to but not include the next line feed (U+000A) or end of file, whichever comes first. Line comments **MUST NOT** produce tokens; the characters they consume **MUST** be discarded by lexical analysis.
>
> Line comments whose first three characters are `///` **MUST** be classified as declaration documentation comments, and line comments whose first three characters are `//!` **MUST** be classified as module documentation comments. Documentation comments **MUST** be preserved and associated with the immediately following declaration or module (subject to the rules of Part III and Appendix F) but **MUST NOT** appear as ordinary tokens in the token stream.
>
> A block comment **MUST** be delimited by the two-character sequence `/*` and the two-character sequence `*/`, neither of which may appear inside a string or character literal for the purposes of comment recognition. Block comments **MUST** nest: each `/*` encountered while inside a block comment **MUST** increase a nesting-depth counter by one, and each `*/` **MUST** decrease it by one.
>
> If end of file is reached while the block-comment nesting depth is non-zero, the implementation **MUST** emit an error diagnostic at the source location of the `/*` that began the unterminated outermost comment and **MUST** treat the compilation unit as ill-formed. Implementations **MAY** additionally highlight the location of the end-of-file or last line as a related note diagnostic.
>
> Characters that appear within any kind of comment **MUST NOT** contribute to token formation, delimiter nesting depth (§10.2.4), or identifier and literal content, and **MUST NOT** change the semantics of statement termination except through the `<newline>` token that terminates a line comment.

**_Diagnostic:_**

| Code         | Severity | Description                 |
| :----------- | :------- | :-------------------------- |
| `E-SRC-0306` | Error    | Unterminated block comment. |

```ebnf
<line_comment>
    ::= "//" <comment_char>* <newline>?

<block_comment>
    ::= "/*" (<block_comment> | <comment_char>)* "*/"
```

> **Comment Character Definition**
>
> The metavariable `<comment_char>` in the grammar above denotes any Unicode scalar value other than the start or end delimiters of the corresponding comment kind and other than line feed (U+000A) where prohibited by §8.1.3.

#### 9.1.4 Lexically Sensitive Unicode Characters [lexical.elements.security]

> **Lexical Sensitivity**
>
> Certain Unicode code points are considered *lexically sensitive* because they may alter the visual appearance of source code without changing its tokenization. At minimum, the following code points and code point classes **MUST** be treated as lexically sensitive:
>
> (a) Bidirectional formatting characters (for example, U+202A–U+202E and U+2066–U+2069);
>
> (b) Zero-width joiner (U+200D) and zero-width non-joiner (U+200C);
>
> (c) Any additional characters that an implementation documents as lexically sensitive in its conformance dossier.
>
> **Diagnostic Requirement**
>
> When a lexically sensitive character appears unescaped in an identifier (§9.3), operator or punctuator lexeme (§9.2.2), or immediately adjacent to token boundaries in non-comment, non-literal context, the implementation **MUST** emit a warning diagnostic and **MUST** identify the location of the first affected code point. In strict conformance modes (§6.3.7), implementations **MUST** upgrade this condition to an error diagnostic and **MUST NOT** accept the affected compilation unit while such diagnostics remain outstanding. Diagnostic messages **SHOULD** describe the class of lexically sensitive character involved.

**_Diagnostic:_**

| Code         | Severity | Description                                                            |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `W-SRC-0308` | Warning  | Lexically sensitive Unicode character in identifier or token boundary. |
| `E-SRC-0308` | Error    | Lexically sensitive Unicode character (Strict Mode).                   |
>
> **Literal Exemption**
>
> Lexically sensitive characters that appear only within string or character literals (§9.4) or are introduced via explicit escape sequences **MUST NOT**, by themselves, affect program well-formedness, but implementations **MAY** still emit non-error diagnostics (notes or warnings) for such occurrences as quality-of-implementation features.

### 9.2 Keywords and Operators [lexical.keywords]

#### 9.2.1 Reserved Keywords [lexical.keywords.reserved]

> **Reserved Keyword List**
>
> The following lexemes **MUST** be treated as reserved keywords in this version of the specification and **MUST NOT** be used where an identifier is expected: `abstract`, `as`, `break`, `char`, `comptime`, `const`, `continue`, `double`, `else`, `enum`, `extern`, `false`, `float`, `fork`, `if`, `half`, `imm`, `import`, `int`, `internal`, `let`, `loop`, `match`, `modal`, `module`, `move`, `mut`, `override`, `parallel`, `partitioned`, `private`, `procedure`, `protected`, `public`, `quote`, `record`, `region`, `result`, `return`, `self`, `Self`, `shadow`, `static`, `true`, `trait`, `type`, `uint`,`unique`, `unsafe`, `use`, `var`, `witness`, `where`.
>
> **Keyword Tokenization**
>
> Implementations **MUST** recognize each reserved keyword as a `<keyword>` token rather than an `<identifier>` token during lexical analysis. Wherever the grammar of Part III–Part V requires an `<identifier>`, the appearance of a reserved keyword **MUST** be rejected and an error diagnostic **MUST** be emitted.

**_Diagnostic:_**

| Code         | Severity | Description                          |
| :----------- | :------- | :----------------------------------- |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier. |
>
> **Keyword Uniformity**
>
> The set of reserved keywords defined above **MUST** be identical across conforming implementations for a given language version. Implementations **MUST NOT** reserve additional keywords or unreserve any of the listed keywords except through a future revision of this specification that explicitly changes the list.

#### 9.2.2 Operators and Punctuators [lexical.keywords.operators]

> **Operator Recognition**
>
> The lexer **MUST** recognize the following multi-character operator and punctuator tokens using a maximal-munch strategy (longest valid token first), subject to grammatical disambiguation rules in §10.2 and Appendix A:
>
> - `==`, `!=`, `<=`, `>=`, `&&`, `||`, `<<`, `>>`, `<<=`, `>>=`
> - `..`, `..=`, `=>`, `**`, `->`, `::`
>
> **Single-Character Tokens**
>
> The lexer **MUST** also recognize at least the following single-character operator and punctuator tokens: `+`, `-`, `*`, `/`, `%`, `<`, `>`, `=`, `!`, `&`, `|`, `^`, `~`, `.`, `,`, `:`, `;`, `(`, `)`, `[`, `]`, `{`, `}`. Additional operator or punctuator tokens **MAY** be defined by later parts of this specification, but any such additions **MUST** appear in Appendix A and **MUST NOT** conflict with the tokens listed here.
>
> **Maximal Munch**
>
> When multiple tokenizations are possible at a character position, the lexer **MUST** emit the longest token whose kind is permitted at that position by the grammar, except when parsing generic type arguments or similar contexts requires treating `>>` as two closing `>` tokens; in such contexts, the implementation **MAY** split a single lexeme `>>` into two logical punctuators for the purposes of parsing while preserving the original lexeme for diagnostics and tooling. This maximal-munch behavior **MUST** be consistent with the statement-termination rules in §10.2 and the grammar in Appendix A.

### 9.3 Identifiers [lexical.identifiers]

#### 9.3.1 XID_Start and XID_Continue Rules [lexical.identifiers.xid]

> **Identifier Composition**
>
> Identifier tokens **MUST** be sequences of Unicode scalar values that satisfy the identifier recommendations of [UAX31] as constrained in this section. The first code point of an identifier **MUST** be either (a) a code point with `XID_Start = Yes` in the Unicode Standard, or (b) U+005F LOW LINE (`_`). Each subsequent code point **MUST** have `XID_Continue = Yes` or be U+005F.
>
> **Forbidden Code Points**
>
> Identifiers **MUST NOT** contain code points that are prohibited by §8.1.3, surrogate code points (U+D800–U+DFFF), or non-characters. If a candidate identifier contains any code point that violates these conditions, the implementation **MUST** emit an error diagnostic at the first offending code point and **MUST** treat the identifier as ill-formed.
>
> **Keyword Exclusion**
>
> Reserved keywords (§9.2.1) **MUST NOT** be treated as identifiers even if they satisfy the `XID_Start`/`XID_Continue` constraints; they **MUST** always be tokenized as `<keyword>` and rejected in identifier positions with an error diagnostic.

**_Diagnostic:_**

| Code         | Severity | Description                          |
| :----------- | :------- | :----------------------------------- |
| `E-SRC-0307` | Error    | Invalid Unicode in identifier.       |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier. |

```ebnf
<identifier>
    ::= <ident_start> <ident_continue>*
```

> **Unicode Property Alignment**
>
> The metavariables `<ident_start>` and `<ident_continue>` above denote the sets of code points described in this section; the concrete character classes used by an implementation **MUST** correspond to the `XID_Start` and `XID_Continue` properties of the Unicode version documented in its conformance dossier (§8.1.4, Appendix C).

#### 9.3.2 Length Limits [lexical.identifiers.length]

> **Length Guarantee**
>
> Implementations **MUST** accept identifiers whose length (measured in Unicode scalar values) is at least 1,023 code points (§6.5.1). Each implementation **MUST** document in its conformance dossier the maximum identifier length it supports; this documented limit **MUST NOT** be less than 1,023.
>
> **Length Enforcement**
>
> If a source file contains an identifier whose length exceeds the implementation’s documented limit, the implementation **MUST** reject the program as ill-formed. The implementation **MUST** emit at least one error diagnostic in the `SRC-03` feature bucket whose code is reserved in Appendix D and **MUST** identify the offending identifier’s source span. This condition **MUST NOT** be classified as IFNDR (§6.1.3.1).

#### 9.3.3 Unicode Normalization [lexical.identifiers.normalization]

> **NFC Enforcement**
>
> Unicode normalization behavior for identifiers and module-path components **MUST** follow the general rules of §8.1.4. Implementations **MUST** normalize every identifier lexeme to Unicode Normalization Form C (NFC) prior to equality comparison, hashing, or inserting it into any name table, and **MUST** apply NFC consistently to all such lexemes within a compilation.
>
> **Name Equivalence**
>
> Two identifier occurrences **MUST** be considered the same binding name if and only if their NFC-normalized forms are identical sequences of Unicode scalar values. All name-comparison operations (including module path comparison, scope formation, and diagnostic reporting) **MUST** use this same NFC-normalized form.
>
> **Normalization Stability**
>
> Implementations **MUST NOT** perform identifier normalization in a way that changes logical line boundaries or the byte offsets used for reporting diagnostic locations, and **MUST NOT** normalize identifiers differently in different phases of translation.

### 9.4 Literals [lexical.literals]

#### 9.4.1 Numeric Literals [lexical.literals.numeric]

> **Literal Matching**
>
> A numeric literal token **MUST** match one of the integer or floating-point forms defined in this section. Any maximal sequence of characters that begins with a digit or a base prefix and fails to match one of these forms **MUST** be diagnosed as an error and **MUST NOT** be silently split into multiple tokens.
>
> **Decimal Format**
>
> A decimal integer literal **MUST** consist of a non-empty sequence of decimal digits (`0`–`9`), optionally separated by single underscores (`_`) between digits. Underscores **MUST NOT** appear at the beginning or end of the literal, immediately after a base prefix, immediately before or after an exponent marker, or immediately before a type suffix.
>
> **Based Integer Format**
>
> Hexadecimal (`0x`), octal (`0o`), and binary (`0b`) integer literals **MUST** begin with the corresponding two-character prefix followed by at least one digit of the appropriate base; digits appearing after a base prefix **MUST** all be valid for that base. Violations of these requirements (missing digits after the prefix or invalid digits for the base) **MUST** be diagnosed as an error.
>
> **Floating-Point Format**
>
> Floating-point literals **MUST** consist of an integer part, an optional fractional part introduced by `.`, an optional exponent part introduced by `e` or `E` followed by an optional sign and at least one decimal digit, and an optional suffix indicating the floating-point type. An exponent marker with no following digits, or any other deviation from this structure, **MUST** be diagnosed as an error.
>
> **Suffix Validation**
>
> Integer and floating-point literals **MAY** carry type suffixes drawn from the sets defined in the type system (Part IV and Appendix A). If a numeric literal is followed by a suffix that is not one of the suffixes permitted for that literal kind, the implementation **MUST** diagnose the literal as malformed.
>
> **Leading Zeroes**
>
> A decimal integer literal whose first digit is `0` and whose textual representation contains at least one additional decimal digit **MUST** be accepted as a valid decimal literal. Implementations **SHOULD** emit a warning for such literals, but **MUST NOT** treat them as octal or reject them solely for having leading zeros.

**_Diagnostic:_**

| Code         | Severity | Description                       |
| :----------- | :------- | :-------------------------------- |
| `E-SRC-0304` | Error    | Malformed numeric literal.        |
| `W-SRC-0301` | Warning  | Leading zeros in decimal literal. |

```ebnf
<decimal_integer>
    ::= <dec_digit> ("_"* <dec_digit>)*

<hex_integer>
    ::= "0x" <hex_digit> ("_"* <hex_digit>)*

<octal_integer>
    ::= "0o" <oct_digit> ("_"* <oct_digit>)*

<binary_integer>
    ::= "0b" <bin_digit> ("_"* <bin_digit>)*
```

> **Digit Consistency**
>
> The helper non-terminals `<dec_digit>`, `<hex_digit>`, `<oct_digit>`, and `<bin_digit>` above correspond to the digit classes used in Appendix A. Implementations **MUST** ensure that these productions and the numeric literal productions in Appendix A describe the same set of token lexemes.

#### 9.4.2 String Literals [lexical.literals.string]

> **String Delimiters**
>
> A string literal **MUST** begin with a double-quote character (`"` = U+0022) and **MUST** end with a matching unescaped double-quote. The characters between the opening and closing quotes **MAY** include any Unicode scalar values other than an unescaped double-quote and control characters forbidden by §8.1.3.
>
> **Escape Sequences**
>
> Inside a string literal, the backslash character (`\` = U+005C) **MUST** introduce an escape sequence. The only valid escape sequences in string literals **MUST** be:
>
> - `\\n`, `\\r`, `\\t`, `\\\\`, `\\\"`, `\\'`, `\\0`
> - `\\xHH` where `H` is a hexadecimal digit (two hex digits total)
> - `\\u{H+}` where each `H` is a hexadecimal digit and the resulting code point is a Unicode scalar value
>
> **Escape Validation**
>
> Any other sequence beginning with `\\` inside a string literal **MUST** be diagnosed as an error, and the implementation **MUST NOT** attempt to reinterpret it as multiple smaller tokens.
>
> **Unterminated Strings**
>
> If a line feed (U+000A) or end-of-file is encountered before a closing double-quote for a string literal, the implementation **MUST** emit an error diagnostic at the location of the opening quote and **MUST** treat the remainder of the source line (or file) as part of the ill-formed literal for diagnostic purposes.
>
> **String Length Limits**
>
> Implementations **MUST** accept string literals whose length (in Unicode scalar values) is at least 65,535 characters (§6.5.1). Each implementation **MUST** document any stricter limit it imposes. When a string literal in source exceeds the implementation’s documented limit, the implementation **MAY** reject the program with an error diagnostic and **MUST**, when it does so, identify the offending literal; when a string literal produced or manipulated during compile-time evaluation exceeds the guaranteed minimum, the implementation **MUST** emit an error diagnostic.

**_Diagnostic:_**

| Code         | Severity | Description                                  |
| :----------- | :------- | :------------------------------------------- |
| `E-SRC-0302` | Error    | Invalid escape sequence.                     |
| `E-SRC-0301` | Error    | Unterminated string literal.                 |
| `E-SRC-0204` | Error    | String literal exceeds limit (compile-time). |

#### 9.4.3 Character Literals [lexical.literals.character]

> **Character Delimiters**
>
> A character literal **MUST** begin with a single-quote character (`'` = U+0027), **MUST** end with a matching unescaped single-quote, and **MUST** represent exactly one Unicode scalar value.
>
> **Character Content**
>
> The content of a character literal **MUST** be either (a) a single Unicode scalar value that is not an unescaped single-quote, backslash, or forbidden control character (§8.1.3), or (b) one of the escape sequences permitted for string literals (`\\n`, `\\r`, `\\t`, `\\\\`, `\\\"`, `\\'`, `\\0`, `\\xHH`, `\\u{H+}`). Any other escape sequence inside a character literal **MUST** be diagnosed as an error.
>
> **Character Validity**
>
> A character literal that is empty (`''`), contains more than one Unicode scalar value after escape interpretation, or reaches end-of-file or a newline before the closing single-quote **MUST** be diagnosed as an error and **MUST** cause the compilation unit to be treated as ill-formed.

**_Diagnostic:_**

| Code         | Severity | Description                |
| :----------- | :------- | :------------------------- |
| `E-SRC-0302` | Error    | Invalid escape sequence.   |
| `E-SRC-0303` | Error    | Invalid character literal. |

#### 9.4.4 Boolean Literals [lexical.literals.boolean]

> **Boolean Keywords**
>
> The lexemes `true` and `false` **MUST** be tokenized as `<keyword>` tokens as specified in §9.2.1 and **MUST NOT** be treated as ordinary identifiers. Their spelling is case-sensitive: only the all-lowercase forms `true` and `false` **MUST** be accepted as boolean literals where the grammar admits a boolean literal.
>
> **Boolean Identifier Exclusion**
>
> Using `true` or `false` where an identifier is expected **MUST** be rejected with an error diagnostic. Implementations **MUST** ensure that the boolean-literal nonterminal in Appendix A and the keyword list in §9.2.1 remain consistent.

**_Diagnostic:_**

| Code         | Severity | Description                          |
| :----------- | :------- | :----------------------------------- |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier. |

### 9.5 Diagnostics Summary [lexical.diagnostics]

This chapter introduces the following diagnostics in the `SRC` (Source) category.

| Code         | Severity | Description                                                            |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `E-SRC-0204` | Error    | String literal exceeds limit (compile-time).                           |
| `E-SRC-0301` | Error    | Unterminated string literal.                                           |
| `E-SRC-0302` | Error    | Invalid escape sequence.                                               |
| `E-SRC-0303` | Error    | Invalid character literal.                                             |
| `E-SRC-0304` | Error    | Malformed numeric literal.                                             |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier.                                   |
| `E-SRC-0306` | Error    | Unterminated block comment.                                            |
| `E-SRC-0307` | Error    | Invalid Unicode in identifier.                                         |
| `E-SRC-0308` | Error    | Lexically sensitive Unicode character (Strict Mode).                   |
| `W-SRC-0301` | Warning  | Leading zeros in decimal literal.                                      |
| `W-SRC-0308` | Warning  | Lexically sensitive Unicode character in identifier or token boundary. |

---

## 10. Syntactic Structure [syntax]

This chapter defines the high-level syntactic structure of Cursive, focusing on compilation units, the declarations permitted at the top level of a source file, and implementation limits on syntactic nesting.

### 10.1 Compilation Units and Top-Level Items [syntax.toplevel]

A compilation unit is the fundamental building block of a Cursive program.

> **Compilation Unit Composition**
>
> A compilation unit MUST be the collection of all source files that constitute a single module, as defined in §8.3.1 [source.inclusion.units] and §11.2.1 [module.discovery].
>
> **Module Correspondence**
>
> Each compilation unit defines exactly one module. The path of the module is derived from its directory path, as specified in §11.2.2 [module.discovery].
>
> **Empty Modules**
>
> A compilation unit **MAY** be empty or contain only whitespace and comments. Such a unit defines a valid, empty module.

A compilation unit consists of a sequence of zero or more top-level items. These are the only constructs permitted at the module scope.

> **Top-Level Items**
>
> A top-level item **MUST** be one of the following kinds of declarations:
>
> *   `import` declaration
> *   `use` declaration
> *   `variable` declaration (`let`, `var`)
> *   `procedure` declaration
> *   `type` declaration (`record`, `enum`, `modal`)
> *   `trait` declaration
>
> **Forbidden Top-Level Constructs**
>
> Any other statement or expression, such as a control-flow construct (`if`, `loop`) or an expression statement, **MUST NOT** appear at the top level and **MUST** be diagnosed as an error.

Declarations at the top level are subject to specific visibility and uniqueness rules.

> **Visibility Defaults**
>
> 1.  A top-level item without an explicit visibility modifier (`public`, `internal`, `private`) **MUST** default to `internal` visibility.
> 2.  The names introduced by top-level items **MUST** be unique within the compilation unit. An attempt to redeclare an identifier in the same scope without using the `shadow` keyword **MUST** be diagnosed as an error.
> 3.  Module-level `let` and `var` bindings **MUST** be initialized before the program's entry point (`main`) is executed. The initialization order is determined by a dependency graph, and cycles **MUST** be diagnosed as an error.

Because Cursive employs a two-phase compilation model (§8.4), declarations within a single compilation unit may appear in any order.

> **Order Independence**
>
> Forward references to declarations within the same compilation unit **MUST** be permitted. An implementation **MUST** parse all top-level items before performing semantic analysis and name resolution.

### 10.2 Syntactic Nesting Limits [syntax.limits]

Implementations must enforce limits on the nesting depth of various syntactic constructs to ensure predictable resource consumption during parsing and analysis.

> **Nesting Limits**
>
> Conforming implementations **MUST** support at least the minimum guaranteed nesting limits defined in this section and **MUST** document their actual limits in the conformance dossier. Exceeding a documented limit **MUST** be diagnosed as an error and **MUST** render the compilation unit ill-formed.

#### 10.2.1 Block Nesting [syntax.limits.blocks]

> **Block Depth**
>
> The depth of nested block statements (e.g., `{ ... { ... } ... }`) **MUST** be limited. Conforming implementations **MUST** support a minimum nesting depth of 256 blocks.
>
> **Block Depth Diagnostic**
>
> If the nesting depth of blocks exceeds the implementation's documented limit, an error diagnostic **MUST** be emitted.

**_Diagnostic:_**

| Code         | Severity | Description                   |
| :----------- | :------- | :---------------------------- |
| `E-SYN-0101` | Error    | Block nesting depth exceeded. |

#### 10.2.2 Expression Nesting [syntax.limits.expressions]

> **Expression Depth**
>
> The depth of nested expressions (e.g., `a + (b * (c - d))`) **MUST** be limited. Conforming implementations **MUST** support a minimum nesting depth of 256 expressions.
>
> **Expression Depth Diagnostic**
>
> If the nesting depth of expressions exceeds the implementation's documented limit, an error diagnostic **MUST** be emitted.

**_Diagnostic:_**

| Code         | Severity | Description                        |
| :----------- | :------- | :--------------------------------- |
| `E-SYN-0102` | Error    | Expression nesting depth exceeded. |

### 10.3 Statement Termination [syntax.termination]

Cursive uses a grammar that allows for implicit statement termination via newlines, while also supporting explicit termination via semicolons.

> **Termination Rules**
>
> A **Statement** is terminated by one of the following:
>
> 1.  **Explicit Semicolon:** A semicolon token `;`.
> 2.  **Implicit Newline:** A `<newline>` token, provided that the line does not end in a way that signals continuation.
>
> **Line Continuation**
>
> **Line Continuation Rules:**
> A `<newline>` token is **ignored** (treated as whitespace) and does **not** terminate a statement if any of the following conditions are met:
>
> 1.  **Open Delimiter:** The newline appears inside an unclosed pair of parentheses `()`, brackets `[]`, or braces `{}`.
> 2.  **Trailing Operator:** The last non-comment token on the line is a binary operator (e.g., `+`, `-`, `*`, `&&`, `|`, etc.) or a separator (`,`).
> 3.  **Leading Dot:** The first non-comment token on the *following* line is a dot operator `.` or double-colon `::`.
>
> These rules allow for multi-line expressions and method chains without requiring backslash escapes.

### 10.4 Diagnostics Summary [syntax.diagnostics]

This chapter introduces the following diagnostics in the `SYN` (Syntax) category.

| Code         | Severity | Description                        |
| :----------- | :------- | :--------------------------------- |
| `E-SYN-0101` | Error    | Block nesting depth exceeded.      |
| `E-SYN-0102` | Error    | Expression nesting depth exceeded. |

# Part 3 - Module System and Name Resolution [part-3---module-system-and-name-resolution]

(This part defines code organization, imports, and scoping.)

## 11. Modules, Assemblies, and Projects [module.overview]

This chapter defines Cursive's organizational units: modules, assemblies, and projects. It specifies the formal rules for discovering these units from the file system and validating their configuration via a manifest file.

### 11.1 Core Definitions [module.definitions]

> **Project Definition**
>
> A **Project** is the top-level organizational unit, consisting of a collection of source files and a single manifest file, `Cursive.toml`, at its root. A project defines one or more assemblies.
>
> **Assembly Definition**
>
> An **Assembly** is a collection of modules that are compiled and distributed as a single unit. An assembly can be either a `library` or an `executable`. Each assembly is defined within the project manifest.
>
> **Module Definition**
>
> A **Module** is the fundamental unit of code organization and encapsulation. A module's contents are defined by the `.cursive` source files within a single directory, and its namespace is identified by a unique, filesystem-derived `module path`.

### 11.2 Module Discovery and Paths [module.discovery]

Cursive's module system is directly mapped to the filesystem. The compiler discovers modules by traversing the directory structure from a set of defined source roots.

#### 11.2.1 The Folder-as-Module Rule [module.discovery.the-folder-as-module-rule]

> **Folder-As-Module**
>
> Each directory within a declared source root that contains one or more `.cursive` files **MUST** be treated as a single module. All `.cursive` files located directly within that directory contribute their top-level declarations to that single module's namespace.

#### 11.2.2 Module Path Derivation [module.discovery.module-path-derivation]

> **Path Derivation**
>
> The `module path` for a given module **MUST** be derived from its directory path relative to the assembly's source root directory. Directory separators in the path **MUST** be replaced by the scope resolution operator `::`.

**_Formal Rule:_**
Let $P$ be the project context containing assembly definitions.
$$
\frac{P \vdash \text{assembly} \Rightarrow (\text{root\_path}, \_) \quad \text{dir\_path} = \text{absolute}(\text{module\_dir}) \quad \text{rel\_path} = \text{relative}(\text{dir\_path}, \text{root\_path})}{P \vdash \text{dir\_path} \Rightarrow \text{replace}(\text{rel\_path}, \text{PATH\_SEPARATOR}, "::")}
\tag{WF-Module-Path-Derivation}
$$

**_Explanation:_**
The judgment $P \vdash \text{dir\_path} \Rightarrow \text{module\_path}$ holds if the module path can be successfully derived. This requires resolving the absolute path of the assembly's source root and the module's directory, computing the relative path, and then replacing the filesystem separator (e.g., `/` or `\`) with `::`.

### 11.3 Project Manifest (`Cursive.toml`) [module.manifest]

Every project **MUST** be defined by a UTF-8 encoded manifest file named `Cursive.toml` at its root directory. The manifest **MUST** follow the TOML 1.0 syntax and be well-formed according to the rules in this section.

> **Manifest Requirement**
>
> An implementation **MUST** issue diagnostic `E-MOD-1101` if the `Cursive.toml` manifest is not found or is syntactically malformed.

#### 11.3.1 Manifest Well-Formedness [module.manifest.manifest-well-formedness]

> **Manifest Validity**
>
> A manifest is well-formed if all its required tables and keys are present and valid.

**_Formal Rule:_**
The judgment $\vdash M: WF$ holds if the manifest $M$ is well-formed.
$$
\frac{
    M \vdash \text{project}: WF \quad
    M \vdash \text{language}: WF \quad
    M \vdash \text{paths}: WF \quad
    \forall a \in M.\text{assemblies}, M \vdash a: WF
}{
    \vdash M: WF
}
\tag{WF-Manifest}
$$

#### 11.3.2 `[project]` Table [module.manifest.project-table]

> **Project Table**
>
> The `[project]` table **MUST** be present and contain `name` and `version` keys.

**_Formal rule:_**
$$
\frac{
    \text{name} \in M.\text{project} \quad \text{version} \in M.\text{project} \quad \vdash \text{name}: \text{Identifier} \quad \vdash \text{version}: \text{SemVer}
}{
    M \vdash \text{project}: WF
}
\tag{WF-Manifest-Project}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                             |
| :----------- | :------- | :---------------------------------------------------------------------- |
| `E-MOD-1107` | Error    | `[project]` table or its required keys (`name`, `version`) are missing. |

#### 11.3.3 `[language]` Table [module.manifest.language-table]

> **Language Table**
>
> The `[language]` table **MUST** be present and contain a `version` key compatible with the compiler.

**_Formal rule:_**
$$
\frac{
    \text{version} \in M.\text{language} \quad \vdash \text{version}: \text{SemVer} \quad \text{is\_compatible}(\text{version}, \text{compiler\_version})
}{
    M \vdash \text{language}: WF
}
\tag{WF-Manifest-Language}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                      |
| :----------- | :------- | :--------------------------------------------------------------- |
| `E-MOD-1109` | Error    | `[language]` table is missing, or its `version` is incompatible. |

#### 11.3.4 `[paths]` Table [module.manifest.paths-table]

> **Paths Table**
>
> The `[paths]` table **MUST** be present and contain at least one key-value pair mapping a symbolic name to a relative path.

**_Formal rule:_**
$$
\frac{
    |M.\text{paths}| \ge 1 \quad \forall (k, v) \in M.\text{paths}, \text{is\_valid\_path}(v)
}{
    M \vdash \text{paths}: WF
}
\tag{WF-Manifest-Paths}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                |
| :----------- | :------- | :--------------------------------------------------------- |
| `E-MOD-1102` | Error    | `[paths]` table in manifest is missing, empty, or invalid. |

#### 11.3.5 `[[assembly]]` Table [module.manifest.assembly-table]

> **Assembly Table**
>
> Each `[[assembly]]` table **MUST** define a unique assembly with a `name`, a valid `root` from the `[paths]` table, and a `path`.

**_Formal rule:_**
$$
\frac{
    a.\text{name} \in \text{identifiers} \quad a.\text{root} \in \text{dom}(M.\text{paths}) \quad \text{is\_valid\_path}(a.\text{path})
}{
    M \vdash a: WF
}
\tag{WF-Manifest-Assembly}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                              |
| :----------- | :------- | :----------------------------------------------------------------------- |
| `E-MOD-1103` | Error    | Assembly references a `root` that is not defined in the `[paths]` table. |
| `E-MOD-1108` | Error    | Duplicate assembly name found in `Cursive.toml`.                         |

### 11.4 Module Path Validity [module.paths]

Module paths are sequences of identifiers and are subject to validation.

**_Formal rule:_**
The judgment $\vdash p: WF_{path}$ holds if a path $p$ is well-formed.
$$
\frac{
    \forall c \in \text{components}(p), (\vdash c: \text{Identifier} \land \vdash c: \text{NotKeyword})
}{
    \vdash p: WF_{path}
}
\tag{WF-Module-Path}
$$

**_Explanation:_**
A module path is well-formed if and only if every component `c` of the path is a valid Cursive identifier (§9.3) and is not a reserved keyword (§9.2.1).

**_Diagnostic:_**

| Code         | Severity | Description                                              |
| :----------- | :------- | :------------------------------------------------------- |
| `E-MOD-1106` | Error    | Module path component is not a valid Cursive identifier. |
| `E-MOD-1105` | Error    | Module path component is a reserved keyword.             |

#### 11.4.1 Case-Sensitivity and Collisions [module.paths.case-sensitivity-and-collisions]

> **Case Insensitivity**
>
> On filesystems that are not case-sensitive, two file or directory names that differ only in case **MUST** be treated as ambiguous if they would resolve to the same module path component.

**_Formal rule:_**
Let $N(p)$ be the NFC-normalized, case-folded version of a path component $p$.
$$
\frac{
    \exists p_1, p_2 \in \text{project\_paths} \quad p_1 \neq p_2 \quad N(p_1) = N(p_2)
}{
    \text{Collision Error}
}
\tag{WF-Module-Path-Collision}
$$
**_Diagnostic:_**

| Code         | Severity | Description                                                      |
| :----------- | :------- | :--------------------------------------------------------------- |
| `E-MOD-1104` | Error    | Module path collision detected on a case-insensitive filesystem. |
| `W-MOD-1101` | Warning  | Potential module path collision on case-insensitive filesystems. |

### 11.5 Diagnostics Summary [module.diagnostics]

This chapter introduces the following diagnostics in the `MOD` (Module System) category.

| Code       | Severity | Description                                                              |
| :--------- | :------- | :----------------------------------------------------------------------- |
| E-MOD-1101 | Error    | Manifest file `Cursive.toml` not found or syntactically malformed.       |
| E-MOD-1102 | Error    | `[paths]` table in manifest is missing, empty, or invalid.               |
| E-MOD-1103 | Error    | Assembly references a `root` that is not defined in the `[paths]` table. |
| E-MOD-1104 | Error    | Module path collision detected on a case-insensitive filesystem.         |
| E-MOD-1105 | Error    | Module path component is a reserved keyword.                             |
| E-MOD-1106 | Error    | Module path component is not a valid Cursive identifier.                 |
| E-MOD-1107 | Error    | `[project]` table or its required keys (`name`, `version`) are missing.  |
| E-MOD-1108 | Error    | Duplicate assembly name found in `Cursive.toml`.                         |
| E-MOD-1109 | Error    | `[language]` table is missing, or its `version` is incompatible.         |
| W-MOD-1101 | Warning  | Potential module path collision on case-insensitive filesystems.         |


## 12. Visibility and Access Control [module.access]

This chapter specifies the formal rules for controlling access to declarations both within and between assemblies. It defines the visibility system, the rules for intra-assembly access, and the `import` and `use` declarations for managing inter-assembly dependencies and bringing items into scope.

### 12.1 Visibility Modifiers [module.visibility]

Every top-level declaration has a visibility level that controls its accessibility from other modules. If no modifier is specified, visibility defaults to `internal`.

> **Visibility Levels**
>
> 1.  **`public`**: The declaration is visible to any module in any assembly that depends on it. This is required for inter-assembly access.
> 2.  **`internal`**: (Default) The declaration is visible only to other modules within the **same assembly**.
> 3.  **`private`**: The declaration is visible only within its **defining module** (i.e., the source files in the same directory).
> 4.  **`protected`**: The declaration is visible only within its **defining type** and any `trait` implementation for that type.

**_Formal Rule:_**
Let the context $\Gamma$ contain the accessor module $m_{acc}$ and its assembly $a_{acc}$. Let the target item $i$ be defined in module $m_{def}$ within assembly $a_{def}$. The judgment $\Gamma \vdash \text{can\_access}(i)$ holds if access is permitted.

$$
\frac{\text{visibility}(i) = \text{public}}{\Gamma \vdash \text{can\_access}(i)}
\tag{WF-Access-Public}
$$

$$
\frac{\text{visibility}(i) = \text{internal} \quad a_{acc} = a_{def}}{\Gamma \vdash \text{can\_access}(i)}
\tag{WF-Access-Internal}
$$

$$
\frac{\text{visibility}(i) = \text{private} \quad m_{acc} = m_{def}}{\Gamma \vdash \text{can\_access}(i)}
\tag{WF-Access-Private}
$$


#### 12.1.4 The `protected` Modifier [module.visibility.the-protected-modifier]

`protected` visibility is designed for encapsulated extension. It restricts access to an item to the type's own implementation and to `trait` implementations for that type **within the same assembly**.

> **Protected Restriction**
>
> A `protected` modifier **MUST NOT** be used on a top-level (module-scope) declaration. It **MUST** only be applied to members (fields or procedures) within a `record`, `enum`, or `modal` declaration.
>
> **Protected Access**
>
> A `protected` item defined in type $T_{def}$ is accessible only from within the following contexts:
> 1.  The lexical scope of the definition of $T_{def}$.
> 2.  The lexical scope of any `trait` implementation for $T_{def}$, provided that the implementation resides in the **same assembly** as $T_{def}$.

**_Formal rule:_**
Let $item$ be a member defined in type $T_{def}$ with $\text{visibility}(item) = \text{protected}$. Let $\Gamma$ be the access context. Let $A(X)$ be the assembly containing definition $X$.

Access is permitted if the context $\Gamma$ is inside the definition of $T_{def}$:
$$
\frac{\Gamma \subseteq T_{def}}{\Gamma \vdash \text{can\_access}(item)}
\tag{WF-Access-Protected-Self}
$$

Access is permitted if the context $\Gamma$ is inside a `trait` implementation for $T_{def}$ within the same assembly:
$$
\frac{\Gamma \subseteq \text{trait } Tr \text{ for } T_{def} \quad A(\Gamma) = A(T_{def})}{\Gamma \vdash \text{can\_access}(item)}
\tag{WF-Access-Protected-Trait}
$$

**_Explanation:_**
This rule allows a `trait` implementation to access `protected` helper methods or fields necessary for its implementation, but restricts this privilege to code packaged within the same assembly. This prevents external code from breaking encapsulation by defining a dummy trait to access protected state.

### 12.2 Intra-Assembly Access [module.access.intra]

Modules within the same assembly are automatically available to each other for qualified name access without requiring an `import` declaration.

> **Internal Access**
>
> A declaration `item` in module `mod` within assembly `A` is accessible from another module in assembly `A` via the qualified path `mod::item` if and only if the visibility of `item` is `public` or `internal`.

### 12.3 Inter-Assembly Imports (The `import` Declaration) [module.import.declaration]

The `import` declaration declares a dependency on a module from an **external assembly**, making that module's public items available for qualified access. It is the primary mechanism for building the inter-assembly dependency graph.

#### 12.3.1 Syntax [module.import.declaration.syntax]

> **Import Syntax**
>
> An `import` declaration **MUST** conform to the following syntactic form:
>
> ```ebnf
> import_declaration ::= "import" <module_path> [ "as" <identifier> ]
> ```
>
> The `<module_path>` **MUST** resolve to a module within an external assembly listed as a dependency in the project manifest.

#### 12.3.2 Semantics [module.import.declaration.semantics]

> **Import Semantics**
>
> An `import` declaration serves two purposes:
>
> 1.  It establishes a dependency between the current assembly and the external assembly for the purposes of linking.
> 2.  It makes the imported module's `public` items available for qualified name resolution.
>
> If an alias is provided via `as <identifier>`, the alias **MUST** be used for qualified access. Otherwise, the last component of the module path is used.
>
> `import` declarations **DO NOT** bring any symbols into the local scope for unqualified access.

**_Formal rule:_**
Let $\Gamma$ be the scope context. The judgment $\Gamma \vdash \text{import}: WF$ holds if the import is well-formed.
$$
\frac{
    \Gamma \vdash \text{resolve\_external\_module}(\text{path}) \Rightarrow m \quad \text{alias} \notin \text{dom}(\Gamma)
}{
    \Gamma \vdash \text{import path as alias;}: WF
}
\tag{WF-Import-Module}
$$
**_Diagnostic:_**

| Code         | Severity | Description                                                              |
| :----------- | :------- | :----------------------------------------------------------------------- |
| `E-MOD-1201` | Error    | `import` path does not resolve to a known external module.               |
| `E-MOD-1203` | Error    | Name introduced by `use` or `import as` conflicts with an existing item. |

### 12.4 Item Scoping (The `use` Declaration) [module.use.declaration]

The `use` declaration brings one or more items from an already-accessible module (either intra-assembly or imported inter-assembly) into the current scope, allowing for *unqualified access*. It is a tool for ergonomic convenience and does not establish a new module dependency.

#### 12.4.1 Syntax [module.use.declaration.syntax]

> **Use Syntax**
>
> A `use` declaration **MUST** conform to one of the following syntactic forms:
>
> ```ebnf
> use_declaration ::= [ "public" ] "use" <use_clause>
>
> use_clause ::= <qualified_path> [ "as" <identifier> ]
>              | <qualified_path> "::" "{" <use_list> "}"
>              | <qualified_path> "::" "*"
>
> use_list ::= <use_specifier> ("," <use_specifier>)* ","?
>
> use_specifier ::= <identifier> [ "as" <identifier> ]
>                 | "self"
> ```
> The `<qualified_path>` **MUST** refer to an accessible module (intra-assembly) or a module made available by an `import` declaration (inter-assembly).

#### 12.4.2 Semantics [module.use.declaration.semantics]

> **Use Semantics**
>
> A `use` declaration creates a local alias for one or more items from another module.
>
> *   **Item Use:** `use path::to::Item;` brings `Item` into the local scope.
> *   **Item Aliasing:** `use path::to::Item as MyItem;` brings `Item` into the local scope under the name `MyItem`.
> *   **List Use:** `use path::to::{Item1, Item2};` brings multiple items into scope. The special item `self` in a list refers to the module path itself, allowing for both qualified and unqualified access from a single statement (e.g., `use my_module::{self, Item1};`).
> *   **Wildcard Use:** `use path::to::*;` brings all accessible items from the target module into scope. This form is discouraged in public APIs and **SHOULD** trigger a warning (`W-MOD-1201`).

**_Formal rule:_**
$$
\frac{
    \Gamma \vdash \text{resolve\_item}(\text{path}::i) \Rightarrow \text{item} \quad \Gamma \vdash \text{can\_access}(\text{item}) \quad \text{name} \notin \text{dom}(\Gamma)
}{
    \Gamma \vdash \text{use path}::i \text{ as name;}: WF
}
\tag{WF-Use-Item}
$$
**_Diagnostic:_**

| Code         | Severity | Description                                                              |
| :----------- | :------- | :----------------------------------------------------------------------- |
| `E-MOD-1202` | Error    | `use` path does not resolve to an accessible module.                     |
| `E-MOD-1204` | Error    | Item specified in `use` path is not found or is not visible.             |
| `E-MOD-1203` | Error    | Name introduced by `use` or `import as` conflicts with an existing item. |

### 12.5 Re-exporting with `public use` [module.reexport]

> **Re-exporting**
>
> A `use` declaration prefixed with the `public` modifier re-exports an item, making it part of the current module's public API.

**_Formal rule:_**
The judgment for a `public use` requires that the used item itself is public.
$$
\frac{
    \Gamma \vdash \text{use path}::i \text{ as name;}: WF \quad \text{visibility}(\text{item}) = \text{public}
}{
    \Gamma \vdash \text{public use path}::i \text{ as name;}: WF
}
\tag{WF-Use-Public}
$$

> **_Explanation:_**
> A `public use` is well-formed only if the underlying `use` is well-formed and the source item's visibility is `public`. This prevents leaking `internal` or `private` items into a public API.

**_Diagnostic:_**

| Code         | Severity | Description                                                    |
| :----------- | :------- | :------------------------------------------------------------- |
| `E-MOD-1205` | Error    | Attempt to `public use` a non-public item from another module. |

### 12.6 Diagnostics Summary [module.diagnostics]

This chapter introduces the following diagnostics.

| Code       | Severity | Description                                                              |
| :--------- | :------- | :----------------------------------------------------------------------- |
| E-MOD-1201 | Error    | `import` path does not resolve to a known external module.               |
| E-MOD-1202 | Error    | `use` path does not resolve to an accessible module.                     |
| E-MOD-1203 | Error    | Name introduced by `use` or `import as` conflicts with an existing item. |
| E-MOD-1204 | Error    | Item specified in `use` path is not found or is not visible.             |
| E-MOD-1205 | Error    | Attempt to `public use` a non-public item from another module.           |
| E-MOD-1206 | Error    | Duplicate item in a `use` list.                                          |
| E-MOD-1207 | Error    | Cannot access a `protected` item from this scope.                        |
| W-MOD-1201 | Warning  | Wildcard `use` (`*`) is discouraged in public APIs.                      |

## 13. Names, Scopes, and Resolution [names]

This chapter provides the formal definition of Cursive's name resolution system, including namespaces, lexical scoping, and the algorithms for name lookup.

### 13.1 Namespaces [names.namespaces]

> **Unified Namespace**
>
> Cursive **MUST** be implemented with a single, unified namespace per scope.
> An identifier's meaning is determined only by its spelling and the scope in which it is defined, not by the syntactic context of its use.
> This single namespace **MUST** be shared by all declaration kinds, including:
>
> 1. Terms: Bindings for variables, constants, and procedures.
> 2. Types: Bindings for type declarations (record, enum, modal, type, trait).
> 3. Modules: Bindings for module import aliases.
>
> A type declaration (e.g., record Point) and a term declaration (e.g., let Point) **MUST NOT** share the same identifier in the same scope.

### 13.2 Scope Context [names.scopes]

A scope is a region of source text where a set of names is valid. Scopes are lexically nested. The active scopes are represented by a scope context, $\Gamma$.
The scope context $\Gamma$ is an ordered list of mappings, from innermost to outermost: $\Gamma = [S_{local}, S_{proc}, S_{module}, S_{universe}]$. Each $S$ maps identifiers to entities.

### 13.3 Name Introduction and Shadowing [names.shadowing]

This chapter defines how names are introduced into a scope's unified namespace and specifies the rules for explicit, safe shadowing.

#### 13.3.1 Name Introduction (Redeclaration in Same Scope) [names.shadowing.name-introduction-redeclaration-in-same-scope]

> **Uniqueness**
>
> A name is introduced into a scope by a declaration. A declaration that introduces an identifier $x$ into the current scope $S_{curr}$ **MUST** be well-formed only if $x$ is not already bound in $S_{curr}$.

**_Formal rule:_**

$$
\frac{x \notin \text{dom}(S_{curr})}{ \Gamma \vdash \text{declare } x: WF }
\tag{WF-Declaration}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                       |
| :----------- | :------- | :---------------------------------------------------------------- |
| `E-NAM-1302` | Error    | Duplicate name: the identifier is already declared in this scope. |

#### 13.3.2 Explicit Shadowing (Redeclaration in Nested Scope) [names.shadowing.explicit-shadowing-redeclaration-in-nested-scope]

> **Shadowing**
>
> A declaration in an inner, nested scope **MAY** shadow a name from an outer scope.
>
> 1.  **Explicit Shadowing:** Prefixing the declaration with the `shadow` keyword explicitly signals the intent to shadow. This is always permitted.
> 2.  **Implicit Shadowing:** Shadowing without the `shadow` keyword is discouraged.
>
> **Conformance Mode Behavior:**
> *   In **Permissive Mode**, implicit shadowing **MUST** trigger warning `W-NAM-1303`.
> *   In **Strict Mode**, implicit shadowing **MUST** be treated as an error `E-NAM-1303`.

**_Formal rules:_**
Let $S_{inner}$ be a scope nested within an outer scope $S_{outer}$. Let $x$ be an identifier such that $x \in \text{dom}(S_{outer})$.

$$
\frac{
x \in \text{dom}(S\_{outer}) \quad x \notin \text{dom}(S\_{inner})
}{
\Gamma \vdash \text{shadow declare } x \text{ in } S\_{inner}: WF
}
\tag{WF-Shadow-Success}
$$

$$
\frac{
x \notin \text{dom}(S\_{outer})
}{
\Gamma \vdash \text{shadow declare } x \text{ in } S\_{inner}: \text{Ill-Formed}
}
\tag{WF-Shadow-Unnecessary}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                            |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `W-NAM-1303` | Warning  | Shadowing existing binding without `shadow` keyword (Permissive Mode). |
| `E-NAM-1303` | Error    | Shadowing existing binding without `shadow` keyword (Strict Mode).     |
| `E-NAM-1306` | Error    | Unnecessary use of `shadow` keyword.                                   |

***Example:***

```cursive
let x: i32 = 10

procedure test() {
    // Inner scope
    
    // VALID: Explicitly shadows 'x'
    shadow let x: string = "hello"

    // IMPLICIT SHADOWING:
    // Triggers W-NAM-1303 (Permissive) or E-NAM-1303 (Strict)
    // let x = 20 
}
```

### 13.4 Name Lookup (Resolution) [names.lookup]

Name lookup is the process of finding the entity to which an identifier refers.

#### 13.4.1 Unqualified Name Lookup [names.lookup.unqualified-name-lookup]

Unqualified lookup searches the scope context from innermost to outermost.

**_Formal rule:_**
The judgment $\Gamma \vdash x \Rightarrow \text{entity}$ holds if the identifier $x$ resolves to an entity in context $\Gamma$. Let $\Gamma = [S_0, S_1, \dots, S_n]$.

$$
\frac{x \in \text{dom}(S_0)}{\Gamma \vdash x \Rightarrow S_0(x)}
\tag{QR-Lookup-Local}
$$

$$
\frac{x \notin \text{dom}(S_0) \quad [S_1, \dots, S_n] \vdash x \Rightarrow \text{entity}}{\Gamma \vdash x \Rightarrow \text{entity}}
\tag{QR-Lookup-Outer}
$$

**_Explanation:_**
The first rule states that if the name $x$ is found in the innermost scope ($S_0$), the lookup succeeds. The second rule states that if it is not found, the search continues in the parent context (the rest of the list). If the context is exhausted and the name is not found, the lookup fails.

**_Diagnostic:_**

| Code         | Severity | Description                                                      |
| :----------- | :------- | :--------------------------------------------------------------- |
| `E-NAM-1301` | Error    | Unresolved name: cannot find identifier in any accessible scope. |

#### 13.4.2 Qualified Name Lookup [names.lookup.qualified-name-lookup]

Qualified lookup resolves a path of identifiers, such as `A::B::C`.

**_Formal rule:_**
The judgment $\Gamma \vdash p::i \Rightarrow \text{entity}$ holds if the qualified path resolves.

$$
\frac{\Gamma \vdash p \Rightarrow m \quad m \vdash i \Rightarrow \text{entity} \quad \Gamma \vdash \text{can\_access}(\text{entity})}{\Gamma \vdash p::i \Rightarrow \text{entity}}
\tag{QR-Lookup-Qualified}
$$

**_Explanation:_**
To resolve a path `p::i`, the prefix `p` must first resolve to a module `m`. Then, the identifier `i` must resolve to a member of `m`. Finally, that member must be accessible from the current scope according to the visibility rules in Chapter 12.

**_Diagnostic:_**

| Code         | Severity | Description                                                                                    |
| :----------- | :------- | :--------------------------------------------------------------------------------------------- |
| `E-NAM-1304` | Error    | Unresolved module: a path prefix did not resolve to a module.                                  |
| `E-NAM-1305` | Error    | Unresolved or private item in path: an item in a qualified path is not found or is not public. |

### 13.5 Diagnostics Summary [names.diagnostics]

This chapter introduces the following diagnostics in the `NAM` category.

| Code       | Severity | Description                                                                                    |
| :--------- | :------- | :--------------------------------------------------------------------------------------------- |
| E-NAM-1301 | Error    | Unresolved name: cannot find identifier in any accessible scope.                               |
| E-NAM-1302 | Error    | Duplicate name: the identifier is already declared in this scope.                              |
| E-NAM-1304 | Error    | Unresolved module: a path prefix did not resolve to a module.                                  |
| E-NAM-1305 | Error    | Unresolved or private item in path: an item in a qualified path is not found or is not public. |

## 14. Initialization [initialization]
This chapter defines the formal rules for the initialization of modules and module-level variable bindings. It specifies the construction of the module dependency graph, the classification of dependencies, the requirement for acyclicity in eager dependencies, and the runtime semantics of initialization order and failure.

### 14.1 Module Initialization [initialization.overview]

> **Initialization Stages**
>
> Module initialization is the process of evaluating the initializers for all module-level let and var bindings. This process MUST be divided into two stages:
>
> 1. Static Initialization: Initializers that are compile-time constants (e.g., literals, comptime values) MUST be evaluated at compile time and stored in the program's data section.
>
> 2. Dynamic Initialization: Initializers requiring runtime execution (e.g., procedure calls or values requiring capabilities like HeapAllocator) MUST be executed after program startup and after the Context capability has been provided, but before the main procedure body executes.

The order of dynamic initialization is determined by the eager dependency graph specified in §14.3.

### 14.2 The Module Dependency Graph [initialization.graph]

The relationships between modules are represented by a Module Dependency Graph (MDG).

The MDG is a directed graph $G = (V, E)$, where:
1. $V$ is the set of all modules in the program and its compiled dependencies.
2. $E$ is a set of directed edges $(A, B)$, where an edge from module $A$ to module $B$ signifies that $A$ depends on $B$.

**Edge Classification:**
Each edge in $E$ is classified as either **Type-Level** or **Value-Level** based on the nature of the reference.

1.  **Value-Level Edge ($A \xrightarrow{val} B$):** Exists if module $A$ contains an expression that evaluates a binding defined in module $B$ at runtime or initialization time.
2.  **Type-Level Edge ($A \xrightarrow{type} B$):** Exists if module $A$ refers to a type, trait, or constant signature defined in module $B$ but does not evaluate it.

***Formal Rule:***
$$
\frac{
\exists e \in \text{exprs}(A), \text{refers\_to\_value}(e, B)
}{
(A, B) \in E, \text{class}((A, B)) = \text{Value-Level}
}
\tag{WF-Dep-Value}
$$

### 14.3 Dependency Classification and Cycles [initialization.order]

To manage initialization, the graph edges are mapped to **eager** and **lazy** dependencies.

#### 14.3.1 Eager Dependencies [initialization.order.eager-dependencies]

> **Eager Edges**
>
> An edge $(A, B)$ is **eager** if it is a **Value-Level Edge** originating from a module-level initializer expression.
>
> $$ (A, B) \text{ is Eager} \iff A \xrightarrow{val} B \land \text{origin}(A \xrightarrow{val} B) \in \text{initializers}(A) $$
>
> This explicitly includes:
> *   Calling a function from $B$ in a `let`/`var` initializer in $A$.
> *   Reading a global variable from $B$ in a `let`/`var` initializer in $A$.

#### 14.3.2 Lazy Dependencies [initialization.order.lazy-dependencies]

> **Lazy Edges**
>
> An edge $(A, B)$ is **lazy** if it is a **Type-Level Edge** or if it is a **Value-Level Edge** that occurs only within procedure bodies (not initializers).
>
> $$ (A, B) \text{ is Lazy} \iff (A, B) \text{ is not Eager} $$

#### 14.3.3 Acyclic Eager Subgraph Requirement [initialization.order.acyclic-eager-subgraph-requirement]

> **Acyclicity**
>
> The initialization order of modules is derived *only* from the subgraph of eager dependencies.
>
> The subgraph $G_e = (V, E_e)$, containing all modules $V$ and only the set of eager edges $E_e$, **MUST** be a Directed Acyclic Graph (DAG). An implementation **MUST** detect cycles in this eager subgraph.

**_Formal rule:_**
The judgment $\vdash G_e: \text{DAG}$ holds if the eager subgraph $G_e$ is acyclic.

$$
\frac{
\forall v \in V, \neg \text{is\_reachable}(v, v, E\_e)
}{
\vdash G\_e: \text{DAG}
}
\tag{WF-Acyclic-Eager-Deps}
$$

Where $\text{is\_reachable}(u, v, E_e)$ is true if there is a path of one or more eager edges from $u$ to $v$.

**_Diagnostic:_**

| Code         | Severity | Description                                                  |
| :----------- | :------- | :----------------------------------------------------------- |
| `E-MOD-1401` | Error    | Cyclic module dependency detected in **eager** initializers. |

### 14.4 Initialization Semantics [initialization.semantics]

The runtime **MUST** adhere to the initialization order computed from the eager dependency graph.

> **Execution Order**
>
> Before the program's `main` procedure is invoked, the runtime **MUST**:
>
> 1.  Take a valid topological sort of modules based on the **eager dependency graph** $G_e$.
> 2.  For each module in the sorted list, execute the initializers for all module-level bindings in the order they appear within that module's source files.

**_Explanation:_**
Because only the eager graph is used for sorting, modules with only lazy dependencies between them (e.g., `A` uses `B`'s types, `B` uses `A`'s types) will not cause a cycle error and will be initialized in a valid, implementation-defined topological order.

### 14.5 Initialization Failure [initialization.failure]

> **Failure Semantics**
>
> If the evaluation of any module-level initializer terminates with a panic, the initialization of that module is considered to have failed.
>
> If the initialization of a module $M$ fails, the program state is considered "poisoned." Any subsequent attempt at runtime to access a binding from module $M$, or from any module that has an **eager dependency** path from $M$, **MUST** also result in a panic.

**_Explanation:_**
This rule ensures that initialization failures are fail-stop and do not lead to undefined behavior from using partially initialized modules. The program is guaranteed to terminate predictably rather than continue in an inconsistent state.

### 14.6 Diagnostics Summary [initialization.diagnostics]

This chapter introduces the following diagnostics in the `MOD` (Module System) category.

| Code       | Severity | Description                                                  |
| :--------- | :------- | :----------------------------------------------------------- |
| E-MOD-1401 | Error    | Cyclic module dependency detected in **eager** initializers. |

---

# Part 4 - The Type System [part-4---the-type-system]

(This part defines all types and their properties.)

## 15. Type System Foundations [type.foundations]

This chapter establishes the foundational principles of the Cursive type system. It defines the core classification of the system, the rules for type equivalence and relationships, guarantees regarding memory layout, and the mechanism of type inference. These principles govern the behavior of all types defined in subsequent chapters of this Part.

### 15.1 Static, Nominal, and Structural Typing [type.foundations.classification]

> **Static Typing Requirement**
>
> Cursive **MUST** be implemented as a **statically typed** language. All type checking **MUST** be performed at compile time. A program that fails type checking **MUST** be diagnosed as ill-formed and rejected.

**_Diagnostic:_**

| Code         | Severity | Description                                   |
| :----------- | :------- | :-------------------------------------------- |
| `E-TYP-1501` | Error    | Type mismatch or other type checking failure. |

The type system is primarily **nominal**. Types defined with `record`, `enum`, and `modal` declarations are distinct based on their declared name and origin. Two types with different names are never equivalent, even if their structure is identical.

Certain built-in types are **structural**. Their equivalence is determined by their composition rather than a declared name. Structural types in Cursive include tuples, anonymous union types, and function types.

### 15.2 Type Equivalence [type.foundations.equivalence]

> **Equivalence Definition**
>
> Two types, `T` and `U`, are considered **equivalent**, written `T ≡ U`, if and only if one of the rules in this section holds. Type equivalence **MUST** be reflexive, symmetric, and transitive.

**_Formal Rule (Nominal Equivalence):_**
Let `D(N)` be the declaration for a nominal type with name `N`.

$$
\frac{
    D(T_{name}) = \text{decl}_1 \quad D(U_{name}) = \text{decl}_2 \quad \text{decl}_1 \text{ is the same declaration as } \text{decl}_2
}{
    \Gamma \vdash T \equiv U
}
\tag{T-Equiv-Nominal}
$$

**_Explanation:_**
Two nominal types are equivalent if and only if they refer to the same declaration.

**_Formal Rule (Structural Equivalence):_**
The following rules apply to structural types:

$$
\frac{
    T = (T_1, \dots, T_n) \quad U = (U_1, \dots, U_n) \quad \forall i \in 1..n, \Gamma \vdash T_i \equiv U_i
}{
    \Gamma \vdash T \equiv U
}
\tag{T-Equiv-Tuple}
$$

$$
\frac{
    T = (T_{p1}, \dots, T_{pn}) \to T_{ret} \quad U = (U_{p1}, \dots, U_{pn}) \to U_{ret} \quad \Gamma \vdash T_{ret} \equiv U_{ret} \quad \forall i \in 1..n, \Gamma \vdash T_{pi} \equiv U_{pi}
}{
    \Gamma \vdash T \equiv U
}
\tag{T-Equiv-Func}
$$

$$
\frac{
    \text{multiset\_equiv}(\text{members}(T), \text{members}(U))
}{
    \Gamma \vdash T \equiv U
}
\tag{T-Equiv-Union}
$$

**_Explanation:_**
Two structural types (tuples, function types, anonymous unions) are equivalent if they have the same shape and their corresponding component types are equivalent. For union types, the order of members does not affect equivalence.

**_Formal Rule (Permission Equivalence):_**

$$
\frac{
    P_1 = P_2 \quad \Gamma \vdash T \equiv U
}{
    \Gamma \vdash P_1~T \equiv P_2~U
}
\tag{T-Equiv-Permission}
$$

**_Explanation:_**
Permissions are part of the type. Two permission-qualified types are equivalent only if both their base types and their permissions are identical. For example, `unique MyRecord` is not equivalent to `const MyRecord`.

### 15.3 Subtyping and Coercion [type.foundations.subtyping]

> **Subtyping Definition**
>
> A type `T` is a **subtype** of a type `U`, written `T <: U`, if a value of type `T` can be used in any context where a value of type `U` is expected. An expression of a subtype **MAY** be implicitly converted to a supertype; this conversion is called **coercion**.

**_Formal Rule (Coercion):_**

$$
\frac{
    \Gamma \vdash e : T \quad \Gamma \vdash T <: U
}{
    \Gamma \vdash e : U
}
\tag{T-Coerce-Subtype}
$$
**_Explanation:_**
The primary subtyping relationships in Cursive are:

1.  **Permissions:** A type with a more restrictive permission is a subtype of the same type with a less restrictive permission. The hierarchy is `unique` -> `const` and `partitioned` -> `const`. (See §16.4 for details).
    $$
    \frac{}{\Gamma \vdash \text{unique } T <: \text{const } T} \quad \frac{}{\Gamma \vdash \text{partitioned } T <: \text{const } T}
    \tag{T-Subtype-Perm}
    $$
2.  **Trait Implementation:** A concrete type `T` that implements a trait `Tr` is a subtype of that trait. This allows a value of type `T` to be coerced to a **witness** of type `Tr`.
    $$
    \frac{
        \Gamma \vdash T \text{ implements } Tr
    }{
        \Gamma \vdash T <: Tr
    }
    \tag{T-Subtype-Trait}
    $$
3.  **The Never Type:** The never type `!` is a subtype of all other types (the "bottom" type). This allows an expression that never returns (e.g., a `panic`) to be used in any context, regardless of the expected type.
    $$
    \frac{
        \text{is\_type}(T)
    }{
        \Gamma \vdash ! <: T
    }
    \tag{T-Subtype-Never}
    $$

### 15.4 Type Layout [type.foundations.layout]

> **Layout Constraints**
>
> The precise size, alignment, and memory representation of types are generally **implementation-defined behavior (IDB)**. Conforming implementations **MUST** document their type layout strategy for each supported target platform in the conformance dossier (Appendix C).
>
> The `[[repr(C)]]` attribute, when applied to a `record` or `enum` declaration, **MUST** direct the implementation to produce a C-compatible memory layout as defined by the target platform's C ABI.
>
> While specific layouts are implementation-defined, the following minimum guarantees **MUST** hold:
>
> *   The size of a `record` is at least the sum of the sizes of its fields.
> *   The size of an `enum` is at least the size of its tag plus the size of its largest variant.
> *   The size of an array `[T; N]` is at least `N` times the size of `T`.
> *   The alignment of a composite type is at least as great as the largest alignment of any of its fields.

### 15.5 Bidirectional Type Inference [type.foundations.inference]

The Cursive type checker operates using a **bidirectional** algorithm. For any given expression, the compiler either **synthesizes** a type (flowing "up" from the expression) or **checks** the expression against an expected type (flowing "down" into the expression).

**Synthesis Mode:** The compiler infers the type of an expression without any outside context. This applies to literals (`123` synthesizes `i32` by default), primitive operations (`a + b`), and calls to procedures with fully-annotated return types.

**Checking Mode:** The compiler verifies that an expression conforms to a known, expected type. This mode is activated by contexts that provide type information, such as variable declarations with explicit types (`let x: string@View = ...`), procedure arguments, and procedure return statements.

> **Explicit Signatures**
>
> All procedure signatures at module scope **MUST** have fully explicit type annotations for all parameters and the return type. Type inference **MUST NOT** operate across public procedure boundaries.

**_Explanation:_**
Bidirectional inference allows for the omission of type annotations within procedure bodies where the type can be unambiguously determined, while maintaining strict type safety and clarity at API boundaries.

### 15.6 Variance and Polarity [type.foundations.variance]

To ensure type safety in the presence of generics and permissions, the compiler **MUST** assign a **Polarity** (Variance) to every generic parameter of a type based on how that parameter is used in the type's definition.

#### 15.6.1 Polarity Inference [type.foundations.variance.polarity-inference]

> **Polarity Inference**
>
> The compiler **MUST** infer polarity for a parameter T in type Type\<T\> as follows:
>
> 1. **Covariant (+):** T appears *only* in "output" positions (field types of const fields, return types of methods).
> 2. **Contravariant (-):** T appears *only* in "input" positions (method parameters).
> 3. **Invariant (=):** T appears in both, or in a mutable field (var field or unique path).
> 4. **Bivariant (\*):** T is unused (phantom data).

#### 15.6.2 Subtyping of Generics [type.foundations.variance.subtyping-of-generics]

> **Generic Subtyping**
>
> The subtyping relationship $\Gamma \vdash Name<A> <: Name<B>$ holds if and only if for every parameter $T_i$ with polarity $P_i$:
>
> * If $P_i$ is **Covariant (+)**: $\Gamma \vdash A_i <: B_i$
> * If $P_i$ is **Contravariant (-)**: $\Gamma \vdash B_i <: A_i$
> * If $P_i$ is **Invariant (=)**: $\Gamma \vdash A_i \equiv B_i$

Permission Interaction:  
Crucially, the const permission allows treating Invariant fields as Covariant.  
$$\frac{\Gamma \vdash A <: B}{\Gamma \vdash \text{const } List<A> <: \text{const } List<B>}$$
$$\frac{A \not\equiv B}{\Gamma \nvdash \text{unique } List<A> <: \text{unique } List<B>}$$

***Explanation:*** A unique List<Dog> cannot be treated as unique List<Animal> because the latter would allow appending a Cat, violating the memory safety of the original list. However, a read-only const List<Dog> *can* be treated as const List<Animal>.

### 15.7 Diagnostics Summary [type.foundations.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code         | Severity | Description                                   |
| :----------- | :------- | :-------------------------------------------- |
| `E-TYP-1501` | Error    | Type mismatch or other type checking failure. |

## 16. Permission Types [type.permissions]

This chapter defines Cursive's permission system. Permissions are **type qualifiers** that are fundamental to the language's memory safety guarantees. They govern how the **data** referenced by a binding may be accessed, mutated, and aliased. If no permission is explicitly written, `const` is the default.

The Permission System is distinct from and orthogonal to two other concepts:

  * It does **not** govern **binding mutability** (whether a binding can be re-assigned). That is controlled by `let` (immutable binding) and `var` (mutable binding) declarations.
  * It does **not** govern **cleanup responsibility** (RAII). That is controlled by responsibility and `move` semantics.

### 16.1 The Permission Lattice [type.permissions.lattice]

Permissions form a strict subtyping hierarchy based on the restrictiveness of the guarantees they provide. This hierarchy is known as the **Permission Lattice**.

$$
\text{unique} <: \text{partitioned} <: \text{const}
$$

1.  **Subtyping Rule:** A value with a stronger permission **MAY** be used in a context expecting a weaker permission. This is an implicit coercion.
    *   `unique` coerces to `partitioned`.
    *   `unique` coerces to `const`.
    *   `partitioned` coerces to `const`.
2.  **No Upgrade:** A value with a weaker permission **MUST NOT** be implicitly coerced to a stronger permission.
3.  **Transitivity:** Subtyping is transitive.

### 16.2 The `const` Permission (Default) [type.permissions.const]

The `const` permission grants **Read-Only** access to the subject and allows **Unlimited Aliasing**.

> **Const Guarantees**
>
> 1.  **Immutability:** An expression whose type has the `const` permission **MUST NOT** be used to directly mutate the data it represents. Any attempt to do so **MUST** be diagnosed as a compile-time error.
> 2.  **Aliasing:** Implementations **MUST** allow any number of bindings or references whose types have `const` permission to the same data to coexist simultaneously.
> 3.  **No Interior Mutability:** Cursive prohibits "interior mutability" (mutation through a const reference) in safe code. Mutation **ALWAYS** requires a path with `unique` or `partitioned` permission.

**_Diagnostic:_**

| Code         | Severity | Description                                     |
| :----------- | :------- | :---------------------------------------------- |
| `E-TYP-1601` | Error    | Attempt to mutate data via a `const` reference. |

**_Explanation:_**
`const` provides aliased, read-only access to data. It is the foundation for sharing data without data races. A `let` binding (immutable binding) can refer to `unique` data (mutable data), and a `var` binding (mutable binding) can refer to `const` data (immutable data).

### 16.3 The `unique` Permission (Static Exclusion) [type.permissions.unique]

The `unique` permission qualifies a type to grant exclusive, mutable access to data. It is a zero-cost mechanism for guaranteeing that there is only ever one path to mutate a piece of data.

> **Unique Guarantees**
>
> 1.  **Static Exclusion:** The existence of a live `unique` path to an object statically precludes the liveness of any other path (const, unique, or partitioned) to that same object or its sub-components. The compiler **MUST** reject the formation of any alias to an object while a `unique` type to that object remains active.
> 2.  **Mutation:** A binding of type `unique T` allows mutation of $T$.
> 3.  **Downgrading:** A `unique` type may be temporarily downgraded to `const` or `partitioned` for a bounded scope (e.g., passing to a procedure). During this scope, the original `unique` type is considered **inactive** and cannot be used. When the downgrade scope ends, the original type regains `unique` status.

**_Diagnostic:_**

| Code         | Severity | Description                                          |
| :----------- | :------- | :--------------------------------------------------- |
| `E-TYP-1602` | Error    | Violation of `unique` exclusion (aliasing detected). |

**_Explanation:_**
The `unique` permission guarantees a single writer, preventing data races at compile time. While it holds the exclusive right to mutate, it can temporarily lend out read-only `const` views of the data.

### 16.4 The `partitioned` Permission (Aliased Mutability) [type.permissions.partitioned]

The `partitioned` permission qualifies a type to explicitly allow aliased mutability, where multiple pointers to mutable data can coexist.

> **Partitioned Guarantees**
>
> 1.  **Access:** A binding of type `partitioned T` allows mutation of $T$.
> 2.  **Aliasing:** Multiple `partitioned` paths to the same object **MAY** coexist simultaneously.
> 3.  **Constraint:** Data referenced through a type with `partitioned` permission **MAY** be mutated through multiple coexisting pointers, but all such access **MUST** be validated by the **Partitioning System** defined in Part 6, §29.3 [memory.partitioning]. An access that violates the rules of the Partitioning System **MUST** be diagnosed as a compile-time error.

**_Diagnostic:_**

| Code         | Severity | Description                    |
| :----------- | :------- | :----------------------------- |
| `E-TYP-1603` | Error    | Partitioning system violation. |

**_Explanation:_**
`partitioned` signals to the compiler that this data requires special static analysis to ensure safety. It is used for complex data structures where different parts of the structure need to be mutated independently.

### 16.5 Diagnostics Summary [type.permissions.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code         | Severity | Description                                          |
| :----------- | :------- | :--------------------------------------------------- |
| `E-TYP-1601` | Error    | Attempt to mutate data via a `const` reference.      |
| `E-TYP-1602` | Error    | Violation of `unique` exclusion (aliasing detected). |
| `E-TYP-1603` | Error    | Partitioning system violation.                       |

## 17. Primitive Types [type.primitive]

This chapter defines the primitive scalar types that are built into the Cursive language. These types form the basis for all other types and represent the fundamental units of data.

### 17.1 Integer Types [type.primitive.integer]

Cursive provides a range of integer types of varying sizes, with both signed and unsigned variants.

> **Integer Types**
>
> The integer types are:
>
> *   **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `i128`
> *   **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `u128`
> *   **Pointer-Sized Integers:** `isize`, `usize`
>
> The number in each type name indicates its bit width. Signed integers (`iN`) **MUST** be represented using two's complement. The pointer-sized integers `isize` and `usize` **MUST** have the same bit width as a memory pointer on the target architecture.
>
> The keyword `int` **MUST** be treated as a transparent alias for the type `i32`. The types specified by `int` and `i32` are fully equivalent in all contexts.
>
> The keyword `uint` **MUST** be treated as a transparent alias for the type `u32`. The types specified by `uint` and `u32` are fully equivalent in all contexts.

**_Arithmetic Overflow:_**
> **Arithmetic Overflow**
>
> The behavior of arithmetic operations (`+`, `-`, `*`) on integer types upon overflow is implementation-defined. However, conforming implementations **MUST** provide a build mode (e.g., a debug or checked mode) in which integer overflow causes the executing thread to panic. In release or optimized builds, implementations **MAY** allow overflow to wrap, as documented in their conformance dossier.

**_Operators:_**
Integer types support standard arithmetic (`+`, `-`, `*`, `/`, `%`), bitwise (`&`, `|`, `^`, `<<`, `>>`), and comparison (`==`, `!=`, `<`, `<=`, `>`, `>=`) operators.

### 17.2 Floating-Point Types [type.primitive.float]

Cursive provides three floating-point types.

> **Floating-Point Types**
>
> The floating-point types are `f16`, `f32`, and `f64`.
>
> The keyword `half` **MUST** be treated as a transparent alias for the type `f16`. The types specified by `half` and `f16` are fully equivalent in all contexts.
>
> The keyword `float` **MUST** be treated as a transparent alias for the type `f32`. The types specified by `float` and `f32` are fully equivalent in all contexts.
>
> The keyword `double` **MUST** be treated as a transparent alias for the type `f64`. The types specified by `double` and `f64` are fully equivalent in all contexts.
>
> These types and their accompanying arithmetic operations **MUST** conform to the **IEEE 754** standard for half-precision (binary16), single-precision (binary32), and double-precision (binary64) floating-point arithmetic, respectively.
>
> Because `f16` arithmetic is often implemented in software on general-purpose CPUs, conforming implementations **SHOULD** issue a warning when `f16` arithmetic operations are used in a context where they are likely to be emulated. This warning **MAY** be disabled by the user.

**_Diagnostic:_**

| Code         | Severity | Description                                |
| :----------- | :------- | :----------------------------------------- |
| `W-TYP-1701` | Warning  | `f16` arithmetic may be emulated and slow. |

**_Explanation:_**
This conformance implies that all special values (`NaN`, `+inf`, `-inf`) and behaviors, such as the result of division by zero, follow the rules specified by the IEEE 754 standard. The `f16` type has very limited precision and is intended primarily for data storage, graphics, and specialized computation on hardware that provides native support, such as GPUs. Its use for general-purpose computation on CPUs is discouraged due to poor performance and potential for numerical instability.

### 17.3 Boolean Type [type.primitive.boolean]

The boolean type represents a truth value.

> **Boolean Type**
>
> The boolean type is `bool`. It has two possible values, represented by the keyword literals `true` and `false`.

**_Explanation:_**
The `bool` type is primarily used for control flow in expressions like `if`. It supports logical operators `&&` (and), `||` (or), and `!` (not), which are defined with short-circuiting semantics where applicable.

### 17.4 Character Type [type.primitive.char]

The character type represents a single Unicode character.

> **Character Type**
>
> The character type is `char`. A value of type `char` **MUST** represent a single **Unicode Scalar Value**, which includes all code points from `U+0000` to `U+D7FF` and `U+E000` to `U+10FFFF` inclusive.
>
> The memory representation of a `char` is implementation-defined, but it **MUST** be capable of representing any valid Unicode Scalar Value.

**_Explanation:_**
A `char` represents a single logical character, not a byte or a code unit. This is typically implemented as a 32-bit unsigned integer.

### 17.5 Unit Type [type.primitive.unit]

The unit type represents the absence of a value.

> **Unit Type**
>
> The unit type is written `()`. It has exactly one value, also written `()`.
>
> A procedure that does not specify a return type implicitly has a return type of `()`.

**_Explanation:_**
The unit type serves a role similar to `void` in other languages, but because it is a true type with a single value, it can be used consistently within the type system. Its size is always zero.

### 17.6 Never Type [type.primitive.never]

The never type represents a computation that never resolves to a value.

> **Never Type**
>
> The never type is written `!`. It is an **uninhabited type**, meaning no value of this type can ever be created.

**_Explanation:_**
The never type is the return type of expressions that do not return control to their caller, such as `panic()`, `sys.exit()`, or an infinite `loop`. As specified in §15.3, `!` is the bottom type and is a subtype of all other types. This allows it to be used in any context, regardless of the expected type, without breaking type safety.

```cursive
let x: i32 = if condition {
    result 100
} else {
    // The type of 'panic()' is '!', which coerces to 'i32'.
    panic("This path is not allowed!")
}
```

### 17.7 Diagnostics Summary [type.primitive.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code         | Severity | Description                                |
| :----------- | :------- | :----------------------------------------- |
| `W-TYP-1701` | Warning  | `f16` arithmetic may be emulated and slow. |

## 18. Composite Types [type.composite]

This chapter defines the composite types that are built by aggregating other types. These include product types (tuples, records), sum types (enums, unions), and sequence types (arrays, slices).

### 18.1 Tuples (Anonymous Products) [type.composite.tuple]

A tuple is an ordered, fixed-size, heterogeneous collection of values. Tuples are structural types.

> **Tuple Syntax**
>
> The type of a tuple is written as a comma-separated list of types enclosed in parentheses: `(<type_1>, <type_2>, ..., <type_n>)`.
>
> A tuple value is constructed with a corresponding literal syntax: `(<expression_1>, <expression_2>, ..., <expression_n>)`.
>
> Individual elements of a tuple `t` **MUST** be accessed by a constant, zero-based integer index using dot notation (e.g., `t.0`, `t.1`). An attempt to access a tuple with an out-of-bounds index **MUST** be diagnosed as a compile-time error.

**_Diagnostic:_**

| Code         | Severity | Description                |
| :----------- | :------- | :------------------------- |
| `E-TYP-1801` | Error    | Tuple index out of bounds. |

**_Explanation:_**
Tuples are a lightweight way to group multiple values together without the ceremony of defining a named `record`. The unit type `()` is the empty tuple.

```cursive
let pair: (i32, bool) = (10, true)
let first_element: i32 = pair.0 // Accesses the 'i32' value
```

### 18.2 Records (Nominal Products) [type.composite.record]

A record is a product type with named fields. Records are nominal types.

> **Record Definition**
>
> A record type is defined using the `record` keyword.
>
> ```ebnf
> record_declaration ::= "record" <identifier> "{" (<field_decl> ("," <field_decl>)* ","?)? "}"
> field_decl ::= <identifier> ":" <type>
> ```
>
> A record value is constructed using a literal that specifies the type and provides values for its fields: `MyRecord { field1: v1, field2: v2 }`.
>
> Fields of a record instance `r` **MUST** be accessed using dot notation: `r.field_name`.
>
> By default, a record's fields are private to the module in which the record is defined. The visibility of fields is governed by the visibility rules in Part 3, Chapter 12.

```cursive
public record Point {
    x: f64,
    y: f64,
}

let p: Point = Point { x: 1.0, y: -1.0 }
let x_coord = p.x
```

### 18.3 Enums (Nominal Sums) [type.composite.enum]

An enum (enumerated type) is a nominal sum type, also known as a tagged union. A value of an enum can be one of several defined variants.

> **Enum Definition**
>
> An enum type is defined using the `enum` keyword. Each variant may be unit-like, tuple-like, or record-like.
>
> ```ebnf
> enum_declaration ::= "enum" <identifier> "{" (<variant> ("," <variant>)* ","?)? "}"
> variant ::= <identifier> ( "(" <type_list> ")" | "{" <field_decl_list> "}" )?
> ```
>
> An enum value is constructed by qualifying the variant name with the enum's type name: `MyEnum::Variant`.
>
> Accessing the data stored within an enum variant **MUST** be performed using a `match` expression, which ensures that all variants are handled safely. The `match` expression is defined in Part 5, §25.

**_Explanation:_**
Enums are useful for representing a value that can be one of a set of possible kinds. The compiler enforces that all possible variants are handled when using a `match` expression, eliminating a common source of bugs.

```cursive
enum WebEvent {
    PageLoad,
    Click { x: i64, y: i64 },
    KeyPress(string),
}
```

### 18.4 Union Types (Anonymous Sums) [type.composite.union]

A union type is a structural sum type. It defines a value that can be one of several different types.

> **Union Syntax**
>
> A union type is written as a list of types separated by a pipe `|`: `<type_1> | <type_2> | ... | <type_n>`.
>
> A union type is structural; the order of its member types does not affect equivalence. `i32 | bool` is equivalent to `bool | i32`.
>
> As with enums, accessing the value stored within a union **MUST** be performed using a `match` expression to ensure type safety.

```cursive
let result: i32 | string = if success {
    result 100
} else {
    result "Error"
}

match result {
    i: i32 => print("Success: #(i)"),
    s: string => print("Failure: #(s)"),
}
```

### 18.5 Array Types [type.composite.array]

An array is a homogeneous collection of elements with a fixed size known at compile time.

> **Array Syntax**
>
> An array type is written as `[<type>; <const_expression>]`, where `<type>` is the element type and `<const_expression>` is a compile-time constant expression of type `usize`.
>
> An array value can be constructed with a list literal `[e1, e2, ...]` or a repeat literal `[e; N]`.
>
> Elements of an array `a` are accessed via indexing: `a[i]`, where `i` is an expression of type `usize`.
>
> All array indexing **MUST** be bounds-checked. An attempt to access an index greater than or equal to the array's length **MUST** cause the executing thread to panic. Implementations **MAY** elide bounds checks only if they can statically prove that the access is always within bounds.

### 18.6 Slice Types [type.composite.slice]

A slice is a dynamically-sized, mutable or immutable view into a contiguous sequence of elements, such as an array.

> **Slice Syntax**
>
> A slice type is written as `[<type>]`, where `<type>` is the element type.
>
> A slice is a "dense pointer" structure, containing both a pointer to the first element and a length. A slice does not own its data.
>
> ```cursive
> let arr: [i32; 5] = [10, 20, 30, 40, 50]
> // 's' is a slice of type '[i32]' containing [20, 30]
> let s: const [i32] = arr[1..3]
> ```
>
> Like arrays, element access via indexing `slice[i]` **MUST** be bounds-checked, and an out-of-bounds access **MUST** cause a panic.


### 18.7 Range Types [type.composite.range]

> **Range Types**
>
> Range types are structural record types produced by range expressions (`..`). Implementations **MUST** provide the following built-in generic definitions with **public fields**:
>
> ```cursive
> // Produced by `start..end`
> public record Range<T> { public start: T, public end: T }
>
> // Produced by `start..=end`
> public record RangeInclusive<T> { public start: T, public end: T }
>
> // Produced by `start..`
> public record RangeFrom<T> { public start: T }
>
> // Produced by `..end`
> public record RangeTo<T> { public end: T }
>
> // Produced by `..=end`
> public record RangeToInclusive<T> { public end: T }
>
> // Produced by `..`
> public record RangeFull {}
> ```
>
> Range types **MUST** be `Copy` if their element type `T` is `Copy`.

### 18.8 Diagnostics Summary [type.composite.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code         | Severity | Description                |
| :----------- | :------- | :------------------------- |
| `E-TYP-1801` | Error    | Tuple index out of bounds. |

---

## 19. Modal Types [type.modal]

This chapter defines modal types, Cursive's mechanism for embedding compile-time-validated state machines into the type system. Modal types statically prevent operations from being performed in an incorrect state, such as dereferencing a `null` pointer or reading from a `closed` file.

### 19.1 Overview [type.modal.overview]

A **modal type** is a nominal type that functions as a state-machine-aware discriminated union. It consists of a family of related types:

1.  **State-Specific Types (`M@S`):** These are concrete, zero-overhead types containing only the data defined in their specific state payload. They do **not** store a runtime state tag.
2.  **The General Modal Type (`M`):** This is a sum type (tagged union) capable of holding a value of any of its specific states. It stores the state payload **plus** a runtime discriminant (tag) to identify the current state.

This system allows for "Zero-Cost" states when the state is known at compile time, while supporting safe, dynamic inspection via `match` when the state is erased to the general type.

### 19.2 The `modal` Declaration [type.modal.declaration]

Modal types are defined using the `modal` keyword, followed by a body containing one or more state blocks.

> **Modal Declaration**
>
> A `modal` declaration **MUST** conform to the following syntactic form:
>
> ```ebnf
> modal_declaration ::= "modal" <identifier> [ <generic_params> ] "{" <state_block>+ "}"
> ```
>
> The declaration introduces a new nominal type, referred to as the **general modal type** (e.g., `FileHandle`).
>
> A `modal` declaration **MUST** contain at least one state block. A modal type with zero states is ill-formed.

**_Diagnostic:_**

| Code         | Severity | Description                                    |
| :----------- | :------- | :--------------------------------------------- |
| `E-TYP-1910` | Error    | Modal type must declare at least one `@State`. |
>
> All state names within a `modal` declaration **MUST** be unique.

**_Diagnostic:_**

| Code         | Severity | Description                             |
| :----------- | :------- | :-------------------------------------- |
| `E-TYP-1911` | Error    | Duplicate state '@State' in modal type. |

### 19.3 State Specifiers (`@State`) [type.modal.state]

A state block defines a single, named state for the modal type. It may contain state-specific data (a payload) and state-specific procedures (methods and transitions).

> **State Block Syntax**
>
> A `state_block` **MUST** conform to the following syntactic form:
>
> ```ebnf
> state_block ::= "@" <identifier> [ <state_payload> ] [ <state_members> ]
> state_payload ::= "{" (<field_decl> ("," <field_decl>)* ","?)? "}"
> state_members ::= "{" <procedure_declaration>* "}"
>
> ```
> 
> **Note:** The `<procedure_declaration>` list is where both standard methods and state transition procedures are defined.

#### 19.3.1 State Payloads [type.modal.state.state-payloads]

> **Payload Definition**
>
> The optional `state_payload` block defines data fields that exist *only* when the modal value is in that specific state. The syntax is identical to a `record` body.
>
> Fields in a state payload **MUST** be treated as `protected`. They are accessible only from within the implementation of the `modal` type.

**_Diagnostic:_**

| Code         | Severity | Description                                         |
| :----------- | :------- | :-------------------------------------------------- |
| `E-TYP-1912` | Error    | Field 'field' is only available in state '@StateA'. |

#### 19.3.2 State Members (Methods and Transitions) [type.modal.state.state-members-methods-and-transitions]

> **State Members**
>
> The optional `state_members` block **MAY** contain standard `procedure_declaration`s.
>
>   * **Standard Methods:** A procedure with a standard return type (e.g., `: i32`) is a method available *only* when the modal value is in that specific state.
>   * **Transition Procedures:** A procedure with a transition return type (e.g., `: @StateA -> @StateB`) is a state transition. This is defined in §19.4.

### 19.4 State Transitions [type.modal.transition]

A state transition is a procedure that moves a modal value from one state to another. This is the **only** mechanism by which a modal value can change its state in safe code.

#### 19.4.1 Transition Signatures [type.modal.transition.signature]

> **Transition Signature**
>
> A transition *signature* declares a valid edge in the modal state graph. It **MUST** appear within the body of a `modal` declaration inside the source state block.
>
> ```ebnf
> transition_signature ::= "transition" <identifier> "(" <param_list> ")" "->" "@" <TargetStateIdentifier>
> ```
>
> The arrow operator `->` in a transition signature denotes the mapping from the enclosing source state to the target state.

#### 19.4.2 Transition Implementation [type.modal.transition.impl]

> **Transition Implementation**
>
> Every transition signature **MUST** be implemented by a corresponding procedure using the `transition` keyword.
>
> ```ebnf
> transition_implementation ::= 
>     "transition" <TypeName> "::" <identifier> "(" <param_list> ")" "->" <TargetStateType>
>     <block>
> ```
>
> 1.  **Keyword:** The implementation **MUST** use `transition`, not `procedure`.
> 2.  **Naming:** The name **MUST** be fully qualified: `ModalType::transition_name`.
> 3.  **Return Type:** The return type **MUST** be the fully qualified target state type (e.g., `File@Open`).
> 4.  **Receiver:** The first parameter **MUST** be the source state type (e.g., `self: unique File@Closed`).

***Example:***

```cursive
// In Modal Declaration:
// transition open(path: string): @Open

// Implementation:
transition File::open(self: unique File@Closed, path: string): File@Open {
    // ...
    result File@Open { ... }
}
```

#### 19.4.3 Transition Implementation [type.modal.transition.transition-implementation]

A transition procedure is implemented like any other procedure. Its body must be provided exactly once and must satisfy the desugared canonical signature.

> **Transition Return**
>
> The implementation for a transition procedure **MUST** return a value whose type is equivalent to the target state-specific type (`M@StateB`).

**_Diagnostic:_**

| Code         | Severity | Description                                                             |
| :----------- | :------- | :---------------------------------------------------------------------- |
| `E-TYP-1915` | Error    | Transition procedure body must return a value of the target state type. |

***Example (Comprehensive Transition Specification):***

**1. The User's View (Declaration within Modal Type)**

```cursive
modal Connection {
    @Disconnected { host: string@View }
    @Connecting { attempt: u32 }

    // This is the expressive transition signature the user writes.
    // It is declared inside the '@Disconnected' state block.
    procedure connect(self: unique Self): @Disconnected -> @Connecting;
}
```

**2. The Implementation**

```cursive
// The implementation is a standard procedure that matches the
// canonical (desugared) signature.
procedure Connection::connect(self: unique Connection@Disconnected): Connection@Connecting {
    log("Attempting to connect to host: ", self.host);
    // ... complex logic ...

    // The result MUST be of the target state type.
    result Connection@Connecting { attempt: 1 }
}
```

**3. Compiler Desugaring (Normative Interpretation)**
For the `connect` procedure, the compiler performs the following desugaring based on its declaration context:

```cursive
// For the `connect` procedure, the compiler performs the following desugaring:
// 1. The procedure is declared inside the '@Disconnected' state block.
//    Therefore, the receiver `self: unique Self` is desugared to `self: unique Connection@Disconnected`.
// 2. The transition arrow `-> @Connecting` specifies the return type.
//    Therefore, the return type is desugared to `Connection@Connecting`.
//
// The resulting canonical signature is:
// procedure Connection::connect(self: unique Connection@Disconnected): Connection@Connecting;
```

**4. Resulting Function Type**
The desugared signature results in the following first-class function type:

```cursive
// The function type of 'Connection::connect' is:
// (unique Connection@Disconnected) -> Connection@Connecting
```

### 19.5 State-Specific Typing and Coercion [type.modal.typing]

#### 19.5.1 Layout and Representation [type.modal.typing.layout-and-representation]

> **Modal Layout**
>
> *   **State-Specific Type (`M@S`):** The layout of `M@S` **MUST** be equivalent to a `record` containing the fields defined in the payload of state `@S`. If the payload is empty, `sizeof(M@S)` is 0.
> *   **General Modal Type (`M`):** The layout of `M` **MUST** be equivalent to an `enum` (tagged union) where each variant corresponds to one defined state. It **MUST** contain a discriminant large enough to distinguish all states.
>
> **Optimization (Niches):** Implementations **MAY** elide the separate discriminant for the General Type `M` if the state can be unambiguously determined from the bit-patterns of the payloads (e.g., "Niche Optimization").
> *   *Normative Example:* For `Ptr<T>`, the `@Null` state is represented by the address `0`. The `@Valid` state is represented by non-zero addresses. Therefore, the general `Ptr<T>` type has the same size as `Ptr<T>@Valid` (one machine word), and the "tag" is implicit in the address bits.

#### 19.5.2 Modal Widening (Coercion) [type.modal.typing.modal-widening-coercion]

> **Modal Coercion**
>
> An expression of a state-specific type `M@S` **MAY** be implicitly coerced to the general modal type `M`.
>
> This coercion is a **constructive operation**:
> 1.  The payload from `M@S` is moved into the corresponding storage slot of `M`.
> 2.  The runtime discriminant for state `@S` is written into `M`.
>
> **Formal Rule:**
> $$
> \frac{}{\Gamma \vdash M@S <: M}
> \tag{T-Coerce-Modal-Widen}
> $$

#### 19.5.3 Incomparability [type.modal.typing.incomparability]

> **State Incompatibility**
>
> Two different state-specific types of the same modal type are incomparable.
>
> $$
> \frac{S_A \neq S_B}{\Gamma \vdash M@S_A \not<: M@S_B \quad \land \quad \Gamma \vdash M@S_B \not<: M@S_A}
> \tag{T-Modal-Incomparable}
> $$

### 19.6 Pattern Matching [type.modal.match]

To safely narrow a general modal type to a state-specific one, a `match` expression must be used.

> **Exhaustive Match**
>
> A `match` expression (see §27) on a value of a general modal type **MUST** be exhaustive. All states of the modal type **MUST** be covered in the match arms.

**_Diagnostic:_**

| Code         | Severity | Description                                                    |
| :----------- | :------- | :------------------------------------------------------------- |
| `E-TYP-1920` | Error    | Match on modal type 'T' is not exhaustive. Missing states: ... |
>
> **Type Refinement**
>
> Within a match arm for a specific state, the bound variable **MUST** be refined to that state-specific type.
>
> ***Grammar:***
>
> ```ebnf
> modal_pattern ::= "@" <StateIdentifier> [ "{" <payload_pattern> "}" ]
> ```
> **Runtime Dispatch**
>
> When matching on a general modal type `M`, the runtime **MUST** inspect the discriminant (or niche bits) to determine the active state.
>
> **Static Match**
>
> When matching on a state-specific type `M@S` (which is rare, as the state is known statically), the match **MUST** be treated as an irrefutable destructuring of the payload, similar to a `record` pattern.
***Example:***

```cursive
procedure process_file(file: FileHandle) { // 'file' is the general type
    match file {
        @Open { handle } => {
            // 'file' is refined to 'FileHandle@Open' in this scope
            // 'handle' field is accessible
            file.read(handle)
        }
        @Closed { path } => {
            // 'file' is refined to 'FileHandle@Closed' in this scope
            // 'path' field is accessible
            file.open(path)
        }
        // No '@Expired' state exists for FileHandle, so this is exhaustive
    }
}
```

### 19.7 Built-in Modal Types [type.modal.built-in]

The Cursive language provides several built-in modal types that are essential for its operation. The following chapters define their specific states and transitions, which follow all rules in this chapter:

  * **`string@State`** (see §20)
  * **`Ptr<T>@State`** (see §21)
  * **`Mutex<T>@State`** (see §31.3)
  * **`Thread<T>@State`** (see §31.2)
  
### 19.8 Diagnostics Summary [type.modal.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code       | Severity | Description                                                                                                                                                         |
| :--------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| E-TYP-1910 | Error    | Modal type must declare at least one `@State`.                                                                                                                      |
| E-TYP-1911 | Error    | Duplicate state '@State' in modal type.                                                                                                                             |
| E-TYP-1912 | Error    | Field 'field' is only available in state '@StateA'.                                                                                                                 |
| E-TYP-1913 | Error    | Procedure 'method' is only available in state '@StateA'.                                                                                                            |
| E-TYP-1914 | Error    | Missing implementation for transition procedure declared in modal type.                                                                                             |
| E-TYP-1915 | Error    | Transition procedure body must return a value of the target state type. For a transition declared as `-> @StateB`, the body must return a value of type `M@StateB`. |
| E-TYP-1920 | Error    | Match on modal type 'T' is not exhaustive. Missing states: ...                                                                                                      |

---

## 20. String Types [type.string]

This chapter defines the Cursive string type. Strings are a built-in modal type that guarantees all string data is a valid, heap-allocated sequence of Unicode scalar values encoded as UTF-8. The `string` type is modal, with two primary states: `string@Managed` (an owned, mutable string buffer) and `string@View` (an immutable, non-owning string slice).

### 20.1 The `string` Modal Type [type.string.the-string-modal-type]

The `string` type is a built-in modal type with two states.

#### 20.1.1 Conceptual Modal Declaration [type.string.the-string-modal-type.conceptual-modal-declaration]

```cursive
// Conceptual built-in declaration
modal string {
    // Owned, mutable, heap-allocated buffer.
    // Implements Drop for automatic cleanup.
    @Managed {
        pointer: Ptr<u8>@Valid, // Must be explicit @Valid state
        length: usize,
        capacity: usize,
    }

    // Immutable, non-owning slice.
    // Implements Copy.
    @View {
        pointer: Ptr<const u8>@Valid, // Must be explicit @Valid state
        length: usize,
    }

    // --- Core Transitions ---

    // Creates an immutable view from a managed string.
    // This is a subtyping coercion.
    transition view(self: const string@Managed): string@View

    // Creates a new managed string by copying a view's data.
    // Requires a HeapAllocator capability.
    transition to_managed(self: const string@View, heap: HeapAllocator): string@Managed
}
```

#### 20.1.2 String Literals \[type.string.literal] [type.string.the-string-modal-type.string-literals-type.string.literal]

String literals are sequences of characters enclosed in double quotes (`"`). They support escape sequences as defined in §9.4.2. All string literals are statically allocated and have the type `string@View`.

> **Literal Validity**
>
> A string literal **MUST** be well-formed UTF-8.
>
> String literals **MUST** be read-only.

**_Formal rule:_**

$$
\frac{\Gamma \vdash s \text{ is a valid string literal}}{\Gamma \vdash s : \text{string@View}}
\tag{T-String-Lit}
$$

```cursive
// 'greeting' has type string@View
let greeting = "Hello, world!\n"
```

### 20.2 The `string@Managed` State \[type.string.managed] [type.string.the-stringmanaged-state-type.string.managed]

The `string@Managed` type is an owned, mutable, heap-allocated string buffer. It is Cursive's primary type for building and modifying strings.

#### 20.2.1 Responsibility and Mutability [type.string.the-stringmanaged-state-type.string.managed.responsibility-and-mutability]

> **Managed Semantics**
>
> A `string@Managed` binding **MUST** follow all standard responsibility and move semantics as defined in Part 6, §28.
>
> It **MUST** implement the `Drop` trait to deallocate its buffer when its responsible owner goes out of scope.
>
> It **MUST NOT** implement the `Copy` trait.

#### 20.2.2 Operations [type.string.the-stringmanaged-state-type.string.managed.operations]

> **Mutation Requirements**
>
> The string@Managed type provides methods for mutation, such as .push(char). These operations **REQUIRE** unique permission.
> Any operation that may need to allocate or reallocate the buffer **MUST** be passed a HeapAllocator capability.

```cursive
// 'ctx: Context' is passed by the runtime and contains 'ctx.heap'
procedure build_string(ctx: Context): string@Managed {
    
    // The HeapAllocator capability must be passed explicitly to the constructor
    let mut_str: unique string@Managed = string::from("Data: ", ctx.heap)

    // The allocator must also be passed for mutation operations that reallocate
    mut_str.append("more data", ctx.heap) // OK: requires 'unique' permission
    
    result mut_str
}
```

#### 20.2.3 Cloning (Capability Pattern) [type.string.the-stringmanaged-state-type.string.managed.cloning-capability-pattern]
> **Cloning Restriction**
>
> A string@Managed **MUST NOT** implement the Clone trait, as it requires heap allocation to be duplicated.
> Instead, it **MUST** provide an explicit Capability-safe clone_with method that accepts an allocator.

```cursive
// Conceptual implementation on string@Managed
procedure clone_with(self: const, heap: HeapAllocator): string@Managed {
    // 1. Allocate a new buffer of the same capacity
    let new_buffer = heap.allocate(self.capacity)
    
    // 2. Copy the data from 'self' to 'new_buffer'
    copy_memory(new_buffer.ptr, self.ptr, self.length)
    
    // 3. Return a new string
    result string@Managed {
        pointer: new_buffer.ptr,
        length: self.length,
        capacity: self.capacity
    }
}
```

### 20.3 The `string@View` State \[type.string.view] [type.string.the-stringview-state-type.string.view]

The `string@View` type is a non-owning, immutable slice of a UTF-8 string. It is the default type for string parameters and literals.

#### 20.3.1 Immutability and Lifetime [type.string.the-stringview-state-type.string.view.immutability-and-lifetime]

> **View Semantics**
>
> A `string@View` is a non-owning reference, and its lifetime **MUST** be guaranteed to be shorter than the lifetime of the data it points to (either a `string@Managed` or a static literal).
>
> It **MUST** be immutable. No operations shall be provided that allow modification of the underlying data through a `string@View`.
>
> It **MUST** implement the `Copy` trait, as it is a simple pointer and length.

#### 20.3.2 Operations (Informative) [type.string.the-stringview-state-type.string.view.operations-informative]

The `string@View` type provides non-mutating methods, such as `.length()`, `.is_empty()`, and slicing operations.

### 20.4 Subtyping and Coercion \[type.string.coercion] [type.string.subtyping-and-coercion-type.string.coercion]

The `string@Managed` type is a subtype of `string@View`.

> **View Coercion**
>
> An expression of type `string@Managed` **MAY** be implicitly coerced to `string@View`. This coercion represents an immutable view of the managed string's data.

**_Formal rule:_**

$$
\frac{}{\Gamma \vdash \text{string@Managed} <: \text{string@View}}
\tag{T-Coerce-String-View}
$$

***Explanation:***
This coercion allows functions that accept a `string@View` to be called with either a `string@View` literal or an owned `string@Managed` binding.

```cursive
procedure print_message(message: string@View) {
// ...
}

let managed_str: string@Managed = string::from("Hello")

print_message("This is a view")     // OK: string@View
print_message(managed_str)          // OK: string@Managed coerces to string@View
```

### 20.5 Indexing and Slicing \[type.string.slicing] [type.string.indexing-and-slicing-type.string.slicing]

Direct indexing into a `string` (e.g., `my_str[i]`) is forbidden, as a byte index may not correspond to a valid `char` boundary in UTF-8.

#### 20.5.1 Slicing [type.string.indexing-and-slicing-type.string.slicing.slicing]

Strings **MAY** be sliced using range expressions (`a..b`). Slicing operates on **byte indices**, not character indices.

> **Slicing Rules**
>
> A slice operation `my_str[a..b]` on a `string@View` or `string@Managed` **MUST** produce a value of type `string@View`.
>
> The slice boundaries (both `a` and `b`) **MUST** fall on valid UTF-8 `char` boundaries.
>
> If either boundary does not fall on a valid UTF-8 char boundary (as defined by the encoding rules in §8.1.1), the operation MUST cause the executing thread to panic.

***Explanation:***
This rule ensures that all `string@View` values are always valid UTF-8, but places the burden of correctness on the programmer. Iterating over `char` indices is the only guaranteed-safe way to slice a string.

```cursive
let s: string@View = "🚀hello" // 🚀 is 4 bytes

// VALID:
let view1 = s[0..4] // "🚀"
let view2 = s[4..9] // "hello"

// PANIC:
// The byte at index 2 is in the middle of the 🚀 character.
let view3 = s[2..5] // PANIC: 'index 2 is not a char boundary'
```

### 20.6 Diagnostics Summary \[type.string.diagnostics] [type.string.diagnostics-summary-type.string.diagnostics]

This chapter introduces the following diagnostics related to string types. (It also references diagnostics from §9.4).

| Code       | Severity | Description                                               |
| :--------- | :------- | :-------------------------------------------------------- |
| E-TYP-1901 | Panic    | String slice boundary does not fall on a `char` boundary. |
| E-TYP-1902 | Error    | Direct indexing (`str[i]`) on a string is not permitted.  |
| ...        | ...      | ...                                                       |
| E-SRC-0301 | Error    | Unterminated string literal. (See §9.4.2)                 |
| E-SRC-0302 | Error    | Invalid escape sequence in string literal. (See §9.4.2)   |

---

## 21. Pointer Types [type.pointer]
This chapter defines Cursive's pointer types. The language provides two distinct pointer families:
1. Safe Modal Pointers (`Ptr<T>@State`): This is Cursive's primary, safe pointer type. It is a modal type that integrates with the type system to provide compile-time guarantees about liveness and nullness, statically preventing null-pointer dereferences and use-after-free errors without a borrow checker.
2. Raw Pointers (`*imm T`, `*mut T`): These are unsafe, C-style pointers. They provide no safety guarantees and are intended only for unsafe blocks and interoperability with foreign code (FFI).

### 21.1 The Safe Pointer Type (Ptr<T>@State) [type.pointer.the-safe-pointer-type-ptrtstate]
The `Ptr<T>@State` type is the idiomatic way to reference memory in safe Cursive code. Its safety is derived from its modal states, which are enforced by the compiler at compile time.

#### 21.1.1 Conceptual Modal Declaration [type.pointer.the-safe-pointer-type-ptrtstate.conceptual-modal-declaration]

```cursive
// Conceptual built-in declaration
modal Ptr<T> {
    // State: The pointer is guaranteed to be non-null
    // and point to live, initialized data.
    // This is the ONLY state that can be dereferenced.
    @Valid {
        // (Internal representation of a non-null pointer)
    }

    // State: The pointer is guaranteed to be null.
    // This is Cursive's safe, explicit replacement for `nullptr`.
    @Null {
        // (Internal representation of a null pointer)
    }

    // State: The pointer *was* valid, but the region it
    // pointed to has been freed.
    // This state is set by the compiler when a region exits.
    @Expired {
        // (Internal representation of a dangling pointer)
    }

    // --- Core Transitions (Informative) ---

    // Constructor for a null pointer
    transition null<T>(): Ptr<T>@Null

    // Transitions from @Valid and @Null to @Expired are
    // managed by the compiler via region exit.
}
#### 21.1.2 Pointer States [type.pointer.the-safe-pointer-type-ptrtstate.pointer-states]
The Ptr<T> type has three compile-time states that track liveness:
- `@Valid`: The pointer is guaranteed to be non-null and to point to live, accessible memory. This is the only state that permits dereferencing (`*`).
- `@Null`: The pointer is guaranteed to be null. Dereferencing this state is a compile-time error.
- `@Expired`: The pointer is guaranteed to be dangling (e.g., it pointed into a `region` block that has exited). Dereferencing this state is a compile-time error.

#### 21.1.3 Pointer Creation (Address-Of) [type.pointer.the-safe-pointer-type-ptrtstate.pointer-creation-address-of]
A safe, valid pointer is created using the address-of operator (`&`).

> **Address-Of Operator**
>
> The `&` operator **MUST** be applied to a valid memory location (e.g., a binding or a field).
> The result of the `&` operator is a safe pointer in the @Valid state.

**_Formal rule:_**
$$
\frac{\Gamma \vdash e : T \quad (e \text{ is a valid place})}{\Gamma \vdash \&e : \text{Ptr<T>@Valid}}
\tag{T-Addr-Of}
$$
let value: i32 = 42
// 'ptr' has the type Ptr<i32>@Valid
let ptr = &value
A null pointer is created using the built-in constructor:// 'null_ptr' has the type Ptr<i32>@Null
let null_ptr: Ptr<i32>@Null = Ptr::null()

#### 21.1.4 Liveness and Dereferencing [type.pointer.the-safe-pointer-type-ptrtstate.liveness-and-dereferencing]
The dereference operator (\*) provides access to the data a pointer points to.

> **Dereference Safety**
>
> The dereference operator (*) **MUST** only be applied to a pointer in the @Valid state.
> An attempt to apply the dereference operator to a pointer in the @Null or @Expired state **MUST** be rejected as a compile-time error.

**_Formal rule:_**
$$
\frac{\Gamma \vdash p : \text{Ptr<T>@Valid}}{\Gamma \vdash *p : T}
\tag{T-Dereference}
$$

**_Explanation:_**
This rule statically enforces memory safety. It is a compile-time error to even *attempt* to dereference a pointer that has not been proven to be `@Valid`.

**_Diagnostic:_**

| Code         | Severity | Description                                                            |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `E-TYP-2001` | Error    | Cannot dereference a pointer in the `@Null` state.                     |
| `E-TYP-2002` | Error    | Cannot dereference a pointer in the `@Expired` state (use-after-free). |

```cursive
procedure safe_access(ptr: Ptr<i32>@Valid) {
let value = *ptr // OK: State is @Valid
}

procedure null_access(ptr: Ptr<i32>@Null) {
// COMPILE-TIME ERROR (E-TYP-2001):
// Cannot dereference a pointer in the @Null state.
let value = *ptr
}

procedure expired_access(ptr: Ptr<i32>@Expired) {
// COMPILE-TIME ERROR (E-TYP-2002):
// Cannot dereference a pointer in the @Expired state.
let value = *ptr
}
```

### 21.2 Raw Pointer Types (`*imm T`, `*mut T`) [type.pointer.raw-pointer-types-imm-t-mut-t]

Cursive provides raw, C-style pointers for low-level operations. These pointers completely bypass the modal `Ptr<T>@State` system and provide no safety guarantees.

#### 21.2.1 Usage in `unsafe` Code [type.pointer.raw-pointer-types-imm-t-mut-t.usage-in-unsafe-code]

> **Unsafe Dereference**
>
> Raw pointers (`*imm T` for immutable, `*mut T` for mutable) **MUST NOT** be dereferenced outside of an `unsafe` block.
>
> A raw pointer may be null, dangling, or unaligned. The programmer assumes all responsibility for safety when using them.

```cursive
let x: i32 = 10
let raw_ptr: *imm i32 = &x as *imm i32

// COMPILE-TIME ERROR (E-TYP-2003):
// Dereference of raw pointer requires 'unsafe' block.
// let value = *raw_ptr

// This is permitted, but the programmer is responsible for safety.
let value_unsafe = unsafe {
*raw_ptr
}
```

#### 21.2.2 FFI and Interoperability [type.pointer.raw-pointer-types-imm-t-mut-t.ffi-and-interoperability]

Raw pointers are the primary FFI-safe (see §32.4) pointer type. The `Ptr<T>@State` modal type is *not* FFI-safe and cannot be used in `extern` procedure signatures.

Raw pointers can be created by casting a safe `Ptr<T>@Valid`:

```cursive
extern "C" procedure c_function(ptr: *imm i32)

procedure call_c_function(safe_ptr: Ptr<i32>@Valid) {
// Cast the safe, valid pointer to a raw pointer for FFI.
let raw_ptr: *imm i32 = safe_ptr as *imm i32

unsafe {
c_function(raw_ptr)
}
}
```

### 21.3 Diagnostics Summary \[type.pointer.diagnostics] [type.pointer.diagnostics-summary-type.pointer.diagnostics]

This chapter introduces the following diagnostics related to pointer types. (It also references diagnostics from §28, such as E-MEM-11001 for use-of-moved-value).

| Code       | Severity | Description                                                                     |
| :--------- | :------- | :------------------------------------------------------------------------------ |
| E-TYP-2001 | Error    | Cannot dereference a pointer in the `@Null` state.                              |
| E-TYP-2002 | Error    | Cannot dereference a pointer in the `@Expired` state (use-after-free).          |
| E-TYP-2003 | Error    | Dereference of a raw pointer (`*imm T` or `*mut T`) requires an `unsafe` block. |

---

## 22. Function Types [type.function]

This chapter defines the syntax, formation rules, and semantics for function types, which represent callable entities.

### 22.1 Overview [type.function.overview]

A function type is a **structural type** that represents a callable signature. It is defined by its parameter types—including any capabilities and `move` responsibility modifiers—and its return type.

Function types are the cornerstone of higher-order programming in Cursive. They are distinct from `procedure` declarations (§24.2), which are named, top-level items. A `procedure` declaration *has* a function type that is a direct representation of its full signature.

This distinction is critical for ensuring type safety in the Capability system and the ownership model:

> **Function Type Definition**
>
> A function type **MUST** be defined by its complete parameter signature and its return type. This **MUST** include:
>
> 1.  All parameter types, including any capabilities (e.g., `FileSystem`, `HeapAllocator`).
> 2.  All parameter responsibility modifiers (the `move` keyword).
> 3.  The return type.
>
> A function type **MUST NOT** include:
>
> 1.  Parameter names.
> 2.  The procedure's contract (the `[[...]]` sequent clause), which is considered metadata about the procedure, not part of its type.

This design ensures that a function's type fully describes its interface, making the Capability system and ownership semantics type-safe and composable, especially for higher-order functions.

### 22.2 Syntax and Formation [type.function.syntax]

> **Function Type Syntax**
>
> A function type **MUST** conform to the following syntactic form:
>
> ```ebnf
> function_type ::= "(" [ <param_type_list> ] ")" "->" <type>
> param_type_list ::= <param_type> ("," <param_type>)*
> param_type ::= [ "move" ] <type>
> ```
>
> 1.  The `<param_type_list>` is a comma-separated list of zero or more parameter types. Each parameter type may optionally be prefixed with the `move` keyword.
> 2.  This list includes **all** parameters, including any capabilities required by the procedure.
> 3.  The `->` operator (hyphen, greater-than) separates the parameters from the return type.
> 4.  The `<type>` following the `->` is the single return type. If a procedure returns no value, this type **MUST** be the **unit type** (`()`).

**_Formal rule (Well-Formedness):_**
The judgment $\Gamma \vdash (\text{move}?~T_1, \dots, \text{move}?~T_n) \to T_{ret} : \text{Type}$ holds if the function type is well-formed.

$$
\frac{
\Gamma \vdash T_{ret} : \text{Type} \quad \forall i \in 1..n, \Gamma \vdash T_i : \text{Type}
}{
\Gamma \vdash (\text{move}?~T_1, \dots, \text{move}?~T_n) \to T_{ret} : \text{Type}
}
\tag{T-Func-WF}
$$

**_Explanation:_**
A function type is well-formed if and only if its return type and all of its parameter types are well-formed. The optional `move` modifier is part of the type's structure.

***Example:***

```cursive
// A procedure that takes a FileSystem capability and consumes a Buffer,
// returning the unit type.
let my_fn_type: (FileSystem, move Buffer) -> ()

// A function type for a procedure that takes no arguments
// and returns an i32.
let my_action: () -> i32
```

### 22.3 Semantics and Properties [type.function.semantics]

#### 22.3.1 Type Equivalence [type.function.semantics.type-equivalence]

> **Function Type Equivalence**
>
> Function types are structural. Two function types are equivalent if and only if they have the same number of parameters, their parameter types are equivalent in order (including matching `move` modifiers), and their return types are equivalent.

**_Formal rule (Equivalence):_**
The judgment $\Gamma \vdash T \equiv U$ holds if function types $T$ and $U$ are equivalent.

$$
\frac{
T = (m_1~T_{p1}, \dots, m_n~T_{pn}) \to T_{ret} \quad U = (k_1~U_{p1}, \dots, k_n~U_{pn}) \to U_{ret} \quad \Gamma \vdash T_{ret} \equiv U_{ret} \quad \forall i \in 1..n, (m_i \equiv k_i \land \Gamma \vdash T_{pi} \equiv U_{pi})
}{
\Gamma \vdash T \equiv U
}
\tag{T-Equiv-Func}
$$
Where $m_i$ and $k_i$ represent the optional `move` modifier for each parameter.

**_Explanation:_**
The types `(move Buffer) -> ()` and `(Buffer) -> ()` are **not** equivalent.

#### 22.3.2 Subtyping (Variance) [type.function.semantics.subtyping-variance]

Function types exhibit variance. Their parameters are **contravariant**, and their return type is **covariant**.

**_Formal rule (Subtyping):_**
The judgment $\Gamma \vdash T <: U$ holds if function type $T$ is a subtype of function type $U$.

$$
\frac{
T = (T_{p1}, \dots, T_{pn}) \to T_{ret} \quad U = (U_{p1}, \dots, U_{pn}) \to U_{ret} \quad \Gamma \vdash T_{ret} <: U_{ret} \quad \forall i \in 1..n, \Gamma \vdash U_{pi} <: T_{pi}
}{
\Gamma \vdash T <: U
}
\tag{T-Subtype-Func}
$$

**_Explanation:_**
*   **Covariant Return Type:** A function `F_Dog` that returns a `Dog` can be used where a function `F_Animal` that returns an `Animal` is expected (assuming `Dog <: Animal`).
*   **Contravariant Parameter Types:** This applies to both the type and the `move` modifier.
    *   A function `F_Animal` that accepts an `Animal` can be used where a function `F_Dog` that accepts a `Dog` is expected (assuming `Dog <: Animal`).
    *   Similarly, a function that borrows (`(Buffer) -> ()`) can be used where a function that consumes (`(move Buffer) -> ()`) is expected. The caller is prepared for the value to be consumed, but the callee only borrows it, which is always safe. The reverse is not true. This establishes the subtyping rule: `(T) -> U` is a subtype of `(move T) -> U`.

#### 22.3.3 Parameter Responsibility (`move`) [type.function.semantics.parameter-responsibility-move]

The `move` keyword is a parameter responsibility modifier that is an integral part of the function type. It is **not** separate metadata.

> **Move Parameter Semantics**
>
> A procedure declared with a `move` parameter:
> `procedure consume(move data: Buffer)`
>
> **MUST** have the function type: `(move Buffer) -> ()`.
>
> A procedure declared without one:
> `procedure inspect(data: Buffer)`
>
> **MUST** have the function type: `(Buffer) -> ()`.
>
> These two function types are **not** equivalent and are not interchangeable, though a subtyping relationship exists (§22.3.2). Any mismatch in `move` expectations at a call site or in a higher-order function context **MUST** be diagnosed as a standard type mismatch error (`E-TYP-2302`).

**_Diagnostic:_**

| Code         | Severity | Description                                   |
| :----------- | :------- | :-------------------------------------------- |
| `E-TYP-2302` | Error    | Type mismatch in function call or assignment. |

### 22.4 Function Types vs. Procedure Declarations [type.function.distinction]

A `procedure` declaration is a named, top-level item that *has* a corresponding function type. The function type is a direct and complete representation of the procedure's signature.

| Construct                 | `procedure` (Declaration) | `(T) -> U` (Type)                       | `witness (T) -> U` (Type)                    |
| :------------------------ | :------------------------ | :-------------------------------------- | :------------------------------------------- |
| **Is a...**               | Named, top-level item     | Structural, anonymous type              | Structural, anonymous type                   |
| **Represents**            | Named procedure           | Sparse function pointer (FFI-safe)      | Dense pointer witness closure (not FFI-safe) |
| **Carries Name?**         | **Yes** (e.g., `my_proc`) | No                                      | No                                           |
| **Carries Contract?**     | **Yes** (as metadata)     | **No**                                  | **No**                                       |
| **Carries Capabilities?** | **Yes** (in parameters)   | **Yes** (as parameter types)            | **Yes** (as parameter types)                 |
| **Carries `move`?**       | **Yes** (on parameters)   | **Yes** (as part of the parameter type) | **Yes** (as part of the parameter type)      |

When a procedure is used as a value, it is treated as a value of its corresponding function type. The compiler **MUST** enforce full type compatibility, including all capability parameters and `move` modifiers. A non-capturing procedure has a sparse function pointer type, while a closure that captures its environment has a dense `witness` function pointer type.

```cursive
// This procedure has the type: (move Buffer) -> ()
procedure consume(move data: Buffer) {
    // ... takes responsibility ...
}

// This procedure has the type: (Buffer) -> ()
procedure inspect(data: Buffer) {
    // ... does not take responsibility ...
}

// This higher-order function requires a CONSUMING function.
procedure do_consuming_work(action: (move Buffer) -> (), move data: Buffer) {
    action(move data)
}

let my_buffer = Buffer::new()

// VALID: The type of `consume` matches the expected type of `action`.
do_consuming_work(consume, move my_buffer);

// COMPILE-TIME ERROR (E-TYP-2302):
// Type mismatch in function argument.
// Expected: `(move Buffer) -> ()`
// Found:    `(Buffer) -> ()`
do_consuming_work(inspect, move my_buffer);
```
### 22.5 Function Pointers vs. Witness Closures [type.function.objects]

Cursive's type system makes an explicit distinction between simple, non-capturing function pointers and stateful, capturing closures. This distinction is represented at the type level using the `witness` keyword, making the cost and capabilities of each form clear.

#### 22.5.1 Sparse Function Pointers [type.function.objects.sparse-function-pointers]

> **Sparse Function Pointer Definition**
>
> A **sparse function pointer** represents a direct pointer to a procedure's machine code. It does not carry any captured environment.
>
> The type of a sparse function pointer is written as `(T) -> U`.
>
> **Properties:**
> *   **Size:** One pointer.
> *   **FFI-Safe:** Can be passed to C code that expects a function pointer.
> *   **Creation:** A non-capturing, top-level `procedure` or a non-capturing closure literal will have this type.

#### 22.5.2 Dense Witness Closures [type.function.objects.dense-closure-objects]

> **Witness Closure Definition**
>
> A **witness closure** represents a stateful, callable entity. It is a "dense pointer" containing both a pointer to the function's machine code and a pointer to its captured environment (the closure's state).
>
> The type of a witness closure is written as `witness (T) -> U`.
>
> **Properties:**
> *   **Size:** Two pointers.
> *   **Not FFI-Safe:** Cannot be passed to C code.
> *   **Creation:** A closure literal that captures variables from its surrounding scope will have this type.

***Example (Type Distinction):***
```cursive
// This is a top-level procedure. Its type is `(i32) -> bool`.
procedure is_even(n: i32): bool {
    result n % 2 == 0;
}

// A procedure that requires a simple, non-capturing function pointer.
procedure run_simple_task(task: (i32) -> bool) {
    let success = task(10);
}

// A procedure that can accept a stateful witness closure.
procedure run_complex_task(task: witness (i32) -> bool) {
    let success = task(10);
}

// --- Usage ---

run_simple_task(is_even); // OK

let divisor = 3;
// This closure captures `divisor`, so its type is `witness (i32) -> bool`.
let is_divisible = |n: i32|: bool { result n % divisor == 0; };

run_complex_task(is_divisible); // OK

// COMPILE-TIME ERROR (E-TYP-2302): Type mismatch.
// The stateful witness closure cannot be passed where a simple function pointer is expected.
// run_simple_task(is_divisible);
```

#### 22.5.3 Subtyping [type.function.objects.subtyping]

> **Function Pointer Subtyping**
>
> A sparse function pointer is a subtype of a dense witness closure. A non-capturing function can be used where a stateful closure is expected.
>
> `(T) -> U` is a subtype of `witness (T) -> U`.


### 22.6 Diagnostics Summary [type.function.diagnostics]

This chapter introduces the following diagnostics in the `TYP` (Type System) category.

| Code       | Severity | Description                                                                                                                                  |
| :--------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------- |
| E-TYP-2301 | Error    | Mismatched parameter count: expected `N` arguments, but `M` were provided.                                                                   |
| E-TYP-2302 | Error    | Type mismatch in function call or assignment. This includes mismatches in parameter types, return types, capabilities, and `move` modifiers. |
| E-TYP-2304 | Error    | A non-`()` return type is required, but no `result` was provided on a control-flow path.                                                     |

---

# Part 5 - Language Syntax and Semantics [part-5---language-syntax-and-semantics]

## 23. Declarations [decl]
This chapter defines the core syntactic constructs that introduce named entities into the Cursive language. All declarations respect the single, unified namespace defined in §13.1 [names.namespaces].

### 23.1 Variable Bindings [decl.variable-bindings]
Variable bindings introduce an identifier for a value and its associated type. Cursive's binding system is orthogonal, separating binding mutability (let vs. var) from type mutability (the permission system). All bindings created with the = operator are responsible for their value's lifetime and cleanup (RAII).

#### 23.1.1 Syntax [decl.binding.syntax]

A variable binding MUST conform to the following syntactic form in safe code:

```ebnf
variable_binding ::= ( "let" | "var" ) <identifier> [ ":" <type> ] "=" <expression>
```

#### 23.1.2 Binding Mutability (let vs. var) [decl.binding.mutability]

The keyword used in a declaration **MUST** determine the binding's mutability.

*   `let`: Creates an **immutable binding**. The binding **MUST NOT** be re-assigned after its initialization. This is the default and preferred binding form.
*   `var`: Creates a **mutable binding**. The binding **MAY** be re-assigned to a new value using the `=` operator.

An attempt to re-assign a `let` binding **MUST** trigger diagnostic `E-DEC-2401`.

#### 23.1.3 Responsibility and Initialization (=) [decl.binding.responsibility]

The = operator MUST be the only operator used for initialization. The = operator creates a responsible binding. The binding is considered the owner of the value it is initialized with. This binding is responsible for the value's lifetime and MUST ensure the value is cleaned up (i.e., its Drop trait is called) when the binding goes out of scope. This mechanism is the foundation of Cursive's RAII (Resource Acquired on Initialization) memory model (see §30.2).

#### 23.1.4 Mutability as a Permission [decl.binding.permission]

The mutability of the data a binding refers to is independent of the binding's mutability (`let` vs. `var`). Data mutability **MUST** be expressed using the permission type system. To create a binding that can be used to mutate its data, the type **MUST** be qualified with the `unique` or `partitioned` permission (see §16.2, §16.3).
Example:
```cursive
// A default 'let' binding.
// 'data' is an immutable binding (cannot be re-assigned).
// 'data' has 'const' permission (data cannot be changed).
let data = MyRecord { ... }

// A 'var' binding.
// 'count' is a mutable binding (can be re-assigned).
// 'count' has 'const' permission (the i32 value itself is immutable).
var count = 10
count = 20 // OK: re-assigning the binding.

// A 'let' binding with 'unique' permission.
// 'buffer' is an immutable binding (cannot be re-assigned).
// 'buffer' has 'unique' permission (the data *can* be changed).
let buffer: unique = Buffer::new()
buffer.fill(0xFF) // OK: mutating data via 'unique' permission.
// buffer = ... // ERROR (E-DEC-2401): 'buffer' is a 'let' binding.
```

### 23.2 Procedure Declarations (procedure) [decl.procedure]
A procedure declaration introduces a named, callable entity (a function) into the unified namespace.

#### 23.2.1 Syntax [decl.procedure.syntax]
> **Procedure Syntax**
>
> A procedure declaration MUST conform to the following syntactic form:
>
> ```ebnf
> procedure_declaration ::=
>     [ <visibility> ] [ "comptime" ] "procedure" <identifier>
>     [ <generic_params> ] "(" [ <param_list> ] ")"
>     [ ":" <return_type> [ "<:" <trait_type> ] ]
>     [ <sequent_clause> ]
>     <callable_body>
> ```
>
> 1.  A `comptime` prefix marks the procedure for compile-time execution (see §34.1).
> 2.  The return type may optionally include an **opaque implementation clause** (`<: <trait_type>`) as defined in §28.5.
> 3.  A `<block_stmt>` provides a full procedure body.
> 4.  An expression body (`= <expression>;`) provides a simple, pure implementation.
> 5.  A semicolon (`;`) without a body is used for `extern` FFI declarations (see §33.1).

##### 23.2.1.1 Parameter List and Receiver Shorthands [decl.procedure.syntax.parameter-list-and-receiver-shorthands]

> **Parameter List Syntax**
>
> The `<param_list>` in a procedure declaration **MUST** conform to the following syntax:
>
> ```ebnf
> param_list ::= <parameter> ("," <parameter>)*
> parameter  ::= <receiver_shorthand>
>              | [ "move" ] <identifier> ":" <type>
>
> receiver_shorthand ::= "~" | "~%" | "~!"
> ```
>
> The **Receiver Shorthands** (`~`, `~%`, `~!`) are syntactic sugar for declaring the `self` parameter. They **MUST** only appear as the first parameter of a procedure declared within a `record`, `enum`, `modal`, or `trait` definition.
>
> Implementations **MUST** desugar these tokens according to the following table:
>
> | Shorthand | Desugared Form            | Permission    | Meaning                                      |
> | :-------- | :------------------------ | :------------ | :------------------------------------------- |
> | `~`       | `self: const Self`        | `const`       | Read-only access (Default)                   |
> | `~%`      | `self: partitioned Self`  | `partitioned` | Read-write access with aliasing checks       |
> | `~!`      | `self: unique Self`       | `unique`      | Exclusive read-write access (No aliasing)    |

> **Note:** The `~!` shorthand (Unique Receiver) corresponds to the ownership semantics required by operations like `Drop::drop`.

#### 23.2.2 Contractual Sequent ([[...]]) [decl.procedure.sequent]

A procedure declaration **MAY** include an optional contract, as defined in §28. The contract **MUST** use the form `[[ [ <must_clause> ] [ "=>" <will_clause> ] ]]`.

#### 23.2.3 Parameter Responsibility (move) [decl.procedure.move]

By default, procedure parameters are non-responsible. They receive a `const` view of the argument, and the caller retains ownership. To accept ownership (cleanup responsibility) of an argument, a parameter **MUST** be prefixed with the `move` keyword.

**_Formal rule (Parameter Responsibility):_**

$$
\frac{
\text{proc} = \text{`procedure P(data: T)`} \quad \text{call is `P(arg)`}
}{
\text{Caller retains ownership of } arg
}
\tag{T-Param-NonResponsible}
\\ 
\frac{
\text{proc} = \text{`procedure P(move data: T)`} \quad \text{call is `move P(arg)`}
}{
\text{Ownership of } arg \text{ transfers to } \text{proc}
}
\tag{T-Param-Responsible}
$$

> **Move Call Semantics**
>
> A call to a procedure that expects a `move` parameter **MUST** use the `move` keyword at the call site (e..g, `move my_proc(my_value)`).
> Conversely, a call **MUST NOT** use the `move` keyword if the parameter is not declared with `move`.
>
**_Diagnostic:_**

| Code         | Severity | Description                           |
| :----------- | :------- | :------------------------------------ |
| `E-DEC-2411` | Error    | `move` keyword mismatch at call site. |

***Example:***

```cursive
// 'inspect' takes a non-responsible view.
procedure inspect(data: Buffer) {
// ...
}

// 'consume' takes ownership via 'move'.
procedure consume(move data: Buffer) {
// 'data' is now owned by this procedure.
} // 'data' is dropped here.

let buf: unique = Buffer::new()
inspect(buf)      // OK. 'buf' is still valid.
consume(move buf) // OK. Ownership is transferred. 'buf' is now invalid.
```

#### 23.2.4 Diagnostics Summary [decl.procedure.diagnostics]

| Code       | Severity | Description                                                               |
| :--------- | :------- | :------------------------------------------------------------------------ |
| E-DEC-2411 | Error    | `move` mismatch: Call site does not match procedure's `move` expectation. |

-----

### 23.3 Type Declarations (`record`, `enum`, `modal`, `type`) [decl.type]

Type declarations introduce new nominal types or type aliases into the unified namespace.

#### 23.3.1 `record` Declaration [decl.type.record]

> **Record Declaration**
>
> A `record` declaration defines a nominal product type with named fields.
>
> ```ebnf
> record_declaration ::= [ <visibility> ] "record" <identifier> [ <generic_params> ] [ "<:" <trait_list> ] "{" ( <field_decl> ("," <field_decl>)* ","? )? "}"
> field_decl ::= [ <visibility> ] <identifier> ":" <type>
> ```

#### 23.3.2 `enum` Declaration [decl.type.enum]

> **Enum Declaration**
>
> An `enum` declaration defines a nominal sum type (a tagged union) with one or more variants.
>
> ```ebnf
> enum_declaration ::= [ <visibility> ] "enum" <identifier> [ <generic_params> ] [ "<:" <trait_list> ] "{" ( <variant> ("," <variant>)* ","? )? "}"
> variant ::= <identifier> [ "(" <type_list> ")" | "{" <field_decl_list> "}" ]
> ```

#### 23.3.3 `modal` Declaration [decl.type.modal]

> **Modal Declaration**
>
> A `modal` declaration defines a nominal type with compile-time states. Its syntax and semantics are fully defined in §19 [type.modal].
>
> ```ebnf
> modal_declaration ::= [ <visibility> ] "modal" <identifier> [ <generic_params> ] [ "<:" <trait_list> ] "{" <state_block>+ "}"
> ```

#### 23.3.4 `type` Alias Declaration [decl.type.alias]

> **Type Alias Declaration**
>
> A `type` declaration defines a transparent alias for an existing type. The alias is equivalent to the original type in all contexts.
>
> ```ebnf
> type_alias_declaration ::= [ <visibility> ] "type" <identifier> [ <generic_params> ] "=" <type>
> ```
>
> A type alias **MUST NOT** be directly or indirectly recursive.
>
**_Diagnostic:_**

| Code         | Severity | Description                          |
| :----------- | :------- | :----------------------------------- |
| `E-DEC-2420` | Error    | Type alias `AliasName` is recursive. |

#### 23.3.5 Trait Implementation (`<:`) [decl.type.trait]

> **Trait Implementation Clause**
>
> A `record`, `enum`, or `modal` declaration **MUST** specify the traits it implements by using the subtype operator (`<:`) followed by a comma-separated list of trait identifiers (the "implements clause").
>
> The semantics of trait implementation are defined in §29.2 [traits.implementation].

***Example:***

```cursive
// 'Point' implements the 'Drawable' trait.
record Point <: Drawable {
x: f64,
y: f64,

// Implementation of 'Drawable::draw'
procedure draw(self: const, ctx: Context) {
// ...
}
}
```

#### 23.3.6 Diagnostics Summary [decl.type.diagnostics]

| Code       | Severity | Description                          |
| :--------- | :------- | :----------------------------------- |
| E-DEC-2420 | Error    | Type alias `AliasName` is recursive. |

-----

### 23.4 Program Entry (`main`) [decl.main]

A Cursive executable is defined by a program entry point. The entry point's signature is strictly defined by the Capability system.

#### 23.4.1 Required Capability Signature [decl.main.signature]

> **Main Procedure Requirement**
>
> A conforming executable program **MUST** contain exactly one procedure named `main` with `public` visibility.
>
> This `main` procedure **MUST** have the following signature [cite: CursiveDesignUpdate.md §5.8]:
>
> ```cursive
> public procedure main(ctx: Context): i32
> ```
>

**_Diagnostic:_**

| Code         | Severity | Description                            |
| :----------- | :------- | :------------------------------------- |
| `E-DEC-2430` | Error    | Missing or duplicate `main` procedure. |
>
> A program whose `main` procedure does not exactly match this signature **MUST** trigger diagnostic `E-DEC-2431`.

**_Diagnostic:_**

| Code         | Severity | Description                                                                        |
| :----------- | :------- | :--------------------------------------------------------------------------------- |
| `E-DEC-2431` | Error    | `main` signature is incorrect. Must be `public procedure main(ctx: Context): i32`. |

#### 23.4.2 The `Context` Parameter [decl.main.context]

> **Context Parameter**
>
> The `ctx: Context` parameter is the **root of capability** for the program. The Cursive runtime **MUST** construct and pass this record to the `main` procedure upon startup.
>
> The `Context` record provides all system-level capabilities (e.g., `ctx.fs` for filesystem, `ctx.heap` for memory, `ctx.net` for network) to the program. The `Context` record and the Capability system are fully defined in §31 [ocap].

**_Diagnostic:_**

| Code         | Severity | Description                                                                        |
| :----------- | :------- | :--------------------------------------------------------------------------------- |
| `E-DEC-2430` | Error    | Missing or duplicate `main` procedure.                                             |
| `E-DEC-2431` | Error    | `main` signature is incorrect. Must be `public procedure main(ctx: Context): i32`. |

#### 23.4.3 Return Value [decl.main.return]

> **Main Return Value**
>
> The `i32` return type **MUST** be used by the program to signal its exit status to the host environment. A return value of `0` indicates success, while a non-zero value indicates failure.

#### 23.4.4 Diagnostics Summary [decl.main.diagnostics]

| Code       | Severity | Description                                                                        |
| :--------- | :------- | :--------------------------------------------------------------------------------- |
| E-DEC-2430 | Error    | Missing or duplicate `main` procedure.                                             |
| E-DEC-2431 | Error    | `main` signature is incorrect. Must be `public procedure main(ctx: Context): i32`. |

### 23.5 Attributes [decl.attribute]

This chapter defines the syntax and general semantics for **attributes**, the unified mechanism for adding metadata to declarations. Attributes provide information to the compiler to influence code generation, enable or disable language features, or enforce conformance rules.

#### 23.5.1 Attribute Syntax [decl.attribute.attribute-syntax]

Attributes are specified using double square brackets `[[...]]`.

> **Attribute Syntax**
>
> An attribute declaration **MUST** conform to the following syntactic form:
>
> ```ebnf
> attribute_list ::= attribute+
> attribute ::= "[[" \<attribute\_spec\> ("," \<attribute\_spec\>)\* "]]"
> attribute\_spec ::= <identifier> [ "(" \<attribute\_args\> ")" ]
> attribute\_args ::= \<attribute\_arg\> ("," \<attribute\_arg\>)\*
> attribute\_arg ::= <literal>
> | <identifier>
> | <identifier> ":" <literal>
> ```
>
> 1.  **Placement:** An `attribute_list` **MUST** appear immediately before the declaration it modifies.
> 2.  **Form:** An attribute consists of `[[` and `]]` delimiters enclosing one or more comma-separated `attribute_spec`s.
> 3.  **Specification:** An `attribute_spec` is an identifier (the attribute's name) optionally followed by a parenthesized argument list.
> 4.  **Arguments:** Arguments can be simple literals (e.g., `"C"`), identifiers (e.g., `static`), or named key-value pairs (e.g., `auditor: "Jane Doe"`).

***Example:***

```cursive
// Single attribute, no arguments
[[reflect]]
record Point { x: f64, y: f64 }

// Single attribute with simple argument
[[repr(C)]]
record FFIStruct { ... }

// Single attribute with complex arguments
[[attestation(
    method: "Manual Audit",
    auditor: "Jane Doe",
    date: "2025-11-17"
)]]
unsafe { ... }

// Multiple attributes in one block
[[repr(C), no_mangle]]
extern "C" public procedure my_c_api() { ... }

// Multiple attribute blocks
[[public]]
[[deprecated("Use new_api() instead")]]
procedure old_api() { ... }
```

#### 23.5.2 Attribute Constraints [decl.attribute.attribute-constraints]

> **Attribute Well-Formedness**
>
> An attribute **MUST** be well-formed. An attribute is well-formed if its name is a valid identifier and its arguments, if any, are syntactically valid literals or identifiers as defined by the EBNF.

**_Diagnostic:_**

| Code         | Severity | Description                 |
| :----------- | :------- | :-------------------------- |
| `E-DEC-2450` | Error    | Malformed attribute syntax. |
>
> An implementation **MUST** maintain a registry of known attributes defined by this specification (e.g., `[[repr]]`, `[[attestation]]`) and by the implementation (e.g., vendor-prefixed attributes).
>
> An implementation **MUST** issue diagnostic `E-DEC-2451` for any attribute name that is not in its registry of known attributes.

**_Diagnostic:_**

| Code         | Severity | Description        |
| :----------- | :------- | :----------------- |
| `E-DEC-2451` | Error    | Unknown attribute. |
>
**_Diagnostic:_**

| Code         | Severity | Description                 |
| :----------- | :------- | :-------------------------- |
| `E-DEC-2450` | Error    | Malformed attribute syntax. |
| `E-DEC-2451` | Error    | Unknown attribute.          |

#### 23.5.3 Attribute Semantics [decl.attribute.attribute-semantics]

> **Attribute Semantics**
>
> Attributes are compile-time metadata. They **MUST NOT** alter the runtime semantics of a declaration unless this specification explicitly defines such a semantic change for that attribute (e.g., `[[repr(C)]]` changing memory layout).
>
> The interpretation of a well-formed attribute is defined by the feature it governs.
>
>   * **Conformance Attributes** (e.g., `[[attestation]]`) are defined in Part 1, §6 [conformance].
>   * **Layout Attributes** (e.g., `[[repr(C)]]`) are defined in Part 7, §33 [ffi].
>   * **Metaprogramming Attributes** (e.g., `[[reflect]]`) are defined in Part 7, §34 [meta].
>
> Implementations **MAY** define additional attributes, but these **MUST** follow the namespacing rules for extensions (e.g., vendor prefixes) defined in §7.3 [evolution.extensions].

#### 23.5.4 Diagnostics Summary [decl.attribute.diagnostics]

This chapter introduces the following diagnostics in the `DEC` (Declaration) category.

| Code       | Severity | Description                 |
| :--------- | :------- | :-------------------------- |
| E-DEC-2450 | Error    | Malformed attribute syntax. |
| E-DEC-2451 | Error    | Unknown attribute.          |

---

## 24. Expressions [expr]

This chapter defines the syntax and semantics of expressions in Cursive. An expression is a syntactic form that produces a value and has a type. All expressions are subject to the language's strict, deterministic evaluation rules and are validated by the type system at compile time.

### 24.1 Expression Fundamentals [expr.fundamental]

#### 24.1.1 Overview [expr.fundamental.overview]

Expressions are the fundamental unit of computation in Cursive. Every expression produces a value, has a static type, and may have side effects. The evaluation of an expression is governed by the rules of this chapter, the type system (Part 4), and the memory model (Part 6, §30).

#### 24.1.2 Evaluation Order [expr.fundamental.evaluation-order]

> **Evaluation Order**
>
> Cursive's evaluation order **MUST** be deterministic. For any compound expression, its subexpressions **MUST** be evaluated strictly from left to right.
>
> The only exception to this rule is for the logical `&&` and `||` operators, which **MUST** implement short-circuiting behavior as defined in §25.4.1.

#### 24.1.3 Value Categories [expr.fundamental.value-categories]

Every expression is classified into one of two value categories, which determines how it can be used.

> **Value Categories**
>
> 1.  **Place Expression:** A `place` expression refers to a memory location. Places can be the target of an assignment, and their address can be taken. Bindings (`let`, `var`), dereferenced pointers, and fields of a `place` are themselves `place`s.
> 2.  **Value Expression:** A `value` expression produces a temporary value that does not have a persistent memory location. Literals, arithmetic results, and the return values of most procedure calls are `value`s.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                           |
| :----------- | :------- | :-------------------------------------------------------------------- |
| `E-EXP-2502` | Error    | A `value` expression was used where a `place` expression is required. |

### 24.2 Operator Precedence and Associativity [expr.precedence]

#### 24.2.1 Overview [expr.precedence.overview]

The order in which operators in a compound expression are evaluated is determined by their precedence and associativity.

#### 24.2.2 Precedence Table [expr.precedence.precedence-table]

> **Operator Precedence**
>
> The following table lists Cursive's operators from highest to lowest precedence. Operators on the same row have the same precedence. The associativity column specifies how operators of the same precedence are grouped. All binary operators are left-associative except for the power operator (`**`) and assignment operators, which are right-associative.

| Precedence | Operator(s)                                              | Description                             | Associativity |
| :--------- | :------------------------------------------------------- | :-------------------------------------- | :------------ |
| 1          | `()` `[]` `.` `~>` `::`                                  | Call, Index, Field, Method, Scope       | Left          |
| 2          | `=>`                                                     | Pipeline                                | Left          |
| 3          | `!` `-` `&` `*` `^` `move`                               | Unary Not, Neg, Ref, Deref, Alloc, Move | Right         |
| 4          | `**`                                                     | Power                                   | Right         |
| 5          | `*` `/` `%`                                              | Multiplicative                          | Left          |
| 6          | `+` `-`                                                  | Additive                                | Left          |
| 7          | `<<` `>>`                                                | Bitwise Shift                           | Left          |
| 8          | `&`                                                      | Bitwise AND                             | Left          |
| 9          | `^`                                                      | Bitwise XOR                             | Left          |
| 10         | `\|`                                                     | Bitwise OR                              | Left          |
| 11         | `==` `!=` `<` `<=` `>` `>=`                              | Comparison                              | Left          |
| 12         | `&&`                                                     | Logical AND                             | Left          |
| 13         | `\|\|`                                                   | Logical OR                              | Left          |
| 14         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Assignment                              | Right         |

### 24.3 Primary and Postfix Expressions [expr.primary]

Primary expressions are the most basic operands. Postfix expressions are formed by applying an operator after a primary expression.

#### 24.3.1 Literals, Identifiers, and Parentheses [expr.primary.literals-identifiers-and-parentheses]

> **Primary Expressions**
>
> A **literal** (e.g., `123`, `"hello"`, `true`) is a primary expression. Its type is defined in §9.4 and §17.
>
> An **identifier** is a primary expression. It **MUST** resolve to a value binding according to the name lookup rules in §13.4.
>
**_Diagnostic:_**

| Code         | Severity | Description                                           |
| :----------- | :------- | :---------------------------------------------------- |
| `E-EXP-2511` | Error    | Identifier resolves to a type or module, not a value. |
>
> A **parenthesized expression** `(<expression>)` has the same value, type, and value category as the enclosed expression.

#### 24.3.2 Field Access (`.`) [expr.primary.field-access]

> **Field and Tuple Access**
>
> A field access expression `record_expr.field` **MUST** be applied to an expression of a `record` type. The `field` **MUST** be a declared field of that record and **MUST** be visible in the current scope (§12.1).
>
> A tuple access expression `tuple_expr.index` **MUST** be applied to an expression of a tuple type. The `index` **MUST** be a constant, non-negative integer literal that is a valid zero-based index for the tuple.
>
**_Diagnostic:_**

| Code         | Severity | Description                                            |
| :----------- | :------- | :----------------------------------------------------- |
| `E-EXP-2531` | Error    | Invalid field or tuple index, or field is not visible. |

#### 24.3.3 Procedure and Method Calls (`()`) [expr.primary.procedure-and-method-calls]

> **Procedure Call**
>
> A procedure call `callable_expr(arg1, arg2, ...)` **MUST** be applied to an expression of a function type (§22).
>
> **Method Calls (`~>` and `::`)**
>
> 1.  **Instance Method Call (`~>`):**
>     The **Receiver Dispatch Operator** `~>` **MUST** be used for calling methods on a value (instance).
>     ```cursive
>     receiver_expr~>method_name(arg1, ...)
>     ```
>     *   **Semantics:** Resolves to a call of the method on the type of `receiver_expr`.
>     *   **Rationale:** This operator visually distinguishes the "message send" semantics of a method call (code execution) from the structural access of a field (memory offset) via `.`. It symbolically combines the Receiver Shorthand `~` with the directional arrow `>`.
>
> 2.  **Static/Disambiguated Call (`::`):**
>     The double-colon operator `::` **MUST** be used for:
>     *   **Static Calls:** Calling a method on a type (e.g., `MyType::new()`).
>     *   **Disambiguation:** Calling a specific trait implementation when an instance method call is ambiguous.
>
**_Diagnostic:_**

| Code         | Severity | Description                            |
| :----------- | :------- | :------------------------------------- |
| `E-EXP-2533` | Error    | Method call using `.` instead of `::`. |

#### 24.3.4 Indexing (`[]`) [expr.primary.indexing]

> **Indexing Expression**
>
> An indexing expression `sequence_expr[index_expr]` **MUST** be applied to an expression of an `array` type (§18.5) or a `slice` type (§18.6).
>
> The `index_expr` **MUST** have the type `usize`.
>
> All indexing operations **MUST** be bounds-checked at runtime. An out-of-bounds access **MUST** cause the executing thread to panic.

#### 24.3.5 Pipeline (`=>`) [expr.primary.pipeline]

> **Pipeline Expression**
>
> The pipeline expression `lhs_expr => rhs_expr` is syntactic sugar for a procedure call `rhs_expr(lhs_expr)`.
>
> The `rhs_expr` **MUST** be a callable expression that accepts a single argument whose type is compatible with the type of `lhs_expr`.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                 |
| :----------- | :------- | :---------------------------------------------------------- |
| `E-EXP-2535` | Error    | Right-hand side of a pipeline `=>` is not a valid callable. |

### 24.4 Unary and Binary Operators [expr.operators]

#### 24.4.1 Logical Operators (`!`, `&&`, `||`) [expr.operators.logical-operators]

> **Logical Operators**
>
> The unary logical NOT operator `!` **MUST** be applied to an operand of type `bool`.
>
> The binary logical AND (`&&`) and OR (`||`) operators **MUST** take two operands of type `bool`. They **MUST** be implemented with short-circuiting semantics.
>
**_Diagnostic:_**

| Code         | Severity | Description                           |
| :----------- | :------- | :------------------------------------ |
| `E-EXP-2541` | Error    | Logical operator applied to non-bool. |

#### 24.4.2 Arithmetic and Bitwise Operators [expr.operators.arithmetic-and-bitwise-operators]

> **Multiplicative and Power Operators:**
> The binary multiplicative operators (`*`, `/`, `%`) and the power operator (`**`) **MUST** take operands of the same primitive numeric type (§17.1, §17.2). There are no implicit numeric promotions.
>
> **Additive Operators (`+`, `-`):**
> The binary additive operators **MUST** take operands that satisfy one of the following typing rules:
>
> 1.  **Numeric Arithmetic:** Both operands are of the same primitive numeric type. The result type is the same as the operand type.
> 2.  **Pointer Offset:** One operand is a raw pointer (`*imm T` or `*mut T`) and the other is an integer of type `usize` or `isize`. The result type is the same as the pointer operand. This operation scales the integer offset by `sizeof(T)`.
> 3.  **Pointer Distance:** Both operands are raw pointers to the same type `T`, and the operator is `-`. The result type is `isize`.
>
> **Safety Constraint:** Usage of `+` or `-` with raw pointer operands is an **unsafe operation**. It **MUST** be enclosed within an `unsafe` block or expression.
>
> **Bitwise Operators:**
> The binary bitwise operators (`&`, `|`, `^`, `<<`, `>>`) **MUST** take operands of the same primitive integer type (§17.1).
>
**_Diagnostic:_**

| Code         | Severity | Description                                                          |
| :----------- | :------- | :------------------------------------------------------------------- |
| `E-EXP-2542` | Error    | Invalid types for arithmetic/bitwise operator.                       |
| `E-MEM-3030` | Error    | Unsafe operation in safe code (pointer arithmetic outside `unsafe`). |

#### 24.4.3 Comparison Operators [expr.operators.comparison-operators]

> **Comparison Operators**
>
> The comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) **MUST** take two operands of the same type. The result of a comparison expression **MUST** have the type `bool`.

#### 24.4.4 Address-Of (`&`) and Dereference (`*`) [expr.operators.address-of-and-dereference]

> **Address-Of Operator**
>
> The address-of operator `&` **MUST** be applied to a `place` expression (§25.1.3). Its result **MUST** be a safe pointer of type `Ptr<T>@Valid`, as defined in §21.1.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                |
| :----------- | :------- | :--------------------------------------------------------- |
| `E-EXP-2545` | Error    | Address-of operator `&` applied to a non-place expression. |
>
> The dereference operator `*` **MUST** be applied to an expression of a pointer type. Its usage is governed by the rules in §21.1 for safe pointers and §21.2 for raw pointers.

#### 24.4.5 Region Allocation Operator (`^`) [expr.operators.region-allocation-operator]

> **Region Allocation**
>
> The unary prefix operator `^` allocates the result of its operand expression into the lexically innermost active `region`.
>
> 1.  **Syntax:** `^ <expression>`
> 2.  **Semantics:** The operand expression is evaluated to a value. Storage is allocated in the current region for that value. The value is moved into that storage.
> 3.  **Result:** The result of the operation is the value itself (not a pointer), but its **provenance** is updated to `Region(CurrentID)`.
> 4.  **Constraint:** Usage of `^` outside of a valid `region` block **MUST** be diagnosed as error `E-MEM-3021`.
>
**_Diagnostic:_**

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-MEM-3021` | Error    | Region allocation `^` outside region scope. |

### 24.5 `move` Expression [expr.move]

> **Move Expression**
>
> A `move` expression `move <binding>` transfers the ownership of the value from the specified binding.
>
> The `<binding>` **MUST** be an identifier that refers to a responsible `let` binding.
>
> After the `move` expression is evaluated, the source binding is **statically invalidated** as defined in §30.2. Any subsequent use of the invalidated binding **MUST** be a compile-time error.

### 24.6 `if` Expressions [expr.if]

> **If Expression**
>
> An `if` expression **MUST** conform to the syntax `if <condition> { <then_block> } else { <else_block> }`.
>
> The `<condition>` **MUST** have the type `bool`.
>
> The `<then_block>` and `<else_block>` **MUST** produce values of the same type. This common type is the type of the `if` expression.
>
> If the `else` clause is omitted, the `<then_block>` **MUST** produce the unit type `()`, and the `if` expression's type is `()`.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                |
| :----------- | :------- | :--------------------------------------------------------- |
| `E-EXP-2561` | Error    | `if` expression without `else` used in a non-unit context. |

### 24.7 `match` Expressions [expr.match]

> **Match Expression**
>
> A `match` expression provides exhaustive pattern matching on a scrutinee expression.
>
> ```ebnf
> match_expression ::= "match" <expression> "{" <match_arm>+ "}"
> match_arm ::= <pattern> "=>" <expression> ","
> ```
>
> The patterns in the `match_arm` list **MUST** be exhaustive for the type of the scrutinee expression, as defined in §27.2.
>
> The expressions in all `match_arm`s **MUST** produce values of the same type. This common type is the type of the `match` expression.
>
**_Diagnostic:_**

| Code         | Severity | Description                         |
| :----------- | :------- | :---------------------------------- |
| `E-EXP-2571` | Error    | Incompatible types in `match` arms. |

### 24.8 `loop` Expressions [expr.loop]

#### 24.8.1 Forms of `loop` [expr.loop.forms-of-loop]

> **Loop Forms**
>
> A `loop` expression **MUST** conform to one of the following three forms:
>
> 1.  **Infinite loop:** `loop { <body> }`. This expression has the never type `!`.
> 2.  **Conditional loop:** `loop <condition> { <body> }`. The `<condition>` **MUST** have type `bool`. This expression has the unit type `()`.
> 3.  **Iterator loop:** `loop <item>: <Type> in <iterator> { <body> }`. The `<iterator>` expression **MUST** conform to the iterator protocol. The type annotation `<Type>` for the loop variable is mandatory. This expression has the unit type `()`.

#### 24.8.2 `loop` with `break` Value [expr.loop.loop-with-break-value]

> **Loop Break Value**
>
> A `loop` expression may produce a value via a `break <expression>` statement.
>
> If one or more `break` statements within a loop provide a value, then all `break` statements for that loop **MUST** provide a value of the same type. This common type becomes the type of the `loop` expression.
>
> A mix of valued and non-valued `break` statements for the same loop, or `break` statements with mismatched types, **MUST** trigger diagnostic `E-EXP-2582`.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                          |
| :----------- | :------- | :------------------------------------------------------------------- |
| `E-EXP-2582` | Error    | `break` statements within a single loop have mismatched value types. |

### 24.9 Structured Block Expressions [expr.structured]

This section defines special block constructs that, in addition to controlling scope and side effects, can be used as expressions to produce a value.

#### 24.9.1 `region` Expression [expr.structured.region-expression]

> **Region Expression**
>
> A `region` expression creates a temporary memory arena and evaluates a block of code within it. Its primary semantic effect is memory management, as defined in §30.6.
>
> A `region` expression **MUST** conform to the syntax `region { <body> }`.
>
> The value and type of a `region` expression are determined by the `result` statement within its body, identical to a standard block expression. If no `result` statement is present, the expression has the unit type `()`.
>
> The value produced by a `result` statement within a `region` expression **MUST NOT** contain any references to memory allocated within that region, unless that memory has been explicitly promoted to the heap.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                        |
| :----------- | :------- | :----------------------------------------------------------------- |
| `E-EXP-2591` | Error    | Returning region-allocated value from its own `region` expression. |

#### 24.9.2 `parallel` Expression [expr.structured.parallel-expression]

> **Parallel Expression**
>
> A `parallel` expression defines a concurrent execution epoch for Concurrent-Read, Exclusive-Write (CREW) patterns, as defined in §31.2.
>
> A `parallel` expression **MUST** conform to the syntax `parallel (<bindings>) { <body> }`.
>
> The value and type of a `parallel` expression are determined by the `result` statement within its body.
>
> The value produced by a `result` statement within a `parallel` expression **MUST NOT** be of a type that relies on bindings that are statically invalidated during the parallel epoch.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                        |
| :----------- | :------- | :----------------------------------------------------------------- |
| `E-EXP-2592` | Error    | Result of `parallel` expression depends on an invalidated binding. |

#### 24.9.3 `unsafe` Expression [expr.structured.unsafe-expression]

> **Unsafe Expression**
>
> An `unsafe` expression creates a block wherein certain compiler safety guarantees are disabled, as defined in §30.8.
>
> An `unsafe` expression **MUST** conform to the syntax `unsafe { <body> }`.
>
> The value and type of an `unsafe` expression are determined by the `result` statement within its body, identical to a standard block expression.

#### 24.9.4 `comptime` Expressions [expr.structured.comptime-expressions]

> **Comptime Expression**
>
> A `comptime` expression defines a block of code that is executed exclusively during the **Compile-Time Execution** phase (§8.4.1).
>
> ```ebnf
> comptime_expr ::= "comptime" <block>
> ```
>
> 1. **Evaluation:** The block is evaluated by the compiler. It MUST not perform runtime effects (e.g., I/O, heap allocation) unless authorized by specific capabilities available in the compile-time context (e.g., capabilities derived from the compiler root capability).
> 2.  **Result:** The result of the block **MUST** be a constant value. This value is substituted into the AST in place of the `comptime` expression.
> 3.  **Scope:** Bindings declared within the `comptime` block are not visible to the surrounding runtime code.
> 4.  **Type:** The type of a `comptime` expression is the type of the value produced by the block.

### 24.10 Diagnostics Summary [expr.diagnostics]

This chapter introduces the following diagnostics in the `EXP` (Expression) category.

| Code       | Severity | Description                                                              |
| :--------- | :------- | :----------------------------------------------------------------------- |
| E-EXP-2501 | Error    | Type mismatch in expression.                                             |
| E-EXP-2502 | Error    | A `value` expression was used where a `place` expression is required.    |
| E-EXP-2511 | Error    | Identifier resolves to a type or module, not a value.                    |
| E-EXP-2531 | Error    | Invalid field or tuple index, or field is not visible.                   |
| E-EXP-2532 | Error    | Mismatched number of arguments in procedure call.                        |
| E-EXP-2535 | Error    | Right-hand side of a pipeline `=>` is not a valid callable.              |
| E-EXP-2541 | Error    | Logical operator operand is not of type `bool`.                          |
| E-EXP-2542 | Error    | Mismatched or unsupported types for arithmetic or bitwise operator.      |
| E-EXP-2545 | Error    | Address-of operator `&` applied to a non-place expression.               |
| E-EXP-2561 | Error    | `if` expression without `else` used in a non-unit context.               |
| E-EXP-2571 | Error    | `match` arms have incompatible types.                                    |
| E-EXP-2582 | Error    | `break` statements within a single loop have mismatched value types.     |
| E-EXP-2591 | Error    | Cannot return a region-allocated value from its own `region` expression. |
| E-EXP-2592 | Error    | Result of `parallel` expression depends on an invalidated binding.       |



---

## 25. Statements [stmt]

This chapter defines the syntax and semantics of statements. A statement is a syntactic form that executes for its side effects and does not produce a value. Statements form the executable body of procedures, loops, and other control-flow blocks.

### 25.1 Statement Fundamentals [stmt.fundamental]

#### 25.1.1 Overview [stmt.fundamental.overview]

Statements are the primary mechanism for sequencing operations and controlling program flow. Unlike expressions, which evaluate to a value, statements are executed to modify state.

> **Statement Kinds**
>
> Every statement **MUST** be one of the following kinds:
>
> 1.  A **Declaration Statement** (§26.2), which introduces new bindings.
> 2.  An **Assignment Statement** (§26.3), which modifies the value of a place expression.
> 3.  An **Expression Statement** (§26.4), which evaluates an expression for its side effects.
> 4.  A **`defer` Statement** (§26.5), which schedules code for execution at scope exit.
> 5.  A **Control Flow Statement** (§26.6), which alters the flow of execution.
> 6.  A **Special Contract Statement** (§26.7), which provides compile-time directives.

#### 25.1.2 Statement Termination [stmt.fundamental.statement-termination]

> **Statement Termination**
>
> The rules for statement termination **MUST** be governed by the lexical structure defined in §10. A statement is terminated by a `<newline>` token unless one of the continuation conditions specified in that chapter is met. A semicolon (`;`) **MAY** also be used to terminate a statement, allowing multiple statements on a single line.

#### 25.1.3 Sequencing [stmt.fundamental.sequencing]

> **Sequential Execution**
>
> Statements within a block **MUST** be executed sequentially in the order they appear in the source text. The effects of a statement **MUST** be fully complete before the next statement begins execution.

### 25.2 Declaration Statements [stmt.decl]

Declaration statements introduce new bindings into the current scope.

> **Declaration Statement**
>
> A declaration statement **MUST** be a `let` or `var` variable binding, as defined in §24.1.
>
> The execution of a declaration statement introduces the specified binding(s) into the current lexical scope. The initializer expression is evaluated, and its resulting value is bound to the identifier(s) according to the rules of responsibility (§24.1.3) and pattern matching (§27).

### 25.3 Assignment Statements [stmt.assign]

Assignment statements modify the value stored in a `place` expression.

> **Assignment Syntax**
>
> An assignment statement **MUST** conform to one of the following forms:
>
> ```ebnf
> assignment_statement ::= <place_expression> <assignment_operator> <expression>
> assignment_operator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>="
> ```
>
> 1.  The left-hand side **MUST** be a `place` expression as defined in §25.1.3.
>
**_Diagnostic:_**

| Code         | Severity | Description                       |
| :----------- | :------- | :-------------------------------- |
| `E-STM-2631` | Error    | Assignment target is not a place. |
>
> 2.  The `place` expression **MUST** refer to a mutable binding (declared with `var`).
>
**_Diagnostic:_**

| Code         | Severity | Description                               |
| :----------- | :------- | :---------------------------------------- |
| `E-DEC-2401` | Error    | Re-assignment of immutable `let` binding. |
> 3.  The `place` expression **MUST** be accessible via a `unique` or `partitioned` permission. An attempt to assign via a `const` permission **MUST** trigger a diagnostic.
> 4. The right-hand side expression MUST be evaluated before the assignment occurs. Its type MUST be compatible with the type of the place expression.
> 5. Drop Semantics: If the place expression refers to an initialized, responsible binding (e.g., a var binding holding an owned value), the implementation MUST invoke the destructor (Drop::drop) of the current value. This destruction MUST occur deterministically, ensuring the old resource is released before or immediately after the new value is installed.

### 25.4 Expression Statements [stmt.expr]

Any expression can be used as a statement to execute it for its side effects.

> **Expression Statement**
>
> An expression statement consists of an expression that is evaluated, after which its resulting value is discarded. The type of an expression statement is the unit type `()`.
>
> Conforming implementations **SHOULD** issue a warning if an expression statement produces a non-unit value that is not explicitly used, as this may indicate a programmer error.

### 25.5 `defer` Statements [stmt.defer]

A `defer` statement schedules a block of code to be executed at the exit of the current lexical scope.

> **Defer Syntax**
>
> A `defer` statement **MUST** conform to the syntax `defer { <body> }`.
>
> The `<body>` block is not executed immediately. Instead, it **MUST** be pushed onto a per-scope stack of deferred actions.
>
>When a scope is exited—either by normal completion, a return statement, a result statement, or a break statement—all deferred blocks for that scope MUST be executed in Last-In, First-Out (LIFO) order.>
>
> The block within a `defer` statement **MUST** have the type `()`. It **MUST NOT** contain any control flow statement (`return`, `break`, `continue`) that would transfer control outside of the `defer` block itself.
>
**_Diagnostic:_**

| Code         | Severity | Description                                       |
| :----------- | :------- | :------------------------------------------------ |
| `E-STM-2652` | Error    | Non-local control flow (return/break) in `defer`. |
| `E-STM-2651` | Error    | `defer` block returns non-unit value.             |

***Example:***
```cursive
procedure process_resource() {
    let resource = open_resource();
    defer { close_resource(resource); } // Executed at scope exit.

    defer { log("Exiting scope..."); } // Executed *before* the first defer.

    if resource.is_invalid() {
        return; // Both defer blocks execute here, in LIFO order.
    }
} // Both defer blocks also execute on normal scope exit.
```

### 25.6 Control Flow Statements [stmt.control]

These statements exist solely to alter the flow of execution. They do not produce a value.

#### 25.6.1 `return` Statement [stmt.control.return-statement]

> **Return Statement**
>
> A `return` statement performs **non-local control flow** to immediately terminate the execution of the current procedure.
>
> It **MUST** conform to the syntax `return [<expression>]`.
>
> *   **Semantics:** Execution jumps immediately to the procedure epilogue. Any deferred actions in intermediate scopes are executed in LIFO order.
> *   **Distinction:** `return` is distinct from `result`. `return` exits the *procedure*; `result` exits the current *block*.
> *   **Type:** If an `<expression>` is provided, its type **MUST** match the declared return type of the enclosing procedure.
>
> A `return` statement **MUST NOT** be used at the top level of a module.

#### 25.6.2 `break` Statement [stmt.control.break-statement]

> **Break Statement**
>
> A `break` statement terminates the execution of the innermost `loop` expression.
>
> It **MUST** conform to the syntax `break ['<label>]`.
>
> If a `'<label>` is provided, it **MUST** terminate the enclosing loop or block with that label.
>
> A `break` statement **MUST** only be used within the body of a `loop` expression.
>
**_Diagnostic:_**

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-STM-2662` | Error    | `break` statement used outside of a `loop`. |
>
> > [!note]
> > The `break <expression>` form is part of a `loop` *expression* (§25.8.2) and is not a standalone statement.

#### 25.6.3 `continue` Statement [stmt.control.continue-statement]

> **Continue Statement**
>
> A `continue` statement skips to the next iteration of the innermost `loop` expression.
>
> It **MUST** conform to the syntax `continue ['<label>]`.
>
> A `continue` statement **MUST** only be used within the body of a `loop` expression.
>
**_Diagnostic:_**

| Code         | Severity | Description                                    |
| :----------- | :------- | :--------------------------------------------- |
| `E-STM-2663` | Error    | `continue` statement used outside of a `loop`. |

#### 25.6.4 `result` Statement [stmt.control.result-statement]

> **Result Statement**
>
> A `result` statement completes the execution of the current **structured block** (e.g., a procedure body, `if` branch, `match` arm, or `region` block) and provides its value to the enclosing context.
>
> It **MUST** conform to the syntax `result <expression>`.
>
> *   **Semantics:** The statement evaluates `<expression>` and transfers control to the end of the immediately enclosing block. It establishes the value of that block expression.
> *   **Usage:** `result` is the standard mechanism for data flow in Cursive. It defines the "happy path" value production.
> *   **Implicit Result:** In a block where the last statement is an expression without a terminator (e.g., `x + y`), implicit `result` semantics apply. However, explicit `result` is required for early exit from a block or to disambiguate types.
>
> ***Example:***
> ```cursive
> let val = if condition {
>     result 10 // Yields 10 from the 'if' block
> } else {
>     return 0 // Returns 0 from the entire procedure immediately
> }
> ```

### 25.7 Special Contract Statements [stmt.contract]

This section defines statement forms that serve as contracts with the compiler, affecting static analysis rather than runtime execution.

#### 25.7.1 `partition` Statement [stmt.contract.partition-statement]

The `partition` statement is a zero-cost, compile-time contract that provides the compiler with a proof of non-aliasing, allowing it to temporarily relax the static partitioning checks for `partitioned` data within a specific block.

> **Partition Syntax**
>
> A `partition` statement **MUST** conform to the following syntactic form:
>
> ```ebnf
> partition_statement ::=
>     "partition" <collection> "by" "(" <index_list> ")"
>     "where" "(" <proof_expression> ")"
>     <block_stmt>
> ```
>
> 1.  **Compile-Time Only:** The `partition` statement is a compile-time-only construct. It **MUST** generate **zero runtime code**.
> 2.  **Proof Requirement:** The `<proof_expression>` in the `where` clause **MUST** be an expression that the compiler can prove is `true` at compile time, according to the rules of the **Partition Proof Verifier** defined in §30.5.
>
**_Diagnostic:_**

| Code         | Severity | Description                                                                 |
| :----------- | :------- | :-------------------------------------------------------------------------- |
| `E-STM-2671` | Error    | `partition` contract proof failed; the `where` clause is not provably true. |
> 3.  **Safety Check Suspension:** Within the lexical scope of the `<block_stmt>`, the compiler **MUST** suspend all static partitioning safety checks for the specified `<collection>` when it is accessed via an index from the `<index_list>`. All other safety checks remain in effect.

### 25.8 Diagnostics Summary [stmt.diagnostics]

This chapter introduces the following diagnostics in the `STM` (Statement) category.

| Code       | Severity | Description                                                                  |
| :--------- | :------- | :--------------------------------------------------------------------------- |
| E-STM-2631 | Error    | Assignment target must be a `place` expression.                              |
| E-STM-2651 | Error    | `defer` block must have the unit type `()`.                                  |
| E-STM-2652 | Error    | `defer` block must not contain a `return` or other non-local control flow.   |
| E-STM-2661 | Error    | Type of `return` expression does not match the procedure's return type.      |
| E-STM-2662 | Error    | `break` statement used outside of a `loop`.                                  |
| E-STM-2663 | Error    | `continue` statement used outside of a `loop`.                               |
| E-STM-2664 | Error    | `result` value type does not match the expected type of the enclosing block. |
| E-STM-2671 | Error    | `partition` contract proof failed; the `where` clause is not provably true.  |

---

## 26. Pattern Matching [patterns]

This chapter defines the syntax and semantics of patterns. A pattern is a syntactic construct that destructures a value, testing it for a specific shape and binding parts of that value to new identifiers. Patterns are a core component of `match` expressions and `let` bindings.

### 26.1 Pattern Fundamentals [patterns.fundamental]

#### 26.1.1 Overview [patterns.fundamental.overview]

Patterns provide a declarative and safe mechanism for inspecting and deconstructing data. Every pattern is classified as either **irrefutable** or **refutable**, which determines the contexts in which it can be used.

#### 26.1.2 Irrefutable and Refutable Patterns [patterns.fundamental.irrefutable-and-refutable-patterns]

> **Pattern Refutability**
>
> 1.  An **irrefutable pattern** is a pattern that will match for any value of a given type. Identifier patterns (e.g., `x`) and tuple/record patterns composed of irrefutable sub-patterns are irrefutable.
> 2.  A **refutable pattern** is a pattern that can fail to match a value of a given type. Literal patterns and modal state patterns are always refutable. Enum variant patterns are refutable **unless** the enum definition contains exactly one variant, in which case the pattern is irrefutable (enabling destructuring of wrapper types in `let` bindings).
>
> The context in which a pattern is used **MUST** be compatible with its refutability.
>
> *   An **irrefutable context**, such as a `let` binding, **MUST** only use irrefutable patterns.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-PAT-2711` | Error | A refutable pattern was used in an irrefutable context (e.g., a `let` binding). |
> *   A **refutable context**, such as a `match` arm or an `if let` condition, **MAY** use either refutable or irrefutable patterns.

### 26.2 Pattern Syntax [patterns.syntax]

#### 26.2.1 Formal Syntax [patterns.syntax.formal-syntax]

> **Pattern Syntax**
>
> A pattern **MUST** conform to the following syntactic forms:
>
> ```ebnf
> pattern ::=
>     literal
>     | "_"                                         // Wildcard
>     | <identifier>                                // Identifier (Binding)
>     | <tuple_pattern>
>     | <record_pattern>
>     | <enum_variant_pattern>
>     | <modal_state_pattern>
>
> tuple_pattern ::= "(" ( <pattern> ("," <pattern>)* ","? )? ")"
>
> record_pattern ::=
>     <path> "{" ( <field_pattern> ("," <field_pattern>)* ","? )? "}"
> field_pattern ::= <identifier> [ ":" <pattern> ]
>
> enum_variant_pattern ::=
>     <path_to_variant>                             // Unit-like variant
>     | <path_to_variant> "(" <pattern_list> ")"    // Tuple-like variant
>     | <path_to_variant> "{" <field_pattern_list> "}" // Record-like variant
>
> modal_state_pattern ::=
>     "@" <StateIdentifier> [ "{" <field_pattern_list> "}" ]
>
> pattern_list ::= <pattern> ("," <pattern>)* ","?
> field_pattern_list ::= <field_pattern> ("," <field_pattern>)* ","?
> ```

#### 26.2.2 Pattern Descriptions [patterns.syntax.pattern-descriptions]

> **Pattern Summary**
>
> The following table summarizes each pattern form, its refutability, and its function.

| Pattern Type | Example Syntax                | Refutability    | Description                                                                                    |
| :----------- | :---------------------------- | :-------------- | :--------------------------------------------------------------------------------------------- |
| Literal      | `100`, `"hello"`, `true`      | Refutable       | Matches if the value is equal to the literal.                                                  |
| Wildcard     | `_`                           | Irrefutable     | Matches any value and binds nothing.                                                           |
| Identifier   | `x`                           | Irrefutable     | Matches any value and binds it to the identifier `x`.                                          |
| Tuple        | `(p1, p2, ...)`               | Irrefutable*    | Destructures a tuple. Must match arity.                                                        |
| Record       | `MyRecord { field: p1, ... }` | Irrefutable*    | Destructures a record.                                                                         |
| Enum         | `MyEnum::Variant`             | **Conditional** | **Irrefutable** if and only if the Enum type has exactly one variant. **Refutable** otherwise. |
| Modal State  | `@State { field: p, ... }`    | Refutable       | Matches a specific state of a `modal` type and destructures its payload.                       |

> **Irrefutability Note**
>
> *Note: Tuple and Record patterns are irrefutable only if all their sub-patterns are also irrefutable.*

### 26.3 Binding Semantics [patterns.binding]

When a pattern successfully matches a value, any identifier patterns within it introduce new bindings.

> **Pattern Bindings**
>
> Bindings introduced by a pattern **MUST** adhere to the standard name introduction and scoping rules defined in §13.3.
>
> 1.  In a `let` statement (`let <pattern> = ...`), the bindings are introduced into the current scope.
> 2.  In a `match` arm (`<pattern> => <body>`), the bindings are introduced into a new scope that encompasses only the `<body>` of that arm.
>
> Bindings introduced within a `match` arm implicitly shadow any existing bindings from an outer scope with the same name. This is a special case that **MUST NOT** require the `shadow` keyword.
>
> For a `let` statement, if a binding introduced by a pattern shadows an existing binding, the `let` statement **MUST** be prefixed with the `shadow` keyword (e.g., `shadow let (x, y) = ...`), in accordance with the rules in §13.3.

### 26.4 Exhaustiveness [patterns.exhaustiveness]

A key safety feature of `match` expressions is the requirement of exhaustiveness, which ensures all possible cases for a value are handled.

> **Exhaustiveness**
>
> A `match` expression **MUST** be exhaustive. The set of patterns in its arms, taken together, **MUST** cover every possible value of the scrutinee expression's type.
>
> The compiler **MUST** perform exhaustiveness checking for the following types:
>
> 1.  `enum` types (§18.3)
> 2.  `modal` types (§19)
> 3.  `bool` type
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-PAT-2741` | Error | `match` expression is not exhaustive for its scrutinee type. |
>
> The wildcard pattern `_` matches all values and can be used as the final arm in a `match` expression to satisfy the exhaustiveness requirement.

***Example (Exhaustiveness Error):***
```cursive
enum Status {
    Running,
    Finished,
}

procedure check_status(s: Status) {
    match s {
        Status::Running => { /* ... */ }
        // COMPILE-TIME ERROR (E-PAT-2741):
        // Non-exhaustive match. Missing pattern: Status::Finished.
    }
}
```

### 26.5 Unreachability [patterns.unreachability]

A `match` arm is unreachable if its pattern can never match because all possible values are covered by preceding arms.

> **Unreachability**
>
> A `match` arm **MUST NOT** be unreachable. An arm is considered unreachable if its pattern covers only values that are a subset of the values covered by the patterns in the preceding arms.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-PAT-2751` | Error | `match` arm is unreachable because its pattern is covered by preceding arms. |

***Example (Unreachable Arm):***
```cursive
enum Status {
    Running,
    Finished,
}

procedure check_status(s: Status) {
    match s {
        _ => { /* Wildcard covers all cases */ }
        Status::Running => { /* ... */ } // COMPILE-TIME ERROR (E-PAT-2751): Unreachable pattern.
    }
}
```

### 26.6 Diagnostics Summary [patterns.diagnostics]

This chapter introduces the following diagnostics in the `PAT` (Pattern) category.

| Code       | Severity | Description                                                                     |
| :--------- | :------- | :------------------------------------------------------------------------------ |
| E-PAT-2711 | Error    | A refutable pattern was used in an irrefutable context (e.g., a `let` binding). |
| E-PAT-2741 | Error    | `match` expression is not exhaustive for its scrutinee type.                    |
| E-PAT-2751 | Error    | `match` arm is unreachable because its pattern is covered by preceding arms.    |

---

# Part 6 - Core Language Systems [part-6---core-language-systems]

## 27. Contracts and Constraints [contracts]

This chapter defines the formal semantics, syntax, and verification rules for Contracts in Cursive. Contracts are the primary mechanism for specifying behavioral properties of code beyond the type system. They govern the logical validity of procedures, types, and loops through preconditions, postconditions, and invariants.

### 27.1 Contract Fundamentals [contracts.fundamental]

A **Contract** is a specification attached to a procedure or type that asserts logical predicates over the program state. Contracts are distinct from the Capability system (Part 6, §31); capabilities control *authority* to perform effects, while contracts control the *logical validity* of data.

#### 27.1.1 Syntax [contracts.fundamental.syntax]

> **Contract Syntax**
>
> A procedure declaration **MAY** include a contract clause immediately following its signature and preceding its body.
>
> ```ebnf
> contract_clause ::= "[[" contract_body "]]"
> contract_body   ::= [ must_clause ] [ "=>" will_clause ]
>
> must_clause     ::= predicate_list
> will_clause     ::= predicate_list
> predicate_list  ::= <expression> ("," <expression>)*
> ```
>
> 1.  **Preconditions (`must`):** Expressions appearing before the `=>` separator. If the separator is omitted, all expressions are preconditions.
> 2.  **Postconditions (`will`):** Expressions appearing after the `=>` separator.

#### 27.1.2 Well-Formedness Constraints [contracts.fundamental.well-formedness-constraints]

> **Contract Constraints**
>
> 1.  **Purity:** All expressions within a contract **MUST** be pure. They **MUST NOT** perform I/O, mutate state, allocate memory, or invoke procedures that are not themselves marked pure or `const`.
> 2.  **Memory Safety:** Expressions within a contract **MUST** adhere to the standard permission system (Clause 11). For example, accessing a field guarded by a **`partitioned`** permission is illegal within a contract unless the contract itself is within a context (like a `monitor`) that guarantees exclusive access or the access is validated by the Partitioning System.
> 3.  **Type:** All expressions in a predicate list **MUST** evaluate to type `bool`.
> 4.  **Scope:**
>     *   Preconditions (`must`) may access parameters and `self`.
>     *   Postconditions (`will`) may access parameters, `self`, and the special contract intrinsics **`@result`** and **`@entry(...)`**.
> 5.  **Evaluation:** Predicates in a list are semantically conjoined ($P_1 \land P_2 \land \dots \land P_n$). Evaluation order is fixed left-to-right.

**_Formal Rule:_**
$$
\frac{
    \forall e \in P_{must}, \Gamma \vdash e : \text{bool} \quad \text{pure}(e) \\
    \forall e \in P_{will}, \Gamma \cup \{ \text{result}, \text{@old} \} \vdash e : \text{bool} \quad \text{pure}(e)
}{
    \Gamma \vdash [[ P_{must} \Rightarrow P_{will} ]] : \text{WF}
}
\tag{WF-Contract}
$$

### 27.2 Preconditions (must) [contracts.preconditions]

The `must` clause defines the obligations of the caller.

> **Precondition Semantics**
>
> 1.  **Caller Obligation:** The caller of a procedure **MUST** ensure that all preconditions evaluate to `true` in the context of the call site, prior to the transfer of control.
> 2.  **Verification:** Failure to satisfy a precondition is a critical error attributed to the **caller**.
> 3.  **Elision:** If no `must` clause is provided, the precondition defaults to `true`.

### 27.3 Postconditions (will) [contracts.postconditions]

The `will` clause defines the guarantees provided by the callee.

> **Postcondition Semantics**
>
> 1.  **Callee Obligation:** The procedure implementation **MUST** ensure that all postconditions evaluate to `true` immediately before returning control to the caller.
> 2.  **Verification:** Failure to satisfy a postcondition is a critical error attributed to the **callee**.
> 3.  **Elision:** If no `will` clause is provided, the postcondition defaults to `true`.

#### 27.3.1 The `@result` Intrinsic [contracts.postconditions.the-result-intrinsic]

> **Result Intrinsic**
>
> Within a `will` clause, the intrinsic **`@result`** refers to the value being returned by the procedure.
>
> *   **Type:** The type of `@result` is the return type of the procedure.
> *   **Unit Returns:** If the procedure returns `()`, `@result` has the value `()`.
> *   **Shadowing:** `@result` is an intrinsic, not an identifier, and cannot be shadowed.

#### 27.3.2 The `@entry` Operator [contracts.postconditions.the-entry-operator]

> **Entry Intrinsic**
>
> The **`@entry(expr)`** operator is available exclusively within the `will` clause.
>
> 1.  **Semantics:** `@entry(e)` evaluates expression `e` in the **entry state** of the procedure (immediately after parameter binding but before body execution).
> 2.  **Capture Constraint:** The expression `e` **MUST** evaluate to a type that implements the `Copy` or `Clone` trait. The runtime (or verifier) captures this value at the start of the function. Capturing non-copyable resources (like `unique` buffers) directly via `@entry` is a compile-time error; specific properties of those resources (like `.len()`) should be captured instead.
> 3.  **Restriction:** `expr` within `@entry` **MUST** be pure and **MUST** depend only on inputs (parameters and `self`).
>
> ***Example:***
> ```cursive
> // Valid: i32 is Copy
> procedure increment(self: unique Counter)
>     [[ => self.value == @entry(self.value) + 1 ]]
>
> // Valid: Captures the 'usize' result of size(), which is Copy
> procedure process(buf: unique Buffer)
>     [[ => buf.size() == @entry(buf.size()) ]] 
> ```

### 27.4 Invariants (where) [contracts.invariants]

Invariants are predicates that must hold true over a defined scope or lifetime. Cursive uses the `where` keyword for invariants.

#### 27.4.1 Type Invariants [contracts.invariants.type-invariants]

A `where` clause inside a `record`, `enum`, or `modal` definition specifies a Type Invariant.

> **Invariant Consistency:** An instance of a type defining a `where` clause **MUST** satisfy the invariant at all "boundary points."
>
> **Boundary Points:**
> 1.  **Post-Construction:** Immediately after a constructor or literal initialization completes.
> 2.  **Pre-Call (Public):** Before any public method is invoked on the instance.
> 3.  **Post-Call (Mutator):** Before any method that takes `unique` or `partitioned` access to `self` returns.
>
> The compiler **MUST** inject checks (or static proof obligations) at these points to ensure the invariant holds.

***Formal Rule (Desugaring):***
Given a type `T` with invariant `Inv` and a mutator procedure `P` with postconditions `Post`:
$$
\text{EffectivePost}(P) = Post \land Inv(self)
$$

#### 27.4.2 Loop Invariants [contracts.invariants.loop-invariants]

A `where` clause attached to a `loop` expression specifies a Loop Invariant.

> **Loop Invariant**
>
> A loop invariant **MUST** hold:
> 1.  **Initialization:** Before the first iteration of the loop body.
> 2.  **Maintenance:** At the start of every subsequent iteration.
> 3.  **Termination:** Immediately after the loop terminates.

***Example:***
```cursive
var i = 0;
loop i < 10
    where { i >= 0 && i <= 10 }
{
    i += 1;
}
```

### 27.5 Liskov Substitution and Trait Implementation [contracts.liskov]

When a type implements a `trait`, or when a `modal` type defines state transitions, the implementation must adhere to the behavioral subtyping principle (Liskov Substitution Principle).

> **Liskov Substitution**
>
> 1.  **Precondition Weakening:** An implementation **MAY** weaken the preconditions defined in the trait (require less). It **MUST NOT** strengthen them (require more).
>     $$ P_{trait} \implies P_{impl} $$
> 2.  **Postcondition Strengthening:** An implementation **MAY** strengthen the postconditions defined in the trait (guarantee more). It **MUST NOT** weaken them (guarantee less).
>     $$ Q_{impl} \implies Q_{trait} $$
>
> Failure to satisfy these implications is a compile-time error.

### 27.6 Verification Modes [contracts.modes]

The enforcement mechanism for contracts is controlled by the `[[verify(mode)]]` attribute. Implementations **MUST** support the following modes.

#### 27.6.1 `static` Mode [contracts.modes.static-mode]

> **Static Verification**
>
> The compiler **MUST** mathematically prove that the contract holds using static analysis.
>
> *   If the proof succeeds, no runtime code is generated.
> *   If the proof fails or is inconclusive, the program is **ill-formed**.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-CON-2801` | Error | Static verification failed: Unable to prove contract in `static` mode. |

#### 27.6.2 `dynamic` Mode [contracts.modes.dynamic-mode]

> **Dynamic Verification**
>
> The compiler **MUST** generate executable code to evaluate the predicates at runtime.
>
> *   **Elision (Optimization):** The compiler **MAY** omit the runtime check for a specific predicate if and only if it can statically prove that the predicate will always evaluate to `true`.
> *   **Execution:** Preconditions are checked at the procedure prologue; postconditions at the epilogue.
> *   **Failure:** If a check evaluates to `false`, the runtime **MUST** execute a Panic.

#### 27.6.3 `trusted` Mode [contracts.modes.trusted-mode]

> **Trusted Mode**
>
> The compiler **MUST** assume the contract evaluates to `true` without verification.
>
> *   No static proofs are attempted.
> *   No runtime checks are generated.
> *   **Warning:** Violation of a trusted contract results in **Unverifiable Behavior (UVB)**.

#### 27.6.4 Default Strategy (The Hybrid Model) [contracts.modes.default-strategy-the-hybrid-model]

> **Hybrid Verification**
>
> If no `verify` attribute is present, the implementation **MUST** apply the following **Hybrid Strategy**:
>
> 1.  **Attempt Static Proof:** The compiler first attempts to verify the contract statically.
> 2.  **Elision:** If the static proof succeeds, the check is elided (Zero Overhead).
> 3.  **Fallback:** If the static proof fails, the compiler falls back to generating a runtime check (equivalent to `dynamic` mode).

### 27.7 Verification Facts (Virtual Control-Flow Facts) [contracts.facts]

In the context of contract verification, a **Verification Fact** (formerly "Witness") is a **virtual, compile-time concept** used to track the satisfaction of logical predicates. Unlike Witnesses (§28.4), Verification Facts have **zero runtime size** and **no runtime representation** as values. They represent the state of the verification analysis.

##### 27.7.1 Fact Semantics [contracts.facts.semantics]

> **Verification Facts**
>
> 1.  **Definition:** A Fact $F(P, L)$ is a compiler-internal guarantee that predicate $P$ is true at program location $L$.
> 2.  **Zero-Size / Non-Value:** Verification Facts **MUST NOT** be represented as runtime values. They occupy no storage, have no size, and **MUST NOT** be referenced by identifiers, passed as parameters, or stored in fields.
> 3.  **Consumption:** When a statement $S$ requires predicate $P$ (e.g., a function call with a `must` clause), the compiler **MUST** verify that a valid Fact $F(P, L)$ exists such that $L$ strictly **dominates** $S$ in the Control Flow Graph (CFG).

##### 27.7.2 Dynamic Fact Injection [contracts.facts.injection]

> **Fact Synthesis**
>
> When the verification mode is `dynamic` (or fallback from failed static proof), the implementation **MUST** synthesize facts using control flow assertions.
>
> **Injection Algorithm:**
> 1.  Identify the r
equirement $P$ at call site $S$.
> **Check Block Construction**
>
> 2.  Construct a check block $C$: `if (!P) { panic("Contract violation"); }`.
> 3.  Insert $C$ into the CFG such that $C$ dominates $S$.
> 4.  The successful execution of $C$ establishes the virtual fact $F(P, \text{exit}(C))$, satisfying the requirement at $S$.

##### 27.7.3 Optimizer Integration (Assumptions) [contracts.facts.optimizer]

> **Fact Optimization**
>
> In `trusted` mode, or when optimization is enabled in `release` builds, the implementation **SHOULD** utilize facts as optimization hints.
>
> 1.  **Assumption Injection:** If a fact $F(P, L)$ exists, the compiler **MAY** treat $P$ as an invariant truth for all instructions dominated by $L$.
> 2.  **Dead Code Elimination:** Branches dependent on $\neg P$ dominated by $F(P, L)$ **MAY** be eliminated.
> 3.  **Implementation Note:** This corresponds to intrinsics like `llvm.assume` in backend IRs.

### 27.8 Diagnostics Summary [contracts.diagnostics]

| Code         | Severity | Description                                                            |
| :----------- | :------- | :--------------------------------------------------------------------- |
| `E-CON-2801` | Error    | Static verification failed: Unable to prove contract in `static` mode. |
| `E-CON-2802` | Error    | Impure or unsafe expression used in contract predicate.                |
| `E-CON-2803` | Error    | Liskov violation: Precondition strengthened in implementation.         |
| `E-CON-2804` | Error    | Liskov violation: Postcondition weakened in implementation.            |
| `E-CON-2805` | Error    | Use of `@entry` operator with non-Copy/Clone result type.              |
| `E-CON-2806` | Error    | Use of `@result` intrinsic outside of a `will` clause.                 |

## 28. Traits and Polymorphism [traits]

This chapter defines the Cursive **trait system**, the unified mechanism for defining interfaces, sharing concrete implementations, and enabling polymorphism. The trait system replaces the `behavior` and `contract` declarations from previous designs, unifying them into a single `trait` keyword.

Traits provide the foundation for three distinct paths of polymorphism:

1.  **Static Polymorphism (Generics):** Zero-cost, compile-time dispatch using constrained generic parameters (`<T <: Trait>`).
2.  **Dynamic Polymorphism (Witnesses):** Opt-in, runtime dispatch using trait-as-type dense pointers (`item: Trait`).
3.  **Opaque Polymorphism (Opaque Types):** Zero-cost, compile-time encapsulation of return types (`-> ... <: Trait`).

### 28.1 Trait Declarations [traits.declaration]

A `trait` is a declaration that defines an abstract interface. A trait may contain a collection of procedure signatures, some of which may be *abstract* (requiring implementation) and some of which may be *concrete* (providing a default implementation).

#### 28.1.1 Syntax [traits.declaration.syntax]

> **Trait Syntax**
>
> A `trait` declaration **MUST** conform to the following syntactic form:
>
> ```ebnf
> trait_declaration ::=
>     [ <visibility> ] "trait" <identifier> [ <generic_params> ]
>     [ <trait_bounds> ] "{"
>         <trait_item>*
>     "}"
>
> trait_item ::= <procedure_declaration>
> ```
>
> The `trait_item` list defines the trait's interface.

#### 28.1.2 Abstract Procedures [traits.declaration.abstract]

> **Abstract Procedure**
>
> An **abstract procedure** is a `procedure_declaration` within a trait body that consists of only a signature and **MUST NOT** include a procedure body (i.e., it must end with a semicolon).
>
> An abstract procedure defines a requirement: any type implementing the trait **MUST** provide a concrete implementation for this procedure.

```cursive
// Example of a trait with abstract procedures
public trait Drawable {
    // This is an abstract procedure.
    // Implementers MUST provide a body for 'draw'.
    procedure draw(self: const, ctx: Context);

    // This is also an abstract procedure.
    procedure get_bounding_box(self: const): Box;
}
```

#### 28.1.3 Concrete Procedures (Default Implementations) [traits.declaration.concrete]

> **Concrete Procedure**
>
> A **concrete procedure** is a `procedure_declaration` within a trait body that **MUST** include a procedure body.
>
> A concrete procedure provides a default implementation. Types implementing the trait automatically inherit this procedure. An implementing type **MAY** replace (override) the concrete procedure using the `override` keyword (see §29.2.4).

```cursive
// Example of a trait with concrete procedures
public trait Display {
    // This is a concrete procedure, providing a default.
    procedure show(self: const): string@View {
        result "[default display]";
    }
}
```

#### 28.1.4 The `Self` Type [traits.declaration.self]

> **Self Type**
>
> Within a trait declaration, the type identifier `Self` **MUST** be used to refer to the (unknown) type that will eventually implement the trait.
>
> `Self` **MUST** be used as the type for the receiver parameter (e.g., `self: const Self`) and **MAY** be used in any other type position (e.g., as a parameter, return type, or field type in an associated type).

### 28.2 Trait Implementation [traits.implementation]

A type implements a trait by specifying the trait in its declaration header and providing implementations for all required abstract procedures.

#### 28.2.1 Implementation (Subclass of) Operator (`<:`) [traits.implementation.operator]

> **Implements Clause**
>
> A type declaration **MUST** specify the traits it implements using the subtype operator (`<:`) after the type's name and before its body. This is referred to as the "implements clause."
>
> ```ebnf
> record_declaration ::=
>     ... "record" <identifier> [ <generic_params> ]
>     [ "<:" <trait_list> ]
>     <record_body>
> trait_list ::= <type> ("," <type>)*
>
> ```

```cursive
// 'Point' implements the 'Drawable' and 'Display' traits.
record Point <: Drawable, Display {
    x: f64,
    y: f64,
    
    // ... implementations ...
}
```

#### 28.2.2 Implementation Requirements [traits.implementation.requirements]

> **Implementation Requirement**
>
> A type `T` that implements a trait `Tr` **MUST** provide a concrete procedure implementation for every abstract procedure declared in `Tr`.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-TRS-2903` | Error | Type 'T' does not implement required procedure 'proc_name' from trait 'Tr'. |

#### 28.2.3 The `override` Keyword [traits.implementation.override]

> **Override Requirement**
>
> To replace a *concrete* (default) procedure inherited from a trait, the procedure implementation in the type body **MUST** be prefixed with the `override` keyword.
>
> The `override` keyword **MUST NOT** be used on an implementation of an *abstract* procedure.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-TRS-2902` | Error | Procedure marked `override` but does not replace a concrete procedure. |
> | `E-TRS-2901` | Error | Procedure implements an abstract requirement and must not use `override`. |

#### 28.2.4 Example of Implementation [traits.implementation.example]

```cursive
// --- TRAIT DEFINITIONS ---
public trait Drawable {
    // Abstract
    procedure draw(~, ctx: Context);
}

public trait Display {
    // Concrete (default)
    procedure show(~): string@View {
        result "[default]";
    }
}

// --- TYPE IMPLEMENTATION ---
record Point <: Drawable, Display {
    x: f64,
    y: f64,
    
    // 1. Implementation of abstract procedure 'draw' from 'Drawable'
    // 'override' is NOT allowed here.
    procedure draw(~, ctx: Context) {
        // ... implementation ...
    }
    
    // 2. Replacement of concrete procedure 'show' from 'Display'
    // 'override' IS required here.
    override procedure show(~): string@View {
        result "Point(..., ...)"
    }
}

// 3. 'record Circle' inherits the default 'show'
record Circle <: Drawable, Display {
    radius: f64,
    
    procedure draw(~, ctx: Context) {
        // ... implementation ...
    }
    
    // No 'override procedure show' is provided,
    // so 'Circle' uses the default implementation from 'Display'.
}
```

### 28.3 Path 1: Static Polymorphism (Generics) [traits.static]

This is the default, zero-cost mechanism for polymorphism on *inputs*. It uses generic parameters that are constrained by traits, and it is resolved at compile time via monomorphization.

#### 28.3.1 Syntax (Constrained Generics) [traits.static.syntax]

> **Generic Constraints**
>
> Static polymorphism **MUST** be specified using a generic parameter list where the parameter is constrained by one or more traits using the `<:` operator.
>
> ```ebnf
> generic_param ::= <identifier> "<:" <trait_list>
> ```

```cursive
// 'T' can be any type, as long as it implements 'Drawable'.
procedure render_item<T <: Drawable>(item: T, ctx: Context) {
    // ...
}
```

#### 28.3.2 Semantics (Monomorphization) [traits.static.semantics]

> **Monomorphization**
>
> A call to a procedure with a constrained generic parameter **MUST** be resolved at compile time. The implementation **MUST** generate a specialized version of the procedure for each concrete type used as an argument (monomorphization).
>
> The call to a trait procedure (e.g., `item.draw(ctx)`) **MUST** be compiled as a direct, static call to the concrete type's implementation (e.g., `Point::draw(item, ctx)`), not as a dynamic vtable lookup.
>
> This mechanism **MUST** incur zero runtime overhead compared to a non-generic call.

### 28.4 Path 2: Dynamic Polymorphism (Witnesses) [traits.dynamic]

This is the opt-in mechanism for runtime polymorphism, used for *inputs* and *storage* (e.g., heterogeneous collections). It uses the `witness` keyword to create a "witness" type from a witness-safe trait. A witness is a concrete, sized type that enables dynamic dispatch.

#### 28.4.1 Syntax (Witnesses with `witness`) [traits.dynamic.syntax]

> **Witnesses**
>
> Dynamic polymorphism is invoked by using the name of a witness-safe `trait` prefixed with the `witness` keyword in any position where a `type` is expected (e.g., `item: witness Drawable`).
>
> The `witness` keyword serves as an explicit marker that a concrete, dynamically-dispatched type is being created from an abstract trait. It signals that the value is a "dense pointer" with an associated vtable, making the runtime cost explicit.

```cursive
// 'item: witness Drawable' declares a parameter of type 'Witness (Drawable)'.
procedure render_dynamic(item: witness Drawable, ctx: Context) {
    // ...
}
```

#### 28.4.2 Witness Safety [traits.dynamic.safety]

> **Witness Safety**
>
> To be used as a witness (`witness MyTrait`), a trait **MUST** be **witness-safe**.
>
> A trait is witness-safe if, for every procedure defined in the trait (including inherited ones), one of the following is true:
> 1.  The procedure is **explicitly excluded** from dynamic dispatch via a `where Self: Sized` clause.
> 2.  The procedure is **vtable-eligible**.
>
> A procedure is **vtable-eligible** if it meets **all** of the following criteria:
> 1.  The procedure **MUST** have a receiver (e.g., `self`, `~`). Static procedures are not vtable-eligible.
> 2.  The procedure **MUST NOT** have any generic parameters.
> 3.  The procedure **MUST NOT** return `Self` or use `Self` in any argument position other than the receiver, unless `Self` is wrapped in a pointer type (e.g., `box Self`, `witness Self`).
>
> An attempt to create a witness from a trait that contains procedures that are neither excluded nor vtable-eligible **MUST** result in a compile-time error.

#### 28.4.3 The `where Self: Sized` Exclusion [traits.dynamic.the-where-self-sized-exclusion]

> **Sized Constraint**
>
> The `where Self: Sized` clause acts as a compile-time filter.
>
> 1.  **Static Dispatch:** When the trait is used on a concrete type (Path 1 Polymorphism), the procedure is available and callable.
> 2.  **Dynamic Dispatch:** When the trait is used as a `witness Trait` (Path 2 Polymorphism), the procedure is **excluded** from the vtable.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-TRS-2940` | Error | Procedure 'name' requires 'Self: Sized' and cannot be called on a witness. |
>
> This mechanism allows a single trait to provide high-performance, complex methods for static code (e.g., `clone() -> Self`) while still offering a subset of its functionality for dynamic code.
#### 28.4.4 Representation (Witness) [traits.dynamic.representation]

> **Witness Layout**
>
> A value of a witness type (e.g., `witness Drawable`) **MUST** be implemented as a "dense pointer" (16 bytes on 64-bit platforms) containing two components:
>
> 1.  A **data pointer** (`*mut ()`) to the instance of the concrete type (e.g., a `Point` or `Circle`).
> 2.  A **metadata pointer** to a static witness table.
>
> To support dynamic dispatch and correct destruction, the witness table **MUST** contain the following entries in a stable layout:
>
> *   **Size and Alignment:** The size and alignment of the concrete type `T`.
> *   **Destructor:** A function pointer to `Drop::drop` for `T` (or a no-op if `T` does not implement `Drop`).
> *   **VTable:** Function pointers for each witness-safe procedure defined in the trait.
>
> When a witness binding goes out of scope, the compiler **MUST** invoke the destructor pointed to by the metadata table.

#### 28.4.5 Coercion (Concrete-to-Witness) [traits.dynamic.coercion]

> **Witness Coercion**
>
> A value of a concrete type `T` that implements a witness-safe trait `Tr` **MAY** be coerced to a witness of type `witness Tr`. This coercion **MUST** construct the dense pointer (data + vtable) for that `T`/`Tr` pair.

```cursive
let p: Point = Point { ... }
let c: Circle = Circle { ... }

// Coercion from a concrete type to a witness:
let d1: witness Drawable = p 
let d2: witness Drawable = c

// This enables heterogeneous collections.
let drawables: [witness Drawable] = [d1, d2]
```

#### 28.4.6 Dispatch (VTable Lookup) [traits.dynamic.dispatch]

> **Dynamic Dispatch**
>
> A call to a trait procedure on a witness (e.g., `item.draw(ctx)`) **MUST** be compiled as a dynamic dispatch.
>
> The implementation **MUST** perform the following sequence:
>
> 1.  Load the vtable pointer from the witness.
> 2.  Load the function pointer for the `draw` procedure from the vtable.
> 3.  Call that function pointer, passing it the data pointer from the witness as the `self` argument.
>
> This mechanism **MUST** incur the runtime cost of one vtable lookup and one indirect function call.

---

### 28.5 Path 3: Opaque Polymorphism (Opaque Types) [traits.opaque]

This is the zero-cost mechanism for polymorphism on *outputs*. It allows a procedure to hide the concrete return type, providing only its trait interface.

#### 28.5.1 Syntax (Return Type Implementation) [traits.opaque.syntax]

> **Opaque Types**
>
> Opaque polymorphism **MUST** be specified by using the `opaque` keyword followed by a trait bound in the return type position.
>
> ```ebnf
> procedure_declaration ::=
>     ... "procedure" <name> ... ":" "opaque" <trait_type>
>     ...
> ```
>
> The body of the procedure **MUST** return a concrete type that implements `<trait_type>`. The specific concrete type is inferred by the compiler but hidden from the caller.

```cursive
// This procedure returns some type that implements 'Drawable',
// but the exact type is hidden from the caller.
public procedure make_drawable(): opaque Drawable;
```

#### 28.5.2 Semantics (Encapsulation) [traits.opaque.semantics]

> **Opaque Type Semantics**
>
> The compiler **MUST** treat the return value of a procedure using an opaque type as having *only* the type of the trait (`<trait_type>`).
>
> The caller **MUST NOT** be able to access any fields, methods, or other properties of the concrete implementation type (`<concrete_type>`). The concrete type is erased from the public signature.
>
> This mechanism **MUST** incur zero runtime overhead. The value returned is the concrete type itself, not a dense pointer. The compiler enforces the type encapsulation statically.

```cursive
// --- Library Code (internal) ---
internal record Widget <: Drawable {
    id: u32,
    procedure draw(self: const, ctx: Context) { ... }
}
public procedure make_widget(): internal::Widget <: Drawable {
    result Widget { id: 123 }
}

// --- User Code (external) ---
let w = make_widget()

// OK: 'draw' is defined on the 'Drawable' trait.
// This is a static, direct call.
w::draw(ctx)

// COMPILE-TIME ERROR (E-TRS-2910):
// 'id' is not a member of trait 'Drawable'.
// let id = w.id
```

#### 28.5.3 Diagnostics [traits.diagnostics.opaque]

> **Opaque Member Access**
>
> An attempt to access a member of an opaque type that is not part of its public trait interface **MUST** trigger diagnostic `E-TRS-2910`: "Member 'member_name' is not defined on trait 'TraitName'."


### 28.6 Fundamental Traits [traits.fundamental]

Certain traits are fundamental to the semantics of the Cursive language, including memory management (`Drop`), implicit duplication (`Copy`), and explicit duplication (`Clone`).

> **Fundamental Traits**
>
> The normative definitions, semantic requirements, and constraints for these fundamental traits are specified in **Appendix D.1**.
>
> Implementations **MUST** provide built-in definitions for `Drop`, `Copy`, and `Clone` that strictly conform to the specifications in Appendix D.1. References to these traits throughout this specification refer to those definitions.


---

## 29. The Cursive Memory Model [memory]

### 29.1 Principles and Object Model [memory.principles]

This section defines the foundational principles of the Cursive memory model, the definition of objects, their storage duration, and their physical layout in memory. The memory model enforces safety through two distinct, orthogonal axes: **Liveness** (validity of data) and **Aliasing** (exclusivity of access).

#### 29.1.1 Liveness vs. Aliasing [memory.principles.safety]

> **Memory Safety Principles**
>
> The memory safety guarantees of a conforming implementation **MUST** be established by enforcing Liveness and Aliasing constraints independently.

**Liveness** ensures that a pointer or binding always refers to allocated, initialized memory.
*   Liveness is enforced via **RAII** (§30.2), **Modal Pointers** (`Ptr<T>@State`, §21.1), and **Region Escapement Analysis** (§30.6.4).
*   A value is **live** if its storage duration has not expired.
*   Dereferencing a value that is not live is a compile-time error.

**Aliasing** ensures that concurrent or reentrant access to memory does not violate data integrity.
*   Aliasing is controlled via **Permissions** (`const`, `unique`, `partitioned`, §16) and the **Partitioning System** (§29.3).
*   A binding **aliases** another binding if they refer to overlapping memory locations.
*   Mutation of a memory location while other aliases to that location are active is restricted by the permission system.

#### 29.1.2 The Explicit-Over-Implicit Principle [memory.principles.explicit]

> **Explicit Management**
>
> Memory management operations that affect ownership, allocation, or synchronization **MUST** be syntactically explicit in the source text.

1.  **Allocation:** Allocation within a region **MUST** use the `^` operator. Dynamic heap allocation **MUST** use explicit methods on an allocator capability (e.g., `heap.alloc(...)`).
2.  **Ownership Transfer:** Transfer of cleanup responsibility **MUST** be indicated by the `move` operator at the call site. Implicit transfers are forbidden.
3.  **Synchronization:** Access to `shared` memory **MUST** involve explicit synchronization primitives (e.g., `Mutex`, `Atomic`). Implicit synchronization or hidden locks are forbidden.

#### 29.1.3 Zero Runtime Overhead [memory.principles.overhead]

> **Static Analysis**
>
> All memory safety checks defined in this chapter, with the exception of dynamic bounds checking for array/slice indexing and dynamic partition checks explicitly enabled by the user, **MUST** be resolved at compile time.

A conforming implementation **SHALL NOT** insert runtime reference counting, garbage collection barriers, or dynamic lifetime tracking metadata into the executable artifact to enforce the rules of this chapter. Safe code must compile to machine code equivalent to that of manual, unchecked memory management.

#### 29.1.4 The Object Lifecycle [memory.object.lifecycle]

An **Object** is a discrete entity within the abstract machine during execution.

> **Object Definition**
>
> An object is defined by the tuple $(Storage, Type, Lifetime, Value)$.

1.  **Storage:** A contiguous sequence of bytes in memory, identified by a start address and a size in bytes.
2.  **Type:** A static classification determining the interpretation of the storage, its alignment requirements, and the set of valid operations.
3.  **Lifetime:** The temporal interval during execution for which the storage is valid and reserved for this object.
4.  **Value:** The specific bit-pattern contained within the storage, which must constitute a valid representation for the object's Type.

The lifecycle of an object consists of three phases:
1.  **Allocation and Initialization:** Storage is reserved and a valid initial value is written. This establishes the start of the Lifetime.
2.  **Usage:** The value is read or modified via valid bindings or pointers.
3.  **Destruction and Deallocation:** The object's cleanup logic (defined by the `Drop` trait) is executed, and the storage is released. This establishes the end of the Lifetime.

#### 29.1.5 Storage Duration Categories [memory.object.duration]

Every object has a storage duration that determines its lifetime.

**Static Storage Duration**
Objects declared at the module level or explicitly marked `static` have static storage duration.
*   **Allocation:** Before program entry (`main`).
*   **Deallocation:** After program exit.
*   **Lifetime:** The entire execution of the program.
*   **Provenance:** Pointers to static objects have `Global` provenance.

**Automatic Storage Duration (Stack)**
Objects declared as local bindings within a procedure or block scope have automatic storage duration.
*   **Allocation:** When execution enters the scope of the declaration.
*   **Deallocation:** When execution exits the scope of the declaration (LIFO order).
*   **Lifetime:** Bounded by the lexical scope.
*   **Provenance:** Pointers to automatic objects have `Stack` provenance.

**Region Storage Duration (Arena)**
Objects allocated using the `^` operator within a `region` block have region storage duration.
*   **Allocation:** When the `^` expression is evaluated.
*   **Deallocation:** When the associated `region` block exits. All objects in a region are deallocated simultaneously (bulk deallocation).
*   **Lifetime:** Bounded by the lifetime of the `Arena` backing the region.
*   **Provenance:** Pointers to region objects have `Region(ID)` provenance.

**Dynamic Storage Duration (Heap)**
Objects allocated via explicit allocator capabilities (e.g., `ctx.heap.alloc`) have dynamic storage duration.
*   **Allocation:** When the allocation method is explicitly invoked.
*   **Deallocation:** When the `free` method is explicitly invoked on the allocator, or via RAII types (e.g., `string@Managed`) that manage such allocations.
*   **Lifetime:** Determined by the logic of the managing type or manual management.
*   **Provenance:** Pointers to dynamic objects have `Heap` provenance.

#### 29.1.6 Layout and Alignment [memory.layout]

This section defines the mapping between types and their physical representation in memory.

**Size and Alignment**
Every type $T$ has a statically determined size, denoted `sizeof(T)`, and a non-negative integer alignment, denoted `alignof(T)`.
*   `alignof(T)` **MUST** be a power of two.
*   The address of any object of type $T$ **MUST** be a multiple of `alignof(T)`.
*   `sizeof(T)` **MUST** be a multiple of `alignof(T)`.

**Primitive Layouts**
*   `i8`, `u8`, `bool`: Size 1, Alignment 1.
*   `i16`, `u16`, `f16`: Size 2, Alignment 2.
*   `i32`, `u32`, `f32`, `char`: Size 4, Alignment 4.
*   `i64`, `u64`, `f64`: Size 8, Alignment 8.
*   `i128`, `u128`: Size 16, Alignment 8 or 16 (platform dependent).
*   `usize`, `isize`, `*imm T`, `*mut T`, `Ptr<T>@State`: Size and Alignment equal to the target platform's pointer width (4 on 32-bit, 8 on 64-bit).

**Composite Layouts**
*   **Arrays (`[T; N]`):** `sizeof([T; N]) = sizeof(T) * N`. `alignof([T; N]) = alignof(T)`. There is no padding between elements.
*   **Records (`record`):** Fields are stored in memory. By default, the compiler **MAY** reorder fields to minimize padding. The alignment of a record is the maximum alignment of its fields.
*   **C-Compatible Records (`[[repr(C)]]`):** Fields **MUST** be stored in declaration order. Padding **MUST** be inserted to satisfy alignment requirements of subsequent fields and the total size alignment.

**Dense Pointer Layout (Witnesses and Slices)**
Certain types are represented as "dense pointers" (also known as fat pointers), consisting of two machine words.
*   **Slices (`[T]`):** Represented as `record { ptr: *imm T, len: usize }`.
*   **Witnesses** (witness Trait): Represented as `record { data: *imm T, vtable: *imm VTable }`.
*   **Size:** `2 * sizeof(usize)`.
*   **Alignment:** `alignof(usize)`.

**Unit and Never Types**
*   `()` (Unit): `sizeof(()) = 0`, `alignof(()) = 1`.
*   `!` (Never): `sizeof(!) = 0`, `alignof(!) = 1`.
*   Objects of zero size do not occupy unique storage but may have distinct addresses for identity comparison purposes.

### 29.2 Responsibility and Cleanup [memory.ownership]

This section defines the rules for memory ownership, the transfer of that ownership, and the deterministic destruction of objects. Cursive employs a **Responsible Binding** model to ensure that every heap or region-allocated object has exactly one binding responsible for its deallocation at any point in the program execution.

#### 29.2.1 Responsible Bindings [memory.ownership.binding]

> **Responsible Binding**
>
> A **Responsible Binding** is a named variable binding created via the value assignment operator (`=`) or a parameter declared with the `move` modifier.

1.  **Sole Responsibility:** A responsible binding holds the exclusive duty to manage the lifetime of the object to which it is bound.
2.  **Initialization:** A responsible binding is created when an object is assigned to an identifier using the `=` operator.
    ```cursive
    let x = Type::new() // 'x' is a responsible binding
    ```
3.  **Duty to Drop:** When a responsible binding goes out of scope, the implementation **MUST** ensure that the associated object is destroyed and its storage deallocated, unless responsibility has been transferred via a `move` operation.

#### 29.2.2 Move Semantics [memory.ownership.move]

Move semantics govern the transfer of responsibility from one binding to another. This transfer is a compile-time operation that alters the static validity of bindings.

##### 29.2.2.1 The Move Operator [memory.ownership.move.the-move-operator]

> **Move Semantics**
>
> The `move` operator explicitly transfers the value and the cleanup responsibility from a source binding to a target context.

$$
\frac{\Gamma \vdash e : T \quad \text{is\_responsible}(e)}{\Gamma \vdash \texttt{move } e : T \Rightarrow \Gamma [e \mapsto \text{moved}]}
\tag{Op-Move}
$$

1.  **Explicit Transfer:** Responsibility transfer **MUST** be explicit. Passing a responsible binding to a consuming context without the `move` keyword is a compile-time error.
2.  **Source Requirement:** The operand of `move` **MUST** be a responsible binding (a variable declared with `let` or `var`). Moving a temporary value (r-value) is permitted but redundant, as temporaries are inherently movable.
3.  **Execution:** At runtime, `move` is a bitwise copy of the object's representation (pointer, record data, etc.) to the new location. No deep copy or allocation occurs.

##### 29.2.2.2 Static Invalidation [memory.ownership.move.static-invalidation]

> **Static Invalidation**
>
> Upon the evaluation of a `move` expression, the source binding is **statically invalidated**.

1.  **Invalidation State:** The compiler tracks the state of every binding. After a `move`, the source binding transitions to the **Moved** state.
2.  **Access Prohibition:** Any attempt to read, write, or move a binding in the **Moved** state is a compile-time error.
3.  **Reinitialization:** A `var` binding in the **Moved** state **MAY** be assigned a new value. Upon assignment, it transitions back to the **Initialized** state, and responsibility is re-established for the new object. `let` bindings **MUST NOT** be reinitialized.

**_Diagnostic:_**

| Code         | Severity | Description         |
| :----------- | :------- | :------------------ |
| `E-MEM-3001` | Error    | Use of moved value. |

##### 29.2.2.3 Partial Moves [memory.ownership.move.partial-moves]

> **Partial Move**
>
> A **Partial Move** transfers responsibility for a specific field of a composite type (record or tuple) while leaving the remaining fields valid.

1.  **Prerequisite:** Partial moves are permitted only if the parent binding has the `unique` permission or is a mutable `var`. Partial moves from `const` or `shared` bindings are forbidden to preserve reference integrity.
2.  **Parent Invalidation:** Moving a field `x.f` invalidates the field `f`. Consequently, the parent binding `x` is considered **Partially Moved**.
3.  **Partial Access:** While `x` is Partially Moved:
    *   Accessing `x.f` is an error.
    *   Accessing other valid fields (e.g., `x.g`) is permitted.
    *   Using `x` as a whole (e.g., `move x`, `f(x)`) is an error.

**_Diagnostic:_**

| Code         | Severity | Description                        |
| :----------- | :------- | :--------------------------------- |
| `E-MEM-3001` | Error    | Use of moved value (partial move). |
4.  **Partial Drop:** When a Partially Moved binding goes out of scope, the compiler **MUST** generate cleanup code only for those fields that remain valid. The parent object's top-level `Drop::drop` implementation **MUST NOT** be called, as the object is no longer coherent.

#### 29.2.3 Parameter Responsibility [memory.ownership.param]

Procedure parameters dictate the flow of responsibility across API boundaries.

##### 29.2.3.1 Non-Transferring Parameters (Borrowing) [memory.ownership.param.non-transferring-parameters-borrowing]

> **Non-Transferring Parameter**
>
> A parameter declared without the `move` modifier is **Non-Transferring**.

1.  **Semantics:** The callee receives a view (pointer) to the object. Responsibility remains with the caller.
2.  **Caller Obligation:** The caller **MUST** ensure the argument remains live for the duration of the call.
3.  **Invalidation:** The source binding at the call site remains valid after the call returns.

##### 29.2.3.2 Transferring Parameters (Consuming) [memory.ownership.param.transferring-parameters-consuming]

> **Transferring Parameter**
>
> A parameter declared with the `move` modifier is **Transferring**.

```cursive
procedure consume(move data: Buffer) { ... }
```

1.  **Semantics:** The callee assumes full responsibility for the object.
2.  **Caller Obligation:** The caller **MUST** apply the `move` operator to the argument at the call site.
    ```cursive
    consume(move my_buffer);
    ```
3.  **Invalidation:** The source binding at the call site is statically invalidated immediately after the call.
4.  **Destruction:** If the callee does not transfer the object further, it **MUST** be destroyed when the callee's scope exits.

#### 29.2.4 Temporary Values [memory.ownership.temporary]

> **Temporary Value**
>
> A **Temporary Value** is an object resulting from the evaluation of an expression that is not immediately bound to a named identifier.

1.  **Scope:** The scope of a temporary value extends from its creation until the end of the innermost enclosing statement.
2.  **Promotion:** If a temporary is used to initialize a `let` or `var` binding, it is promoted to a responsible binding, and its lifetime extends to the scope of that binding.
3.  **Cleanup:** At the end of the statement, any temporary value that has not been moved or bound **MUST** be destroyed.

#### 29.2.5 The `Drop` Trait and Cleanup [memory.ownership.drop]

The `Drop` trait defines the custom destruction logic for a type. It provides the mechanism for **Deterministic Destruction**.

##### 29.2.5.1 Deterministic Destruction [memory.ownership.drop.deterministic-destruction]

> **Automatic Release**
>
> Whenever a responsible binding goes out of scope, or a temporary value reaches the end of its statement, the implementation **MUST** automatically release the associated resources.

The cleanup process proceeds as follows:
1.  **Custom Drop:** If the type implements `Drop`, the `Drop::drop` procedure is executed.
2.  **Field Drop:** After `Drop::drop` returns (or if it does not exist), the fields of the object are destroyed recursively.

##### 29.2.5.2 LIFO Order [memory.ownership.drop.lifo-order]

> **Destruction Order**
>
> Destruction within a scope proceeds in strict **Last-In, First-Out (LIFO)** order based on declaration.

Given bindings declared in order `a`, `b`, `c`:
1.  Binding `c` is dropped.
2.  Binding `b` is dropped.
3.  Binding `a` is dropped.

This ordering ensures that objects created later (which may depend on earlier objects) are destroyed before their dependencies.

##### 29.2.5.3 Panic Semantics [memory.ownership.drop.panic-semantics]

> **Panic Unwinding**
>
> If the program terminates abnormally via a panic (stack unwinding), the runtime **MUST** attempt to execute destructors for all live responsible bindings in the current stack frame before unwinding to the caller.

1.  **Double Panic:** If a destructor invoked during unwinding itself panics, the runtime **MUST** immediately abort the process to prevent undefined behavior.

##### 29.2.5.4 Compiler Invocation [memory.ownership.drop.compiler-invocation]

> **Drop Procedure**
>
> The `Drop::drop` procedure is reserved for implicit invocation by the compiler.

1.  **Explicit Call Forbidden:** User code **MUST NOT** explicitly call `x.drop()`.
2.  **Early Drop:** To destroy an object before its scope ends, user code **MUST** use the standard library intrinsic `mem::drop(move x)`, which consumes the value via move semantics and allows it to go out of scope immediately.

**_Diagnostic:_**

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-MEM-3005` | Error    | Explicit call to destructor (`Drop::drop`). |


### 29.3 The Partitioning System [memory.partitioning]

The Partitioning System provides the mechanism for safely mutating data accessed via the `partitioned` permission. It enforces aliasing exclusion rules at compile time, allowing simultaneous mutation of disjoint memory locations derived from the same object without the risk of data races or reference invalidation.

#### 29.3.1 Static Record Partitioning [memory.partitioning.record]

Static Record Partitioning groups the fields of a `record` type into named sets called **partitions**.

**Syntax:**
A record definition **MAY** include `partition` declarations. Fields declared within a `partition` block belong to that partition. Fields declared outside any partition block belong to an implicit, anonymous partition unique to that field.

```ebnf
partition_decl ::= "partition" identifier "{" field_decl+ "}"
```

**Disjointness Rule:**
When accessing a record `r` via a `partitioned` binding:
1.  The compiler **MUST** track the set of active partitions for `r` within the current scope.
2.  Accessing a field `f` acquires a lock on the partition containing `f`.
3.  Acquiring a lock on a partition $P$ is permitted if and only if $P$ is not currently locked.
4.  Simultaneous access to fields in *different* partitions is permitted.
5.  Simultaneous access to fields in the *same* partition (including the same field twice) via separate paths is a compile-time error.

> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-MEM-3010` | Error | Static partition conflict. |

**Example:**
```cursive
record World {
    // Implicit partitions
    time: i64,
    
    // Explicit partition 'physics'
    partition physics {
        bodies: [Body],
        gravity: f64,
    }
    
    // Explicit partition 'ai'
    partition ai {
        agents: [Agent],
    }
}

let w: partitioned World = ...
let t = &w.time          // Locks 'time' (implicit)
let b = &w.bodies        // Locks 'physics'
let g = &w.gravity       // Error E-MEM-3010: 'physics' already locked
let a = &w.agents        // OK: Locks 'ai', disjoint from 'physics' and 'time'
```

#### 29.3.2 Static Collection Partitioning [memory.partitioning.collection]

Static Collection Partitioning allows simultaneous mutable access to distinct elements or ranges of a collection (e.g., array or slice). Proof of disjointness is provided via the **Partition Contract Block**.

**Syntax:**
The `partition` statement is a block-scoped contract.

```ebnf
partition_stmt ::= 
    "partition" collection_expr "by" "(" partition_target_list ")" 
    "where" "(" proof_expr ")" 
    block_stmt

partition_target_list ::= partition_target ("," partition_target)*
partition_target ::= identifier | identifier ".." identifier
```

**Semantics:**
1.  **Hybrid Enforcement:** The statement generates implicit runtime checks for range validity (e.g., `start <= end`) and overflow, but relies on static verification for disjointness. See §30.5.
2.  **Verification:** The compiler **MUST** verify that `proof_expr` evaluates to `true` given the control-flow facts available at the statement (§30.5).
3.  **Scope:** Within `block_stmt`, the specified targets are treated as disjoint `unique` paths.

**_Diagnostic:_**

| Code         | Severity | Description                      |
| :----------- | :------- | :------------------------------- |
| `E-MEM-3012` | Error    | Partition contract proof failed. |
    *   For an index target `i`, the element `collection_expr[i]` is available.
    *   For a range target `i..j`, the slice `collection_expr[i..j]` is available.
4.  **Restriction:** The compiler **MUST** reject any attempt to alias these targets or access the collection via other means within the block if those accesses cannot be statically proven disjoint from the partitioned targets.

**Example:**
```cursive
let arr: [i32; 10] = ...
let mid = 5

// Partition by two ranges (slices)
partition arr by (0..mid, mid..10) {
    // Inside this block, left and right are disjoint unique slices
    let left = &arr[0..mid]
    let right = &arr[mid..10]
    
    sort(left)
    sort(right)
}
```

### 29.4 The Partition Proof Verifier [memory.verifier]

This section defines the normative logic for the **Partition Proof Verifier**, the static analysis pass responsible for validating the where clause of a partition statement. Implementations **MUST** implement logic equivalent to the algorithms defined below.

#### 29.4.1 Scope and Abstract Domain [memory.verifier.scope]

The verifier operates on a restricted abstract domain. It **MUST** ignore any expression that cannot be reduced to the **Canonical Linear Form**.

Definition: Canonical Linear Form  
Every expression $E$ tracked by the verifier is represented as:

$$E ::= C_{base} + \sum (C_i \times V_i)$$

Where:

* $C_{base} \in \mathbb{Z}$ is a constant base offset.  
* $V_i$ is a unique symbolic variable ID (representing a let-binding, loop index, or parameter).  
* $C_i \in \mathbb{Z}$ is a constant coefficient for variable $V_i$.

#### 29.4.2 Algorithm: Canonical Reduction [memory.verifier.reduce]

The compiler **MUST** apply the following reduction procedure Reduce(Expr) -> LinearForm to all expressions in the partition clause and relevant control flow facts.

```cursive
procedure Reduce(e: Expression): LinearForm {
    match e {
        case Literal(n) => result { base: n, terms: [] }
        case Identifier(id) => result { base: 0, terms: [{coeff: 1, var: id}] }
        case Add(lhs, rhs) => result AddLinear(Reduce(lhs), Reduce(rhs))
        case Sub(lhs, rhs) => result AddLinear(Reduce(lhs), ScaleLinear(Reduce(rhs), -1))
        case Mul(lhs, rhs) => {
            let L = Reduce(lhs)
            let R = Reduce(rhs)
            if L.is_constant() { result ScaleLinear(R, L.base) }
            if R.is_constant() { result ScaleLinear(L, R.base) }
            result Unknown // Non-linear terms are not tracked
        }
        case _ => result Unknown
    }
}
```

#### 29.4.3 Algorithm: Verification Walk [memory.verifier.walk]

The verifier **MUST** compute the set of known facts at the partition statement by traversing the Control Flow Graph (CFG).

```cursive
// Input: CFG Node 'Target' (the partition statement)
// Output: Set<Constraint>

procedure GatherFacts(Target: Node): Set<Constraint> {
    let Facts = Set::new()
    let Node = Target.immediate_dominator
    
    while Node != null {
        match Node.statement {
            case "let x = E" =>
                Facts.add(Constraint::Eq(x, Reduce(E)))
            
            case "loop i in start..end" =>
                Facts.add(Constraint::Ge(i, Reduce(start)))
                Facts.add(Constraint::Lt(i, Reduce(end)))
                
            case "if Condition" =>
                if Target.is_dominated_by(Node.then_branch) {
                    Facts.add(ReduceCondition(Condition))
                } else {
                    Facts.add(ReduceCondition(Negate(Condition)))
                }
        }
        Node = Node.immediate_dominator
    }
    
    result Facts
}
```

#### 29.4.4 Proof Evaluation [memory.verifier.eval]

To validate partition arr by (A, B), the verifier checks if the ranges are disjoint given the Facts.

Disjointness Logic:
Two ranges $R_1=[L_1, U_1]$ and $R_2=[L_2, U_2]$ are disjoint if:
$$ (U_1 \le L_2) \lor (U_2 \le L_1) $$
The verifier **MUST** attempt to prove this inequality by substituting known Facts into the linear forms of $L$ and $U$. If the resulting inequality simplifies to $C \le 0$ where $C$ is a positive constant, the proof fails.

#### 29.4.5 Hybrid Enforcement [memory.verifier.hybrid]

If the static proof relies on the absence of integer overflow (e.g., assuming $i+1 > i$), the compiler **MUST** inject a runtime assertion to verify that specific assumption, unless it can prove via value-range analysis that overflow is impossible for the given types.

### 29.5 Regions and Arenas [memory.region]

Regions provide a mechanism for lexically scoped, deterministic, bulk memory allocation. A region is a named extent of program execution during which objects may be allocated into a specific memory arena. When the region ends, the arena is deallocated in constant time, destroying all objects contained within it.

#### 29.5.1 The `Arena` Modal Type [memory.region.arena]

The fundamental primitive underlying the region system is the built-in `Arena` modal type. It manages the lifecycle of the underlying memory block.

> **Definition:** `Arena` is a modal type with the following states and transitions:

```cursive
modal Arena {
    // The arena is live and accepts new allocations.
    @Active { ... }

    // The arena is live but prohibits new allocations.
    // Existing objects remain valid.
    @Frozen { ... }

    // The arena backing store has been deallocated.
    // No objects within it are valid.
    @Freed { ... }

    // Transitions
    procedure new() -> @Active;
    procedure freeze(self: unique Self@Active) -> @Frozen;
    procedure free(self: unique Self); // Transitions to @Freed (effectively)
}
```

1.  **Initialization:** A new arena starts in the `@Active` state.
2.  **Allocation:** Allocation is permitted if and only if the Arena is in the `@Active` state.
3.  **Termination:** The `free` operation invalidates the Arena and releases all backing memory.

#### 29.5.2 Region Blocks [memory.region.block]

The `region` statement creates a new scope associated with a specific `Arena` instance.

**Syntax:**
```ebnf
region_stmt ::= "region" identifier block_stmt
```

**Semantics:**
The `region` statement is syntactic sugar for the initialization of a local `Arena` binding and the registration of a deferred cleanup operation.

Given the statement `region r { ... }`, the implementation **MUST** behave as if the following code were generated:

```cursive
{
    // 1. Create the arena binding
    let r: unique Arena@Active = Arena::new();

    // 2. Register deterministic cleanup
    defer {
        r.free();
    }

    // 3. Execute the user block within a context where 'r' is the current region
    {
        ...
    }
}
```

**Constraints:**
1.  **Unique Identifier:** The `identifier` for the region **MUST** be unique within the current scope.
2.  **LIFO Lifetime:** Because `region` blocks desugar to standard lexical scopes with `defer`, regions strictly obey LIFO (Last-In, First-Out) lifetime semantics.

#### 29.5.3 The Allocation Operator (`^`) [memory.region.alloc]

The caret operator (`^`) performs allocation within an active region.

**Syntax:**
```ebnf
alloc_expr ::= "^"+ expression
```

**Semantics:**
1.  **Evaluation:** The operand expression is evaluated to produce a value.
2.  **Target Resolution:**
    *   A single caret (`^`) selects the lexically innermost active region.
    *   **Caret Stacking:** Each additional caret (`^^`, `^^^`, etc.) selects the immediate parent of the currently selected region.
3.  **Allocation:** The value is copied into storage managed by the selected `Arena`.
4.  **Result:** The operator evaluates to the allocated value (not a pointer). The location of this value is now within the region.

**Constraints:**
1.  **Active Context:** Usage of `^` is a compile-time error if no region scope is lexically enclosing the expression.
2.  **Depth Limit:** Usage of stacked carets exceeding the current region nesting depth is a compile-time error.

#### 29.5.4 Provenance and Escape Analysis [memory.region.escape]

To ensure memory safety, the compiler **MUST** track the origin of every pointer and reference to prevent use-after-free errors caused by a pointer outliving its backing storage.

**Provenance:**
Every type `Ptr<T>` and every reference binding carries a compile-time **Provenance Tag** $\pi$.

$$
\pi ::= \text{Stack} \mid \text{Heap} \mid \text{Region}(\text{id})
$$

1.  **Stack:** Addresses of local variables declared with `let` or `var`.
2.  **Heap:** Addresses of objects managed by the HeapAllocator capability (global lifetime or manually managed).
3.  **Region(id):** Addresses of objects allocated via `^` within the region named `id`.

**The Escape Rule:**
> **Provenance Constraint**
>
> A value with provenance $\text{Region}(R)$ **MUST NOT** be assigned to a location or binding that outlives the scope of region $R$.

**Validation:**
For every assignment `target = source`, the compiler compares the lifetime of `target` ($L_{target}$) with the provenance of `source` ($\pi_{source}$).

$$
\frac{\text{outlives}(L_{target}, \pi_{source})}{\text{Error: E-MEM-3020}}
$$

1.  **Return Values:** A function cannot return a pointer with `Region` provenance if that region is local to the function.
2.  **Outer Assignment:** A pointer with provenance `Region(Inner)` cannot be assigned to a variable declared in `Region(Outer)` (since `Inner` dies before `Outer`).
3.  **Heap Assignment:** A pointer with `Region` provenance cannot be stored in a `Heap` object.

**_Diagnostic:_**

| Code         | Severity | Description            |
| :----------- | :------- | :--------------------- |
| `E-MEM-3020` | Error    | Region pointer escape. |

### 29.6 Unsafe Memory [memory.unsafe]

Cursive permits the relaxation of static safety guarantees within explicitly demarcated regions of code. This facility is provided to implement low-level system primitives, interface with foreign code (FFI), and perform performance-critical operations where the compiler's static analysis is overly conservative.

#### 29.6.1 The `unsafe` Block [memory.unsafe.block]

The `unsafe` block delineates a lexical scope in which the compiler suspends specific memory safety enforcement mechanisms.

**Syntax:**
```ebnf
unsafe_block ::= "unsafe" block_stmt
```

**Semantics:**
1.  **Suspension of Constraints:** Within an `unsafe` block, the compiler **SHALL NOT** enforce:
    *   **Liveness Checks:** The validity of memory addresses being accessed.
    *   **Aliasing Checks:** The exclusivity of mutable access paths.
    *   **Partitioning Checks:** The disjointness of indices or fields during access.
2.  **Enabled Operations:** The following operations are permitted *only* within an `unsafe` block:
    *   Dereferencing **Raw Pointers** (§30.7.2).
    *   Calling procedures marked with the `unsafe` attribute or declared `extern`.
    *   Calling `transmute` to reinterpret bits.
3.  **Programmer Obligation:** The use of an `unsafe` block constitutes a normative assertion by the programmer that the code within satisfies all memory safety invariants (Liveness and Aliasing) dynamically, despite the absence of static verification.
4.  **Isolation:** The effects of `unsafe` code **MUST NOT** compromise the safety of safe code outside the block.

#### 29.6.2 Raw Pointers [memory.unsafe.raw]

Raw pointers are address types that carry no compile-time guarantees regarding validity, ownership, or aliasing. They are the mechanism for unchecked memory access.

**Syntax:**
```ebnf
raw_pointer_type ::= "*imm" type  |  "*mut" type
```

*   `*imm T`: An immutable raw pointer to a value of type `T`.
*   `*mut T`: A mutable raw pointer to a value of type `T`.

**Semantics:**
1.  **Representation:** Raw pointers are represented as an address integer. They have the same size and alignment as `usize`.
2.  **Copy Semantics:** Raw pointers implement `Copy`. Duplicating a raw pointer creates a new value pointing to the same address; it does not affect the lifecycle of the pointed-to data.
3.  **Absence of Ownership:** Raw pointers are **never** responsible bindings. They do not own data, do not participate in RAII, and do not trigger `Drop::drop` when they go out of scope.
4.  **Dereference:**
    *   The dereference operator (`*`) **MAY** be applied to a raw pointer.
    *   This operation is valid **only** within an `unsafe` block.
    *   Dereferencing an invalid, null, or misaligned raw pointer results in **Undefined Behavior**.
5.  **Pointer Arithmetic:**
    *   Arithmetic operations (offset, addition, subtraction) on raw pointers are permitted **only** within an `unsafe` block.
    *   These operations are unchecked and do not account for object boundaries.

#### 29.6.3 Bitwise Reinterpretation (`transmute`) [memory.unsafe.transmute]

> **Transmute Intrinsic**
>
> The `transmute` intrinsic reinterprets the bits of a value of one type as another type. It is a primitive unsafe operation.
>
> **Syntax:**
> `transmute` **MUST** be called with explicit type arguments: `transmute::<SourceType, TargetType>(expression)`.
>
> **Constraints:**
>
> 1.  **Safety:** `transmute` **MUST** appear only within an `unsafe` block.
> 2.  **Size Matching:** The size of `SourceType` and `TargetType` **MUST** be identical. This size equality **MUST** be verified at compile time.
> 3.  **Programmer Obligation:** The programmer guarantees that the bit pattern of the source value is a valid representation for the target type. Creating an invalid value (e.g., a bool with value 3, or a null reference) via transmute constitutes Unverifiable Behavior (UVB) (see §6.1.1).

**_Diagnostic:_**

| Code         | Severity | Description                |
| :----------- | :------- | :------------------------- |
| `E-MEM-3031` | Error    | `transmute` size mismatch. |

### 29.7 Diagnostics Summary [memory.diagnostics]

This section lists the diagnostic codes associated with the Memory Model. Conforming implementations **MUST** emit these codes when the corresponding normative constraints are violated.

| Code           | Severity | Description                                                                                                               | Section |
| :------------- | :------- | :------------------------------------------------------------------------------------------------------------------------ | :------ |
| **E-MEM-3001** | Error    | **Use of moved value.** Attempt to access a binding that has been statically invalidated by a `move` operation.           | §30.2.2 |
| **E-MEM-3005** | Error    | **Explicit call to destructor.** User code attempted to call `Drop::drop` directly.                                       | §30.2.5 |
| **E-MEM-3010** | Error    | **Static partition conflict.** Simultaneous access to the same record partition via `shared` bindings.                    | §29.3.1 |
| **E-MEM-3012** | Error    | **Partition contract proof failed.** The verifier could not prove the disjointness of indices in a `partition` statement. | §29.3.2 |
| **E-MEM-3020** | Error    | **Region pointer escape.** A value with `Region` provenance was assigned to a location outliving the region.              | §30.6.4 |
| **E-MEM-3030** | Error    | **Unsafe operation outside unsafe block.** Raw pointer dereference or other unsafe operation used in safe code.           | §30.7   |

---

---

## 30. The Capability System [ocap]

This chapter defines the Cursive Capability system. This system governs all procedures that produce observable **external effects** (e.g., I/O, networking, threading, heap allocation) and enforces the security principle of **No Ambient Authority**.

### 30.1 Principles [ocap.principles]

> **Global State Prohibition**
>
> 1.  **No Global State:** A conforming implementation **MUST NOT** provide mutable global variables or global procedures that perform side effects (e.g., no `open()`, `print()`, or `malloc()` in the global namespace).
> 2.  **Capabilities:** Authority to perform a sensitive operation **MUST** be represented by a first-class value (a **Capability**).
> 3.  **Parameter Injection:** To perform an effect, a procedure **MUST** require the corresponding capability as an explicit parameter.
> 4.  **Unforgeability:** Capabilities cannot be constructed arbitrarily by user code. They **MUST** originate from the runtime root or be derived (attenuated) from an existing capability.

### 30.2 The Root of Capability [ocap.root]

All system-level capabilities originate from the Cursive runtime and are injected into the program at the entry point.

#### 30.2.1 `main` Procedure Signature [ocap.root.main]

> **Entry Point**
>
> The entry point for an executable **MUST** be a procedure named `main` with the following signature:
>
> ```cursive
> public procedure main(ctx: Context): i32
> ```
>
> The runtime **MUST** guarantee that `ctx` is a valid, initialized `Context` record containing the root capabilities for the process.
>
> Any other signature for `main` (e.g., no parameters, incorrect return type) **MUST** be diagnosed as error `E-DEC-2431`.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-DEC-2431` | Error | `main` signature is incorrect. Must be `public procedure main(ctx: Context): i32`. |

#### 30.2.2 The `Context` Record [ocap.root.context]

> **Context Record**
>
> The `Context` is a built-in `public record` type. It serves as the root of authority for the application, bundling the implementations of all available system-level capabilities.
>
> The `Context` record **MUST** be defined with the following structure:
>
> ```cursive
> public record Context {
>     // Filesystem capability (Witness)
>     public fs: witness FileSystem,
>
>     // Network capability (Witness)
>     public net: witness Network,
>
>     // System capability (Public Concrete Record)
>     public sys: System,
>
>     // Heap Allocator capability (Witness)
>     public heap: witness HeapAllocator,
> }
> ```
>
> **Note:** By using `witness` types, the `Context` exposes capabilities via their public interfaces (`FileSystem`, `Network`) while keeping the concrete root implementations (e.g., `internal record RootFileSystem`) hidden from the public API.

### 30.3 System Capability Traits [ocap.traits]

System capabilities are defined by **Traits** (interfaces). This allows for **Attenuation** (§30.4) and **Virtualization** (mocking for tests). The normative definitions of these traits are provided in **Appendix D.2**.

#### 30.3.1 FileSystem Trait [ocap.traits.fs]

> **FileSystem Trait**
>
> The `FileSystem` trait governs access to the host filesystem.
>
> *   **Operations:** It **MUST** provide methods for reading, writing, and opening files (returning `FileHandle`).
> *   **Attenuation:** It **MUST** provide a `restrict(path)` method that returns a new `witness FileSystem` capability limited to a specific directory subtree.

#### 30.3.2 Network Trait [ocap.traits.net]

> **Network Trait**
>
> The `Network` trait governs access to network sockets.
>
> *   **Operations:** It **MUST** provide methods for connecting to remote hosts (`connect`) and binding listeners.
> *   **Attenuation:** It **MUST** provide a `restrict_to_host(addr)` method that returns a new `witness Network` capability limited to specific domains or IP ranges.

#### 30.3.3 System Record [ocap.traits.system]

> **System Capability**
>
> The `System` capability is a `public record` aggregating miscellaneous system-level primitives.
>
> ```cursive
> public record System {
>     // Environment Variables
>     procedure get_env(self: const, key: string@View): string;
>
>     // Time
>     procedure time(self: const): Timestamp;
>
>     // Process Control (Terminates execution)
>     procedure exit(self: const, code: i32): !;
>
>     // Concurrency (See Chapter 31)
>     procedure spawn<T>(self: const, action: () -> T): Thread<T>@Spawned;
>     procedure create_mutex<T>(self: const, value: T): Mutex<T>@Unlocked;
> }
> ```

#### 30.3.4 HeapAllocator Trait [ocap.traits.heap]

> **HeapAllocator Trait**
>
> The `HeapAllocator` trait governs dynamic memory allocation.
>
> *   **Operations:** It **MUST** provide `alloc` and `free` methods.
> *   **Safety:** Explicit use of `HeapAllocator` is required for types like `string@Managed` and `Vec<T>`.
> *   **Attenuation:** It **MUST** provide a `with_quota(bytes)` method that returns a new `witness HeapAllocator` that fails if the allocation limit is exceeded.

### 30.4 Capability Attenuation [ocap.attenuation]

Attenuation is the process of creating a new capability with strictly less authority than the original.

> **Capability Authority**
>
> A procedure that accepts a capability trait (e.g., `fs: witness FileSystem`) **SHOULD NOT** assume it holds root authority. It acts only on the authority granted by the capability it receives.
>
> Attenuation methods (e.g., `restrict`) **MUST** return a capability that:
> 1.  Implements the same capability trait.
> 2.  Enforces the new restrictions (e.g., path validation).
> 3.  Delegates authorized operations to the parent capability.

### 30.5 Capability Propagation [ocap.propagation]

Capabilities travel through the call graph as explicit parameters.

#### 30.5.1 Explicit Capability Passing [ocap.propagation.explicit]

> **Granular Capabilities**
>
> Low-level or reusable procedures **SHOULD** accept only the specific capability traits they require.
>
> ```cursive
> // Good: Accepts any implementation of FileSystem
> procedure read_config(fs: witness FileSystem, path: string@View) { ... }
> ```

#### 30.5.2 Capability Bundle Pattern [ocap.propagation.bundle]

> **Capability Bundles**
>
> High-level "manager" procedures **MAY** accept custom record types ("Bundles") that aggregate multiple capabilities.
>
> ```cursive
> record AppContext {
>     fs: witness FileSystem,
>     net: witness Network
> }
>
> procedure run_server(ctx: AppContext) { ... }
> ```

### 30.6 User-Defined Capabilities [ocap.user]

Users **MAY** define their own capability types to represent application-level authority (e.g., `DatabaseAccess`, `BillingService`).

> **User-Defined Capabilities**
>
> A user-defined capability is typically implemented as a `record` that:
> 1.  Implements a specific domain trait.
> 2.  Holds system capabilities (e.g., `witness Network`) internally as `private` or `protected` fields.
>
> By wrapping the system capability, the user-defined capability restricts access to the raw system resource, allowing only the application-specific logic defined on its methods.
---

## 31. Concurrency [concurrency]

This chapter defines the Cursive concurrency model. The language provides two distinct, mutually exclusive paths for concurrent execution: **Path 1**, a deterministic, statically verified model for data parallelism (CREW); and **Path 2**, a capability-based model for stateful coordination using system threads and locks.

### 31.1 The Two-Path Concurrency Model [concurrency.model]

> **Concurrency Models**
>
> A conforming implementation **MUST** support exactly two models for concurrency. Programs **MUST** utilize one of the following paths for any concurrent operation:
>
> 1.  **Path 1 (Deterministic Data Parallelism):** Defined by the `parallel` block statement. This path guarantees **Concurrent Read, Exclusive Write (CREW)** semantics at compile time. It allows multiple threads to read shared data, but statically prevents mutation of that data during the parallel epoch. It is designed for high-performance compute tasks.
> 2.  **Path 2 (Stateful Coordination):** Defined by the `System` capability and synchronization primitives (`Mutex`, `Thread`). This path manages mutable state across threads using explicit locking and ownership transfer. It is designed for I/O, services, and non-deterministic event handling.

#### 31.1.1 Thread Safety via Permissions [concurrency.model.safety]

Cursive does **not** utilize "marker traits" (such as `Send` or `Sync`) to define thread safety. Instead, thread safety is an intrinsic property derived directly from the **Permission System** defined in Part 4, §16.

> **Thread Safety Rules**
>
> The compiler **MUST** enforce thread safety rules based on the permission of the binding being captured or transferred:
>
> 1.  **`const` Permission (Immutable):** Bindings with `const` permission are **Always Thread-Safe**. They **MAY** be shared freely between threads in both Path 1 and Path 2.
> 2.  **`unique` Permission (Exclusive):** Bindings with `unique` permission are **Transfer-Safe**. They **MAY** be moved to a new thread (transferring ownership). Once moved, they are inaccessible in the originating thread.
> 3.  **`partitioned` Permission (Aliased Mutable):** Bindings with `partitioned` permission are **Thread-Unsafe**. They **MUST NOT** be captured by `fork` or `spawn` closures unless wrapped in a synchronization primitive (e.g., `Mutex`).

**_Formal rule: Thread Safety_**
Let $\Gamma \vdash x : P~T$ be a binding $x$ with permission $P$ and type $T$.
Let $\text{IsSafe}(x, \text{Mode})$ be the judgment that $x$ is safe to use in concurrency mode $\text{Mode}$ ($\text{Share}$ or $\text{Transfer}$).

$$
\frac{}{\Gamma \vdash \text{IsSafe}(x : \text{const } T, \text{Share})}
\tag{Safe-Const}
$$

$$
\frac{}{\Gamma \vdash \text{IsSafe}(x : \text{unique } T, \text{Transfer})}
\tag{Safe-Unique}
$$

$$
\frac{}{\Gamma \nvdash \text{IsSafe}(x : \text{partitioned } T, _)}
\tag{Unsafe-Partitioned}
$$

**_Diagnostic:_**

| Code         | Severity | Description                                                                                     |
| :----------- | :------- | :---------------------------------------------------------------------------------------------- |
| `E-CON-3201` | Error    | Thread Safety Violation: Attempting to capture a `partitioned` binding in a concurrent closure. |

### 31.2 Path 1: The `parallel` Epoch (CREW) [concurrency.parallel]

The `parallel` statement creates a lexical scope called an **Epoch**. Within this epoch, the compiler enforces a "Concurrent Read" policy by statically tightening permissions, guaranteeing data-race freedom without runtime locks.

#### 31.2.1 The `parallel` Block Syntax [concurrency.parallel.syntax]

> **Parallel Block Syntax**
>
> The `parallel` block **MUST** conform to the following syntax:
>
> ```ebnf
> parallel_statement ::= "parallel" "(" binding_list ")" block
> binding_list ::= identifier ("," identifier)*
> ```
>
> The `binding_list` specifies the set of `unique` or `partitioned` bindings from the outer scope that will be shared within the parallel epoch.

#### 31.2.2 Permission Tightening and Static Invalidation [concurrency.parallel.permissions]

> **Parallel Semantics**
>
> Upon entry to a `parallel` block:
>
> 1.  **Static Invalidation:** The compiler **MUST** statically invalidate the bindings listed in `binding_list` in the enclosing scope. They cannot be accessed or mutated outside the block until the block terminates.
> 2.  **Permission Tightening:** Inside the block, the compiler **MUST** introduce new bindings for the identifiers in `binding_list`. These inner bindings **MUST** have the `const` permission, regardless of their outer permission (`unique` or `partitioned`).
> 3.  **Restoration:** Upon exit of the `parallel` block, the outer bindings are re-validated with their original permissions.

**_Formal rule: Parallel Context_**
Let $\Gamma_{outer}$ be the environment before the block. Let $x$ be a binding in the list with type $P_{outer}~T$.

$$
\frac{
    \Gamma_{inner} = \Gamma_{outer} [ x \mapsto \text{const } T ] \quad
    \Gamma_{outer}' = \Gamma_{outer} [ x \mapsto \text{invalidated} ]
}{
    \Gamma_{outer} \vdash \text{parallel}(x) \{ s \} \Rightarrow \Gamma_{outer}
}
\tag{WF-Parallel-Epoch}
$$

**_Explanation:_**
This transformation ensures that within the block, `x` is read-only. Since multiple threads spawned within the block can only capture `const` references (per §31.1.1), data races on `x` are impossible.

#### 31.2.3 The `fork` Expression [concurrency.parallel.fork]

> **Fork Keyword**
>
> The `fork` keyword is a syntactic construct permitted **only** within the lexical scope of a `parallel` block.
>
> ```ebnf
> fork_expression ::= "fork" closure_expression
> ```
>
> 1.  The closure **MUST** capture bindings from the `parallel` scope by reference. Since these bindings are `const`, the capture is thread-safe.
> 2.  The `fork` expression returns a handle of type `JobHandle<T>`, where `T` is the return type of the closure.

#### 31.2.4 The `JobHandle<T>` Type [concurrency.parallel.handle]

> **JobHandle Type**
>
> The `JobHandle<T>` is a specialized, non-modal type used exclusively for Path 1 concurrency.
>
> *   It **MUST** provide a method `join(self) -> T`.
> *   It **MUST NOT** provide a `detach()` method.
> *   It **MUST NOT** be `Copy` or `Clone`.

#### 31.2.5 The Static Join Requirement [concurrency.parallel.join]

> **Static Join Requirement**
>
> To guarantee deterministic termination of the epoch, the compiler **MUST** enforce the **Static Join Requirement**:
>
> Every `JobHandle` produced by a `fork` expression **MUST** be consumed by a call to `.join()` within the `parallel` block.
>
> The compiler **MUST** perform a linear usage analysis or definitive assignment analysis to verify that no `JobHandle` is dropped without being joined.
>
> 1.  If a `JobHandle` goes out of scope without being joined, the program is **ill-formed**.
> 2.  If a `JobHandle` is returned from the `parallel` block, the program is **ill-formed**.

**_Diagnostic:_**

| Code         | Severity | Description                                                                        |
| :----------- | :------- | :--------------------------------------------------------------------------------- |
| `E-CON-3202` | Error    | Static Join Violation: A `JobHandle` created in a `parallel` block was not joined. |

**_Example: Valid CREW Concurrency_**

```cursive
let buffer: unique [i32; 1000] = ...

// Enter Epoch. 'buffer' is invalidated here.
parallel(buffer) {
    // Inside: 'buffer' is 'const [i32; 1000]'

    let handle = fork {
        // Captures 'buffer' as const. Safe to read.
        process_part(buffer, 0, 500)
    }

    let handle2 = fork {
        // Captures 'buffer' as const. Safe to read.
        process_part(buffer, 500, 1000)
    }

    // Static Join Requirement: Must join both.
    handle.join()
    handle2.join()
}
// Exit Epoch. 'buffer' is 'unique' again.
// Modifications (if any were done via interior mutability primitives like atomics) are visible.
```

### 31.3 Path 2: Mutex Capability [concurrency.ocap]

Path 2 handles concurrency that requires stateful coordination or mutable aliasing using the Capability system.

#### 31.3.1 The `Thread<T>` Modal Type [concurrency.ocap.thread]

> **Thread Type**
>
> The `Thread<T>` type represents a system thread. It is a modal type (§19) with the following states:
>
> *   `@Spawned`: The thread is running.
> *   `@Joined`: The thread has finished, and its result `T` is available.
> *   `@Detached`: The thread has been detached; its result is discarded.

**_Transitions:_**
> **Thread Join**
>
> *   `join(self: unique Thread<T>@Spawned) -> Thread<T>@Joined`
>     *   Blocks the current thread until the target thread completes.
> *   `detach(self: unique Thread<T>@Spawned) -> Thread<T>@Detached`
>     *   Allows the thread to continue execution independently.

#### 31.3.2 The `Mutex<T>` Modal Type [concurrency.ocap.mutex]

> **Mutex Type**
>
> The `Mutex<T>` type provides synchronized mutable access to data. It is a modal type with two states:
>
> *   `@Unlocked`: The mutex is free. The data `T` is contained but inaccessible.
> *   `@Locked`: The mutex is held by the current thread. The data `T` is accessible.

**_Transitions and Operations:_**

> **Mutex Lock**
>
> 1.  **`lock`**:
>     *   Signature: `lock(self: const Mutex<T>@Unlocked) -> MutexGuard<T>`
>     *   Requires `const` permission. It transitions the *logical* state of the mutex to locked for the caller.
>     *   Returns a RAII guard (see §31.3.3).
>
> 2.  **`unlock`**:
>     *   Signature: `unlock(self: unique Mutex<T>@Locked) -> Mutex<T>@Unlocked`
>     *   Invoked implicitly via the `MutexGuard` destructor.

#### 31.3.3 The `MutexGuard<T>` RAII Pattern [concurrency.ocap.guard]

> **Mutex Guard**
>
> The `lock` transition **MUST** return a `MutexGuard<T>`.
>
> *   The guard is a **responsible binding** that holds a `unique` reference to the data `T`.
> *   The guard implements the `Drop` trait. When the guard goes out of scope, its `drop` procedure **MUST** invoke the `unlock` transition on the underlying mutex.

**_Diagnostic:_** Accessing data protected by a mutex without holding the guard is prevented by the type system (the data is private to the mutex).

#### 31.3.4 `System.spawn` [concurrency.ocap.spawn]

> **Spawn Procedure**
>
> To spawn a thread in Path 2, the `System` capability is required. The `spawn` procedure is a member of the `System` record (accessible via `ctx.sys`).
>
> ```cursive
> // In System record
> procedure spawn<T>(self: const, closure: () -> T): Thread<T>@Spawned
> ```
>
> **Capture Constraints:**
> 1.  The `closure` **MUST NOT** capture any `partitioned` bindings.
> 2.  Any `unique` bindings captured by the closure **MUST** be moved into the closure.
> 3.  Any `const` bindings captured by the closure **MUST** be `Copy` or thread-safe references.

**_Diagnostic:_**

| Code         | Severity | Description                                                                                         |
| :----------- | :------- | :-------------------------------------------------------------------------------------------------- |
| `E-CON-3203` | Error    | Spawn Capture Violation: Invalid capture in `System.spawn` (e.g., capturing `unique` without move). |

### 31.4 Diagnostics Summary [concurrency.diagnostics]

| Code         | Severity | Description                                                                                         |
| :----------- | :------- | :-------------------------------------------------------------------------------------------------- |
| `E-CON-3201` | Error    | Thread Safety Violation: Attempting to capture a `partitioned` binding in a concurrent closure.     |
| `E-CON-3202` | Error    | Static Join Violation: A `JobHandle` created in a `parallel` block was not joined.                  |
| `E-CON-3203` | Error    | Spawn Capture Violation: Invalid capture in `System.spawn` (e.g., capturing `unique` without move). |

---

## 32. Interoperability (FFI) [ffi]

This chapter defines the mechanisms for interacting with foreign code, specifically code adhering to C-compatible Application Binary Interfaces (ABIs). It specifies the syntax for external declarations, the safety boundaries enforced by `unsafe` blocks, the memory layout guarantees provided by representation attributes, and the strict categorization of types allowed across the language boundary.

### 32.1 Extern Declarations [ffi.extern]

The `extern` declaration introduces a symbol whose definition is provided by a foreign object file or library, or defines a Cursive procedure to be exported to foreign code.

#### 32.1.1 Syntax [ffi.extern.syntax]

> **Extern Syntax**
>
> An `extern` declaration **MUST** conform to the following syntax:
>
> ```ebnf
> extern_declaration ::= [ attribute_list ]
>                        "extern" <string_literal>
>                        "procedure" <identifier>
>                        "(" <param_list> ")" [ ":" <return_type> ]
>                        ( ";" | <block> )
> ```
>
> 1.  The `<string_literal>` specifies the **Calling Convention** (e.g., `"C"`, `"stdcall"`).
> 2.  **Import:** If the body is a semicolon `;`, the procedure is imported from a foreign library.
> 3.  **Export:** If the body is a block `{ ... }`, the procedure is defined in Cursive and exported to foreign code using the specified ABI.

#### 32.1.2 Constraints [ffi.extern.constraints]

> **FFI Safety**
>
> 1.  **FFI-Safe Signatures:** The `<param_list>` and `<return_type>` **MUST** consist exclusively of **FFI-Safe Types** as defined in §33.4. Violations **MUST** trigger `E-FFI-3301`.
> 2.  **Variadic Prohibition:** Cursive does **not** support variadic arguments (`...`). Declaration of a variadic extern procedure is a syntax error (`E-FFI-3304`).

**_Diagnostic:_**

| Code         | Severity | Description                                   |
| :----------- | :------- | :-------------------------------------------- |
| `E-FFI-3301` | Error    | Non-FFI-Safe type used in `extern` signature. |
| `E-FFI-3304` | Error    | Variadic arguments (`...`) are not supported. |
> **Export Visibility**
>
> 3.  **Export Visibility:** An exported extern procedure (one with a body) **MUST** be declared `public`.
> 4.  **Closure Prohibition:** Exported extern procedures **MUST NOT** capture values from their environment; they must be static.

#### 32.1.3 Attributes [ffi.extern.attributes]

> **FFI Attributes**
>
> FFI declarations support specific attributes to control linking and runtime behavior:
>
> 1.  **`[[link_name("symbol")]]`**: Overrides the symbol name used by the linker.
> 2.  **`[[no_mangle]]`**: Disables symbol mangling. This is **Implicit** for all `extern "C"` declarations but may be explicit.
> 3.  **`[[unwind(abort|catch)]]`**: Controls panic behavior crossing the FFI boundary (see §33.5.2). Default is `abort`.

### 32.2 Unsafe Interaction [ffi.unsafe]

Calling a foreign function is inherently an operation whose safety cannot be verified by the Cursive compiler. The foreign code may violate memory safety, type safety, or concurrency guarantees.

#### 32.2.1 The Unverifiable Behavior (UVB) Rule [ffi.unsafe.uvb]

> **FFI Safety Boundary**
>
> A call to an imported `extern` procedure is classified as **Unverifiable Behavior (UVB)**. Consequently:
>
> 1.  Any call site invoking an imported `extern` procedure **MUST** be enclosed within an `unsafe` block (§30.7).
> 2.  Attempting to call an imported `extern` procedure from safe code **MUST** be diagnosed as an error (`E-FFI-3302`).

**_Diagnostic:_**

| Code         | Severity | Description                                        |
| :----------- | :------- | :------------------------------------------------- |
| `E-FFI-3302` | Error    | Call to `extern` procedure outside `unsafe` block. |

#### 32.2.2 Attestation Requirement [ffi.unsafe.attestation]

> **FFI Attestation**
>
> In accordance with §6.7, `unsafe` blocks containing FFI calls **SHOULD** be annotated with `[[attestation]]`. In `strict` conformance mode, this is **REQUIRED**.

### 32.3 Type Representation [ffi.repr]

To exchange data with foreign code, Cursive types must have a predictable memory layout.

#### 32.3.1 Default Layout (Unspecified) [ffi.repr.default]

> **Default Layout**
>
> For any `record` or `enum` **not** marked with the `[[repr(C)]]` attribute, the memory layout (field ordering, padding, size, and alignment) is **Unspecified Behavior**. Passing a default-layout reference to foreign code is unsafe.

#### 32.3.2 The `[[repr(C)]]` Attribute [ffi.repr.c]

> **C Layout**
>
> The `[[repr(C)]]` attribute may be applied to `record` and `enum` declarations.
>
> **Records:**
> For a `record` marked `[[repr(C)]]`, the implementation **MUST** layout fields in declaration order, inserting padding only as required to satisfy alignment constraints defined by the target platform's C ABI.
>
> **Enums:**
> For an `enum` marked `[[repr(C)]]`, the implementation **MUST** represent the discriminant using a C-compatible integer tag. The tag size is implementation-defined (typically `i32`) unless specified via `[[repr(type)]]` (e.g., `[[repr(u8)]]`).
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-FFI-3303` | Error | Invalid use of `[[repr(C)]]` (e.g., on generic/modal type). |

### 32.4 FFI-Safe Types [ffi.types]

Only a strict subset of Cursive types are permitted to cross the FFI boundary.

#### 32.4.1 The FFI-Safe Catalog [ffi.types.catalog]

> **FFI-Safe Definition**
>
> A type $T$ is **FFI-Safe** if and only if $\text{IsFFISafe}(T)$ holds.
>
> 1.  **Primitives:**
>     *   Signed Integers: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`.
>     *   Unsigned Integers: `u8`, `u16`, `u32`, `u64`, `u128`, `usize`.
>     *   Floating Point: `f16`, `f32`, `f64`.
>     *   Unit: `()` (maps to `void` in return position, or zero-sized type in arguments).
> 2.  **Raw Pointers:**
>     *   `*imm T` and `*mut T`, provided $T$ is FFI-Safe or `()` (which maps to `void*`).
> 3.  **Function Pointers:**
>     *   Sparse function pointers `(Args) -> Ret` **ONLY IF** declared with an `extern` ABI (e.g., `extern "C" (i32) -> i32`).
> 4.  **Composites:**
>     *   `record` types annotated with `[[repr(C)]]`, provided all fields are FFI-Safe.
>     *   `enum` types annotated with `[[repr(C)]]`.

#### 32.4.2 Explicit Exclusions [ffi.types.exclusion]

> **Excluded Types**
>
> The following types are expressly **Excluded** from FFI signatures (`E-FFI-3301`):
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-FFI-3301` | Error | Non-FFI-Safe type in `extern` signature. |
>
> **ABI Strings**
>
> Implementations **MUST** support the following ABI string literals:
>
> 1.  `"C"`: The default C compiler calling convention for the target platform.
> 2.  `"system"`: The standard system-call convention for the target OS (e.g., `stdcall` on Win32, `C` on Linux).
>
> Implementations **MAY** support additional platform-specific conventions (e.g., `"stdcall"`, `"fastcall"`).

#### 32.5.2 Panic Safety and Unwinding [ffi.abi.panic]

> **FFI Unwinding**
>
> Cursive exceptions (panics) **MUST NOT** unwind across an FFI boundary. Behavior is controlled by the `[[unwind]]` attribute on the `extern` declaration:
>
> 1.  **`[[unwind(abort)]]` (Default):** If a panic reaches the boundary of an exported `extern` procedure, the runtime **MUST** immediately abort the process (fail-fast).
> 2.  **`[[unwind(catch)]]`:** The compiler generates a landing pad at the boundary. If a panic occurs, it is caught, and the procedure **MUST** return a fallback error value (e.g., `-1` or `null`).
>
> **Constraint:** Procedures marked `[[unwind(catch)]]` **MUST** return a type capable of representing failure (e.g., an integer or pointer), or the behavior is undefined.

### 32.6 Diagnostics Summary [ffi.diagnostics]

| Code         | Severity | Description                                                 |
| :----------- | :------- | :---------------------------------------------------------- |
| `E-FFI-3301` | Error    | Non-FFI-Safe type used in `extern` signature.               |
| `E-FFI-3302` | Error    | Call to `extern` procedure outside `unsafe` block.          |
| `E-FFI-3303` | Error    | Invalid use of `[[repr(C)]]` (e.g., on generic/modal type). |
| `E-FFI-3304` | Error    | Variadic arguments (`...`) are not supported.               |

---

## 33. Metaprogramming (Codegen) [meta]

This chapter defines the Cursive metaprogramming system. Cursive provides a deterministic, declarative code generation mechanism based on **compile-time execution**, **type introspection**, **quasiquoting**, and **explicit AST emission**.

This system adheres to the **Two-Phase Compilation Model** defined in §8.4. Metaprogramming occurs strictly between the **Parsing** and **Semantic Analysis** phases.

### 33.1 Compile-Time Execution [meta.comptime]

Compile-time execution allows arbitrary Cursive logic to run during the compilation process to compute constants or generate code.

#### 33.1.1 The `comptime` Context [meta.comptime.context]

> **Comptime Execution**
>
> Code marked with the `comptime` keyword **MUST** execute during the Metaprogramming Phase. This code executes in a sandboxed interpreter or VM distinct from the runtime program.

**_Formal rule:_**
The `comptime` environment $\Gamma_{ct}$ is initialized with the standard library and any modules imported via `import`. It does **not** share mutable state with the runtime environment $\Gamma_{rt}$.

Constraints on the `comptime` context:
1.  **Isolation:** `comptime` code **MUST NOT** access runtime memory, file handles, sockets, or foreign function interfaces (FFI), except via explicitly provided compiler capabilities.
2.  **Determinism:** `comptime` code **MUST** be deterministic. Given the same source input and compiler configuration, it **MUST** produce the same output.
3.  **Termination:** Implementations **MUST** enforce resource limits (§34.6) to ensure compilation terminates.

#### 33.1.2 `comptime` Procedures [meta.comptime.procedures]

> **Comptime Procedure**
>
> A procedure declared with the `comptime` modifier is a **compile-time procedure**.

```cursive
comptime procedure generate_lookup_table(size: i32): [i32] {
    // ... logic ...
}
```

1.  **Callability:** A `comptime` procedure **MAY** be called by other `comptime` code, `comptime` blocks, or used in `const` initializers.
2.  **Runtime Exclusion:** A `comptime` procedure **MUST NOT** be called by runtime code.

**_Diagnostic:_**

| Code         | Severity | Description                                       |
| :----------- | :------- | :------------------------------------------------ |
| `E-MET-3401` | Error    | `comptime` procedure called from runtime context. |

    Attempting to call a `comptime` procedure from a runtime context **MUST** be diagnosed as error `E-MET-3401`.
3.  **Parameter Types:** Parameters to `comptime` procedures must be types that are representable at compile time (primitives, strings, arrays, tuples, or structs thereof).

#### 33.1.3 `comptime` Blocks [meta.comptime.blocks]

> **Comptime Block**
>
> A `comptime` block is a block statement prefixed with the `comptime` keyword. It executes immediately when encountered during the Metaprogramming Phase.

```cursive
comptime {
    let x = calculate_const();
    // ...
}
```

1.  **Scope:** Variables declared inside a `comptime` block are local to the compile-time environment and do not persist to the runtime program.
2.  **Expression Use:** A `comptime` block **MAY** return a value. If the value is a valid constant type, the block may be used as an expression in runtime code (e.g., `let x = comptime { 1 + 1 };`).

---

### 33.2 Type Introspection [meta.introspection]

To facilitate code generation based on types (e.g., serialization, ORM mappings), Cursive provides built-in introspection capabilities within the `comptime` context.

#### 33.2.1 The `TypeInfo` Structure [meta.introspection.typeinfo]

> **TypeInfo**
>
> Implementations **MUST** provide a `TypeInfo` record (or equivalent API) accessible in `comptime` that describes a type's structure.

This includes:
*   **Kind:** (Record, Enum, Primitive, etc.)
*   **Name:** Fully qualified name.
*   **Fields:** List of field names, types, and attributes (for records).
*   **Variants:** List of variant names and payloads (for enums).

#### 33.2.2 The `reflect_type<T>()` Intrinsic [meta.introspection.reflect]

> **Reflect Type**
>
> The intrinsic `reflect_type<T>()` **MUST** be available in `comptime` contexts. It returns the `TypeInfo` for the generic parameter `T`.

**_Constraint:_**
`reflect_type` can only be used on types that are fully defined at the point of invocation. Recursive dependencies that prevent layout resolution **MUST** be diagnosed.

---

### 33.3 Quote Expressions [meta.quote]

Quote expressions are the primary mechanism for creating code fragments (Abstract Syntax Trees). They allow programmers to write Cursive syntax that is captured as data rather than executed.

#### 33.3.1 Syntax and Semantics [meta.quote.syntax]

> **Quote Syntax**
>
> A quote expression **MUST** conform to the syntax `quote <block>` or `quote <expression>`.

```cursive
let definition = quote {
    public procedure hello() {
        print("Hello");
    }
}
```

1.  **Validation:** The content of a `quote` expression **MUST** be syntactically valid Cursive code. Implementations **MUST** parse the quoted code at definition time.
2.  **Type:** The `quote` expression evaluates to an opaque value of type `QuotedBlock` (for blocks) or `QuotedExpr` (for single expressions).
3.  **Deferred Typing:** The code within `quote` is **not type-checked** at the point of definition. Type checking occurs only after the code is emitted into a valid scope (§34.5).

#### 33.3.2 Lexical Scoping and Hygiene [meta.quote.hygiene]

> **Quote Resolution**
>
> Identifiers appearing within a `quote` block are resolved as follows:

1.  **Free Identifiers:** Identifiers that are not defined within the quote block are **captured** from the lexical scope where the `quote` expression appears. This ensures hygienic behavior for external references.
2.  **Bound Identifiers:** Variables and procedures declared *within* the quote block are local to that block.
3.  **Hygiene Breaking:** To introduce new identifiers into the *target* scope (the scope where the code is emitted), the programmer **MUST** use Identifier Splicing (§34.4.2).

---

### 33.4 Interpolation (Splicing) [meta.interpolation]

Interpolation allows compile-time values to be injected ("spliced") into a `quote` block. Cursive uses the `$(...)` syntax for interpolation.

#### 33.4.1 Value Splicing [meta.interpolation.value]

> **Literal Splicing**
>
> If the expression inside `$(...)` evaluates to a supported literal type (integer, boolean, string, float, char), it is spliced as a **literal value** in the generated AST.

```cursive
let limit = 100
let check = quote {
    if x > $(limit) { return; } // Becomes: if x > 100 { return; }
}
```

#### 33.4.2 Identifier Splicing [meta.interpolation.ident]

> **Identifier Splicing**
>
> If the expression inside `$(...)` evaluates to a `string` (or `string@View`), and that string appears in a position where an identifier is expected, it is spliced as an **identifier**.

This is the mechanism for programmatically generating names (e.g., generating struct fields or method names).

```cursive
let method_name = "get_value"
let impl = quote {
    procedure $(method_name)() { ... } // Becomes: procedure get_value() { ... }
}
```

**_Constraint:_** The string must be a valid Cursive identifier (§9.3). Invalid identifiers **MUST** result in a compile-time error (`E-MET-3403`).

**_Diagnostic:_**

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-MET-3403` | Error    | Invalid identifier string in interpolation. |

#### 33.4.3 AST Splicing [meta.interpolation.ast]

> **AST Splicing**
>
> If the expression inside `$(...)` evaluates to a `QuotedBlock` or `QuotedExpr`, the AST fragment is inserted directly into the surrounding code structure.

```cursive
let inner = quote { x = x + 1; }
let outer = quote {
    loop {
        $(inner) // Injects the body of 'inner' here
    }
}
```

---

### 33.5 Code Emission [meta.emit]

The `emit` intrinsic is the bridge between the compile-time metaprogram and the runtime program structure. Code is never emitted implicitly; it must be explicitly injected.

#### 33.5.1 The `ComptimeCodegen` Capability [meta.emit.capability]

> **Code Emission**
>
> Code emission is a side effect on the compilation unit. It **MUST** require the `ComptimeCodegen` capability. This capability is provided by the compiler environment to `comptime` entry points (e.g., via the `Context` or a compiler intrinsic).

#### 33.5.2 The `emit` Method [meta.emit.method]

> **Emit Method**
>
> The `emit` method on the `ComptimeCodegen` capability takes a `QuotedBlock` and injects its contents into the current module's scope.
>
> ```cursive
> // Method signature on ComptimeCodegen type
> procedure emit(self: unique, code: QuotedBlock);
> ```

1.  **Injection Point:** Code is always emitted into the **module scope** where the `comptime` block resides. It cannot be injected into arbitrary scopes.
2.  **Visibility:** Emitted declarations are visible to all subsequent phases of compilation, exactly as if they had been written in the source file.
3.  **Type Checking:** After the Metaprogramming Phase completes, the compiler **MUST** perform full type checking on the expanded AST.
    *   Any type errors found in generated code **MUST** be reported with a diagnostic trace pointing to the `emit` call site (`E-MET-3405`).
    *   Implementations **SHOULD** provide the generated source code in the error message to aid debugging.

**_Diagnostic:_**

| Code         | Severity | Description                                                   |
| :----------- | :------- | :------------------------------------------------------------ |
| `E-MET-3405` | Error    | Emitted code failed type checking (includes trace to source). |

#### 33.5.3 Normative Example [meta.emit.example]

```cursive
// [Normative Example]
// Assume 'compiler' is the build-system provided environment
comptime {
    let cg = compiler.get_codegen()
    let type_name = "DynamicRecord"
    
    // Generate a record with a method
    let ast = quote {
        public record $(type_name) {
            val: i32,
        }
        
        public procedure make_dynamic(): $(type_name) {
            result $(type_name) { val: 0 }
        }
    }

    // Injects definitions into the module
    cg.emit(ast)
}

// Runtime code can now use the generated types
public procedure main(ctx: Context): i32 {
    let d = make_dynamic()
    result d.val
}
```

---

### 33.6 Implementation Limits [meta.limits]

> **Comptime Limits**
>
> Conforming implementations **MUST** enforce the following minimum limits for compile-time execution to ensure portability. Exceeding these limits **MUST** result in error `E-MET-3402`.
>
> **_Diagnostic:_**
>
> | Code | Severity | Description |
> | :--- | :--- | :--- |
> | `E-MET-3402` | Error | Compile-time execution resource limit exceeded. |

| Resource              | Minimum Limit | Description                                            |
| :-------------------- | :------------ | :----------------------------------------------------- |
| **Recursion Depth**   | 256 frames    | Stack depth for `comptime` procedure calls.            |
| **Evaluation Steps**  | 1,000,000     | Basic operations (fuel) to prevent infinite loops.     |
| **Memory Allocation** | 64 MiB        | Total heap memory available to the `comptime` context. |
| **AST Depth**         | 1024 levels   | Maximum nesting depth of quoted ASTs.                  |

---

### 33.7 Diagnostics Summary [meta.diagnostics]

This chapter introduces the following diagnostics in the `MET` (Metaprogramming) category.

| Code         | Severity | Description                                                                  |
| :----------- | :------- | :--------------------------------------------------------------------------- |
| `E-MET-3401` | Error    | `comptime` procedure called from runtime context.                            |
| `E-MET-3402` | Error    | Compile-time execution resource limit exceeded (recursion, memory, or fuel). |
| `E-MET-3403` | Error    | Invalid identifier string in interpolation (contains invalid characters).    |
| `E-MET-3404` | Error    | `quote` block contains syntax error (parsing failed).                        |
| `E-MET-3405` | Error    | Emitted code failed type checking (includes trace to source).                |
| `E-MET-3406` | Error    | `emit` called without valid `ComptimeCodegen` capability.                    |

---

# Part 7 - Appendices (Normative) [part-7---appendices-normative]

## Appendix A: Formal Grammar (ANTLR) [appendix.formal-grammar-antlr]

This appendix contains the complete normative grammar for the Cursive programming language, expressed in ANTLRv4 syntax.

**Conventions:**
1.  This grammar defines the **concrete syntax** of Cursive source files.
2.  Lexical rules (UPPERCASE) define tokenization.
3.  Parser rules (lowercase) define the syntactic structure.
4.  The grammar assumes the source has already been normalized (UTF-8 decoded, BOM stripped, line endings normalized to LF) as per §8.

```antlr
grammar Cursive;

// ============================================================================
// PARSER RULES
// ============================================================================

// --- Compilation Unit -------------------------------------------------------

compilationUnit
    : topLevelItem* EOF
    ;

topLevelItem
    : attributeList? (
          importDeclaration
        | useDeclaration
        | procedureDeclaration
        | typeDeclaration
        | variableDeclaration
        | traitDeclaration
      )
    ;

// --- Attributes -------------------------------------------------------------

attributeList
    : attribute+
    ;

attribute
    : '[[' attributeSpec (',' attributeSpec)* ']]'
    ;

attributeSpec
    : IDENTIFIER ('(' attributeArgs ')')?
    ;

attributeArgs
    : attributeArg (',' attributeArg)*
    ;

attributeArg
    : literal
    | IDENTIFIER
    | IDENTIFIER ':' literal
    ;

// --- Module System ----------------------------------------------------------

importDeclaration
    : 'import' modulePath ('as' IDENTIFIER)? ';'
    ;

useDeclaration
    : visibility? 'use' useClause ';'
    ;

useClause
    : qualifiedPath ('as' IDENTIFIER)?
    | qualifiedPath '::' '{' useList '}'
    | qualifiedPath '::' '*'
    ;

useList
    : useSpecifier (',' useSpecifier)* ','?
    ;

useSpecifier
    : IDENTIFIER ('as' IDENTIFIER)?
    | 'self'
    ;

modulePath
    : IDENTIFIER ('::' IDENTIFIER)*
    ;

qualifiedPath
    : IDENTIFIER ('::' IDENTIFIER)*
    ;

visibility
    : 'public' | 'internal' | 'private' | 'protected'
    ;

// --- Declarations -----------------------------------------------------------

// Procedures
procedureDeclaration
    : visibility? 'comptime'? 'procedure' IDENTIFIER genericParams?
      '(' paramList? ')'
      (':' type ( '<:' typeList )? )?
      contractClause?
      ( block | ';' )
    ;

paramList
    : parameter (',' parameter)* ','?
    ;

parameter
    : receiverShorthand
    | 'move'? IDENTIFIER ':' type
    ;

receiverShorthand
    : '~'    // self: const Self
    | '~%'   // self: partitioned Self
    | '~!'   // self: unique Self
    ;

contractClause
    : '[[' ( mustClause? ('=>' willClause)? ) ']]'
    ;

mustClause
    : expression (',' expression)*
    ;

willClause
    : expression (',' expression)*
    ;

// Variables (Let/Var)
variableDeclaration
    : 'shadow'? ( 'let' | 'var' ) pattern ( ':' type )? '=' expression ';'
    ;

// Traits
traitDeclaration
    : visibility? 'trait' IDENTIFIER genericParams? traitBounds? '{'
          traitItem*
      '}'
    ;

traitItem
    : procedureDeclaration
    ;

traitBounds
    : '<:' typeList
    ;

typeList
    : type (',' type)*
    ;

// Types (Record, Enum, Modal, Alias)
typeDeclaration
    : recordDeclaration
    | enumDeclaration
    | modalDeclaration
    | typeAliasDeclaration
    ;

recordDeclaration
    : visibility? attributeList? 'record' IDENTIFIER genericParams? traitBounds? '{'
          recordBody
      '}'
    ;

recordBody
    : partitionDecl* fieldDeclList?
      procedureDeclaration* // Methods
    ;

partitionDecl
    : 'partition' IDENTIFIER '{' fieldDeclList? '}'
    ;

fieldDeclList
    : fieldDecl (',' fieldDecl)* ','?
    ;

fieldDecl
    : visibility? IDENTIFIER ':' type
    ;

enumDeclaration
    : visibility? attributeList? 'enum' IDENTIFIER genericParams? traitBounds? '{'
          enumVariantList?
          procedureDeclaration* // Methods
      '}'
    ;

enumVariantList
    : enumVariant (',' enumVariant)* ','?
    ;

enumVariant
    : IDENTIFIER ( '(' typeList ')' | '{' fieldDeclList '}' )?
    ;

modalDeclaration
    : visibility? attributeList? 'modal' IDENTIFIER genericParams? traitBounds? '{'
          stateBlock+
      '}'
    ;

stateBlock
    : '@' IDENTIFIER statePayload? stateMembers?
    ;

statePayload
    : '{' fieldDeclList? '}'
    ;

stateMembers
    : '{' ( procedureDeclaration | transitionSignature )* '}'
    ;

transitionSignature
    : 'transition' IDENTIFIER '(' paramList? ')' '->' '@' IDENTIFIER ';'
    ;

typeAliasDeclaration
    : visibility? 'type' IDENTIFIER genericParams? '=' type ';'
    ;

genericParams
    : '<' genericParam (',' genericParam)* '>'
    ;

genericParam
    : IDENTIFIER ('<:' typeList)?
    ;

// --- Types ------------------------------------------------------------------

type
    : permission? baseType
    ;

permission
    : 'const'
    | 'unique'
    | 'partitioned'
    ;

baseType
    : primitiveType
    | nominalType
    | tupleType
    | arrayType
    | sliceType
    | funcType
    | pointerType
    | modalStateType
    | witnessType
    | neverType
    | groupingType
    ;

primitiveType
    : 'i8' | 'i16' | 'i32' | 'i64' | 'i128' | 'int'
    | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'uint'
    | 'isize' | 'usize'
    | 'f16' | 'f32' | 'f64' | 'float' | 'double' | 'half'
    | 'bool' | 'char'
    | '(' ')' // Unit
    ;

nominalType
    : qualifiedPath genericArgs?
    ;

genericArgs
    : '<' typeList '>'
    ;

tupleType
    : '(' type (',' type)+ ','? ')'
    ;

arrayType
    : '[' type ';' expression ']'
    ;

sliceType
    : '[' type ']'
    ;

funcType
    : 'witness'? '(' funcParamList? ')' '->' type
    ;

funcParamList
    : funcParam (',' funcParam)*
    ;

funcParam
    : 'move'? type
    ;

pointerType
    : '*imm' type
    | '*mut' type
    ;

modalStateType
    : nominalType '@' IDENTIFIER // e.g., File@Open
    ;

witnessType
    : 'witness' nominalType // e.g., witness Drawable
    ;

neverType
    : '!'
    ;

groupingType
    : '(' type ')'
    ;

// --- Statements -------------------------------------------------------------

block
    : '{' statement* '}'
    ;

statement
    : declarationStatement
    | assignmentStatement
    | expressionStatement
    | deferStatement
    | controlFlowStatement
    | specialContractStatement
    | ';' // Empty statement
    ;

declarationStatement
    : variableDeclaration
    ;

assignmentStatement
    : expression assignmentOperator expression ';'
    ;

assignmentOperator
    : '=' | '+=' | '-=' | '*=' | '/=' | '%='
    | '&=' | '|=' | '^=' | '<<=' | '>>='
    ;

expressionStatement
    : expression ';'
    ;

deferStatement
    : 'defer' block
    ;

controlFlowStatement
    : 'return' expression? ';'
    | 'break' (LIFETIME_LABEL)? expression? ';'
    | 'continue' (LIFETIME_LABEL)? ';'
    | 'result' expression ';'
    ;

specialContractStatement
    : 'partition' expression 'by' '(' identifierList ')'
      'where' '(' expression ')'
      block
    ;

identifierList
    : IDENTIFIER (',' IDENTIFIER)*
    ;

// --- Expressions ------------------------------------------------------------

expression
    : logicalOrExpression
    ;

logicalOrExpression
    : logicalAndExpression ('||' logicalAndExpression)*
    ;

logicalAndExpression
    : equalityExpression ('&&' equalityExpression)*
    ;

equalityExpression
    : relationalExpression (('==' | '!=') relationalExpression)*
    ;

relationalExpression
    : bitwiseOrExpression (('<' | '>' | '<=' | '>=') bitwiseOrExpression)*
    ;

bitwiseOrExpression
    : bitwiseXorExpression ('|' bitwiseXorExpression)*
    ;

bitwiseXorExpression
    : bitwiseAndExpression ('^' bitwiseAndExpression)*
    ;

bitwiseAndExpression
    : shiftExpression ('&' shiftExpression)*
    ;

shiftExpression
    : additiveExpression (('<<' | '>>') additiveExpression)*
    ;

additiveExpression
    : multiplicativeExpression (('+' | '-') multiplicativeExpression)*
    ;

multiplicativeExpression
    : powerExpression (('*' | '/' | '%') powerExpression)*
    ;

powerExpression
    : unaryExpression ('**' unaryExpression)*
    ;

unaryExpression
    : ('!' | '-' | '*' | '&' | '~' | '^' | 'move') unaryExpression
    | primaryExpression
    ;

primaryExpression
    : literal
    | IDENTIFIER
    | qualifiedPath
    | '(' expression ')'
    | tupleLiteral
    | arrayLiteral
    | structLiteral
    | ifExpression
    | matchExpression
    | loopExpression
    | blockExpression
    | primaryExpression '(' argumentList? ')'      // Call
    | primaryExpression '[' expression ']'         // Index
    | primaryExpression '.' IDENTIFIER             // Field access
    | primaryExpression '.' INTEGER_LITERAL        // Tuple access
    | primaryExpression '::' IDENTIFIER '(' argumentList? ')' // Method call
    | primaryExpression '=>' primaryExpression     // Pipeline
    | primaryExpression '..' ('='? primaryExpression)? // Range
    ;

argumentList
    : argument (',' argument)* ','?
    ;

argument
    : 'move'? expression
    ;

tupleLiteral
    : '(' expression (',' expression)+ ','? ')'
    ;

arrayLiteral
    : '[' expression (',' expression)* ','? ']'
    | '[' expression ';' expression ']'
    ;

structLiteral
    : qualifiedPath genericArgs? '{' fieldInitList? '}'
    ;

fieldInitList
    : fieldInit (',' fieldInit)* ','?
    ;

fieldInit
    : IDENTIFIER ':' expression
    | IDENTIFIER // shorthand
    ;

ifExpression
    : 'if' expression block ('else' (block | ifExpression))?
    ;

matchExpression
    : 'match' expression '{' matchArm* '}'
    ;

matchArm
    : pattern '=>' ( expression ',' | block )
    ;

loopExpression
    : 'loop' expression? block // Infinite or conditional
    | 'loop' IDENTIFIER ':' type 'in' expression block // Iterator
    ;

blockExpression
    : 'unsafe' block
    | 'region' IDENTIFIER block
    | 'parallel' '(' identifierList ')' block
    | 'comptime' block
    | 'quote' ( block | expression )
    ;

// --- Patterns ---------------------------------------------------------------

pattern
    : literal
    | '_'
    | IDENTIFIER
    | tuplePattern
    | recordPattern
    | enumPattern
    | modalPattern
    ;

tuplePattern
    : '(' (pattern (',' pattern)* ','?)? ')'
    ;

recordPattern
    : qualifiedPath '{' (fieldPattern (',' fieldPattern)* ','?)? '}'
    ;

fieldPattern
    : IDENTIFIER (':' pattern)?
    ;

enumPattern
    : qualifiedPath '::' IDENTIFIER ('(' patternList ')')?
    | qualifiedPath '::' IDENTIFIER '{' (fieldPattern (',' fieldPattern)* ','?)? '}'
    ;

modalPattern
    : '@' IDENTIFIER ('{' (fieldPattern (',' fieldPattern)* ','?)? '}')?
    ;

patternList
    : pattern (',' pattern)* ','?
    ;

literal
    : INTEGER_LITERAL
    | FLOAT_LITERAL
    | STRING_LITERAL
    | CHAR_LITERAL
    | 'true'
    | 'false'
    | '(' ')' // Unit
    | interpolation // $(...) for quotes
    ;

interpolation
    : '$(' expression ')'
    ;

// ============================================================================
// LEXER RULES
// ============================================================================

// --- Keywords ---------------------------------------------------------------

KW_AS : 'as';
KW_BREAK : 'break';
KW_COMPTIME : 'comptime';
KW_CONST : 'const';
KW_CONTINUE : 'continue';
KW_DEFER : 'defer';
KW_ELSE : 'else';
KW_ENUM : 'enum';
KW_EXTERN : 'extern';
KW_FALSE : 'false';
KW_FORK : 'fork';
KW_IF : 'if';
KW_IMPORT : 'import';
KW_INTERNAL : 'internal';
KW_LET : 'let';
KW_LOOP : 'loop';
KW_MATCH : 'match';
KW_MODAL : 'modal';
KW_MOVE : 'move';
KW_MUT : 'mut';
KW_WITNESS : 'witness';
KW_OVERRIDE : 'override';
KW_PARALLEL : 'parallel';
KW_PARTITION : 'partition';
KW_PARTITIONED : 'partitioned';
KW_PRIVATE : 'private';
KW_PROCEDURE : 'procedure';
KW_PROTECTED : 'protected';
KW_PUBLIC : 'public';
KW_QUOTE : 'quote';
KW_RECORD : 'record';
KW_REGION : 'region';
KW_RESULT : 'result';
KW_RETURN : 'return';
KW_SELF : 'self';
KW_SHADOW : 'shadow';
KW_TRAIT : 'trait';
KW_TRANSITION : 'transition';
KW_TRUE : 'true';
KW_TYPE : 'type';
KW_UNIQUE : 'unique';
KW_UNSAFE : 'unsafe';
KW_USE : 'use';
KW_VAR : 'var';
KW_WHERE : 'where';

// Primitive types as keywords for convenience in grammar
KW_BOOL : 'bool';
KW_CHAR : 'char';
KW_I8 : 'i8'; KW_I16 : 'i16'; KW_I32 : 'i32'; KW_I64 : 'i64'; KW_I128 : 'i128'; KW_INT : 'int';
KW_U8 : 'u8'; KW_U16 : 'u16'; KW_U32 : 'u32'; KW_U64 : 'u64'; KW_U128 : 'u128'; KW_UINT : 'uint';
KW_ISIZE : 'isize'; KW_USIZE : 'usize';
KW_F16 : 'f16'; KW_F32 : 'f32'; KW_F64 : 'f64'; KW_FLOAT : 'float'; KW_DOUBLE : 'double'; KW_HALF : 'half';

// --- Identifiers ------------------------------------------------------------

IDENTIFIER
    : ( XID_START | '_' ) ( XID_CONTINUE )*
    ;

fragment XID_START
    : [a-zA-Z] | [\u00A0-\uFFFF] // Simplified approximation for ANTLR
    ;

fragment XID_CONTINUE
    : XID_START | [0-9] | '_'
    ;

LIFETIME_LABEL
    : '\'' IDENTIFIER
    ;

// --- Literals ---------------------------------------------------------------

INTEGER_LITERAL
    : (DEC_DIGIT (DEC_DIGIT | '_')*)
    | ('0x' HEX_DIGIT (HEX_DIGIT | '_')*)
    | ('0o' OCT_DIGIT (OCT_DIGIT | '_')*)
    | ('0b' BIN_DIGIT (BIN_DIGIT | '_')*)
    ;

FLOAT_LITERAL
    : DEC_DIGIT+ '.' DEC_DIGIT+ EXPONENT?
    | DEC_DIGIT+ EXPONENT
    ;

fragment DEC_DIGIT : [0-9];
fragment HEX_DIGIT : [0-9a-fA-F];
fragment OCT_DIGIT : [0-7];
fragment BIN_DIGIT : [0-1];
fragment EXPONENT  : [eE] [+-]? DEC_DIGIT+;

STRING_LITERAL
    : '"' ( ESCAPE_SEQUENCE | ~('\\' | '"') )* '"'
    ;

CHAR_LITERAL
    : '\'' ( ESCAPE_SEQUENCE | ~('\\' | '\'') ) '\''
    ;

fragment ESCAPE_SEQUENCE
    : '\\' [nrt\\'0"]
    | '\\x' HEX_DIGIT HEX_DIGIT
    | '\\u{' HEX_DIGIT+ '}'
    ;

// --- Whitespace and Comments ------------------------------------------------

WS
    : [ \t\r\n\u000C]+ -> skip
    ;

LINE_COMMENT
    : '//' ~[\r\n]* -> skip
    ;

BLOCK_COMMENT
    : '/*' .*? '*/' -> skip
    ;
```

---

## Appendix B: Diagnostic Code Taxonomy [appendix.diagnostic-code-taxonomy]

This appendix defines the normative taxonomy for compiler diagnostics. All conforming implementations **MUST** use these codes when reporting the corresponding conditions to ensure consistent error reporting across toolchains.

### B.1 Diagnostic Code Format [appendix.diagnostic-code-taxonomy.diagnostic-code-format]

Diagnostic codes follow the format `K-CAT-FFNN`:

*   **K (Kind/Severity):**
    *   `E`: **Error**. A violation of a normative requirement. Compilation cannot proceed to codegen.
    *   `W`: **Warning**. Code is well-formed but contains potential issues (e.g., deprecated usage).
    *   `N`: **Note**. Informational message attached to an error or warning.
*   **CAT (Category):** A three-letter code identifying the language subsystem.
*   **FF (Feature Bucket):** Two digits identifying the specific feature area or chapter within the category.
*   **NN (Number):** Two digits uniquely identifying the specific condition within the bucket.

### B.2 Feature Buckets (FF Values) [appendix.diagnostic-code-taxonomy.feature-buckets-ff-values]

The following tables define the "Feature Bucket" (`FF`) values for each Category (`CAT`). These values generally align with the specification chapters but are grouped for diagnostic utility.

#### B.2.1 Source, Syntax, & Modules [appendix.diagnostic-code-taxonomy.feature-buckets-ff-values.source-syntax-modules]

| Category | FF   | Feature Name         | Relevant Chapters |
| :------- | :--- | :------------------- | :---------------- |
| **SRC**  | 01   | Encoding & Structure | §8.1, §8.2        |
|          | 02   | Resource Limits      | §6.5, §8.2.2      |
|          | 03   | Lexical Elements     | §9                |
| **SYN**  | 01   | Recursive Limits     | §10.2             |
|          | 02   | General Grammar      | Appx A            |
| **MOD**  | 11   | Manifest & Projects  | §11               |
|          | 12   | Imports & Visibility | §12               |
|          | 14   | Initialization       | §14               |
| **NAM**  | 13   | Scopes & Shadowing   | §13               |

#### B.2.2 Type System [appendix.diagnostic-code-taxonomy.feature-buckets-ff-values.type-system]

| Category | FF   | Feature Name               | Relevant Chapters |
| :------- | :--- | :------------------------- | :---------------- |
| **TYP**  | 15   | Foundations                | §15               |
|          | 16   | Permissions                | §16               |
|          | 17   | Primitives                 | §17               |
|          | 18   | Composites                 | §18               |
|          | 19   | Modal Types (incl. String) | §19, §20          |
|          | 20   | Pointers                   | §21               |
|          | 23   | Function Types             | §22               |

#### B.2.3 Logic & Semantics [appendix.diagnostic-code-taxonomy.feature-buckets-ff-values.logic-semantics]

| Category | FF   | Feature Name     | Relevant Chapters |
| :------- | :--- | :--------------- | :---------------- |
| **DEC**  | 24   | Declarations     | §24               |
| **EXP**  | 25   | Expressions      | §25               |
| **STM**  | 26   | Statements       | §26               |
| **PAT**  | 27   | Pattern Matching | §27               |
| **CON**  | 28   | Contracts        | §28               |
|          | 32   | Concurrency      | §32               |

#### B.2.4 Systems & Metaprogramming [appendix.diagnostic-code-taxonomy.feature-buckets-ff-values.systems-metaprogramming]

| Category | FF   | Feature Name        | Relevant Chapters |
| :------- | :--- | :------------------ | :---------------- |
| **TRS**  | 29   | Traits              | §29               |
| **MEM**  | 30   | Memory Model        | §30               |
|          | 31   | Object Capabilities | §31               |
| **FFI**  | 33   | FFI & ABI           | §33               |
| **MET**  | 34   | Metaprogramming     | §34               |

### B.3 Normative Diagnostic Catalog [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog]

The following tables list all diagnostic codes required by this specification, organized by their Category and Feature Bucket.

#### B.3.1 SRC (Source) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.src-source]

| Code         | Severity | Description                                                                  |
| :----------- | :------- | :--------------------------------------------------------------------------- |
| `E-SRC-0101` | Error    | Invalid UTF-8 byte sequence in source file.                                  |
| `E-SRC-0102` | Error    | Source file exceeds implementation-defined maximum size.                     |
| `E-SRC-0103` | Error    | UTF-8 Byte Order Mark (BOM) found after the first byte.                      |
| `E-SRC-0104` | Error    | Source contains prohibited control character or null byte.                   |
| `E-SRC-0105` | Error    | Maximum logical line count exceeded.                                         |
| `E-SRC-0106` | Error    | Maximum line length exceeded.                                                |
| `W-SRC-0101` | Warning  | Source file begins with UTF-8 BOM (should be stripped).                      |
| `E-SRC-0204` | Error    | String literal length exceeds implementation limit during compile-time eval. |
| `E-SRC-0301` | Error    | Unterminated string literal.                                                 |
| `E-SRC-0302` | Error    | Invalid escape sequence in literal.                                          |
| `E-SRC-0303` | Error    | Invalid character literal (empty, multiple chars).                           |
| `E-SRC-0304` | Error    | Malformed numeric literal.                                                   |
| `E-SRC-0305` | Error    | Reserved keyword used as identifier.                                         |
| `E-SRC-0306` | Error    | Unterminated block comment.                                                  |
| `E-SRC-0307` | Error    | Invalid Unicode in identifier (violates UAX31).                              |
| `E-SRC-0308` | Error    | Lexically sensitive Unicode character in identifier (Strict Mode).           |
| `W-SRC-0301` | Warning  | Integer literal has leading zeros (interpreted as decimal, not octal).       |
| `W-SRC-0308` | Warning  | Lexically sensitive Unicode character in identifier (Permissive Mode).       |

#### B.3.2 SYN (Syntax) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.syn-syntax]

| Code         | Severity | Description                                             |
| :----------- | :------- | :------------------------------------------------------ |
| `E-SYN-0101` | Error    | Block nesting depth exceeded implementation limit.      |
| `E-SYN-0102` | Error    | Expression nesting depth exceeded implementation limit. |
| `E-SYN-0103` | Error    | Delimiter nesting depth exceeded implementation limit.  |

#### B.3.3 MOD (Modules) & NAM (Naming) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.mod-modules-nam-naming]

| Code         | Severity | Description                                           |
| :----------- | :------- | :---------------------------------------------------- |
| `E-MOD-1101` | Error    | `Cursive.toml` missing or syntactically malformed.    |
| `E-MOD-1102` | Error    | Manifest `[paths]` table missing or invalid.          |
| `E-MOD-1103` | Error    | Assembly references undefined root in `[paths]`.      |
| `E-MOD-1104` | Error    | Module path collision on case-insensitive filesystem. |
| `E-MOD-1105` | Error    | Module path component is a reserved keyword.          |
| `E-MOD-1106` | Error    | Module path component is not a valid identifier.      |
| `E-MOD-1107` | Error    | Manifest `[project]` table missing required keys.     |
| `E-MOD-1108` | Error    | Duplicate assembly name in manifest.                  |
| `E-MOD-1109` | Error    | Incompatible language version in manifest.            |
| `E-MOD-1201` | Error    | `import` path does not resolve to external module.    |
| `E-MOD-1202` | Error    | `use` path does not resolve to accessible module.     |
| `E-MOD-1203` | Error    | Name conflict in `use` or `import as`.                |
| `E-MOD-1204` | Error    | Item in `use` path not found or not visible.          |
| `E-MOD-1205` | Error    | Attempt to `public use` a non-public item.            |
| `E-MOD-1206` | Error    | Duplicate item in `use` list.                         |
| `E-MOD-1207` | Error    | Access to `protected` item denied.                    |
| `E-MOD-1401` | Error    | Cyclic dependency in eager module initialization.     |
| `W-MOD-1101` | Warning  | Potential module path collision (case-sensitivity).   |
| `W-MOD-1201` | Warning  | Wildcard `use` (`*`) usage.                           |
| `E-NAM-1301` | Error    | Unresolved name.                                      |
| `E-NAM-1302` | Error    | Duplicate name declaration in same scope.             |
| `E-NAM-1303` | Error    | Shadowing existing binding without `shadow` keyword.  |
| `E-NAM-1304` | Error    | Unresolved module in qualified path.                  |
| `E-NAM-1305` | Error    | Unresolved or inaccessible member in path.            |
| `E-NAM-1306` | Error    | Unnecessary use of `shadow` keyword.                  |

#### B.3.4 TYP (Type System) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.typ-type-system]

| Code         | Severity | Description                                             |
| :----------- | :------- | :------------------------------------------------------ |
| `E-TYP-1901` | Panic    | String slice boundary is not a valid `char` boundary.   |
| `E-TYP-1902` | Error    | Direct indexing of `string` is forbidden.               |
| `E-TYP-1910` | Error    | Modal type declares no states.                          |
| `E-TYP-1911` | Error    | Duplicate state in modal declaration.                   |
| `E-TYP-1912` | Error    | Accessing field existing only in specific modal state.  |
| `E-TYP-1913` | Error    | Accessing method existing only in specific modal state. |
| `E-TYP-1914` | Error    | Missing implementation for modal transition.            |
| `E-TYP-1915` | Error    | Transition body does not return target state type.      |
| `E-TYP-1920` | Error    | Non-exhaustive match on modal type.                     |
| `E-TYP-2001` | Error    | Dereference of `Ptr<T>@Null`.                           |
| `E-TYP-2002` | Error    | Dereference of `Ptr<T>@Expired`.                        |
| `E-TYP-2003` | Error    | Dereference of raw pointer outside `unsafe`.            |
| `E-TYP-2301` | Error    | Function argument count mismatch.                       |
| `E-TYP-2302` | Error    | Type mismatch (general).                                |
| `E-TYP-2304` | Error    | Control flow path missing `result` value.               |

#### B.3.5 DEC (Declarations), EXP (Expressions), STM (Statements) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.dec-declarations-exp-expressions-stm-statements]

| Code         | Severity | Description                                           |
| :----------- | :------- | :---------------------------------------------------- |
| `E-DEC-2401` | Error    | Re-assignment of immutable `let` binding.             |
| `E-DEC-2411` | Error    | `move` keyword mismatch at call site.                 |
| `E-DEC-2420` | Error    | Recursive type alias detected.                        |
| `E-DEC-2430` | Error    | Missing or duplicate `main` procedure.                |
| `E-DEC-2431` | Error    | Invalid signature for `main` (must accept `Context`). |
| `E-DEC-2450` | Error    | Malformed attribute syntax.                           |
| `E-DEC-2451` | Error    | Unknown attribute name.                               |
| `E-EXP-2501` | Error    | Expression type mismatch.                             |
| `E-EXP-2502` | Error    | `value` expression used where `place` required.       |
| `E-EXP-2511` | Error    | Identifier resolves to type/module in value context.  |
| `E-EXP-2531` | Error    | Invalid field/tuple access (not found or invisible).  |
| `E-EXP-2532` | Error    | Procedure call argument count mismatch.               |
| `E-EXP-2533` | Error    | Method call using `.` instead of `::`.                |
| `E-EXP-2535` | Error    | Invalid pipeline `=>` right-hand side.                |
| `E-EXP-2541` | Error    | Logical operator applied to non-bool.                 |
| `E-EXP-2542` | Error    | Invalid types for arithmetic/bitwise operator.        |
| `E-EXP-2545` | Error    | Address-of `&` applied to non-place.                  |
| `E-EXP-2561` | Error    | `if` without `else` in value context.                 |
| `E-EXP-2571` | Error    | Incompatible types in `match` arms.                   |
| `E-EXP-2582` | Error    | Mismatched types in `loop` `break` values.            |
| `E-EXP-2591` | Error    | Returning region-allocated value from `region` block. |
| `E-EXP-2592` | Error    | `parallel` result depends on invalidated binding.     |
| `E-STM-2631` | Error    | Assignment target is not a place.                     |
| `E-STM-2651` | Error    | `defer` block returns non-unit value.                 |
| `E-STM-2652` | Error    | Non-local control flow (return/break) in `defer`.     |
| `E-STM-2661` | Error    | `return` value type mismatch.                         |
| `E-STM-2662` | Error    | `break` used outside loop.                            |
| `E-STM-2663` | Error    | `continue` used outside loop.                         |
| `E-STM-2664` | Error    | `result` value mismatch with block type.              |
| `E-STM-2671` | Error    | `partition` proof verification failed.                |

#### B.3.6 PAT (Patterns) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.pat-patterns]

| Code         | Severity | Description                                    |
| :----------- | :------- | :--------------------------------------------- |
| `E-PAT-2711` | Error    | Refutable pattern used in irrefutable context. |
| `E-PAT-2741` | Error    | Non-exhaustive pattern match.                  |
| `E-PAT-2751` | Error    | Unreachable match arm.                         |

#### B.3.7 CON (Contracts & Concurrency) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.con-contracts-concurrency]

| Code         | Severity | Description                                                              |
| :----------- | :------- | :----------------------------------------------------------------------- |
| `E-CON-2801` | Error    | Static contract verification failed.                                     |
| `E-CON-2802` | Error    | Impure/Unsafe expression in contract.                                    |
| `E-CON-2803` | Error    | Liskov violation: Precondition strengthened.                             |
| `E-CON-2804` | Error    | Liskov violation: Postcondition weakened.                                |
| `E-CON-2805` | Error    | `@entry` applied to non-Copy/Clone type.                                 |
| `E-CON-2806` | Error    | `@result` used outside `will` clause.                                    |
| `E-CON-3201` | Error    | Thread Safety: Capturing `partitioned` binding in concurrency primitive. |
| `E-CON-3202` | Error    | Static Join violation: `JobHandle` not joined in `parallel`.             |
| `E-CON-3203` | Error    | Spawn capture violation (e.g. `unique` not moved).                       |

#### B.3.8 TRS (Traits) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.trs-traits]

| Code         | Severity | Description                                            |
| :----------- | :------- | :----------------------------------------------------- |
| `E-TRS-2901` | Error    | Abstract implementation incorrectly marked `override`. |
| `E-TRS-2902` | Error    | Concrete override missing `override` keyword.          |
| `E-TRS-2903` | Error    | Missing implementation for required trait procedure.   |
| `E-TRS-2910` | Error    | Accessing non-trait member on opaque type.             |
| `E-TRS-2920` | Error    | Explicit call to `Drop::drop`.                         |
| `E-TRS-2921` | Error    | Type implements both `Copy` and `Drop`.                |
| `E-TRS-2922` | Error    | `Copy` implementation on type with non-Copy fields.    |
| `E-TRS-2940` | Error    | Calling `where Self: Sized` procedure on witness.      |

#### B.3.9 MEM (Memory & Safety) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.mem-memory-safety]

| Code         | Severity | Description                                 |
| :----------- | :------- | :------------------------------------------ |
| `E-MEM-3001` | Error    | Use of moved value.                         |
| `E-MEM-3005` | Error    | Explicit call to destructor.                |
| `E-MEM-3010` | Error    | Static record partition conflict.           |
| `E-MEM-3012` | Error    | Partition contract proof failed.            |
| `E-MEM-3020` | Error    | Region pointer escape.                      |
| `E-MEM-3021` | Error    | Region allocation `^` outside region scope. |
| `E-MEM-3030` | Error    | Unsafe operation in safe code.              |
| `E-MEM-3031` | Error    | `transmute` size mismatch.                  |

#### B.3.10 FFI (Interoperability) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.ffi-interoperability]

| Code         | Severity | Description                                        |
| :----------- | :------- | :------------------------------------------------- |
| `E-FFI-3301` | Error    | Non-FFI-Safe type in `extern` signature.           |
| `E-FFI-3302` | Error    | Call to `extern` procedure outside `unsafe` block. |
| `E-FFI-3303` | Error    | Invalid application of `[[repr(C)]]`.              |
| `E-FFI-3304` | Error    | Variadic arguments not supported.                  |

#### B.3.11 MET (Metaprogramming) [appendix.diagnostic-code-taxonomy.normative-diagnostic-catalog.met-metaprogramming]

| Code         | Severity | Description                                       |
| :----------- | :------- | :------------------------------------------------ |
| `E-MET-3401` | Error    | `comptime` procedure called from runtime context. |
| `E-MET-3402` | Error    | Compile-time resource limit exceeded.             |
| `E-MET-3403` | Error    | Invalid identifier string in interpolation.       |
| `E-MET-3404` | Error    | Syntax error in `quote` block.                    |
| `E-MET-3405` | Error    | Emitted AST failed type checking.                 |
| `E-MET-3406` | Error    | `emit` called without capability.                 |

---

## Appendix C: Conformance Dossier Schema [appendix.conformance-dossier-schema]

This appendix defines the normative JSON Schema for the Conformance Dossier. A conforming implementation **MUST** produce a JSON artifact matching this schema when the `dossier` emission phase is active.

### C.1 File Format [appendix.conformance-dossier-schema.file-format]
The dossier **MUST** be a valid JSON document encoded in UTF-8.

### C.2 Schema Definition [appendix.conformance-dossier-schema.schema-definition]
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Cursive Conformance Dossier",
  "type": "object",
  "required": ["metadata", "configuration", "safety_report", "implementation_limits"],
  "properties": {
    
    "metadata": {
      "type": "object",
      "description": "Information about the compiler and build environment.",
      "required": ["compiler_id", "compiler_version", "target_triple", "build_timestamp"],
      "properties": {
        "compiler_id": { "type": "string", "example": "cursive-ref-impl" },
        "compiler_version": { "type": "string", "pattern": "^\\d+\\.\\d+\\.\\d+$" },
        "target_triple": { "type": "string", "example": "x86_64-unknown-linux-gnu" },
        "build_timestamp": { "type": "string", "format": "date-time" }
      }
    },

    "configuration": {
      "type": "object",
      "description": "The conformance mode and settings used for this compilation.",
      "required": ["mode", "features"],
      "properties": {
        "mode": { 
          "type": "string", 
          "enum": ["strict", "permissive"],
          "description": "Strict mode rejects unsafe blocks without attestation." 
        },
        "features": {
          "type": "array",
          "items": { "type": "string" },
          "description": "List of enabled language feature flags."
        }
      }
    },

    "safety_report": {
      "type": "object",
      "description": "Inventory of unsafe usage and attestations.",
      "required": ["unsafe_blocks_count", "attestations"],
      "properties": {
        "unsafe_blocks_count": { "type": "integer", "minimum": 0 },
        "attestations": {
          "type": "array",
          "description": "List of all attested unsafe blocks in the program closure.",
          "items": {
            "type": "object",
            "required": ["location", "mechanism", "auditor", "justification"],
            "properties": {
              "location": {
                "type": "object",
                "properties": {
                  "file": { "type": "string" },
                  "line": { "type": "integer" },
                  "module": { "type": "string" }
                }
              },
              "mechanism": { "type": "string", "example": "Manual Audit" },
              "auditor": { "type": "string" },
              "date": { "type": "string", "format": "date" },
              "justification": { "type": "string" },
              "proof_uri": { "type": "string", "format": "uri" }
            }
          }
        },
        "unattested_violations": {
          "type": "array",
          "description": "In Permissive mode, lists unsafe blocks missing attestation.",
          "items": {
            "type": "object",
            "properties": {
              "file": { "type": "string" },
              "line": { "type": "integer" }
            }
          }
        }
      }
    },

    "implementation_defined_behavior": {
      "type": "object",
      "description": "Documentation of IDB choices made by this implementation.",
      "required": ["type_layout", "pointer_width"],
      "properties": {
        "pointer_width": { "type": "integer", "enum": [32, 64] },
        "type_layout": {
          "type": "object",
          "additionalProperties": {
             "type": "object",
             "properties": {
               "size": { "type": "integer" },
               "alignment": { "type": "integer" }
             }
          },
          "description": "Layout map for primitive types (i32, usize, etc)."
        }
      }
    },
    
    "implementation_limits": {
      "type": "object",
      "description": "Actual limits enforced by this implementation.",
      "required": ["max_recursion_depth", "max_identifier_length"],
      "properties": {
        "max_recursion_depth": { "type": "integer" },
        "max_identifier_length": { "type": "integer" },
        "max_source_size": { "type": "integer" }
      }
    }
  }
}
```

---

## Appendix D: Standard Trait Catalog [appendix.standard-trait-catalog]

This appendix provides the normative definitions for foundational traits and system capability traits that are built into the Cursive language or its core library.

The definitions in this appendix are authoritative. Other chapters in this specification **MUST** reference these definitions for semantic rules regarding memory management (e.g., `Drop`, `Copy`) and external effects (e.g., `FileSystem`, `HeapAllocator`).

### D.1 Foundational Traits [appendix.standard-trait-catalog.foundational-traits]

These traits define fundamental semantic properties that are deeply integrated with the language's core mechanics, such as responsibility, memory management, and aliasing rules.

#### D.1.1 The `Drop` Trait [appendix.standard-trait-catalog.foundational-traits.the-drop-trait]

The `Drop` trait provides the mechanism for deterministic, compiler-managed cleanup (RAII) for a type when its responsible binding goes out of scope.

***Definition***

> **Drop Trait**
>
> The `Drop` trait **MUST** be defined as:
>
> ```cursive
> public trait Drop {
>    // The `~!` shorthand denotes `self: unique Self`.
>    // This signature makes it explicit that `drop` takes
>    // exclusive ownership to perform cleanup.
>    procedure drop(~!);
> }
> ```

> [!note]
> The `self` parameter in `Drop::drop` is a special case. It does not default to `const` permission. Instead, the compiler automatically provides temporary, exclusive (`unique`) access to `self` for the duration of the `drop` call, as specified in Constraint 3 of this section.

***Constraints and Semantics***

> **Drop Constraints**
>
> 1.  **Compiler Invocation Only:** The `Drop::drop` procedure **MUST NOT** be called directly by user code. It is invoked exclusively by the compiler.
>       * ***Diagnostic:*** An attempt to call `my_value.drop()` **MUST** trigger diagnostic `E-TRS-2920`: "The 'Drop::drop' procedure cannot be called directly."
> 2. **RAII Trigger:** The compiler MUST automatically invoke Drop::drop on a binding b if and only if both of the following conditions are met:
    a) b is a responsible binding.
    b) b is at the end of its lexical scope (e.g., block exit, return, or procedure end).
> **Drop Semantics**
>
> 3.  **Exclusive Access:** During the execution of `drop(self)`, the compiler **MUST** grant temporary, exclusive (`unique`) access to the `self` binding.
> 4. **Static Invalidation:** When Drop::drop is called on a responsible binding b (the "owner"), the compiler MUST perform Static Invalidation.
>   - This invalidation MUST apply to all partitioned aliases and Ptr references derived from b.
>   - Any subsequent use of these invalidated aliases MUST result in a compile-time error.
> 5. **Compiler Invocation Only:** The Drop::drop procedure MUST NOT be called directly by user code. It is invoked exclusively by the compiler.
>   - **Diagnostic:** An attempt to call my_value.drop() MUST trigger diagnostic E-TRS-2920: "The 'Drop::drop' procedure cannot be called directly."

#### D.1.2 The `Copy` Trait [appendix.standard-trait-catalog.foundational-traits.the-copy-trait]

The `Copy` trait is a marker trait that indicates a type's values can be safely and implicitly duplicated via a simple bitwise copy. Types that implement `Copy` are duplicated on assignment or parameter passing, rather than being moved.

***Definition***

> **Copy Trait**
>
> The `Copy` trait **MUST** be defined as a marker trait with no procedures:
>
> ```cursive
> public trait Copy {
>     // This trait is a marker and has no procedures.
> }
> ```

***Constraints and Semantics***

> **Copy Semantics**
>
> 1.  **Implicit Duplication:** If a type `T` implements `Copy`, operations that would normally *move* a value of type `T` (such as assignment or passing as a non-`move` parameter) **MUST** instead perform a bitwise copy, leaving the original binding valid.
> 2.  **Structural Requirement:** A composite type (like a `record` or `enum`) **MAY** implement `Copy` if and only if all of its constituent fields or variant payloads also implement `Copy`.
>       * ***Diagnostic:*** An attempt to implement `Copy` on a type containing non-`Copy` fields **MUST** trigger diagnostic `E-TRS-2922`: "Cannot implement 'Copy' on type 'TypeName' because field 'field\_name' does not implement 'Copy'."
> 3.  **Mutual Exclusion with `Drop`:** A type **MUST NOT** implement `Copy` if it also implements the `Drop` trait.
>       * ***Diagnostic:*** An attempt to implement `Copy` on a type that implements `Drop` (or vice-versa) **MUST** trigger diagnostic `E-TRS-2921`: "Cannot implement 'Copy' on type 'TypeName' because it also implements 'Drop'."
> 4.  **Primitive Types:** All primitive types (integers, floats, `bool`, `char`, `()`, and raw pointers `*imm T`/`*mut T`) **MUST** implicitly implement `Copy`.

#### D.1.3 The `Clone` Trait [appendix.standard-trait-catalog.foundational-traits.the-clone-trait]

The `Clone` trait provides a standardized, explicit mechanism for duplicating an object. This is distinct from `Copy` (which is implicit and bitwise) and is intended for user-defined "deep copy" semantics.

***Definition***

> **Clone Trait**
>
> The `Clone` trait **MUST** be defined as:
>
> ```cursive
> public trait Clone {
>     procedure clone(self: const): Self;
> }
> ```

***Constraints and Semantics***

> **Clone Semantics**
>
> 1.  **Explicit Duplication:** The `clone` method **MUST** be called explicitly (e.g., `let new_value = old_value.clone()`).
> 2.  **`Copy` Types:** Any type that implements `Copy` **SHOULD** also implement `Clone`, where the `clone` method's implementation is a simple bitwise copy.
> Owned Types: Types that manage owned resources (e.g., string@Managed, heap-allocated collections) SHOULD implement Clone to provide explicit deep-copy functionality.
>
>   - Because the Clone::clone procedure signature does not take a HeapAllocator capability, it MUST NOT perform new heap allocations. Types requiring allocation for a deep copy SHOULD provide a separate, explicit method (e.g., clone_with(self: const, heap: HeapAllocator): Self).

***Definition***

> **HeapAllocator Trait**
>
> The `HeapAllocator` trait **MUST** be defined as:
>
> ```cursive
> public trait HeapAllocator {
>     // Allocates memory for type T.
>     // On success, returns a valid pointer.
>     // On allocation failure (OOM), this procedure MUST panic.
>     procedure alloc<T>(self: const, layout: Layout): Ptr<T>@Valid;
>
>     // Deallocates the memory pointed to by ptr.
>     procedure free<T>(self: const, ptr: Ptr<T>@Valid);
>
>     // Returns an attenuated allocator limited to 'bytes'.
>     procedure with_quota(self: const, bytes: usize): witness HeapAllocator;
> }
> ```

***Semantics***
> **Allocation Semantics**
>
> 1.  **Allocation Failure:** The `alloc` procedure **MUST** succeed and return a `@Valid` pointer or terminate the thread (panic). It **MUST NOT** return a null pointer.
> 2.  **Alignment:** The returned pointer **MUST** be aligned to `alignof(T)`.
> 3.  **Zero-Initialization:** The memory returned by `alloc` is uninitialized. The caller is responsible for initialization.
> 4.  **Capability Integration:** Procedures that perform dynamic allocation (e.g., `string::from`, `Vec::push`) **MUST** accept a parameter implementing `HeapAllocator`.

#### D.2.4 The `Time` Trait [appendix.standard-trait-catalog.system-capability-traits.the-time-trait]

> **Time Trait**
>
> 1.  **Monotonicity:** The `now` procedure **MUST** return a monotonically increasing value.
> 2.  **Capability Integration:** The `Time` trait **MUST** be implemented by the `System` record.
> 3.  **Attenuation:** The `Time` trait **MUST** be attenuatable.
> 4.  **Implementation:** The `System` record **MUST** implement the `Time` trait.
> 
> ***Definition***
> ```cursive
> public trait Time {
>     procedure now(self: const): Timestamp;
> }
> ```

---

## Appendix E: Core Library Specification [appendix.core-library-specification]
*   Minimal definitions for `string`, `u8`, `bool`, `Option`, `Result`.
*   Definition of `Context` root capability record.

---

## Appendix F: Implementation Limits [appendix.implementation-limits]
*   Table of minimum requirements vs. recommended limits (e.g., "Max identifier length: 1023 (Required), Unlimited (Recommended)").

---

## Appendix G: Implementation Guide (Informative) [appendix.implementation-guide-informative]

This appendix provides non-normative guidance for compiler authors implementing the Cursive specification.

### G.1 Control Flow Graph (CFG) for Verification [appendix.implementation-guide-informative.g.1-control-flow-graph-cfg-for-verification]

When implementing the Fact Injection logic for §27.7 and §29.4:

* **Dominator Trees:** Use a standard Lengauer-Tarjan algorithm to build the dominator tree. Verification facts are valid only if their origin node strictly dominates the consumption node.  
* **Loop Headers:** Synthesize "entry facts" for loop induction variables at the loop header node. For loop i in 0..N, inject i >= 0 and i < N as facts dominating the loop body.

### G.2 Niche Optimization for Modal Types [appendix.implementation-guide-informative.g.2-niche-optimization-for-modal-types]

Implementations are strongly encouraged to use "Niche Optimization" to reduce the size of modal types.

* **Example:** Ptr<T>  
  * @Null state is represented by address 0x0.  
  * @Valid state is represented by non-zero addresses.  
  * **Optimization:** The modal Ptr<T> (the general sum type) should occupy 64 bits, not 128 bits. The discriminant is implicit: if the bits are 0, it is @Null; otherwise, it is @Valid.  
* **General Algorithm:** If a state's payload has invalid bit-patterns (niches), those patterns can be used to encode other empty states.

### G.3 Canonical Formatting [appendix.implementation-guide-informative.canonical-formatting]

To satisfy the syntactic stability goals (§3.3), implementations should provide a formatter that adheres to:

* **Indent:** 4 spaces.  
* **Brace Style:** 1TBS (One True Brace Style) - opening brace on the same line.  
* **Ordering:** Imports sorted alphabetically; declarations sorted public then internal then private.

## Appendix H: Behavior Classification Index (Normative) [appendix.behavior-classification-index-normative]

This appendix catalogues all explicit behaviors defined in this specification that fall outside "safe, deterministic execution."

### H.1 Unverifiable Behavior (UVB) [appendix.behavior-classification-index-normative.unverifiable-behavior-uvb]

The following operations are **UVB**. They MUST occur within an unsafe block, and their correctness is the sole responsibility of the programmer.

| Operation              | Section | Description                                      |
| :--------------------- | :------ | :----------------------------------------------- |
| **FFI Call**           | §32.2   | Calling any imported extern procedure.           |
| **Raw Deref**          | §29.6.2 | Dereferencing a *imm T or *mut T pointer.        |
| **Transmute**          | §29.6.3 | Reinterpreting bits via transmute::\<?, ?>.      |
| **Pointer Arithmetic** | §24.4.2 | Using + or - on raw pointers.                    |
| **Trusted Contracts**  | §27.6.3 | Violating a contract marked [[verify(trusted)]]. |

### H.2 Implementation-Defined Behavior (IDB) [appendix.behavior-classification-index-normative.implementation-defined-behavior-idb]

The following behaviors vary by implementation but MUST be documented in the Conformance Dossier.

| Feature              | Section | Description                                                        |
| :------------------- | :------ | :----------------------------------------------------------------- |
| **Type Layout**      | §15.4   | Exact size/alignment of types without [[repr(C)]].                 |
| **Integer Overflow** | §17.1   | Behavior of +, -, * on overflow (wrap vs panic) in release builds. |
| **Pointer Width**    | §17.1   | Bit-width of usize, isize, and pointers.                           |
| **Resource Limits**  | §6.5    | Max recursion depth, max source file size.                         |
| **Panic Abort**      | §32.5.2 | Exact mechanism of process abort during FFI unwind.                |

### H.3 Unspecified Behavior (USB) [appendix.behavior-classification-index-normative.unspecified-behavior-usb]

The following behaviors are bounded but not documented.

| Feature           | Section | Description                                                   |
| :---------------- | :------ | :------------------------------------------------------------ |
| **Map Iteration** | N/A     | Order of iteration for hash-based collections in the std lib. |
| **Padding Bytes** | §15.4   | The values of padding bytes in non-repr(C) records.           |

---

## Appendix I: Formal Core Semantics (Normative) [appendix.formal-core-semantics-normative]

This appendix defines the **Cursive Core Calculus**, a simplified formal model of the language's memory and permission system. Implementations **MUST** preserve the safety properties defined here.

### I.1 Syntax of the Core [appendix.formal-core-semantics-normative.syntax-of-the-core]

$$\begin{aligned} v &::= \ell \mid \text{const } \ell \mid \text{null} \\ e &::= v \mid \text{let } x = e \text{ in } e \mid x \mid x.f \mid x.f \leftarrow v \mid \text{fork}(e) \\ \tau &::= \text{const } T \mid \text{unique } T \mid \text{partitioned } T \end{aligned}$$

### I.2 Operational Semantics (Small-Step) [appendix.formal-core-semantics-normative.operational-semantics-small-step]

State is defined as a pair $(H, e)$ where $H$ is the heap mapping locations $\ell$ to values.

**Read Rule:**

$$\frac{H(\ell) = v}{(H, \ell.f) \longrightarrow (H, v.f)}$$  
**Write Rule (Unique):**

$$\frac{H(\ell) \text{ is live}}{(H, \ell.f \leftarrow v') \longrightarrow (H[\ell.f \mapsto v'], ())}$$

### I.3 Safety Theorems [appendix.formal-core-semantics-normative.safety-theorems]

#### Theorem 1: Progress [appendix.formal-core-semantics-normative.safety-theorems.theorem-1-progress]
If $\vdash e : \tau$ and $e$ is not a value, then there exists a state $(H', e')$ such that $(H, e) \longrightarrow (H', e')$.  
Implication: A well-typed Cursive program never gets "stuck" (segfaults or undefined behavior).

#### Theorem 2: Preservation (Type Safety) [appendix.formal-core-semantics-normative.safety-theorems.theorem-2-preservation-type-safety]
If $\vdash e : \tau$ and $(H, e) \longrightarrow (H', e')$, then $\vdash e' : \tau$.  
Implication: Operations never violate the permission rules defined in Part 4\.  

#### Theorem 3: Data Race Freedom [appendix.formal-core-semantics-normative.safety-theorems.theorem-3-data-race-freedom]
If $\Gamma \vdash e : \text{well-formed}$, and $e$ contains fork, no two threads can access location $\ell$ simultaneously unless both accesses are Reads.  
_Proof Sketch:_ The unique permission ($\ell$) cannot be duplicated. The const permission ($\text{const } \ell$) allows duplication but removes the Write Rule from the set of valid reductions for that value.