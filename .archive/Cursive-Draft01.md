# Cursive Language Specification

## Clause 1 — Introduction and Conformance

**Part**: I — Introduction and Conformance
**File**: 01-0_Scope.md  
**Section**: §1.1 Scope  
**Stable label**: [intro.scope]  
**Forward references**: §2.1–§2.5 [lex.source]–[lex.units], Clauses 3–9, §10–§13, §15.6 [interop.abi], Annex B.2 [behavior.undefined]

---

### §1.1 Scope [intro.scope]

[1] This clause establishes the boundaries of the Cursive language specification, defines the actors it serves, and identifies complementary material external to the core standard. The scope applies to all implementations that claim adherence to Cursive version 1.0 and later compatible editions.

[2] The specification governs every program element required to compile and execute portable, deterministic Cursive code. The governed areas are:

- lexical structure and translation phases (§2.1–§2.5 [lex.source]–[lex.units]);
- foundational concepts: objects, values, storage duration, alignment, and name binding categories (specified in their authoritative clauses);
- modules, declarations, names and scopes, types, and expressions (Clauses 3–7);
- statements and control flow (Clause 8);
- the generics, permission, contract, and witness systems that ensure memory safety and semantic guarantees (Clauses 9–12);
- concurrency, interoperability, and compile-time evaluation (Clauses 13–15).

[3] The specification intentionally excludes topics whose evolution is decoupled from language conformance. Excluded topics include:

- the normative standard library catalogue (moved to separate documentation);
- platform-specific ABI and calling convention details left to implementation policy (§14.6 [interop.abi]);
- concurrency libraries beyond the surface guarantees described in §13.1 [concurrency.model];
- tooling, build systems, or project layout conventions (informative guidance may appear in companion documents).

[4] Certain behaviors are implementation-defined but remain within the specification's boundary. Conforming implementations shall document at least integer and floating-point representations, pointer and region sizes, alignment rules, diagnostic formatting, and resource ceilings consistent with §1.5.4 [intro.conformance.impldef].

[5] Undefined behavior is catalogued centrally in Annex B.2 [behavior.undefined]. Any construct not explicitly marked as undefined shall be diagnosed or defined. Implementers shall ensure that undefined entries referenced in later clauses map back to the Annex catalogue.

[6] The language's foundational concepts—objects (§10.2 [memory.object]), types (Clause 6 [type]), scopes (§5.2 [name.scope]), and storage duration (§10.2.3 [memory.object.storage])—are specified directly in their authoritative clauses. Each clause provides complete semantics without requiring external context beyond the common notation established in §1.4.

#### §1.1.1 Intended Audiences [intro.scope.audience]

[7] Implementers require a precise definition of syntax, typing, evaluation, and diagnostic obligations. Paragraphs marked **Normative** in Clauses 2–15 and Annexes A–B constitute their primary reference set.

[8] Tool developers (formatters, linters, debuggers, analysers) depend on the grammar (Annex A [grammar]), semantic judgments (§1.4 [intro.notation]), and diagnostic contracts (§1.5 [intro.conformance]).

[9] Language designers and researchers rely on the formal notation, meta-theory, and rationale supplied throughout Clause 1 and Annex C [formal].

[10] Programmers seeking educational material should use the informative Programming Guide; Clause 1 provides orientation but does not substitute for tutorials.

#### §1.1.2 Forward References [intro.scope.forward]

[11] Clause 1 references later material only when necessary to state the conformance boundary. Every forward reference is identified explicitly so that implementers can trace dependencies. Circular references are avoided by delegating operational detail to the destination clause.


### §1.2 Normative References [intro.refs]

[1] The documents listed here contain provisions that, through citation, become requirements of the Cursive specification. Where a document is identified as normative, conforming implementations shall obey the referenced clauses exactly.

[2] When a referenced standard is revised, the most recent edition applies provided it remains backward compatible with the requirements stated in this specification. Implementations shall document which revision they use when a choice exists.

#### §1.2.1 ISO/IEC and ECMA Standards [intro.refs.iso]

[3] **ISO/IEC Directives, Part 2: Principles and rules for the structure and drafting of ISO and IEC documents (2021).** Establishes the normative vocabulary (`shall`, `should`, `may`, `can`) and organisational conventions adopted in §1.5 [intro.conformance].

[4] **ISO/IEC 10646:2020 — Information technology — Universal Coded Character Set (UCS).** Defines the character repertoire permitted in source text (§2.1 [lex.source]) and informs identifier classifications (§2.3 [lex.tokens]).

[5] **ISO/IEC 60559:2020 (IEEE 754-2019) — Floating-Point Arithmetic.** Governs semantics for binary32 and binary64 arithmetic used throughout the numeric type definitions (§7.2 [type.primitive]) and runtime semantics (§8.3 [expr.operator]).

[6] **ISO/IEC 9899:2018 — Programming Languages — C.** The foreign-function interface (§15.1 [interop.ffi]) relies on C definitions of object representation, calling conventions, and variadic semantics.

[7] **ECMA-334 — C# Language Specification (current edition).** Cited solely for the cross-reference and documentation practices mirrored in §1.6 [intro.document].

#### §1.2.2 Unicode and IETF Publications [intro.refs.unicode]

[8] **The Unicode Standard, Version 15.0.0 or later.** Supplies derived properties, normalization forms, and identifier recommendations leveraged by the lexical grammar and diagnostics (§2.1 [lex.source], Annex A.2 [grammar.lexical]).

[9] **Unicode Standard Annex #31 — Unicode Identifier and Pattern Syntax.** Specifies identifier composition rules adopted verbatim in §2.3 [lex.tokens].

[10] **Unicode Standard Annex #29 — Unicode Text Segmentation** and **UAX #44 — Unicode Character Database.** Provide segmentation and property metadata for tokenisation and editor guidance; they apply where §2.2 [lex.phases] references grapheme boundaries.

[11] **RFC 2119** and **RFC 8174** — Key words for use in RFCs. While Clause 1 follows ISO terminology, these RFCs define equivalent terminology for readers familiar with IETF documents and are referenced in §1.5.2 [intro.conformance.keywords].

#### §1.2.3 Platform and ABI References [intro.refs.abi]

[12] **System V Application Binary Interface** (generic and architecture supplements including AMD64 psABI and ARM AAPCS). These documents guide interoperability obligations in §15.6 [interop.abi] and Annex G [portability].

[13] **Microsoft x64 Calling Convention** documentation. Required for conforming implementations targeting Windows platforms; referenced alongside other ABI requirements in §15.6 [interop.abi].

#### §1.2.4 Availability and Access [intro.refs.access]

[14] ISO/IEC and IEEE publications typically require purchase; implementers shall secure legitimate access before claiming conformance. Unicode and IETF materials are freely available online and shall be consulted in their latest release form.

[15] Annex G.1 [portability.platform] summarises how to reconcile conflicts when platform-specific guidance diverges from these normative sources.


### §1.3 Terms and Definitions [intro.terms]

[1] The vocabulary below is normative. When a term is defined in this clause it shall carry the same meaning throughout Clauses 2–16 and the annexes. Paragraph numbering resets within each subclause per the organizational template described in §1.6 [intro.document].

#### §1.3.1 General Language Terms [intro.terms.general]

[2] **binding** — the association between an identifier and an entity within a particular scope.

[3] **compilation unit** — the smallest source artifact processed as a whole during translation (§2.5 [lex.units]).

[4] **conforming implementation** — any compiler, interpreter, or analysis tool that meets the requirements of §1.5.3 [intro.conformance.impl] and documents its implementation-defined behavior.

[5] **conforming program** — a program that satisfies the grammar, static semantics, and behavioral requirements outlined in §1.5.4 [intro.conformance.program]; conforming programs shall not rely on undefined behavior.

[6] **declaration** — a syntactic form that introduces a name and determines its category (§5 [decl]).

[7] **diagnostic** — a message issued when a program violates a rule that requires detection (§1.5.5 [intro.conformance.diagnostics]). Diagnostics include errors (rejecting) and warnings (permissive).

[8] **entity** — any value, type, module, predicate, contract, region, or grant that may be named or referenced (Clause 6 [name]).

[9] **expression** — a syntactic form that yields a value or place (§8 [expr]).

[10] **statement** — a syntactic form that executes for effects on program state without directly yielding a value (§9 [stmt]).

[11] **scope** — the syntactic region where a binding is visible (§6.2 [name.scope]).

#### §1.3.2 Cursive-Specific Concepts [intro.terms.language]

[12] **binding responsibility mode** — the axis that distinguishes responsible (`=`) and non-responsible (`<-`) initialisation for `let`/`var` bindings (§5.2 [decl.variable]).

[13] **permission** — a capability (`const`, `shared`, `unique`) describing how a value may be accessed (§11.4 [memory.permission]).

[14] **grant** — a token representing authority to perform a capability such as file I/O (§12.3 [contract.grant]).

[15] **grant set** — the finite set of grants required or produced by an expression, preserved throughout typing (§8.8 [expr.typing]).

[16] **sequent** — a formal specification of procedure requirements and guarantees, using the form `[[ grants |- must => will ]]` where `grants` lists capability requirements, `must` lists preconditions, and `will` lists postconditions. Also called "procedure sequent" for clarity (§12.2 [contract.sequent]). The semantic brackets `⟦ ⟧` (Unicode U+27E6, U+27E7) or their ASCII equivalent `[[ ]]` denote formal specification content, consistent with their use for type value sets throughout this specification. The turnstile `⊢` or its ASCII equivalent `|-` separates the grants component from the logical implications.

[17] **grant component** — the portion of a sequent before the turnstile (`|-`), listing zero or more grant identifiers (capability tokens) that must be available for the procedure to execute.

[18] **contract** — a user-defined abstract interface declaration that specifies required procedure signatures and associated types (§12.1 [contract.overview]). Contracts are distinct from sequents: contracts define abstract interfaces, while sequents specify procedure requirements and guarantees.

[19] **behavior** — a collection of callable signatures with concrete implementations that types may attach to gain functionality (§10.4 [generic.behavior]). Behaviors provide reusable code and differ from contracts (which specify abstract requirements) by providing procedure bodies. The term "behavior" is distinct from "predicate expression," which refers to boolean-valued expressions used in sequent clauses.

[20] **predicate expression** — a boolean-valued expression used in sequent clauses (`must`, `will`, `where`) to express logical constraints and conditions.

[21] **modal type** — a type whose values transition through named states validated at compile time (§7.6 [type.modal]).

[22] **witness** — runtime evidence that a contract or behavior obligation has been satisfied, or that a modal value is in a specific state (§13.2 [witness.kind]). Witnesses enable dynamic polymorphism through dense pointer representation with vtable-based dispatch.

[23] **region** — a lexically-scoped allocation arena released in strict LIFO order (§11.3 [memory.region]).

[24] **unsafe block** — an explicit region where the programmer assumes responsibility for safety constraints while interacting with raw operations (§11.8 [memory.unsafe]).

[25] **hole** — a placeholder for an inferred type, permission, or grant inserted by programmers or tools. Type inference and hole resolution are specified in §8.8 [expr.typing].

[26] **principal type** — in a type inference context, the most general type that satisfies all constraints. When type inference succeeds, the principal type is unique and is a supertype of all other valid types for the expression. Bidirectional type checking (§8.1.6) produces principal types for expressions at inference sites.

#### §1.3.3 Behavioral Classifications [intro.terms.behaviour]

[27] **implementation-defined behavior** — behavior where the specification provides a set of allowed outcomes and requires documentation (§1.5.4 [intro.conformance.impldef]).

[28] **unspecified behavior** — behavior for which multiple outcomes are permitted without documentation, yet each outcome is well-defined (§1.5.6 [intro.conformance.unspecified]).

[29] **undefined behavior (UB)** — behavior for which the specification imposes no requirements; UB entries are enumerated in Annex B.2 [behavior.undefined].

[30] **ill-formed program** — a program that violates a static semantic rule requiring diagnosis (§1.5.5 [intro.conformance.diagnostics]).

[31] **ill-formed, no diagnostic required (IFNDR)** — rare violations that implementations are not obligated to detect (§1.5.5 [intro.conformance.ifndr]).

#### §1.3.4 Symbols and Abbreviations [intro.terms.abbrev]

[32] **ABI** — Application Binary Interface.

[33] **AST** — Abstract Syntax Tree.

[34] **EBNF** — Extended Backus–Naur Form.

[35] **FFI** — Foreign Function Interface.

[36] **IFNDR** — Ill-Formed, No Diagnostic Required.

[37] **LPS** — Lexical Permission System.

[38] **RAII** — Resource Acquisition Is Initialisation.

[39] **UB** — Undefined Behavior.

[40] **UTF-8** — Unicode Transformation Format, 8-bit.

[41] Numerical and symbolic notations used in inference rules are catalogued in §1.4.3 [intro.notation.math].


### §1.4 Notation and Conventions [intro.notation]

[1] This subclause formalises the notational systems used throughout the specification. All mathematical and formal notation is written in LaTeX, using inline `$…$` or display `\[ … \]`/`$$ … $$` delimiters.

#### §1.4.1 Grammar Presentation [intro.notation.grammar]

[2] Grammar fragments appear in fenced code blocks using the `ebnf` fence. Productions follow Extended Backus–Naur Form with terminals enclosed in single quotes and non-terminals expressed in `snake_case`.

[3] The following meta-symbols are used:

- `::=` definition;
- `|` alternative;
- `*`, `+`, `?` zero-or-more, one-or-more, and optional;
- parentheses for grouping; brackets for character classes.

[4] Annex A [grammar] consolidates the authoritative grammar. When a section presents a local excerpt, it shall remain textually consistent with the Annex. Throughout this specification, in-text grammar fragments are informative excerpts provided for convenience; Annex A contains the normative productions that implementations shall follow. Specific Annex A section references are provided where the in-text grammar significantly differs from or extends the Annex.

**Example 1.4.1.1** (EBNF notation):

```ebnf
variable_declaration
    ::= binding_head identifier type_annotation? '=' expression

binding_head
    ::= 'let'
     | 'var'
     | 'shadow' 'let'
     | 'shadow' 'var'
```

This example demonstrates the standard EBNF notation used throughout the specification: non-terminals in `snake_case`, terminals in single quotes, `::=` for definition, `|` for alternatives, and `?` for optional elements.

#### §1.4.2 Metavariables [intro.notation.meta]

[5] Metavariables denote ranges of syntactic or semantic entities. The canonical sets are:

- $x, y, z$ for variables and identifiers;
- $T, U, V$ (or $\tau$) for types;
- $e, f, g$ for expressions;
- $p$ for patterns;
- $s$ for statements;
- $\Gamma, \Sigma, \Delta$ for contexts (type, state, region respectively);
- $G$ for grant sets;
- $@S$ for modal states.

[6] Context operations use conventional notation: $\Gamma, x : T$ extends a context; $\Gamma[x \mapsto T]$ updates a binding; $\sigma[\ell \mapsto v]$ updates a store.

#### §1.4.3 Mathematical Notation [intro.notation.math]

[7] Set membership ($\in$, $\notin$), unions ($\cup$), intersections ($\cap$), and subset relations ($\subseteq$) follow standard mathematical meaning. Logical connectives ($\land$, $\lor$, $\lnot$, $\Rightarrow$, $\Leftrightarrow$) and quantifiers ($\forall$, $\exists$) are also used without further embellishment.

[8] **Evaluation judgments** use big-step operational semantics as the primary notation:

$$
\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle
$$

This judgment states: "Expression $e$ evaluated in store $\sigma$ reduces to value $v$ with resulting store $\sigma'$."

**Store notation conventions:**
- $\sigma$ — Current program store (maps locations to values)
- $\sigma'$ — Resulting store after evaluation (by convention, prime indicates "after")
- $\sigma_{\text{ct}}$ — Compile-time evaluation store (for comptime contexts)
- $\sigma_{\text{entry}}$, $\sigma_{\text{exit}}$ — Temporal stores (procedure entry/exit)
- $\sigma[x \mapsto v]$ — Store $\sigma$ updated with binding $x$ mapped to value $v$

**Evaluation contexts:**
- $\Downarrow$ — Big-step evaluation (expression to value in one step)
- $\Downarrow_{\text{comptime}}$ — Compile-time evaluation (for comptime blocks)
- $\to$ — Small-step reduction (rarely used; expression to expression)

[8.1] **Notation policy**: This specification uses big-step semantics as the primary evaluation model. Small-step is defined for completeness but not used extensively. All evaluation rules should use the big-step form with consistent store threading.

#### §1.4.4 Inference Rules [intro.notation.rules]

[9] Inference rules adopt the standard fraction layout rendered in LaTeX as

$$
\frac{\text{premise}_1 \quad \cdots \quad \text{premise}_n}{\text{conclusion}}\tag{\text{Rule-Name}}
$$

[10] Rules without premises are axioms. Precondition boxes (`[ Given: … ]`) precede rules when necessary to state environmental requirements. Immediately following each rule, prose shall explain the rule's effect in plain language.

[11] **Formal rule naming convention.** Rule tags shall follow a consistent prefix scheme to indicate their semantic category:

- **T-Feature-Case**: Type formation and typing rules (e.g., T-If, T-Bool-True)
- **E-Feature-Case**: Evaluation and operational semantics rules
- **WF-Feature-Case**: Well-formedness and static checking rules (e.g., WF-Modal-Type, WF-Import)
- **P-Feature-Case**: Permission and memory safety rules

Additional prefixes used for specialized semantic categories:

- **Prop-Feature-Case**: Behavior satisfaction and property proofs (e.g., Prop-Int-Copy proves integers satisfy Copy behavior)
- **Coerce-Feature-Case**: Type coercion rules (e.g., Coerce-Never for never-type coercions)
- **Prov-Feature-Case**: Provenance and aliasing rules (e.g., Prov-Addr for address provenance)
- **Ptr-Feature-Case**: Pointer-specific properties and constraints (e.g., Ptr-Size)
- **QR-Feature-Case**: Qualified name resolution rules (e.g., QR-Resolve)

The prefix indicates the judgment form or semantic domain; Feature identifies the language construct; Case distinguishes variants when multiple rules apply to the same construct.

**Example 1.4.4.1** (Inference rule format):

[ Given: $\Gamma$ is a well-formed type environment ]

$$
\frac{\Gamma \vdash e_1 : \text{bool} \quad \Gamma \vdash e_2 : T \quad \Gamma \vdash e_3 : T}{\Gamma \vdash \texttt{if}\ e_1\ \texttt{then}\ e_2\ \texttt{else}\ e_3 : T}
\tag{T-If}
$$

This rule states that an if-expression has type $T$ when the condition has type `bool` and both branches have the same type $T$. The precondition box establishes that $\Gamma$ must be well-formed. The tag `T-If` identifies this as a typing rule for the if-expression.

#### §1.4.5 Typography and Examples [intro.notation.style]

[11] Normative requirements use **bold** emphasis. Newly introduced defined terms appear in _italics_ on first use within a subclause. Language tokens, identifiers, and keywords use `monospace` formatting.

[12] Examples are fenced with the `cursive` info string. Valid and invalid examples may include inline markers `// correct` and `// incorrect` purely for informative purposes. Unless otherwise stated, examples are informative.

[13] Notes, warnings, and rationale blocks follow the bracketed ISO style:

```
[ Note: … — end note ]
[ Warning: … — end warning ]
[ Rationale: … — end rationale ]
```

**Example 1.4.5.1** (ISO bracketed formats):

[ Note: This is informative commentary that clarifies normative requirements without imposing additional constraints. Notes may include implementation guidance or rationale for design decisions.
— end note ]

[ Warning: Violating this constraint results in undefined behavior [UB-ID: B.2.15]. Implementations are not required to diagnose this condition.
— end warning ]

[ Rationale: This design choice ensures type safety while maintaining zero-cost abstraction. Alternative approaches were considered but rejected due to runtime overhead concerns.
— end rationale ]

These three formats distinguish informative notes, safety-critical warnings referencing the undefined behavior catalog (Annex B §B.2), and design rationale respectively.

#### §1.4.6 Cross-References [intro.notation.refs]

[14] In prose, cross-references use the pattern `§X.Y[label]`. Within Clause 1 the stable labels defined in §1.6 [intro.document] apply. Digital versions shall hyperlink every cross-reference.


### §1.5 Conformance [intro.conformance]

[1] This subclause defines what it means to conform to the Cursive specification. Conformance applies both to implementations and to programs.

#### §1.5.1 Normative Vocabulary [intro.conformance.keywords]

[2] The keywords **shall** and **shall not** express absolute requirements and prohibitions. **Should** and **should not** express strong recommendations; implementations may deviate provided the deviation is documented and justified. **May** and **may not** describe permissions. **Can** and **cannot** describe capability, and are informative. These meanings follow ISO/IEC Directives, Part 2 and mirror RFC 2119 terminology.

[3] When a paragraph is marked Informative it contains guidance, examples, or rationale that does not impose requirements. Notes, warnings, and rationale blocks are informative by default.

#### §1.5.2 Conforming Implementations [intro.conformance.impl]

[4] An implementation conforms if and only if it satisfies all of the following conditions:

- **Acceptance**: It shall accept every program that satisfies the rules of §1.5.4 [intro.conformance.program].
- **Rejection**: It shall issue a diagnostic for any ill-formed program (§1.5.5 [intro.conformance.diagnostics]).
- **Semantics**: It shall implement the runtime behavior described in Clauses 2–16 for well-formed programs that avoid undefined behavior.
- **Documentation**: It shall document every implementation-defined behavior identified in §1.5.3 [intro.conformance.impldef].
- **Extension safety**: Extensions shall not alter the meaning of conforming programs nor mask diagnostics that the base language would require.

[5] Conforming implementations may provide additional tools, optimisations, and analyses. Such features shall be disableable when they would otherwise change language semantics.

#### §1.5.3 Implementation-Defined Behavior [intro.conformance.impldef]

[6] Implementation-defined behavior occurs when this specification allows multiple outcomes but requires that an implementation choose one deterministically and document it. The following categories are implementation-defined:

- Numeric representation widths beyond mandated minima (§11.6 [memory.layout]);
- Pointer and region size, alignment, and layout details (§11.6 [memory.layout]);
- Resource ceilings such as maximum recursion depth or compilation unit size;
- Diagnostic formatting and display conventions (§1.5.5 [intro.conformance.diagnostics]);
- ABI choices for each supported platform (§15.6 [interop.abi]).

[7] Implementations shall publish these choices in user-facing documentation and apply them consistently.

#### §1.5.4 Conforming Programs [intro.conformance.program]

[8] A program is conforming when it:

- Satisfies the grammar of Annex A and the static semantics of Clauses 2–12;
- Abides by all contract, grant, permission, and modal requirements (§12–§14);
- Avoids undefined behaviour as catalogued in Annex B.2;
- Respects implementation-defined limits documented by the chosen implementation;
- Indicates the language edition it targets when required by the build manifest (§1.7 [intro.versioning]).

[9] Conforming programs may rely on unspecified behaviour, but shall not assume a particular outcome when the specification leaves choices open.

#### §1.5.5 Diagnostics and IFNDR [intro.conformance.diagnostics]

[10] A program that violates a static semantic rule is _ill-formed_ and shall provoke a diagnostic. Diagnostics shall include at minimum an error code, source location, and a brief description of the violation.

[11] Some violations are classified _ill-formed, no diagnostic required_ (IFNDR). These cases are documented explicitly at the point of definition; implementations are encouraged, but not required, to diagnose them. IFNDR is reserved for situations that are impractical to detect statically, such as exceeding translation limits that are only observable post-link.

[12] Diagnostic presentation style is implementation-defined, yet tools should strive for clarity and actionable guidance. Informative advice, suggested fixes, and machine-readable output formats are quality-of-implementation features, not conformance requirements.

#### §1.5.6 Behavioural Classifications [intro.conformance.unspecified]

[13] **Unspecified behaviour** permits multiple well-defined outcomes without documentation. **Undefined behaviour** confers no guarantees; once triggered, any result is permitted, and the program ceases to be conforming. Undefined behaviour sites are labelled `[UB: B.2 #N]` and mapped to Annex B.2 [behavior.undefined].

[14] Distinguishing these categories enables implementers to provide stronger diagnostics and enables programmers to reason about portability.


### §1.6 Document Conventions [intro.document]

[1] This subclause prescribes the structural conventions used throughout the specification: stable labels, cross-references, example formatting, and validation expectations. Digital and print editions shall follow the same logical structure.

#### §1.6.1 Stable Labels [intro.document.labels]

[2] Each clause and subclause carries a stable label of the form `[clause.topic[.subtopic]]`. Clause 1 uses the following labels:

- `[intro.scope]`, `[intro.refs]`, `[intro.terms]`, `[intro.notation]`, `[intro.conformance]`, `[intro.document]`, `[intro.versioning]`.
- Subclauses append descriptive suffixes, e.g. `[intro.document.labels]` or `[intro.conformance.impl]`.

[3] Later clauses follow the same style: clause prefix (e.g., `lex`, `decl`, `memory`) plus a concise topic. Labels are unique and stable across editions. When content moves, the label moves with it to preserve hyperlinks.

#### §1.6.2 Cross-Reference Format [intro.document.references]

[4] Cross-references shall use the format `§X.Y[label]`. For example, “§5.2 [decl.variable]” references the variable binding rules in Clause 5. Within the same clause the leading clause number may be omitted when unambiguous (`§1.5 [intro.conformance]`).

[5] Digital publications shall hyperlink the rendered text to the referenced section. PDF editions should provide bidirectional navigation where feasible.

[6] Forward references are permitted when necessary to inform the reader about required prerequisites. Authors shall explicitly mark the forward reference (e.g., “Forward reference: §12.4 [memory.permission]”). Cycles should be avoided; when unavoidable they must be documented in both target sections.

#### §1.6.3 Validation Requirements [intro.document.validation]

[7] Prior to publication, editors shall verify that every label resolves to an existing target and that no dangling references remain. Automated tooling should generate:

- an outbound reference table listing, for each section, the labels it references;
- an inbound reference table to identify orphans (sections with no references);
- a report for unresolved labels or malformed cross-references.

[8] Failing references shall block publication. Errata releases may fix discovered issues; patch releases (e.g., 1.0.1) shall include updated validation artefacts.

#### §1.6.4 Examples and Annotations [intro.document.examples]

[9] Examples are informative unless clearly marked otherwise. Code examples use the `cursive` fence. Diagnostics may annotate expected errors using comments (`// ERROR E4001: …`). When examples demonstrate invalid code the surrounding prose shall identify the normative rule being violated.

[10] Notes and warnings employ the bracketed ISO format described in §1.4.5 [intro.notation.style]. Informative commentary shall never contradict normative rules.

#### §1.6.5 Document Metadata [intro.document.metadata]

[11] Each file includes navigation metadata (**Previous**, **Next**) to aid editors working in split files. These links are informative; they shall mirror the logical order determined by Clause 1 but impose no additional requirements on implementations.

[12] Version history entries belong in dedicated change logs (Annex H [changes]). Individual clause files should reference the change log instead of embedding historical commentary.

#### §1.6.6 Diagnostic Code Format [intro.document.diagnostics]

[13] All diagnostic codes in this specification shall use the canonical format `E[CC]-[NNN]`, where:

- `E` denotes an error diagnostic;
- `[CC]` is a two-digit clause number with leading zero (01, 02, ..., 16);
- `-` is a hyphen separator for visual clarity;
- `[NNN]` is a three-digit sequential number with leading zeros (001, 002, ..., 999).

**Example**: `E02-001` indicates the first diagnostic in Clause 02 (Lexical Structure and Translation).

[14] Each clause allocates sequential diagnostic codes starting from 001. Within a clause, diagnostic codes should be allocated by subsection to facilitate maintenance and avoid conflicts. For instance, Clause 07 (Type System) may reserve:

- `E07-001` through `E07-099` for §7.1 (Type foundations);
- `E07-100` through `E07-299` for §7.2 (Primitive types);
- `E07-300` through `E07-499` for §7.3 (Composite types);
- and so forth.

[15] Implementations shall report diagnostic codes using this exact format in compiler output, error messages, and diagnostic payloads. Diagnostic payloads shall follow structured schemas defined in Annex E §E.5.3 [implementation.diagnostics.payloads].

[16] Reserved ranges within a clause may be documented to accommodate future expansion of specific subsections without renumbering existing diagnostics. Implementations should not define diagnostic codes outside the ranges specified by this document.

[17] Annex E §E.5 [implementation.diagnostics] provides the authoritative diagnostic code registry, including:

- Complete enumeration of all diagnostic codes across all clauses;
- Structured payload schemas for machine-readable diagnostic output;
- Suggested diagnostic message templates and quality guidelines;
- Severity levels (error, warning, note) for each code.

[18] Deprecated diagnostic codes from earlier specification versions shall be documented in the migration mapping (Annex H [changes]). Implementations may recognize legacy codes for backward compatibility but shall normalize them to the canonical format in output.

**NOTE 1**: The two-digit clause prefix supports clauses up to 99. Current specification planning does not anticipate exceeding 20 clauses.

**NOTE 2**: The three-digit sequential number provides 999 codes per clause. If a clause exhausts its allocation, the specification editors should consider subdividing the clause or consolidating related diagnostics.

**NOTE 3**: Warning and note diagnostics may use prefix `W` or `N` in future versions (e.g., `W02-001`, `N02-001`). Currently, all diagnostics use the `E` prefix.

#### §1.6.7 Example Guidelines [intro.document.examples.guidelines]

[19] All examples in the specification should follow these guidelines:

**Completeness:**
- Examples should be self-contained (define all referenced types)
- Include necessary imports and declarations
- Show expected output or error for invalid examples

**Clarity:**
- Use descriptive names (`buffer`, `owner`, `viewer`) not single letters (`a`, `b`, `c`)
- Include inline comments explaining key concepts
- Mark invalid code with `// error[E##-###]` showing expected diagnostic

**Relevance:**
- Each example demonstrates exactly one concept (or a deliberate interaction)
- Examples are minimal - no extraneous code
- Real-world patterns preferred over contrived examples

**Consistency:**
- Reuse common type names across specification (Buffer, Point, Data, Resource)
- Follow language style guide (naming conventions, formatting)
- Use consistent comment style


### §1.7 Versioning and Evolution [intro.versioning]

[1] Cursive follows semantic versioning (`MAJOR.MINOR.PATCH`). This subclause describes the meaning of each component and the obligations imposed on implementations and programs as the language evolves.

#### §1.7.1 Version Identifiers [intro.versioning.identifiers]

[2] The specification defined herein corresponds to version **1.0.0**. Minor revisions (`1.x.0`) add backwards-compatible features; patch revisions (`1.0.x`) provide errata and clarifications without changing behavior. Major revisions (`2.0.0`, `3.0.0`, …) may introduce breaking changes but shall follow the migration process in §1.7.4 [intro.versioning.deprecation].

[3] Projects shall declare a minimum required language version in their manifest or build configuration. If no version is declared, implementations may default to the latest supported minor release within the highest major version they provide (for example, 1.0 defaults to 1.latest within the 1.x series).

#### §1.7.2 Implementation Support [intro.versioning.impl]

[4] Conforming implementations shall document the set of language versions they support, including the default compilation version. When multiple versions are supported simultaneously, the implementation shall expose a mechanism (flag, configuration value, or project manifest entry) that selects the desired version.

[5] Preview or experimental versions may be offered, but they shall require explicit opt-in (e.g., `--language-version 2.0-preview`). Preview behavior shall never silently override stable semantics.

#### §1.7.3 Feature Stability Classes [intro.versioning.features]

[6] Features fall into three stability classes:

- **Stable**: Available by default in all minor releases of the current major version; breaking changes require a major release.
- **Preview**: Opt-in features that are intended for the next major release. Preview features shall be tagged `[Preview: target_version]` in the specification.
- **Experimental**: Highly unstable features guarded by feature-control directives. Experimental features may change or disappear without notice and shall never be enabled implicitly.

[7] Implementations shall clearly report when preview or experimental features are enabled. Tooling should emit warnings reminding users of the stability level.

#### §1.7.4 Deprecation and Removal [intro.versioning.deprecation]

[8] A feature slated for removal shall first be marked **deprecated** in a minor release. Deprecation notes include the planned removal version, rationale, and migration guidance. Deprecation lasts for at least one minor release before removal.

[9] Removal occurs only in a major release. Implementations shall issue diagnostics in the new major version when code relies on removed features and should provide migration hints. Automated migration tooling is a recommended, but not mandatory, quality-of-implementation feature.

[10] Deprecated features remain fully functional until removal but may trigger warnings. Programs may suppress such warnings only through documented means that do not mask other diagnostics.

#### §1.7.5 Errata and Patch Releases [intro.versioning.patch]

[11] Patch releases address specification defects, typographical errors, or clarifications that do not change behavior. When errata alter normative text, the change log in Annex H [changes] shall record the revision, rationale, and impacted sections.

[12] Implementations are encouraged to adopt patch releases promptly. When behavior diverges from a published patch release, implementations shall document the discrepancy and, if possible, provide compatibility modes.

#### §1.7.6 Project Manifest Schema [intro.versioning.manifest]

[13] Every project shall provide a UTF-8 encoded manifest file named `Cursive.toml` at the workspace root. The manifest shall conform to TOML 1.0 (ISO/IEC - ISO/IEC DIS 30170:2022) so that tooling can parse it deterministically.

[14] The manifest shall contain a `[cursive.language]` table with a `version = "MAJOR.MINOR.PATCH"` entry that names the language version targeted by the project. The version string shall follow the semantic-versioning grammar defined in §1.7.1 and shall be present even when the implementation also accepts command-line overrides.

[15] The manifest shall declare at least one source root using the `[cursive.source]` table with a `roots = ["relative/path", ...]` array. Each entry shall be a POSIX-style relative path rooted at the manifest directory, shall resolve to an existing directory, and shall be unique after path normalisation. Clause 4 derives module paths exclusively from these roots.

[16] Implementations shall issue diagnostics when the manifest is missing, malformed, omits the `language.version`, or provides an empty `roots` array. Implementations may extend the manifest with additional tables provided that the `cursive.language` and `cursive.source` tables remain intact and their semantics are not altered.


### §1.8 Design Decisions and Absent Features [intro.absent]

[1] Cursive achieves memory safety through explicit mechanisms that differ from other systems programming languages. Understanding what Cursive does NOT provide clarifies the deliberate design choices.

#### §1.8.1 No Garbage Collection [intro.absent.gc]

[2] Cursive does not employ garbage collection. Resource cleanup is deterministic via RAII (§10.2.4), occurring at statically determined program points. Complete memory management model is specified in Clause 10.

[3] Cleanup follows RAII (Resource Acquisition Is Initialization): objects are automatically destroyed at scope exit in LIFO (last-in, first-out) order. Destructors execute deterministically, releasing resources without programmer intervention.

[4] Comparison with garbage-collected languages:

**Table 1.1 — GC vs RAII comparison**

| Aspect           | Garbage Collection (Java, Go, Python) | Cursive RAII                   |
| ---------------- | ------------------------------------- | ------------------------------ |
| Cleanup timing   | Non-deterministic (GC decides)        | Deterministic (scope exit)     |
| Performance      | Unpredictable pauses                  | Bounded, predictable           |
| Resource release | Delayed (finalization queues)         | Immediate (LIFO at scope exit) |
| Real-time        | Difficult (GC pauses)                 | Natural (no pauses)            |
| Memory overhead  | GC metadata, heap pressure            | Minimal (stack/region only)    |

#### §1.8.2 No Borrow Checker [intro.absent.borrow]

[5] Cursive achieves memory safety without borrow checking or lifetime annotations. The design uses regions (§10.3), permissions (§10.4), and explicit move semantics (§10.5) instead of lifetime parameters and exclusive borrowing.

[ Rationale: Regions are concrete allocation arenas, not abstract lifetime bounds. Permissions control access without exclusive XOR mutable borrowing. Explicit move makes responsibility transfer visible. This approach provides memory safety with simpler mental model and better support for complex data structures. — end rationale ]

#### §1.8.3 No Send/Sync Markers [intro.absent.markers]

[6] Thread safety is encoded through the permission system (§10.4), not separate marker behaviors. The permission lattice (unique <: shared <: const) directly encodes thread safety properties (§13.1.2).

[7] **Permission-based thread safety:**

- **const types** are safe to share across threads (immutable, no races possible)
- **unique types** can be transferred between threads via `move` (exclusive ownership prevents races)
- **shared types** require explicit synchronization (programmer ensures coordination via Mutex, RwLock, etc.)

[ Rationale: The permission system already controls access and provides thread safety guarantees without introducing redundant markers. See §10.4 for complete permission semantics. — end rationale ]


### §1.9 Design Principles [intro.principles]

[1] Cursive embodies the following core design principles that inform decisions throughout this specification:

#### §1.9.1 Explicit Over Implicit [intro.principles.explicit]

[2] Every effect is visible in code. Cleanup responsibility uses explicit operators (`=` vs `<-`). Transfer requires explicit `move`. Grants require explicit declaration. Permissions require explicit annotation when not defaulted. All grants, preconditions, and postconditions are explicitly written in procedure signatures. There are no hidden effects, implicit preconditions, or unspecified guarantees. All compile-time execution is marked with the `comptime` keyword. Reflection requires explicit `[[reflect]]` attribute.

#### §1.9.2 Zero-Cost Abstractions [intro.principles.zerocost]

[3] Abstractions compile to code equivalent to hand-written alternatives. Safety mechanisms operate at compile time. Generic dispatch uses monomorphization. Permissions have no runtime representation. Static dispatch through monomorphization remains the zero-cost default. Witnesses are an explicit opt-in for scenarios requiring runtime flexibility. Types without `[[reflect]]` have no reflection metadata overhead.

#### §1.9.3 Local Reasoning [intro.principles.local]

[4] Program properties are derivable from local context. Procedure contracts specify complete requirements. Permissions prevent action at a distance. Region escape analysis is local to region blocks. Witness types show complete dispatch strategy. Metaprogramming code is readable without global context.

#### §1.9.4 Deterministic Semantics [intro.principles.deterministic]

[5] Language behavior is fully specified and deterministic. Evaluation order is left-to-right. No undefined evaluation order. Comptime evaluation is reproducible. Compilation order and comptime evaluation are deterministic.


### §2.1 Source Text and Encoding [lex.source]

#### §2.1.1 Overview

[1] Cursive source input is a sequence of Unicode scalar values that shall be encoded as UTF-8. All subsequent phases (§2.2 [lex.phases]) assume that the implementation has normalised line endings and removed optional metadata such as byte order marks before tokenisation (§2.3 [lex.tokens]).

[2] A _source file_ is the decoded Unicode scalar stream after UTF-8 validation and line-ending normalisation. A _compilation unit_ is the textual content of a single source file after this preprocessing step.

### §2.1.2 Syntax

[1] Source files conform to the following lexical skeleton prior to tokenisation:

```ebnf
source_file
    ::= bom? normalized_line*

normalized_line
    ::= code_point* line_terminator?

line_terminator
    ::= "\n"

bom
    ::= "\uFEFF"
```

[ Note: See Annex A §A.2 [grammar.lexical] for the complete lexical grammar including source file structure.
— end note ]

[2] `code_point` denotes any Unicode scalar value other than control characters disallowed by constraint [4].

### §2.1.3 Constraints

[1] _UTF-8 validation._

> Implementations **MUST** accept only byte streams that decode to legal UTF-8 sequences. Invalid byte sequences **MUST** elicit diagnostic `E-SRC-0101`.

[2] _Byte order mark handling._

> If the byte stream begins with U+FEFF, the implementation **MUST** strip the BOM before any further analysis. Any occurrence of U+FEFF after the first decoded scalar value **MUST** trigger diagnostic `E-SRC-0103`.

[3] _Line endings._ Implementations shall recognise LF, CR, and CRLF sequences and normalise each to a single LF code point before tokenisation. Mixed line endings are permitted; the normalisation process preserves the number of logical lines.

[4] _Prohibited code points._

> Outside string and character literals, only horizontal tab (U+0009), line feed (U+000A), carriage return (U+000D), and form feed (U+000C) **MAY** appear from Unicode category Cc. U+0000 **MUST NOT** appear anywhere in the source and **MUST** result in diagnostic `E-SRC-0104`.

[5] _File size._

> Implementations **MUST** document an implementation-defined maximum source size and **MUST** accept files of at least 1 MiB. Files exceeding the implementation limit **MUST** raise diagnostic `E-SRC-0102`.

> Diagnostics `E-SRC-0101`–`E-SRC-0104` **MUST** be assigned to the `SRC-01` feature bucket (Source ingestion and normalization). Any compilation unit that triggers one or more of these diagnostics **MUST** be treated as an ill-formed program (§4.2): the implementation **MUST NOT** advance later translation phases for that compilation unit and **MUST** reject it without producing executable artifacts.

### §2.1.4 Semantics

[1] After constraint checks succeed, the normalised LF characters become significant tokens that participate in automatic statement termination (§2.4 [lex.terminators]). Horizontal tabs and spaces serve as token separators but are otherwise ignored by lexical analysis.

[2] Unicode normalisation is implementation-defined. Implementations should accept any of NFC, NFD, NFKC, or NFKD input; if additional normalisation is performed, it shall not alter source line boundaries or byte offsets used for diagnostics.

Formal source-ingestion judgment:

```text
[WF-Src-OK]
decode_utf8(bytes) = scalars
strip_leading_BOM(scalars) = scalars'
normalize_line_endings(scalars') = S
no_prohibited_controls(S)        // per §2.1.3[4]
|bytes| ≤ max_source_size        // per §2.1.3[5]
------------------------------------------------
bytes ⊢src (S, ∅)


[WF-Src-Invalid-UTF8]
decode_utf8(bytes) fails at span s
------------------------------------------------
bytes ⊢src (⊥, { E-SRC-0101 @ s })


[WF-Src-Size-Limit]
decode_utf8(bytes) = scalars
strip_leading_BOM(scalars) = scalars'
normalize_line_endings(scalars') = S
no_prohibited_controls(S)
|bytes| > max_source_size
------------------------------------------------
bytes ⊢src (⊥, { E-SRC-0102 @ file_span })


[WF-Src-Embedded-BOM]
decode_utf8(bytes) = scalars
strip_leading_BOM(scalars) = scalars'
normalize_line_endings(scalars') = S
∃ position p > 0. S[p] = U+FEFF
------------------------------------------------
bytes ⊢src (⊥, { E-SRC-0103 @ p })


[WF-Src-Prohibited-Control]
decode_utf8(bytes) = scalars
strip_leading_BOM(scalars) = scalars'
normalize_line_endings(scalars') = S
∃ position p. S[p] is U+0000
  ∨ (S[p] ∈ Cc \ {U+0009,U+000A,U+000C,U+000D}
     ∧ p is not within a string/character literal span)
------------------------------------------------
bytes ⊢src (⊥, { E-SRC-0104 @ p })
```

### §2.1.5 Examples

**Example 2.1.5.1 (Valid Source Structure):**

```cursive
//! Module overview — documentation comment
let greeting = "Hello, world"  // UTF-8 literal
let delta = "Δ"                // Non-ASCII scalar value
```

[1] The example uses LF line endings, no BOM, and only permitted control characters, so it satisfies constraints [1]–[4].

**Example 2.1.5.2 - invalid (Embedded BOM):**

```cursive
let x = 1
\uFEFFlet y = 2  // error[E-SRC-0103]
```

[2] The second line embeds U+FEFF after decoding, violating constraint [2].

### §2.1.6 Conformance Requirements

[1] Implementations shall document the maximum supported source-file size and the Unicode version they validate against.

[2]

> Diagnostics `E-SRC-0101`–`E-SRC-0104` **MUST** be emitted with a source span that precisely identifies the offending byte sequence or code point. The span's byte offsets and line/column coordinates **MUST** be computed with respect to the preprocessed source file after UTF-8 validation, BOM stripping, and line-ending normalisation (§2.1.1–§2.1.3), and any further Unicode normalisation **MUST NOT** change these offsets (§2.1.4[2]). Suggestions in diagnostic text are informative; the failure remains normative.

> The implementation-defined maximum source size and the Unicode normalisation form used for source text **MUST** be documented as implementation-defined behaviors (IDB) in the implementation's conformance dossier, consistent with Annex B entries B.1.07 and B.1.17. Conforming programs **MUST NOT** rely on undocumented choices for these behaviors.

> When the byte stream begins with a UTF-8 BOM (U+FEFF) and otherwise satisfies the constraints in §2.1.3, a conforming implementation **SHOULD** emit diagnostic `W-SRC-0101` (UTF-8 BOM present) while still accepting the source file.

[3] Implementations may issue warnings when large files or mixed normalisation forms are detected, but such warnings shall not replace the mandatory diagnostics described above.


### §2.2 Translation Phases [lex.phases]

#### §2.2.1 Overview

[1] Cursive compilation proceeds through a deterministic pipeline of translation phases that convert validated UTF-8 source (§2.1 [lex.source]) into executable artifacts. The phases are designed to expose explicit intermediate products so that diagnostics, tooling, and contracts can observe well-defined boundaries.

[2] A _compilation unit_ is the textual content of a single source file after preprocessing (§2.1). Clause 4 derives module identity from these units; imports create dependencies between units but do not merge them. A program is _well-formed_ precisely when every compilation unit completes each translation phase without producing a fatal diagnostic.

[3] Cursive deliberately omits textual preprocessing: the pipeline begins immediately with lexical analysis (§2.3 [lex.tokens]), ensuring that all transformations are performed with full syntactic and semantic context rather than token substitution.

[4] The pipeline follows a **two-phase compilation model**: the parsing phase records the complete set of declarations and their structural metadata without enforcing semantic requirements, and the semantic phases (compile-time execution, code generation, type checking, and lowering) run only after parsing succeeds. This model guarantees that declarations may appear in any order within a compilation unit—forward references are resolved during the semantic phases rather than by separate stub declarations.

### §2.2.2 Syntax

[1] The sequencing of phases is described by the following grammar; the symbols correspond to the sections in §2.2.4.

```ebnf
phase_pipeline
    ::= parsing
     "→" comptime_execution
     "→" type_checking
     "→" code_generation
     "→" lowering
```

[2] Implementations may internally refactor work, but they shall present the externally observable phase boundaries in the order above. Type checking therefore gates code generation: no target code is produced until the program has passed parsing, compile-time execution, and type checking.

### §2.2.3 Constraints

[1] _Phase ordering._ Implementations shall execute phases strictly in the order defined by `phase_pipeline`. A phase that emits a diagnostic with severity _error_ shall terminate the pipeline for the affected compilation unit; later phases shall not observe partially processed artefacts.

(1.1) _Parsing boundary._ Parsing shall complete (successfully or with diagnostics) **before** compile-time execution begins. Subsequent phases are prohibited from mutating the parse tree in ways that would invalidate the recorded declaration inventory; they may annotate the tree with semantic metadata only.

(1.2) _Type-checking gate._ Type checking shall complete (successfully or with diagnostics) **before** code generation begins. Generated code is therefore guaranteed to correspond to a well-typed program that satisfies all permission, grant, and contract requirements available at that point in the pipeline.

[2] _Determinism._ The observable results of a phase (diagnostics, generated declarations, lowered IR) shall be deterministic with respect to the input compilation unit and compilation configuration.

[3] _Comptime evaluation limits._ The compile-time execution phase shall enforce resource limits at least as permissive as the following minima:

| Resource               | Minimum                     | Diagnostic |
| ---------------------- | --------------------------- | ---------- |
| Recursion depth        | 256 frames                  | E02-101    |
| Evaluation steps       | 1,000,000 per block         | E02-102    |
| Memory allocation      | 64 MiB per compilation unit | E02-103    |
| String size            | 1 MiB                       | E02-104    |
| Collection cardinality | 10,000 elements             | E02-105    |

[4] _Grant safety._ Comptime execution shall refuse any grant that is not listed in the grants clause of the executing item's contractual sequent. Runtime-only capabilities (e.g., file system or network grants as will be cataloged in §12.3 [contract.grant]) are forbidden and shall raise diagnostic E02-106. Comptime blocks declare their capability requirements explicitly through the same sequent mechanism used by procedures; complete grant semantics are specified in Clause 12 [contract].

[5] _Generated symbol hygiene._ Code generation shall ensure that generated declarations do not collide with declarations already present in the AST. Name collisions shall be diagnosed as E02-107.

### §2.2.4 Semantics

#### §2.2.4.1 Parsing

[1] The parsing phase consumes the normalized token stream (§2.3 [lex.tokens]) and constructs an abstract syntax tree (AST) that preserves source spans needed for diagnostics and tooling.

[2] Parsing records every declaration, its identifier, structural metadata (e.g., parameter lists, field declarations), and source scope. The AST produced at this stage is the authoritative inventory of declarations for the compilation unit.

[3] Parsing shall not attempt semantic validation. All name lookup, type checking, permission/grant checks, and diagnostic enforcement occur during the semantic-analysis phase (§2.2.4.2–§2.2.4.4).

[4] Forward references are therefore permitted: declarations may appear after their uses in the source, and mutual recursion is resolved by the later semantic phases.

#### §2.2.4.2 Compile-Time Execution

[1] The comptime execution phase evaluates `comptime` blocks in dependency order. Implementations build a dependency graph whose nodes represent comptime blocks and whose edges reflect value or type dependencies discovered during parsing. The graph is constructed only after the parser has completed the compilation unit, ensuring all referenced declarations are known.

[2] Before executing a block, the compiler verifies that all predecessors in the dependency graph have succeeded. Cycles are ill-formed and shall be reported as diagnostic E02-100.

[3] Comptime code executes with access only to explicitly-granted capabilities (`comptime.alloc`, `comptime.codegen`, `comptime.config`, `comptime.diag`). All other grants are rejected per constraint [4].

#### §2.2.4.3 Type Checking

[1] The type-checking phase resolves names, validates type constraints, enforces grant clauses, and checks contracts. Because parsing has already recorded every declaration, name resolution always observes a complete declaration inventory.

(1.1) [ Note: Module scope formation (§4.3 [module.scope]) occurs during this phase, before name lookup. Wildcard imports (`use module::*`) expand at scope-formation time, after parsing has completed for all modules in the dependency graph. This ensures that the set of exported items is stable before expansion proceeds. — end note ]

[2] Permission checks, modal verification, and contract evaluation are delegated to their respective clauses (memory model, modals, contracts) but are orchestrated from this phase to guarantee that only semantically sound programs proceed to code generation and lowering.

#### §2.2.4.4 Code Generation

[1] Code generation materialises declarations requested by comptime execution (e.g., via `codegen::declare_procedure`) and produces backend-specific artefacts only after type checking succeeds. Generated declarations are appended to the AST and annotated so that diagnostics can reference both the generated item and the originating comptime site.

[2] Hygiene utilities such as `gensym` shall be used to avoid collisions; generated code is subject to the same visibility and validation rules as user-authored code.

#### §2.2.4.5 Lowering

[1] Lowering transforms the fully-validated AST into an intermediate representation (IR) suitable for target-specific code generation. Comptime constructs are eliminated, generic constructs are monomorphised, and deterministic cleanup paths (RAII) are made explicit.

[2] Implementations may perform optimisation-friendly rewrites during lowering provided the externally observable behaviour remains unchanged.

### §2.2.5 Examples

**Example 2.2.5.1 (Phase Interaction):**

```cursive
// Phase 1: Parse comptime block and procedure skeleton
comptime {
    let size = config::get_usize("buffer_size", default: 4096)
    codegen::declare_constant(
        name: "BUFFER_SIZE",
        ty: codegen::type_named("usize"),
        value: quote { #(size) }
    )
}

public procedure create_buffer(): Buffer
    [[ |- true => true ]]
{
    result Buffer { data: make_zeroes(len: BUFFER_SIZE) }
}
```

[1] Parsing records a comptime block and an incomplete procedure. During compile-time execution the configuration query runs, contributing a constant. Code generation publishes the constant via `declare_constant`; type checking resolves `BUFFER_SIZE` and validates the call to `make_zeroes`; lowering erases the comptime block and emits IR containing the numeric literal produced at compile time.

### §2.2.6 Conformance Requirements

[1] Implementations shall provide diagnostics cited in this clause and shall guarantee that fatal diagnostics terminate the compilation of the affected compilation unit.

[2] Implementations shall make the outputs of each phase observable to tools (for example through logs or compiler APIs) so that external tooling can integrate with the pipeline.

[3] Implementations may parallelise translation phases across independent compilation units, but the phases for any single compilation unit shall respect the deterministic pipeline defined in this clause.


### §2.3 Lexical Elements [lex.tokens]

#### §2.3.1 Overview

[1] Lexical analysis transforms the normalised character stream (§2.1 [lex.source]) into a sequence of tokens consumed by the parser (§2.2 [lex.phases]). Tokens carry a kind, lexeme, and source location, while whitespace and non-documentation comments are discarded.

[2] Documentation comments beginning with `///` or `//!` are retained for later association with declarations; all other comments are removed during this phase.

### §2.3.2 Syntax

[1]

> The lexical analysis phase **MUST** classify each non-whitespace, non-comment span of the normalised character stream into exactly one of the following token kinds: `identifier`, `keyword`, `literal`, `operator`, `punctuator`, or `newline`. Whitespace and comments **MUST NOT** be emitted as tokens. Each line feed (U+000A) code point that is not part of a string or character literal **MUST** be represented by a `NEWLINE` token in the token stream.

```ebnf
token
    ::= identifier
     | keyword
     | literal
     | operator
     | punctuator
     | newline
```

[ Note: See Annex A §A.2 [grammar.lexical] for complete lexical grammar.
— end note ]

[2]

> An identifier **MUST** begin with a Unicode scalar value whose Unicode property `XID_Start` is `Yes` or with U+005F LOW LINE (`'_'`), and **MUST** be followed by zero or more Unicode scalar values whose Unicode property `XID_Continue` is `Yes` or that are U+005F LOW LINE (`'_'`). Any lexeme used where an identifier is expected that does not satisfy this shape **MUST NOT** be treated as an identifier. Identifiers **MUST NOT** be equal in spelling to any reserved keyword listed in constraint [4].

### §2.3.3 Constraints

[1] _Whitespace._ Space (U+0020), horizontal tab (U+0009), and form feed (U+000C) act as token separators and are not emitted as tokens. Line feed (U+000A) is emitted as a `NEWLINE` token for use in §2.4 [lex.terminators].

[2] _Comments._

- (2.1) Line comments starting with `//` consume characters to the next line terminator and are discarded.
- (2.2) Block comments delimited by `/*` and `*/` shall nest; unclosed block comments raise diagnostic E-SRC-0306.

> A comment whose first three characters are `///` or `//!` **MUST** be classified as a documentation comment governed by constraint [3] and **MUST NOT** be processed as an ordinary line comment under (2.1).

[3] _Documentation comments._ Comments beginning with `///` or `//!` shall be preserved and attached to the following item or module, respectively. They participate in documentation tooling but do not appear in the token stream.

[4] _Keywords._ The following identifiers are reserved and may not be used as ordinary identifiers: `abstract`, `as`, `async`, `await`, `behavior`, `break`, `by`, `case`, `comptime`, `const`, `continue`, `contract`, `defer`, `else`, `enum`, `exists`, `false`, `forall`, `grant`, `if`, `import`, `internal`, `invariant`, `let`, `loop`, `match`, `modal`, `module`, `move`, `must`, `new`, `none`, `private`, `procedure`, `protected`, `public`, `record`, `region`, `result`, `select`, `self`, `Self`, `shadow`, `shared`, `state`, `static`, `true`, `type`, `unique`, `var`, `where`, `will`, `with`, `witness`.

[5] _Literals._ Numeric literals support decimal, hexadecimal (`0x`), octal (`0o`), and binary (`0b`) prefixes. Underscores `_` may separate digits but shall not appear at the start or end of the literal, immediately after a base prefix, or before a type suffix. Integer literals without a suffix default to type `i32`. Violations raise diagnostic E02-206. Floating-point literals consist of an integer part, optional fractional part, optional exponent, and optional suffix (`f32` or `f64`).

[6] _String and character literals._ Strings are delimited by double quotes and support escape sequences `\n`, `\r`, `\t`, `\\`, `\"`, `\'`, `\0`, `\xNN`, and `\u{...}`. Invalid escapes raise diagnostic E-SRC-0302. Character literals use single quotes and must correspond to a single Unicode scalar value; empty or multi-character literals raise diagnostic E-SRC-0303.

(6.1) _String literal line boundaries._ String literals may not span multiple lines unless escaped newlines (`\n`) are used. An unclosed string literal that reaches end-of-file or encounters a newline without being closed emits diagnostic E-SRC-0301 (unterminated string literal). The lexer shall not attempt to recover by inserting a closing quote; the compilation unit is ill-formed.

(6.2) _Nested block comments._ Block comments nest arbitrarily: `/* outer /* inner */ still outer */` is valid and consumes all characters between the outermost `/*` and `*/`. Unclosed nested comments emit diagnostic E-SRC-0306. Implementations shall track nesting depth and report the nesting level at the point of failure to aid debugging.

(6.3) _Invalid Unicode in identifiers._

> Identifiers **MUST** consist only of Unicode scalar values permitted by §2.3.2[2]. If an identifier contains a scalar value that does not satisfy those rules, the implementation **MUST** emit diagnostic `E-SRC-0307` (invalid Unicode in identifier). The lexer **MUST NOT** attempt to repair such identifiers; they are rejected and produce no tokens.

[7] _Operators and punctuators._ Multi-character operators (e.g., `==`, `!=`, `=>`, `..=`, `<-`) are recognised using maximal munch (§2.4 [lex.terminators]). The reference-binding operator `<-` participates in the same precedence and continuation rules as `=` so that Clause 5 bindings parse unambiguously. Implementations shall disambiguate closing angle brackets in generic type contexts by treating `>>` as two tokens when syntactically required. The glyph `~` is reserved for procedure receiver shorthand (§5.4 [decl.function]) and is tokenised as an operator so that combinations such as `~%` and `~!` are available.

### §2.3.4 Semantics

[1] Tokens retain source-span metadata (file, line, column) so that later phases can provide precise diagnostics and tooling hooks.

[2]

> A documentation comment preserved by constraint [3] **MUST** be associated with the immediately following declaration or module in the same compilation unit if there is no intervening blank line containing non-comment characters. If no such declaration or module exists—because the comment appears at end of file or is separated from the next declaration by one or more blank lines—the documentation comment **MUST** be ignored for semantic purposes while remaining available to tooling; it **MUST NOT** affect the token stream or program well-formedness.

[3]

> Lexical analysis under this subclause **MUST** be applied only to compilation units that have passed the source-ingestion checks of §2.1. Violations of UTF-8 validity, file-size limits, BOM placement, or forbidden control characters **MUST** be diagnosed using `E-SRC-0101`–`E-SRC-0104` (with `W-SRC-0101` permitted for an initial BOM) and **MUST** prevent further translation of the affected compilation unit. Any compilation unit that contains a violation of the lexical rules in §2.3—including identifier, keyword, literal, or comment constraints—**MUST** be classified as ill-formed (§4.2). Implementations **MUST** emit at least one `E-SRC-03xx` diagnostic for such units and **MUST NOT** produce translation artifacts for them, although they **MAY** continue analysis to report additional diagnostics.

### §2.3.5 Examples

**Example 2.3.5.1 (Token Stream):**

```cursive
// comment
let answer = 42
```

[1] Tokens emitted: `NEWLINE`, `KEYWORD("let")`, `IDENTIFIER("answer")`, `OPERATOR("=")`, `INTEGER_LITERAL("42")`, `NEWLINE`.

**Example 2.3.5.2 - invalid (Keyword misuse):**

```cursive
let let = 5  // error[E-SRC-0305]
```

[2] The second `let` is rejected because keywords cannot serve as identifiers (constraint [4]).

**Example 2.3.5.3 (Numeric formatting):**

```cursive
let mask = 0b1111_0000u8
let size = 1_024
```

[3] Underscore placement satisfies constraint [5], so both literals are accepted.

### §2.3.6 Diagnostic Summary

| Code    | Condition                                            | Constraint |
| ------- | ---------------------------------------------------- | ---------- |
| E-SRC-0305 | Reserved keyword used as identifier                  | [4]        |
| E-SRC-0301 | Unterminated string literal                          | [6]        |
| E-SRC-0306 | Unterminated block comment                           | [2], (6.2) |
| E-SRC-0304 | Malformed numeric literal                            | [5]        |
| E-SRC-0302 | Invalid escape sequence                              | [6]        |
| E-SRC-0303 | Invalid character literal                            | [6]        |
| E-SRC-0307 | Invalid Unicode in identifier                        | [6.3]      |

> The conditions in §2.3.3 **MUST** be reported using the `SRC-03` diagnostics defined in this table. Implementations **MUST NOT** repurpose these codes for any other conditions.

### §2.3.7 Conformance Requirements

[1] Implementations shall expose token streams (or equivalent APIs) to tooling with location metadata preserved.

[2] Implementations shall detect and report the diagnostics in §2.3.6 at the earliest phase that can do so without suppressing additional diagnostics.

[3] Implementations may extend the set of contextual keywords provided they do not conflict with the reserved set in constraint [4] and provided the contextual keywords remain usable as identifiers outside the specialised contexts that introduce them.


### §2.4 Tokenization and Statement Termination [lex.terminators]

#### §2.4.1 Overview

[1] This clause refines the behavior of the lexer around newline handling, statement continuation, and the maximal-munch rule used to recognise multi-character operators. It builds on the token categories introduced in §2.3 [lex.tokens] and defines when newline tokens terminate statements implicitly.

### §2.4.2 Syntax

[1] Statement termination operates on the following abstract grammar:

```ebnf
statement_sequence
    ::= statement (newline separator)*

separator
    ::= newline
     | semicolon

continuation
    ::= trailing_operator
     | leading_dot
     | leading_pipeline
     | unclosed_delimiter
```

[ Note: See Annex A §A.2 [grammar.lexical] for the complete lexical grammar including statement termination rules.
— end note ]

[2] A `newline` that satisfies `continuation` does not terminate the preceding statement; otherwise it behaves as a separator.

### §2.4.3 Constraints

[1] _Implicit termination._ A newline shall terminate the current statement unless one of the continuation predicates in §2.4.4 evaluates to true. The same rule applies at end-of-file.

(1.1) _Multiple continuation rules._ When multiple continuation rules apply simultaneously (e.g., a trailing operator followed by a leading dot on the next line), the statement continues. The rules are evaluated independently; any matching rule prevents termination. This allows flexible formatting while maintaining predictable behavior.

(1.2) _EOF in middle of statement._ If end-of-file occurs while a statement is incomplete (unclosed delimiters, trailing operator, or other continuation condition), diagnostic E02-211 (unexpected end of file) is emitted. The lexer shall report the location where the statement began and which continuation condition was active.

[2] _Semicolons._ Semicolons may be used to separate multiple statements on a single line but are never required at line breaks.

[3] _Maximal munch._ When multiple tokenisations are possible at a character position, the lexer shall emit the longest valid token. In generic type contexts the parser may reinterpret `>>` as two closing angle brackets to satisfy the grammar of §7.2 [type.primitive].

(3.1) _Delimiter nesting depth._ Implementations shall support delimiter nesting to at least depth 256. Nested delimiters beyond this limit may be rejected with diagnostic E02-300 (delimiter nesting too deep). This limit prevents stack overflow in pathological cases while accommodating realistic code structures.

### §2.4.4 Semantics

#### §2.4.4.1 Unclosed Delimiters

[1] If the lexer encounters a newline while an opening delimiter `(`, `[`, `{`, or `<` remains unmatched, the newline is treated as whitespace and the statement continues until the delimiter stack is balanced. Diagnostic context highlights the location of the unmatched delimiter when exhaustion occurs.

#### §2.4.4.2 Trailing Operators

[1] When a line ends with a binary or assignment operator (`+`, `-`, `*`, `/`, `%`, `**`, `==`, `!=`, `<`, `<=`, `>`, `>=`, `&&`, `||`, `&`, `|`, `^`, `<<`, `>>`, `..`, `..=`, `=>`, `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`), the following newline is ignored and the expression continues on the next line.

#### §2.4.4.3 Leading Dot

[1] A line beginning with `.` is treated as a continuation of the previous expression to support fluent member access. The token `::` does not activate this rule; code using the scope operator shall remain on the same line or employ explicit parentheses.

#### §2.4.4.4 Leading Pipeline

[1] A line beginning with the pipeline operator `=>` continues the preceding expression. Pipelines are commonly chained with one entry per line for readability.

#### §2.4.4.5 Maximal Munch

[1] The lexer applies the maximal-munch rule globally. Examples include recognising `<<=` as a single left-shift assignment operator and `..=` as an inclusive range operator. When maximal munch conflicts with generic parsing, the parser reinterprets tokens without altering original lexemes, preserving tooling fidelity.

### §2.4.5 Examples

**Example 2.4.5.1 (Continuation Rules):**

```cursive
let sum = calculate(
    input
)  // newline ignored because '(' was unclosed

let transformed = source
    => normalize
    => render  // leading pipeline

let value = builder
    .step_one()
    .step_two()
```

**Example 2.4.5.2 (Maximal Munch vs Generics):**

```cursive
let shift = value >> 3        // lexer emits single '>>'
let ptr: Ptr<Ptr<i32>> = make_ptr()  // parser splits '>>' into two closers
```

### §2.4.6 Diagnostic Summary

[1] Diagnostics associated with this subclause:

| Code    | Condition                                | Constraint |
| ------- | ---------------------------------------- | ---------- |
| E02-211 | Unexpected end of file during statement  | [1.2]      |
| E02-300 | Delimiter nesting too deep (exceeds 256) | [3.1]      |

### §2.4.7 Conformance Requirements

[1] Implementations shall expose diagnostics that identify the continuation rule responsible when statement termination behaves unexpectedly (e.g., pointing to a trailing operator or unclosed delimiter).

[2] Implementations shall preserve original lexemes even when the parser reinterprets tokens for generic closings so tooling can reconstruct the exact source text.


### §2.5 Compilation Units and Top-Level Forms [lex.units]

#### §2.5.1 Overview

[1] A compilation unit is the syntactic content of a single source file after preprocessing (§2.1 [lex.source]). Clause 2 governs the translation of those files; Clause 4 derives module paths from the file system layout. This clause enumerates the declarations permitted at module scope and describes module-level initialisation.

### §2.5.2 Syntax

[1] Top-level structure is constrained by the following grammar, with non-terminals defined in later clauses:

```ebnf
compilation_unit
    ::= top_level_item*

top_level_item
    ::= import_declaration
     | use_declaration
     | variable_declaration
     | procedure_declaration
     | type_declaration
     | predicate_declaration
     | contract_declaration
     | grant_declaration
```

[2] Expression statements, control-flow constructs (`if`, `match`, `loop`, etc.), and local bindings are not permitted at module scope.

[Note: Constants are expressed via type qualifiers on variable declarations (`let x: const Y = 0`) rather than separate declaration forms. Grant declarations (§5.9 [decl.grant]) introduce user-defined capability tokens for use in procedure contractual sequent specifications. — end note]

### §2.5.3 Constraints

[1] _Visibility._ Declarations without an explicit visibility modifier default to `internal`. The modifiers `public`, `internal`, `private`, and `protected` control accessibility across modules and packages; see Clause 4 [module] for re-exporting behaviour.

[2] _Uniqueness._ The names introduced by top-level items shall be unique within the compilation unit. Redeclaration without explicit `shadow` is diagnosed as E02-400.

[3] _Forward references._ Forward references to declarations in the same compilation unit are permitted because the parser records declarations before type checking (§2.2 [lex.phases]).

[4] _Disallowed forms._ Expression statements, control-flow constructs, and block scopes at module level shall raise diagnostic E02-301.

[5] _Empty compilation units._ A compilation unit may contain zero top-level items. An empty compilation unit defines a valid module with no exports. Such modules may be imported for their side effects (e.g., module-level initialisation) but contribute no bindings to the importing module's namespace.

[6] _Whitespace and comments only._ A compilation unit containing only whitespace, line comments, block comments, or documentation comments (with no top-level items) is treated as an empty compilation unit per constraint [5]. No diagnostic is emitted for such files.

### §2.5.4 Semantics

#### §2.5.4.1 Module-Level Initialisation

[1] Module-level `let` and `var` bindings are initialised before the program entry point executes. Implementations construct a dependency graph between initialisers and evaluate bindings in topological order. Cycles are rejected with diagnostic E02-401.

[2] Initialisers execute exactly once per program instance. Mutable `var` bindings retain their state for the life of the program unless explicitly mutated or reset by user code.

#### §2.5.4.2 Entry Point

[1] Executable programs shall provide exactly one procedure named `main`. The canonical forms and required diagnostics are specified in §5.8 [decl.entry], which owns entry-point validation (codes E05-801–E05-804).

### §2.5.5 Examples

**Example 2.5.5.1 (Valid Compilation Unit):**

```cursive
use std::io::println

public record Point { x: f64, y: f64 }

let ORIGIN: Point = Point { x: 0.0, y: 0.0 }

public procedure distance(a: Point, b: Point): f64
    [[ |- true => true ]]
{
    let dx = b.x - a.x
    let dy = b.y - a.y
    result (dx * dx + dy * dy).sqrt()
}
```

[1] The example contains only permitted top-level items and relies on the implicit initialisation rules of §2.5.4.1.

**Example 2.5.5.2 - invalid (Expression Statement at Module Scope):**

```cursive
let value = 5
value + 1  // error[E02-301]
```

### §2.5.6 Conformance Requirements

[1] Implementations shall expose APIs or metadata that identify the module path corresponding to each compilation unit so tooling can correlate files with module identifiers.

[2] Diagnostically, implementations shall detect redeclarations (E02-400), prohibited constructs (E02-301), and entry-point violations (E05-801–E05-804, see §5.8 [decl.entry]) during or before type checking.

[3] Implementations may lazily evaluate module-level initialisers provided that observable behaviour matches the eager semantics described in §2.5.4.1.


### §3.1 Module Overview and File-Based Organization [module.overview]

#### §3.1.1 Overview

[1] A _module_ is the fundamental namespace unit in Cursive. Each compilation unit described in §2.5 defines exactly one module without additional syntax. Module boundaries determine which declarations are visible outside the file, where documentation attaches, and how Clause 5 resolves qualified names. Filesystem layout fixes the module's fully-qualified path; this clause specifies path derivation, export boundaries, and required diagnostics.

#### §3.1.2 Syntax

[1] Module paths consist of one or more identifiers separated by `::`. Examples: `main`, `utilities::math`, `core::io::file`.

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `module_path` production. — end note ]

[3] Each compilation unit contributes one `module_path`; mapping rules appear in §3.1.3.

#### §3.1.3 Constraints

[1] **Single-file modules.** Each compilation unit shall define exactly one module. Attempts to amalgamate multiple files into a single module are ill-formed (diagnostic E03-001).

[2] **Manifest-defined roots.** The workspace manifest `Cursive.toml` (§1.7.6 [intro.versioning.manifest]) shall exist and shall provide a `[cursive.source]` table whose `roots` array lists every source root. Missing manifests or malformed tables provoke diagnostic E03-006. When the manifest is well-formed, every source file shall reside beneath exactly one declared root; files outside the declared roots provoke diagnostic E03-002.

[3] **Component derivation.** The relative path from the selected root to the file, minus extension, is segmented by the platform path separator. Each segment must satisfy the identifier rules of §2.3. Segments that fail this requirement elicit diagnostic E03-003.

[4] **Extension.** The canonical extension for module files is `.cursive`. Implementations may document additional extensions, but such extensions shall not alter module semantics.

[5] **Case collisions.** When two files differ only by case under a case-insensitive filesystem, the build is ill-formed (diagnostic E03-004). Implementations shall detect this condition before semantic analysis.

(5.1) **Case sensitivity error handling.** When a case-insensitive filesystem is detected and multiple files would map to the same module path when case is ignored, implementations shall:

- Emit diagnostic E03-004 listing all conflicting file paths
- Reject the compilation unit containing the ambiguous reference
- Provide suggestions for resolving the conflict (e.g., standardizing on a single case convention)

(5.2) **Cross-platform consistency.** Implementations shall warn (diagnostic E03-007, severity warning) when module paths that are distinct on case-sensitive filesystems would collide on case-insensitive filesystems. This helps developers maintain portability across platforms.

[6] **Reserved components.** Module components shall not coincide with reserved keywords (§2.3[4]). Violations produce diagnostic E03-005.

#### §3.1.4 Semantics

[1] The derived path establishes the stable label namespace `[module.<component>*]`.

[2] Items lacking `public` visibility remain confined to the defining module unless re-exported (§3.4).

[3] Documentation comments not otherwise attached to declarations bind to the enclosing module.

[4] Manifest metadata beyond the declared roots is informative only; normative behaviour flows solely from the filesystem-derived identity. Implementations shall ignore unspecified tables while still enforcing the `language.version` and `source.roots` requirements inherited from §1.7.6.

[5] Implementations shall canonicalise absolute paths after root resolution to guarantee diagnostics and tooling can identify modules uniquely.

#### §3.1.5 Examples

**Example 3.1.5.1 (Canonical layout):**

```
workspace/
├── Cursive.toml           # [cursive.source].roots = ["source"]
└── source/
    ├── main.cursive       → module path: main
    ├── utilities.cursive  → module path: utilities
    └── math/
        ├── geometry.cursive → module path: math::geometry
        └── report.cursive   → module path: math::report
```

[1] Manifest declares `source` as the root; each segment is a valid identifier.

**Example 3.1.5.2 - invalid (Reserved component):**

```
workspace/
└── source/
    └── module/
        └── type.cursive   → module component `type` is reserved
```

[2] Diagnostic E03-005 is required.

#### §3.1.6 Integration

[1] Clause 4 scopes declarations by module identity; Clause 5 performs lookup using the same paths. Annex E §E.2.1 mandates tooling support for enumerating module dependencies.

[2] Build caches may persist manifest resolution results provided they do not modify the normative mapping.


### §3.2 Module Syntax [module.syntax]

#### §3.2.1 Overview

[1] Module syntax encompasses the declarations that import other modules, bring exported items into scope, and re-export items for downstream consumers.

[2] This subclause provides the normative grammar; semantics for scope formation, visibility, and diagnostics appear in §§3.3–3.5.

#### §3.2.2 Syntax

[1] Module-level items extend §2.5's grammar as follows (authoritative production appears in Annex A §A.6):

**Import declarations** match the pattern:
```
"import" <module_path> [ "as" <identifier> ]
```

**Use declarations** match the pattern:
```
[ "public" ] "use" <use_clause>
```

**Use clauses** take one of the following forms:
```
<qualified_path>
<qualified_path> "as" <identifier>
<qualified_path> "::" "{" <use_list> "}"
<qualified_path> "::" "*"
```

**Qualified paths** match the pattern:
```
<module_path>
<module_path> "::" <identifier>
```

**Use lists** match the pattern:
```
<use_specifier> [ "," <use_specifier> [ "," <use_specifier> ... ] ]
```

**Use specifiers** take one of the following forms:
```
<identifier>
<identifier> "as" <identifier>
```

[ Note: The normative grammar production `use_decl` in Annex A §A.6 unifies import and use declarations. Statement termination follows §2.4 [lex.units] rules.
— end note ]

[2] `visibility_modifier` is limited to `public` for re-export intent; other visibility keywords belong to Clause 4.

[3] Statement termination interacts with implicit termination rules in §2.4; a newline suffices unless a continuation predicate applies.

#### §3.2.3 Constraints

[1] The `module_path` in any `import` or `use` shall resolve under §3.1.3; missing modules trigger diagnostics defined in §3.6.

[2] `public use` marks the clause as re-exporting the referenced items; its semantics are covered in §3.4.

[3] Aliases introduced with `as` must be valid identifiers (§2.3) and shall not collide with existing bindings. An import alias binds the module path to the alias for subsequent qualified references.

[4] Within a `use_list`, each specifier shall be unique; duplicates provoke diagnostic E03-100.

[5] Wildcard clauses (`:: *`) shall be expanded during scope formation (§3.3); conflicts at expansion time emit diagnostic E03-101.

[6] `qualified_path :: identifier` forms are resolved according to §3.5; ill-formed targets (missing or non-public items) are diagnosed in §3.4. A `qualified_path` whose head component is an import alias refers to the aliased module.

[7] `visibility_modifier` shall not appear on `import` declarations; attempts to do so provoke diagnostic E03-102.

#### §3.2.4 Semantics

[1] `import` declarations bring a module’s namespace into scope for qualified references. When an alias is provided, qualified references shall use the alias as the head component; otherwise the full module path is required. Imports establish the prerequisite for later `use` declarations (§4.3).

[2] `use` declarations introduce bindings into the current module scope. When marked `public`, those bindings are re-exported from the current module.

[3] The resulting bindings participate in scope formation rules (§4.3) and qualified-name resolution (§4.5).

[4] Wildcards expand to the set of public items exported by the target module at the time of analysis; the expansion respects visibility modifiers and re-export status described in §4.4.

#### §3.2.5 Examples

**Example 4.2.5.1 (Imports and uses):**

```cursive
import math::geometry          // qualified access: math::geometry::area
import math::statistics as statistics
use math::geometry::area_of_circle
public use math::geometry::{circumference as circle_circumference}
use statistics::*
```

[1] The module imports `math::geometry` for qualified access, adds the alias `statistics` for `math::statistics`, pulls `area_of_circle` unqualified, re-exports `circumference` under a new alias, and wildcard-imports all public items exposed by `statistics`.

**Example 4.2.5.2 - invalid (Duplicate specifier):**

```cursive
use math::geometry::{area_of_circle, area_of_circle}  // error[E03-100]
```

[2] Duplicate entries in the use list violate constraint [4].

**Example 4.2.5.3 - invalid (`public` on import):**

```cursive
public import math::geometry  // error[E03-102]
```

[3] Visibility modifiers on `import` are not permitted.

---


### §3.3 Module Scope Formation [module.scope]

#### §3.3.1 Overview

[1] Module scope formation defines how bindings introduced by `import`, `use`, and `public use` participate in the namespace of the enclosing module.

[2] The rules in this subclause ensure that imported modules are available for qualified references, that `use` declarations introduce explicit aliases, and that re-exports (`public use`) become part of the module’s outward interface.

[3] Scope formation interacts closely with Clause 5 (declaration binding) and Clause 6 (name resolution). Forward references are restricted to those clauses and Annex E §E.2.1.

#### §4.3.2 Constraints

[1] **Import availability.** For each `import module_path`, the referenced module shall exist and be reachable via the manifest-declared source roots (§4.1.3). Missing modules trigger diagnostic E04-205 (§4.6). When an alias is supplied, it becomes the preferred head component for subsequent qualified references.

[2] **Import idempotence.** Multiple `import` declarations referring to the same module path are permitted and shall not change semantics. Implementations may diagnose redundant imports as a quality-of-implementation feature but shall not reject them.

[3] **Alias uniqueness.** A `use` declaration shall not introduce a binding whose identifier matches an existing binding in the module scope. To avoid conflicts, use the `as` clause to provide a distinct alias. Violations raise diagnostic E04-200.

[4] **Wildcard determinism.** Expansion of `use module::path::*` shall be deterministic. If two exports from the target module map to the same identifier (after considering aliasing), diagnostic E04-201 shall be emitted and the importing module is ill-formed.

[5] **Public exposure.** `public use` shall only reference public items from the target module. Attempting to re-export an internal or private item raises diagnostic E04-204 (§4.4).

[6] **Evaluation order.** Scope formation shall treat all `use` declarations as if they were evaluated after parsing but before name resolution. No `use` may depend on bindings introduced later in the same module unless Clause 5 explicitly allows forward references.

[7] **Use prerequisites.** A `use` declaration is well-formed only if its referenced module path (or alias) resolves to an imported module in the current compilation unit. Violations emit diagnostic E04-202. This requirement prevents `use` from implicitly importing modules.

(7.1) The two-phase compilation model (§2.2 [lex.phases]) permits declarations to appear in any textual order. The prerequisite is semantic (the module must be imported) not temporal (the import need not precede the use textually). Implementations **shall** collect all `import` declarations during parsing before validating `use` declarations.

[ Note: This ensures that the complete set of imports is known before use-declaration validation proceeds, enabling forward references while maintaining deterministic resolution.
— end note ]

#### §4.3.3 Formal Rules

[1] The following inference rules capture the well-formedness of module imports and use bindings. Paragraph numbering resets at each rule for traceability.

[2]
[ Given: Module table $\mathbb{M}$ ]

$$
\frac{m \in \operatorname{dom}(\mathbb{M})}{\mathbb{M} \vdash \text{Import}(m)}\tag{WF-Import}
$$

[3] Rule WF-Import requires the referenced module path `m` to exist in the module table derived from manifest roots.

[4]
[ Given: Scope $S$, identifier $a$, binding $b$ ]

$$
\frac{a \notin S \qquad \text{binding}(b)}{S \vdash \text{UseBind}(a, b)}\tag{WF-Use-Binding}
$$

[5] Rule WF-Use-Binding requires `a` to be fresh within scope `S` and the referenced entity to be a valid binding. When freshness fails, diagnostic E04-200 applies.

[6]
[ Given: Scope $S$, identifier $a$, binding $b$ ]

$$
\frac{\text{binding}(b) \qquad \text{visibility}(b) = public}{S \vdash \text{PublicUse}(a, b)}\tag{WF-Public-Use}
$$

[7] Rule WF-Public-Use enforces that re-exported bindings originate from public items before entering the exporting scope.

[8]
[ Given: Imported module set $\mathbb{I}$ ]

$$
\frac{p \in \mathbb{I}}{\mathbb{I} \vdash \text{UsePrereq}(p)}\tag{WF-Use-Prerequisite}
$$

[9] Rule WF-Use-Prerequisite formalises constraint [7]; the module path (or alias) `p` drawn from the `use` statement must appear in the imported module set `𝕀`. When an alias is introduced, both the canonical module path and alias are inserted into `𝕀`.

#### §4.3.4 Semantics

##### §4.3.4.1 Import Semantics

[1] An `import` declaration records a dependency between the current module and the referenced module. Implementations shall ensure the referenced module is compiled (or otherwise available) before name resolution proceeds. The import table records both the canonical module path and any alias supplied by the programmer.

[2] Each import contributes entries to the module's **alias map**, a deterministic mapping from identifier → module path. The canonical module name is always inserted; when an alias is present, the alias is inserted as a distinct key that resolves to the same module path. Clause 6 consumes the alias map when performing qualified lookup so that constructs such as `stats::mean` resolve predictably.

[3] Alias-map identifiers do not introduce standalone bindings. They may only appear as the leading component of a qualified name (`alias::item`). Using an alias without a following `::` is ill-formed and should be diagnosed via the lookup rules in Clause 6.

[4] `import` does not introduce a new binding. Qualified references use the module path directly (e.g., `math::geometry::area`).

##### §4.3.4.2 Use Semantics

[3] A `use` declaration introduces bindings into the module scope according to the forms specified in §4.2.2. Each binding records: (a) the originating module path, (b) the imported identifier, and (c) any alias applied via `as`.

[4] Wildcard imports expand to the set of public items exported by the target module at scope-formation time. Expansion observes aliases declared in the exporting module; each resulting identifier behaves as if introduced by an explicit `use` of the same form.

[5] When expansion encounters an identifier already present in scope, the importer shall issue diagnostic E04-201 and treat the module as ill-formed. Implementations may suggest explicit aliases to disambiguate. `use` declarations that introduce aliases shall also update the alias map so that Clause 6 can disambiguate between module heads and value bindings.

[6] If the wildcard head component is an import alias, expansion is evaluated against the aliased module.

##### §4.3.4.3 Re-export Semantics

[1] A `public use` re-export introduces bindings into the current module scope (for local use) and simultaneously marks them for inclusion in the module’s export set. Re-exported aliases are exported under the alias name; the original name is not automatically re-exported unless an explicit binding is introduced.

[2] Re-exported bindings participate in visibility checks during downstream imports exactly as if they had been declared `public` within the module. If the referenced item is not public in the source module, diagnostic E04-204 shall be emitted at scope-formation time.

#### §4.3.5 Examples

**Example 4.3.5.1 (Alias and re-export):**

```cursive
import math::geometry as geometry
use geometry::area_of_circle as area
public use geometry::{circumference as circle_circumference}
```

[1] The identifier `area` is available within the module. `circle_circumference` is both locally accessible and exported for downstream modules.

**Example 4.3.5.2 - invalid (Alias conflict):**

```cursive
import math::geometry
use math::geometry::area_of_circle
use math::geometry::area_of_circle as area_of_circle  // error[E04-200]
```

[2] The second `use` attempts to introduce `area_of_circle` again without using `as` to provide a distinct alias, provoking diagnostic E04-200.

**Example 4.3.5.3 - invalid (Wildcard conflict):**

```cursive
import math::geometry
import math::statistics
public use math::geometry::*
public use math::statistics::*  // error[E04-201] if both export `mean`
```

[3] If both modules export an identifier named `mean`, the wildcard expansion conflicts, making the importing module ill-formed.

#### §4.3.6 Integration

[1] Clause 5 shall treat bindings introduced by `use` as declarations for the purposes of visibility checks. Clause 6 leverages the recorded origin information when resolving qualified and unqualified names.

[2] Annex E §E.2.1 extends the module resolution algorithm to include scope-formation diagnostics (E04-200, E04-201) so tooling can surface conflicts consistently.


### §3.4 Export, Import, and Re-export Interactions [module.export]

#### §3.4.1 Overview

[1] This subclause specifies how modules expose declarations to other modules, how `use` bindings participate in the export set, and which diagnostics govern attempts to re-export inaccessible items.

[2] Clause 4 governs the declarations themselves; this clause focuses on how visibility modifiers and `public use` statements determine the observable surface of a module.

[3] Forward references: §2.5 (compilation units), §4.3 (scope formation), Clause 5 (declaration visibility), Clause 6 (name resolution), Annex A §A.7 (grammar), Annex E §E.2.1 (module resolution algorithm).

#### §4.4.2 Constraints

[1] **Visibility gate.** A declaration contributes to the module’s export set if and only if it is declared `public` or is re-exported via `public use`. All other declarations are confined to the defining module (§5.6).

[2] **Re-export access.** `public use module::item` is well-formed only when `item` is exported by `module`. Violations emit diagnostic E04-204 and the re-export is rejected.

[3] **Alias stability.** When `public use` renames an item, the alias becomes the exported identifier. The original name is exported only if another binding (local or re-export) supplies it.

[4] **Conflict detection.** Two exported bindings in the same module shall not share the same identifier. To avoid conflicts, use the `as` clause in `public use` declarations to provide distinct aliases. Re-export collisions (including wildcard expansion) provoke diagnostic E04-203.

[5] **Wildcard exports.** `public use module::*` exports every public item that survives wildcard expansion after applying §4.3.4.2. The importing module is responsible for resolving conflicts introduced by wildcards.

[6] **Import alias exports.** Import aliases created with `import module as alias` do not enter the export set automatically. To expose the alias, the module shall declare a `public use` that binds the alias explicitly.

[7] **Metadata propagation.** Re-exported declarations retain documentation comments, diagnostics metadata, and stability annotations from their original definition unless supplemented with informative local annotations that do not contradict the source.

[8] **Visibility chain.** If module `A` re-exports an item from module `B`, and `B` re-exported it from module `C`, visibility is determined by the final `public` status in `C` and by every intermediate `public use`. Any non-public link diagnoses E04-204 at the point of failure.

[9] **Modules with no public exports.** A module may have an empty export set (no `public` declarations and no `public use` re-exports). Such modules are well-formed and may be imported for their side effects (e.g., module-level initialisation) or internal use, but contribute no bindings to importing modules' namespaces. No diagnostic is emitted for empty export sets.

#### §4.4.3 Formal Judgments

[ Given: Module export set $\mathbb{E}$, declaration $d$ ]

$$
\frac{\text{visibility}(d) = public}{\mathbb{E} \vdash \text{AddExport}(d)}\tag{WF-Export}
$$

[1] Rule WF-Export adds a declaration to the export set when the declaration itself is `public`.

[ Given: Scope $S$, binding $b$, alias $a$ ]

$$
\frac{S \vdash \text{UseBind}(a,b) \qquad \text{visibility}(b) = public}{\mathbb{E} \vdash \text{AddReexport}(a,b)}\tag{WF-Reexport}
$$

[2] Rule WF-Reexport promotes a `public use` binding into the export set under alias `a`.

[ Given: Export set $\mathbb{E}$, identifier $a$ ]

$$
\frac{a \in \mathbb{E}}{\mathbb{E} \vdash \text{RejectDup}(a)}\tag{WF-Reexport-Conflict}
$$

[3] Rule WF-Reexport-Conflict captures constraint [4]; duplicate exported identifiers trigger diagnostic E04-203 unless resolved via `as` aliases.

#### §4.4.4 Semantics

##### §4.4.4.1 Export Set Construction

[1] Implementations build a module’s export set after scope formation (§4.3). Each `public` declaration in the module adds itself (WF-Export). Re-exported items contribute according to WF-Reexport.

[2] Export sets are ordered only for presentation; semantically they behave as maps from identifiers to bindings.

[3] When two bindings map to the same exported identifier, the module is ill-formed (WF-Reexport-Conflict). Implementations shall report E04-203 and may offer suggestions such as introducing aliases.

##### §4.4.4.2 Qualified Access

[4] A module may access its own exported items via unqualified names and may access other modules’ exports via qualified names (`module::item`), subject to Clause 6 lookup rules.

[5] Import aliases do not alter the exported identifier; they merely shorten the qualified path within the importing module.

##### §4.4.4.3 Re-export Metadata

[6] Re-exported bindings retain diagnostic obligations (for example, required contracts) and stability annotations. Tooling shall attribute documentation to both the originating module and the re-exporting module.

[7] Informative annotations attached locally (such as additional documentation comments) may supplement but shall not contradict the originating documentation. When conflicts arise, implementations shall prefer the originating declaration for normative content while retaining local annotations as informative notes.

#### §4.4.5 Examples

**Example 4.4.5.1 (Selective re-export):**

```cursive
// module analytics::reporting
import analytics::statistics as stats
public use stats::{mean, median as middle_value}

public record Report { values: [f64] }

public procedure summarize(report: Report): ReportSummary
    [[ |- true => true ]]
{
    result ReportSummary {
        mean: mean(report.values),
        median: middle_value(report.values),
    }
}
```

[1] `mean` is exported under its original name; `median` is exported as `middle_value`. Both originate from `analytics::statistics`.

**Example 4.4.5.2 - invalid (Private re-export):**

```cursive
// module data::store
import data::backend
public use backend::connection_pool  // error[E04-204] if `connection_pool` is not public
```

[2] The re-export fails because `connection_pool` is not public in `data::backend`.

**Example 4.4.5.3 - invalid (Duplicate export):**

```cursive
// module math::geometry
public procedure area(circle: Circle): f64
    [[ |- true => true ]]
{ ... }

import math::legacy as legacy
public use legacy::{area as legacy_area}

// accidental duplicate
public use legacy::{area}  // error[E04-203]
```

[3] The final `public use` re-exports `area` again, colliding with the existing `public procedure area`.

#### §4.4.6 Integration

[1] Clause 6 relies on the export set to answer qualified lookups. Annex E §E.2.1 shall record export-set construction so tooling exposes re-export origins.

[2] Diagnostics introduced here: E04-203 ("duplicate exported identifier") supplements E04-204 ("non-public re-export") and the wildcard conflict diagnostics defined earlier in this clause.


### §3.5 Qualified Names and Resolution [module.qualified]

#### §3.5.1 Overview

[1] This subclause defines how qualified names are formed (`module::identifier`, `alias::identifier`) and how the resolver locates declarations across module boundaries.

[2] Resolution depends on the module table (§3.1), scope bindings (§3.3), and export sets (§3.4).

[3] Forward references: §2.3 (identifiers), Clause 5 (declaration categories), Clause 6 (unqualified lookup), Annex A §A.7 (grammar), Annex E §E.2.1 (resolution algorithm).

#### §4.5.2 Syntax

[1] Qualified names use the scope operator `::` and match one of the following patterns:

```
<module_path> "::" <identifier>
<identifier> "::" <identifier>
```

where the first form uses a full module path, and the second form uses an alias (an identifier introduced by `import module as alias`) in place of the module path.

[ Note: The normative grammar in Annex A §A.6 represents both forms as `module_path '::' ident | ident '::' ident`, treating aliases as identifiers that semantically resolve to module paths.
— end note ]

[2] `module_path` expands per §4.1.

#### §4.5.3 Constraints

[1] **Canonical head.** The head component of a qualified name shall match an imported module path or alias recorded under §4.3.4.1. Otherwise diagnostic E04-400 is issued.

[2] **Export availability.** The identifier following the head component shall exist in the export set of the head module. Missing identifiers raise diagnostic E04-404.

[3] **Ambiguity avoidance.** The resolver shall not disambiguate identically named modules. Programmers shall introduce distinct aliases; failure yields diagnostic E04-401.

[4] **Stable ordering.** When a qualified name contains multiple components (e.g., `pkg::subpkg::item`), resolution shall verify each prefix against the module table from left to right. A prefix that does not resolve emits diagnostic E04-402.

[5] **Alias immutability.** Once an alias is bound, subsequent `import ... as ...` statements shall not rebind the same alias to a different module. Violations produce diagnostic E04-403.

[6] **No implicit traversal.** Resolution stops at the first module boundary that exports the identifier. Private or internal bindings are never traversed implicitly.

#### §4.5.4 Formal Judgments

[ Given: Module table $\mathbb{M}$, export map $\mathbb{E}$ ]

$$
\frac{m \in \operatorname{dom}(\mathbb{M}) \qquad x \in \mathbb{E}(m)}{\mathbb{M}, \mathbb{E} \vdash m::x \Rightarrow \text{Binding}(m,x)}\tag{QR-Resolve}
$$

[1] Rule QR-Resolve succeeds when both the module path `m` exists and the identifier `x` is exported from `m`.

[ Given: Alias map $\mathbb{A}$ ]

$$
\frac{a \in \operatorname{dom}(\mathbb{A}) \qquad \mathbb{M}, \mathbb{E} \vdash \mathbb{A}(a)::x \Rightarrow b}{\mathbb{A}, \mathbb{M}, \mathbb{E} \vdash a::x \Rightarrow b}\tag{QR-Alias}
$$

[2] Rule QR-Alias substitutes the alias head with its canonical module path before delegating to QR-Resolve.

[ Given: Alias map $\mathbb{A}$ ]

$$
\frac{a \in \operatorname{dom}(\mathbb{A}) \qquad \mathbb{A}(a) = m}{\mathbb{A} \vdash \text{AliasStable}(a,m)}\tag{QR-Alias-Stability}
$$

[3] Rule QR-Alias-Stability ensures aliases remain bound to their original module.

#### §4.5.5 Semantics

##### §4.5.5.1 Resolution Pipeline

[1] Resolution proceeds in three stages: (a) head verification (module or alias), (b) export lookup, and (c) binding retrieval.

[2] Implementations shall surface diagnostics at the earliest failing stage. A missing head triggers E04-400 or E04-402; a missing export triggers E04-404.

##### §4.5.5.2 Diagnostics

[3] Diagnostics shall include contextual information and, where possible, heuristic suggestions:

- **E04-400** — Unrecognised module or alias head `<head>`.
- **E04-401** — Ambiguous qualified head `<component>`; add explicit aliases.
- **E04-402** — Partial module path `<prefix>` does not resolve to a module.
- **E04-403** — Alias `<alias>` already bound to `<module>`; cannot rebind.
- **E04-404** — Item `<identifier>` not exported from `<module>` (with notes indicating traversal history).

[4] Heuristic suggestions may include near-miss module names, possible aliases, or exported identifiers differing by edit distance, provided the suggestions are marked informative.

##### §4.5.5.3 Integration with Clause 6

[5] Clause 6 resolves unqualified identifiers using the bindings introduced by `use`. When source code explicitly employs `::`, resolution follows the rules in this subclause. There is no automatic fallback from unqualified names to qualified lookup.

#### §4.5.6 Examples

**Example 4.5.6.1 (Alias resolution):**

```cursive
import analytics::statistics as stats

procedure compute(metrics: Metrics): Analysis
    [[ |- true => true ]]
{
    result Analysis {
        spread: stats::variance(metrics.values),
        center: stats::mean(metrics.values),
    }
}
```

[1] `stats::variance` resolves by substituting the alias `stats` with `analytics::statistics` and applying QR-Resolve.

**Example 4.5.6.2 - invalid (Missing export):**

```cursive
import analytics::statistics

let bucket = analytics::statistics::histogram  // error[E04-404] if `histogram` is not public
```

[2] The identifier `histogram` fails the export lookup stage.

**Example 4.5.6.3 - invalid (Partial path):**

```cursive
import analytics::statistics
let m = analytics::stats::mean  // error[E04-402]; `analytics::stats` is not a module
```

[3] The resolver stops at `analytics::stats`, which does not correspond to a module path.

#### §4.5.7 Integration

[1] Annex E §E.2.1 shall expose the module table, alias map, and export sets for tooling so diagnostics can include trace data.

[2] Clause 6 diagnostic reporting shall suggest creating aliases when E04-401 occurs.


### §3.6 Cycles, Initialization Order, and Diagnostics [module.initialization]

#### §3.6.1 Overview

[1] This subclause defines how module dependencies form a directed graph, how module-level initialization order is derived, and which diagnostics apply to cyclic or ill-formed dependency structures.

[2] It refines §2.5 (module initialisers) and §3.1–§3.5 (module identity, scope, exports) by establishing deterministic rules for dependency classification, initialization execution, failure handling, and diagnostic reporting.

[3] Forward references: Clause 5 §5.7 [decl.initialization], Annex E §E.2.1 [implementation.algorithms], Annex E §E.5 [implementation.diagnostics].

#### §4.6.2 Constraints

[1] **Dependency graph.** Implementations shall construct a directed graph $G = (V, E)$ whose vertices are modules and whose edges record inter-module dependencies introduced by `import` and `public use` declarations as well as module-level references to external bindings.

[2] **Eager edge criterion.** An edge `m → n` is _eager_ when any of the following hold: - a module-level binding or `comptime` block in `m` directly reads a binding exported by `n` while initialising; - `m` performs `public use` of a binding in `n` whose declaration requires initialization (e.g., `let`, `var`, `comptime`-generated constant); - `m` re-exports `n::*` and the expansion includes any eager binding; - a diagnostic obligation in `m` requires evaluating a contract or grant in `n` during module initialization.

(2.1) **Eager/lazy classification algorithm.** Implementations shall classify edges using the following deterministic procedure: 1. Initialize all edges as _lazy_. 2. For each module `m` and each dependency `m → n`:
a. If `m` contains a module-level `let` or `var` binding whose initializer expression references any binding exported by `n`, mark `m → n` as _eager_.
b. If `m` contains a `comptime` block that references any binding exported by `n` during module initialization, mark `m → n` as _eager_.
c. If `m` performs `public use n::item` where `item` is a `let`, `var`, or `comptime`-generated constant, mark `m → n` as _eager_.
d. If `m` performs `public use n::*` and the wildcard expansion includes any binding that would make an edge eager per steps (a)–(c), mark `m → n` as _eager_. 3. Transitive closure: if `m → n` is eager and `n → p` is eager, then `m → p` inherits eager status for initialization ordering purposes (though the direct edge classification remains unchanged). 4. All edges not marked eager remain _lazy_.

[3] **Lazy edge criterion.** An edge `m → n` is _lazy_ when the only interactions are references to declarations that do not require immediate initialization—procedures, types, behaviors, or contracts whose bodies are not executed during module initialization. Lazy edges may form cycles.

(3.1) **Lazy edge examples.** The following interactions create lazy edges: - `m` imports `n` and references only procedure signatures (not bodies) - `m` references type declarations from `n` without reading their values - `m` references behavior or contract declarations from `n` without instantiating them - `m` performs `public use n::item` where `item` is a procedure, type, behavior, or contract declaration

[4] **Acyclic eager subgraph.** The subgraph containing all eager edges shall be acyclic. Detection of a cycle in this subgraph triggers diagnostic E04-500.

[5] **Initialization order.** Modules that participate in eager edges shall be initialised according to any topological ordering of the eager subgraph that preserves predecessor relationships.

[6] **Failure propagation.** If a module's initialization fails, every module that depends on it through an eager edge is blocked from initializing. Diagnostic E04-501 shall identify the blocked modules and the failing predecessor.

[7] **Deferred evaluation fidelity.** Implementations may evaluate module initializers lazily provided the observable behavior matches eager evaluation: each initializer runs at most once, dependencies remain respected, and no additional side effects occur.

[8] **Uninitialised access.** A module shall not read an eager binding from another module before that binding's initializer has completed successfully. Violations emit diagnostic E04-502 referencing the dependency chain.

[9] **Retry safety.** After an initialization failure, implementations may permit a retry during the same compilation provided they reset all side effects of the failed module and its blocked dependents. Retried modules shall re-execute in the established topological order.

#### §4.6.3 Formal Judgments

[ Given: Dependency graph $G = (V, E)$, eager edge set $E_e \subseteq E$ ]

$$
\frac{\exists C \subseteq V : C \neq \emptyset \land \text{Cycle}(C, E_e)}{G \vdash \text{RejectCycle}(C)}\tag{WF-Cycle}
$$

[1] Rule WF-Cycle rejects any set of modules forming a cycle using eager edges.

[ Given: Eager DAG $G_e = (V, E_e)$, total order $\prec$ ]

$$
\frac{v_1 \prec v_2 \prec \dots \prec v_n}{G_e \vdash \text{InitOrder}(v_1,\ldots,v_n)}\tag{WF-InitOrder}
$$

[2] Rule WF-InitOrder establishes a valid initialization order over the eager subgraph.

[ Given: Module $m$, predecessors $\operatorname{Pred}_e(m)$ ]

$$
\frac{\forall p \in \operatorname{Pred}_e(m).\, \text{Initialised}(p)}{\text{SafeInit}(m)}\tag{WF-SafeInit}
$$

[3] Rule WF-SafeInit ensures module $m$ may initialise only after all eager predecessors have completed successfully.

#### §4.6.4 Semantics

##### §4.6.4.1 Graph Construction

[1] The compiler analyses `import` and `public use` statements together with module-level expressions to classify edges per §4.6.2[2]–[3]. Dependencies discovered during `comptime` execution contribute eager edges when their results are required at initialization time.

[2] Lazy edges are retained for completeness but do not influence initialization ordering; they remain available for tooling and diagnostics.

##### §4.6.4.2 Cycle Handling

[3] When WF-Cycle fails, the implementation shall emit diagnostic E04-500. The diagnostic shall include a machine-readable list of modules in the cycle (Annex E §E.5 format) and a textual explanation naming each edge.

[4] Suggested refactorings may accompany the diagnostic as informative notes, but compilation fails for the affected modules until the cycle is removed.

##### §4.6.4.3 Initialization Execution

[5] Initialization executes modules in the order produced by WF-InitOrder. Each module records whether its initializer succeeded, failed, or was skipped due to upstream failure.

[6] On failure, the compiler emits E04-501 for each blocked module, referencing the original error and providing machine-readable dependency metadata. Implementations that support retries shall roll back side effects before reattempting initialization.

[7] Successful initialization marks all eager bindings defined in the module as ready for use. Repeated execution of the same initializer is prohibited.

##### §4.6.4.4 Diagnostics

[8] Diagnostics associated with this clause include:

- **E04-500** — "Module dependency cycle detected." Payload: ordered list of modules forming the cycle, each edge annotated with its eager classification reason.
- **E04-501** — "Module initialisation blocked." Payload: identifier of the blocked module, failing predecessor, and dependency path.
- **E04-502** — "Access to uninitialised module binding." Payload: requesting module, target binding, outstanding predecessors.
- **E04-503** — "Misclassified lazy dependency." Payload: module pair and evidence that the interaction required eagerly initialised data.

[ Note: Diagnostic E07-750 (Internal type referenced across module boundary) is defined in Annex E §E.5.1.2 and is emitted during type checking (Clause 7) when a non-public type is referenced across module boundaries. It is referenced here in §4.6.7[4] to document the interaction between module initialization and type checking phases.
— end note ]

[9] Structured payloads shall follow Annex E §E.5 so that diagnostics are machine-readable and suitable for tooling consumption.

#### §4.6.5 Examples

**Example 4.6.5.1 (Valid ordering):**

```text
module analytics::core       // no eager initialisers
module analytics::config     // eager: let CONFIG = load_config()
module analytics::reporting  // eager: reads CONFIG during initialisation
```

[1] The eager subgraph forms the order `analytics::config → analytics::reporting`; `analytics::core` has only lazy edges and can initialise at any point.

**Example 4.6.5.2 - invalid (Cycle):**

```text
module input::parser      // eager edge: builds table using output::formatter
module output::formatter  // eager edge: initialises inverse map using input::parser
```

[2] The eager cycle `parser ↔ formatter` triggers E04-500 with the cycle list `[input::parser, output::formatter]`.

**Example 4.6.5.3 - invalid (Uninitialised access):**

```text
module data::cache
import data::tables
let DEFAULT = tables::DEFAULT_TABLE  // eager edge
```

[3] If `data::tables` fails to initialise `DEFAULT_TABLE`, `data::cache` receives E04-501 and any attempt to read `DEFAULT` produces E04-502.

#### §4.6.6 Integration

[1] Annex E §E.2.1 shall define algorithms for constructing the eager dependency graph, detecting cycles, and orchestrating initialization retries.

[2] Clause 5 §5.7 shall treat module-level bindings as defined only after WF-SafeInit succeeds for their module.

[3] Annex E §E.5 shall include structured diagnostic schemas for E04-500–E04-503 to ensure consistent reporting across tooling.

#### §4.6.7 Interaction with Type Checking [module.type.integration]

[4] Type-checking obligations for exported types, generic instantiation, and contract verification are specified in Clause 7 (§7.1.5). This subclause establishes the following normative requirements:

**Ordering Constraints:**

(4.1) Module initialization (including eager bindings) **shall** complete successfully before Clause 7 semantic analysis begins for any module. Implementations **shall not** perform type checking on a module whose eager dependencies have not been initialized.

(4.2) Type checking proceeds in module dependency order: if module `m` imports module `n`, then `n` **shall** be fully type-checked (all declarations validated, all types resolved) before type-checking expressions in `m` that reference `n`'s exports.

**Cross-Module Visibility Rules:**

(4.3) When a module `m` references a type `T` exported from module `n`:

1. `T` **shall** be declared `public` in `n` (diagnostic E07-750 if internal or private)
2. The fully-qualified type name `n::T` **shall** resolve during qualified lookup (§4.5)
3. Generic instantiations `T<Args>` **shall** satisfy visibility constraints for all type arguments

(4.4) When a generic type from module `n` is instantiated in module `m`, all type parameters **shall** either be:

- Public types from any module, OR
- Internal/private types from `m` itself, OR
- Types visible in `m` through import/use declarations

Attempting to instantiate a generic with an inaccessible internal type from a third module **shall** produce diagnostic E07-750.

**Contract and Witness Integration:**

(4.5) Contract implementations (predicates, witnesses) attached to exported types **shall** be complete and validated before the type becomes visible to importing modules. If a type declares a contract clause but lacks required implementations, diagnostic E05-506 applies (see §5.5.3[14]).

(4.6) Implementations **shall** report diagnostic E07-750 (internal type access violation) when:

- A `public` procedure signature exposes an `internal` or `private` type
- A `public` type's field has a type that is not accessible from importing modules
- A `public use` re-export would expose an internal type

**Diagnostic Responsibilities:**

(4.7) Clause 7 specifies type formation rules; Clause 4 specifies visibility rules. When both are violated simultaneously, implementations **should** emit the visibility diagnostic (E07-750, E04-701) before the type error diagnostic to help programmers understand the root cause.


### §4.1 Declaration Overview [decl.overview]

#### §4.1.1 Overview

[1] Clause 4 specifies the syntactic and semantic forms that introduce names in Cursive programs. A _declaration_ binds an identifier to a category (value, type, callable, predicate, contract, or grant), assigns visibility and storage attributes, and determines how later references participate in the permission, grant, and modal systems.

#### §4.1.2 Declaration Categories

[3] Every declaration belongs to exactly one of the following categories:

- **Variable bindings** (`let`, `var`, `shadow let`, `shadow var`) introduce bindings with explicit mutability and optional pattern destructuring.
- **Binding patterns** extend variable bindings with structured destructuring that binds multiple identifiers simultaneously.
- **Callable declarations** (`procedure`, `comptime procedure`, `extern procedure`) introduce named computations, including their parameter lists, contracts, and grant obligations.
- **Type declarations** (`record`, `enum`, `modal`, `type`) introduce nominal or transparent types into the unified namespace.
- **Visibility modifiers** (`public`, `internal`, `private`, `protected`) refine the accessibility of the associated declaration.
- **Auxiliary declarations** (behaviors, contracts, grants) rely on their dedicated clauses for semantics but use this clause for name introduction and visibility rules. Grant declarations are specified in §5.9 [decl.grant]; grant system semantics are specified in Clause 12 [contract].

[4] Declarations located at module scope participate in module initialisation ordering (§4.6) and contribute to the program entry model (§5.8). Declarations inside block scopes follow the storage-duration rules established in §5.7 and the scoping rules of Clause 6.

#### §5.1.3 Namespace and Scope Invariants

[5] Cursive maintains a single lexical identifier namespace per scope: within a given scope, types and values share the same identifier space. Redeclaration within that scope is ill-formed. Shadowing an outer-scope binding requires an explicit `shadow` keyword.

[6] Two-phase compilation (§2.2) guarantees that declarations may appear in any order within a translation unit. Parsing records the complete declaration inventory before semantic analysis, so forward references are resolved without separate stub declarations.

#### §5.1.4 Examples (Informative)

**Example 5.1.5.1 (Representative module declarations):**

```cursive
public record Account { id: u64, balance: i64 }

use bank::ledger::post_entry

let DEFAULT_LIMIT = 10_000
shadow var session_state = Session::new()

public procedure create_account(id: u64): Account
{
    result Account { id, balance: 0 }
}
```

[1] This module defines a public record, imports a ledger operation, introduces immutable and mutable bindings, and exposes a callable—all forms elaborated in subsequent subclauses.

### §5.1.5 Conformance Requirements [decl.overview.requirements]

[1] Implementations shall recognise each declaration category enumerated in §5.1.2 and apply the specialised rules defined in §§5.2–5.8 to every occurrence.

[2] Implementations shall enforce the single lexical identifier namespace described in §5.1.3 and require `shadow` when redeclaring identifiers from an enclosing scope.


### §4.2 Variable Bindings and Initialisers [decl.variable]

#### §4.2.1 Overview

[1] Variable bindings introduce identifiers into the lexical namespace with explicit binding mutability (`let`, `var`) and optional pattern destructuring.

[2] Bindings may appear at module scope or within block scopes; their storage duration and initialisation ordering depend on location (§4.7, §3.6).

[3] This subclause defines binding syntax, pattern forms, initialiser requirements, and the interaction with shadowing, permissions, and compile-time constants.

#### §4.2.2 Syntax

[ Note: See Annex A §A.5 [grammar.statement] for the normative `var_decl_stmt` production. — end note ]

[3] Variable bindings consist of a binding head (`let`, `var`, `shadow let`, or `shadow var`), a pattern (identifier or destructuring), an optional type annotation, a binding operator (`=` for responsible or `<-` for non-responsible), and an initializer expression.

[1] Every binding introduces at least one identifier. Patterns specify that identifier set explicitly; anonymous bindings are ill-formed.

[2] When a pattern binds more than one identifier, a `:{Type}` annotation is mandatory and applies uniformly to every identifier in the pattern.

[3] `initializer` must be present for every binding form. The binding operator determines whether the binding is responsible for cleanup (`=`) or non-responsible (`<-`).

[4] **Type independence.** The type of the binding is determined by the initializer expression and is independent of the binding operator choice. Both `let x: T = value` and `let x: T <- value` create bindings of type `T`; the difference lies in cleanup responsibility (binding metadata), not in the type itself.

#### §4.2.3 Constraints

[1] _Explicit shadowing._ `shadow let` and `shadow var` shall only appear when an enclosing scope already defines the same identifier. Violations: E05-201.

[2] _Single assignment._ `let` bindings shall not be reassigned after initialisation. `var` bindings may be reassigned. Violations: E05-202.

[3] _Pattern uniformity._ Multi-identifier patterns require a type annotation `:{Type}` that applies to every identifier in the pattern. All identifiers in the pattern must be distinct. Violations: E05-203.

[4] _Initialiser completeness._ The initialiser expression shall provide values for every identifier in the pattern. Violations: E05-204.

[5] _Compile-time constants._ A binding is a compile-time constant only when it is a module-scope `let` with a compile-time evaluable initialiser or a binding declared within a `comptime` block. Function- or block-scope bindings remain runtime values regardless of their initialiser expression.

[6] _Permission independence._ Binding mutability controls reassignment, not value mutation. Value mutation permissions arise from the type's permission qualifiers or region attributes (§11.4).

[7] _Forward references._ Due to two-phase compilation (§2.2), bindings may reference declarations that appear later in the translation unit. Shadowing rules are evaluated after parsing, ensuring forward references do not bypass explicit shadow requirements.

#### §4.2.4 Semantics

[1] Binding introduction inserts the identifier or identifiers into the current lexical scope's namespace, honouring the single-namespace rule (§5.1.3) and shadowing constraints.

[2] For patterns, the initialiser expression is evaluated once; its value is destructured into the constituent bindings. The implementation behaves as if a temporary value were created, followed by individual bindings drawing from that value.

[3] Module-scope bindings participate in the eager dependency graph (§3.6); their initialisers shall not depend on bindings that, directly or indirectly, require the binding being initialised.

[4] Pattern bindings do not change visibility or storage semantics: each identifier inherits the visibility modifier and scope of the encompassing binding.

[5] The binding operator (`=` or `<-`) does not affect the binding's type but determines whether the binding is recorded as responsible or non-responsible in the binding table (§5.3). This metadata is used by move checking (Clause 9) and definite assignment analysis (§4.7) but does not participate in type checking (Clause 6).

#### §4.2.5 Binding Operator Semantics [decl.variable.operator]

##### §4.2.5.1 Value Assignment Operator (`=`)

[5] The value assignment operator `=` creates a responsible binding. The binding assumes cleanup responsibility for the value and shall invoke the value's destructor when the binding goes out of scope.

**Formation:**

```cursive
let identifier: Type = expression     // Responsible, non-rebindable
var identifier: Type = expression     // Responsible, rebindable
```

**Cleanup Responsibility:**

[6] At scope exit, the binding's destructor is invoked in LIFO order (§11.2). If the binding was created with `let`, it may transfer responsibility via the `move` keyword (§11.5). If the binding was created with `var`, responsibility cannot be transferred but the binding may be rebound in place.

**Example 4.2.5.1 (Responsible bindings):**

```cursive
{
    let resource = File::open("data.txt")   // Responsible binding
    // Use resource...
}  // resource.drop() called automatically
```

##### §4.2.5.2 Non-Responsible Binding Operator (`<-`)

[7] The non-responsible binding operator `<-` creates a binding that does NOT assume cleanup responsibility. The binding shall NOT invoke a destructor when it goes out of scope.

[ Note: The `<-` operator does NOT create a reference type or pointer type. Both `let x: T = value` and `let x: T <- value` create bindings of type `T`; the difference is only in cleanup responsibility (binding metadata), not in the type itself. The terminology "non-responsible binding" emphasizes that this is about cleanup semantics, not type semantics.
— end note ]

**Formation:**

```cursive
let identifier: Type <- expression    // Non-responsible, non-rebindable
var identifier: Type <- expression    // Non-responsible, rebindable
```

**Type Semantics:**

[8] The type of a binding created with `<-` is identical to the type of the initializer expression. The `<-` operator creates a non-responsible binding to the value with the value's type but without cleanup responsibility. It does NOT create a reference type, pointer type, or any other type-level construct.

**Example 4.2.5.2 (Type preservation):**

```cursive
let buffer: Buffer = Buffer::new()     // Type: Buffer, responsible
let ref: Buffer <- buffer              // Type: Buffer, non-responsible
// Both bindings have type Buffer
// Only difference is cleanup responsibility (binding metadata)
```

**Non-Responsibility:**

[9] Non-responsible bindings do not call destructors:

```cursive
let owner = Resource::new()
{
    let viewer <- owner                // Non-responsible binding
    viewer.read()                      // Access value
}  // viewer.drop() NOT called (owner still responsible)
// owner still valid here
```

**Multiple Non-Responsible Bindings:**

[10] Multiple non-responsible bindings to the same value are permitted:

```cursive
let data = load_data()
let view1 <- data
let view2 <- data
let view3 <- data
// All three non-responsible bindings valid simultaneously
// Only 'data' will call destructor at scope exit
```

**Invalidation After Responsibility Transfer:**

[11] Non-responsible binding validity and invalidation rules are specified completely in §5.7.5 [decl.initialization]. In summary, non-responsible bindings become invalid when the source binding is moved to a responsible parameter (one with the `move` modifier), as the object might be destroyed by the callee.

[12] This invalidation propagation prevents use-after-free: when a value's ownership transfers to a procedure that might destroy it, all references derived from the original binding become inaccessible. The compiler tracks dependencies through definite assignment analysis with zero runtime overhead.

**Transferability:**

[13] Non-responsible bindings cannot be moved because they have no cleanup responsibility to transfer. Violations: E11-502.

##### §4.2.5.3 Binding Operator Choice

[14] The choice between `=` and `<-` determines cleanup responsibility:

| Operator | Cleanup Responsibility | Destructor Called   | Transferable via `move` |
| -------- | ---------------------- | ------------------- | ----------------------- |
| `=`      | YES                    | YES (at scope exit) | YES (if `let`)          |
| `<-`     | NO                     | NO                  | NO                      |

[15] The binding operator is orthogonal to rebindability (`let` vs `var`) and permissions (`const`, `unique`, `shared`), creating a fully compositional binding system.

##### §4.2.5.4 Validity and Invalidation Rules

[15.1] **Summary of non-responsible binding lifetime tracking**:

Non-responsible bindings reference **objects**, not bindings. Their validity depends on whether the object exists:

**Remains valid when**:

- Source binding is in scope and not moved
- Source binding is passed to non-responsible parameters (no `move` at call site)
- Object is guaranteed to survive (non-destroying callees)

**Becomes invalid when**:

- Source binding is moved to responsible parameter (`move` at call site)
- Source binding's scope ends (object destroyed)
- Non-responsible binding's own scope ends

The compiler uses **parameter responsibility** (visible in procedure signatures) to approximate object destruction at compile time, maintaining zero runtime overhead while preventing use-after-free.

##### §4.2.5.5 Rebinding Semantics

[16] `var` bindings may be rebound using the same assignment operator:

**Responsible `var` rebinding:**

```cursive
var data = Buffer::new()               // Responsible
data = Buffer::new()                   // Old buffer destroyed, new buffer bound
```

When rebinding a responsible `var`, the old value's destructor is invoked before the new value is assigned.

**Non-responsible `var` rebinding:**

```cursive
var ref <- buffer1                     // Non-responsible
ref <- buffer2                         // Rebind to different object (no cleanup)
```

When rebinding a non-responsible `var`, no destructor is invoked; the binding simply refers to a different value.

#### §4.2.6 Additional Examples [decl.variable.examples]

[ Note: Examples demonstrating the interaction between binding operators and parameter responsibility are provided in §4.4.5 [decl.function] and §4.7.5 [decl.initialization]. — end note ]

**Example 4.2.6.2 (Rebinding with different operators):**

```cursive
var responsible = Data::new()          // Responsible, rebindable
responsible = Data::new()              // Old value destroyed, new value bound

var non_responsible <- some_value      // Non-responsible, rebindable
non_responsible <- other_value         // Rebind to different object (no cleanup)
```

**Example 4.2.6.3 - invalid (Implicit shadowing):**

```cursive
let limit = 10
{
    let limit = limit + 5  // error[E04-201]: use 'shadow let limit'
}
```

**Example 4.2.6.4 - invalid (Pattern arity mismatch):**

```cursive
let {left, right}: Pair = make_triple()  // error[E04-204]
```

**Example 4.2.6.5 - invalid (Move from non-responsible binding):**

```cursive
let buffer = Buffer::new()
let ref <- buffer
consume(move ref)                      // error[E10-502]: cannot move non-responsible binding
```

#### §4.2.7 Conformance Requirements [decl.variable.requirements]

[1] Implementations shall track cleanup responsibility and invalidation per binding operator semantics specified in §4.2.5.

[2] Module-scope bindings shall participate in the dependency analysis of §3.6; implementations shall detect initialiser cycles (E04-701) and block dependent initialisers per §4.7.


### §4.3 Binding Patterns [decl.pattern]

#### §4.3.1 Overview

[1] Binding patterns provide declarative destructuring for variable bindings. They allow a single declaration to introduce multiple identifiers by projecting fields or positional elements from a composite value.

[2] Patterns currently apply only to variable bindings (§4.2). Other constructs (parameters, match expressions) reference their own pattern grammars when available.

[3] Patterns preserve the visibility, storage duration, and shadowing behaviour of the enclosing binding.

#### §5.3.2 Syntax

**Binding patterns** take one of the following forms:
```
<identifier>
"{" <record_field_list> "}"
"(" <pattern_list> ")"
```

**Record field lists** match the pattern:
```
<record_field> [ "," <record_field> [ "," <record_field> ... ] ]
```

**Record fields** take one of the following forms:
```
<identifier>
<identifier> "as" <identifier>
<identifier> ":" <binding_pattern>
```

**Pattern lists** match the pattern:
```
<binding_pattern> [ "," <binding_pattern> [ "," <binding_pattern> ... ] ]
```

[ Note: See Annex A §A.3 [grammar.pattern] for the normative pattern grammar.
— end note ]

[1] `record_pattern` binds named fields; an optional `as` clause renames the bound field while preserving the source field name. `tuple_pattern` binds positional elements in order.

[2] Patterns appear within a variable binding as `let pattern: Type = initializer` or `var pattern: Type = initializer`. The type annotation applies to the whole pattern when it contains more than one identifier.

#### §5.3.3 Constraints

[1] _Type annotation required._ Any pattern containing more than one identifier shall include a type annotation of the form `:{Type}` in the enclosing binding. The annotated type must be compatible with the pattern shape (record or tuple). Missing annotations yield diagnostic E05-304.

[2] _Field matching._ Each `record_field` must correspond to a field in the annotated record type. Unknown fields raise diagnostic E05-301. When `field as binding` is used, `field` references the record field name and `binding` names the introduced identifier.

(2.1) _Partial matching._ Pattern matching is all-or-nothing: if any field in a record pattern fails to match (unknown field name) or any element in a tuple pattern has incorrect arity, the entire pattern binding is ill-formed and no bindings are introduced. Implementations shall emit a single diagnostic (E05-301 for record fields, E05-302 for tuple arity) and treat the binding as failed. Partial success is not permitted.

[3] _Tuple arity._ Tuple patterns shall list exactly the number of elements present in the annotated tuple type. Mismatches produce diagnostic E05-302.

[4] _Distinct identifiers._ Identifiers introduced by a pattern shall be unique within that pattern. Duplicates cause diagnostic E05-303.

[5] _Nested patterns._ Patterns may nest arbitrarily: record and tuple patterns may contain nested record, tuple, or identifier patterns. Each level of nesting follows the same typing rules recursively. The pattern as a whole shall type-check against the initializer expression's type.

[6] _Initialiser evaluation._ The initializer expression is evaluated once. Implementations may behave as if a temporary value were created and then projected recursively into individual bindings according to the pattern structure.

[7] _Visibility inheritance._ Identifiers introduced by the pattern inherit the visibility modifier and scope of the enclosing binding.

#### §5.3.4 Semantics

[1] Record pattern `let {field as name}: RecordType = expr` binds `name` to `expr.field`. Absent `as`, the binding identifier matches the field name.

[2] Tuple pattern `let (left, right): (T0, T1) = expr` binds `left` to the tuple’s element at index 0 and `right` to index 1.

[3] Patterns do not retain a reference to the composite value after destructuring; only the introduced identifiers remain in scope.

#### §5.3.5 Examples (Informative)

**Example 5.3.5.1 (Record pattern with renaming):**

```cursive
let {x, y as vertical}: Point2 = current_position()
// Binds identifiers `x` and `vertical` of type Point2
```

**Example 5.3.5.2 - invalid (Missing annotation):**

```cursive
let {real, imag} = complex_value  // error[E05-304]
```

**Example 5.3.5.3 (Tuple pattern):**

```cursive
let (min, max): (i32, i32) = bounds()
```

**Example 5.3.5.4 - invalid (Unknown record field):**

```cursive
let {width}: Point2 = current_position()  // error[E05-301]
```

### §5.3.6 Conformance Requirements [decl.pattern.requirements]

[1] Implementations shall require type annotations for multi-identifier patterns (E05-304) and ensure that record and tuple patterns match the annotated type's shape (E05-301–E05-302).

[2] Compilers shall reject patterns that introduce duplicate identifiers within the same binding (E05-303) and enforce the single-evaluation semantics described in §5.3.4.


### §4.4 Procedures [decl.function]

#### §4.4.1 Overview

[1] Procedure declarations introduce named computations at module scope or as associated members of types.

[2] Cursive provides a single callable form: _procedures_. Purity is determined by the sequent's grant set. Procedures whose sequents declare an empty grant set (e.g., omitted sequents defaulting to `[[ ∅ |- true => true ]]`, or explicit `[[ P => Q ]]` without grants) are pure and may be evaluated anywhere without requiring additional capabilities. Procedures whose sequents declare non-empty grant sets may perform the capabilities named in that set.

[3] Procedures may declare a receiver parameter `self` typed as `Self` with permission qualifiers `const`, `shared`, or `unique` (§10.4). When omitted, the procedure behaves as a static callable that still participates in grant checking.

[4] This subclause specifies the declaration surface for procedures; Clause 8 details callable bodies and evaluation, while Clause 11 defines sequent semantics and the grant system.

#### §4.4.2 Syntax

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `procedure_decl` production. — end note ]

[1] Procedure declarations consist of optional attributes and visibility modifiers, a procedure head (procedure kind and identifier), a signature (optional generic parameters, parameter list, optional return type, optional sequent clause), and a callable body (block, expression body for pure procedures, or semicolon for extern declarations). Procedure kinds are `procedure`, `comptime procedure`, or `extern [string] procedure`. Parameters may include receiver shorthands (`~`, `~%`, `~!`) or regular parameters with optional `move` modifier. Sequent clauses use `[[ sequent_expr ]]` syntax per Annex A §A.7.

[1] `callable_attributes` encompasses optimisation, diagnostic, and linkage attributes defined in Clauses 9 and 16.

[2] Sequents attach to procedures using form `[[ grants |- must => will ]]`. The sequent clause is **optional**: when omitted, defaults to pure procedure `[[ |- true => true ]]`. Abbreviated forms (e.g., `[[ io::write ]]`, `[[ x > 0 => result > x ]]`) are supported with deterministic expansion. Complete sequent syntax, smart defaulting rules, and canonical forms are specified in §11.2 [contract.sequent].

[3] Expression-bodied forms (`= expression ;`) are syntactic sugar for pure procedures and shall not include a sequent (the default `[[ ∅ |- true => true ]]` is implicit, canonical: `[[ |- true => true ]]` with empty grant set). Violations: E05-408.

#### §4.4.3 Constraints

[1] _Visibility defaults._ Module-scope procedures default to `internal` visibility. Associated procedures inherit the containing type’s visibility unless overridden.

[2] _Receiver parameter._ Procedures that include a receiver must declare it as the first parameter, either explicitly (`self: const/shared/unique Self`) or by using the shorthand `~`/`~%`/`~!`, which desugars respectively to `self: const/shared/unique Self`. A receiver parameter shall not appear in any position other than first. Violations: E05-401.

(2.1) _Parameter responsibility modifier._ Parameters may optionally include the `move` modifier to indicate that the procedure assumes cleanup responsibility for the parameter value:

```cursive
procedure process(data: Buffer)             // Non-responsible (default)
procedure consume(move data: Buffer)        // Responsible (takes ownership)
```

(2.2) Without `move`, parameters are non-responsible: they behave like non-responsible bindings (`let param <- argument`) and do not invoke destructors when the procedure returns. With `move`, parameters are responsible: they behave like responsible bindings (`let param = argument`) and invoke destructors when the procedure returns.

(2.3) Call sites must use `move` when calling procedures with `move` parameters: `consume(move x)`. Omitting `move` when required: E05-409. Using `move` when parameter lacks modifier: E05-410.

[3] _Sequents optional._ Sequent specifications are optional. When omitted, the procedure defaults to `[[ ∅ |- true => true ]]` (empty grant set, canonical: `[[ |- true => true ]]`, pure procedure). Procedures shall include explicit sequents when they require grants, enforce preconditions, or guarantee postconditions. Sequents may appear on the same line as the signature (for simple cases) or on the following line (recommended style for complex contracts).

[4] _Expression bodies._ Expression-bodied procedures (`= expression ;`) shall not include explicit sequents; the default `[[ ∅ |- true => true ]]` is implicit (canonical: `[[ |- true => true ]]` with empty grant set). Violations: E05-408.

[5] _Pure procedures._ Procedures whose sequents declare an empty grant set may not call procedures whose grant sets are non-empty nor perform operations that require grants. Violations: E05-406.

[6] _Comptime procedures._ Bodies of `comptime procedure` declarations shall be compile-time evaluable. Any grants referenced must be valid in compile-time contexts. Violations: E05-402.

[7] _Extern procedures._ `extern` procedures declare their signature and sequent but omit a body (`;`). Their linkage is governed by Clause 14.

[8] _Recursion._ Procedures may reference themselves directly or indirectly. Implementations may warn when they detect unprovable termination but shall not reject recursive procedures solely for that reason.

#### §4.4.4 Semantics

[1] Procedure definitions introduce callable entities that, when referenced, produce values of FunctionType (§6.4). The type records parameter types, return type, grant set, and sequent.

[2] The sequent governs three responsibilities:

- **grant component** (before turnstile): grants that must be available when the procedure executes
- **must** (after turnstile, before arrow): predicates that must hold when the procedure begins execution
- **will** (after arrow): predicates that will hold when the procedure completes normally

[3] Receiver shorthands desugar before semantic analysis so that tooling observes an explicit `self` parameter bound to `Self` with the requested permission qualifier.

[4] When procedures include sequents, the sequent shall appear contiguous with the signature; implementations shall accept either the same line or the immediately following line. For pure procedures, the sequent may be omitted entirely.

[5] `comptime` procedures execute during compile-time evaluation. Failure to evaluate successfully renders any compile-time use ill-formed.

##### §4.4.4.1 Parameter Responsibility Semantics [decl.function.params.responsibility]

[6] Parameter cleanup responsibility is determined by the presence of the `move` modifier:

**Non-responsible parameters (default):**

```cursive
procedure process(data: Buffer)
{
    // data is non-responsible (like 'let data <- argument')
    // data.drop() NOT called when procedure returns
}
```

When a procedure is called with a non-responsible parameter, the argument remains valid after the call. The parameter binding does not invoke a destructor.

**Responsible parameters (`move` modifier):**

```cursive
procedure consume(move data: Buffer)
{
    // data is responsible (like 'let data = argument')
    // data.drop() WILL be called when procedure returns
}
```

When a procedure is called with a responsible parameter, cleanup responsibility transfers from the argument to the parameter. The argument binding becomes invalid (moved) and the parameter binding invokes the destructor at the end of the procedure body.

[7] **Call site requirement.** When calling a procedure with a `move` parameter, the call site must use the `move` keyword on the argument:

```cursive
let buffer = Buffer::new()
process(buffer)             // ✅ OK: non-responsible parameter, buffer still valid
consume(move buffer)        // ✅ OK: responsible parameter, buffer becomes invalid
consume(buffer)             // ❌ ERROR E05-409: missing move for responsible parameter
```

[8] **Binding semantics equivalence.** Parameter responsibility semantics are equivalent to the corresponding local binding forms: `data: T` is equivalent to `let data <- argument` (non-responsible), and `move data: T` is equivalent to `let data = argument` (responsible). This equivalence ensures consistent behavior between parameter passing and local bindings.

#### §4.4.5 Examples (Informative)

**Example 4.4.5.1 (Pure procedure with expression body):**

```cursive
procedure clamp(value: i32, min: i32, max: i32): i32
= value.max(min).min(max)
```

[1] Expression-bodied procedures are implicitly pure; no sequent is needed.

**Example 4.4.5.3 (Responsible parameter with move):**

```cursive
procedure consume(move data: Buffer)
{
    process_data(data)
    // data.drop() called automatically when procedure returns
}

let buffer = Buffer::new()
consume(move buffer)             // buffer becomes invalid
// buffer.use()                  // error[E11-503]: use of moved value
```

**Example 4.4.5.4 (Procedure with receiver and grants):**

```cursive
procedure deposit(~!, amount: i64)
    [[ ledger::post |- amount > 0 => self.balance >= amount ]]
{
    self.balance += amount
}
```

**Example 5.4.5.8 - invalid (Missing move at call site):**

```cursive
procedure consume(move data: Buffer)
{ }

let buffer = Buffer::new()
consume(buffer)              // error[E05-409]: parameter requires move
```

#### §4.4.6 Conformance Requirements [decl.function.requirements]

[1] Tooling shall record sequents, grant sets, receiver permissions, parameter responsibility modifiers, and callable kinds in reflection metadata so that downstream analyses can reason about capability requirements and cleanup responsibilities.


### §4.5 Type Declarations [decl.type]

#### §4.5.1 Overview

[1] Type declarations introduce nominal and transparent types into a module’s lexical namespace. The language provides records (named product types), tuple records (product types with positional fields), enums (tagged sum types), modal types (compile-time state machines), and transparent type aliases.

[2] This subclause defines the syntactic forms of these declarations, their visibility rules, and the interaction points with other clauses. Semantic properties and typing rules reside in Clause 6 (Type System) and Clause 10 (Permissions and Memory).

#### §5.5.2 Syntax

[ Note: See Annex A §A.6 [grammar.declaration] for the normative type declaration productions (`RecordDecl`, `EnumDecl`, `ModalDecl`, `TypeAlias`). — end note ]

[3] Type declarations include records (named product types with optional methods), tuple records (product types with positional fields), enums (tagged sum types), modal types (compile-time state machines), and type aliases (transparent type synonyms). Records and enums may include contract clauses (`: Contract`) and behavior clauses (`with Behavior`). Modal types declare states with `@State` syntax and transitions with `@State::method(...) -> @Target` syntax.

[1] `attribute_list` follows §1.4.3; representation attributes such as `[[repr(packed)]]` or `[[repr(transparent)]]` attach to records, tuple records, enums, or modal types.

[2] `procedure_declaration` embeds member procedures (§5.4) within records.

[3] Tuple records reuse the `record` keyword with a positional field list and may include an optional body containing member procedures.

[4] **Modal state transitions**: Modal types distinguish between transition signatures (declared in modal body) and procedure implementations (separate declarations). Transition signatures use the `->` operator to declare state graph edges; procedure implementations use standard procedure syntax with `:` for return types.

**For complete modal type syntax, transition semantics, operator disambiguation rules, and comprehensive examples, see §7.6 [type.modal].**

#### §5.5.3 Constraints

[1] _Visibility defaults._ Type declarations at module scope default to `internal`. Member visibility defaults to the containing declaration’s visibility unless overridden. Tuple record fields default to the declaration’s visibility.

[2] _Namespace uniqueness._ Type names share the lexical namespace with other identifiers (§5.1.3) and shall not collide within the same scope.

[3] _Field requirements._ Record and enum field names must be unique within their declaration. Field type annotations are mandatory. Tuple record fields specify types but no identifiers.

[4] _Member procedures._ Procedures declared inside records or modal states follow §5.4. Receiver shorthand (`~`, `~%`, `~!`) binds the implicit `self` parameter to the enclosing type. Member procedures shall include a contractual sequent; placing it on the line immediately following the signature is recommended for readability.

[5] _Enum variants._ Variants may be unit-style, tuple-style (`Variant(T₁, …, Tₙ)`), or record-style (`Variant { field: Type, … }`). Variants inherit the enum’s visibility unless overridden. Variant identifiers must be unique.

[6] _Contract clause._ When a type declaration includes a contract clause, each referenced contract shall be visible at the point of declaration and the type shall provide implementations for every required item as specified in Clause 12. Duplicate contract references are diagnosed as E05-503.

[7] _Behavior clause._ When a type declaration includes a behavior clause, each referenced behavior shall be visible and applicable to the type's kind. Behaviors shall be implemented according to Clause 10; duplicate behavior references are diagnosed as E05-504.

[8] _Modal structure._ A modal type shall declare at least one state using the `@State` notation. Each state may include a payload block `{ fields }` (record-style) followed by zero or more transition signatures. Transition signatures use the **mapping operator `->` (reads as "transitions to")** in the form `@SourceState::name(params) -> @TargetState` where `@SourceState` matches the state containing the signature. The source state qualifier makes explicit which state the transition originates from. Parameters may include receiver shorthand (`~`, `~%`, `~!`) as the first parameter.

[9] _Transition implementations._ Each transition signature requires a corresponding procedure implementation. Complete modal type syntax, transition semantics, operator disambiguation (`->` vs `:`), and implementation requirements are specified in §7.6 [type.modal].

[10] _Attributes._ Representation attributes (`[[repr(packed)]]`, `[[repr(transparent)]]`, `[[repr(align(N))]]`) are optional and shall comply with layout rules in Clause 7. Violations: E05-502.

[11] _Type alias cycles._ Type aliases form transparent names. Direct or indirect cyclic aliases are prohibited (diagnostic E05-501).

[12] _Generics._ Generic parameter lists may include type, const, and grant parameters. Bounds are specified via `where` clauses (§10.3 [generic.bounds]) and validated in Clause 7.

[13] _Empty type declarations._ Records, enums, and modal types may have empty bodies (no fields, variants, or states). Empty records represent unit-like types; empty enums represent uninhabited types (never types); empty modal types are ill-formed (diagnostic E05-505) as they provide no states. Empty tuple records are well-formed and represent zero-element tuples.

[14] _Multiple contract implementations._ When a type implements multiple contracts via the contract clause, all required items from all contracts must be satisfied. If two contracts require procedures with the same name but incompatible signatures, the type declaration is ill-formed (diagnostic E05-506). If signatures are compatible (subtype relationship), a single implementation may satisfy both contracts.

[15] _Recursive type definitions._ Types may reference themselves directly or indirectly in field types, variant payloads, or generic bounds. Recursive definitions are well-formed provided they do not create infinite-size types (e.g., `record R { field: R }` is ill-formed, but `record R { field: Ptr<R> }` is well-formed). Violations: E05-507.

#### §5.5.4 Semantics

[1] Records and tuple records introduce nominal product types; field layout, initialization, and destruction semantics are governed by Clause 7 and Clause 12.

[2] Enums introduce nominal sum types with tagged variants. Variant constructors become callable expressions (§8.4) and participate in exhaustiveness checking (§7.3).

[3] Modal types define compile-time verified state machines. Each state corresponds to a distinct type, and transitions are enforced through the modal transition signatures in Clause 7.

[4] When a type lists contracts using the contract clause, the declaration establishes an implementation obligation. Clause 12 specifies how each referenced contract contributes required procedures, associated types, and clauses; §5.5.3[6] enforces that every obligation is fulfilled within the declaration.

[5] Behavior clauses attach behavior implementations to the type. Clause 10 governs behavior formation, coherence, and conflict detection. The behavior clause is equivalent to writing separate behavior implementation blocks whose receiver is the declaring type.

[6] Type aliases provide transparent renaming. Aliases do not create new nominal identities and are interchangeable with the aliased type in all contexts.

#### §5.5.5 Examples (Informative)

**Example 5.5.5.1 (Record with contracts and behaviors):**

```cursive
public record Account: Ledgered with UserStorage {
    public id: u64,
    private balance: i64,

    procedure deposit(~!, amount: i64)
        [[ ledger::post |- amount > 0 => self.balance >= amount ]]
    {
        self.balance += amount
    }
}
```

[1] `Ledgered` is a contract that contributes obligations satisfied by the record's procedures; `UserStorage` is a behavior implemented for `Account` via the behavior clause.

**Example 5.5.5.2 (Tuple record):**

```cursive
record Velocity(f64, f64) {
    procedure magnitude(~): f64
    {
        result (self.0 * self.0 + self.1 * self.1).sqrt()
    }
}
```

**Example 5.5.5.3 (Enum with mixed variants):**

```cursive
enum Message {
    Ping,
    Pong,
    Data(i32, string),
    Log { level: u8, text: string }
}
```

**Example 5.5.5.4 (Modal type declaration):**

[See §7.6.9.1 Example 7.6.9.1 for complete FileHandle modal type with states, transitions, and procedure implementations.]

**Example 5.5.5.5 (Type alias):**

```cursive
public type UserId = u64
```

### §5.5.6 Conformance Requirements [decl.type.requirements]

[1] Implementations shall enforce uniqueness of type names, record fields, enum variants, and modal state identifiers within their respective scopes, issuing diagnostics E05-501–E05-502 where applicable.

[2] Compilers shall verify contract and behavior clauses: referenced interfaces must be visible, duplicates are rejected (E05-503–E05-504), and the declared type shall supply every required item defined by Clause 12 and Clause 10 respectively.

[3] Compilers shall validate modal transition declarations against the requirements of §5.5.3[8]–[9], ensuring that every transition declaration has a corresponding procedure implementation with matching signature (receiver type, parameter types, and return type) and that representation attributes obey Clause 7 layout constraints.

[4] Type aliases shall be transparent; implementations shall reject cycles (E05-501) and substitute the aliased type wherever the alias appears during type analysis.


### §4.6 Visibility Rules [decl.visibility]

#### §4.6.1 Overview

[1] Visibility modifiers determine which scopes may refer to a declaration. Cursive recognises four modifiers: `public`, `internal`, `private`, and `protected`.

[2] This subclause states where modifiers may appear, the defaults that apply when no modifier is written, and the limits imposed when re-exporting or aliasing declarations.

#### §5.6.2 Syntax

**Visibility modifiers** take one of the following forms:
```
"public"
"internal"
"private"
"protected"
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `visibility` production.
— end note ]

#### §5.6.3 Defaults and Placement

[1] Module-scope declarations default to `internal` visibility. Writing `private` or `protected` at module scope is ill-formed (diagnostic E05-601); authors shall use `internal` explicitly when they wish to emphasise the default.

[2] Fields inside records, tuple records, enum variants, and modal state payloads inherit the containing type’s visibility unless overridden by an explicit modifier.

[3] Procedures nested inside types (including modal state transition blocks) inherit the type’s visibility. Procedures declared at module scope obey the module default.

[4] Visibility modifiers shall not appear on local (block-scoped) bindings. Any attempt to do so is ill-formed (diagnostic E05-602).

#### §5.6.4 Modifier Semantics

[1] **public** — Accessible from any module once imported. `public use` re-exports preserve this visibility.

[2] **internal** — Accessible only within the declaring module. Importers cannot name the entity directly; any attempt to re-export it as `public` is ill-formed (diagnostic E05-603).

[3] **private** — Accessible only within the smallest enclosing declaration:

- For type members, visibility is limited to the declaring type’s own procedures.
- For modal state payloads, visibility is limited to transition procedures defined in that state’s block.
- Module-scope `private` is rejected by [1].

[4] **protected** — May be applied only to members declared inside a type or modal state block. It grants visibility to the declaring type and to behaviors or contracts (Clause 10 and Clause 12) that provide implementations for that type. Outside those contexts `protected` behaves like `internal`. Module-scope or stand-alone `protected` declarations are rejected by [1].

#### §5.6.5 Re-export and Aliasing Rules

[1] `public use module::item` is valid only when `item` was `public` in its defining module. Attempting to widen visibility produces diagnostic E05-603.

[2] Visibility narrowing during re-export is disallowed. Modifiers other than `public` shall not be written with `use`; statements such as `private use`, `internal use`, or `protected use` are ill-formed (diagnostic E05-604).

[3] Type aliases adopt the visibility written on the alias declaration. They do not inherit the aliased type's visibility.

[4] _Nested visibility._ When a type member has explicit visibility that differs from the containing type's visibility, the more restrictive modifier applies. For example, a `private` field in a `public` record remains `private`; a `protected` procedure in a `public` type remains `protected`. This ensures that explicit modifiers are never widened by inheritance.

[5] _Protected access context._ `protected` members are accessible only within: - The declaring type's own procedures - Behavior implementations (`behavior X for Y`) where `Y` matches the declaring type - Contract implementations (`contract X for Y`) where `Y` matches the declaring type - Modal state transition procedures defined within the same state block (for state-specific `protected` members)

    Attempts to access `protected` members from other contexts (e.g., external modules, unrelated behaviors) emit diagnostic E05-605 (protected member access violation).

[6] _Visibility inheritance in type hierarchies._ When a type implements a behavior or contract, `protected` members of the implementing type become accessible within the behavior/contract implementation, but not within the behavior/contract declaration itself. This allows implementations to access internal helpers while keeping the interface clean.

#### §5.6.6 Examples (Informative)

**Example 5.6.6.1 (Module defaults and errors):**

```cursive
let cache_size = 1024          // internal by default
public procedure fetch(id: UserId): Record
{ ... }
private let temp = 0           // error[E05-601]
```

**Example 5.6.6.2 (Type members):**

```cursive
public record User {
    public id: UserId
    private password_hash: string

    protected procedure helper(~) { ... }
}
```

User behavior implementations may reference `helper`, whereas external modules cannot.

**Example 5.6.6.3 - invalid (Visibility widening on re-export):**

```cursive
public use auth::internal_helper  // error[E05-603]
```

**Example 5.6.6.4 - invalid (Visibility narrowing on re-export):**

```cursive
private use auth::Session         // error[E05-604]
```

**Example 5.6.6.5 (Protected access through behavior):**

```cursive
behavior UserStorage for User {
    procedure seed(~%, data: Seed)
 {
        User.helper(data.initial_password)
    }
}
```

### §5.6.7 Conformance Requirements [decl.visibility.requirements]

[1] Implementations shall reject attempts to apply `private` or `protected` at module scope (E05-601) and forbid visibility modifiers on local bindings (E05-602).

[2] Compilers shall prevent re-exports from widening or narrowing visibility (E05-603–E05-604) and ensure that `protected` members are accessible only within the contexts described in §5.6.4.
[ Note: Behavior `UserStorage` may call the protected `helper`, while unrelated modules cannot.
— end note ]


### §4.7 Initialization and Definite Assignment [decl.initialization]

#### §4.7.1 Overview

[1] This subclause specifies how declarations acquire initial values and how the compiler ensures every binding is definitely assigned before use. Cursive provides two binding operators: `=` for responsible bindings and `<-` for non-responsible bindings.

[2] Module-scope initialization interacts with the dependency model in §3.6; block-scoped initialization and reassignment rules integrate with permissions in Clause 10.

#### §5.7.2 Module-Scope Initialization

[1] Module-scope `let`/`var` bindings are initialized exactly once before code in the module executes. Implementations construct the eager dependency graph described in §4.6 and evaluate initializers in topological order.

[2] Cycles in the eager dependency graph are ill-formed (diagnostic E05-701). Implementations shall report every binding in the cycle.

[3] If an initializer fails (e.g., panics), dependent bindings are not evaluated. Each blocked binding receives diagnostic E05-702, identifying the failing dependency.

[4] Module-scope `let` bindings whose initializers are compile-time evaluable become compile-time constants; Clause 7 treats them as `ConstExpr`.

[5] Module-scope `var` bindings evaluate their initializers at module initialization. Subsequent assignments follow the rules in Clause 12.

#### §5.7.3 Block-Scoped Initialization

[1] Block-scoped bindings (`let`/`var`) are initialized when execution reaches the declaration. Control flow shall not use a binding before it has been assigned.

[2] The compiler diagnoses uses of unassigned bindings as E05-703 (“binding may be unassigned here”). This check applies across branches and loop iterations.

#### §5.7.4 Definite Assignment Rules

[1] A binding declared with `let` or `var` must be assigned on every control-flow path before each use. `let` forbids reassignment; `var` permits it.

[2] For conditionals (`if`, `match`), each branch must assign the binding before it is used afterwards.

[3] Before entering a loop, the binding must already have a value. Assignments that occur only inside the loop body do not satisfy definite assignment for code that executes before the first iteration.

[4] Pattern bindings (§5.2–§5.3) shall bind every identifier in the pattern. Omitting a field produces E05-704.

[5] **Dependency tracking for non-responsible bindings**: When a non-responsible binding is created via `let n <- source`, the compiler records that `n` depends on the same object as `source`. The non-responsible binding remains valid as long as the object exists. Since the compiler cannot track object destruction at runtime (zero-cost principle), it uses **parameter responsibility** as a compile-time approximation:

- When `source` is moved to a **responsible parameter** (`move` modifier), the callee might destroy the object, so `n` becomes invalid
- When `source` is passed to a **non-responsible parameter** (no `move`), the callee will not destroy the object, so `n` remains valid
- When `source`'s scope ends, the object is destroyed, so `n` must also be out of scope or invalid

This compile-time approximation ensures memory safety without runtime tracking: non-responsible bindings cannot access potentially destroyed objects.

[6] With non-responsible bindings (`<-`), the compiler enforces permissions from Clause 11. Assignments that violate permission rules are diagnosed in that clause.

#### §5.7.5 Non-Responsible Binding Validity

##### §5.7.5.1 Overview

[1] Non-responsible bindings (created with `<-`) have distinct validity rules from responsible bindings. This subsection specifies when non-responsible bindings become invalid and their interaction with responsibility transfer.

##### §5.7.5.2 Invalidation on Potential Object Destruction

[2] **THIS SECTION IS AUTHORITATIVE** for non-responsible binding invalidation. Non-responsible bindings bind to the **object**, not the binding. The `<-` operator creates a non-responsible binding that remains valid as long as the object exists. However, non-responsible bindings become invalid when the object **might be destroyed**.

[3] The compiler uses **parameter responsibility** as the compile-time signal for potential destruction. When a binding is moved to a procedure with a **responsible parameter** (marked with `move`), the callee might destroy the object, so all non-responsible bindings referencing that object become invalid:

**Invalidation Rule:**

[ Given: Binding $r$, non-responsible binding $n$ created via $n \gets r$, procedure with parameter `move x: T` ]

$$
\frac{r \text{ moved to responsible parameter (move at call site)}}
     {r \text{ and } n \text{ both become invalid}}
\tag{WF-NonResp-Invalidate}
$$

[3.1] This rule is the **COMPLETE** invalidation condition. Non-responsible bindings remain valid when:

1. Source binding is passed to NON-responsible parameters (no `move` at call site)
2. Source binding remains in scope and not moved
3. Non-responsible binding has not exited its own scope

**Example 5.7.5.1 (Invalidation when object might be destroyed):**

```cursive
procedure consume(move data: Buffer)   // Responsible parameter (might destroy)
{
    data.process()
    // data.drop() called at scope exit
}

let owner = Buffer::new()              // Responsible
let viewer <- owner                    // Non-responsible (binds to object)

consume(move owner)                    // Object might be destroyed by consume
// owner becomes invalid (moved-from state)
// viewer becomes invalid (object might be destroyed)
// viewer.read()                       // ERROR E11-504: use of invalidated non-responsible binding
```

[4] This invalidation ensures memory safety:
- No use-after-free: Non-responsible bindings become invalid before object destruction
- No double-free: Non-responsible bindings never call destructors
- Zero runtime cost: Parameter responsibility known at compile time

##### §5.7.5.3 Non-Responsible Parameters Preserve Validity

[5] When a binding is passed to a procedure with a **non-responsible parameter** (no `move` modifier), the object is guaranteed to survive the call. Non-responsible bindings remain valid:

**Example 5.7.5.2 (Non-responsible parameter preserves validity):**

```cursive
procedure inspect(data: Buffer)        // Non-responsible parameter (no move)
{
    println("Size: {}", data.size())
    // data.drop() NOT called (non-responsible parameter)
}

let owner = Buffer::new()              // Responsible binding
let viewer <- owner                    // Non-responsible (references object)

inspect(owner)                         // ✅ OK: passed to non-responsible param
viewer.read()                          // ✅ VALID: object guaranteed to survive inspect()
owner.use()                            // ✅ VALID: owner still responsible

// At scope exit: owner.drop() called, viewer does not call drop
```

[6] The key distinction: parameter responsibility determines object lifetime:
- **Non-responsible parameter**: Object survives the call, non-responsible bindings remain valid
- **Responsible parameter** (`move`): Object might be destroyed, non-responsible bindings become invalid

##### §5.7.5.4 Scope-Based Invalidation

[7] Non-responsible bindings also become invalid when they exit their lexical scope:

```cursive
let owner = Data::new()
{
    let temp_view <- owner             // Valid within this scope
    temp_view.read()                   // ✅ OK: owner not moved, scope active
}  // temp_view exits scope (invalidated by scope exit)
// owner still valid (not moved)
```

[8] Invalidation conditions (cumulative):
1. Non-responsible binding exits its own lexical scope
2. Source binding is moved to a responsible parameter

##### §5.7.5.5 Type Preservation

[9] Non-responsible bindings have the same type as the value they reference. The `<-` operator affects binding metadata (cleanup responsibility) but not type:

**Example 5.7.5.3 (Type identity):**

```cursive
let buffer: Buffer = Buffer::new()     // Type: Buffer, responsible
let ref: Buffer <- buffer              // Type: Buffer, non-responsible
// Same type, different cleanup responsibility
```

[10] Type checking, permission enforcement, and all type system rules apply identically to both responsible and non-responsible bindings. Only cleanup responsibility and transferability differ.

##### §5.7.5.6 Rebinding Non-Responsible Vars

[11] `var` bindings created with `<-` may be rebound to reference different values:

**Example 5.7.5.4 (Rebinding non-responsible var):**

```cursive
var current_view <- buffer1
current_view.read()

current_view <- buffer2                // Rebind to different object
current_view.read()                    // Now reads from buffer2
// No destructors called during rebinding
```

[12] Rebinding a non-responsible `var` does not invoke any destructors. The binding simply refers to a different value.

##### §5.7.5.7 Permission Compatibility

[13] Non-responsible bindings must have permission-compatible types with the source value. Permission coercion rules (§11.4) apply: `unique` → `const` and `shared` → `const` are permitted, but upgrades and cross-coercions are forbidden.

**Example 5.7.5.5 (Permission coercion):**

```cursive
let data: unique = Data::new()
let const_view: const <- data          // ✅ OK: unique → const coercion
let unique_view: unique <- data        // ❌ ERROR: cannot create second unique binding
```

[14] Complete permission semantics are specified in Clause 11 [memory].

##### §5.7.5.8 Safe Usage Patterns for Non-Responsible Bindings

[15] Non-responsible bindings are safe when used according to the following patterns:

**Pattern 1: Pass to non-responsible parameters**

When the source binding is passed to procedures with non-responsible parameters (no `move` modifier), the object survives the call and non-responsible bindings remain valid. This is the primary use case for non-responsible bindings.

**Pattern 2: Keep source binding alive**

When the source binding remains in scope and is not moved, all non-responsible bindings derived from it remain valid until they exit their own scopes.

**Pattern 3: Use with Copy types**

Copy types (§10.4.5.2) have no destructors, so concerns about object destruction don't apply. Non-responsible bindings to Copy-type values are always safe.

**Example 5.7.5.6 (Complete safe usage pattern):**

```cursive
procedure inspect(data: Buffer)        // Non-responsible parameter (no move modifier)
{
    println("Size: {}", data.size())
    // data.drop() NOT called (non-responsible parameter)
}

procedure consume(move data: Buffer)   // Responsible parameter (might destroy)
{
    data.process()
    // data.drop() IS called at scope exit
}

let owner = Buffer::new()
let viewer <- owner                    // Non-responsible binding (references object)

// Safe: pass to non-responsible parameter
inspect(owner)                         // ✅ Object survives
viewer.read()                          // ✅ VALID: object alive

// Safe: use without moving
viewer.read()                          // ✅ VALID: owner not moved
owner.use()                            // ✅ VALID: owner still responsible

// Unsafe: move to responsible parameter
// consume(move owner)                 // Would invalidate owner AND viewer
// viewer.read()                       // ERROR E11-504: object might be destroyed

// At scope exit: owner.drop() called, viewer does not call drop
```

[16] **Recommended practice**: Use non-responsible bindings to create multiple temporary views of data that remains under the original binding's control. Avoid moving the source binding to responsible parameters while non-responsible bindings exist, or ensure non-responsible bindings exit scope before the move.

##### §5.7.5.9 Validity Summary

[17] **Table 5.7.1 — Non-responsible binding validity conditions**

| Operation on Source                     | Non-Responsible Binding State | Rationale                       |
|-----------------------------------------|-------------------------------|---------------------------------|
| Create `let n <- source`                | Valid                         | Binds to object                 |
| Pass `source` to non-responsible param  | Remains valid                 | Object survives call            |
| Pass `inspect(source)` (no move)        | Remains valid                 | Object not destroyed            |
| Move to responsible param `move source` | Becomes invalid               | Object might be destroyed       |
| Call `consume(move source)`             | Becomes invalid               | Callee might destroy object     |
| Source scope ends                       | Must be out of scope          | Object destroyed at scope exit  |
| Non-responsible binding scope ends      | Becomes invalid               | Binding exits scope             |

[18] The key insight: **parameter responsibility** (presence of `move` modifier on procedure parameter) signals whether the callee will destroy the object. This compile-time information enables safe non-responsible binding tracking without runtime overhead.

#### §5.7.6 Reassignment and Drop Order

[1] Reassigning a `let` binding is ill-formed (E05-705). `var` bindings may be reassigned, subject to permission checks.

[2] When a scope exits, bindings are dropped in reverse declaration order. Drop behavior and destructor semantics are governed by Clause 11.

#### §5.7.7 Examples (Informative)

**Example 5.7.7.1 (Module-level constants):**

```cursive
let VERSION: string = "1.2.0"        // compile-time constant
var current_locale = detect_locale()  // runtime initialization
```

**Example 5.7.7.2 (Definite assignment across branches):**

```cursive
var total: i64
if config.has_value {
    total = config.value
} else {
    total = 0
}
use_total(total)  // OK: both branches assign total
```

**Example 5.7.7.3 - invalid (Unassigned variable):**

```cursive
var data: Buffer
if should_allocate {
    data = make_buffer()
}
consume(data)  // error[E05-703]: data may be unassigned
```

**Example 5.7.7.4 - invalid (Pattern mismatch):**

```cursive
let {x, y}: Point = make_point()   // OK
let {x}: Point = make_point()      // error[E05-704]: field y missing
```

### §5.7.8 Conformance Requirements [decl.initialization.requirements]

[1] Implementations shall construct the module initialisation dependency graph of §4.6, diagnose cycles (E05-701), and report blocked bindings when an initialiser fails (E05-702).

[2] Compilers shall enforce definite-assignment analysis for block-scoped bindings, emitting E05-703 when a binding might be uninitialised and E05-705 when a `let` binding is reassigned.

[3] Compilers shall track dependencies for non-responsible bindings: when `let n <- source` is declared, record that `n` depends on `source`. When `source` is moved to a responsible parameter (indicated by `move` at call site), propagate invalidation to all dependent non-responsible bindings and emit E11-504 when invalidated bindings are used. When `source` is passed to non-responsible parameters (no `move` at call site), non-responsible bindings remain valid because the object is guaranteed to survive.

[4] Pattern bindings shall bind every identifier declared in the pattern; omissions shall be diagnosed with E05-704 and prevent the program from compiling.


### §4.8 Program Entry and Execution Model [decl.entry]

#### §4.8.1 Overview

[1] This subclause defines how an executable Cursive program begins execution, the required form of the entry point, and how exit status is determined.

[2] Library modules omit an entry point and instead expose public APIs.

#### §5.8.2 Entry Point Requirements

[1] An executable module shall define exactly one top-level `procedure main`. Multiple definitions or the absence of `main` produce diagnostic E05-801.

[2] The entry point must be declared as:
```
public procedure main(): i32
```
or
```
public procedure main(args: [string]): i32
```
Return type `i32` expresses the process exit status.

[3] `main` shall be `public`. Other visibility modifiers are rejected (E05-802).

[4] `main` shall declare a contractual sequent that explicitly lists any grants required for execution. When `main` uses operations that require grants (such as I/O, allocation, file system access, etc.), the sequent clause is **required** and must explicitly declare those grants. If `main` performs no grant-requiring operations, the sequent clause may be omitted and defaults to `[[ ∅ |- true => true ]]` (empty grant set, canonical: `[[ |- true => true ]]`). `comptime` entry points and asynchronous entry points are not permitted (E05-803).

[5] Attributes such as `[[test]]`, `[[bench]]`, or other non-standard annotations shall not decorate `main` (E05-804).

#### §5.8.3 Execution Order

[1] Before `main` executes, all module-scope initializers in the root module and its dependencies run according to §4.6 and §5.7.

[2] `main` executes on the initial thread. Additional concurrency is implementation-defined and initiated explicitly by user code.

[3] If `main` returns normally, its `i32` result is mapped to the platform’s exit status conventions.

[4] If `main` panics or aborts, the program terminates with a non-zero exit status chosen by the implementation. Clause 11 describes destructor semantics in such cases.

#### §5.8.4 Argument Handling

[1] When the signature includes `args: [string]`, the implementation supplies command-line arguments normalized to UTF-8. Invalid data may be replaced or rejected; behavior is documented per implementation.

[2] The first argument (`args[0]`) may contain the executable path; subsequent positions carry user-provided parameters.

#### §5.8.5 Examples (Informative)

**Example 5.8.5.1 (Basic entry point):**
```cursive
public procedure main(): i32
    [[ io::write |- true => true ]]
{
    println("Hello, Cursive!")
    result 0
}
```

[1] The example shows `main` with an explicit grant declaration for I/O operations, demonstrating the standard pattern for executable programs.

**Example 5.8.5.2 (Entry with arguments):**
```cursive
public procedure main(args: [string]): i32
    [[ io::write |- args.len() > 0 => true ]]
{
    if args.len() < 2 {
        println("Usage: tool <path>")
        result 1
    } else {
        run_tool(args[1])
        result 0
    }
}
```

**Example 5.8.5.3 - invalid (Non-public main):**
```cursive
internal procedure main(): i32
{  // error[E05-802]
    result 0
}
```

### §5.8.6 Conformance Requirements [decl.entry.requirements]

[1] Implementations shall require exactly one `public procedure main` per executable program, diagnose missing or duplicate definitions (E05-801), and reject non-public entry points (E05-802). The contractual sequent follows standard optionality rules per §5.4 [decl.function].

[2] Compilers shall forbid entry points that are `comptime` procedures or asynchronous procedures (E05-803) and reject disallowed attributes on `main` (E05-804). `main` may declare any grants necessary for program execution.

[3] Before executing `main`, runtime systems shall evaluate module initialisers according to §4.6 and honour the exit-status mapping described in §5.8.3.


### §4.9 Grant Declarations [decl.grant]

#### §5.9.1 Overview

[1] Grant declarations introduce user-defined capability tokens at module scope. Grants are compile-time annotations used in procedure contractual sequent specifications to track operational capabilities and side effects.

[2] This section specifies the declaration syntax and basic semantics for user-defined grants. The complete grant system, including built-in grants, verification rules, and propagation semantics, is specified in Clause 11 [contract].

#### §5.9.2 Syntax

**Grant declarations** match the pattern:

```
[ <visibility> ] "grant" <identifier>
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `grant_decl` production.
— end note ]

[3] Grant declarations consist of an optional visibility modifier followed by the `grant` keyword and an identifier.

#### §5.9.3 Constraints

[1] _Visibility defaults._ Grant declarations at module scope default to `internal` visibility, matching the default for module-scoped declarations (§5.6.3). The modifiers `public`, `internal`, `private`, and `protected` control accessibility across modules.

[2] _Namespace uniqueness._ Grant names share the lexical namespace with other identifiers (§5.1.3) and shall not collide within the same scope.

[3] _Reserved namespaces._ Grant names shall not conflict with reserved grant namespaces. [ Note: Complete built-in grant catalog is specified in §11.3.3 [contract.grant.builtin]. — end note ]

Violations produce diagnostic E05-901.

[4] _Module scope only._ Grant declarations shall appear at module level only, not nested within types, procedures, or blocks. Violations: E05-902.

[5] _Forward references._ Grant declarations may be referenced before their definition within the same module due to two-phase compilation (§2.2).

#### §5.9.4 Semantics

[1] Grant declarations introduce compile-time capability tokens with no runtime representation. The fully qualified grant path is constructed from the module path and grant name: for grant `g` in module `M`, the path is `M::g`.

[2] User-defined grants are referenced in procedure contractual sequent specifications using their fully qualified paths (see §5.4 [decl.function] for contractual sequent syntax).

[3] Grant visibility determines which modules may reference the grant in their contractual sequents. Private grants are accessible only within the declaring module; public grants are accessible from any module that imports the declaring module.

[4] Grant declarations have zero runtime cost and are fully erased during compilation. All grant checking is performed statically at compile time.

#### §5.9.5 Examples

**Example 5.9.5.1 (Basic grant declarations):**

```cursive
public grant query
public grant write
internal grant admin
private grant internal_cache
```

**Example 5.9.5.2 (Using grants in contractual sequents):**

```cursive
// File: database.cursive
public grant query
public grant write

procedure execute_query(sql: string@View): [i32]
    [[ query |- sql.len() > 0 ]]
{
    // Implementation uses local grant 'query'
    result perform_query(sql)
}

// File: application.cursive
import database

procedure fetch_items(): [i32]
    [[ database::query ]]
{
    result database::execute_query("SELECT id FROM items")
}
```

**Example 5.9.5.3 (Mixed built-in and user-defined grants):**

```cursive
import database

procedure save_query_results(path: string@View): ()
    [[ database::query, fs::write, alloc::heap |- path.len() > 0 ]]
{
    let results = database::execute_query("SELECT * FROM items")
    write_to_file(path, results)
}
```

#### §5.9.6 Diagnostics

[1] Minimal diagnostics:

| Code    | Condition                                    |
| ------- | -------------------------------------------- |
| E05-901 | Grant name conflicts with reserved namespace |
| E05-902 | Grant declaration not at module scope        |
| E05-903 | Duplicate grant name in same module          |

#### §5.9.7 Integration with Grant System

[1] Grant declarations defined in this section participate in the complete grant system specified in Clause 11 [contract], which provides built-in grant catalog (§11.3.3), grant verification rules (§11.3.8), grant parameters for polymorphism (§11.3.7), and grant checking algorithm (§11.7.2).

[2] User-defined grants integrate seamlessly with built-in grants and are verified using identical rules during compilation.

#### §5.9.8 Conformance Requirements [decl.grant.requirements]

[1] Implementations shall recognize grant declarations at module scope and verify:

- Grant names do not conflict with reserved namespaces (E05-901)
- Grant declarations appear only at module scope (E05-902)
- Grant names are unique within their module (E05-903)

[2] Implementations shall construct fully qualified grant paths from module paths and grant names.

[3] Implementations shall enforce visibility constraints on grant usage in contractual sequent specifications.

[4] Implementations shall forward grant declarations to the grant system (Clause 11 [contract]) for verification and propagation checking.


### §5.1 Identifiers [name.identifier]

#### §5.1.1 Overview [name.identifier.overview]

[1] This subclause defines how identifiers are formed, classified, and interpreted within Cursive's unified namespace model. Identifiers name every declaration that participates in lexical scope: variables, procedures, types, modules, contracts, predicates, grants, and labels.

[2] Identifier formation relies on the lexical grammar specified in §2.3 [lex.tokens]; the present clause records the semantic obligations that arise once an identifier enters a scope. In particular, it clarifies case sensitivity, Unicode handling, reserved keywords, and the relationship between identifier spelling and the single-namespace rule introduced in §6.2.

#### §6.1.2 Syntax [name.identifier.syntax]

[3] Identifiers follow the lexical production `identifier` in §2.3.2, which recognises Unicode XID_Start followed by zero or more XID_Continue code points and excludes the reserved keywords listed in §2.3.3.

[4] Implementations shall treat identifiers as Unicode scalar sequences compared by code-point equality after the normalisation rules of §2.1 (source text preprocessing) have been applied.

#### §6.1.3 Constraints [name.identifier.constraints]

[5] Identifiers are case-sensitive. Distinct code-point sequences (including differences in case) denote distinct identifiers unless they normalise to identical sequences under the preprocessing rules of §2.1.2.

[6] Reserved keywords (e.g., `module`, `let`, `with`) shall not be used as identifiers. Attempts to declare or reference a reserved keyword as an identifier are ill-formed (diagnostic E02-208).

[7] Identifiers shall not be the empty string, shall not contain surrogate code points, and shall not embed U+0000. Violations inherit the diagnostics defined in §2.1 (E02-004) and §2.3 (lexical error family).

[8] Identifiers introduced by tooling (for example, code generation utilities) shall satisfy the same lexical rules and shall avoid the `__cursive` prefix reserved for implementation-defined helper symbols.

#### §6.1.4 Semantics [name.identifier.semantics]

[9] Every identifier enters exactly one lexical namespace per scope (§6.2) and is associated with the binding properties listed in §6.3. Identifiers used in value contexts, type contexts, or module contexts are resolved uniformly; category mismatches are diagnosed after lookup.

[10] Two identifiers that compare equal under the normalisation in §2.1 refer to the same binding; no additional case folding or locale-dependent equivalence is applied.

[11] When an identifier appears in qualified form (`Prefix::Name`), only `Name` is subject to the rules in this subclause; the qualification rules in §6.4 govern the prefix resolution.

#### §6.1.5 Examples (Informative) [name.identifier.examples]

**Example 6.1.5.1 (Identifier usage and reserved keywords):**
```cursive
// Valid identifiers (Unicode and ASCII)
let Δ = 0.1
let customer_total = 42
let 数据 = 512

// Case-sensitive distinctions
let user = "alice"
let User = "bob"  // different binding from `user`

// Invalid: reserved keyword
// let module = 5            // ERROR E02-206

// Invalid: contains forbidden control character
// let name = "bad\u0000"    // ERROR E02-004 (caught lexically)
```

#### §6.1.6 Conformance Requirements [name.identifier.requirements]

[12] Implementations shall accept any identifier that satisfies the lexical grammar of §2.3 and the normalisation rules of §2.1, rejecting all others with the diagnostics defined in those clauses.

[13] Implementations shall compare identifiers using exact code-point equality after preprocessing; no locale-dependent folding is permitted.

[14] Implementations shall enforce the prohibition on reserved keywords serving as identifiers and emit diagnostic E02-208 when violated.


### §5.2 Scope Formation [name.scope]

#### §5.2.1 Overview [name.scope.overview]

[1] This subclause defines the lexical structures that create scopes, the hierarchy relating module, procedure, and block scopes, and the rules by which declarations enter those scopes. Scope formation underpins the unified namespace model: each scope provides exactly one binding table shared by all name categories.

[2] The rules complement the binding semantics in §6.3 and the lookup algorithm in §6.4. Together they ensure deterministic, two-phase name resolution that aligns with Cursive’s goals of explicitness and AI-friendly predictability.

#### §6.2.2 Syntax [name.scope.syntax]

[3] Scope boundaries coincide with the following syntactic constructs:

**Scopes** take one of the following forms:
```
<module_scope>
<procedure_scope>
<block_scope>
```

**Module scopes** are:
```
<compilation_unit>
```

**Procedure scopes** take one of the following forms:
```
<procedure_body>
<comptime_callable_body>
```

**Block scopes** take one of the following forms:
```
"{" <statement>* "}"
<region_block>
```

**Region blocks** match the pattern:
```
"region" [ <identifier> ] "{" <statement>* "}"
```

[ Note: See Clause 9 for `procedure_body` and `statement` grammar; §2.5.2 for `compilation_unit`; §11.3 [memory.region] for region semantics.
— end note ]

[4] The canonical forms for procedure bodies and statements appear in Clause 9; compilation units are defined in §2.5.2; region blocks are elaborated in §11.3 [memory.region].

#### §6.2.3 Constraints [name.scope.constraints]

[5] Every scope shall have a single parent except the implicit root scope associated with the compilation unit. The parent relation shall form a tree—cycles and multiple parents for a single scope are forbidden (diagnostic E06-201).

[6] Module scope is the outermost scope for each compilation unit. All top-level declarations (`module`, `import`, `use`, `let`, `var`, `record`, `enum`, `modal`, `contract`, `predicate`, `grant`) enter this scope and become visible throughout the unit subject to visibility modifiers (§5.6).

[7] Procedure scope is established when a callable body begins. Parameters and labels have procedure-wide visibility within that scope regardless of nested blocks. Nested procedure declarations create new scopes following the rules in §5.4.

[8] Block scope begins at each `{` and ends at the matching `}`. Declarations inside a block are visible from the point of declaration to the end of the block and may shadow outer bindings only when marked with `shadow` (§6.3). Region blocks (`region`) create block scopes that are constrained additionally by the region stack (§11.3), but their name-visibility behaviour is identical to ordinary blocks.

[9] Control-flow constructs that introduce implicit blocks (`if`, `while`, `for`, `match`) behave as if they contained explicit braces. Implementations shall normalise such constructs to block scopes before name-resolution analysis.

[10] `use` declarations augment the surrounding module scope; they do not create nested lexical scopes. Imported bindings therefore share the module’s binding table and obey the single-namespace rule. Treating a `use` clause as a nested scope is ill-formed (diagnostic E06-202).

#### §6.2.4 Semantics [name.scope.semantics]

[11] Scope formation proceeds during parsing. Two-phase compilation (§2.2) records every scope boundary before semantic analysis so that forward references within a compilation unit are valid. Each scope owns a binding table populated as declarations are encountered.

[12] Shadowing is resolved lexically: when a nested scope declares an identifier marked with `shadow`, it inserts a new binding that temporarily overrides the ancestor binding for the duration of the nested scope. Without `shadow`, redeclaration in the same or nested scope triggers E06-300 (§6.3).

[13] Function scope exposes parameters and labels to all nested blocks. Block-local declarations do not escape their block even when references to them are captured by closures; closures capture the value, not the scope entry, and the captured value obeys the permission rules of Clause 11.

[14] Region blocks attach lifetime semantics to the bindings created within them; when the region closes, any region-allocated storage is reclaimed. Name visibility nonetheless follows ordinary block rules—bindings cease to exist after the closing brace.

#### §6.2.5 Examples (Informative) [name.scope.examples]

**Example 6.2.5.1 (Scope hierarchy with region blocks):**

```cursive
// Module scope: MODULE_CONST, helper, and main share the module binding table
let MODULE_CONST = 42

procedure helper(x: i32): i32
    [[ |- true => true ]]
{
    // Procedure scope begins here; parameter `x` and label `'retry` are visible throughout
    'retry: loop {
        let temp = x + MODULE_CONST  // `temp` is block-scoped within the loop body
        if temp > 100 {
            break 'retry
        }
        shadow let x = temp  // Allowed shadowing within the loop block
    }

    // Block scope ends; the shadowed `x` is gone, the original parameter `x` is still visible
    result x
}

public procedure main(): i32
    [[ |- true => true ]]
{
    let value = helper(10)
    {
        region session {
            let handle = open_resource()
            // `handle` visible only inside region block
        }
        // `handle` is out of scope here (and the resource has been reclaimed)
    }
    result value
}
```

#### §6.2.6 Conformance Requirements [name.scope.requirements]

[15] Implementations shall construct the scope tree described in this subclause during parsing, ensuring parent/child relationships are acyclic and well-defined (diagnostic E06-201 when violated).

[16] Implementations shall treat implicit blocks in control-flow constructs as lexical scopes equivalent to explicit braces before performing name lookup.

[17] Implementations shall enforce the procedure-scope visibility of parameters and labels and the block-scope visibility of local declarations, raising diagnostics when references escape their scope (E06-410 or context-specific errors).

[18] Implementations shall ensure region blocks behave as block scopes for name visibility while honouring the additional lifetime semantics defined in §11.3.


### §5.3 Name Introduction and Shadowing [name.shadow]

#### §5.3.1 Overview [name.shadow.overview]

[1] This subclause defines how declarations introduce bindings into the scope tree described in §6.2, the properties recorded on each binding, and the rules governing shadowing. Cursive’s unified namespace means every declaration, regardless of category (type, value, module, label), shares the same binding table per scope.

[2] The explicit `shadow` keyword enforces deliberate rebinding of outer-scope names. Without it, redeclaration in the same scope—or in a nested scope that would otherwise hide an outer binding—is ill-formed, preventing accidental name capture and improving clarity for both humans and tooling.

#### §6.3.2 Syntax [name.shadow.syntax]

[3] Binding-introducing declarations take one of the following forms (excerpted from Annex A §A.6):

**Declarations** take one of the following forms:
```
<variable_declaration>
<type_declaration>
<procedure_declaration>
<contract_declaration>
<behavior_declaration>
<grant_declaration>
<module_declaration>
<label_declaration>
```

**Variable declarations** match the pattern:
```
<binding_head> <pattern> [ ":" <type> ] "=" <expression>
```

**Binding heads** take one of the following forms:
```
"let"
"var"
"shadow" "let"
"shadow" "var"
"shadow" <identifier_declaration_head>
```

[ Note: See Annex A §A.6 [grammar.declaration] for complete declaration grammar. The `shadow` keyword may prefix variable bindings and other declaration forms.
— end note ]

[4] `identifier_declaration_head` captures non-variable declarations (type, procedure, module, etc.) that may legally use `shadow`. Full grammar details appear in Annex A §A.6; this subclause restricts when the `shadow` prefix is valid.

[ Note: `identifier_declaration_head` is a placeholder for the leading keywords of other declaration forms, such as `type`, `procedure`, `record`, etc. It signifies that the `shadow` keyword can prefix not just `let` and `var`, but any declaration that introduces an identifier. — end note ]

#### §6.3.3 Constraints [name.shadow.constraints]

[5] Every declaration introduces at most one binding per identifier. Multiple declarators in the same statement are prohibited; use pattern destructuring when multiple identifiers are required (§5.2).

[6] Redeclaring a name within the same scope without `shadow` is ill-formed (diagnostic E06-300). The rule applies uniformly across categories: a type cannot be redeclared as a value, nor a value as a type, in the same scope.

[7] The `shadow` keyword may appear only in a scope strictly nested within the scope that defines the original binding. Using `shadow` in the same scope as the target binding or at module scope is ill-formed (diagnostic E06-301).

[8] `shadow` shall not target predeclared/built-in identifiers from the universe scope (§6.6). Attempts to shadow such bindings are rejected (diagnostic E06-302).

[9] Shadowing preserves visibility modifiers from the new declaration; visibility is not inherited from the shadowed binding. A `shadow` declaration must spell out its own visibility when applicable.

[10] Pattern destructuring with `shadow` (e.g., `shadow let {x, y}`) may only shadow identifiers that already exist in an enclosing scope. All identifiers in the pattern must correspond to bindings that can be shadowed; otherwise, diagnostic E06-303 is emitted.

#### §6.3.4 Semantics [name.shadow.semantics]

[11] When a declaration introduces a binding, the compiler records the following metadata and inserts it into the current scope's binding table:

- **identifier**: The name of the binding
- **entity**: The bound entity (value, type, module, etc.)
- **type**: The type of the binding
- **visibility**: Visibility modifier (public, internal, private, protected)
- **cleanup_responsibility**: Whether binding is responsible for calling destructor (boolean)
- **rebindability**: Whether binding can be reassigned (`let` vs `var`)
- **source_location**: File, line, and column for diagnostics

[11.1] Cleanup responsibility is determined by:

- For variable bindings: Assignment operator (`=` is responsible, `<-` is non-responsible)
- For procedure parameters: Presence of `move` modifier (`move param` is responsible, `param` is non-responsible)
- For pattern bindings: Inherits from enclosing binding

[11.2] Two-phase compilation (§2.2) ensures that all bindings are recorded before semantic resolution proceeds. The binding metadata is used during type checking, move checking, and definite assignment analysis.

[12] During name lookup (§6.4), when a reference traverses from an inner scope to an outer scope, any inner binding marked with `shadow` masks the outer binding for the duration of that inner scope. Once control exits the inner scope, the original binding becomes visible again.

[13] Shadowing does not alter the lifetime or storage duration of the shadowed value; it simply changes which binding a given identifier resolves to. Values captured by closures retain the semantics defined in Clause 11 regardless of shadowing.

[14] Label declarations (e.g., `'loop`) participate in shadowing rules but are confined to procedure scope. A label declared with `shadow` must target a label from an enclosing block within the same procedure; cross-procedure label shadowing is impossible because labels do not escape their procedure (§6.2).

#### §6.3.5 Examples (Informative) [name.shadow.examples]

**Example 6.3.5.1 (Shadowing across nested scopes):**

```cursive
let threshold = 100  // Module-scope binding

procedure process(value: i32): i32
    [[ |- true => true ]]
{
    let result = value

    {
        shadow let result = result + threshold  // Shadows outer `result`
        if result > 200 {
            shadow let threshold = 150  // Shadows module-scope `threshold`
            return result - threshold
        }
        // `threshold` here still refers to 100; shadow lasts only inside inner block
    }

    return result
}

// Invalid: redeclaration without `shadow`
// let threshold = 200  // ERROR E06-300

// Invalid: `shadow` in same scope
// shadow let threshold = 200  // ERROR E06-301
```

#### §6.3.6 Conformance Requirements [name.shadow.requirements]

[15] Implementations shall maintain a single binding table per scope and reject duplicate entries unless the declaration uses `shadow` in a nested scope (E06-300).

[16] Implementations shall verify that `shadow` targets an existing binding in an enclosing scope, raising E06-301 when it targets the current scope and E06-303 when pattern elements do not correspond to existing bindings.

[17] Implementations shall prohibit shadowing of predeclared identifiers (E06-302) and ensure that shadowed labels remain confined to their procedure scope.


### §5.4 Name Lookup [name.lookup]

#### §5.4.1 Overview [name.lookup.overview]

[1] This subclause specifies the algorithms that map identifier occurrences to their bindings: unqualified lookup (single identifiers) and qualified lookup (`Prefix::Name`). The rules honour the scope tree defined in §6.2, the shadowing semantics of §6.3, and the visibility/export rules in Clause 4.

[2] Lookup is context-agnostic: it produces a binding independent of whether the identifier is used in a value or type position. Category checks occur after lookup (for example, using a type name in an expression is diagnosed by Clause 8).

#### §6.4.2 Syntax [name.lookup.syntax]

[3] Lookup operates on identifiers and qualified names:

**Unqualified names** are:
```
<identifier>
```

**Qualified names** match the pattern:
```
<identifier> "::" <identifier> [ "::" <identifier> ... ]
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `qualified_name` production.
— end note ]

[4] Longer chains (e.g., `pkg::module::Type::member`) are therefore part of the grammar itself; prefix resolution applies repeatedly to each `::` component (§6.4.4).

#### §6.4.3 Constraints [name.lookup.constraints]

[5] Unqualified lookup proceeds in a fixed order: current block scope → lexical ancestors → module scope → imported bindings → universe scope. Ambiguity or absence at any stage produces the diagnostics defined below.

[6] Qualified lookup requires the prefix to resolve to a module or type binding. Prefixes that resolve to other entities are rejected (diagnostic E06-402). Visibility of the suffix is enforced by the export rules in Clause 4; attempting to access a non-exported item produces E06-403.

[7] `use` bindings introduced in module scope participate in Step 4. Resolved names inherit any alias applied with `as`. Wildcard imports contribute all exported names from the target module; collisions are handled by §6.5.

[8] Universe-scope bindings (primitive types, constants, built-ins) are considered only after imported names. Implementations shall not treat predeclared names as candidates if they are explicitly listed as non-overridable in §6.6; user declarations that would mask such names shall be rejected per §6.6 (diagnostic E06-302).

#### §6.4.4 Semantics [name.lookup.semantics]

##### Unqualified Lookup

[9] The lookup algorithm searches scopes from innermost to outermost using the following procedure:

```
resolve_unqualified(name):
    // Step 1: current block scope
    if name ∈ bindings(current_scope):
        return bindings(current_scope)[name]

    // Step 2: lexical ancestors
    for scope in ancestors(current_scope):
        if name ∈ bindings(scope):
            return bindings(scope)[name]

    // Step 3: module scope
    if name ∈ bindings(module_scope):
        return bindings(module_scope)[name]

    // Step 4: imported bindings (module-level `use`)
    candidates := { b ∈ use_bindings(module_scope) | b.identifier == name }
    if |candidates| == 1:
        return candidates[0]
    if |candidates| > 1:
        error E06-400 (ambiguous identifier)  // see §6.5 for resolution strategies

    // Step 5: universe scope (predeclared identifiers)
    if name ∈ universe_scope:
        return universe_scope[name]

    error E06-401 (undefined identifier)
```

[10] Shadowed bindings in inner scopes mask outer bindings automatically because Step 1 and Step 2 encounter them first. Import aliases populate the alias map described in §4.3.4.1; they participate only when resolving qualified prefixes (Step 1 of §6.4.4) rather than as standalone bindings. The algorithm is deterministic and requires at most the lexical depth d of the reference, giving O(d) complexity.

##### Qualified Lookup

[11] A qualified reference `Prefix::Name` is resolved in two stages:

1. Resolve `Prefix` using `resolve_unqualified`.
2. Depending on the entity kind of `Prefix`:
   - **Module**: look up `Name` in the module’s export table; enforce visibility.
   - **Type**: look up associated items (methods, constants) exposed by the type; enforce access rules defined by the type’s module and visibility modifiers.

[12] Qualified chains longer than two components (e.g., `pkg::module::Type::method`) are resolved left-to-right, applying step 1 and step 2 repeatedly.

(12.1) _Intermediate failure handling._ When resolving a qualified chain `A::B::C::D`, if any intermediate component fails to resolve (e.g., `A::B` does not exist), the lookup terminates immediately and emits the appropriate diagnostic (E06-404 for missing module components, E06-405 for missing type components). Subsequent components in the chain are not evaluated. This ensures that diagnostics point to the first failing component rather than cascading errors.

(12.2) _Maximum chain length._ Implementations shall support qualified name chains of at least 32 components. Chains exceeding this limit may be rejected with diagnostic E06-406 (qualified name chain too long). This limit prevents pathological cases while accommodating deep module hierarchies.

[13] If the prefix is not a module or type, diagnostic E06-402 is emitted. If the suffix exists but is not exported, E06-403 is emitted; if it does not exist, E06-404 (module case) or E06-405 (type case) is emitted.

(13.1) _Empty module path components._ A qualified name may not contain empty components (e.g., `::Name` or `A::::B`). Such constructs are ill-formed and emit diagnostic E06-407 (empty qualified name component) during parsing, before lookup proceeds.

#### §6.4.5 Diagnostics [name.lookup.diagnostics]

[14] Lookup-related diagnostics defined in this subclause reference the structured payloads in Annex E §E.5:

| Code    | Condition                                         | Constraint |
| ------- | ------------------------------------------------- | ---------- |
| E06-400 | Ambiguous identifier (multiple imported)          | [6]        |
| E06-401 | Undefined identifier                              | [6]        |
| E06-402 | Prefix not module or type                         | [6]        |
| E06-403 | Item not exported                                 | [6]        |
| E06-404 | Module doesn't contain item                       | [13]       |
| E06-405 | Type doesn't expose associated item               | [13]       |
| E06-406 | Qualified name chain too long                     | [12.2]     |
| E06-407 | Empty qualified name component                    | [13.1]     |

[14.1] See §6.5 for disambiguation strategies for E06-400.

#### §6.4.6 Examples (Informative) [name.lookup.examples]

**Example 6.4.6.1 (Lookup order and qualification):**

```cursive
use math::geometry::{area, circumference as circle_circumference}

procedure demo(radius: f64): f64
    [[ |- true => true ]]
{
    let area = area(radius)                         // Steps 1–3 resolve local `area`
    let perimeter = circle_circumference(radius)    // Step 4 uses the alias
    let precise = math::geometry::area(radius)      // Qualified lookup
    let whole = i32(area)                           // Step 5: universe-scope primitive
    result perimeter + precise + whole
}
```

**Example 6.4.6.2 (Ambiguous import diagnosis):**

```cursive
use lib_a::process
use lib_b::process

procedure run()
    [[ |- true => true ]]
{
    // ERROR E06-400: ambiguous identifier 'process'
    let value = process()
}
```

#### §6.4.7 Conformance Requirements [name.lookup.requirements]

[15] Implementations shall implement the five-step unqualified lookup algorithm and emit diagnostics E06-400 (ambiguity) and E06-401 (undefined) as appropriate.

[16] Implementations shall enforce qualified lookup rules, including prefix validation (E06-402), visibility (E06-403), existence checks (E06-404/E06-405), chain length limits (E06-406), and empty component detection (E06-407).

[17] Implementations shall integrate module exports and `use` bindings into Step 4 without creating additional lexical scopes (§6.2). Module re-exports (`public use`) must appear exactly as exported in import tables.

[18] Implementations shall expose lookup traces to tooling (for example, IDEs) showing the scope path and final binding, to assist diagnostics and AI feedback.


### §5.5 Disambiguation and Ambiguity [name.ambiguity]

#### §5.5.1 Overview [name.ambiguity.overview]

[1] This subclause defines how Cursive detects, diagnoses, and resolves ambiguous bindings uncovered by the lookup rules in §6.4. Ambiguity arises when multiple bindings with the same identifier are simultaneously visible (typically via imports or wildcard expansions). Rather than silently choosing one, Cursive requires explicit disambiguation to preserve predictability.

[2] The rules below specify when ambiguity is reported, how programmers can disambiguate (qualification, aliasing, or scope restriction), and which diagnostics implementations must emit.

#### §6.5.2 Ambiguity Detection [name.ambiguity.detection]

[3] Ambiguity occurs exactly when Step 4 of the unqualified lookup algorithm (§6.4.4) yields more than one candidate binding for the same identifier. The lookup procedure shall emit diagnostic **E06-400** with payload enumerating every contributing module or alias.

[4] Ambiguity is never resolved by declaration order, import order, or visibility precedence. If two candidates survive Steps 1–3 and differ only in origin, the diagnostic is mandatory; the program is ill-formed until disambiguated.

[5] Qualified lookup (`Prefix::Name`) is never ambiguous because the prefix identifies a single namespace. If the prefix itself is ambiguous, it triggers E06-400 during prefix resolution prior to the qualified lookup stage.

#### §6.5.3 Disambiguation Techniques [name.ambiguity.resolution]

[6] Cursive provides three orthogonal strategies for eliminating ambiguity:

- **Explicit qualification**: Write `module::Name` (or `Type::Name`) to select a particular binding. Any entity that triggered the ambiguity may be referenced this way.
- **Alias introduction**: Attach `as alias` to one or more `use` declarations so subsequent unqualified references resolve uniquely.
- **Scope restriction**: Remove or narrow the `use` declaration supplying the unwanted binding (for example, replace wildcard imports with explicit lists).

[7] Implementations shall accept the program once all ambiguous references have been rewritten using one of the strategies above and re-run lookup accordingly.

[8] Disambiguation does not alter shadowing semantics. A `shadow` declaration can mask an imported binding, but it does not resolve the ambiguity among imports; the ambiguity must be addressed before shadowing rules are considered.

#### §6.5.4 Diagnostics [name.ambiguity.diagnostics]

[9] Diagnostic **E06-400** shall include:

- The ambiguous identifier.
- The set of modules/aliases contributing candidates.
- Suggested fixes (qualification or alias introduction) as informative notes.
- Structured payload as defined in Annex E §E.5 for tooling consumption.

[10] Additional errors may cascade (e.g., “missing `use` alias” suggestions) but shall not suppress E06-400.

#### §6.5.5 Examples (Informative) [name.ambiguity.examples]

**Example 6.5.5.1 (Ambiguous imports requiring qualification):**

```cursive
use lib_a::process
use lib_b::process  // Same identifier imported twice

procedure run()
    [[ |- true => true ]]
{
    // ERROR E06-400: ambiguous identifier 'process'
    // Candidates: lib_a::process, lib_b::process
    // Suggested fixes:
    //   - qualify as lib_a::process(...)
    //   - alias: use lib_b::process as process_b
    let value = process()
}
```

[1] The ambiguity arises from importing the same identifier from two different modules. Disambiguation requires explicit qualification or aliasing.

**Example 6.5.5.2 (Resolving ambiguity via aliasing):**

```cursive
use math::geometry::*
use math::analytics::*
use math::analytics::area as analytics_area

let a = area(5.0)             // OK: geometry::area
let b = analytics_area(5.0)   // OK: analytics::area via alias
```

#### §6.5.6 Conformance Requirements [name.ambiguity.requirements]

[11] Implementations shall detect ambiguous unqualified references per §6.5.2 and emit E06-400 with the payload described above.

[12] Implementations shall honour programmer disambiguation by recomputing lookup after qualification, aliasing, or scope changes and shall not cache the prior ambiguous state.

[13] Implementations shall not attempt heuristic tie-breaking; if multiple candidates remain after all deterministic steps, the program is ill-formed until the programmer resolves the ambiguity.


### §5.6 Predeclared Bindings [name.predeclared]

#### §5.6.1 Overview [name.predeclared.overview]

[1] This subclause enumerates the identifiers that exist in the universe scope without explicit user declarations—primitive types, literals, and built-in operators—and defines the rules governing their visibility, protection, and interaction with user-defined bindings.

[2] Predeclared bindings are always reachable during lookup (Step 5 in §6.4) but cannot be redefined or shadowed. They provide the stable foundation required for type checking, literals, and intrinsic operations.

#### §6.6.2 Catalogue [name.predeclared.catalogue]

[3] Implementations shall provide at least the following universe-scope bindings:

- **Primitive scalar types**: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, `f32`, `f64`, `bool`, `char`, `string`.
- **Unit and never types**: `()` (unit), `!` (never).
- **Boolean constants**: `true`, `false`.
- **Numeric literal helpers**: literal suffix constructors matching the primitive types above.
- **Intrinsic operations**: `panic`, `assert` (if included in the core language; optional extensions may add more).
- **Pointer helpers**: `Ptr` (subject to §7.5).

[4] Implementations may extend this set with additional intrinsics, but they shall document the extensions and adhere to the protection rules below.

#### §6.6.3 Constraints [name.predeclared.constraints]

[5] Predeclared identifiers occupy the universe scope and are visible in every module without import. They do not obey visibility modifiers and cannot be hidden by module exports or `use` clauses.

[6] Any attempt to redeclare or shadow a predeclared identifier shall be rejected with diagnostic **E06-302** (alias for historical E3D12). The prohibition applies to both direct declarations (`let i32 = …`) and shadowing forms (`shadow let i32 = …`).

[7] Predeclared identifiers participate in lookup only after Steps 1–4 (§6.4.4). Because redeclaration is forbidden, user programs cannot mask them; if an implementation extension allows masking, it does not conform to this specification.

[8] Aliasing predeclared identifiers is permitted only through explicit declarations (for example, `type MyInt = i32`). `use` aliasing of universe-scope names is prohibited and shall be diagnosed as E06-302.

#### §6.6.4 Diagnostics [name.predeclared.diagnostics]

[9] Diagnostic **E06-302** shall include:

- The forbidden identifier.
- Whether the attempt was a redeclaration or a `shadow`.
- A note indicating that the identifier is predeclared.
- Suggested fix: choose a different name.

Structured payload requirements are defined in Annex E §E.5.

#### §6.6.5 Examples (Informative) [name.predeclared.examples]

**Example 6.6.5.1 (Using and protecting predeclared identifiers):**

```cursive
let value: i32 = 42       // OK: reference to predeclared primitive in Step 5
let flag = true && false  // OK: boolean constants from universe scope
let point: (f64, f64) = (0.0, 1.0)

// Invalid: attempting to redefine a primitive type
// let i32 = 10            // ERROR E06-302: 'i32' is predeclared

{
    // Invalid: attempting to shadow a predeclared identifier
    // shadow let bool = get_flag()  // ERROR E06-302
}

// Valid alias via type declaration
type MyInt = i32
let number: MyInt = 5
```

#### §6.6.6 Conformance Requirements [name.predeclared.requirements]

[10] Implementations shall populate the universe scope with at least the bindings listed in §6.6.2 and any additional ones promised by implementation documentation.

[11] Implementations shall reject any redeclaration, shadowing, or `use` aliasing of predeclared identifiers with E06-302 and ensure such identifiers never appear in Steps 1–4 of the lookup algorithm.

[12] Implementations shall ensure that diagnostics referencing predeclared bindings include the structured payload required by Annex E §E.5 for tooling.


### §6.1 Type System Overview [type.overview]

[1] This clause specifies the static type system that governs every well-formed Cursive program. The type system classifies values, constrains expressions, coordinates permissions and grants, and ensures that well-typed programs avoid undefined behavior attributable to type errors.

[2] Cursive's type discipline is primarily nominal, augmented with structural forms where doing so preserves zero abstraction cost and local reasoning. Bidirectional type inference is an intrinsic design goal: the type checker flows information both from expressions to their contexts and from contexts into expressions so that most local declarations do not require redundant annotations while still keeping inference predictable.

#### §6.1.1 Design Objectives [type.overview.objectives]

[3] The type system shall satisfy the following objectives:

- **Safety**: Typing judgments preclude use-after-free, type confusion, and contract violations when combined with the permission (§10) and contract (§11) systems.
- **Determinism**: Type checking is deterministic with respect to the source program, the available grants, and the compilation environment.
- **Explicitness**: Grants, modal states, and region usage are reflected in type constructors, ensuring that each obligation is visible in source.
- **Composability**: Types compose predictably through generics, unions, and composite constructors without hidden coercions or implicit special cases.
- **LLM-friendly regularity**: Type formation rules, inference heuristics, and rule names follow consistent patterns so that automated tooling can reason locally.

#### §6.1.2 Permission-Qualified Types [type.overview.permissions]

[3.1] Permission qualifiers (const, unique, shared) attach to types at binding sites. Complete permission semantics are specified in §10.4 [memory.permission].

#### §6.1.3 Typing Judgments and Notation [type.overview.judgments]

[4] The core judgments reused throughout Clause 6 are:

- $\Gamma \vdash \tau : \text{Type}$ — $\tau$ is a well-formed type under environment $\Gamma$.
- $\Gamma \vdash e : \tau \; ! \varepsilon$ — expression $e$ has type $\tau$ and requires grant set $\varepsilon$.
- $\tau_1 <: \tau_2$ — subtyping relation defined in §6.7 [type.relation].
- $\tau_1 \simeq \tau_2$ — type equivalence relation that respects aliases and structural normalization (§6.7.2).

[5] Type environments bind term variables to types, type variables to kinds (with optional behavior bounds), grant parameters to grant sets, and modal parameters to state constraints. Environment formation and lookup rules follow §1.3 [intro.terms] conventions; §6.7 restates any additional obligations introduced by subtype or modal analysis.

#### §6.1.4 Guarantees [type.overview.guarantees]

[6] A program that satisfies all typing, permission, and contract judgments shall not:

- Invoke undefined behavior listed in Annex B due to type mismatches.
- Access memory through an invalid pointer representation (permissions enforce aliasing rules).
- Invoke a procedure without possessing the grants named in its signature.
- Transition a modal value to a state not permitted by its modal type.

[7] Bidirectional inference is sound and complete with respect to the declarative typing rules stated in §§6.2–6.7. When local annotations are omitted, inference succeeds if and only if a unique principal type exists under the rules of this clause. Situations requiring programmer guidance (e.g., ambiguous unions or polymorphic recursion) shall elicit diagnostics that point to the relevant obligation.

#### §6.1.5 Examples (Informative) [type.overview.examples]

**Example 6.1.6.1 (Bidirectional inference with unions):**

```cursive
procedure normalize(input: stream::Line): string \/ io::Error
    [[ io::read |- input.is_open() => result is string \/ io::Error ]]
{
    let trimmed = input.text().trim();        // Context infers `string`
    if trimmed.is_empty() {
        result io::Error::invalid_data("empty line")
    } else {
        result trimmed
    }
}
```

[21] The return type annotation supplies the expected union. The `result` statements rely on automatic widening (`string <: string \/ io::Error`) and on the contractual sequent to document the grant requirements.

**Example 6.1.6.2 (Pointer state integrated with permissions):**

```cursive
procedure swap_current(~!, nodes: list::Iterator@Active, value: Node)
    [[ allocator::unique |- nodes.has_current() => nodes.current() == value ]]
{
    let target: Ptr<Node>@Valid = nodes.current_ptr();
    target.write(value);   // Pointer type ensures state validity and unique access
}
```

[22] The pointer type records both the region (`PointerType`, §7.5) and the modal state (`@Valid`). The contract and grant annotations rely on the type system to guarantee that the write is safe.


### §6.2 Primitive Types [type.primitive]

[1] Primitive types are the built-in scalar types whose size, representation, and value sets are fixed by this specification. They form the base cases for well-formed type construction (§7.1.3) and participate directly in the arithmetic, logical, and conversion operators defined in Clause 8.

[2] Cursive provides six primitive categories: integer types (§7.2.2), floating-point types (§7.2.3), the boolean type (§7.2.4), the character type (§7.2.5), the unit type (§7.2.6), and the never type (§7.2.7). All primitive types satisfy the `Copy` predicate (§11.4) and impose no ownership obligations beyond those of their containing bindings.

[3] Primitive types integrate with other language components as follows:

- **Expressions** (§8.2–§8.6) evaluate primitive literals, arithmetic, and logical operators.
- **Generics** (Clause 10) permit primitive types as actual arguments and support specialization.
- **Memory model** (Clause 11) defines layout, alignment, and region interactions for primitive values.
- **Contracts and predicates** (Clause 12, §10.4) use primitive types in preconditions and grants without additional witness requirements.

#### §7.2.1 Syntax [type.primitive.syntax]

[4] Primitive types include integer types (`i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`), floating-point types (`f32`, `f64`), `bool`, `char`, unit type `()`, and never type `!`.

[ Note: See Annex A §A.3 [grammar.type] for the normative `PrimitiveType` production. — end note ]

[5] These identifiers are reserved (§5.6). Attempting to redeclare or shadow them is ill-formed (diagnostic E06-001).

#### §7.2.2 Integer Types [type.primitive.int]

##### §7.2.2.1 Overview

[6] Integer types represent fixed-width, twos-complement (signed) or binary (unsigned) integers. They support exact arithmetic operations defined in §8.5.2 and participate in bitwise operations (§8.5.4), shifts (§8.5.5), and comparison operators (§8.5.6).

##### §7.2.2.2 Value Sets and Layout [type.primitive.int.values]

[7] Table 7.2.1 enumerates the value set and layout of each integer type.

**Table 7.2.1 — Integer type ranges and layout**

| Type    | Value set $\llbracket T \rrbracket$     | Minimum                    | Maximum                    | Size        | Alignment       |
| ------- | --------------------------------------- | -------------------------- | -------------------------- | ----------- | --------------- |
| `i8`    | $\mathbb{Z} \cap [-2^7, 2^7-1]$         | −128                       | 127                        | 1 byte      | 1 byte          |
| `i16`   | $\mathbb{Z} \cap [-2^{15}, 2^{15}-1]$   | −32,768                    | 32,767                     | 2 bytes     | 2 bytes         |
| `i32`   | $\mathbb{Z} \cap [-2^{31}, 2^{31}-1]$   | −2,147,483,648             | 2,147,483,647              | 4 bytes     | 4 bytes         |
| `i64`   | $\mathbb{Z} \cap [-2^{63}, 2^{63}-1]$   | −9,223,372,036,854,775,808 | 9,223,372,036,854,775,807  | 8 bytes     | 8 bytes         |
| `i128`  | $\mathbb{Z} \cap [-2^{127}, 2^{127}-1]$ | −$2^{127}$                 | $2^{127}-1$                | 16 bytes    | 8 or 16 bytes\* |
| `isize` | $\mathbb{Z} \cap [-2^{n-1}, 2^{n-1}-1]$ | platform                   | platform                   | $n/8$ bytes | $n/8$ bytes     |
| `u8`    | $\mathbb{N} \cap [0, 2^8-1]$            | 0                          | 255                        | 1 byte      | 1 byte          |
| `u16`   | $\mathbb{N} \cap [0, 2^{16}-1]$         | 0                          | 65,535                     | 2 bytes     | 2 bytes         |
| `u32`   | $\mathbb{N} \cap [0, 2^{32}-1]$         | 0                          | 4,294,967,295              | 4 bytes     | 4 bytes         |
| `u64`   | $\mathbb{N} \cap [0, 2^{64}-1]$         | 0                          | 18,446,744,073,709,551,615 | 8 bytes     | 8 bytes         |
| `u128`  | $\mathbb{N} \cap [0, 2^{128}-1]$        | 0                          | $2^{128}-1$                | 16 bytes    | 8 or 16 bytes\* |
| `usize` | $\mathbb{N} \cap [0, 2^{n}-1]$          | 0                          | platform                   | $n/8$ bytes | $n/8$ bytes     |

\*Implementations shall document whether 128-bit integers align to 8 or 16 bytes.

[8] The pointer-width-dependent parameter $n$ equals 32 on 32-bit targets and 64 on 64-bit targets. Implementations targeting additional widths shall publish their alignment choices and conformance evidence.

[9] Signed integers use two’s complement representation. The bit pattern for value $v$ is $v$ when $v \ge 0$ and $2^n + v$ otherwise. Unsigned integers use standard binary representation.

[10] Endianness is target-dependent. Implementations shall document the endianness used for integer storage.

##### §7.2.2.3 Syntax [type.primitive.int.syntax]

[11] Integer literals follow the lexical productions in §2.3, supporting decimal, hexadecimal (`0x`), octal (`0o`), and binary (`0b`) forms with optional `_` separators. Literal suffixes may be any integer type token (`123u16`, `0x10usize`).

##### §7.2.2.4 Constraints [type.primitive.int.constraints]

[12] Integer types are always well-formed:

$$
\dfrac{T \in \{i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize\}}{\Gamma \vdash T : \text{Type}}
\tag{WF-Int-Type}
$$

[13] An unsuffixed integer literal defaults to type `i32`. When a literal appears in a context requiring type $T$ and $\text{value}(n) \in \llbracket T \rrbracket$, the literal is typed as $T$ (contextual typing). Suffixes override both defaults and contextual expectations provided the value lies within $\llbracket T \rrbracket$.

##### §7.2.2.5 Semantics [type.primitive.int.semantics]

[14] Arithmetic operators `+`, `-`, `*`, `/`, `%` are defined on matching integer operand types (§8.5.2). Overflow behaviour is determined by operator form (wrapping, checked, saturating, or panicking). Bitwise operators (`&`, `|`, `^`, `~`, shifts) require the operands to be integer types (§8.5.4–§8.5.5).

[15] Integer-to-integer conversions follow these rules:

- Widening conversions (e.g., `u16` → `u32`, `i16` → `i32`) are implicit when required by the typing rules of §8, otherwise explicit via `as`.
- Narrowing conversions require `as` and shall diagnose potential data loss at compile time when the source expression is constant and out of range.
- Conversions between signed and unsigned integers are implementation-defined only with respect to wraparound; explicit casts define the bit interpretation as specified in §8.5.7.

##### §7.2.2.6 Diagnostic Requirements [type.primitive.int.diagnostics]

[16] Implementations shall emit at least the following diagnostics:

- **E02-206** — Invalid separator placement or literal out of range (§2.3.3).
- **E02-201** — Invalid escape sequence in numeric literal (§2.3.3).
- **E07-100** — Constant folding overflow (Clause 8 diagnostic catalog).
- **E07-101** — Division or remainder by zero detected statically (§8.5.2).

##### §7.2.2.7 Examples (Informative)

**Example 7.2.2.1 (Literal forms):**

```cursive
let decimal: const i32 = 1_000_000
let hex: const u32 = 0xFF00_FF00
let octal: const u16 = 0o755
let binary: const u8 = 0b1010_0101
let suffixed = 42usize
```

**Example 7.2.2.2 (Contextual typing and casts):**

```cursive
let timer: const u64 = 1_000          // literal widened from default i32
let pages: const u16 = 4096u16        // suffix ensures exact type
let bits = (timer as u128) << 8
```

---

#### §7.2.3 Floating-Point Types [type.primitive.float]

##### §7.2.3.1 Overview

[18] `f32` and `f64` implement IEEE 754-2019 binary floating-point arithmetic. They support finite numbers, subnormals, infinities, signed zeros, and NaNs. Operations follow IEEE rounding and exception semantics.

##### §7.2.3.2 Value Sets and Layout [type.primitive.float.values]

**Table 7.2.2 — Floating-point properties**

| Type  | IEEE 754 name | Size    | Alignment | Significand bits | Exponent range |
| ----- | ------------- | ------- | --------- | ---------------- | -------------- |
| `f32` | binary32      | 4 bytes | 4 bytes   | 24               | −126 to +127   |
| `f64` | binary64      | 8 bytes | 8 bytes   | 53               | −1022 to +1023 |

[19] Floating-point storage format matches the IEEE encoding. Implementations shall specify whether subnormals are flushed to zero; deviations render the implementation non-conforming.

##### §7.2.3.3 Syntax [type.primitive.float.syntax]

[20] Literals accept decimal and scientific notation with optional `_` separators (`0.5`, `3.14`, `6.022e23`, `1.0e-6`). Suffixes `f32` or `f64` select the type. Absence of suffix defaults to `f64`.

##### §7.2.3.4 Constraints [type.primitive.float.constraints]

$$
\dfrac{T \in \{f32, f64\}}{\Gamma \vdash T : \text{Type}}
\tag{WF-Float-Type}
$$

[21] Unsuffixed literals default to `f64`. Contextual typing may downcast to `f32` when the literal is representable (no rounding required beyond IEEE rules).

##### §7.2.3.5 Semantics [type.primitive.float.semantics]

[22] Arithmetic follows IEEE 754-2019 (§8.5.5). NaNs propagate through operations; `NaN != NaN`. Signed zeros compare equal yet produce sign-sensitive results for division and some transcendental functions. Comparison operators implement total ordering for `f64::total_cmp` style operations only when explicitly requested; ordinary comparisons follow IEEE partial ordering.

##### §7.2.3.6 Diagnostic Requirements [type.primitive.float.diagnostics]

[23] Diagnostics include:

- **E02-204** — Unterminated floating literal (§2.3, Annex E §E.5 diagnostics).
- **E02-212** — Literal out of range for chosen suffix (Annex E §E.5).
- **E07-102** — Invalid literal suffix (Annex E §E.5).
- **E07-103** — Constant folding overflow or division by zero at compile time (Annex E §E.5).

##### §7.2.3.7 Examples (Informative)

**Example 7.2.3.1 (Special values):**

```cursive
let pos_inf: const f64 = 1.0 / 0.0
let neg_inf: const f64 = -1.0 / 0.0
let nan_div: const f64 = 0.0 / 0.0
let signed_zero = (1.0 / pos_inf, 1.0 / neg_inf)  // (+0.0, -0.0)
```

**Example 7.2.3.2 (Precision considerations):**

```cursive
let delta64 = (0.1 + 0.2) - 0.3          // ≈ 5.551e-17
let delta32 = (0.1f32 + 0.2f32) - 0.3f32 // ≈ 5.960e-08
```

---

#### §7.2.4 Boolean Type [type.primitive.bool]

##### §7.2.4.1 Overview

[24] `bool` encodes two-valued logic. It serves as the condition type for control-flow constructs (§9.2) and supports logical operators (`&&`, `||`, `!`, `^`).

##### §7.2.4.2 Syntax and Constraints

$$
\dfrac{}{\Gamma \vdash bool : \text{Type}}
\tag{WF-Bool-Type}
$$

$$
\dfrac{}{\Gamma \vdash true : bool}
\tag{T-Bool-True}
$$

$$
\dfrac{}{\Gamma \vdash false : bool}
\tag{T-Bool-False}
$$

[25] `bool` literal tokens are `true` and `false`. No other tokens implicitly convert to `bool`; conversions shall use explicit tests.

##### §7.2.4.3 Semantics

[26] Logical operators short-circuit: `e₁ && e₂` skips `e₂` when `e₁` is `false`; `e₁ || e₂` skips `e₂` when `e₁` is `true`. `!` flips the truth value. Bitwise `^` corresponds to exclusive-or.

##### §7.2.4.4 Diagnostics

[27] **E07-104** — Non-`bool` operand supplied to logical operator (Clause 8 diagnostic). **E07-105** — `bool` used where numeric type required.

##### §7.2.4.5 Examples (Informative)

**Example 7.2.4.1 (Boolean operations):**

```cursive
let feature_enabled = config::flag("experimental")
let ready = feature_enabled && service().probe()
```

---

#### §7.2.5 Character Type [type.primitive.char]

##### §7.2.5.1 Overview

[28] `char` represents Unicode scalar values (code points excluding U+D800–U+DFFF). It stores a value as a 32-bit unsigned integer and interacts with string conversions (§7.3.4) and pattern matching (§8.4.6).

##### §7.2.5.2 Syntax and Constraints

$$
\dfrac{}{\Gamma \vdash char : \text{Type}}
\tag{WF-Char-Type}
$$

$$
\dfrac{c \in \text{ScalarValues}}{\Gamma \vdash c : char}
\tag{T-Char-Lit}
$$

[29] Character literals use single quotes and may include escape sequences listed in Table 7.2.3.

**Table 7.2.3 — Character literal escapes**

| Escape     | Meaning                         | Unicode |
| ---------- | ------------------------------- | ------- |
| `\n`       | Line feed                       | U+000A  |
| `\r`       | Carriage return                 | U+000D  |
| `\t`       | Horizontal tab                  | U+0009  |
| `\\`       | Backslash                       | U+005C  |
| `\'`       | Single quote                    | U+0027  |
| `\"`       | Double quote                    | U+0022  |
| `\0`       | Null                            | U+0000  |
| `\u{HHHH}` | Unicode scalar (1–6 hex digits) | U+HHHH  |

[30] Surrogates trigger diagnostic E07-106. Literals shall denote exactly one scalar value.

##### §7.2.5.3 Semantics

[31] Ordering compares code points numerically. `char` supports conversion to UTF-8/UTF-16 sequences via standard library routines (informative reference: Annex F §F.2).

##### §7.2.5.4 Examples (Informative)

**Example 7.2.5.1 (Character literals):**

```cursive
let letter: const char = 'A'
let emoji: const char = '\u{1F4A1}'
```

---

#### §7.2.6 Unit Type [type.primitive.unit]

##### §7.2.6.1 Overview

[32] The unit type `()` has a single inhabitant `()`. It represents absence of meaningful value, serves as the return type of procedures that only produce effects, and corresponds to the zero-element tuple.

##### §7.2.6.2 Constraints and Semantics

$$
\dfrac{}{\Gamma \vdash () : \text{Type}}
\tag{WF-Unit-Type}
$$

$$
\dfrac{}{\Gamma \vdash () : ()}
\tag{T-Unit-Lit}
$$

[33] `sizeof(()) = 0`, `alignof(()) = 1`. No storage is allocated for unit values; they may be freely elided.

##### §7.2.6.3 Examples (Informative)

**Example 7.2.6.1 (Unit return type):**

```cursive
procedure log_event(event: string)
    [[ io::write |- true => () ]]
{
    println("event: {}", event)
}
```

---

#### §7.2.7 Never Type [type.primitive.never]

##### §7.2.7.1 Overview

[34] The never type `!` is uninhabited. Expressions of type `!` represent computations that never produce a value (diverge, panic, or exit). `!` acts as the bottom of the subtype lattice; any value of type `!` can coerce to any type.

##### §7.2.7.2 Constraints and Semantics

$$
\dfrac{}{\Gamma \vdash ! : \text{Type}}
\tag{WF-Never-Type}
$$

$$
\dfrac{\Gamma \vdash e : ! \quad \Gamma \vdash \tau : \text{Type}}{\Gamma \vdash e : \tau}
\tag{Coerce-Never}
$$

[35] Since `!` has no values, `sizeof(!) = 0` and `alignof(!) = 1`. Moves and drops never occur.

##### §7.2.7.3 Examples (Informative)

```cursive
procedure fatal(error: string): !
    [[ diag::panic |- true => false ]]
{
    panic(error)
}

procedure compute_or_exit(code: i32): i32
    [[ process::exit |- true => true ]]
{
    if code >= 0 {
        result code
    } else {
        std::process::exit(code)  // type ! coerces to i32
    }
}
```

---

#### §7.2.8 Summary of Copy Behaviors [type.primitive.copy]

[ Note: Formal proofs that primitive types satisfy Copy are provided in Annex C §C.4 [formal.permission]. — end note ]

| Type           | Copy behavior               |
| -------------- | ---------------------------- |
| `IntegerTypes` | `T : Copy`                   |
| `f32`, `f64`   | `T : Copy`                   |
| `bool`         | `Copy`                      |
| `char`         | `Copy`                      |
| `()`           | `Copy`                      |
| `!`            | Vacuously `Copy`             |

All primitive types are therefore movable without consuming permissions.

#### §7.2.9 Conformance Requirements [type.primitive.requirements]

[36] A conforming implementation shall:

- Support every primitive type enumerated in paragraph [2] with the sizes, alignments, and value sets in §§7.2.2–7.2.7.
- Honour two-phase typing and inference: primitive literals shall type-check using the rules in this subclause without requiring speculative rewriting.
- Emit diagnostics listed in the corresponding subsections when literals or operations violate constraints.
- Expose primitive type metadata (size, alignment, name) through introspection facilities (§7.7.2) consistent with this clause.
- Prevent user programs from redeclaring primitive identifiers or altering their semantics.

[37] Deviations render the implementation non-conforming unless explicitly permitted as implementation-defined behaviour elsewhere in the specification.


### §6.3 Composite Types [type.composite]

[1] Composite types combine or select among other types. They cover structural products (tuples), nominal products (records), sequential collections (arrays, slices, strings, ranges), discriminated sums (enums), and safe unions (`τ₁ \/ τ₂`).

[2] Composite types integrate with permissions (§9.4), regions (§9.3), contracts (Clause 10), and generics (Clause 8). Each constructor follows the standard template: syntax, formation constraints, semantics, and canonical examples. Where relevant, Copy behaviors and size/alignment rules are stated explicitly.

[3] This subclause is organized as follows:

- §7.3.2 Tuples (structural products)
- §7.3.3 Records (nominal products with dual access)
- §7.3.4 Collections (arrays, slices, strings, ranges)
- §7.3.5 Enums (discriminated sums)
- §7.3.6 Union types (safe structural unions)
- §7.3.7 Conformance requirements

---

#### §7.3.2 Tuples [type.composite.tuple]

##### §7.3.2.1 Overview [type.composite.tuple.overview]

[4] Tuple types are anonymous structural products. Two tuple types are equivalent when they have the same arity and pairwise equivalent element types. Tuple components inherit the permissions of the aggregate.

##### §7.3.2.2 Syntax [type.composite.tuple.syntax]

[5] Tuple types require at least two elements. Single-element tuple syntax is prohibited to avoid ambiguity with parenthesized expressions. The zero-element product is the unit type (§7.2.6).

[ Note: See Annex A §A.3 [grammar.type] for the normative `TupleType` production. — end note ]

##### §7.3.2.3 Constraints [type.composite.tuple.constraints]

[7] Tuple well-formedness requires each component type to be well-formed:

$$
\dfrac{\Gamma \vdash \tau_1 : \text{Type} \quad \cdots \quad \Gamma \vdash \tau_n : \text{Type} \quad n \ge 2}{\Gamma \vdash (\tau_1, \ldots, \tau_n) : \text{Type}}
\tag{WF-Tuple}
$$

[8] Construction requires matching types for each element:

$$
\dfrac{\Gamma \vdash e_1 : \tau_1 \quad \cdots \quad \Gamma \vdash e_n : \tau_n}{\Gamma \vdash (e_1, \ldots, e_n) : (\tau_1, \ldots, \tau_n)}
\tag{T-Tuple-Ctor}
$$

[9] Projection is zero-based:

$$
\dfrac{\Gamma \vdash e : (\tau_1, \ldots, \tau_n) \quad 0 \le i < n}{\Gamma \vdash e.i : \tau_{i+1}}
\tag{T-Tuple-Proj}
$$

##### §7.3.2.4 Semantics [type.composite.tuple.semantics]

[10] Evaluation proceeds left-to-right; side effects in elements are sequenced accordingly. Runtime representation stores elements contiguously with padding inserted to satisfy each element’s alignment. Tuple alignment equals the maximum alignment of its elements; tuple size equals the padded sum of element sizes.

[11] Copy behavior and variance:

- $(\tau_1, \ldots, \tau_n)$ satisfies `Copy` iff every $\tau_i$ does.
- Tuples are invariant in each parameter position because elements may be both read and written.

##### §7.3.2.5 Examples (Informative) [type.composite.tuple.examples]

```cursive
let point: const (f64, f64) = (3.0, 4.0)
let (x, y) = point                 // Destructuring
let next = (x + 1.0, y + 1.0)      // New tuple, same structure
let dx = point.0                   // Positional access (0-based)
```

---

#### §7.3.3 Records [type.composite.record]

##### §7.3.3.1 Overview [type.composite.record.overview]

[12] Record types are nominal products with named fields and optional methods. They support dual access: named (`value.field`) and positional (`value.0`). Positional indices mirror declaration order and enforce the same visibility as named access.

##### §7.3.3.2 Syntax [type.composite.record.syntax]

[13] Record declarations consist of a record keyword, identifier, optional generic parameters, and a body containing field and method declarations. Visibility modifiers are `public`, `internal` (default), or `private` (§5.6).

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `RecordDecl` and `FieldDecl` productions. — end note ]

##### §7.3.3.3 Constraints [type.composite.record.constraints]

[14] Field names shall be unique. Each field's type shall be well-formed. Formally:

$$
\dfrac{\text{record } R \{ f_1 : \tau_1, \ldots, f_n : \tau_n \} \text{ declared} \quad \Gamma \vdash \tau_i : \text{Type}}{\Gamma \vdash R : \text{Type}}
\tag{WF-Record}
$$

[15] Construction and field access rules:

$$
\dfrac{\Gamma \vdash e_i : \tau_i}{\Gamma \vdash R \{ f_1 : e_1, \ldots, f_n : e_n \} : R}
\tag{T-Record-Ctor}
$$

$$
\dfrac{\Gamma \vdash e : R \quad f_k \text{ visible}}{\Gamma \vdash e.f_k : \tau_k}
\tag{T-Record-Field}
$$

$$
\dfrac{\Gamma \vdash e : R \quad 0 \le i < n \quad \text{field } i \text{ visible}}{\Gamma \vdash e.i : \tau_{i+1}}
\tag{T-Record-Pos}
$$

##### §7.3.3.4 Semantics [type.composite.record.semantics]

[16] Records are nominal: two records are equivalent iff they share the same declaration. Fields are laid out in declaration order with padding inserted as required. Dual access refers to the same storage location. Struct update syntax (`R { field: value, ..expr }`) copies unspecified fields from `expr`.

[17] Copy behavior: a record satisfies `Copy` iff every field does and no user-defined destructor is attached. Variance is invariant per field for the same reason as tuples.

##### §7.3.3.5 Examples (Informative) [type.composite.record.examples]

```cursive
record Point { x: f64, y: f64 }
let origin = Point { x: 0.0, y: 0.0 }
let translated = Point { x: 5.0, ..origin }
let x_named = translated.x         // Named access
let x_pos = translated.0           // Positional access (same field)
```

```cursive
record BankAccount {
    public number: u64,
    private balance: f64,
}

let acct = BankAccount { number: 10_001, balance: 250.0 }
let seen = acct.number             // OK (public)
// let hidden = acct.1            // ERROR: index 1 refers to private field
```

---

#### §7.3.4 Collections [type.composite.collection]

[18] Collections are sequential composites. They include fixed-size arrays, dynamic slices, modal strings, and range types used for iteration and slicing.

##### §7.3.4.1 Arrays [type.composite.collection.array]

###### Overview

[19] Arrays `[T; n]` store exactly `n` elements of type `T`. Length `n` is a compile-time constant. Arrays support indexing, slicing, and iteration.

###### Syntax

```
ArrayType ::= '[' Type ';' ConstExpr ']'
ArrayLiteral ::= '[' Expr (',' Expr)* ']' | '[' Expr ';' ConstExpr ']'
ArrayIndex ::= Expr '[' Expr ']'
```

###### Constraints

[20] Array formation:

$$
\dfrac{\Gamma \vdash \tau : \text{Type} \quad n \in \mathbb{N}^+}{\Gamma \vdash [\tau; n] : \text{Type}}
\tag{WF-Array}
$$

[21] Array literals require each element to type-check as `τ`. Repeat literals `[e; n]` require `e : τ` and `τ : Copy`.

###### Semantics

[22] Elements are stored contiguously with no padding between them. Array alignment equals `align(τ)`; size equals `n × size(τ)`. Indexing evaluates the index expression, converts it to `usize`, and performs bounds checking (§8.4.7). Out-of-bounds indices raise a runtime diagnostic unless proven safe at compile time.

[23] `Copy` holds for `[τ; n]` iff `τ : Copy`.

###### Examples (Informative)

```cursive
let numbers: [i32; 5] = [1, 2, 3, 4, 5]
let zeros: [i32; 8] = [0; 8]         // repeat syntax
let first = numbers[0]
let row: [f64; 3] = [[1.0, 0.0, 0.0],
                     [0.0, 1.0, 0.0],
                     [0.0, 0.0, 1.0]][1]
```

---

##### §7.3.4.2 Slices [type.composite.collection.slice]

###### Overview

[24] Slice types `[T]` are dynamic views over contiguous sequences of `T`. A slice stores a pointer and length; it does not own the underlying data. Permissions on the slice govern aliasing.

###### Syntax

```
SliceType ::= '[' Type ']'
SliceExpr ::= Expr '[' RangeExpr? ']'
```

###### Constraints

[25] Slice formation:

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash [\tau] : \text{Type}}
\tag{WF-Slice}
$$

Slicing requires the source to be an array, owned string, or pointer supporting the slicing operation, and the range to be within bounds.

###### Semantics

[26] A slice value is `{ ptr: Ptr<τ>, len: usize }`. Copy behavior: a slice satisfies `Copy` because the view is immutable with respect to ownership; mutability is represented through permissions on the pointer. Indexing a slice is identical to array indexing with bounds checking.

###### Examples (Informative)

```cursive
let data: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
let head: [u8] = data[..4]     // elements 0..3
let tail: [u8] = data[6..]     // elements 6..9
procedure checksum(bytes: [u8]): u8 { bytes.iter().fold(0, add) }
checksum(data[..])
```

---

##### §7.3.4.3 Strings [type.composite.collection.string]

###### Overview

[27] Strings are UTF-8 sequences with two modal states (defined in §7.6):

- `string@Managed`: growable, heap-allocated buffer (`ptr`, `len`, `cap`), not `Copy`.
- `string@View`: read-only view over UTF-8 data (`ptr`, `len`), `Copy`.

(27.1) **String type defaulting**: A bare `string` identifier in a type annotation defaults to `string@View`. The `string@Managed` state shall be explicitly specified. This default aligns with the common use case of string parameters and return types, which typically use read-only views. There is an implicit coercion `string@Managed <: string@View` established via the modal subtyping rule (`Sub-Modal-Widen`).

###### Syntax

```
StringType ::= 'string'              // Defaults to string@View in annotations
             | 'string' '@Managed'
             | 'string' '@View'
StringLiteral ::= '"' UTF8Text '"'
```

[ Note: See Annex A §A.2 for the authoritative grammar. — end note ]

(27.2) `string` is a built-in modal type (§7.6) with two states:

- `string@Managed` — manages heap-allocated UTF-8 storage and may reallocate or mutate.
- `string@View` — an immutable span consisting of pointer + length.
  Transition signatures `string@Managed::view(~) -> @View` and `string@View::to_managed(~) -> @Managed` define the canonical conversions.

###### Constraints

[28] Well-formedness follows the modal formation rules (§7.6). String literals have type `string@View`. Conversions:

- `string.from(view: string@View) : string@Managed`
- `view.to_managed() : string@Managed`
- Implicit coercion `string@Managed` → `string@View`

###### Semantics

[29] Layout on 64-bit targets:

- `string@Managed`: `{ ptr: Ptr<u8>, len: usize, cap: usize }` (24 bytes)
- `string@View`: `{ ptr: Ptr<u8>, len: usize }` (16 bytes)

`string@View : Copy`; `string@Managed` is movable but not `Copy`. All string forms guarantee UTF-8 validity, and `string@Managed` values implicitly coerce to `string@View` by invoking the modal transition above.

**Example 7.3.4.3.1 (Managed/View transitions):**

```cursive
let greeting: string@Managed = string.from("hello")
let view: string@View = greeting.view()    // implicit when needed
print_line(view)

let roundtrip: string@Managed = view.to_managed()
print_line(roundtrip.view())
```

[ Note: The procedures `view()` and `to_managed()` are mnemonics for the modal transitions declared in §7.6; concrete names will follow the eventual Clause 10/standard library surface when specified. — end note ]

###### Examples (Informative)

**Example 7.3.4.3.2 (String type defaulting):**

```cursive
// Bare 'string' defaults to string@View
procedure print_line(text: string) {      // text: string@View
    io::write_all(text)
}

// Explicit states must be specified for managed strings
let managed: string@Managed = string.from("hello")
let view: string@View = managed           // implicit coercion
let also_view: string = managed           // bare 'string' = string@View

print_line(view)
print_line(also_view)
print_line("literal")                     // literal : string@View
```

---

##### §7.3.4.4 Range Types [type.composite.collection.range]

###### Overview

[30] Range types underpin slicing and iteration. Cursive provides six constructors: `Range<T>`, `RangeInclusive<T>`, `RangeFrom<T>`, `RangeTo<T>`, `RangeToInclusive<T>`, and `RangeFull<T>`.

###### Syntax

Range literals map to constructors:

| Literal | Type constructor      | Bounds                         |
| ------- | --------------------- | ------------------------------ |
| `a..b`  | `Range<T>`            | inclusive start, exclusive end |
| `a..=b` | `RangeInclusive<T>`   | inclusive start and end        |
| `a..`   | `RangeFrom<T>`        | inclusive start, unbounded end |
| `..b`   | `RangeTo<T>`          | unbounded start, exclusive end |
| `..=b`  | `RangeToInclusive<T>` | unbounded start, inclusive end |
| `..`    | `RangeFull<T>`        | unbounded start and end        |

###### Constraints

[31] Each constructor is well-formed when `Γ ⊢ T : Type`:

$$
\dfrac{\Gamma \vdash T : \text{Type}}{\Gamma \vdash Range<T> : \text{Type}}
\quad
\cdots
\quad
\dfrac{\Gamma \vdash T : \text{Type}}{\Gamma \vdash RangeFull<T> : \text{Type}}
\tag{WF-Range}
$$

###### Semantics

[32] Ranges carry optional bounds. `Range<T>` stores `{ start_present: bool, start: T, end_present: bool, end: T, inclusive: bool }` with `inclusive = false`. `RangeInclusive<T>` stores `{ start: T, end: T }` (bounds always present). `RangeFull<T>` has no fields (unbounded). Bounds are evaluated eagerly; illegal constructions (e.g., `a..b` with `b < a` for numeric ranges) are diagnosed by the consuming API.

###### Examples (Informative)

```cursive
let data: [u8; 8] = [10, 11, 12, 13, 14, 15, 16, 17]
let prefix = data[..4]
let suffix = data[4..]
loop i in 0..data.len() { println("{}", data[i]) }
```

---

#### §7.3.5 Enums [type.composite.enum]

##### §7.3.5.1 Overview [type.composite.enum.overview]

[33] Enums are nominal discriminated sums. Variants may be unit-like, tuple-like, or struct-like. Exhaustive pattern matching is required to ensure all variants are handled.

##### §7.3.5.2 Syntax [type.composite.enum.syntax]

[33] Enum declarations consist of an enum keyword, identifier, optional generic parameters, and a body containing variant declarations. Variants may be unit-like (no payload), tuple-like (parenthesized type list), or record-like (braced field list).

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `EnumDecl` and `VariantDecl` productions. — end note ]

##### §7.3.5.3 Constraints [type.composite.enum.constraints]

[34] Variants shall have unique names. Payload types shall be well-formed under the enum's generic parameters:

$$
\dfrac{\Gamma, \vec{\alpha} \vdash \tau_i : \text{Type}}{\Gamma \vdash enum\;E\langle \vec{\alpha} \rangle : \text{Type}}
\tag{WF-Enum}
$$

[35] Variant construction typing rules follow the payload form (unit, tuple, struct). Generic instantiation requires well-formed arguments.

##### §7.3.5.4 Semantics [type.composite.enum.semantics]

[36] Each enum value stores a discriminant plus payload. Layout is implementation-defined but shall allocate enough space for the largest payload and align to the maximum payload alignment. `Copy` holds iff every variant payload satisfies `Copy` and no destructor is defined.

[37] Pattern matching shall be exhaustive. The compiler emits a compile-time error when variants remain unmatched. Wildcards (`_`) count as covering remaining cases.

##### §7.3.5.5 Examples (Informative) [type.composite.enum.examples]

```cursive
enum Status {
    Pending,
    Running,
    Completed,
}

match Status::Running {
    Status::Pending => println("Not started"),
    Status::Running => println("In progress"),
    Status::Completed => println("Done"),
}
```

```cursive
enum Shape {
    Point,
    Circle(f64),
    Rectangle { width: f64, height: f64 },
}

let circle = Shape::Circle(2.0)
match circle {
    Shape::Point => println("point"),
    Shape::Circle(r) => println("radius {}", r),
    Shape::Rectangle { width, height } => println("{} × {}", width, height),
}
```

---

#### §7.3.6 Union Types [type.composite.union]

##### §7.3.6.1 Overview [type.composite.union.overview]

[38] Safe union types use the **union operator `\/` (reads as "or")** to combine types structurally. They are discriminated unions with automatically inserted runtime tags that track which component type is active. Unlike enums (which are nominal and require explicit declaration), unions are structural and may be formed inline without prior declaration.

[39] Union types enable error handling, optional values, and control-flow merging without manual wrapper types. The type system automatically widens component types to the union and enforces exhaustive pattern matching.

##### §7.3.6.2 Syntax [type.composite.union.syntax]

[40] Union type syntax:

```
UnionType ::= Type '\/' Type ('\/' Type)*
```

[ Note: See Annex A §A.3 [grammar.type] for complete union type grammar.
— end note ]

[41] **Union properties**:

- **Binary operator**: `\/` is a type-level binary operator
- **Associative**: `(τ₁ \/ τ₂) \/ τ₃ ≡ τ₁ \/ (τ₂ \/ τ₃)`
- **Commutative**: `τ₁ \/ τ₂ ≡ τ₂ \/ τ₁`
- **Idempotent**: `τ \/ τ ≡ τ`
- **Flattening**: Nested unions automatically flatten: `(τ₁ \/ τ₂) \/ τ₃ ≡ τ₁ \/ τ₂ \/ τ₃`

[42] Component ordering is semantically immaterial; `i32 \/ string` and `string \/ i32` denote the same type after normalization.

##### §7.3.6.3 Constraints [type.composite.union.constraints]

##### §7.3.6.3.1 Formation

[43] A union is well-formed when each component type is well-formed:

**Binary union formation:**

$$
\dfrac{\Gamma \vdash \tau_1 : \text{Type} \quad \Gamma \vdash \tau_2 : \text{Type}}{\Gamma \vdash \tau_1 \/ \tau_2 : \text{Type}}
\tag{WF-Union-Binary}
$$

**N-ary union formation:**

$$
\dfrac{\Gamma \vdash \tau_1 : \text{Type} \quad \cdots \quad \Gamma \vdash \tau_n : \text{Type} \quad n \geq 2}{\Gamma \vdash \tau_1 \/ \cdots \/ \tau_n : \text{Type}}
\tag{WF-Union-Nary}
$$

[44] **Normalization**: Implementations shall normalize unions by:

1. Flattening nested unions: `(τ₁ \/ τ₂) \/ τ₃` → `τ₁ \/ τ₂ \/ τ₃`
2. Removing duplicates: `τ \/ τ \/ υ` → `τ \/ υ`
3. Sorting components by canonical order (implementation-defined but stable)

After normalization, union types are compared component-wise for equivalence.

##### §7.3.6.3.2 Subtyping

[45] Each component type is automatically a subtype of the union:

**Component introduction:**

$$
\dfrac{i \in [1..n]}{\tau_i <: \tau_1 \/ \cdots \/ \tau_n}
\tag{Sub-Union-Intro}
$$

**Union subsumption:**

$$
\dfrac{\forall i.\, \tau_i <: \upsilon_1 \/ \cdots \/ \upsilon_m}{\tau_1 \/ \cdots \/ \tau_n <: \upsilon_1 \/ \cdots \/ \upsilon_m}
\tag{Sub-Union-Subsumption}
$$

If every component of the left union is a subtype of the right union (or one of its components), then the left union is a subtype of the right union.

[46] **Automatic widening**: Expressions of type `τᵢ` automatically coerce to type `τ₁ \/ ... \/ τₙ` when required by context:

$$
\dfrac{\Gamma \vdash e : \tau_i \quad \tau_i <: \tau_1 \/ \cdots \/ \tau_n}{\Gamma \vdash e : \tau_1 \/ \cdots \/ \tau_n}
\tag{Coerce-Union-Widen}
$$

This enables returning different component types from the same procedure without explicit wrapper construction.

##### §7.3.6.3.3 Pattern Matching and Exhaustiveness

[47] Pattern matching on unions requires exhaustive coverage of all component types:

**Exhaustiveness rule:**

[ Given: Union type $\tau_1 \/ \cdots \/ \tau_n$, match patterns $p_1, \ldots, p_m$ ]

$$
\dfrac{\bigcup_{j=1}^{m} \text{cover}(p_j) \supseteq \{\tau_1, \ldots, \tau_n\}}{\text{match}(\tau_1 \/ \cdots \/ \tau_n, [p_1, \ldots, p_m]) \text{ is exhaustive}}
\tag{WF-Union-Exhaustive}
$$

[48] Incomplete matches produce diagnostic E08-450 (non-exhaustive union match). Wildcard patterns (`_`) satisfy exhaustiveness for all remaining component types.

[49] **Type refinement in patterns**: Within a match arm matching component type `τᵢ`, the matched value is refined to type `τᵢ`:

```cursive
let result: i32 \/ Error = compute()

match result {
    value: i32 => {
        // value has type i32 here (refined)
        println("Success: {}", value)
    }
    error: Error => {
        // error has type Error here (refined)
        println("Failed: {}", error.message)
    }
}
```

##### §7.3.6.4 Semantics [type.composite.union.semantics]

##### §7.3.6.4.1 Runtime Representation

[50] Union types use **tagged union** representation:

**Layout:**

```
struct Union<T₁, ..., Tₙ> {
    discriminant: usize,           // Which component is active
    payload: max_size(T₁, ..., Tₙ) // Storage for largest component
}
```

[51] **Discriminant**: The discriminant is an unsigned integer requiring minimum bits to represent $n$ component types:

- 2-3 components: 2 bits (u8)
- 4-255 components: 8 bits (u8)
- 256+ components: 16 bits (u16)

Implementations may use larger discriminants for alignment purposes.

[52] **Size and alignment**:

$$
\text{sizeof}(\tau_1 \/ \cdots \/ \tau_n) = \text{sizeof(discriminant)} + \max_i(\text{sizeof}(\tau_i)) + \text{padding}
$$

$$
\text{alignof}(\tau_1 \/ \cdots \/ \tau_n) = \max(\text{alignof(discriminant)}, \max_i(\text{alignof}(\tau_i)))
$$

Padding is inserted to satisfy alignment requirements.

##### §7.3.6.4.2 Construction and Widening

[53] Union values are constructed by automatic widening:

**Typing rule:**

$$
\dfrac{\Gamma \vdash e : \tau_i \quad \tau_i <: \tau_1 \/ \cdots \/ \tau_n}{\Gamma \vdash e : \tau_1 \/ \cdots \/ \tau_n}
\tag{T-Union-Widen}
$$

The discriminant is set to indicate component `τᵢ`, and the payload stores the value.

[54] **No explicit constructor**: Union construction is automatic through subtyping. Expressions of component type automatically widen to union type when expected by context.

##### §7.3.6.4.3 Pattern Matching Semantics

[55] Pattern matching inspects the discriminant and extracts the payload:

**Match evaluation:**

[ Given: Union value $v : \tau_1 \/ \cdots \/ \tau_n$ with active component $\tau_k$ ]

$$
\dfrac{v \text{ has discriminant } k \quad p_j \text{ matches } \tau_k}{\text{match } v \{ \ldots, p_j \Rightarrow e_j, \ldots \} \text{ selects branch } j}
\tag{E-Union-Match}
$$

The pattern matching extracts the payload as type `τₖ` and evaluates the corresponding arm.

##### §7.3.6.4.4 Copy Behavior

[56] A union type satisfies `Copy` if and only if all component types satisfy `Copy`:

$$
\dfrac{\forall i.\, \tau_i : \text{Copy}}{\tau_1 \/ \cdots \/ \tau_n : \text{Copy}}
\tag{Prop-Union-Copy}
$$

If any component is move-only, the entire union is move-only.

##### §7.3.6.4.5 Never Type Absorption

[57] Union with never type `!` simplifies to the other type:

$$
\tau \/ ! \equiv \tau
\tag{Union-Never-Absorb}
$$

Since `!` is uninhabited, a union containing `!` can never hold a `!` value, so the union is equivalent to the union of all other components.

##### §7.3.6.5 Examples (Informative) [type.composite.union.examples]

**Example 7.3.6.1 (Error handling with unions):**

```cursive
procedure parse(input: string@View): i32 \/ parse::Error
{
    if input.is_empty() {
        result parse::Error::invalid_data("empty")  // Widens to union
    }
    result input.to_i32()  // Widens to union
}

let result = parse("42")
match result {
    value: i32 => println("Parsed: {}", value),
    err: parse::Error => println("Error: {}", err.message()),
}
```

[1] Both return paths produce union type `i32 \/ parse::Error` through automatic widening. The match expression exhaustively handles both components.

**Example 7.3.6.4 (Optional values via union):**

```cursive
type Option<T> = T \/ None

record None { }  // Unit-like type for "no value"

procedure find(items: [i32], target: i32): i32 \/ None
{
    loop i in 0..items.len() {
        if items[i] == target {
            result items[i]  // Widens to i32 \/ None
        }
    }
    result None { }  // Widens to i32 \/ None
}
```

**Example 7.3.6.6 - invalid (Non-exhaustive match):**

```cursive
let result: i32 \/ Error = compute()

match result {
    value: i32 => println("Got {}", value)
    // error[E08-450]: non-exhaustive match, missing Error case
}
```

##### §7.3.6.6 Integration with Type Inference [type.composite.union.inference]

[58] Union types participate in bidirectional type inference:

**Context-driven inference:**

```cursive
procedure example(): i32 \/ Error {
    if condition {
        result 42               // Infers i32, widens to i32 \/ Error
    } else {
        result Error::failed()  // Infers Error, widens to i32 \/ Error
    }
}
```

**Inference with multiple branches:**

```cursive
let value = if condition {
    42
} else {
    Error::failed()
}
// Infers type: i32 \/ Error (union of branch types)
```

[59] When branches produce different types, the type checker automatically forms a union of those types. If a return type annotation is provided, branches must be subtypes of that annotation.

##### §7.3.6.7 Diagnostic Requirements [type.composite.union.diagnostics]

[60] Union-related diagnostics:

| Code    | Condition                                         | Section |
| ------- | ------------------------------------------------- | ------- |
| E08-450 | Non-exhaustive match on union type                | §8.5    |
| E07-710 | Union component type not well-formed              | §7.3.6  |
| E07-711 | Type mismatch: cannot widen to union              | §7.3.6  |
| E07-712 | Single-component union (should use type directly) | §7.3.6  |

[61] Implementations shall provide clear diagnostics showing which union components are missing from match expressions and suggest adding the missing patterns.

---

#### §7.3.7 Conformance Requirements [type.composite.requirements]

[43] A conforming implementation shall:

- Support tuples, records, arrays, slices, strings, ranges, enums, and safe unions as specified.
- Enforce dual record access while respecting visibility modifiers.
- Uphold the `string@Managed`/`string@View` split, including defaulting rules and implicit coercion.
- Guarantee bounds checking semantics for arrays and slices, with diagnostics that match Clause 7 listings and Annex E §E.5 payload requirements.
- Provide exhaustive pattern diagnostics for enums and unions.
- Preserve the stated size/alignment rules and Copy behaviors.
- **Union types**: Implement automatic widening (Coerce-Union-Widen), normalization (flattening, duplicate removal), exhaustiveness checking (WF-Union-Exhaustive), and runtime tagging with minimal discriminant size.
- **Union type equivalence**: Normalize unions before comparison (associativity, commutativity, idempotence).

[44] Deviations from layout, semantics, or diagnostic obligations render the implementation non-conforming unless explicitly categorized as implementation-defined elsewhere.


### §6.4 Function Types [type.function]

[1] Function types (also called callable types) describe procedure declarations. They record parameter types, return type, required grants, and contractual sequents. Callable types carry this information wherever they appear (variable bindings, record fields, generic arguments), ensuring that higher-order programming preserves grant and contract obligations.

[2] Cursive uses a single arrow `->` for all callable types. Purity is indicated by an empty grant set and the trivial contractual sequent `[[ ∅ |- true => true ]]` (canonical: `[[ |- true => true ]]`). When sequents are omitted, they default to this form. Grant-requiring callables list their grants explicitly. Procedures with receivers desugar to ordinary callable types whose first parameter is the receiver pointer annotated with the appropriate permission (§7.4.3.4).

[2.1] **Transition types**: Modal type transitions use a special form of function type syntax `@Source -> @Target` that is syntactic sugar for `(Self@Source, ...params) -> Self@Target`, where `Self` is the modal type and `@State` desugars to `Self@State` in modal scope. Transition types are first-class function types and can be bound and passed as parameters. See §7.6.4 for details.

#### §7.4.1 Syntax [type.function.syntax]

[3] Callable type syntax follows (authoritative grammar: Annex A §A.3):

```
FunctionType   ::= '(' ParamTypes? ')' '->' Type GrantClause? SequentClause?
ParamTypes     ::= Type (',' Type)*
GrantClause    ::= '!' GrantSet
SequentClause  ::= '[[' SequentBody ']]'
SequentBody    ::= '|-' MustClause '=>' WillClause
MustClause     ::= PredicateExpr (',' PredicateExpr)* | 'true'
WillClause     ::= PredicateExpr (',' PredicateExpr)* | 'true'
```

[ Note: The token `|-` is the ASCII representation of the mathematical turnstile symbol `⊢` (U+22A2). Lexers shall recognize `|-` as a single two-character token used exclusively in contractual sequents. This ensures the sequent syntax `[[ grants |- must => will ]]` is parsed consistently.
— end note ]

[4] An omitted `GrantClause` denotes the empty grant set. An omitted `SequentClause` is equivalent to `[[ ∅ |- true => true ]]` (empty grant set, canonical: `[[ |- true => true ]]`). Parameters may be absent (`()`), yielding a nullary callable. Tuples are used to encode variadic parameters after desugaring (§9.3).

#### §7.4.2 Formation Rules [type.function.formation]

[5] Callable types are well-formed when each parameter and the result type are well-formed, the grant set is valid (§12.2), and the contractual sequent predicates are type-correct:

$$
\dfrac{\Gamma \vdash \tau_1 : \text{Type} \; \cdots \; \Gamma \vdash \tau_n : \text{Type} \quad \Gamma \vdash \tau_{\text{ret}} : \text{Type} \quad \varepsilon \text{ valid}}{\Gamma \vdash (\tau_1, \ldots, \tau_n) \to \tau_{\text{ret}} ! \varepsilon : \text{Type}}
\tag{WF-Function}
$$

[6] Contractual sequents must be well-formed under the same environment:

$$
\dfrac{\Gamma \vdash \text{Must predicates valid} \quad \Gamma \vdash \text{Will predicates valid}}{\Gamma \vdash \texttt{[[} \; \texttt{|-} \; \text{Must} \; \texttt{=>} \; \text{Will} \; \texttt{]]} \text{ ok}}
\tag{WF-Sequent}
$$

[7] Callable literals (closures) and declarations are checked against these types. Generic callable types follow §10.2; grant parameters (if any) are handled via contractual sequent quantification (§12.4).

#### §7.4.3 Semantics [type.function.semantics]

##### §7.4.3.1 Evaluation Model [type.function.semantics.eval]

[8] A callable value comprises:

- A code pointer referencing the implementation.
- An environment record capturing free variables (possibly empty).
- Metadata describing parameter count, grant set, and contractual sequent.

The environment record layout follows §8.6; it is a nominal record whose fields correspond to captured bindings. The callable type does not expose the environment type directly; instead, closure conversion generates a concrete record type `_Closure_X` with fields and an `apply` method matching the declared FunctionType.

##### §7.4.3.2 Grants [type.function.semantics.grants]

[9] The grant set `ε` enumerates capabilities the callable may exercise. Invocation requires the caller’s context to supply each grant in `ε`. Grant sets compose transitively: if a higher-order procedure receives `(T) -> U ! ε`, then its own grant set must include `ε` unless the procedure guarantees it never invokes the argument.

##### §7.4.3.3 Contracts [type.function.semantics.contract]

[10] The contractual sequent `[[ must => will ]]` (or `[[ grants |- must => will ]]` when grants are present) is interpreted as follows:

- `must` predicates describe caller obligations. At a call site, the type checker verifies these predicates under the caller's context.
- `will` predicates describe callee guarantees. After a call, these predicates may be assumed by the caller.

Logical implication in subtyping (§7.4.3.5) relies on Clause 12's contract entailment rules.

##### §7.4.3.4 Receivers [type.function.semantics.receiver]

[11] Procedure declarations use receiver shorthands `~`, `~%`, and `~!` (§5.4). They desugar to an explicit first parameter `self` with a lexical permission annotation on `Self`:

| Shorthand | Desugared parameter |
| --------- | ------------------- |
| `~`       | `self: const Self`  |
| `~%`      | `self: shared Self` |
| `~!`      | `self: unique Self` |

When a procedure is treated as a first-class callable, that desugared `self` parameter appears as the leading entry in its FunctionType. Section §7.5 explains how these lexical permissions interact with pointer and modal types when the receiver is lowered.

##### §7.4.3.5 Variance and Subtyping [type.function.semantics.variance]

[12] Callable types support the following subtyping rule:

$$
\dfrac{\forall i.\; \upsilon_i <: \tau_i \quad \tau_{\text{ret}} <: \upsilon_{\text{ret}} \quad \varepsilon \subseteq \varepsilon' \quad \text{Must}' \Rightarrow \text{Must} \quad \text{Will} \Rightarrow \text{Will}'}{(\tau_1, \ldots, \tau_n) \to \tau_{\text{ret}} ! \varepsilon \; \texttt{[[} \; \texttt{|-} \; \text{Must} \; \texttt{=>} \; \text{Will} \; \texttt{]]} <: (\upsilon_1, \ldots, \upsilon_n) \to \upsilon_{\text{ret}} ! \varepsilon' \; \texttt{[[} \; \texttt{|-} \; \text{Must}' \; \texttt{=>} \; \text{Will}' \; \texttt{]]}}
\tag{Sub-Function}
$$

- Parameter positions are contravariant (requirements on inputs cannot increase).
- Return type is covariant.
- Grant sets are contravariant (a subtype may require fewer grants).
- `must` clauses are contravariant; `will` clauses are covariant.

##### §7.4.3.6 Copy Predicate [type.function.semantics.copy]

[13] Theorem 7.4.1 (_Callable Copy Predicate_): A callable value is `Copy` iff its closure environment is empty and the underlying implementation marks the code pointer representation as duplicable (e.g., plain procedure items). Capturing closures are `Move`-only.

**Proof sketch**: copying a closure duplicates captured resources. Unless the environment is empty or each captured value satisfies `Copy` and the runtime knows how to duplicate the environment structure safely, copying cannot be guaranteed. The specification leaves implementation-defined hooks for marking specific closures `Copy` but forbids assuming copyability by default.

##### §7.4.3.7 Conversion to Pointers [type.function.semantics.pointer]

[14] Callable values may be converted to pointer types (`Ptr<FnSig>@State`) described in §7.5, enabling FFI interop. Such conversion is permitted only when the callable has an empty environment. Otherwise, the conversion is ill-formed (diagnostic E07-206).

#### §7.4.4 Diagnostics [type.function.diagnostics]

[15] Implementations shall emit at least the diagnostics in Table 7.4.1 when callable types are misused.

**Table 7.4.1 — Callable type diagnostics**

| Code    | Condition                                        |
| ------- | ------------------------------------------------ |
| E07-200 | Grant set contains undeclared grant              |
| E07-201 | Sequent references undefined predicate           |
| E07-202 | Call site lacks required grants                  |
| E07-203 | Call site cannot prove `must` clause             |
| E07-204 | Stored callable loses required grant information |
| E07-205 | Subtyping check violates variance rules          |
| E07-206 | Conversion of capturing closure to raw pointer   |

Diagnostics reference Annex E §E.5 for payload structure (e.g., missing grant names, behavior locations).

#### §7.4.5 Interaction with Declarations [type.function.declarations]

[16] Function and procedure declarations synthesize callable types:

```cursive
procedure add(lhs: i32, rhs: i32): i32
{ ... }
// Type: (i32, i32) -> i32 ! ∅ [[ ∅ |- true => true ]] (canonical: `[[ |- true => true ]]`)

procedure write_line(~%, text: string@View): ()
    [[ io::write |- text.len() < 4096 => true ]]
{
    io::write_all(text)
}
// Type: (Ptr<Self>@Shared, string@View) -> () ! { io::write }
//       [[ text.len() < 4096 => true ]] (canonical: `[[ |- text.len() < 4096 => true ]]`)
```

[17] Closure literals adopt their inferred FunctionType. Example:

```cursive
let scale: (f64) -> f64 = |value| { result value * 2.0 }
```

Closures capturing variables produce a synthesized record `_Closure_Scale` with fields for each capture and an apply function `_Closure_Scale::call(self@Const, value: f64)` matching the FunctionType.

[18] When callable values cross module boundaries, their FunctionType (including grants and sequents) must appear in the exported signature. Re-exporting a callable with a wider grant set or weaker `will` clause is ill-formed (E07-204).

#### §7.4.6 Examples (Informative) [type.function.examples]

**Example 7.4.6.1 (Higher-order procedure):**

```cursive
procedure map<T, U>(values: [T], f: (T) -> U ! ε): [U]
    [[ ε |- values.len() > 0 => result.len() == values.len() ]]
{
    let result = array::with_len(values.len())
    loop i in 0..values.len() {
        result[i] = f(values[i])
    }
    result
}
```

**Example 7.4.6.2 (Closure with capture):**

```cursive
procedure make_logger(stream: io::Writer@Unique): (string@View) -> () ! { io::write }
    [[ alloc::heap |- true => true ]]
{
    result (| message: string@View |)
        [[ io::write |- message.len() <= 1024 => true ]]
    {
        stream.write(message)
    }
}
```

**Example 7.4.6.3 (Subtyping):**

```cursive
let pure_add: (i32, i32) -> i32 = add
let noisy_add: (i32, i32) -> i32 ! { io::write } = annotate(add)
// pure_add <: noisy_add because it requires no grants and has identical contract
```

#### §7.4.7 Conformance Requirements [type.function.requirements]

[19] Implementations shall:

1. Recognize FunctionType syntax with inline grant and sequent clauses.
2. Enforce formation, variance, and subtyping rules, including grant containment and sequent entailment checks.
3. Preserve callable metadata through type inference, closure conversion, and ABI lowering.
4. Diagnose violations using the codes in Table 7.4.1.
5. Ensure receiver shorthand desugars to the pointer forms in §7.4.3.4 and obey the pointer semantics in §7.5.
6. Forbid conversion of capturing closures to raw pointers unless the environment is empty.
7. Expose callable information via introspection (§7.7) exactly as represented in the FunctionType.

[20] Deviations from these obligations render an implementation non-conforming unless explicitly categorized as implementation-defined elsewhere in the specification.


### §6.5 Pointer and Reference Types [type.pointer]

[1] Cursive provides two pointer families:

- **Safe modal pointers** `Ptr<T>@State`, which are first-class values with compile-time state tracking, provenance, and aliasing guarantees.
- **Raw pointers** `*const T` and `*mut T`, which bypass safety guarantees for FFI and low-level code.

Reference bindings (`let name <- value`) and procedure receivers desugar to safe pointers described in this clause. General modal types are specified in §7.6; `Ptr<T>` is a built-in modal definition.

#### §7.5.1 Syntax [type.pointer.syntax]

[2] Pointer types follow Annex A §A.3:

```
PointerType    ::= SafePtrType | RawPtrType
SafePtrType    ::= 'Ptr' '<' Type '>' ('@' Ident)?
RawPtrType     ::= '*const' Type | '*mut' Type
```

[3] `Ptr<T>` without a state annotation refers to the unconstrained pointer type. Annotated forms `Ptr<T>@State` restrict the pointer to a particular modal state (paragraph [9]). Safe pointer types support optional provenance attributes (informative tooling metadata) but provenance is primarily tracked via the typing rules in §7.5.3.

#### §7.5.2 Safe Modal Pointers [type.pointer.safe]

##### §7.5.2.1 Modal States [type.pointer.safe.states]

[4] The modal declaration for pointers is defined by the language core:

```cursive
modal Ptr<T> { … }
```

[5] The modal declaration follows the general rules in §7.6.1. The built-in pointer states are:

| State      | Meaning                             |
| ---------- | ----------------------------------- |
| `@Null`    | explicit null pointer               |
| `@Valid`   | dereferenceable pointer             |
| `@Weak`    | weak reference (non-owning)         |
| `@Expired` | weak reference whose target is gone |

[6] State ordering: `Ptr<T>@Null`, `Ptr<T>@Valid`, `Ptr<T>@Weak`, `Ptr<T>@Expired` ⊑ `Ptr<T>`. Widening to `Ptr<T>` is implicit; narrowing requires state refinement (pattern matching or transition results). For modal syntax, witness semantics, and transition guarantees, see §7.6.

##### §7.5.2.2 Formation [type.pointer.safe.formation]

[6] Safe pointers are well-formed when their pointee type is well-formed and the state is one of the built-in identifiers:

$$
\dfrac{\Gamma \vdash \tau : \text{Type} \quad S \in \{\text{@Null}, \text{@Valid}, \text{@Weak}, \text{@Expired}\}}{\Gamma \vdash \text{Ptr}\langle\tau\rangle@S : \text{Type}}
\tag{WF-Ptr-State}
$$

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash \text{Ptr}\langle\tau\rangle : \text{Type}}
\tag{WF-Ptr}
$$

##### §7.5.2.3 Pointer Creation [type.pointer.safe.creation]

[7] Address-of operator:

$$
\dfrac{\Gamma \vdash e : \tau \quad \text{storage}(e)=\text{location}}{\Gamma \vdash \&e : \text{Ptr}\langle\tau\rangle@\text{Valid}}
\tag{T-Addr}
$$

The operand must denote a storage location (lvalue). Taking the address of aliases, temporaries, or computed expressions is ill-formed (diagnostic E07-302). Pointer declarations must include explicit types; pointer types are not inferred (E07-303).

[8] `Ptr::null<T>()` yields `Ptr<T>@Null`. Other constructors (`to_heap`, region allocation) are defined in Clause 12 but always return pointers with known state and provenance.

##### §7.5.2.4 Dereference and Access [type.pointer.safe.deref]

[9] Dereference is permitted only in `@Valid` state:

$$
\dfrac{\Gamma \vdash p : \text{Ptr}\langle\tau\rangle@\text{Valid}}{\Gamma \vdash *p : \tau}
\tag{T-Deref}
$$

The dynamic semantics evaluate the pointer to an address and read from the pointed location:

```
[E-Deref]
⟨p, σ⟩ ⇓ ⟨Ptr⟨τ⟩@Valid { addr: ℓ }, σ'⟩
σ'(ℓ) = v
--------------------------------
⟨*p, σ⟩ ⇓ ⟨v, σ'⟩
```

[10] Compilation rejects dereferences in other states:

- `Ptr<T>@Null`: E07-301 — “cannot dereference null pointer”.
- `Ptr<T>@Weak`: E07-304 — must upgrade to `@Valid` first.
- `Ptr<T>@Expired`: E07-305 — pointer refers to destroyed object.

##### §7.5.2.5 Weak References and Upgrades [type.pointer.safe.weak]

[11] State transitions are provided via pointer methods:

```
Procedure   Signature                               Effect
-----------------------------------------------------------------------
Ptr::downgrade  (self: const Ptr<T>@Valid) -> Ptr<T>@Weak
Ptr::upgrade    (self: const Ptr<T>@Weak)  -> Ptr<T>        // returns Ptr<T>@Valid or Ptr<T>@Null at runtime
Ptr::is_null    (self: const Ptr<T>@Valid) -> bool          // always false
Ptr::is_expired (self: const Ptr<T>@Weak)  -> bool
```

Typing rules:

$$
\dfrac{\Gamma \vdash p : \text{Ptr}\langle\tau\rangle@\text{Valid}}{\Gamma \vdash p.\text{downgrade}() : \text{Ptr}\langle\tau\rangle@\text{Weak}}
\tag{T-Downgrade}
$$

$$
\dfrac{\Gamma \vdash p : \text{Ptr}\langle\tau\rangle@\text{Weak}}{\Gamma \vdash p.\text{upgrade}() : \text{Ptr}\langle\tau\rangle}
\tag{T-Upgrade}
$$

The result of `upgrade` must be pattern matched to recover `@Valid` or `@Null` states.

##### §7.5.2.6 Pattern Matching and Refinement [type.pointer.safe.pattern]

[12] Pattern matching on pointer states refines the pointer type within each branch. Example:

```cursive
match ptr {
    @Null => println("optional value missing"),
    @Valid => println("value: {}", *ptr),
    @Weak => match ptr.upgrade() {
        @Valid => println("weak upgraded: {}", *ptr),
        @Null => println("target destroyed"),
    },
    @Expired => println("stale weak reference"),
}
```

Typing rule:

$$
\dfrac{\Gamma \vdash e : \text{Ptr}\langle\tau\rangle}{\Gamma \vdash \text{match } e \text{ with states}} \quad \text{patterns cover all states}
\tag{T-Match-Ptr}
$$

##### §7.5.2.7 State Transitions [type.pointer.safe.transitions]

[13] Safe pointers follow the deterministic transition table in Table 7.5.1. No other state transitions are permitted.

**Table 7.5.1 — `Ptr<T>` transition catalogue**

| Operation                     | Source state              | Target state | Conditions / notes                                                                            |
| ----------------------------- | ------------------------- | ------------ | --------------------------------------------------------------------------------------------- |
| `&e` (address-of)             | storage-backed expression | `@Valid`     | `e` denotes a live storage location; provenance recorded per §7.5.3                           |
| `Ptr::null<T>()`              | —                         | `@Null`      | Produces an explicit null pointer                                                             |
| `Ptr::downgrade()`            | `@Valid`                  | `@Weak`      | Pointer retains provenance and no longer proves liveness                                      |
| `Ptr::upgrade()` success path | `@Weak`                   | `@Valid`     | Only when the referent is still live; caller SHALL pattern match the result                   |
| `Ptr::upgrade()` failure path | `@Weak`                   | `@Null`      | Indicates the referent has been destroyed; dereference must not follow                        |
| Owning scope/region drop      | `@Weak`                   | `@Expired`   | Occurs automatically when the final owning `@Valid` pointer drops; dereference raises E07-305 |

[14] Implementations shall diagnose any attempt to forge a transition not listed above. In particular, there is no transition that converts `@Expired` back to `@Valid`; a stale pointer can only become usable again by obtaining a fresh pointer via the safe constructors above.

#### §7.5.3 Provenance and Escape Analysis [type.pointer.safe.provenance]

##### §7.5.3.1 Provenance Model

[13] Provenance metadata tracks allocation source:

| Provenance  | Description                                     |
| ----------- | ----------------------------------------------- |
| `Stack`     | Stack frame local                               |
| `Region(r)` | Region `r` allocated via `region` block         |
| `Heap`      | Explicit heap allocation (`to_heap`, allocator) |

Rules:

$$
\text{prov}(\&e) = \text{storage\_class}(e)
\tag{Prov-Addr}
$$

$$
\text{prov}(p') = \text{prov}(p) \quad \text{(copy/move)}
\tag{Prov-Copy}
$$

##### §7.5.3.2 Escape Restrictions

[14] Escape analysis forbids pointer escape when provenance would become invalid:

- **Stack escape**: returning or storing a stack pointer beyond procedure scope → E07-300.
- **Region escape**: pointer leaves region lifetime without explicit heap escape → E07-300.
- **Heap**: unrestricted (subject to ownership checks in Clause 12).

Pseudo algorithm:

```
CHECK_ESCAPE(ptr, target_scope):
    match prov(ptr):
        Stack  -> deny if target_scope ≠ current_procedure
        Region(r) -> deny if target_scope escapes r
        Heap   -> allow
```

Diagnostics include allocation site, escape site, and suggested remedies (e.g., `.to_heap()` or returning by move).

#### §7.5.4 Copy Predicate and Layout [type.pointer.safe.copy]

[15] Theorem 7.5.1 (_Pointer Copy_): `Ptr<T>@S` is `Copy` for all states `S`. Proof sketch: pointer values are machine addresses independent of pointee semantics.

[16] Size and alignment equal machine word size and alignment:

$$
\text{size}(\text{Ptr}\langle\tau\rangle@S) = \text{size}(usize) \quad \text{align}(\text{Ptr}\langle\tau\rangle@S) = \text{align}(usize)
\tag{Ptr-Size}
$$

#### §7.5.5 Raw Pointers [type.pointer.raw]

##### §7.5.5.1 Formation and Copy

[17] Raw pointers are well-formed when the pointee type is well-formed:

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash *\text{const}\; \tau : \text{Type}} \qquad \dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash *\text{mut}\; \tau : \text{Type}}
\tag{WF-Raw}
$$

They are always `Copy`, with the same size/alignment as safe pointers.

##### §7.5.5.2 Operations

[18] Dereferencing and writing require the grant `unsafe.ptr`:

$$
\dfrac{\Gamma \vdash p : *\text{const}\; \tau}{\Gamma \vdash *p : \tau \; ! \{\text{unsafe.ptr}\}}
\tag{T-Raw-Deref}
$$

$$
\dfrac{\Gamma \vdash p : *\text{mut}\; \tau \quad \Gamma \vdash v : \tau}{\Gamma \vdash (*p = v) : () \; ! \{\text{unsafe.ptr}\}}
\tag{T-Raw-Write}
$$

Pointer arithmetic and casts also require `unsafe.ptr` and are otherwise unchecked. Undefined behaviour occurs if alignment, lifetime, or aliasing rules are violated; the spec imposes no compile-time enforcement beyond the `unsafe` requirement.

##### §7.5.5.3 Interoperation

[19] Coercions:

- `Ptr<T>@Valid` → `*const T`/`*mut T` (explicit cast).
- `*const T`/`*mut T` → `Ptr<T>` forbidden without proving state (requires user-provided witness or safe wrapper).
- Capturing closures may not be cast to raw procedure pointers (E07-206).

#### §7.5.6 Diagnostics [type.pointer.diagnostics]

[20] Mandatory diagnostics:

| Code    | Condition                                        |
| ------- | ------------------------------------------------ |
| E07-300 | Pointer escape violating provenance rules        |
| E07-301 | Dereference of `Ptr<T>@Null`                     |
| E07-302 | Address-of expression without storage            |
| E07-303 | Missing explicit pointer type annotation         |
| E07-304 | Dereference of `Ptr<T>@Weak`                     |
| E07-305 | Dereference of `Ptr<T>@Expired`                  |
| E07-400 | Raw pointer dereference outside `unsafe` context |
| E07-401 | Raw pointer assignment outside `unsafe` context  |
| E07-402 | Cast between incompatible raw pointer types      |

Diagnostics follow Annex E §E.5 for payload structure (allocation sites, provenance, and suggested fixes).

Diagnostics shall include allocation site, pointer provenance, and hints consistent with Annex E §E.5.

#### §7.5.7 Examples (Informative) [type.pointer.examples]

**Example 7.5.7.1 (Safe pointer workflow):**

```cursive
record Node {
    parent: Ptr<Node>@Weak,
    children: [Ptr<Node>@Valid],
}

procedure attach_child(parent: Ptr<Node>@Valid, child: Ptr<Node>@Valid) {
    (*child).parent = parent.downgrade()
    (*parent).children.push(child)
}

procedure print_parent(child: Ptr<Node>) {
    match child {
        @Valid => match (*child).parent.upgrade() {
            @Valid => println("parent children: {}", (*parent).children.len()),
            @Null  => println("no parent"),
        },
        _ => println("invalid node pointer"),
    }
}
```

**Example 7.5.7.2 (Escape violation):**

```cursive
procedure dangling(): Ptr<i32> {
    region r {
        let value = ^42
        result &value    // error[E07-300]
    }
}
```

**Example 7.5.7.3 (Raw pointer usage):**

```cursive
procedure bump(ptr: *mut i32)
    [[ unsafe.ptr |- true => true ]]
{
    unsafe {
        *ptr = *ptr + 1
    }
}
```

#### §7.5.8 Conformance Requirements [type.pointer.requirements]

[21] A conforming implementation shall:

1. Support the pointer syntax in §7.5.1 and states in §7.5.2.1.
2. Enforce address-of, dereference, downgrade/upgrade, and pattern-matching rules, rejecting invalid state operations with diagnostics E07-301, E07-304, E07-305.
3. Track provenance (Stack, Region, Heap) and reject illegal pointer escapes, reporting E07-300 with contextual notes.
4. Require explicit pointer type annotations (E07-303) and prohibit address-of on non-storage expressions (E07-302).
5. Treat all safe and raw pointers as `Copy` with machine word size and alignment.
6. Require `unsafe.ptr` grants for raw pointer dereference, writes, arithmetic, and casts, issuing E07-400–E07-402 when missing.
7. Maintain pointer metadata through type inference and ABI lowering so introspection (§7.7) reflects accurate state and provenance information.

[22] Deviations render an implementation non-conforming unless another clause explicitly designates the behaviour as implementation-defined.


### §6.6 Modal Types [type.modal]

[1] Modal types define compile-time state machines. Each modal value inhabits exactly one named state at a time; state transitions are enforced by the type system, ensuring that operations occur in valid orders without runtime overhead. Modal types integrate with the contract system (Clause 12) and the witness system (Clause 13) to express and verify obligations.

[1.1] **Built-in modal types**: Cursive provides two built-in modal types:

- `Ptr<T>` (§7.5): Pointer states (@Null, @Valid, @Weak, @Expired)
- `Arena` (§11.3.2): Memory arena states (@Active, @Frozen, @Freed)

User-defined modal types follow the same syntax and semantics as these built-in types.

(1.2) **Transition Signatures vs. Implementations**: Modal types use two distinct syntactic forms with semantically meaningful operators:

- **Transition signatures** (`@Source::name(params) -> @Target`): Declare valid state transitions within the modal body. These lightweight declarations define the state machine graph and use the **mapping operator `->` (reads as "transitions to" or "maps to")** to indicate the state-to-state relationship.

- **Procedure implementations**: Provide the actual transition logic using standard procedure syntax (§5.4) with the **type operator `:` (reads as "is of type")** for return type annotations. Each transition signature must have a corresponding procedure implementation named `ModalType.name` that takes a receiver in the source state and returns the target state.

[ Note: The semantic distinction between operators clarifies intent:

- **`->` (mapping operator)**: Declares a state transition relationship (`@Source` maps to `@Target`)
- **`:` (type operator)**: Declares a type annotation (`return value : Type`)

Transition signatures use `->` because they declare state graph edges (how states map to each other). Procedure implementations use `:` because they follow standard procedure syntax where return types are type annotations. The operators have distinct semantic meanings that reflect their different roles.
— end note ]

[2] Examples include file handles (Closed → Open → Closed), parser contexts, transactional resources, capability tokens, and memory arenas (Active → Frozen → Freed). The built-in modal types `Ptr<T>` (§7.5) and `Arena` (§11.3.2) demonstrate this mechanism.

#### §7.6.1 Syntax [type.modal.syntax]

[3] The grammar in Annex A §A.3 defines modal declarations:

```
ModalDecl        ::= 'modal' Ident GenericParams? '{' StateBlock+ '}'
StateBlock       ::= '@' Ident StateFields? StateBody?
StateFields      ::= '{' FieldDecl* '}'
StateBody        ::= '{' StateMember* '}'
StateMember      ::= ProcedureDecl | FunctionDecl | TransitionSignature
TransitionSignature ::= '@' Ident '::' Ident '(' ParamList? ')' '->' '@' Ident
```

[4] **Transition Declarations and Implementations**: Modal types distinguish between transition _signatures_ and transition _implementations_:

- **Transition signatures** (inside modal body): Use the form `@SourceState::name(params) -> @TargetState` to declare valid state transitions. The **mapping operator `->` (reads as "transitions to")** indicates that invoking this transition maps the value from the source state to the target state. These lightweight declarations define the state machine graph.

- **Procedure implementations**: Each transition signature shall have a corresponding procedure implementation using standard procedure syntax (§5.4). The procedure is named `ModalType.name`, takes receiver using shorthand (`~`, `~%`, or `~!` corresponding to `const`, `shared`, or `unique` permission on `Self@Source`), and returns a transition type `@Source -> @Target` using the **type operator `:` (reads as "is of type")**. The transition type `@Source -> @Target` is syntactic sugar for the function type `(Self@Source, ...params) -> Self@Target`, where `Self` is the modal type and `@State` desugars to `Self@State` in modal scope. Implementations may appear at module scope or within the state body as full procedure declarations.

[ Note: Transition types are first-class function types. The syntax `@Source -> @Target` in a procedure return type is syntactic sugar for `(Self@Source, ...params) -> Self@Target`, where `Self` is the modal type. This allows transitions to be bound, passed as parameters, and used in higher-order operations. The `->` operator in transition types expresses the state transition relationship as part of the type system, making transitions first-class values while preserving their semantic meaning.
— end note ]

[5] Each state may:

- Declare fields (state-specific payload).
- Provide methods (procedures) available while in that state.
- Define transition signatures using `@Source::name(params) -> @Target` syntax.

#### §7.6.2 Formation Rules [type.modal.formation]

[6] A modal declaration `modal M { @S₁ … @Sₙ }` is well-formed when:

1. State names `Sᵢ` are unique.
2. Field types within each state are well-formed under the enclosing context.
3. Transition clauses reference existing states.
4. Methods use receivers consistent with pointer semantics: receiver shorthand (`~`, `~%`, `~!`) corresponding to permissions `{const, shared, unique}` on `Self@State`.

(6.1) _Missing transition implementation._ If a transition signature `@Source::name(params) -> @Target` is declared but no corresponding procedure `ModalType.name` with matching signature exists, diagnostic E07-505 is emitted. The implementation must match the signature exactly: receiver permission, parameter types, and target state must align. Implementations with mismatched signatures do not satisfy the signature requirement.

(6.2) _Orphan transition implementations._ If a procedure `ModalType.name` exists but no corresponding transition signature is declared, the procedure is treated as a regular associated procedure (not a transition). Such procedures may still be called but do not participate in state tracking. No diagnostic is emitted for orphan implementations; they are valid for non-transition operations.

(6.3) _State field access outside state._ When a state-specific field is accessed through a modal value that is not in the field's defining state, diagnostic E07-504 is emitted. This check occurs during type checking; the compiler tracks the current state of each modal value through pattern matching and transition calls. Accessing fields from a different state is always ill-formed, even if the access would be safe at runtime.

Formally:

$$
\dfrac{\text{modal } M \{ @S_1, \ldots, @S_n \} \text{declared} \quad S_i \ne S_j \quad \Gamma \vdash \text{fields/members}}{\Gamma \vdash M : \text{Type}}
\tag{WF-Modal-Type}
$$

#### §7.6.2.5 Parser Disambiguation [type.modal.disambiguation]

[7] The `->` and `:` operators are grammatically unambiguous in modal contexts:

**Context 1: Transition signatures (within modal body)**

- Form: `@StateIdentifier::name(params) -> @StateIdentifier`
- Operator: `->` (mapping operator)
- Context markers: Appears after parameter list within modal state block
- Parser rule: When `@Ident::Ident(...)` is followed by `->`, parse as transition signature

**Context 2: Procedure implementations (module or state scope)**

- Form: `procedure ModalType.name(params): ReturnType`
- Operator: `:` (type operator)
- Context markers: Appears after parameter list in procedure declaration
- Parser rule: When `procedure` keyword precedes, `:` introduces return type

**Disambiguation table:**

| Syntactic Context                       | Operator | Parsed As              |
| --------------------------------------- | -------- | ---------------------- |
| Inside modal body after `@Ident::(...)` | `->`     | Transition signature   |
| After `procedure` keyword and params    | `:`      | Return type annotation |

[8] **Transition type parsing**: When parsing a return type after `:` in a procedure declaration, if the type contains `->` between state identifiers (`@Ident -> @Ident`), it is parsed as a transition type. Transition types may only appear in return type positions of procedures declared within modal scope (i.e., procedures that are methods of a modal type). The parser recognizes transition types by the pattern `@` followed by an identifier, `->`, `@`, and another identifier.

#### §7.6.3 State Types [type.modal.state]

[9] Each state induces a nominal subtype `M@State`. Values of type `M` have unknown state. Pattern matching refines the state:

```cursive
match conn {
    @Closed { path } => { ... }   // conn : Connection@Closed
    @Open { handle } => { ... }   // conn : Connection@Open
}
```

Typing rule:

$$
\dfrac{\Gamma \vdash e : M \quad \text{states cover all }@S_i}{\Gamma \vdash \text{match } e \text{ with }@S_i : \tau}
\tag{T-Match-Modal}
$$

Within each branch, the value is treated as `M@S_i` and state fields are accessible.

#### §7.6.4 Transitions [type.modal.transition]

[8] Transitions are defined through two components:

**Transition signature** (inside modal body):

```cursive
modal Connection {
    @Closed { path: string@Managed }
    @Closed::open(~!, path: string@View) -> @Open

    @Open { handle: Handle }
}
```

**Procedure implementation** (at module scope or inline):

```cursive
procedure Connection.open(~!, path: string@View): @Closed -> @Open
    [[ io::open |- true => witness Connection@Open ]]
{
    let handle = os::open(path)
    result Connection@Open { handle, path: path.to_owned() }
}
```

[9] The signature `@Source::name(params) -> @Target` declares the transition, including receiver shorthand (`~`, `~%`, `~!`) if the transition requires a self parameter. The implementation shall:

- Be named `ModalType.name`
- Take receiver using shorthand matching the signature: `~` (const), `~%` (shared), `~!` (unique)
- Return a transition type `@Source -> @Target` where Source and Target match the signature
- The transition type `@Source -> @Target` desugars to function type `(Self@Source, ...params) -> Self@Target`, where `@State` desugars to `Self@State` in modal scope

Typing rule:

$$
\dfrac{\Gamma \vdash self : M@S \quad \Gamma \vdash \text{body}: M@Target \quad \text{contract ok}}{\Gamma \vdash \text{procedure } M.name(self: perm M@S, ...): @S \to @Target}
\tag{T-Transition}
$$

The body must `result` a value of type `M@Target` (where `M@Target` is the desugared form of `@Target` in modal scope). The transition type `@S -> @Target` is equivalent to the function type `(M@S, ...params) -> M@Target`. Failing to return the correct type triggers E07-502. Witness semantics are described in §7.6.5.

[ Rationale: For transitions on `unique` receivers (`~!`), returning `result ModalType@NewState { ... }` performs an in-place update of the object's memory. The fields are overwritten, and the object's conceptual state changes without requiring a new allocation. This ensures that state transitions on unique values are efficient, zero-cost abstractions. Transitions on `const` or `shared` receivers must construct and return a new object in the target state, as they cannot modify the original in place. — end rationale ]

#### §7.6.5 Contracts and Witnesses [type.modal.contract]

[10] Modal transition procedures follow all standard procedure semantics (§5.4), including contractual sequent specifications `[[ grants … |- must => will ]]`. In addition, each transition signature imposes the following witness obligations:

1. **Entry witness** — the caller shall provide `witness M@Source` (or an equivalent fact provable from the current control-flow) before invoking the procedure.
2. **Exit witness** — the procedure shall prove or emit `witness M@Target` on every non-diverging exit path. Returning a value of type `M@Target` without supplying the witness is ill-formed and triggers E07-502.
3. **Exclusive result states** — a transition signature maps exactly one `@Source` to one `@Target`. A procedure that wishes to return multiple states shall declare separate signatures so that each branch has an explicit witness obligation.

(10.1) Implementations shall enforce that every transition signature has a matching procedure whose contractual sequent names the entry/exit witnesses. This requirement ensures that the witness system (Clause 13) can track linear state changes without heuristic inference.

**Example:**

```cursive
procedure close(~!): @Open -> @Closed
    [[ io::close, witness Connection@Open
       |- true => witness Connection@Closed ]]
{
    os::close(self.handle)
    result Connection@Closed { path: self.path }
}
```

#### §7.6.6 Modal Field Access [type.modal.fields]

[11] State fields are accessible only when the value is known to be in that state. Attempting to read `value.field` when the current type is `M` (unknown state) is ill-formed (E07-504). Pattern matching or witness-based refinement is required.

#### §7.6.7 Subtyping [type.modal.subtyping]

[12] The subtyping relationship includes:

- `M@State <: M` (state-specific type is a subtype of the general modal type).
- Distinct states are incomparable (`M@S₁` and `M@S₂` only subtype each other if `S₁ = S₂`).

These rules integrate with the general subtyping relation in §7.7.

#### §7.6.8 Diagnostics [type.modal.diagnostics]

[13] Minimal diagnostics:

| Code    | Condition                                       |
| ------- | ----------------------------------------------- |
| E07-500 | Duplicate state name                            |
| E07-501 | Transition references undeclared state          |
| E07-502 | Transition body fails to return target state    |
| E07-503 | Exhaustiveness failure in modal pattern match   |
| E07-504 | State-specific field accessed outside its state |
| E07-505 | Missing transition implementation               |

#### §7.6.9 Examples (Informative) [type.modal.examples]

**Example 7.6.9.1 (File lifecycle):**

```cursive
modal FileHandle {
    @Closed { path: string@Managed }
    @Closed::open(~!, path: string@View) -> @Open

    @Open { path: string@Managed, handle: os::Handle }
    @Open::read(~%, buffer: [u8]) -> @Open
    @Open::close(~!) -> @Closed
}
```

**Transition implementations at module scope:**

```cursive
procedure FileHandle.open(~!, path: string@View): @Closed -> @Open
[[io::open |- true => witness FileHandle@Open]]
{
let handle = os::open(path)
result FileHandle@Open { path: path.to_owned(), handle }
}

procedure FileHandle.read(~%, buffer: [u8]): @Open -> @Open
[[io::read, witness FileHandle@Open |- buffer.len() > 0 => true]]
{
os::read(self.handle, buffer)
result self
}

procedure FileHandle.close(~!): @Open -> @Closed
[[io::close, witness FileHandle@Open |- true => witness FileHandle@Closed]]
{
os::close(self.handle)
result FileHandle@Closed { path: self.path }
}

procedure use_file(path: string@View)
grants io::open, io::read, io::close
{
let file = FileHandle::from_path(path)
match file {
@Closed => {
let open = file.open()
open.read(buffer)
let closed = open.close()
// closed : FileHandle@Closed
}
}
}
```

**Example 7.6.9.2 (Token-based capability):**

```cursive
modal Transaction {
    @Idle {}
    @Idle::begin(~!) -> @Active

    @Active {}
    @Active::commit(~!) -> @Idle
    @Active::rollback(~!) -> @Idle
}

// Transition implementations
procedure Transaction.begin(~!): @Idle -> @Active
    [[ db::begin |- true => witness Transaction@Active ]]
{
    db::begin()
    result Transaction@Active {}
}

procedure Transaction.commit(~!): @Active -> @Idle
    [[ db::commit, witness Transaction@Active |- true => witness Transaction@Idle ]]
{
    db::commit()
    result Transaction@Idle {}
}

procedure Transaction.rollback(~!): @Active -> @Idle
    [[ db::rollback, witness Transaction@Active |- true => witness Transaction@Idle ]]
{
    db::rollback()
    result Transaction@Idle {}
}
```

#### §7.6.10 Conformance Requirements [type.modal.requirements]

[14] Implementations shall:

1. Support modal syntax as described in §7.6.1 with unique state names.
2. Enforce that state-specific fields and methods are used only in their defining state.
3. Ensure transitions return values of the target state; emit diagnostic E07-502 otherwise.
4. Refine modal types in pattern matches and enforce exhaustiveness (E07-503).
5. Track witnesses per Clause 13, ensuring sequent clauses are respected.
6. Provide diagnostics in §7.6.8 with contextual information (location of state declaration and offending use).

[15] Deviations render an implementation non-conforming unless explicitly noted elsewhere.


### §6.7 Type Relations [type.relation]

[1] This subclause defines the core relations on types: type equivalence (`≡`), subtyping (`<:`), and compatibility. These relations govern implicit conversions, variance, and the conditions under which values may be substituted for one another.

[2] Type equivalence is an equivalence relation used to normalize types (e.g., expanding aliases). Subtyping is a preorder determining assignability. Compatibility captures auxiliary checks (e.g., state compatibility for modal types) used during type inference and diagnostics.

#### §7.7.1 Syntax [type.relation.syntax]

```
EquivalenceJudgment ::= TypeExpr "≡" TypeExpr
SubtypingJudgment   ::= TypeExpr "<:" TypeExpr
CompatibilityJudgment ::= TypeExpr "~" TypeExpr
```

A judgment is well-formed only if both operands are well-formed types in the current type environment Γ.

$$
\dfrac{\Gamma \vdash \tau : \text{Type} \quad \Gamma \vdash \upsilon : \text{Type}}{\Gamma \vdash (\tau \prec \upsilon) \text{ wf}}
\tag{WF-Relation}
$$

Where `τ ≺ υ` stands for any of the three relations.

#### §7.7.2 Type Equivalence [type.relation.equivalence]

[3] **Definition 7.7.1 (Equivalence).** Two types `τ₁` and `τ₂` are equivalent (`τ₁ ≡ τ₂`) when they denote the same type after expanding aliases, substituting generic arguments, normalizing associated types, and erasing syntactic sugar.

[4] Equivalence is reflexive, symmetric, and transitive:

$$
\dfrac{}{\tau \equiv \tau}
\tag{Equiv-Refl}
$$

$$
\dfrac{\tau_1 \equiv \tau_2}{\tau_2 \equiv \tau_1}
\tag{Equiv-Sym}
$$

$$
\dfrac{\tau_1 \equiv \tau_2 \quad \tau_2 \equiv \tau_3}{\tau_1 \equiv \tau_3}
\tag{Equiv-Trans}
$$

[5] Type aliases are transparent:

$$
\dfrac{\text{type } A = \tau}{A \equiv \tau}
\tag{Equiv-Alias}
$$

$$
\dfrac{\text{type } F\langle\alpha_1, \ldots, \alpha_n\rangle = \tau[\alpha]}{F\langle\upsilon_1, \ldots, \upsilon_n\rangle \equiv \tau[\alpha_i \mapsto \upsilon_i]}
\tag{Equiv-Generic-Alias}
$$

[6] Structural types compare element-wise:

$$
\dfrac{\forall i.\, \tau_i \equiv \upsilon_i}{(\tau_1, \ldots, \tau_n) \equiv (\upsilon_1, \ldots, \upsilon_n)}
\tag{Equiv-Tuple}
$$

$$
\dfrac{\tau \equiv \upsilon \quad n = m}{[\tau; n] \equiv [\upsilon; m]}
\tag{Equiv-Array}
$$

$$
\dfrac{\tau \equiv \upsilon}{[\tau] \equiv [\upsilon]}
\tag{Equiv-Slice}
$$

$$
\dfrac{\tau_1 \equiv \upsilon_1 \; \cdots \; \tau_n \equiv \upsilon_n \quad \tau_r \equiv \upsilon_r \quad \varepsilon = \varepsilon'}{(\tau_1, \ldots, \tau_n) \to \tau_r ! \varepsilon \; \texttt{[[} \; \texttt{|-} \; M \; \texttt{=>} \; W \; \texttt{]]} \equiv (\upsilon_1, \ldots, \upsilon_n) \to \upsilon_r ! \varepsilon' \; \texttt{[[} \; \texttt{|-} \; M \; \texttt{=>} \; W \; \texttt{]]}}
\tag{Equiv-Function}
$$

$$
\dfrac{\text{State sets identical}}{\text{Ptr}\langle\tau\rangle@S \equiv \text{Ptr}\langle\upsilon\rangle@S \quad \text{iff } \tau \equiv \upsilon}
\tag{Equiv-Ptr}
$$

$$
\dfrac{\text{Same state names and payloads}}{M@S \equiv M@S}
\tag{Equiv-Modal-State}
$$

[7] Nominal types (records, enums, modals, behaviors) are equivalent only if they reference the same declaration. Structural types (tuples, arrays, slices, unions, function types, pointers) use component-wise equivalence.

#### §7.7.3 Subtyping [type.relation.subtyping]

[8] **Definition 7.7.2 (Subtyping).** `τ <: υ` indicates that any value of type `τ` may substitute for `υ` without violating safety guarantees. Subtyping is reflexive and transitive:

$$
\dfrac{}{\tau <: \tau}
\tag{Sub-Refl}
$$

$$
\dfrac{\tau_1 <: \tau_2 \quad \tau_2 <: \tau_3}{\tau_1 <: \tau_3}
\tag{Sub-Trans}
$$

[9] Equivalence implies subtyping:

$$
\dfrac{\tau \equiv \upsilon}{\tau <: \upsilon}
\tag{Sub-Equiv}
$$

[10] Derived rules per type family:

- **Primitive:** Only equality; no widening beyond equivalence.
- **Tuples/Arrays/Slices:** Invariant (component-wise equivalence required).
- **Records/Enums/Modals:** Nominal, invariant.
- **Function types:** Contravariant in parameters, covariant in result, contravariant in grants and preconditions, covariant in postconditions (see §7.4.3.5).
- **Pointers:** State hierarchy `Ptr<T>@S <: Ptr<T>`; specific states do not subtype each other except through widening to the unconstrained type.
- **Unions:** `τ_i <: τ_1 \/ \cdots \/ τ_n`. Conversely, a union subtypes another union if every component of the source appears in the target (`{τ}` subset containment).
- **Never type:** `! <: τ` for all τ (§7.2.7).

Formal union subtyping:

$$
\dfrac{}{\tau_i <: \tau_1 \/ \cdots \/ \tau_n}
\tag{Sub-Union-Intro}
$$

$$
\dfrac{\forall i.\, \exists j.\, \tau_i \equiv \upsilon_j}{\tau_1 \/ \cdots \/ \tau_m <: \upsilon_1 \/ \cdots \/ \upsilon_n}
\tag{Sub-Union-Contain}
$$

Pointer widening:

$$
\dfrac{}{\text{Ptr}\langle\tau\rangle@S <: \text{Ptr}\langle\tau\rangle}
\tag{Sub-Ptr-Widen}
$$

Modal widening:

$$
\dfrac{}{M@S <: M}
\tag{Sub-Modal-Widen}
$$

#### §7.7.4 Variance Summary [type.relation.variance]

[11] Table 7.7.1 summarizes variance:

| Constructor               | Variance notes                                                                        |
| ------------------------- | ------------------------------------------------------------------------------------- |
| `τ` (primitive)           | invariant (only equality)                                                             |
| `(τ₁, …, τₙ)`             | invariant per component                                                               |
| `[τ; n]`, `[τ]`           | invariant                                                                             |
| `record`/`enum`/`modal`   | nominal, invariant                                                                    |
| `(τ₁,…,τₙ) -> τ_ret`      | contravariant parameters, covariant result, contravariant grants/must, covariant will |
| `Ptr<T>@State`            | invariant in `T`, but state-specific types widen to `Ptr<T>`                          |
| `τ₁ \/ … \/ τₙ`           | covariant in every component                                                          |
| `Option<T>` (example ADT) | follows enum rules (nominal)                                                          |

Manifesting a variance rule requires referencing the appropriate constructor rule (e.g., `Sub-Function`, `Sub-Union-Contain`).

#### §7.7.5 Compatibility [type.relation.compatibility]

[12] Some operations require compatibility checks beyond subtyping. Compatibility is denoted `τ ~ υ` and is used for:

- Matching pointer states (e.g., `Ptr<T>@Valid ~ Ptr<T>`).
- Matching modal states in pattern bindings.
- Ensuring binary operators operate on types with shared promotion rules (Clause 8).

Compatibility is reflexive and symmetric, but not necessarily transitive.

Example compatibility rules:

$$
\dfrac{}{\text{Ptr}\langle\tau\rangle@S ~ \text{Ptr}\langle\tau\rangle}
\tag{Compat-Ptr}
$$

$$
\dfrac{}{(\tau_1, \tau_2) ~ (\tau_1, \tau_2)}
\tag{Compat-Tuple}
$$

Compatibility failures produce diagnostics (Table 7.7.2).

#### §7.7.6 Diagnostics [type.relation.diagnostics]

[13] Required diagnostics:

| Code    | Condition                                                     |
| ------- | ------------------------------------------------------------- |
| E07-700 | Failed subtyping check (reports source/target, variance info) |
| E07-701 | Cyclic type alias detected                                    |
| E07-702 | Incompatible types in operation (compatibility failure)       |
| E07-703 | Pattern match missing modal state branch                      |
| E07-704 | Union pattern missing component type                          |

Each diagnostic SHALL provide the offending types, the rule violated, and suggestions (e.g., insert cast, add missing branch).

#### §7.7.7 Examples (Informative) [type.relation.examples]

```cursive
// Tuple invariance
let pair: (i32, string@Managed) = (1, string.from("hi"))
// let wider: (i32, string@View) = pair  // ERROR E07-700: tuple invariant

// Function subtyping
let pure: (i32) -> i32 = |x| [[ |- true => true ]] { result x }
let grant_fn: (i32) -> i32 ! { io::write } [[ |- true => true ]] = pure

// Union widening
let value: i32 \/ string@Managed = 42
let union: i32 \/ string@Managed \/ bool = value  // OK: subset containment

// Modal widening
procedure fetch(conn: Connection) {
    match conn {
        @Open => println("open"),
        @Closed => println("closed"),
    }
}

// Pointer state refinement
procedure use(ptr: Ptr<Data>) {
    match ptr {
        @Valid => println("value {}", (*ptr).id),
        @Null => println("missing"),
        _ => println("unusable"),
    }
}
```

#### §7.7.8 Conformance Requirements [type.relation.requirements]

[14] Implementations shall:

1. Implement equivalence, subtyping, and compatibility exactly as specified, maintaining reflexivity/transitivity properties.
2. Expand type aliases during equivalence checks and detect alias cycles (E07-701).
3. Enforce variance rules per constructor, rejecting invalid subtyping conversions with E07-700 diagnostics that include variance context.
4. Integrate pointer and modal state widening with provenance tracking to ensure state-sensitive operations are safe.
5. Report compatibility failures with E07-702/E07-703/E07-704, pinpointing missing cases.
6. Propagate relation results through the compiler (type inference, code generation, diagnostics) so downstream phases do not contradict type judgments.

[15] Any deviation from these requirements renders an implementation non-conforming unless explicitly noted elsewhere as implementation-defined.


### §6.8 Type Introspection [type.introspection]

[1] Type introspection provides compile-time access to metadata about types. It enables generic algorithms, diagnostics, and metaprogramming to query type properties without runtime overhead. Introspection facilities operate in two modes:

- **Type-level operators** such as `typeof(expr)` usable in type positions.
- **Compile-time queries** (e.g., `type_name<T>()`) available in compile-time evaluation contexts (Clause 16).

[2] Introspection never alters type semantics; it only exposes metadata. All results are immutable and must be consumed in compile-time contexts unless a function explicitly returns a runtime value (e.g., `type_id`).

#### §7.8.1 Syntax [type.introspection.syntax]

```
TypeOfExpr     ::= 'typeof' '(' Expression ')'
TypeNameExpr   ::= 'type_name' '<' Type '>' '()'
TypeIdExpr     ::= 'type_id' '<' Type '>' '()'
TypeInfoExpr   ::= 'type_info' '<' Type '>' '()'
```

`TypeOfExpr` is a type-level operator; the others produce values that may be used in compile-time or runtime contexts depending on the API.

#### §7.8.2 `typeof` Operator [type.introspection.typeof]

[3] `typeof(expr)` yields the static type of `expr` after type inference. It is valid only in type positions (e.g., type annotations, alias definitions). Formation rule:

$$
\dfrac{\Gamma \vdash e : \tau}{\Gamma \vdash \text{typeof}(e) : \text{Type}}
\tag{T-TypeOf}
$$

[4] `typeof` is evaluated during type checking. It cannot appear in runtime expressions; doing so emits diagnostic E07-900 (“`typeof` is a type-level operator”).

**Example 7.8.2.1**

```cursive
let value = compute()
let clone: typeof(value) = value.copy()
```

#### §7.8.3 Type Name Query [type.introspection.typename]

[5] `type_name<T>()` returns a `string@View` containing the canonical, fully-qualified type name.

- Accessible in both compile-time and runtime contexts.
- Guaranteed to be UTF-8.
- Name format is stable within a specification version (implementation may add informative namespace qualifiers but must document them).

Typing rule:

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash \text{type\_name}<\tau>() : \text{string@View}}
\tag{T-TypeName}
$$

**Example 7.8.3.1**

```cursive
let label: string@View = type_name<[i32]>()
println("Type: {}", label)
```

#### §7.8.4 Type Identity [type.introspection.typeid]

[6] `type_id<T>()` yields a `TypeId` value (opaque, comparable) used to test type equality at runtime. `TypeId` supports `==` and `!=` only.

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash \text{type\_id}<\tau>() : \text{TypeId}}
\tag{T-TypeId}
$$

`TypeId` satisfies:

- `type_id<T>() == type_id<U>()` iff `T ≡ U`.
- `TypeId : Copy`.

`TypeId` values may be stored at runtime for type-erasure scenarios.

#### §7.8.5 Detailed Type Information [type.introspection.typeinfo]

[7] `type_info<T>()` returns a compile-time constant of type `TypeInfo`. `TypeInfo` is defined as:

```cursive
record TypeInfo {
    name: string@View,
    size: usize,
    alignment: usize,
    kind: TypeKind,
    fields: [FieldInfo@Owned],
    variants: [VariantInfo@Owned],
}

enum TypeKind {
    Primitive,
    Tuple,
    Record,
    Enum,
    Union,
    Pointer,
    Modal,
    Function,
    Array,
    Slice,
    Other,
}

record FieldInfo {
    name: string@View,
    ty: Type,
    visibility: Visibility,
}

record VariantInfo {
    name: string@View,
    payload: [FieldInfo@Owned],
}
```

`TypeInfo` is evaluated in compile-time contexts. Attempting to use `type_info<T>()` at runtime emits E07-901. Elements `fields` and `variants` are empty for kinds where they are inapplicable.

Typing rule:

$$
\dfrac{\Gamma \vdash \tau : \text{Type}}{\Gamma \vdash \text{type\_info}<\tau>() : \text{TypeInfo}}
\tag{T-TypeInfo}
$$

`FieldInfo.ty` has kind `Type` and may only be inspected inside compile-time contexts (Clause 16). Using it in runtime expressions is rejected (E07-901).

#### §7.8.6 Compile-Time Context Requirements [type.introspection.comptime]

[8] Calls to `type_name`, `type_id`, and `type_info` are permitted in runtime code, but `type_info` results must remain compile-time constants (e.g., assigned to `const` bindings, used inside `comptime` blocks). Using `type_info` in runtime expressions triggers E07-901. `type_name` and `type_id` may be evaluated at runtime; their cost is implementation-defined but expected to be O(1).

[9] Introspection functions inside `comptime` blocks may be used to generate code (e.g., auto-derive implementations). Combine with Clause 16 semantics for compile-time evaluation.

#### §7.8.7 Interaction with Generics [type.introspection.generics]

[10] For generic parameters:

- `typeof<T>(expr)` is illegal; `typeof` always inspects expressions.
- `type_name<T>()` and `type_id<T>()` accept generic arguments instantiated in the current monomorphization.
- `type_info<T>()` reflects the monomorphized instantiation (after substitutions and alias expansion).

#### §7.8.8 Diagnostics [type.introspection.diagnostics]

[11] Required diagnostics:

| Code    | Condition                                                     |
| ------- | ------------------------------------------------------------- |
| E07-900 | `typeof` used in value position                               |
| E07-901 | `type_info` result escapes runtime context                    |
| E07-902 | Introspection invoked on ill-formed type                      |
| E07-903 | Attempt to inspect private field without visibility (tooling) |

E07-903 is emitted when tooling attempts to access private fields via `type_info` outside the defining module. Public metadata remains accessible.

#### §7.8.9 Examples (Informative) [type.introspection.examples]

```cursive
// Example: auto-generate debug output
comptime {
    let info = type_info<Point>()
    assert(info.kind == TypeKind::Record)
    let debug_impl = format!(
        "procedure debug(self: const Point) {{ println(\"Point(x: {{}}, y: {{}})\", self.{}, self.{}) }}",
        info.fields[0].name,
        info.fields[1].name,
    )
    compiler::emit_impl(debug_impl)
}

// Runtime type comparisons
let a_id = type_id<[i32; 10]>()
let b_id = type_id<[i32; 10]>()
assert(a_id == b_id)

let label = type_name<string@Managed \/ io::Error>()
println("Type label: {}", label)
```

#### §7.8.10 Conformance Requirements [type.introspection.requirements]

[12] Implementations shall:

1. Evaluate `typeof` during type checking and forbid value-position use.
2. Provide stable, fully-qualified names for `type_name`, documented per implementation.
3. Generate unique, comparable `TypeId` values respecting type equivalence.
4. Implement `type_info` as a compile-time constant with accurate metadata (size, alignment, fields, variants, kind) and enforce compile-time-only usage.
5. Detect misuse via diagnostics E07-900–E07-903.
6. Ensure introspection results are unaffected by optimization levels; metadata is purely structural.

[13] Deviations render an implementation non-conforming unless explicitly marked as implementation-defined elsewhere.


### §7.1 Expression Fundamentals [expr.fundamental]

#### §7.1.1 Scope and Purpose

[1] This subclause establishes the global properties shared by all expressions. Expressions are analysed relative to a _context_ consisting of: (a) the lexical typing environment `Γ`, (b) the active grant budget supplied by the enclosing procedure's grants clause (the grant component of its contractual sequent, see Clause 9), (c) the region and permission stacks defined by Clause 9, and (d) the evaluation schedule described in §7.1.3. Every well-formed expression shall respect all contextual obligations simultaneously; violation of any dimension renders the expression ill-formed.

#### §8.1.2 Grammar Map

[3] Annex A §A.4 is the authoritative grammar for expressions. Table 8.1 lists each relevant production together with the specification subclause that defines its semantics.

| Annex production                                    | Description                                               | Spec reference |
| --------------------------------------------------- | --------------------------------------------------------- | -------------- |
| `PrimaryExpr`, `PostfixExpr`                        | Literals, identifiers, blocks, calls, indexing, pipelines | §8.2           |
| `UnaryExpr`, `BinaryExpr`, `AssignExpr`             | Prefix, infix, and assignment operators                   | §8.3           |
| `StructuredExpr`, `IfExpr`, `MatchExpr`, `LoopExpr` | Composite constructors and control expressions            | §8.4           |
| `Pattern`, `MatchArm`                               | Expression patterns and guards                            | §8.5           |
| `CastExpr`                                          | Explicit conversions (`as`)                               | §8.6           |
| `ComptimeExpr`                                      | Compile-time blocks                                       | §8.7           |
| `Expr`                                              | Type/diagnostic consolidation                             | §8.8           |

#### §8.1.3 Deterministic Evaluation Model

[4] **Strict left-to-right order.** Subexpressions evaluate strictly left-to-right unless a subclause explicitly states otherwise. Formally,

$$
\frac{\langle e_1, \sigma \rangle \Downarrow \langle v_1, \sigma_1 \rangle \quad \cdots \quad \langle e_n[v_1,\ldots,v_{n-1}], \sigma_{n-1} \rangle \Downarrow \langle v_n, \sigma_n \rangle}{\langle f(e_1,\ldots,e_n), \sigma \rangle \Downarrow \langle f(v_1,\ldots,v_n), \sigma_n \rangle}}
\tag{E-LeftToRight}
$$

applies to every compound expression `f`. No implementation may reorder independent operands or hoist subexpressions.

[5] **Short-circuit exception.** The only sanctioned deviation from §8.1.3[4] is the short-circuit behaviour of `&&` and `||` (§8.3.7), which may skip evaluating their right operand when the left operand determines the result. All other operators, including pipelines and ternary constructs, must evaluate each operand.

[6] **Call-by-value semantics.** Procedure calls, grant-requiring operations, and pipeline stages evaluate their arguments completely before transferring control to the callee. Divergent subexpressions (type `!`) propagate divergence to the enclosing expression, ensuring predictable side-effect ordering.

[7] **Determinism.** Given identical inputs, grant budgets, and compile options, a conforming implementation shall produce identical observable behaviour: evaluation order, side effects, and panic points are deterministic. There is no unspecified behaviour akin to C/C++ sequence points.

[8] **Comptime vs runtime contexts.** Expressions appearing in const/comptime positions (§7.7) must be evaluable during the compile-time execution phase (§2.2). Injecting runtime-only constructs (IO, heap allocation, raw pointer arithmetic) into such contexts is ill-formed (E07-001).

[9] **Pipeline annotation rule.** In `lhs => stage : Type`, the annotation `: Type` may be omitted only when the compiler proves `typeof(lhs) ≡ typeof(stage(lhs))` (type equivalence per §6.7). If the stage changes the type—or if equivalence cannot be proven—an explicit annotation is mandatory; omission yields E07-020. Type-preserving stages may omit the annotation to reduce redundancy, but tooling shall still record the before/after types.

#### §8.1.4 Expression Categories

[10] Each expression is classified into exactly one of the following categories:

- **Value** — produces a temporary result that may be moved (consumed) or copied depending on the `Copy` predicate of its type (§6.2–§6.3). Literals, arithmetic expressions, and most calls fall into this category.
- **Place** — denotes a storage location (variables, fields, tuple components, indexed elements, dereferenced pointers). Places may appear on the left side of assignments or as operands to operators requiring mutable access, provided they carry `mut` or `own` permission (§9.4).
- **Divergent** — expressions of type `!` that never return (`loop {}` without `break`, `panic`). Divergent expressions coerce to any type via the rule in §6.2.7 and retain category `divergent` for diagnostic purposes.

[11] The typing judgment records the category: `Γ ⊢ e : τ ! ε [cat]`. While Cursive does not currently expose category information as surface syntax, compilers and IDE tooling shall surface it in diagnostics and metadata. (Informative note: future editions may extend the comptime reflection system with predicates such as `is_place(expr)` when metaprogramming demand justifies the added complexity.)

#### §8.1.5 Grant Accumulation

[12] Grants describe observable capabilities (Clause 11). Each expression carries a grant set `ε`. The grant set of a compound expression is the union of its subexpression grants plus any intrinsic grants contributed by the expression form.

[13] Rule `Grant-Union` summarises grant accumulation:

$$
\frac{\Gamma \vdash e_i : \tau_i ! \varepsilon_i}{\Gamma \vdash f(e_1,\ldots,e_n) : \tau_f ! \left(\bigcup_i \varepsilon_i \cup \varepsilon_f\right)}
\tag{Grant-Union}
$$

where `ε_f` covers intrinsic grants (e.g., `unsafe.ptr` for raw-pointer dereference).

[14] The enclosing procedure shall list at least this union in its contractual sequent's grants clause. Violations: E07-004. This edition deliberately avoids grant bundles to keep obligations explicit. (Informative note: if production experience shows repeated unions hinder readability, the working group may introduce declared bundles in a future revision.)

#### §8.1.6 Typing Discipline

[15] Cursive employs a bidirectional typing discipline:

- **Inference sites** (literals, identifiers, most operands) synthesise a type without needing contextual information.
- **Checking sites** (block `result` expressions, match arms, annotated bindings) require a contextual type. When inference fails and no context exists, E07-002 recommends adding annotations.
- **Bidirectional sites** (function calls, pipelines, polymorphic literals) first attempt to satisfy the contextual expectation; failing that, they synthesise a type and ask the context to accept it via subtyping (§6.7).

[16] Every expression must also satisfy three auxiliary checks:

- **Definite assignment** — Clause 4 §4.7 ensures bindings are initialised before use. Ill-formed usages trigger E07-210 (identifier used before assignment) within expression contexts.
- **Permission safety** — Clause 9 tracks permissions on places. Assigning through a `let` binding or reading a moved `own` value emits E09-403.
- **Type compatibility** — Operands must satisfy the subtyping/compatibility rules of Clause 6. Failures result in E07-800, which reports both types, the relevant rule (variance, equality), and suggested remedies.

#### §8.1.7 Diagnostics

[17] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.7. — end note]

#### §8.1.8 Canonical Example

**Example 8.1.8.1 (Deterministic evaluation and pipeline annotations).**

```cursive
use io::{read_config, write_log}

procedure refresh(user: mut Session, raw: string@View): ()
    [[ io::read, io::write |- raw.len() > 0 => user.last_refresh >= clock::now() - 5m ]]
{
    let normalized: Config \/ Error = raw
        => trim
        => parse_config: Config \/ Error
        => validate

    match normalized {
        cfg: Config => {
            user.apply(cfg)
            write_log("refresh ok")
        }
        err: Error => {
            write_log(err.message())
        }
    }
}
```

[19] The example illustrates: (a) strict left-to-right evaluation (`trim` runs before `parse_config`), (b) the pipeline annotation rule (only type-changing stage `parse_config` uses `: Config \/ Error`), (c) place semantics (`user` is a place requiring `mut` permission), and (d) grant accumulation (`io::read` introduced by `read_config` plus `io::write` from `write_log`).

---


### §7.2 Primary and Postfix Expressions [expr.primary]

#### §7.2.1 Overview

[1] Primary expressions form the leaves of the expression grammar (Annex A §A.4.1–§A.4.3); postfix expressions extend those primaries with calls, field access, indexing, slicing, pointer manipulation, and pipelines (Annex A §A.4.4–§A.4.8). This subclause specifies their syntax, typing, evaluation, and diagnostics in detail.

#### §7.2.2 Literals

[2] Grammar reference: Annex A §A.4.1 (`Literal`). Literal tokens arise from the lexical grammar (§2.3). Each literal’s default type is defined in Clause 7 §7.2.

[3] Typing rules:

- **Integer literals** default to `i32`. Contextual typing may coerce them to any integer type `τ` whose value set contains the literal. Literal suffixes (`123u64`, `0xffu8`) override both defaults and contextual expectations. Ill-fitting literals produce E08-201.
- **Floating literals** default to `f64`; suffix `f32` selects `f32`. Mixed numeric literals require explicit casts (§8.6).
- **Boolean literals** `true`/`false` always have type `bool`.
- **Character literals** have type `char`. They shall denote a single Unicode scalar value; invalid escapes or surrogate code points emit E08-202.
- **String literals** have type `string@View` and refer to statically allocated UTF-8 data. Modal transitions to `string@Owned` require explicit constructors (§7.3.4).
- **Tuple literals** and **array literals** are structured forms handled in §8.4, but their element typing relies on the literal rules above.

[4] Evaluation: literals evaluate to themselves without modifying the store. String literals may share backing storage; this does not affect semantics because `string@View` values are immutable views.

#### §7.2.3 Identifier Expressions

[5] Grammar reference: Annex A §A.4.1 (`PrimaryExpr ::= IDENT`). Identifiers are resolved using the algorithm in Clause 6 §6.4. If resolution yields a type, module, or contract, the expression is ill-formed (E08-211).

[6] Typing rule:

$$
\frac{(x : \tau [cat]) \in \Gamma}{\Gamma \vdash x : \tau ! \emptyset [cat]}
\tag{T-Ident}
$$

[7] Using an identifier before definite assignment (Clause 5 §5.7) emits E08-210. When the binding category is `place`, the expression inherits that category; otherwise it is a value.

#### §7.2.4 Parenthesised Expressions

[8] Grammar: `ParenExpr ::= '(' Expr ')'` (Annex A §A.4.2).

[9] Typing: parentheses do not alter type, grant set, or category. They exist solely for disambiguation and readability. Implementations shall preserve parentheses in diagnostics to aid tooling.

#### §7.2.5 Block Expressions

[10] Grammar: `BlockExpr ::= '{' Statement* ('result' Expr)? '}'` (Annex A §A.4.3).

[11] Typing:

- Blocks introduce a lexical scope (§6.2). Statements inside the block are type-checked per Clause 9.
- If the block includes `result expr`, the block’s type is `typeof(expr)`; otherwise it is `()`.
- Non-unit blocks shall use `result` explicitly; omission triggers E08-220.

[12] Evaluation: statements execute in order, each possibly mutating the store. `result expr` evaluates `expr` as the final value; the scope then exits, dropping bindings in reverse creation order (Clause 12 §12.2).

#### §7.2.6 Unit Expression

[13] `()` denotes both the unit literal and the unit type (§7.2.6). It is the default result when an expression exists solely for side effects.

#### §7.2.7 Procedure and Function Calls

[14] Grammar: `CallExpr ::= PostfixExpr '(' ArgumentList? ')'` (Annex A §A.4.4).

[15] Typing:

$$
\frac{\Gamma \vdash f : (\tau_1,\ldots,\tau_n) \to \tau_r ! \varepsilon_f \quad \Gamma \vdash a_i : \tau_i ! \varepsilon_i}{\Gamma \vdash f(a_1,\ldots,a_n) : \tau_r ! (\varepsilon_f \cup \varepsilon_1 \cup \cdots \cup \varepsilon_n)}
\tag{T-Call}
$$

[16] Variadic or keyword argument patterns are expanded into syntactic sugar that ultimately matches the above rule. Call arity mismatches or missing required arguments emit E08-230; extra arguments emit E08-231.

[17] Associated procedures (`receiver::method(args)`) desugar to calls on values defined in Clause 5. The receiver expression is evaluated first and must provide the permission declared by the method’s `self` parameter. Violations produce E08-232 (insufficient permission) or E08-233 (receiver type mismatch).

[18] Evaluation order is left-to-right: callee expression, then each argument. Partial evaluation (e.g., due to `move`) follows the semantics of the argument expressions themselves.

#### §7.2.8 Field Access and Tuple Projection

[19] Grammar: `FieldExpr ::= PostfixExpr '.' IDENT`, `TupleProj ::= PostfixExpr '.' INTEGER_LITERAL` (Annex A §A.4.5).

[20] Typing:

- Records: if `Γ ⊢ e : R` and `R` declares field `f : τ` visible in the current module (Clause 5 §5.6), then `Γ ⊢ e.f : τ [cat]` where `cat` matches `e`’s category. Accessing a private/internal field from another module emits E08-240.
- Tuple projections: if `Γ ⊢ e : (τ_1,…,τ_n)` and `0 ≤ i < n`, then `Γ ⊢ e.i : τ_{i+1}`. Indices outside this range emit E08-241.

[21] Both forms preserve place/value categories: reading a field from a place yields a place.

#### §7.2.9 Array Indexing and Slicing

[22] Grammar: `IndexExpr ::= PostfixExpr '[' Expr ']'`, `SliceExpr ::= PostfixExpr '[' RangeExpr? ']'` (Annex A §A.4.6).

[23] Typing:

- Arrays `[τ; n]` and slices `[τ]` may be indexed with `usize`. The result type is `τ`. Index expressions evaluate left-to-right.
- Slicing `[start..end]` yields `[τ]`. Bounds may be partially omitted (defaulting to `0` or `len`). Bounds must satisfy `0 ≤ start ≤ end ≤ len`; otherwise E08-251 is raised.

[24] Runtime bounds checking is mandatory. Out-of-range indices panic with diagnostic E08-250 containing the index, length, and expression span.

#### §7.2.10 Pointer Address-of and Dereference

[25] Grammar: unary `&` and unary `*` (Annex A §A.4.7).

[26] Address-of (`&place`) is valid only for place expressions tied to storage. Typing rule:

$$
\frac{\Gamma \vdash p : \tau [place]}{\Gamma \vdash \&p : Ptr\langle \tau \rangle@Valid}
\tag{T-Addr}
$$

Attempting to take the address of a value emits E08-260.

[27] Dereference typing is defined in Clause 7 §7.5, but evaluation semantics require the pointer to be in state `@Valid`. Dereferencing `@Null`, `@Weak`, or `@Expired` pointers produces diagnostics E07-301/E07-304/E07-305 as appropriate.

#### §7.2.11 Pipelines

[28] Grammar: `PipelineExpr ::= PostfixExpr '=>' PostfixExpr ( '=>' PostfixExpr )*` (Annex A §A.4.8).

[29] Semantics: `lhs => stage` desugars to `stage(lhs)`. Each stage shall be callable with exactly one argument—the output of the preceding stage. Additional parameters shall be supplied via closures or partial application.

[30] Typing: let `Γ ⊢ lhs : τ_0`. For each stage `stage_k`, require `Γ ⊢ stage_k : (τ_{k-1}) -> τ_k ! ε_k`. The pipeline’s type is `τ_m`. Stages that omit `: τ_k` must satisfy the type-preserving rule in §8.1.3[9]. Missing or mismatched annotations trigger E08-020/E08-021.

[31] Evaluation is left-to-right: compute `lhs`, feed it into `stage_1`, feed the result into `stage_2`, and so on. The grant set is the union of `lhs`’s grants and all stage grants.

#### §7.2.12 Diagnostics Summary

| Code    | Condition                                              |
| ------- | ------------------------------------------------------ |
| E08-201 | Integer literal cannot fit target type                 |
| E08-202 | Invalid character literal                              |
| E08-210 | Identifier used before definite assignment             |
| E08-211 | Identifier resolves to non-value entity                |
| E08-220 | Block producing non-unit value without `result`        |
| E08-230 | Procedure call arity mismatch                          |
| E08-231 | Procedure call has extra arguments                     |
| E08-232 | Method receiver lacks required permission              |
| E08-233 | Method receiver has incompatible type                  |
| E08-240 | Field access violates visibility                       |
| E08-241 | Tuple projection index out of range                    |
| E08-250 | Array/slice index out of range                         |
| E08-251 | Slice bounds invalid                                   |
| E08-260 | Address-of applied to non-place expression             |
| E08-020 | Pipeline stage omitted type while changing type        |
| E08-021 | Pipeline stage annotation disagrees with inferred type |

#### §7.2.13 Canonical Example

```cursive
let payload: string@Managed \/ ParseError = raw
    => trim
    => parse: Ast \/ ParseError
    => render: string@Managed \/ ParseError

match payload {
    html: string@Managed => io::write(html),
    err: ParseError => log::error(err.message()),
}
```

[32] This example demonstrates literal strings, pipelines with mandatory annotation on the type-changing stage, field access on union types, and pattern matching (detailed further in §8.5). The pipeline's grant set is the union of the individual stage grants, ensuring the enclosing procedure's grants clause (in its contractual sequent) is explicit.

---


### §7.3 Unary and Binary Operators [expr.operator]

#### §7.3.1 Overview

[1] Operators extend expressions with prefix (`!`, `-`, `&`, `move`), infix (arithmetic, comparison, logical, range), exponentiation, and assignment semantics. Annex A §A.4.9 defines their precedence and associativity. This subclause restates the table, then specifies typing, evaluation, and diagnostics for each operator.

#### §7.3.2 Precedence hierarchy

[2] Table 8.3.1 lists operators from highest to lowest precedence. All binary operators associate left-to-right except exponentiation and assignments, which associate right-to-left.

| Level | Operators                                      | Associativity        | Notes    |
| ----- | ---------------------------------------------- | -------------------- | -------- |
| 1     | Postfix (`()`, `[]`, `.`, `::`, pipeline `=>`) | Left                 | See §8.2 |
| 2     | Prefix (`!`, `-`, `&`, `move`)                 | Right                | §8.3.3   |
| 3     | `**`                                           | Right                | §8.3.4   |
| 4     | `*`, `/`, `%`                                  | Left                 | §8.3.4   |
| 5     | `+`, `-`                                       | Left                 | §8.3.4   |
| 6     | `<<`, `>>`                                     | Left                 | §8.3.4   |
| 7     | `..`, `..=` (binary form)                      | Left                 | §8.3.5   |
| 8     | Bitwise `&`                                    | Left                 | §8.3.4   |
| 9     | Bitwise `^`                                    | Left                 | §8.3.4   |
| 10    | Bitwise `\|`                                   | Left                 | §8.3.4   |
| 11    | `<`, `<=`, `>`, `>=`                           | Left                 | §8.3.6   |
| 12    | `==`, `!=`                                     | Left                 | §8.3.6   |
| 13    | `&&`                                           | Left (short-circuit) | §8.3.7   |
| 14    | `\|\|`                                         | Left (short-circuit) | §8.3.7   |
| 15    | `=`, `op=`                                     | Right                | §8.3.8   |

#### §7.3.3 Unary operators

[3] Grammar: `UnaryExpr ::= ('!' | '-' | '&' | 'move') UnaryExpr | PostfixExpr` (Annex A §A.4.9).

**Logical NOT (`!`)**

[4] Operand must have type `bool`. Result type is `bool`. Using a non-boolean operand yields E08-320.

**Arithmetic negation (`-`)**

[5] Operand must belong to `NumericTypes`. Result type equals operand type. Negating the minimum signed integer in checked builds triggers a panic with diagnostic E08-330; release builds wrap according to Clause 7 §7.2. Developers may opt into always-checked or always-wrapping modes via attributes (Clause 1 §1.6).

**Address-of (`&`)**

[6] Covered in §8.2.10; invalid uses emit E08-260.

**Move (`move e`)**

[7] The `move` operator explicitly transfers cleanup responsibility from one binding to another. Only `let` bindings created with `=` may be moved; moving from `var` or non-responsible (`<-`) bindings is ill-formed. Complete move semantics, transfer rules, and invalidation behavior are specified in §11.5.2 [memory.move].

#### §7.3.4 Arithmetic and bitwise operators

[8] Grammar: `MulExpr`, `AddExpr`, `ShiftExpr`, `BitAndExpr`, `BitXorExpr`, `BitOrExpr` in Annex A §A.4.9.

[9] Typing rules:

- Operands shall have identical numeric type `τ`. Mixed-type arithmetic requires explicit casts (§8.6) and therefore is ill-formed by default (E08-301).
- `%` is defined only for integer types. Using it with floating types emits E08-302.
- Shift operators require left operand of integer type `τ` and right operand of type `usize`. The shift amount must satisfy `amount < bitwidth(τ)`; otherwise E08-303.

[10] Evaluation: both operands evaluate left-to-right. Division or modulo by zero panic with diagnostic E08-304. Integer overflow follows the semantics configured for the compilation mode: checked builds panic, release builds wrap (Clause 7 §7.2). Bitwise operators operate on the binary representation without additional checks.

#### §7.3.5 Power and range operators

[11] Exponentiation `**` accepts numeric operands of identical type and returns that type. It associates right-to-left, so `a ** b ** c` parses as `a ** (b ** c)`.

[12] Binary range operators `a..b` and `a..=b` create range values (Clause 7 §7.3.4). Operands must have the same numeric type. Evaluation occurs left-to-right: compute `a`, compute `b`, then package the range structure. Invalid ordering (e.g., `b < a`) is permitted; it is diagnosed only when consumers demand ordered ranges (e.g., slicing).

#### §7.3.6 Comparison and equality

[13] `<`, `<=`, `>`, `>=` require operands of identical numeric or `char` type. Result is `bool`. Comparisons on `f32`/`f64` follow IEEE 754 semantics (`NaN` is unordered).

[14] `==` and `!=` are available exactly when the operand type satisfies the `Eq` behavior (Clause 11). Primitive types satisfy `Eq` by default. Custom types shall derive or satisfy `Eq`; otherwise E08-310 is emitted. Equality is symmetric and reflexive for non-`NaN` values.

#### §7.3.7 Logical operators

[15] `&&` and `||` require operands of type `bool`. Both operators short-circuit: `a && b` evaluates `b` only when `a` is `true`; `a || b` evaluates `b` only when `a` is `false`. Their result is `bool`. Mis-typed operands emit E08-320.

[16] Bitwise XOR (`^`) is distinct from logical XOR; it operates on integers. For boolean logical XOR, compose `a != b`.

#### §7.3.8 Assignment and compound assignment

[17] Grammar: `AssignExpr ::= UnaryExpr AssignmentOperator Expr`, where `AssignmentOperator ∈ { '=', '+=', '-=', '*=', '/=', '%=', '&=', '|=', '^=', '<<=', '>>=' }` (Annex A §A.4.9).

[18] Typing constraints:

- Left operand must be a place with permission `mut` or `own` and type `τ`.
- Right operand must have type `τ`.
- `op=` forms require `op` to be valid for type `τ` (e.g., `+=` valid on numeric types).

[19] Evaluation order: evaluate the left operand to obtain the target place, then evaluate the right operand, then perform the assignment. For compound assignments, the compiler reads the current value of the place exactly once, applies the operator, and writes the result back.

[20] Diagnostics:

- Non-place left operand → E08-340.
- Insufficient permission → E11-403.
- Unsupported compound operator/type combination → E08-341.
- Chained assignment attempts (e.g., `x = y = z`) emit E08-342 unless each assignment is standalone.

#### §7.3.9 Move interaction

[21] Operators follow move semantics. If an operand’s type is move-only (`own`) and lacks `Copy`, the operator consumes it; subsequent uses of the binding are ill-formed (Clause 5 diagnostics). Commutative operators still evaluate left-to-right, so moving the left operand before evaluating the right operand is observable.

#### §7.3.10 Diagnostics summary

| Code    | Condition                                              |
| ------- | ------------------------------------------------------ |
| E08-301 | Operand types mismatch for arithmetic/bitwise operator |
| E08-302 | Modulo operator applied to non-integer type            |
| E08-303 | Shift amount ≥ bit width                               |
| E08-304 | Division or modulo by zero                             |
| E08-310 | Equality invoked on type without `Eq` implementation   |
| E08-320 | Logical operator operands not `bool`                   |
| E08-330 | Checked-mode arithmetic negation overflow              |
| E08-331 | `move` applied to value without ownership              |
| E08-340 | Assignment target is not a place                       |
| E08-341 | Compound assignment invalid for operand type           |
| E08-342 | Chained assignment is ill-formed                       |

#### §7.3.11 Canonical example

```cursive
var counter: mut i32 = 0

procedure tick(delta: i32): ()
    [[ |- true => true ]]
{
    counter += delta                 // compound assignment
    if counter < 0 {
        counter = 0
    }
    if counter % 5 == 0 && delta != 0 {
        log::info("milestone reached")
    }
}
```

[22] The example demonstrates compound assignment, comparison, modulo, and logical short-circuiting, while respecting evaluation order and permissions.

---


### §7.4 Structured Expressions [expr.structured]

#### §7.4.1 Overview

[1] Structured expressions construct composite values (records, tuples, arrays, enums) and perform control flow (`if`, `match`, `loop`). They introduce nested scopes, bindings, and evaluation paths that interact with patterns (§8.5) and the typing discipline (§8.8). Grammar references: Annex A §A.4.10–§A.4.16.

#### §7.4.2 Record, Tuple, and Enum Construction

**Record literals**

[2] Grammar: `RecordExpr ::= Path '{' FieldInit (',' FieldInit)* '}'` (Annex A §A.4.10).

[3] Typing:

- Let record `R` declare fields `{f₁: τ₁, …, fₙ: τₙ}`. A literal `R { f_i : e_i }` is well-formed iff each field appears exactly once, no extra fields are supplied, and `Γ ⊢ e_i : τ_i`.
- Shorthand `{ field }` expands to `{ field: field }`.
- Field visibility is enforced: referencing an internal/private field from another module emits E08-402.

[4] Evaluation: evaluate field expressions left-to-right as written (not declaration order). The record value is then formed with the evaluated fields. Temporaries drop after the literal completes.

**Tuple literals**

[5] Grammar: `TupleExpr ::= '(' Expr ',' Expr (',' Expr)* ')'` (Annex A §A.4.11).

[6] Typing: `Γ ⊢ (e₁,…,eₙ) : (τ₁,…,τₙ)` with `n ≥ 2`. Single-element tuple syntax is prohibited (E08-403); use parentheses or arrays as appropriate.

[7] Evaluation: evaluate elements left-to-right, storing them in a contiguous tuple layout (Clause 7 §7.3.2).

**Enum variants**

[8] Grammar: `EnumExpr ::= Path | Path '(' ExprList ')' | Path '{' FieldInit* '}'` (Annex A §A.4.12).

[9] Typing: the referenced variant must belong to the enum. Payload expressions shall match the variant’s tuple or record payload types. Missing or extra payload elements emit E08-404.

#### §7.4.3 Array Literals and Repetition

[10] Grammar: `ArrayLiteral ::= '[' Expr (',' Expr)* ']' | '[' Expr ';' ConstExpr ']'` (Annex A §A.4.13).

[11] Typing:

- Elements must share the same type `τ`. If the literal appears in a context with type `[τ; n]`, the number of expressions shall equal `n`.
- Repeat form `[value; n]` requires `τ : Copy` and `n` to be comptime evaluable (§8.7). Violations produce E08-430/E08-431.

[12] Evaluation: element expressions evaluate left-to-right. Repeat form evaluates `value` once and duplicates it `n` times.

#### §7.4.4 Conditional Expressions (`if` and `if let`)

[13] Grammar: `IfExpr ::= 'if' Expr Block ('else' Clause)?`, `IfLetExpr ::= 'if' 'let' Pattern '=' Expr Block ('else' Block)?` (Annex A §A.4.14).

[14] Typing rules:

- `if`: condition must have type `bool`. Branch blocks shall produce a common type `τ`; if `else` is omitted, `τ` must be `()`.
- `if let`: pattern typing follows §8.5. Bindings introduced by the pattern exist only inside the `then` block. Both branches shall converge to the same type; `else` may be omitted only when the expression is used in a `()` context.

[15] Guards on `if let` (`if let pattern = expr if guard`) shall have type `bool` and are evaluated only after the pattern succeeds.

#### §7.4.5 Match Expressions

[16] Grammar: `MatchExpr ::= 'match' Expr '{' MatchArm (',' MatchArm)* '}'` (Annex A §A.4.15).

[17] Semantics:

- The scrutinee expression is evaluated once.
- Arms are tried sequentially. Each arm consists of `pattern => expr` or `pattern if guard => expr`.
- Pattern typing follows §8.5. Each arm expression shall yield a common result type `τ`.
- Guards evaluate after the pattern matches and may use bindings introduced by the pattern.

[18] Type annotation requirement: when a match expression's result type cannot be inferred unambiguously, an explicit type annotation shall be provided using a typed hole (`let output: _ = match …`). The compiler shall infer the match result type when all arms produce compatible types; when inference fails or arms produce union types, the programmer may provide an explicit annotation or allow the hole to trigger diagnostic E08-002 requesting clarification.

[19] Exhaustiveness: matches over enums, unions, modal states, and booleans must cover all constructors. Non-exhaustive matches emit E07-451 with a list of missing cases. Catch-all `_` arms satisfy the requirement.

[20] Reachability: arms shadowed by earlier arms are reported via E08-452.

#### §7.4.6 Loop Expressions

[21] Grammar: `LoopExpr ::= 'loop' Block | 'loop' Expr Block | 'loop' Pattern ':' Type 'in' Expr Block` (Annex A §A.4.16).

**Infinite loops**

[22] `loop { body }` has type `!` (never) unless a `break value` appears. When all break statements supply the same type `τ`, the loop expression has type `τ`. Inconsistent break types produce E08-460.

**Conditional loops**

[23] `loop condition { body }` requires `condition : bool`. The loop type is `()` unless breaks specify otherwise.

**Iterator loops**

[24] Syntax enforces explicit iterator annotation: `loop item: ItemType in iterator_expr { … }`. Missing `ItemType` yields E08-461. The iterator expression shall satisfy the iteration protocol defined by Clause 11; otherwise E08-462 is emitted. Inside the loop, `item` has type `ItemType` and inherits permissions from the iterator yield.

**Break/continue**

[25] `break` exits the nearest loop, optionally yielding a value. `continue` restarts the current loop iteration. Using either outside a loop is ill-formed (E08-463).

#### §7.4.7 Closure Expressions and Capture [expr.structured.closure]

##### §7.4.7.1 Overview

[26] Closure expressions create anonymous callable values that can capture variables from enclosing scopes. They are first-class values of function type (§7.4) and enable higher-order programming patterns.

##### §7.4.7.2 Syntax

**Closure expressions** match the pattern:
```
"|" [ <parameter_list> ] "|" [ <sequent_clause> ] <block_expr>
```

[ Note: See Annex A §A.4 [grammar.expression] for the normative `closure_expr` production.
— end note ]

[27] Closures use vertical bars `|...|` to delimit parameters (which may be empty). The sequent clause is optional and defaults to `[[ |- true => true ]]` (pure closure). The block expression forms the closure body.

##### §7.4.7.3 Free Variable Identification [expr.structured.closure.free]

[28] A variable is _free_ in a closure if it is referenced within the closure body but not declared within the closure itself (not a parameter, not a local binding within the closure).

**Example:**

```cursive
let factor = 2.0
let scale = |value| [[ |- true => true ]] {
    result value * factor  // `factor` is free (captured), `value` is bound (parameter)
}
```

##### §7.4.7.4 Capture Modes [expr.structured.closure.modes]

[29] Free variables are automatically captured. The capture mode depends on the binding category of the captured variable:

**Table 8.4.1 — Closure capture modes**

| Binding Category | Capture Mode           | Semantics                                       |
| ---------------- | ---------------------- | ----------------------------------------------- |
| `let x = value`  | By reference (default) | Closure holds reference to binding location     |
| `let x <- value` | By reference           | Closure holds non-responsible reference         |
| `var x = value`  | By reference           | Closure holds mutable reference                 |
| `var x <- value` | By reference           | Closure holds non-responsible mutable reference |
| Parameters       | By reference           | Closure references parameter storage            |

[30] **Explicit move capture.** When a closure body explicitly uses `move x` for a captured responsible binding, cleanup responsibility transfers to the closure environment and the original binding becomes invalid:

```cursive
let data = Buffer::new()
let consumer = || [[ |- true => true ]] {
    process(move data)  // Explicit move transfers responsibility to closure
}
// data is now invalid (moved into closure environment)
```

[31] Without explicit `move`, all captures default to by-reference mode, preserving the binding's validity in the outer scope while allowing the closure to access or mutate the value.

##### §7.4.7.5 Environment Record Synthesis [expr.structured.closure.environment]

[32] The compiler synthesizes an environment record type `_Closure_N` containing fields for each captured variable. The closure value is represented as:

```cursive
// Conceptual representation (compiler-internal)
record _Closure_N {
    captured_var1: Type1,
    captured_var2: Type2,
    // ... one field per capture
}
```

[33] The closure callable has type `(Params) -> ReturnType ! Grants` and is implemented as a procedure taking the environment record plus declared parameters.

##### §7.4.7.6 Copy Behavior for Closures [expr.structured.closure.copy]

[34] A closure is `Copy` only when:

1. The environment record is empty (no captures), OR
2. Every captured value satisfies `Copy` AND is captured by immutable reference

[35] Most closures with captures are move-only. Empty closures (capturing no variables) may be freely copied.

##### §7.4.7.7 Constraints

[36] **Permission requirements.** Captured bindings must have permissions compatible with closure usage:

- Closures mutating captured `var` bindings require those bindings to have mutable permission
- Capturing `unique` bindings by reference requires the unique binding to be temporarily inactive while the closure holds the reference
- Closures escaping the capturing scope must not capture stack-local references (escape analysis applies)

[37] **Grant propagation.** The closure's grant set includes the union of:

- Grants declared in the closure's sequent clause
- Grants required by captured procedure calls within the closure body
- Grants from any subexpressions in the closure

##### §7.4.7.8 Diagnostics

| Code    | Condition                                                          |
| ------- | ------------------------------------------------------------------ |
| E08-470 | Closure captures moved-from value                                  |
| E08-471 | Closure outlives captured reference (escape violation)             |
| E08-472 | Closure captures unique binding while uniqueness is active         |
| E08-473 | Closure permission incompatible with captured variable permissions |

##### §7.4.7.9 Examples

**Example 8.4.7.1 (Closure capturing var binding by reference):**

```cursive
procedure make_counter(): () -> i32
    [[ alloc::heap |- true => true ]]
{
    var count = 0
    result || [[ |- true => true ]] {
        count += 1
        result count
    }
    // Closure captures `count` by reference; each call mutates the same counter
}
```

**Example 8.4.7.2 (Closure with explicit move capture):**

```cursive
let data = Buffer::from("hello")
let consumer = || [[ alloc::heap |- true => true ]] {
    consume(move data)  // Cleanup responsibility transfers to closure
}
// data is invalid here (moved into closure environment)
consumer()  // Executes with moved data
```

**Example 8.4.7.3 (Multiple captures with mixed modes):**

```cursive
let config = load_config()       // let binding (immutable)
var counter = 0                  // var binding (mutable)

let process = |input: string@View| [[ io::write |- true => true ]] {
    counter += 1                 // counter captured by reference (mutable)
    let prefix = config.prefix   // config captured by reference (immutable)
    println("{}{}", prefix, input)
}

process("test")  // Both counter and config remain valid
```

**Example 8.4.7.4 - invalid (Capturing moved value):**

```cursive
let data = Buffer::new()
consume(move data)
let closure = || [[ |- true => true ]] {
    data.size()  // error[E08-470]: cannot capture moved-from value
}
```

#### §7.4.8 Scope interaction and temporaries

[38] Structured expressions introduce nested lexical scopes. Bindings declared inside an `if`, `match`, or `loop` block follow the scope rules in Clause 6 §6.2. Temporaries drop at scope exit in reverse order of their creation (Clause 12 §12.2). Developers shall not rely on unspecified destruction order across branches; each branch is analysed separately for move/drop semantics.

#### §7.4.8 Diagnostics summary

| Code    | Condition                                                                  |
| ------- | -------------------------------------------------------------------------- |
| E08-400 | Record literal missing required field                                      |
| E08-401 | Record literal duplicates field                                            |
| E08-402 | Record literal references field not visible in scope                       |
| E08-403 | Single-element tuple literal disallowed                                    |
| E08-404 | Enum variant payload mismatch                                              |
| E08-430 | Array literal elements have mismatched types                               |
| E08-431 | Repeat array requires `Copy` element or comptime length                    |
| E08-440 | `if` expression requires `else` but none provided                          |
| E08-450 | Match result type inference failed (use typed hole or explicit annotation) |
| E07-451 | Match is non-exhaustive                                                    |
| E08-452 | Match arm unreachable                                                      |
| E08-460 | Loop break values disagree                                                 |
| E08-461 | Iterator loop missing element type annotation                              |
| E08-462 | Iterator does not satisfy iteration protocol                               |
| E08-463 | `break`/`continue` used outside loop                                       |

#### §7.4.9 Canonical examples

**Example 8.4.9.1 (Record literal with explicit fields).**

```cursive
let profile = UserProfile {
    id: request.user_id,
    name: request.name.clone(),
    is_admin: request.flags.contains(Flag::Admin),
}
```

**Example 8.4.9.2 (Match with guards and union return type).**

```cursive
let action: Order \/ Error = match command {
    Command::Buy(req) if req.amount > 0 => execute_buy(req),
    Command::Sell(req) => execute_sell(req),
    Command::Cancel(id) => cancel(id),
}
```

**Example 8.4.9.3 (Iterator loop).**

```cursive
loop entry: LogEntry in log_stream.records() {
    if entry.level == Level::Warning {
        warn(entry.message)
    }
}
```

[39] The iterator loop explicitly states the item type, ensuring both the compiler and readers understand the type flowing through the loop.

---


### §7.5 Patterns and Exhaustiveness [expr.pattern]

#### §7.5.1 Overview

[1] Patterns provide structural matching inside expressions, complementing the declaration patterns defined in Clause 5 §5.3. They appear in `if let`, match arms, and destructuring statements embedded within expressions. This subclause adapts the pattern typing judgment for expression contexts, details guard semantics, and specifies exhaustiveness and reachability analyses.

#### §7.5.2 Pattern Typing Judgment

[2] The judgment `Γ ⊢ p : τ ⇝ Δ` means “pattern `p` matches scrutinee type `τ` and extends the environment with bindings `Δ`.” The rules mirror Clause 4 but are restated here for clarity:

- **Wildcard (`_`)**: matches any value, introduces no bindings.
- **Identifier (`name`)**: matches any value, introduces binding `name : τ` with the surrounding mutability/permission qualifiers.
- **Literal (`42`, `'x'`, `true`)**: matches only if the scrutinee equals the literal.
- **Tuple pattern `(p₁,…,pₙ)`**: requires `τ = (τ₁,…,τₙ)`; each component is checked recursively.
- **Record pattern `{ field: p }`**: requires `τ` to be a record containing the listed fields; each field pattern is checked recursively. Omitting a required field is ill-formed (E07-500).
- **Enum pattern `Enum::Variant(p)`**: requires `τ` to be the enum; payload patterns are checked recursively.
- **Union component pattern `name: Type`**: matches values of union types when the discriminant indicates the value is of the specified component type (see §7.5.2.5 for complete specification).
- **Or-pattern (`p₁ | p₂ | …`)**: every branch shall introduce the same identifiers with identical types. Violations emit E07-510 (missing identifier) or E07-511 (type mismatch).
- **Refutable patterns** (enum variant patterns such as `Status::Running`, union component patterns) may only appear where failure is handled (`if let`, match arms).

[3] Pattern bindings inherit mutability/permissions from the pattern prefix (`mut`, `own`, `ref`, etc.). Attempting to bind a name that already exists in scope without `shadow` is ill-formed (Clause 4 diagnostics).

#### §7.5.2.5 Union Type Patterns [expr.pattern.union]

[3.1] Union types (`τ₁ \/ τ₂ \/ ... \/ τₙ`) use type annotation patterns for matching. The syntax `identifier: Type` matches when the union's runtime discriminant indicates the value is of the specified component type.

**Grammar:**

**Type annotation patterns** (for union types) match the pattern:

```
<identifier> ":" <type>
```

[ Note: See Annex A §A.3 [grammar.pattern] for the complete pattern grammar.
— end note ]

**Typing rule:**

[ Given: Union type $\tau_1 \/ \cdots \/ \tau_n$, pattern with type annotation ]

$$
\frac{\Gamma \vdash e : \tau_1 \/ \cdots \/ \tau_n \quad \tau_i \in \{\tau_1, \ldots, \tau_n\}}{\Gamma \vdash (x: \tau_i \Rightarrow \text{body}) \text{ matches component } \tau_i \quad \Gamma, x: \tau_i \vdash \text{body}}
\tag{T-Union-Pattern}
$$

**Exhaustiveness:** Union patterns must cover all component types or include a wildcard catch-all. Missing component types produce diagnostic E07-704 (incomplete union match).

**Example 7.5.2.5 (Union type patterns):**

```cursive
procedure handle_result(value: i32 \/ ParseError)
    [[ |- true => true ]]
{
    match value {
        num: i32 => println("Success: {}", num),
        err: ParseError => println("Error: {}", err.message()),
    }
}
```

[3.2] Type annotation patterns introduce a binding with the matched component type. The binding is available only within the arm body and has the refined type (not the union type).

#### §7.5.3 Guards

[4] A guard (`pattern if expr => body`) is evaluated only after the pattern matches and the bindings described by `Δ` are in scope. Guard expressions shall have type `bool`. Guards may not introduce new bindings or move values out of the pattern unless the pattern itself owns them. If the guard evaluates to `false`, control proceeds to the next arm as if the pattern had not matched.

#### §7.5.4 Exhaustiveness and Reachability

[5] Match expressions over enums, unions, modal states, and `bool` shall be exhaustive. The compiler uses the coverage algorithm defined in Annex E §E.2.5 to ensure every constructor is handled. Missing cases produce diagnostic E07-451 with a machine-readable list of unhandled constructors (variant name, module path, payload arity).

[6] Reachability analysis ensures later arms are not shadowed by earlier arms. If an arm can never match because a prior arm covers the same space, the compiler emits E07-512 so the dead arm can be removed or reordered.

#### §7.5.5 Destructuring Statements inside Expressions

[7] Expression contexts may include destructuring statements (`let pattern = expr;`). They are permitted only as standalone statements or at the top level of block expressions; embedding them mid-expression introduces ambiguity and is forbidden (E07-520).

[8] Typing follows the same judgment `Γ ⊢ p : τ ⇝ Δ`. Bindings in `Δ` enter scope after the statement and remain valid until the surrounding block ends, subject to move semantics.

#### §7.5.6 Diagnostics Summary

| Code    | Condition                                                    |
| ------- | ------------------------------------------------------------ |
| E07-500 | Record pattern omits required field                          |
| E07-510 | Or-pattern branches bind different identifiers               |
| E07-511 | Or-pattern branches bind identifiers with incompatible types |
| E07-512 | Match arm is unreachable                                     |
| E07-520 | Destructuring statement used in disallowed context           |
| E07-704 | Union pattern match missing component type(s)                |

#### §7.5.7 Canonical Example

```cursive
match packet {
    Packet::Data { id, payload } if payload.len() > 0 => process(id, payload),
    Packet::Ack(id) | Packet::Nack(id) => update_status(id),
    Packet::Heartbeat => (),
}
```

[9] The or-pattern ensures both `Ack` and `Nack` arms introduce the same `id` binding with type `u64`. The guard accesses `payload` only after the pattern succeeds, illustrating the evaluation order.

---


### §7.6 Conversions and Coercions [expr.conversion]

#### §7.6.1 Overview

[1] Conversions translate values between compatible types. Cursive differentiates **explicit casts** (`expr as Type`) from the small set of **implicit coercions** performed by the type checker. Annex A §A.4.17 provides the grammar for cast expressions.

#### §7.6.2 Explicit casts (`as`)

[2] Cast expressions use the `as` keyword: `unary_expr as Type`.

[ Note: See Annex A §A.4 [grammar.expression] for the normative `CastExpr` production. — end note ]

[3] Legal cast categories:

1. **Numeric-to-numeric.** Conversions between primitive numeric types (Clause 7 §7.2). Narrowing conversions may truncate; constant expressions that cannot fit emit E07-600.
2. **Pointer casts.** Safe pointers `Ptr<T>@State` may cast to `Ptr<U>@State` when the pointee layouts are proven equivalent (Clause 12). Casting to the unconstrained pointer `Ptr<T>` is always legal (widening). Raw pointer casts (`*const T` ↔ `*mut U`) require grant `unsafe.ptr` and are unchecked at runtime.
3. **Modal widening.** `ModalType@State as ModalType` discards state information. Narrowing (adding a state) is illegal without a witness from a transition procedure and emits E08-601.
4. **Enum discriminants.** Casting an enum value to `usize` yields its discriminant. Casting integers back to enums is forbidden to avoid bypassing exhaustiveness.
5. **Opaque handles.** Implementation-defined opaque types may specify additional cast hooks (e.g., ABI handles). Such casts shall be documented in Clause 16 and require explicit `as`.

[4] Any cast outside these categories is rejected with E08-601. Implementations may provide future extensions only through the specification process; ad-hoc casts are non-conforming.

[5] Evaluation: the operand evaluates first. Numeric casts follow two’s-complement or IEEE rounding rules. Pointer casts are representational; they do not alter permissions or provenance. Enum-to-integer casts read the discriminant without affecting the payload.

#### §7.6.3 Implicit coercions

[6] The type checker performs only the following coercions automatically:

- **Unit insertion:** expressions lacking `result` implicitly yield `()` to match contexts expecting unit.
- **Pointer/modal widening:** `Ptr<T>@State <: Ptr<T>` and `Modal@State <: Modal` (Clause 7 §7.7). This is the only implicit pointer conversion.
- **String state defaulting:** bare `string` resolves to `string@View`; `string@Managed` may coerce to `string@View` when required.
- **Pipeline annotations:** when a pipeline stage omits its annotation under §8.1.3[9], the checker inserts an equality coercion `τ → τ` after proving equivalence.

[7] No numeric promotions occur implicitly; developers must cast explicitly when combining different numeric types. Likewise, there is no implicit conversion between `bool` and integers.

#### §7.6.4 Diagnostics

| Code    | Condition                            |
| ------- | ------------------------------------ |
| E07-600 | Constant cast loses information      |
| E08-601 | Cast not covered by a legal category |

#### §7.6.5 Canonical example

```cursive
let magnitude: f64 = (vector.x as f64).hypot(vector.y as f64)
let bucket: u8 = ((hash as u32) % 256u32) as u8
let ptr: Ptr<u8> = some_slice.as_ptr() as Ptr<u8>
```

[8] The example showcases explicit numeric casts (with narrowing), as well as safe-pointer widening via `as` to document intent.

---


### §7.7 Constant Expressions and Comptime Contexts [expr.constant]

#### §7.7.1 Overview

[1] Constant expressions are those evaluable during the translation phases (§2.2). They appear in `const` bindings, array lengths, enum discriminants, attribute arguments, and `comptime` blocks. This subclause defines the admissible constructs inside const contexts, the grants permitted during compile-time execution, and the diagnostics for violations.

#### §7.7.2 Const contexts

[2] An expression is required to be constant when:

- It belongs to a `const`/`static` binding (§5.2).
- It appears in a position that influences type formation (array length `[T; n]`, repeat literal `[value; n]`, const generic argument).
- It occurs inside `comptime { … }` (§8.7.3) or within a `comptime procedure` body (Clause 10).
- It supplies default values for const generic parameters (Clause 11).

[3] Const expressions may contain:

- Literals and literal operators.
- References to previously defined constants.
- Calls to `comptime procedure`s whose grants are comptime-safe.
- Non-capturing closures whose bodies obey these restrictions.
- Type introspection intrinsics (`type_name`, `type_id`, `type_info`; Clause 7.8) provided their results remain compile-time data.

[4] Disallowed constructs include: runtime IO, heap allocation, raw pointer arithmetic on runtime pointers, accesses to mutable statics, and any call that requires a runtime-only grant. Using such constructs inside const contexts emits E08-700.

#### §7.7.3 Comptime blocks

[5] Grammar: `ComptimeExpr ::= 'comptime' Block` (Annex A §A.4.18).

[6] Semantics:

- The block executes during the compile-time execution phase (§2.2). Its statements follow the same rules as runtime blocks but must obey the const restrictions above.
- The block introduces a new lexical scope; bindings declared inside it do not leak to runtime.
- The `result` expression becomes a literal embedded into the compiled program. If the block omits `result`, its type is `()` and the expression is useless—implementations may warn.

[7] Grants: comptime blocks may only request grants whose names begin with `comptime.` (e.g., `comptime.alloc`, `comptime.codegen`). Attempting to invoke a runtime grant (e.g., `io.write`) emits E08-701 identifying the offending grant.

[8] Error reporting: any panic or error encountered during comptime evaluation is reported at compile time with the original source span plus the enclosing `comptime` block span for context.

#### §7.7.4 Interaction with generics

[9] Const generics (Clause 11) substitute concrete values before const evaluation. Expressions referencing const parameters are therefore treated identically to literal constants once monomorphisation occurs. Type-level intrinsics (e.g., `type_name<T>()`) may appear inside comptime contexts as long as their results are assigned to const bindings or used as compile-time metadata.

#### §7.7.5 Diagnostics

| Code | Condition |
| --- | --- |
| E08-700 | Runtime-only construct used in const/comptime context |
| E08-701 | Comptime block requested non-comptime grant |

#### §7.7.6 Canonical example

````cursive
const POWERS: [u32; 8] = comptime {
    let mut table = [0; 8]
    var i = 0
    loop i < table.len() {
        table[i] = (1u32 << i)
        i += 1
    }
    result table
}
````

[10] The block executes at compile time, constructing an array literal without using any runtime-only grants.

---


### §7.8 Expression Typing Rules and Ill-formed Cases [expr.typing]

#### §7.8.1 Overview

[1] This subclause consolidates the global typing judgment (`Γ ⊢ e : τ ! ε [cat]`) introduced in §8.1, clarifies how it interacts with definite assignment, permissions, and grants, and catalogues common ill-formed expressions together with their diagnostics and required payloads. It also documents the tooling obligations that make expression metadata available to IDEs and analysis tools.

#### §7.8.2 Typing judgment recap

[2] Every expression typing derivation has the form `Γ ⊢ e : τ ! ε [cat]`, where:

- `Γ` stores bindings, region stack, grant budget, and contextual type expectations.
- `τ` is the expression’s type after alias expansion (§7.7).
- `ε` is the cumulative grant set (§8.1.5).
- `[cat] ∈ {value, place, divergent}` is the category (§8.1.4).

[3] The following invariants shall hold simultaneously:

- **Name resolution:** identifiers resolve using Clause 6 §6.4. Names bound to types/modules/contracts cannot appear in expression position (E08-211).
- **Definite assignment:** Clause 5 §5.7 ensures bindings are initialised before use. Violations emit E08-210 at the expression site.
- **Permission safety:** assignments and moves operate only on places with sufficient permission (`mut` or `own`). Violations emit E11-403.
- **Grant coverage:** the enclosing procedure's grants clause (within its contractual sequent) covers ε; missing grants produce E08-004.
- **Type compatibility:** operands satisfy the subtyping/compatibility rules in Clause 7. Failures emit E08-800 with both types and the violated rule.

#### §7.8.3 Ill-formed expression catalogue

[4] Table 8.8.1 lists representative ill-formed constructs. Each diagnostic references Annex E §E.5 for payload requirements.

| ID    | Description                                           | Diagnostic |
| ----- | ----------------------------------------------------- | ---------- |
| IF-01 | Identifier resolves to non-value entity               | E08-211    |
| IF-02 | Type inference failed and no context provided         | E08-002    |
| IF-03 | Place used without required permission                | E11-403    |
| IF-04 | Runtime-only construct used in const/comptime context | E08-700    |
| IF-05 | Match result type inference failed                    | E08-450    |
| IF-06 | Pipeline stage omitted type while changing type       | E08-020    |
| IF-07 | Array/slice index out of range                        | E08-250    |
| IF-08 | Assignment target is not a place                      | E08-340    |
| IF-09 | Match is non-exhaustive                               | E08-451    |
| IF-10 | Cast outside allowed categories                       | E08-601    |

#### §7.8.4 Drop semantics and temporaries

[5] Temporaries created during expression evaluation are destroyed at scope exit in reverse creation order (Clause 12 §12.2). When an expression spans multiple branches (`if`, `match`), each branch is analysed independently for drop order. Developers must not rely on unspecified destruction timing across branches; the specification guarantees only that every temporary drops exactly once.

#### §7.8.5 Tooling integration

[6] Conforming implementations shall expose expression metadata (type, grant set, category, evaluation order index) via the tooling interface in Annex E §E.3. Diagnostics shall embed this metadata in their JSON payloads when it aids remediation—for example, E11-403 specifies the binding name and required permission, while E08-004 includes both required and supplied grant sets.

#### §7.8.6 Example diagnostic payload

```json
{
  "code": "E11-403",
  "message": "assignment requires mutable place",
  "expr_range": "src/lib.rs:42:9-42:22",
  "binding": "total",
  "required_permission": "mut",
  "observed_binding_permission": "let",
  "suggested_fixes": [
    {
      "description": "declare binding as 'var total'",
      "edits": [
        /* implementation-defined */
      ]
    }
  ]
}
```

[7] Annex E §E.5 mandates that every diagnostic payload identify the offending source span, the relevant contextual metadata, and any fix-it hints. This ensures IDEs and automated tooling can present actionable feedback consistent with the deterministic semantics defined in Clause 8.

---


### §8.1 Statement Fundamentals [stmt.fundamental]

#### §8.1.1 Overview

[1] A _statement_ is a syntactic form that executes for its effects on program state and control flow. Unlike expressions (Clause 7), statements do not directly produce values for consumption; instead, they modify bindings, transfer control, or orchestrate execution order. The execution model uses judgment $\langle s, \sigma \rangle \Downarrow \text{outcome}$, where statement $s$ transforms store $\sigma$ and produces a control outcome. Control outcomes classify normal completion, early returns, loop exits, and abnormal termination.

#### §9.1.2 Statement vs Expression Distinction

[4] Cursive distinguishes statements from expressions:

- **Expressions** (Clause 7) produce typed values and use judgment $\Gamma \vdash e : \tau \; ! \varepsilon$.
- **Statements** (this clause) execute for effects and use judgment $\langle s, \sigma \rangle \Downarrow \text{outcome}$.

[5] Control-flow constructs (`if`, `match`, `loop`) are defined as expressions in Clause 7. When used in statement position, their result values are discarded. This clause specifies how statements sequence, how control outcomes propagate, and how statement-specific forms (assignments, `return`, `defer`) integrate with the expression-based control flow.

#### §9.1.3 Grammar Map

[6] Annex A §A.5 provides the authoritative statement grammar. Table 9.1 maps grammar productions to specification subclauses.

**Table 9.1 — Statement grammar organization**

| Annex production | Description | Specified in |
|---|---|---|
| `Statement`, `SimpleStmt` | Statement categories | §9.1.4 |
| `AssignStmt`, `CompoundAssign` | Assignment forms | §9.2.2 |
| `ExprStmt` | Expression as statement | §9.2.3 |
| `DeferStmt` | Deferred cleanup | §9.2.5 |
| `ReturnStmt` | Early function exit | §9.3.1 |
| `BreakStmt`, `ContinueStmt` | Loop control | §9.3.2, §9.3.3 |
| `LabeledStmt`, `Label` | Statement labels | §9.3.4 |
| `StatementSeq` | Statement sequencing | §9.4.1 |

[ Note: See Annex A §A.5 [grammar.statement] for complete statement grammar.
— end note ]

#### §9.1.4 Statement Categories

[7] Statements are classified into three categories for specification organization:

1. **Simple statements** (§9.2): assignments, expression statements, defer, empty statements
2. **Control-flow statements** (§9.3): return, break, continue, labeled statements
3. **Structured statements**: Control-flow expressions from Clause 8 used as statements

[8] This classification is organizational only; all statements participate uniformly in the execution and sequencing model.

#### §9.1.5 Execution Judgment

[9] The execution judgment has form:

$$
\langle s, \sigma \rangle \Downarrow \text{outcome}
$$

where:
- $s$ is the statement to execute
- $\sigma$ is the current program store (memory state)
- $\text{outcome}$ is a control outcome (§9.1.6)

[10] The store $\sigma$ maps memory locations to values. Statement execution may read from the store, modify existing bindings, allocate new locations, or leave the store unchanged.

#### §9.1.6 Control Outcomes

[11] Control outcomes classify how statement execution terminates. The outcome type is defined:

$$
\text{Outcome} ::= \text{Normal}(\sigma') \mid \text{Return}(v, \sigma') \mid \text{Break}(\ell?, v?, \sigma') \mid \text{Continue}(\ell?, \sigma') \mid \text{Panic}
$$

where:
- $\sigma'$ is the updated store
- $v$ is an optional result value
- $\ell$ is an optional label identifier

[12] **Outcome semantics:**

- **Normal**($\sigma'$): Statement completed successfully; execution continues with updated store
- **Return**($v$, $\sigma'$): Function returns immediately with value $v$ (after executing defers)
- **Break**($\ell?$, $v?$, $\sigma'$): Exit labeled construct, optionally with value $v$
- **Continue**($\ell?$, $\sigma'$): Skip to next iteration of labeled loop
- **Panic**: Abnormal termination; implementation may unwind stack or abort

[13] Non-**Normal** outcomes are _control-transfer outcomes_. They bypass remaining statements in a sequence and propagate outward to their target construct.

#### §9.1.7 Outcome Propagation

[14] Control outcomes propagate through statement sequences according to the following rules:

[ Given: Statements $s_1, s_2$ and store $\sigma$ ]

$$
\frac{\langle s_1, \sigma \rangle \Downarrow \text{Normal}(\sigma') \quad \langle s_2, \sigma' \rangle \Downarrow \text{outcome}}{\langle s_1; s_2, \sigma \rangle \Downarrow \text{outcome}}
\tag{E-Seq-Normal}
$$

[15] When $s_1$ produces a Normal outcome, execution continues with $s_2$ using the updated store.

[ Given: Statement $s_1$ producing control-transfer outcome ]

$$
\frac{\langle s_1, \sigma \rangle \Downarrow \text{outcome} \quad \text{outcome} \in \{\text{Return}, \text{Break}, \text{Continue}, \text{Panic}\}}{\langle s_1; s_2, \sigma \rangle \Downarrow \text{outcome}}
\tag{E-Seq-Transfer}
$$

[16] Control-transfer outcomes bypass remaining statements in the sequence. Statement $s_2$ is not executed.

#### §9.1.8 Well-Formedness Judgment

[17] Statement well-formedness uses judgment $\Gamma \vdash s \; \text{ok}$, where $\Gamma$ is the typing environment. Well-formed statements satisfy:

- Type constraints for subexpressions
- Permission requirements for assignments
- Definite assignment for variable uses
- Label resolution for break/continue
- Grant availability for operation execution

[18] Ill-formed statements produce compile-time diagnostics as specified in the relevant subclauses.

#### §9.1.9 Integration with Expressions

[19] Statements integrate with Clause 7 expressions in three ways:

(19.1) **Expression statements**: Any expression may be used as a statement; its value is discarded (§9.2.3).

(19.2) **Control-flow expressions**: Constructs like `if`, `match`, `loop` (Clause 7 §7.4) may be used as statements. Their execution follows Clause 7 semantics; when used as statements, result values are discarded.

(19.3) **Subexpressions**: Statements contain expressions (initializers, conditions, operands). Expression evaluation follows Clause 7 rules; statement execution sequences those evaluations.

#### §9.1.10 Statement Termination

[20] Statement termination follows the rules in §2.4 [lex.terminators]:

- Newlines terminate statements unless a continuation rule applies
- Semicolons may separate multiple statements on one line
- Four continuation cases: unclosed delimiters, trailing operators, leading dot, leading pipeline

[21] These rules apply uniformly to all statement forms. Statement-specific syntax does not alter termination behavior.

#### §8.1.11 Conformance Requirements

[22] Implementations shall execute defer blocks in LIFO order on all control-flow exits and provide structured control flow only (no goto).


### §8.2 Simple Statements [stmt.simple]

#### §8.2.1 Overview

[1] Simple statements perform basic operations without introducing complex control flow. They include variable declarations, assignments, expression evaluation for side effects, explicit empty statements, and defer registration for cleanup.

[2] This subclause specifies execution semantics for these forms. Syntactic details for variable declarations reside in Clause 5 §5.2; this subclause defines only their execution behavior as statements.

#### §8.2.2 Variable Declaration Statements [stmt.simple.vardecl]

##### §8.2.2.1 Syntax

[3] Variable declaration statements follow the grammar in §5.2 [decl.variable]. The forms are:

```ebnf
variable_declaration_stmt
    ::= binding_head pattern type_annotation? binding_operator initializer
```

[ Note: See Annex A §A.5 [grammar.statement] and §A.7 [grammar.declaration] for complete grammar.
— end note ]

[4] Variable declarations are statements (not expressions). They introduce bindings into the current scope and participate in definite assignment analysis (§5.7).

##### §8.2.2.2 Constraints

[5] All constraints from §5.2 apply: explicit shadowing requirements, single-assignment for `let`, type annotation requirements for multi-identifier patterns, and initializer completeness.

##### §8.2.2.3 Semantics

[6] Execution of a variable declaration statement:

[ Given: Binding $x$, initializer expression $e$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle \texttt{let } x = e, \sigma \rangle \Downarrow \text{Normal}(\sigma'[x \mapsto v])}
\tag{E-Let}
$$

[7] The initializer expression evaluates to a value, which is bound to the identifier. The store is extended with the new binding. Execution continues normally.

[8] For `var` bindings, the semantics are identical except the binding is marked mutable, permitting subsequent reassignment (§9.2.3).

##### §8.2.2.4 Examples

**Example 9.2.2.1 (Variable declarations as statements):**

```cursive
procedure compute(input: i32): i32
    [[ |- true => true ]]
{
    let doubled = input * 2      // Immutable binding statement
    var accumulator = 0          // Mutable binding statement
    accumulator = doubled + 10   // Assignment (next subsection)
    result accumulator
}
```

#### §8.2.3 Assignment Statements [stmt.simple.assign]

##### §8.2.3.1 Overview

[9] Assignment statements modify the value stored at a place expression. They require the target to be a mutable location and the source expression to produce a compatible type.

##### §8.2.3.2 Syntax

[10] Assignment syntax follows:

```ebnf
assignment_stmt
    ::= place_expr "=" expression
     | place_expr "<-" expression
     | place_expr compound_op expression

compound_op
    ::= "+=" | "-=" | "*=" | "/=" | "%="
     | "&=" | "|=" | "^=" | "<<=" | ">>="
```

[ Note: See Annex A §A.5 [grammar.statement] for complete assignment grammar.
— end note ]

[11] The left operand must be a place expression (§8.1.4): a variable, field access, tuple projection, array index, or pointer dereference.

##### §8.2.3.3 Constraints

[12] **Mutability requirement.** The place expression shall refer to a `var` binding or a field of a structure accessed through a mutable permission. Assigning to `let` bindings produces diagnostic E08-101.

[13] **Type compatibility.** The right-hand expression type shall be compatible with the place type. Mismatches produce diagnostic E08-102 (type mismatch in assignment).

[14] **Permission requirement.** The place expression shall have permission allowing writes. Permission violations produce diagnostics specified in Clause 9.

[15] **Binding operator restriction.** Value assignment (`=`) may only assign to bindings originally created with `=` (responsible bindings). Reference assignment (`<-`) may only assign to bindings originally created with `<-` (non-responsible bindings). Mixing assignment operators produces diagnostic E08-103 (assignment operator mismatch).

##### §8.2.3.4 Semantics

[16] **Value assignment (`=`):**

[ Given: Place expression $p$, value expression $e$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle \quad p \mapsto \ell \text{ in } \sigma'}{\langle p = e, \sigma \rangle \Downarrow \text{Normal}(\sigma'[\ell \mapsto v])}
\tag{E-Assign-Value}
$$

[17] The right-hand expression evaluates first, then the place resolves to a location, then the value is stored. For responsible `var` bindings, the old value's destructor is invoked before the new value is stored.

[18] **Reference assignment (`<-`):**

[ Given: Non-responsible `var` binding $x$, value expression $e$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle \quad x \text{ is non-responsible}}{\langle x \texttt{ <- } e, \sigma \rangle \Downarrow \text{Normal}(\sigma'[x \mapsto v])}
\tag{E-Assign-Reference}
$$

[19] Reference assignment updates a non-responsible binding to refer to a different value. No destructor is invoked because the binding has no cleanup responsibility. The binding simply updates its reference to the new value.

[20] **Compound assignment:**

[ Given: Place $p$, operator $\oplus$, expression $e$ ]

$$
\frac{p \mapsto \ell \quad \sigma(\ell) = v_{\text{old}} \quad \langle e, \sigma \rangle \Downarrow \langle v_{\text{rhs}}, \sigma' \rangle \quad v_{\text{result}} = v_{\text{old}} \oplus v_{\text{rhs}}}{\langle p \oplus\!= e, \sigma \rangle \Downarrow \text{Normal}(\sigma'[\ell \mapsto v_{\text{result}}])}
\tag{E-Assign-Compound}
$$

[18] Compound assignment reads the current value, evaluates the right-hand expression, applies the operator, and stores the result. The place is evaluated once, preserving side-effect ordering.

##### §8.2.3.5 Examples

**Example 9.2.3.1 (Assignment statements):**

```cursive
var counter: i32 = 0
counter = 10                    // Simple assignment
counter += 5                    // Compound assignment: counter = counter + 5

var point = Point { x: 0.0, y: 0.0 }
point.x = 3.14                  // Field assignment
```

**Example 9.2.3.2 (Reference assignment to var):**

```cursive
var ref <- buffer1                     // Non-responsible binding
ref <- buffer2                         // Update reference (no cleanup)
ref <- buffer3                         // Update again (no cleanup)
```

**Example 9.2.3.3 - invalid (Assignment to immutable binding):**

```cursive
let constant = 42
constant = 100                  // error[E08-101]: cannot assign to immutable binding
```

**Example 9.2.3.4 - invalid (Assignment operator mismatch):**

```cursive
var data = Buffer::new()        // Responsible binding (created with =)
data <- other_buffer            // error[E08-103]: cannot use <- on responsible binding

var ref <- buffer               // Non-responsible binding (created with <-)
ref = other_buffer              // error[E08-103]: cannot use = on non-responsible binding
```

#### §8.2.4 Expression Statements [stmt.simple.expr]

##### §8.2.4.1 Overview

[19] Expression statements evaluate expressions solely for their side effects, discarding any produced value.

##### §8.2.4.2 Syntax

[20] Any expression from Clause 8 may be used as a statement:

```ebnf
expr_stmt
    ::= expression
```

[21] Expression statements are distinguished from expression-producing blocks by context: standalone expressions at statement position are expression statements.

##### §8.2.4.3 Constraints

[22] The expression shall be well-formed per Clause 8. No additional constraints apply.

##### §8.2.4.4 Semantics

[23] Expression statement execution:

[ Given: Expression $e$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle e, \sigma \rangle \Downarrow \text{Normal}(\sigma')}
\tag{E-Expr-Stmt}
$$

[24] The expression evaluates and its value is discarded. Only side effects (store modifications, I/O) persist.

##### §8.2.4.5 Examples

**Example 9.2.4.1 (Expression statements for side effects):**

```cursive
procedure demo(data: Buffer)
    [[ io::write |- true => true ]]
{
    println("Processing data")   // Expression statement: procedure call
    data.clear()                  // Expression statement: method call
    compute_checksum(data)        // Value discarded (if non-unit type, may warn)
}
```

#### §8.2.5 Empty Statements [stmt.simple.empty]

##### §8.2.5.1 Overview

[25] Empty statements consist of a standalone semicolon or empty lines. They have no effect and serve as placeholders or formatting aids.

##### §8.2.5.2 Syntax

```ebnf
empty_stmt
    ::= ";"
```

##### §8.2.5.3 Semantics

[26] Empty statement execution:

$$
\frac{}{\langle ; , \sigma \rangle \Downarrow \text{Normal}(\sigma)}
\tag{E-Empty}
$$

[27] The store is unchanged; execution continues normally.

#### §8.2.6 Defer Statements [stmt.simple.defer]

##### §8.2.6.1 Overview

[28] Defer statements register blocks for execution at scope exit. Deferred blocks execute in LIFO (last-in, first-out) order, ensuring cleanup occurs on all control-flow paths including normal returns, early returns, breaks, and panics.

##### §8.2.6.2 Syntax

```ebnf
defer_stmt
    ::= "defer" block
```

[ Note: See Annex A §A.5 [grammar.statement] for complete defer grammar.
— end note ]

[29] The deferred block shall be a block statement with unit type. Value-producing blocks are ill-formed in defer context (diagnostic E08-120).

##### §8.2.6.3 Constraints

[30] **Unit type requirement.** The deferred block shall have type `()`. Blocks producing values trigger diagnostic E08-120.

[31] **No control transfer in defers.** Defer blocks shall not contain `return`, `break`, or `continue` statements referencing outer scopes. Violations produce diagnostic E08-121.

(31.1) Defer blocks may contain their own internal control flow (loops, conditional branches) provided control remains within the defer block.

##### §8.2.6.4 Semantics

[32] **Defer registration:**

[ Given: Defer block $b$, store $\sigma$ ]

$$
\frac{}{\langle \texttt{defer } b, \sigma \rangle \Downarrow \text{Normal}(\sigma)}
\tag{E-Defer-Register}
$$

[33] Executing a defer statement does not execute the block immediately. The block is registered in the current scope's defer queue for later execution.

[34] **Defer execution at scope exit:**

When a scope exits (block end, function return, break out of block), deferred blocks execute in reverse registration order:

[ Given: Defer queue $[d_1, \ldots, d_n]$ in registration order ]

$$
\frac{\langle d_n, \sigma \rangle \Downarrow \text{Normal}(\sigma_n) \quad \cdots \quad \langle d_1, \sigma_1 \rangle \Downarrow \text{Normal}(\sigma_{\text{final}})}{\text{execute defers} \Rightarrow \sigma_{\text{final}}}
\tag{E-Defer-Execute}
$$

[35] Defers execute after the triggering event (return value computed, break value computed) but before control transfers or the scope ends.

##### §8.2.6.5 Defer on Panic

[36] When a panic occurs, defer blocks execute during stack unwinding. If unwinding is disabled (implementation-defined), defers may not execute. Defer behavior during panic is specified in Clause 11 §11.2.5.5 [memory.object.destructor.panic].

##### §8.2.6.6 Examples

**Example 9.2.6.1 (Defer LIFO execution):**

```cursive
procedure demo()
    [[ io::write |- true => true ]]
{
    defer { println("First defer") }
    defer { println("Second defer") }
    defer { println("Third defer") }
    println("Body")
}
// Output order: Body, Third defer, Second defer, First defer
```

**Example 9.2.6.2 (Defer with early return):**

```cursive
procedure process_file(path: string@View): i32 \/ FileError
    [[ fs::open, fs::read |- path.len() > 0 => true ]]
{
    let file = open_file(path)
    defer { close_file(file) }   // Executes on BOTH return paths

    if file.is_empty() {
        result FileError::Empty  // defer executes before return
    }

    result read_size(file)       // defer executes before normal return
}
```

**Example 9.2.6.3 - invalid (Defer with value-producing block):**

```cursive
defer { result 42 }             // error[E08-120]: defer block must have unit type
```

#### §8.2.7 Diagnostics

[37] Diagnostics defined in this subclause:

| Code    | Condition                                                  |
| ------- | ---------------------------------------------------------- |
| E08-101 | Assignment to immutable (`let`) binding                    |
| E08-102 | Type mismatch in assignment                                |
| E08-120 | Defer block produces non-unit value                        |
| E08-121 | Defer block contains control transfer escaping defer scope |

#### §8.2.8 Conformance Requirements

[38] Implementations shall:

1. Execute variable declarations per §5.2, extending the environment and store
2. Enforce mutability and type constraints for assignments, emitting E08-101 and E08-102
3. Support compound assignment operators with single place evaluation
4. Discard values from expression statements, preserving only side effects
5. Support empty statements with no runtime cost
6. Register defer blocks for LIFO execution on all scope exits
7. Enforce unit-type and control-transfer constraints on defer blocks


### §8.3 Control Flow Statements [stmt.control]

#### §9.3.1 Conditional Statements [stmt.control.conditional]

##### §9.3.1.1 Overview

[1] Conditional statements execute code selectively based on boolean conditions or pattern matching. They include `if` expressions, `if let` expressions, and `match` expressions when used in statement position.

[2] Conditional expressions are specified in Clause 7 §7.4 [expr.structured]. This subsection specifies their behavior when used as statements: result values are discarded, and execution continues sequentially.

##### §9.3.1.2 Syntax Reference

[3] Conditional statement forms reference Clause 7 §7.4:

- **If expressions** (§8.4.4): `if condition block else? block`
- **If-let expressions** (§8.4.4): `if let pattern = expr block else? block`
- **Match expressions** (§8.4.5): `match expr { arms }`

[ Note: Complete syntax and typing rules are in Clause 7 §7.4 [expr.structured]. This subsection specifies statement-specific execution semantics.
— end note ]

##### §9.3.1.3 Constraints

[4] When conditional expressions are used as statements, they shall be well-formed per Clause 7 §7.4. No additional statement-specific constraints apply.

[5] Result values from conditional statements are discarded. Implementations may warn when conditional expressions producing non-unit values are used as statements (quality-of-implementation feature).

##### §9.3.1.4 Semantics

[6] **Conditional statement execution:**

When a conditional expression is used as a statement, its value is evaluated per Clause 7 and then discarded:

[ Given: Conditional expression $e_{\text{cond}}$ with type $\tau$, store $\sigma$ ]

$$
\frac{\langle e_{\text{cond}}, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle e_{\text{cond}}, \sigma \rangle \Downarrow \text{Normal}(\sigma')}
\tag{E-Conditional-Stmt}
$$

[7] Side effects from condition evaluation and executed branches persist in the store. The result value $v$ is discarded.

##### §9.3.1.5 Examples

**Example 9.3.1.1 (If statement for side effects):**

```cursive
procedure update_status(should_update: bool, status: unique Status)
    [[ |- true => true ]]
{
    if should_update {
        status.mark_completed()    // Executed if condition is true
    }
    // Result value (unit) discarded; continues to next statement
}
```

**Example 9.3.1.2 (Match statement with multiple branches):**

```cursive
procedure handle_event(event: Event)
    [[ io::write |- true => true ]]
{
    match event {
        Event::KeyPress(key) => println("Key: {}", key),
        Event::MouseClick(x, y) => println("Click at ({}, {})", x, y),
        Event::Quit => println("Quit event"),
    }
    // Match result value discarded; execution continues
}
```

#### §9.3.2 Loop Statements [stmt.control.loop]

##### §9.3.2.1 Overview

[8] Loop statements execute code repeatedly based on conditions or iteration protocols. They include infinite loops, conditional loops, and iterator loops.

[9] Loop expressions are specified in Clause 7 §7.4.6 [expr.structured]. This subsection specifies their behavior when used as statements.

##### §9.3.2.2 Syntax Reference

[10] Loop statement forms reference Clause 7 §7.4.6:

- **Infinite loop**: `loop block`
- **Conditional loop**: `loop condition block`
- **Iterator loop**: `loop pattern: Type in expr block`

[ Note: Complete syntax and typing rules are in Clause 7 §7.4.6 [expr.structured]. This subsection specifies statement-specific execution semantics.
— end note ]

##### §9.3.2.3 Constraints

[11] When loop expressions are used as statements, they shall be well-formed per Clause 7 §7.4.6.

[12] Infinite loops without `break` have type `!` (never). When used as statements, they do not complete normally. Execution never continues past an infinite loop.

[13] Loops with `break` statements or finite iterations have type determined by break values (if valued) or `()` (if unvalued). When used as statements, these types are discarded.

##### §9.3.2.4 Semantics

[14] **Loop statement execution:**

Loops execute per Clause 7 §7.4.6 semantics. When used as statements, result values are discarded:

[ Given: Loop expression $e_{\text{loop}}$, store $\sigma$ ]

$$
\frac{\langle e_{\text{loop}}, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle e_{\text{loop}}, \sigma \rangle \Downarrow \text{Normal}(\sigma')}
\tag{E-Loop-Stmt}
$$

[15] For infinite loops without breaks:

$$
\frac{\langle \texttt{loop } \{ \ldots \}, \sigma \rangle \Downarrow \bot}{\langle \texttt{loop } \{ \ldots \}, \sigma \rangle \Downarrow \text{Panic} \text{ or divergence}}
\tag{E-Loop-Infinite}
$$

[16] Infinite loops either diverge (server loops) or exit via panic/explicit termination. They never produce Normal outcomes.

##### §9.3.2.5 Examples

**Example 9.3.2.1 (Loop statement for iteration):**

```cursive
procedure process_items(items: [Item])
    [[ io::write |- items.len() > 0 => true ]]
{
    loop item: Item in items {
        println("Processing: {}", item.name)
        transform(item)
    }
    // Loop completes; result (unit) discarded; continues
}
```

**Example 9.3.2.2 (Conditional loop statement):**

```cursive
procedure retry_until_success()
    [[ net::send |- true => true ]]
{
    var attempts = 0
    loop attempts < 10 {
        if try_connect() {
            break  // Exit loop
        }
        attempts += 1
    }
    // Loop exits normally with () type
}
```

**Example 9.3.2.3 (Infinite loop - never returns):**

```cursive
procedure server()
    [[ net::accept, io::write |- true => false ]]  // will: false (never returns)
{
    loop {
        let connection = accept_connection()
        handle_request(connection)
    }
    // Unreachable: loop never exits
}
```

#### §9.3.3 Return Statements [stmt.control.return]

##### §9.3.3.1 Overview

[17] Return statements exit the enclosing procedure immediately, optionally producing a return value. They have type `!` (never) because execution does not continue past a return.

##### §9.3.3.2 Syntax

[18] Return statement syntax:

```ebnf
return_stmt
    ::= "return" expression?
```

[ Note: See Annex A §A.5 [grammar.statement] for complete return grammar.
— end note ]

[19] The expression is optional. When omitted, the return value is `()` (unit).

##### §9.3.3.3 Constraints

[20] **Context requirement.** Return statements shall appear only within procedure bodies. Return at module scope or in `comptime` blocks produces diagnostic E08-201 (return outside procedure).

[21] **Type compatibility.** When a return value is provided, its type shall match the procedure's declared return type. Type mismatches produce diagnostic E08-202.

[22] **Definite return.** Procedures with non-unit return types shall ensure all control-flow paths produce a return value. Missing returns on some paths trigger diagnostic E08-203 (missing return value).

##### §9.3.3.4 Semantics

[23] Return execution:

[ Given: Expression $e$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle \texttt{return } e, \sigma \rangle \Downarrow \text{Return}(v, \sigma')}
\tag{E-Return}
$$

[24] For unit returns:

$$
\frac{}{\langle \texttt{return}, \sigma \rangle \Downarrow \text{Return}((), \sigma)}
\tag{E-Return-Unit}
$$

[25] Return outcomes propagate through statement sequences and trigger defer execution (§9.2.6) before the procedure exits.

##### §9.3.3.5 Examples

**Example 9.3.3.1 (Early return):**

```cursive
procedure validate(value: i32): i32 \/ ValidationError
    [[ |- value >= 0 => true ]]
{
    if value < 0 {
        result ValidationError::Negative  // Early return with error
    }
    if value > 1000 {
        result ValidationError::TooLarge  // Another early return
    }
    result value  // Normal path
}
```

**Example 9.3.3.2 (Return with defer):**

```cursive
procedure process(): i32
    [[ alloc::heap |- true => true ]]
{
    let resource = acquire_resource()
    defer { release_resource(resource) }

    if should_abort() {
        return -1  // defer executes before return
    }

    result compute(resource)  // defer executes here too
}
```

#### §9.3.4 Break Statements [stmt.control.break]

##### §9.3.4.1 Overview

[26] Break statements exit loops or labeled blocks, optionally producing a value. They enable structured early exit without goto.

##### §9.3.4.2 Syntax

[27] Break statement forms:

```ebnf
break_stmt
    ::= "break" label? expression?

label
    ::= "'" identifier
```

[ Note: See Annex A §A.5 [grammar.statement] for complete break grammar.
— end note ]

[28] Four syntactic forms exist:

- `break` — Exit innermost loop
- `break value` — Exit innermost loop with value
- `break 'label` — Exit labeled construct
- `break 'label value` — Exit labeled construct with value

##### §9.3.4.3 Constraints

[29] **Context requirement.** Break shall appear within a loop or labeled block. Break outside these contexts produces diagnostic E08-211 (break outside loop or block).

[30] **Label resolution.** When a label is specified, it shall refer to a label declared in an enclosing scope within the same procedure. Undefined labels produce diagnostic E08-212.

[31] **Type unification.** When a loop or labeled block contains multiple `break` statements with values, all values shall have the same type or a common supertype. Type mismatches produce diagnostic E08-213.

(31.1) A loop or block with at least one valued `break` has result type equal to the unified break value type. Loops with no valued breaks have type `!` (never) if infinite, or `()` if conditional.

##### §9.3.4.4 Semantics

[32] Break execution:

[ Given: Optional label $\ell$, optional value $v$, store $\sigma$ ]

$$
\frac{\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle}{\langle \texttt{break } \ell \; e, \sigma \rangle \Downarrow \text{Break}(\ell, v, \sigma')}
\tag{E-Break-Value}
$$

[33] For breaks without values:

$$
\frac{}{\langle \texttt{break } \ell, \sigma \rangle \Downarrow \text{Break}(\ell, (), \sigma)}
\tag{E-Break}
$$

[34] Break outcomes propagate outward until reaching the target construct (labeled block/loop or innermost loop if unlabeled).

##### §9.3.4.5 Examples

**Example 9.3.4.1 (Break with label and value):**

```cursive
let result: i32 = 'search: {
    loop i in 0..100 {
        if found(i) {
            break 'search i  // Exit labeled block with value
        }
    }
    result -1  // Not found
}
```

**Example 9.3.4.2 (Multi-level break):**

```cursive
'outer: loop {
    'inner: loop {
        if should_exit_all {
            break 'outer     // Exit both loops
        }
        if should_exit_inner {
            break            // Exit inner loop only
        }
    }
}
```

#### §9.3.5 Continue Statements [stmt.control.continue]

##### §9.3.5.1 Overview

[35] Continue statements skip to the next iteration of a loop, bypassing remaining statements in the current iteration.

##### §9.3.5.2 Syntax

```ebnf
continue_stmt
    ::= "continue" label?
```

[36] Two forms: `continue` (innermost loop) and `continue 'label` (specific loop).

##### §9.3.5.3 Constraints

[37] **Loop context requirement.** Continue shall appear only within loop expressions. Continue outside loops produces diagnostic E08-221.

[38] **Label targets loops.** When labeled, continue shall target a label attached to a loop. Continue targeting a non-loop labeled block produces diagnostic E08-222.

##### §9.3.5.4 Semantics

[39] Continue execution:

[ Given: Optional label $\ell$, store $\sigma$ ]

$$
\frac{}{\langle \texttt{continue } \ell, \sigma \rangle \Downarrow \text{Continue}(\ell, \sigma)}
\tag{E-Continue}
$$

[40] Continue outcomes propagate outward until reaching the target loop, where the next iteration begins.

##### §9.3.5.5 Examples

**Example 9.3.5.1 (Continue in loop):**

```cursive
loop i in 0..10 {
    if i % 2 == 0 {
        continue  // Skip even numbers
    }
    println("{}", i)  // Prints only odd numbers
}
```

**Example 9.3.5.2 (Labeled continue):**

```cursive
'outer: loop row in rows {
    'inner: loop col in row {
        if skip_condition(col) {
            continue 'inner  // Next column
        }
        if row_done_condition(col) {
            continue 'outer  // Next row
        }
        process(col)
    }
}
```

#### §9.3.6 Labeled Statements [stmt.control.labeled]

##### §9.3.6.1 Overview

[41] Labeled statements attach identifiers to loops and blocks, enabling multi-level control transfer via `break 'label` and `continue 'label`.

##### §9.3.6.2 Syntax

[42] Label syntax:

```ebnf
labeled_stmt
    ::= label ":" statement

label
    ::= "'" identifier
```

[ Note: See Annex A §A.5 [grammar.statement] for complete label grammar.
— end note ]

[43] Labels use a leading apostrophe `'` to distinguish them from regular identifiers.

##### §9.3.6.3 Constraints

[44] **Unique labels.** Labels shall be unique within a procedure body. Duplicate labels produce diagnostic E09-231.

[45] **Procedure scope.** Labels have procedure-wide scope (§6.2): they are visible throughout the procedure regardless of nesting. Labels do not escape procedures.

[46] **Attachable constructs.** Labels may attach to:

- Loop expressions (Clause 7 §7.4.6)
- Block statements
- Conditional statements (if, match)

Labels shall not attach to simple statements (assignments, expression statements, variable declarations) or other labeled statements directly.

##### §9.3.6.4 Semantics

[47] Labels do not affect execution directly. They serve as targets for `break` and `continue`:

[ Given: Label $\ell$, statement $s$, store $\sigma$ ]

$$
\frac{\langle s, \sigma \rangle \Downarrow \text{outcome}}{\langle \ell: s, \sigma \rangle \Downarrow \text{outcome}}
\tag{E-Label}
$$

[48] The labeled statement executes identically to the unlabeled form. Labels enable break/continue to reference the construct.

##### §9.3.6.5 Examples

**Example 9.3.6.1 (Label on loop):**

```cursive
'retry: loop {
    if attempt_operation() {
        break 'retry  // Success, exit
    }
    if too_many_attempts() {
        break 'retry  // Give up
    }
    wait_and_retry()
}
```

**Example 9.3.6.2 (Label on conditional for early exit):**

```cursive
'validate: if complex_check(data) {
    if !subcheck_a(data) {
        break 'validate  // Exit the if statement early
    }
    if !subcheck_b(data) {
        break 'validate
    }
    perform_action(data)
}
```

#### §9.3.7 Typed Early-Exit Blocks [stmt.control.earlyexit]

##### §9.3.7.1 Overview

[49] Labeled blocks combined with valued `break` statements enable typed early-exit patterns without goto. The block's type is determined by the break values and result expression.

##### §9.3.7.2 Syntax

[50] Typed early-exit uses labeled blocks with valued breaks:

```cursive
'label: block_expr
// Inside block:
break 'label value
```

[51] The block type is the unified type of all `break 'label value` expressions and the block's `result` expression (if any).

##### §9.3.7.3 Constraints

[52] **Type unification.** All valued breaks targeting the same label shall produce values of compatible types. The block's type is the join of all break value types and the result expression type.

[53] **Consistent usage.** A labeled block should use either all valued breaks or all unit breaks. Mixing valued and unit breaks may produce type inference ambiguity (diagnostic E08-213).

##### §9.3.7.4 Semantics

[54] Break capture at labeled block:

[ Given: Labeled block with break outcomes ]

$$
\frac{\langle b, \sigma \rangle \Downarrow \text{Break}(\ell, v, \sigma') \quad \text{block has label } \ell}{\langle \ell: b, \sigma \rangle \Downarrow \text{Normal}(\sigma') \text{ with result } v}
\tag{E-Block-Capture-Break}
$$

[55] When a break targets the labeled block, the block completes normally with the break value as its result.

##### §9.3.7.5 Examples

**Example 9.3.7.1 (Typed early-exit for validation):**

```cursive
let parsed: Data \/ ParseError = 'parse: {
    let header = read_header(input)
    if header.is_invalid() {
        break 'parse ParseError::InvalidHeader
    }

    let body = read_body(input)
    if body.is_invalid() {
        break 'parse ParseError::InvalidBody
    }

    result Data { header, body }
}
// Type: Data \/ ParseError (unified from breaks and result)
```

**Example 9.3.7.2 (Multi-exit error handling):**

```cursive
let outcome: i32 \/ Error = 'validate: {
    if !check_precondition() {
        break 'validate Error::PreconditionFailed
    }
    if !allocate_resources() {
        break 'validate Error::AllocationFailed
    }
    result perform_computation()  // Returns i32
}
// All exits (breaks and result) unify to i32 \/ Error
```

#### §9.3.8 No Goto Rationale

[56] Cursive intentionally omits unstructured `goto` statements. The combination of:

- Conditional statements (if, match)
- Loop statements (loop, conditional loop, iterator loop)
- Labeled blocks with typed early-exit
- Multi-level break and continue
- Structured expressions (Clause 7)

provides equivalent expressiveness while maintaining:

- Local reasoning (control flow is lexically scoped)
- Verifiable properties (definite assignment, region escape analysis)
- LLM-friendly patterns (structured forms are predictable)
- Zero abstraction cost (labeled break compiles to direct jumps)

[57] Programs requiring goto-like control flow shall use labeled blocks with `break 'label value` for early exit or restructure using the provided control primitives.

#### §9.3.9 Diagnostics

[58] Diagnostics defined in this subclause:

| Code    | Condition                                     |
| ------- | --------------------------------------------- |
| E08-201 | Return statement outside procedure body       |
| E08-202 | Return value type mismatch                    |
| E08-203 | Missing return value on control-flow path     |
| E08-211 | Break statement outside loop or labeled block |
| E08-212 | Break/continue references undefined label     |
| E08-213 | Break values have incompatible types          |
| E08-221 | Continue statement outside loop               |
| E08-222 | Continue targets non-loop label               |
| E09-231 | Duplicate label in procedure                  |

#### §9.3.10 Conformance Requirements

[59] Implementations shall:

1. Support conditional expressions (if, if let, match) as statements per Clause 7 §7.4
2. Support loop expressions (infinite, conditional, iterator) as statements per Clause 7 §7.4.6
3. Discard result values when control-flow expressions are used as statements
4. Support return statements with type checking against procedure return types
5. Execute return statements by producing Return outcomes with defer execution
6. Support break statements with optional labels and values
7. Unify break value types and determine loop/block result types
8. Support continue statements with optional labels
9. Enforce that continue targets only loops (not blocks or conditionals)
10. Implement label resolution with procedure-wide scope per Clause 6
11. Reject duplicate labels within procedures (E09-231)
12. Provide structured control flow only (no goto)
13. Support typed early-exit via labeled blocks with valued breaks


### §8.4 Evaluation Order, Sequencing, Short-Circuit, and Divergence [stmt.order]

#### §9.4.1 Statement Sequencing [stmt.order.sequencing]

##### §9.4.1.1 Overview

[1] Statement sequencing defines the order in which statements execute and how control outcomes propagate through sequences. Cursive guarantees deterministic, left-to-right execution.

##### §9.4.1.2 Sequential Execution

[2] Statements in a sequence execute in textual order:

[ Given: Statement sequence $s_1; s_2; \ldots; s_n$ ]

$$
\frac{\langle s_1, \sigma \rangle \Downarrow \text{Normal}(\sigma_1) \quad \langle s_2, \sigma_1 \rangle \Downarrow \text{Normal}(\sigma_2) \quad \cdots \quad \langle s_n, \sigma_{n-1} \rangle \Downarrow \text{Normal}(\sigma_n)}{\langle s_1; s_2; \ldots; s_n, \sigma \rangle \Downarrow \text{Normal}(\sigma_n)}
\tag{E-Seq-All}
$$

[3] Each statement receives the store produced by its predecessor. Side effects from earlier statements are visible to later statements.

##### §9.4.1.3 Early Termination

[4] Control-transfer outcomes bypass remaining statements:

[ Given: Statement $s_i$ producing control-transfer outcome ]

$$
\frac{\langle s_1, \sigma \rangle \Downarrow \text{Normal}(\sigma_1) \quad \cdots \quad \langle s_i, \sigma_{i-1} \rangle \Downarrow \text{outcome} \quad \text{outcome} \ne \text{Normal}}{\langle s_1; \ldots; s_n, \sigma \rangle \Downarrow \text{outcome}}
\tag{E-Seq-Early}
$$

[5] Statements $s_{i+1}$ through $s_n$ are not executed. The control outcome propagates to the enclosing construct.

##### §9.4.1.4 Examples

**Example 9.4.1.1 (Statement sequencing with early exit):**

```cursive
procedure process(data: [i32]): i32
    [[ |- data.len() > 0 => true ]]
{
    let first = data[0]          // Statement 1
    var accumulator = first      // Statement 2
    
    if first < 0 {
        return -1                // Early return: remaining statements skipped
    }
    
    accumulator += 10            // Statement 3 (not executed if first < 0)
    result accumulator           // Statement 4
}
```

#### §9.4.2 Deterministic Execution Order [stmt.order.determinism]

##### §9.4.2.1 Determinism Guarantee

[6] Statement execution order is deterministic and strictly sequential. Unlike some languages with unspecified evaluation order, Cursive guarantees that:

(6.1) Statements execute in the order written in source code.

(6.2) For a given statement, all subexpressions evaluate in the order specified by Clause 8 §8.1.3.

(6.3) Side effects from earlier statements are observable by later statements.

(6.4) No statement reordering, speculation, or parallel execution alters observable behavior.

[7] This determinism guarantee enables local reasoning about program behavior and supports reproducible execution for testing and verification.

##### §9.4.2.2 Interaction with Expression Evaluation

[8] When a statement contains expressions, those expressions evaluate per Clause 8 rules:

- Arithmetic and logical operations follow strict left-to-right evaluation
- Procedure calls evaluate arguments left-to-right
- Short-circuit operators (`&&`, `||`) may skip right operands (§8.3.7)

[9] Statement-level determinism composes with expression-level determinism to provide end-to-end predictability.

##### §9.4.2.3 Examples

**Example 9.4.2.1 (Deterministic side effects):**

```cursive
var counter = 0

procedure increment(): i32
    [[ |- true => true ]]
{
    counter += 1
    result counter
}

procedure demo()
    [[ |- true => true ]]
{
    let a = increment()  // counter = 1, a = 1
    let b = increment()  // counter = 2, b = 2
    let c = increment()  // counter = 3, c = 3
    // Order guaranteed: a=1, b=2, c=3
}
```

#### §9.4.3 Short-Circuit Behavior [stmt.order.shortcircuit]

##### §9.4.3.1 Reference to Clause 8

[10] Short-circuit evaluation for logical operators (`&&`, `||`) is specified in Clause 8 §8.3.7. Those rules apply when such expressions appear in statement contexts.

[11] No additional short-circuit behavior exists at the statement level. Statement sequences always execute until a control-transfer outcome occurs; there is no statement-level "short-circuiting" of sequences.

#### §9.4.4 Divergence and Unreachability [stmt.order.divergence]

##### §9.4.4.1 Divergent Statements

[12] Statements that produce control-transfer outcomes have type `!` (never) because they do not complete normally:

- `return` statements
- `break` statements  
- `continue` statements
- Expressions of type `!` (panic, infinite loops)

[13] Divergent statements may coerce to any type per §7.2.7, enabling their use in contexts expecting specific types.

##### §9.4.4.2 Unreachable Code

[14] Statements following a divergent statement are unreachable:

[ Given: Divergent statement $s_1$ followed by statement $s_2$ ]

$$
\frac{\Gamma \vdash s_1 : !}{\Gamma \vdash s_2 \text{ unreachable}}
\tag{WF-Unreachable}
$$

[15] Implementations should warn about unreachable code (quality of implementation feature). Unreachable code does not affect conformance provided the reachable portions satisfy all normative requirements.

##### §9.4.4.3 Examples

**Example 9.4.4.1 (Unreachable code after return):**

```cursive
procedure example(): i32
    [[ |- true => true ]]
{
    return 42
    // WARNING: Following code is unreachable
    let unused = compute()  // Never executes
}
```

**Example 9.4.4.2 (Divergent loop):**

```cursive
procedure infinite_server()
    [[ io::read |- true => false ]]  // will clause: false (never returns)
{
    loop {
        handle_request()
        // Loop has type ! (never exits)
    }
    // Unreachable: loop never exits
}
```

#### §9.4.5 State Threading

[16] The execution model threads state through statement sequences explicitly. Each statement:

1. Receives the current store $\sigma$
2. Executes, possibly reading and modifying the store
3. Produces an updated store $\sigma'$ (or a control outcome with store)

[17] This explicit state threading ensures that the memory model (Clause 11) and grant system (Clause 12) can reason about program state at each step.

#### §9.4.6 Conformance Requirements

[18] Implementations shall:

1. Execute statements in strict textual order
2. Thread state through statement sequences as specified in §9.4.1
3. Guarantee deterministic execution order for statements and subexpressions
4. Propagate control-transfer outcomes per §9.1.7, bypassing remaining statements
5. Respect short-circuit behavior from Clause 8 for operators in expressions
6. Treat divergent statements as having type `!` and mark following code unreachable
7. Warn about unreachable code (recommended quality-of-implementation feature)
8. Maintain the execution model's semantic consistency with the memory model (Clause 11) and expression evaluation (Clause 8)


### §9.1 Region Parameters Overview [generic.regions]

#### §9.1.1 Overview

[1] This subclause specifies how region allocation integrates with the generic type system. Region type parameters are not supported in version 1.0; allocation uses explicit region blocks with the `^` operator (§10.3) and provenance tracking rather than type-level parameterization.

#### §9.1.2 Current Design: Provenance Without Parameterization

[4] Under the current design, region allocation uses the `^` prefix operator within explicit `region` blocks:

```cursive
region session {
    let data = ^Buffer::new()
    process(data)
}
// All allocations in 'session' freed at O(1) when block exits
```

[5] The compiler tracks provenance metadata (Stack, Region(r), Heap) for each allocated object as described in §9.3.4 and §7.5.3. Escape analysis prevents region-allocated values from outliving their region without requiring type-level region parameters.

[6] Generic types currently do not expose region parameters. A type such as `List<T>` may contain region-allocated elements, but the region is determined by allocation sites rather than by parameterization. The provenance of contained elements is tracked via the existing escape analysis mechanism.

#### §9.1.3 Syntax (Current Edition)

[7] Region allocation syntax (defined in §9.3.2):

**Region blocks** match the pattern:
```
"region" [ <identifier> ] <block_stmt>
```

**Region allocation expressions** take one of the following forms:
```
"^" <expression>
"^" "^" ... <expression>    // Caret stacking for parent regions
```

[ Note: Complete region allocation semantics are specified in §9.3.2 [memory.region]. — end note ]

[8] Generic parameter lists (§8.2.2) currently support type, const, and grant parameters but not region parameters:

**Generic parameters** match the pattern:
```
"<" <generic_param_list> ">"
```

where **generic parameter lists** match:
```
<generic_param> [ "," <generic_param> ... ]
```

and each **generic parameter** takes one of the following forms:
```
<type_param>
<const_param>
<grant_param>
// region_param reserved for future edition
```

[ Note: See §8.2.2 [generic.params] and Annex A §A.6 for the complete generic parameter grammar. — end note ]

#### §9.1.4 Constraints (Current Edition)

[9] Region allocation requires an active region block. Using `^` outside a region context produces diagnostic E10-103 (defined in §9.3).

[10] Escape analysis (§9.3.3, §7.5.3) prevents region-allocated values from escaping their originating region. This constraint is enforced through provenance tracking without requiring type-level region annotations.

[11] Generic types containing region-allocated elements shall not expose those elements in ways that would allow escape. The prohibition is enforced through the same provenance and escape rules that apply to non-generic types.

#### §9.1.5 Semantics (Current Edition)

[12] When a generic type `Container<T>` is instantiated with region-allocated elements:

1. The element type `T` carries no region annotation
2. Elements allocated with `^` have provenance Region(r) where r is the active region
3. Escape analysis prevents storing those elements in containers with longer lifetimes
4. The container itself may be allocated in any region or on the heap

[13] The lack of region parameterization means that containers cannot abstract over region lifetimes. Each container instance is associated with a specific allocation site, and region provenance is determined by that site rather than by type parameters.

#### §9.1.6 Examples (Current Edition)

**Example 9.1.6.1 (Region allocation without parameterization):**

```cursive
record List<T> {
    data: Ptr<T>@Valid,
    len: usize,
    cap: usize,
}

procedure demo()
    [[ alloc::region, alloc::heap |- true => true ]]
{
    region temp {
        let items = ^List::new()        // List allocated in temp
        items.push(^Item::new())         // Item allocated in temp
        // Both List and Items freed when temp exits
    }

    let permanent = List::new()          // List allocated on heap
    permanent.push(Item::new())          // Item allocated on heap
    // Separate lifetime from temp region
}
```

**Example 9.1.6.2 (Escape prevention through provenance):**

```cursive
procedure invalid_escape(): List<Data>
    [[ alloc::region, alloc::heap |- true => true ]]
{
    region temp {
        let list = ^List::new()
        list.push(^Data::new())
        result list  // error[E10-101]: region-allocated value cannot escape
    }
}

procedure valid_heap_return(): List<Data>
    [[ alloc::region, alloc::heap |- true => true ]]
{
    region temp {
        let list = ^List::new()
        list.push(^Data::new())
        result list.to_heap()  // Explicit heap conversion before escape
    }
}
```

#### §9.1.7 Design Decision: No Region Type Parameters

[14] This specification deliberately does **not** introduce region type parameters (syntax like `List<^r, T>`). Region allocation is managed through the `Arena` modal type (§9.3.2) and provenance metadata, not type-level parameterization.

[ Rationale: Region type parameters would reintroduce complexity similar to lifetime parameters, contradicting Cursive's explicit allocation philosophy. Regions are concrete arenas (§10.3), not abstract bounds. Named arena bindings provide necessary control without type-level pollution. — end rationale ]

[15] Region type parameters are not supported in version 1.0. Future editions may reconsider based on field experience if the Arena modal type proves insufficient for all use cases. If additional arena control is needed beyond named bindings and modal states, extensions will prioritize first-class arena values (library types, collection patterns) rather than type-level parameterization.

#### §9.1.8 Integration with Other Systems

[17] Region allocation integrates with:

- **Type system (Clause 7)**: Pointer provenance (§7.5.3) tracks allocation source
- **Memory model (Clause 9)**: Region blocks (§9.3), escape analysis (§9.3.3)
- **Permissions (§9.4)**: Orthogonal—region allocation works with all permissions
- **Generics (§10.6)**: Monomorphization preserves region semantics

[18] These integrations ensure that region allocation remains safe and deterministic even when combined with generic types, permissions, and contracts.

#### §9.1.9 Conformance Requirements

[19] Implementations shall integrate region allocation with monomorphization (§8.6) so that generic instantiations preserve region semantics, and shall not introduce region parameterization syntax without specification approval.


### §9.2 Type Parameters [generic.parameter]

#### §9.2.1 Overview

[1] Type parameters enable parametric polymorphism: procedures and types may abstract over types, compile-time constants, and grant sets. This subclause specifies the syntax for declaring parameters, their scope and shadowing rules, default values, and explicit instantiation syntax.

[2] Cursive provides three kinds of generic parameters:

- **Type parameters** (`<T>`, `<T, U>`) — abstract over types
- **Const parameters** (`<const N: usize>`) — abstract over compile-time constant values
- **Grant parameters** (`<ε>`, `<ε ⊆ {...}>`) — abstract over grant sets for grant polymorphism

[3] All three kinds may appear in the same parameter list. Monomorphization (§10.6) generates specialized code for each distinct instantiation, ensuring zero runtime overhead.

#### §9.2.2 Syntax

[4] Generic parameter syntax follows:

**Generic parameters** match the pattern:
```
"<" <generic_param_list> ">"
```

where **generic parameter lists** match:
```
<generic_param> [ "," <generic_param> ... ]
```

**Generic parameters** take one of the following forms:
```
<type_param>
<const_param>
<grant_param>
```

**Type parameters** match the pattern:
```
<identifier> [ ":" <behavior_bounds> ]
```

**Behavior bounds** match the pattern:
```
<behavior_bound> [ "+" <behavior_bound> ... ]
```

where each **behavior bound** is:
```
<type_expression>    // Resolves to behavior or contract
```

**Const parameters** match the pattern:
```
"const" <identifier> ":" <const_type>
```

where **const types** are:
```
"usize" | "u8" | "u16" | "u32" | "u64" | "u128"
"isize" | "i8" | "i16" | "i32" | "i64" | "i128"
"bool"
```

**Grant parameters** take one of the following forms:
```
<identifier>                                  // Unbounded grant variable
<identifier> "⊆" "{" <grant_set> "}"         // Bounded grant variable
```

where **grant sets** match:
```
<grant_identifier> [ "," <grant_identifier> ... ]
```

and each **grant identifier** is:
```
<qualified_name>    // Module-qualified grant name
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative generic parameter grammar.
— end note ]

[5] Type parameters may have bounds specifying behaviors or contracts that constrain valid instantiations. Bounds may be declared inline (`<T: Display>`) or in `where` clauses (§10.3).

[6] Const parameters abstract over compile-time constant values of integer or boolean type. The parameter identifier may be used in type expressions, array lengths, and other compile-time contexts.

[7] Grant parameters abstract over grant sets. They enable grant-polymorphic procedures that work with callables requiring different grants.

#### §9.2.3 Type Parameters [generic.parameter.type]

##### §9.2.3.1 Declaration and Scope

[8] Type parameters are declared in generic parameter lists on:

- Type declarations: `record List<T> { ... }`
- Procedure declarations: `procedure map<T, U>(...) { ... }`
- Behavior declarations: `behavior Container<T> { ... }`
- Contract declarations (Clause 12): `contract Serializable<T> { ... }`

[9] Type parameters introduce bindings into the declaring entity's scope. Within that scope, the parameter identifier shadows any outer type binding with the same name (§6.3). Parameters are visible throughout the entity body and in `where` clauses.

[10] **Scope rule**:

[ Given: Generic declaration with type parameter `T` ]

$$
\frac{\text{declaration } D\langle T \rangle \{ \text{body} \}}{\text{In body: } T \in \Gamma \text{ as type variable}}
\tag{WF-TypeParam-Scope}
$$

##### §9.2.3.2 Bounds

[11] Type parameters may have bounds constraining which types may be used as arguments:

```cursive
procedure sort<T>(values: [T])
    [[ |- values.len() > 0 => true ]]
    where T: Ord
{
    // Implementation can use T::compare
}
```

[12] Bounds are checked at instantiation (§10.6). Multiple bounds are specified using `+` syntax or `where` clauses (§10.3).

##### §9.2.3.3 Type Parameter Inference

[13] Type parameters may be inferred from usage context:

```cursive
procedure identity<T>(value: T): T
{
    result value
}

let x = identity(42)          // T inferred as i32
let y: string = identity("hello")  // T inferred as string from return context
```

[14] When inference fails, diagnostic E10-101 requests explicit type arguments using turbofish syntax (§10.2.7).

##### §9.2.3.4 Examples

**Example 10.2.3.1 (Type parameters in record):**

```cursive
record Pair<T, U> {
    first: T,
    second: U,
}

let coordinates: Pair<f64, f64> = Pair { first: 3.0, second: 4.0 }
let mixed: Pair<i32, string@Managed> = Pair { first: 1, second: string.from("hello") }
```

**Example 10.2.3.2 (Type parameters in procedure):**

```cursive
procedure swap<T>(a: unique T, b: unique T): (T, T)
{
    result (b, a)
}

let (y, x) = swap(x, y)  // T inferred from arguments
```

#### §9.2.4 Const Parameters [generic.parameter.const]

##### §9.2.4.1 Declaration and Valid Types

[15] Const parameters abstract over compile-time constant values. They must have an integer or boolean type as specified in §10.2.2.

[16] Const parameters enable types and procedures parameterized by compile-time values:

```cursive
record FixedBuffer<T, const N: usize> {
    data: [T; N],
    len: usize,
}

procedure create_buffer<T, const SIZE: usize>(): FixedBuffer<T, SIZE>
    [[ alloc::heap |- SIZE > 0 => true ]]
{
    result FixedBuffer { data: [T::default(); SIZE], len: 0 }
}
```

##### §9.2.4.2 Const Parameter Values

[17] Const parameter arguments must be evaluable at compile time (§8.7):

- Integer or boolean literals
- Const bindings
- Arithmetic expressions over const values
- `sizeof(T)` or `alignof(T)` introspics
- Other const parameters

[18] Runtime values cannot be used as const arguments. Violations produce diagnostic E10-102.

##### §9.2.4.3 Const Expression Evaluation

[19] Const parameter values are evaluated during the compile-time execution phase (§2.2.4.2). The evaluation follows the same rules as `comptime` blocks but is restricted to the const parameter's type.

[20] **Evaluation rule**:

[ Given: Const parameter `const N: usize`, argument expression `e` ]

$$
\frac{\langle e, \emptyset \rangle \Downarrow_{\text{comptime}} \langle v, \emptyset \rangle \quad v \in \llbracket \text{usize} \rrbracket}{\text{const arg } N = v \text{ ok}}
\tag{E-Const-Arg}
$$

##### §9.2.4.4 Usage in Type Expressions

[21] Const parameters may appear in:

- Array length expressions: `[T; N]`
- Repeat array literals: `[value; N]`
- Const generic arguments to other types: `FixedBuffer<T, N>`
- Compile-time assertions in sequents: `[[ |- N > 0 => true ]]`

[22] Using const parameters in runtime-only contexts (assignments to `var` bindings, mutable operations) is ill-formed (diagnostic E10-103).

##### §9.2.4.5 Examples

**Example 10.2.4.1 (Const parameter for array size):**

```cursive
record Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

procedure identity_matrix<const N: usize>(): Matrix<f64, N, N>
    [[ alloc::heap |- N > 0 => true ]]
{
    var matrix = Matrix { data: [[0.0; N]; N] }
    var i: usize = 0
    loop i < N {
        matrix.data[i][i] = 1.0
        i = i + 1
    }
    result matrix
}

let mat3: Matrix<f64, 3, 3> = identity_matrix()  // N inferred as 3
```

**Example 10.2.4.2 - invalid (Runtime value as const argument):**

```cursive
let size = read_input()
let buffer: FixedBuffer<i32, size> = create_buffer()
// error[E10-102]: const argument must be compile-time evaluable
```

#### §9.2.5 Grant Parameters [generic.parameter.grant]

##### §9.2.5.1 Declaration and Bounds

[23] Grant parameters enable grant-polymorphic programming: procedures may abstract over the grant sets required by higher-order callables.

[24] Grant parameters are declared as identifiers optionally bounded by grant sets using the subset operator `⊆`:

```cursive
procedure apply<T, U, ε>(value: T, f: (T) -> U ! ε): U
    [[ ε |- true => true ]]
{
    result f(value)
}
```

[25] The sequent clause `[[ ε |- ... ]]` uses the grant parameter `ε` directly as the grants clause. This indicates that the procedure requires exactly the grants that `f` requires.

##### §9.2.5.2 Grant Parameter Bounds

[26] Grant parameters may be bounded to limit the permitted grants:

```cursive
procedure safe_apply<T, U, ε>(value: T, f: (T) -> U ! ε): U
    [[ ε |- true => true ]]
    where ε ⊆ {io::write, alloc::heap}
{
    result f(value)
}
```

[27] The bound `ε ⊆ {io::write, alloc::heap}` constrains `ε` to be a subset of the specified grant set. At instantiation, the actual grant set must satisfy this constraint.

##### §9.2.5.3 Integration with Contractual Sequents

[28] Contractual sequents support generic syntax with grant parameters integrated directly into the sequent specification:

```cursive
procedure transform<T, U, [[ε |- P => Q]]>(data: T, f: (T) -> U ! ε): U ! ε
    [[ ε |- P => Q ]]
```

[29] The notation `<T, U, [[ε |- P => Q]]>` declares type parameters `T`, `U`, and embeds the grant parameter with its sequent in the generic parameter list. This is syntactic sugar for:

```cursive
procedure transform<T, U, ε>(data: T, f: (T) -> U ! ε): U ! ε
    [[ ε |- P => Q ]]
```

Both forms are equivalent; the embedded form documents the grant parameter's role more explicitly.

##### §9.2.5.4 Grant Parameter Inference

[30] Grant parameters are inferred from callable arguments:

```cursive
procedure twice<T, ε>(f: () -> T ! ε): (T, T)
    [[ ε |- true => true ]]
{
    result (f(), f())
}

// Inference:
let pure = || { result 42 }
let pair = twice(pure)  // ε inferred as ∅

let writer = || [[ io::write |- true => true ]] { println("hi") }
let pair2 = twice(writer)  // ε inferred as {io::write}
```

##### §9.2.5.5 Examples

**Example 10.2.5.1 (Grant-polymorphic map):**

```cursive
procedure map<T, U, ε>(values: [T], f: (T) -> U ! ε): [U]
    [[ alloc::heap, ε |- values.len() > 0 => result.len() == values.len() ]]
{
    let result = array::with_capacity(values.len())
    loop i in 0..values.len() {
        result.push(f(values[i]))
    }
    result result
}

// Usage with pure function
let numbers = [1, 2, 3, 4, 5]
let doubled = map(numbers, |x| { result x * 2 })

// Usage with grant-requiring function
let logged = map(numbers, |x| [[ io::write |- true => true ]] {
    println("Processing {}", x)
    result x * 2
})
```

**Example 10.2.5.2 (Bounded grant parameter):**

```cursive
procedure with_resource<T, ε>(f: () -> T ! ε): T ! ε
    [[ alloc::heap, ε |- true => true ]]
    where ε ⊆ {io::write, io::read}
{
    let resource = acquire_resource()
    defer { release_resource(resource) }
    result f()
}

// Valid: io::write ⊆ {io::write, io::read}
with_resource(|| [[ io::write ]] { println("hello") })

// Invalid: fs::write ⊄ {io::write, io::read}
with_resource(|| [[ fs::write ]] { write_file() })
// error[E10-301]: grant set violates bound
```

#### §9.2.6 Parameter Ordering and Defaults

##### §9.2.6.1 Parameter Order

[31] Parameters shall appear in the following order within a generic parameter list:

1. Type parameters
2. Const parameters
3. Grant parameters

[32] Implementations may relax this ordering provided doing so does not introduce ambiguity during parsing or instantiation. The recommended style places type parameters first for consistency with established conventions.

##### §9.2.6.2 Default Values

[33] Type and const parameters may have default values:

```cursive
record Buffer<T = u8, const SIZE: usize = 1024> {
    data: [T; SIZE],
}

let bytes: Buffer = Buffer::new()              // T = u8, SIZE = 1024
let custom: Buffer<i32> = Buffer::new()        // T = i32, SIZE = 1024 (default)
let large: Buffer<u8, 4096> = Buffer::new()    // T = u8, SIZE = 4096
```

[34] Parameters with defaults must appear after parameters without defaults. Violating this ordering produces diagnostic E10-104.

[35] Grant parameters do not support defaults. They must be explicitly provided or inferred from usage.

##### §9.2.6.3 Default Value Constraints

[36] Default values shall be:

- **Type defaults**: Any well-formed type visible in the declaring scope
- **Const defaults**: Compile-time evaluable expressions of the parameter's const type
- **No grant defaults**: Grant parameters have no default mechanism

[37] Default values are evaluated in the scope of the generic declaration. They may reference earlier parameters but not later ones:

```cursive
record Pair<T, U = T> {     // Valid: U defaults to T
    first: T,
    second: U,
}

record Invalid<T = U, U> {  // error[E10-105]: default references later parameter
    // ...
}
```

#### §9.2.7 Explicit Type Arguments (Turbofish)

[38] Explicit type arguments use turbofish syntax: `::<TypeArgs>` following an identifier.

```cursive
generic_instantiation
    ::= identifier "::" "<" type_argument_list ">"

type_argument_list
    ::= type_argument ("," type_argument)*

type_argument
    ::= type_expression              // Type argument
     | const_expression              // Const argument
     | "{" grant_set "}"             // Grant argument
```

[39] Turbofish syntax disambiguates instantiations when inference fails or when explicit types are desired for clarity:

```cursive
let values = make_vec::<i32>()                       // Explicit T = i32
let buffer = create_buffer::<u8, 512>()              // T = u8, SIZE = 512
let mapped = apply::<i32, string, {io::write}>(...)  // All parameters explicit
```

##### §9.2.7.1 Partial Explicit Arguments

[40] Implementations shall support partial explicit type arguments: providing only leading parameters allows trailing parameters to be inferred.

```cursive
procedure convert<T, U>(value: T): U
    where T: Into<U>
{
    result value.into()
}

let result = convert::<i32>(value)   // T = i32, U inferred from context
```

[41] Partial application must respect parameter order. Skipping early parameters while providing later ones is ill-formed (diagnostic E10-106).

##### §9.2.7.2 Turbofish Parsing

[42] The turbofish operator `::` binds tightly to the preceding identifier. In generic call expressions, `function::<Type>(args)` parses as `(function::<Type>)(args)`.

[43] When the `<` token could begin both a comparison operator and a type argument list, the parser shall disambiguate using lookahead: if the token sequence matches `:: <` followed by a valid type expression and `>`, it is a turbofish; otherwise it is the scope operator followed by a comparison.

#### §9.2.8 Constraints

[44] _Parameter uniqueness._ Parameter identifiers shall be unique within a generic parameter list. Duplicate parameters produce diagnostic E10-107.

[45] _Valid const types._ Const parameters shall have types from the `const_type` grammar (integer types or `bool`). Other types are ill-formed (diagnostic E10-108).

[46] _Bound well-formedness._ Behavior and contract bounds must refer to visible behaviors or contracts. Invalid bounds produce diagnostic E10-201 (§10.3).

[47] _Grant bound syntax._ Grant parameter bounds use `⊆` (subset) operator, not `:` (type constraint). Using `:` for grant bounds is a syntax error (diagnostic E10-109).

[48] _Shadowing outer bindings._ Type parameters shadow outer type bindings with the same identifier. No explicit `shadow` keyword is needed—parameters implicitly shadow (§6.3).

[49] _Const parameter scope._ Const parameters are available in type expressions and compile-time contexts within the declaring entity. They are not available in runtime expressions except when embedded in types. Using a const parameter as a runtime value is ill-formed (diagnostic E10-110).

#### §9.2.9 Semantics

##### §9.2.9.1 Type Parameter Semantics

[50] Type parameters are placeholders replaced during monomorphization (§10.6). They introduce universally quantified types:

$$
\text{record } R\langle T \rangle \equiv \forall T. \text{ RecordType}(R, T)
$$

$$
\text{procedure } f\langle T \rangle \equiv \forall T. \text{ ProcedureType}(f, T)
$$

[51] Within the generic entity's body, `T` is treated as an opaque type satisfying its bounds. Operations on values of type `T` are limited to those guaranteed by the bounds.

##### §9.2.9.2 Const Parameter Semantics

[52] Const parameters are compile-time values substituted during monomorphization:

$$
\text{FixedBuffer}\langle T, N \rangle \text{ instantiated with } N=1024 \equiv \text{FixedBuffer}_{\text{specialized}}(T, 1024)
$$

[53] After substitution, const parameters become literal values in the generated code. Array lengths, repeat counts, and other compile-time expressions are resolved to constants.

##### §9.2.9.3 Grant Parameter Semantics

[54] Grant parameters represent grant set variables. They participate in grant checking (Clause 12) as placeholders for actual grant sets determined at instantiation:

$$
\frac{\Gamma \vdash f : (T) \to U \; ! \varepsilon}{\Gamma \vdash \text{apply}(v, f) : U \; ! \varepsilon}
\tag{Grant-Param-Subst}
$$

[55] The procedure `apply` inherits the grant set `ε` from its callable argument `f`. Grant checking ensures that `apply`'s sequent lists `ε` in its grants clause.

#### §9.2.10 Diagnostics

[56] Type parameter diagnostics:

| Code    | Condition                                                          |
| ------- | ------------------------------------------------------------------ |
| E10-101 | Type parameter cannot be inferred; explicit type argument required |
| E10-102 | Const argument not compile-time evaluable                          |
| E10-103 | Const parameter used in runtime-only context                       |
| E10-104 | Parameter with default appears before parameter without default    |
| E10-105 | Default value references later parameter                           |
| E10-106 | Partial explicit arguments skip early parameters                   |
| E10-107 | Duplicate parameter name in generic parameter list                 |
| E10-108 | Const parameter has invalid type (not integer or bool)             |
| E10-109 | Grant parameter uses `:` instead of `⊆` for bound                  |
| E10-110 | Const parameter used as runtime value                              |

#### §9.2.11 Conformance Requirements

[57] Implementations shall:

1. Support type, const, and grant parameters in generic parameter lists
2. Enforce parameter ordering constraints and uniqueness (E10-107)
3. Validate const parameter types are limited to integers and bool (E10-108)
4. Evaluate const parameter arguments at compile time (E10-102)
5. Infer type and grant parameters from usage context when possible
6. Support turbofish syntax for explicit type arguments
7. Allow partial explicit type arguments (leading parameters only)
8. Support default values for type and const parameters
9. Enforce default parameter ordering (defaults after non-defaults)
10. Integrate grant parameters with contractual sequent specifications
11. Emit structured diagnostics (Annex E §E.5) for parameter violations


### §9.3 Bounds and Where-Constraints [generic.bounds]

#### §9.3.1 Overview

[1] Bounds constrain generic type parameters to types satisfying specific behaviors or contracts. They enable generic algorithms to assume certain operations are available without knowing the concrete type.

[2] Cursive provides two syntactic forms for expressing bounds:

- **Inline bounds** (`<T: Behavior>`) — bounds attached directly to parameter declarations
- **Where clauses** (`where T: Behavior`) — bounds listed after the procedure signature or type declaration header

[3] This subclause specifies bound syntax, satisfaction rules, associated type constraints, grant bounds, and the interaction between inline and where-clause forms.

#### §9.3.2 Syntax

[4] Bound syntax follows:

**Type parameters with bounds** match the pattern:
```
<identifier> ":" <behavior_bounds>
```

**Behavior bounds** match the pattern:
```
<behavior_bound> [ "+" <behavior_bound> ... ]
```

where each **behavior bound** is:
```
<type_expression>    // Must resolve to behavior or contract name
```

**Where clauses** match the pattern:
```
"where" <where_predicate_list>
```

where **where predicate lists** match:
```
<where_predicate> [ "," <where_predicate> ... ]
```

**Where predicates** take one of the following forms:
```
<type_param> ":" <behavior_bounds>
<associated_type_equality>
<grant_bound>
```

**Associated type equalities** match the pattern:
```
<type_param> "::" <identifier> "=" <type>
```

**Grant bounds** match the pattern:
```
<grant_param> "⊆" "{" <grant_set> "}"
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative bounds grammar.
— end note ]

[5] The `+` operator combines multiple behavior or contract bounds. Bounds may be specified inline or in `where` clauses; both forms are semantically equivalent.

#### §9.3.3 Inline Bounds [generic.bounds.inline]

##### §9.3.3.1 Syntax and Formation

[6] Inline bounds attach directly to type parameter declarations:

```cursive
procedure display_all<T: Display>(items: [T])
    [[ io::write |- items.len() > 0 => true ]]
{
    loop item: T in items {
        println("{}", item.show())
    }
}
```

[7] Multiple inline bounds use `+` syntax:

```cursive
procedure serialize<T: Display + Clone>(value: T): string@Managed
    [[ alloc::heap |- true => true ]]
{
    result value.clone().show().to_managed()
}
```

##### §9.3.3.2 Constraints

[8] Each bound in an inline bound list shall resolve to a behavior or contract visible in the current scope. Invalid bounds produce diagnostic E10-201.

[9] Duplicate bounds in the same parameter are permitted but redundant. Implementations may warn about duplicates as a quality-of-implementation feature.

[10] Inline bounds apply only to the parameter they are attached to. Cross-parameter constraints require `where` clauses.

#### §9.3.4 Where Clauses [generic.bounds.where]

##### §9.3.4.1 Syntax and Placement

[11] Where clauses appear after the parameter list in procedure signatures or after the generic parameter list in type declarations:

```cursive
procedure complex<T, U>(a: T, b: U): Result
    where T: Display + Clone,
          U: Serializable,
          T::Output = U
{
    // Implementation
}

record Processor<T, U>
    where T: Parseable,
          U: Writable
{
    parser: T,
    writer: U,
}
```

##### §9.3.4.2 Where Clause Constraints

[12] Where clauses support three forms of constraints:

1. **Behavior bounds** (`T: Behavior`) — type parameter must satisfy behavior
2. **Associated type equality** (`T::Item = U`) — associated type must equal specified type
3. **Grant bounds** (`ε ⊆ {...}`) — grant parameter must be subset of specified grants

[13] All three forms may appear in the same where clause. Constraints are evaluated in the order written; later constraints may reference earlier ones.

##### §9.3.4.3 Equivalence with Inline Bounds

[14] Inline bounds and where clause bounds are semantically equivalent:

```cursive
// These two declarations are equivalent:

procedure f1<T: Display + Clone>(value: T)
{
    // ...
}

procedure f2<T>(value: T)
    where T: Display + Clone
{
    // ...
}
```

[15] Mixing inline and where clauses is permitted; bounds accumulate:

```cursive
procedure combined<T: Display>(value: T)
    where T: Clone
{
    // T must satisfy both Display and Clone
}
```

#### §9.3.5 Behavior and Contract Bounds [generic.bounds.predicate]

##### §9.3.5.1 Bound Satisfaction

[16] A type `τ` satisfies bound `B` (written `τ : B`) when:

- If `B` is a behavior: a behavior implementation `behavior B for τ` exists (§10.5)
- If `B` is a contract: a contract implementation `τ: B` exists in the type declaration (Clause 12)

[17] **Satisfaction judgment**:

[ Given: Type `τ`, bound `B` (behavior or contract) ]

$$
\frac{\text{behavior } B \text{ for } \tau \text{ implemented}}{\Gamma \vdash \tau : B}
\tag{WF-Bound-Satisfied}
$$

[18] For contract bounds (Clause 12):

$$
\frac{\text{record } \tau \text{: } B \text{ declared} \quad \text{all } B \text{ obligations met}}{\Gamma \vdash \tau : B}
\tag{WF-Contract-Bound}
$$

##### §9.3.5.2 Multiple Bounds

[19] A type parameter with multiple bounds must satisfy all bounds simultaneously:

$$
\frac{\Gamma \vdash \tau : B_1 \quad \Gamma \vdash \tau : B_2 \quad \cdots \quad \Gamma \vdash \tau : B_n}{\Gamma \vdash \tau : (B_1 + B_2 + \cdots + B_n)}
\tag{WF-Multi-Bound}
$$

[20] Bound checking occurs at instantiation time (§10.6). If any bound is not satisfied, the instantiation is ill-formed and produces diagnostic E10-202.

##### §9.3.5.3 Examples

**Example 10.3.5.1 (Single behavior bound):**

```cursive
behavior Ord {
    procedure compare(~, other: Self): i32
    {
        // Default implementation
        result 0
    }
}

procedure min<T: Ord>(a: T, b: T): T
{
    if a.compare(b) <= 0 {
        result a
    } else {
        result b
    }
}
```

**Example 10.3.5.2 (Multiple bounds):**

```cursive
procedure log_and_clone<T: Display + Clone>(value: T)
    [[ io::write, alloc::heap |- true => true ]]
{
    println("Value: {}", value.show())
    let copy = value.clone()
    process(copy)
}
```

#### §9.3.6 Associated Type Constraints [generic.bounds.assoc]

##### §9.3.6.1 Associated Type Equality

[21] Where clauses may constrain associated types to specific types:

```cursive
procedure sum_items<I>(iter: I): i32
    [[ alloc::heap |- true => true ]]
    where I: Iterator,
          I::Item = i32
{
    var total: i32 = 0
    loop item: i32 in iter {
        total = total + item
    }
    result total
}
```

[22] The constraint `I::Item = i32` requires that the associated type `Item` of behavior or contract `Iterator` equals `i32` for type `I`.

##### §9.3.6.2 Associated Type Projection

[23] Within a generic context, associated types are referenced using projection syntax `T::AssocType`:

$$
\frac{\Gamma \vdash T : \text{Behavior} \quad \text{Behavior declares type } I}{\Gamma \vdash T::I : \text{Type}}
\tag{T-Assoc-Proj}
$$

[24] For type variables with behavior bounds, the projection remains abstract until instantiation. For concrete types, the projection resolves to the specified associated type.

##### §9.3.6.3 Associated Type Bounds

[25] Associated types may themselves have bounds:

```cursive
procedure process<C>(container: C)
    where C: Container,
          C::Element: Display + Clone
{
    let first = container.get(0)
    println("{}", first.show())
    let copy = first.clone()
}
```

[26] The bound `C::Element: Display` applies to the associated type `Element` of `C`. Both the container bound and the element bound must be satisfied at instantiation.

##### §9.3.6.4 Examples

**Example 10.3.6.1 (Associated type equality constraint):**

```cursive
behavior Iterator {
    type Item = ()

    procedure next(~%): Item
    { result () }
}

procedure collect_bytes<I>(iter: I): [u8]
    [[ alloc::heap |- true => true ]]
    where I: Iterator,
          I::Item = u8
{
    let result = array::new()
    loop item: u8 in iter {
        result.push(item)
    }
    result result
}

// Valid: ByteIterator::Item = u8
collect_bytes(byte_stream)

// Invalid: Range::Item = i32 ≠ u8
// collect_bytes(range)  // error[E10-203]: associated type mismatch
```

#### §9.3.7 Grant Bounds [generic.bounds.grant]

##### §9.3.7.1 Syntax and Semantics

[27] Grant parameters may be bounded using the subset operator `⊆`:

```cursive
procedure controlled<T, ε>(f: () -> T ! ε): T
    [[ ε |- true => true ]]
    where ε ⊆ {io::write, alloc::heap}
{
    result f()
}
```

[28] The bound `ε ⊆ {io::write, alloc::heap}` requires that grant set `ε` be a subset of the specified grants. At instantiation, the actual grant set must satisfy:

$$
\varepsilon_{\text{actual}} \subseteq \{\text{io::write}, \text{alloc::heap}\}
$$

[29] Violating grant bounds produces diagnostic E10-301 listing the actual grant set and the bound.

##### §9.3.7.2 Grant Bound Checking

[30] Grant bounds are checked during instantiation:

[ Given: Grant parameter `ε`, bound `ε ⊆ G`, instantiation with grant set `ε'` ]

$$
\frac{\varepsilon' \subseteq G}{\text{grant bound satisfied}}
\tag{WF-Grant-Bound}
$$

[31] Grant bounds compose with behavior bounds: a procedure may constrain both types and grants:

```cursive
procedure transform<T, U, ε>(
    values: [T],
    f: (T) -> U ! ε
): [U]
    [[ alloc::heap, ε |- values.len() > 0 => result.len() == values.len() ]]
    where T: Clone,
          U: Display,
          ε ⊆ {io::write}
{
    // Can clone T, display U, and f can use only io::write
}
```

##### §9.3.7.3 Examples

**Example 10.3.7.1 (Grant bounds limiting capabilities):**

```cursive
procedure with_logging<ε>(action: () -> () ! ε)
    [[ io::write, ε |- true => true ]]
    where ε ⊆ {alloc::heap, fs::read}
{
    println("Starting action")
    action()
    println("Completed action")
}

// Valid: alloc::heap ⊆ {alloc::heap, fs::read}
with_logging(|| [[ alloc::heap ]] { allocate_buffer() })

// Invalid: net::send ⊄ {alloc::heap, fs::read}
// with_logging(|| [[ net::send ]] { send_packet() })
// error[E10-301]: grant set exceeds bound
```

#### §9.3.8 Bound Entailment and Subsumption

##### §9.3.8.1 Entailment Rules

[32] Bounds participate in logical entailment: if a type satisfies a stronger bound, it automatically satisfies weaker bounds derived from it.

[33] **Transitive closure**: If behavior `P` extends behavior `Q` (§10.4), then `T: P` entails `T: Q`:

$$
\frac{\text{predicate } P \text{ with } Q \{ \ldots \} \quad \Gamma \vdash T : P}{\Gamma \vdash T : Q}
\tag{Bound-Entail}
$$

[34] This allows procedures to accept types with more specific bounds when only a weaker bound is required.

##### §9.3.8.2 Grant Subsumption

[35] Grant bounds follow subset subsumption:

$$
\frac{\varepsilon_1 \subseteq \varepsilon_2 \subseteq G \quad \text{bound is } \varepsilon \subseteq G}{\varepsilon_1 \text{ satisfies bound}}
\tag{Grant-Subsume}
$$

[36] A grant set that is a subset of another grant set satisfies any bound that the larger set satisfies.

##### §9.3.8.3 Examples

**Example 10.3.8.1 (Bound entailment):**

```cursive
behavior Display {
    procedure show(~): string@View
    { result "Display" }
}

behavior Debug with Display {
    procedure debug(~): string@View
    { result self.show() }

    procedure show(~): string@View
    { result "Debug default" }
}

procedure print<T: Display>(value: T)
    [[ io::write |- true => true ]]
{
    println("{}", value.show())
}

record Point with Debug {
    x: f64,
    y: f64,

    procedure show(~): string@View
    { result "Point" }

    procedure debug(~): string@View
    { result "Point(x, y)" }
}

// Point: Debug, and Debug with Display
// Therefore Point: Display (via entailment)
print(Point { x: 1.0, y: 2.0 })  // OK: Debug entails Display
```

#### §9.3.9 Constraints

[37] _Bound visibility._ Behaviors and contracts referenced in bounds must be visible in the scope where the generic entity is declared. Non-visible bounds produce diagnostic E10-201.

[38] _Bound satisfaction at instantiation._ When a generic is instantiated with type argument `τ`, every bound on the corresponding type parameter must be satisfied by `τ`. Unsatisfied bounds produce diagnostic E10-202 listing the type, the bound, and available implementations.

[39] _Associated type validity._ Associated type equality constraints shall reference associated types declared in the behaviors or contracts listed in the type parameter's bounds. Referencing undeclared associated types produces diagnostic E10-203.

[40] _Grant bound validity._ Grant bounds shall use the subset operator `⊆`, not the type bound operator `:`. Grant sets in bounds must contain only valid grant identifiers. Invalid grant identifiers produce diagnostic E10-204.

[41] _Cyclic bounds._ Bounds shall not form cycles through associated type projections. For example, `where T: C, T::Item: D, D::Value = T` may create a cycle. Cyclic bound dependencies produce diagnostic E10-205.

[42] _Conflicting equality constraints._ A where clause shall not contain conflicting associated type equalities for the same projection. For example, `where T::Item = i32, T::Item = u32` is ill-formed (diagnostic E10-206).

#### §9.3.10 Semantics

##### §9.3.10.1 Bound Checking

[43] Bound checking occurs during the resolution phase (§10.6) after type arguments are determined. The compiler verifies that each type argument satisfies all bounds on its corresponding parameter.

[44] **Checking algorithm**:

```
check_bounds(parameters, arguments, bounds):
    for each (param, arg) in zip(parameters, arguments):
        for each bound B in bounds(param):
            if bound is behavior/contract:
                verify: behavior B for arg exists
                if not: error E10-202
            if bound is associated type equality T::A = U:
                verify: arg::A ≡ U
                if not: error E10-203

    for each grant bound (ε ⊆ G):
        verify: actual_grant_set ⊆ G
        if not: error E10-301

    return bounds_satisfied
```

##### §9.3.10.2 Bound Propagation

[45] Bounds propagate through the generic entity's body. Within a generic procedure or type body, operations on type variables are limited to those guaranteed by their bounds:

```cursive
procedure use_bounded<T: Display>(value: T)
    [[ io::write |- true => true ]]
{
    println("{}", value.show())    // OK: Display guarantees show()
    // value.clone()               // error: Clone not in bounds
}
```

[46] The type checker enforces that only methods guaranteed by the bounds are called on type variables.

##### §9.3.10.3 Associated Type Resolution

[47] Associated type projections are resolved based on the concrete type at instantiation:

$$
\frac{\Gamma \vdash \tau : P \quad \text{behavior } P \text{ for } \tau \{ \text{type } I = \upsilon \}}{\Gamma \vdash \tau::I \equiv \upsilon}
\tag{Assoc-Resolve}
$$

[48] For generic type variables, projections remain abstract until monomorphization substitutes concrete types.

#### §9.3.11 Higher-Kinded Bounds

[49] Cursive does not support higher-kinded type parameters (type parameters that are themselves generic). Bounds may not abstract over type constructors:

```cursive
// NOT SUPPORTED:
// procedure map_container<F<_>, T, U>(c: F<T>) -> F<U>
```

[50] All type parameters are first-order: they range over concrete types, not type constructors. Higher-kinded patterns may be encoded using associated types when needed.

#### §9.3.12 Diagnostics

[51] Bound-related diagnostics:

| Code    | Condition                                                       |
| ------- | --------------------------------------------------------------- |
| E10-201 | Bound references undefined or non-visible behavior/contract     |
| E10-202 | Type argument does not satisfy bound                            |
| E10-203 | Associated type equality constraint: types do not match         |
| E10-204 | Grant bound references invalid grant identifier                 |
| E10-205 | Cyclic bound dependencies through associated type projections   |
| E10-206 | Conflicting associated type equality constraints                |
| E10-301 | Grant parameter exceeds bound (grant set not subset of allowed) |

#### §9.3.13 Examples

**Example 10.3.13.1 (Where clause with multiple constraint kinds):**

```cursive
procedure convert_and_log<T, U, ε>(
    value: T,
    converter: (T) -> U ! ε
): U
    [[ io::write, ε |- true => true ]]
    where T: Display + Clone,
          U: Serializable,
          ε ⊆ {alloc::heap, io::write}
{
    println("Converting: {}", value.show())
    let result = converter(value.clone())
    log_output(result.serialize())
    result result
}
```

**Example 10.3.13.2 (Associated type with bounds):**

```cursive
behavior Container {
    type Element = ()

    procedure get(~, index: usize): Element
    { result () }
}

procedure display_first<C>(container: C)
    [[ io::write |- true => true ]]
    where C: Container,
          C::Element: Display
{
    let first = container.get(0)
    println("First element: {}", first.show())
}
```

**Example 10.3.13.3 - invalid (Unsatisfied bound):**

```cursive
record Point {
    x: f64,
    y: f64,
}

procedure show_item<T: Display>(item: T)
    [[ io::write |- true => true ]]
{
    println("{}", item.show())
}

// error[E10-202]: Point does not satisfy bound Display
// show_item(Point { x: 1.0, y: 2.0 })
```

#### §9.3.14 Conformance Requirements

[52] Implementations shall:

1. Support inline bounds (`T: Behavior`) and where clauses
2. Accept multiple bounds with `+` syntax and comma-separated where behaviors
3. Check bound satisfaction at instantiation time (§10.6)
4. Support associated type equality constraints in where clauses
5. Support grant parameter bounds using `⊆` operator
6. Validate bound references resolve to visible behaviors or contracts (E10-201)
7. Diagnose unsatisfied bounds with structured payloads (E10-202) listing type, bound, and available implementations
8. Resolve associated type projections to concrete types at monomorphization
9. Detect and reject cyclic bound dependencies (E10-205)
10. Detect and reject conflicting associated type constraints (E10-206)
11. Integrate bounds with the resolution algorithm (§10.6)
12. Propagate bounds through generic entity bodies for type checking


### §9.4 Behaviors: Declarations and Items [generic.behavior]

#### §9.4.1 Overview [generic.behavior.overview]

##### §9.4.1.1 Behavior Purpose

[1] A _behavior_ is a declaration that provides concrete, reusable implementations of procedures and associated types. Behaviors enable code sharing across multiple types without inheritance: types attach behaviors to gain functionality through monomorphized dispatch.

[2] Behaviors are Cursive's mechanism for concrete code reuse. They provide default implementations that types may use directly or override. Every procedure in a behavior **shall** have a concrete body; behaviors with abstract (body-less) procedures are ill-formed.

[3] **Critical distinction**: Behaviors provide concrete code; contracts (Clause 12) specify abstract requirements. The separation ensures that interface obligations (contracts) remain distinct from implementation sharing (behaviors). The term "behavior" describes reusable type functionality; "predicate expression" refers to boolean-valued logical expressions used in contractual sequent clauses.

##### §9.4.1.2 Behaviors vs Contracts

[4] Table 10.4.1 summarizes the distinction:

| Aspect              | Behaviors                                     | Contracts (Clause 12)                     |
| ------------------- | --------------------------------------------- | ----------------------------------------- |
| Purpose             | Concrete code reuse                           | Abstract interface specification          |
| Procedure bodies    | ALL procedures MUST have bodies               | NO procedures may have bodies             |
| Associated types    | Concrete defaults (may be overridden)         | Abstract requirements (must be specified) |
| Dispatch            | Static (monomorphization)                     | Static or dynamic (witnesses)             |
| Attachment syntax   | `with Behavior` or standalone implementation  | `: Contract` in type declaration          |
| Implementation site | Inline in type body or standalone declaration | Inline in type body only                  |
| Use case            | Sharing default implementations, marker types | Defining behavioral requirements          |

[5] Types may attach both behaviors and contracts:

```cursive
record Account: Ledgered with Serializable, Display {
    // Ledgered is a contract (abstract requirement, defined in Clause 12)
    // Serializable and Display are behaviors (concrete code reuse)
}
```

#### §9.4.2 Syntax [generic.behavior.syntax]

[6] Behavior declaration syntax:

**Behavior declarations** match the pattern:
```
[ <visibility_modifier> ] "behavior" <identifier> [ <generic_params> ]
    [ <behavior_extension> ] <behavior_body>
```

**Behavior extension clauses** match the pattern:
```
"with" <behavior_reference> [ "," <behavior_reference> ... ]
```

where each **behavior reference** is a `<type_expression>` that must resolve to a behavior name.

**Behavior bodies** match the pattern:
```
"{" [ <behavior_item> ... ] "}"
```

where each **behavior item** takes one of the following forms:
```
<associated_type_decl>
<procedure_declaration>
```

**Associated type declarations** match the pattern:
```
"type" <identifier> [ "=" <type_expression> ] [ ":" <behavior_bounds> ]
```

[ Note: See Annex A §A.7 [grammar.declaration] for complete behavior grammar.
— end note ]

[7] Procedure declarations within behaviors follow §5.4 [decl.function] syntax with the receiver parameter using `Self` to denote the implementing type. Receiver shorthand (`~`, `~%`, `~!`) desugars to `self: const/shared/unique Self`.

#### §9.4.3 Constraints [generic.behavior.constraints]

##### §9.4.3.1 Mandatory Procedure Bodies

[8] **Normative requirement**: Every procedure declared in a behavior **shall** include a concrete body. Behaviors declaring procedures without bodies are ill-formed.

$$
\frac{\text{behavior } P \{ \text{procedure } m : \text{Signature} \} \quad m \text{ has no body}}{\text{ERROR E10-401: behavior procedure must have body}}
\tag{WF-Pred-Body-Required}
$$

[9] This constraint distinguishes behaviors from contracts. Contracts declare procedures without bodies (abstract interfaces, Clause 12); behaviors provide bodies (concrete implementations).

##### §9.4.3.2 Visibility and Scope

[10] Behaviors declared at module scope default to `internal` visibility. The modifiers `public`, `internal`, `private`, and `protected` apply per §5.6 [decl.visibility].

[11] Behaviors introduce type bindings into the module scope (§6.2). The behavior identifier enters the unified namespace and may not collide with other bindings.

##### §9.4.3.3 Behavior Extension

[12] Behaviors may extend other behaviors using the `with` clause:

```cursive
behavior Debug with Display {
    procedure debug(~): string@View
    {
        result "Debug: " ++ self.show()
    }

    // Inherits show() from Display behavior
}
```

[13] Extension requires that all extended behaviors are visible and that no name conflicts arise. When multiple extended behaviors declare procedures with the same name:

- If signatures are identical (same parameters and return type), one implementation satisfies all
- If signatures differ, the extending behavior must provide an explicit implementation resolving the conflict
- If no explicit implementation is provided for conflicting signatures, diagnostic E10-413 is emitted

Extended behaviors contribute their procedures to the extending behavior; implementations must provide bodies for inherited procedures or use the inherited defaults.

[14] Cyclic extension (a behavior extending itself directly or transitively) is ill-formed (diagnostic E10-402).

##### §9.4.3.4 Generic Behaviors

[15] Behaviors may be generic over type, const, and grant parameters:

```cursive
behavior Converter<T, U> {
    procedure convert(~): U
    {
        // Default implementation
        panic("Converter not implemented")
    }
}
```

[16] Generic behaviors follow the same parameter rules as generic types (§10.2). Bounds on behavior parameters constrain which types may satisfy the behavior.

##### §9.4.3.5 Self Type

[17] Within a behavior body, the keyword `Self` refers to the implementing type. It is available in:

- Procedure signatures (`procedure method(~): Self`)
- Procedure bodies (`result Self { ... }`)
- Associated type bounds (`where Self: OtherBehavior`)
- Type expressions (`Ptr<Self>`, `[Self]`)

[18] `Self` is a type variable that resolves to the concrete implementing type during monomorphization (§10.6).

#### §9.4.4 Associated Types in Behaviors [generic.behavior.assoc]

##### §9.4.4.1 Overview

[19] Behaviors may declare associated types: type members that implementing types specify. Associated types in behaviors may have default values; implementing types may override the default.

##### §9.4.4.2 Syntax

[20] Associated type declarations in behaviors:

```cursive
behavior Iterator {
    type Item = ()    // Default value

    procedure next(~%): Item
    {
        result ()
    }
}
```

[21] The syntax `type Item = ()` provides a concrete default. Implementing types may override:

```cursive
record Range with Iterator {
    type Item = i32   // Override default

    start: i32,
    end: i32,

    procedure next(~%): i32
    {
        // Custom implementation
    }
}
```

##### §9.4.4.3 Associated Type Bounds

[22] Associated types may have bounds constraining valid overrides:

```cursive
behavior Container {
    type Element: Copy = u8    // Bound: Element must satisfy Copy

    procedure get(~, index: usize): Element
    {
        // Default implementation
        panic("Container::get not implemented")
    }
}
```

[23] Implementing types must provide associated types satisfying the bounds:

$$
\frac{\text{behavior } P \{ \text{type } A : B = \tau_{\text{default}} \} \quad \text{type } R \text{ with } P \{ \text{type } A = \upsilon \}}{\Gamma \vdash \upsilon : B}
\tag{WF-Assoc-Bound}
$$

[24] Violating associated type bounds produces diagnostic E10-403.

##### §9.4.4.4 Associated Type Projection

[25] Associated types are accessed using projection syntax `T::AssocType` as specified in §10.3.6. Within generic contexts, projections enable algorithms polymorphic over the associated type:

```cursive
procedure sum_container<C>(container: C): i32
    [[ alloc::heap |- true => true ]]
    where C: Container,
          C::Element = i32
{
    var total: i32 = 0
    var i: usize = 0
    loop i < container.len() {
        total = total + container.get(i)
        i = i + 1
    }
    result total
}
```

##### §9.4.4.5 Examples

**Example 10.4.4.1 (Associated type with default):**

```cursive
behavior Producer {
    type Output = ()

    procedure produce(~%): Output
    {
        result ()
    }
}

record IntProducer with Producer {
    type Output = i32    // Override default

    counter: i32,

    procedure produce(~%): i32
    {
        result self.counter
    }
}

record UnitProducer with Producer {
    // Uses default: type Output = ()

    procedure produce(~%): ()
    {
        result ()  // Inherits default associated type
    }
}
```

#### §9.4.5 Marker Behaviors [generic.behavior.marker]

##### §9.4.5.1 Overview

[26] Marker behaviors are special built-in behaviors with no procedures and no associated types. They express compile-time properties about types for use in bounds and optimization.

[27] Cursive provides three marker behaviors:

- **`Copy`**: Type values can be duplicated bitwise
- **`Sized`**: Type has statically known size
- **`Drop`**: Type has custom destructor

[28] Marker behaviors are automatically derived when structural requirements are met. They may be explicitly attached using the behavior clause syntax but cannot be manually implemented with procedure bodies.

##### §9.4.5.2 Copy Behavior [generic.behavior.marker.copy]

###### Definition

[29] The `Copy` behavior indicates that values of a type can be duplicated bitwise without violating safety invariants.

```cursive
behavior Copy {
    // No procedures, no associated types
    // Marker only
}
```

###### Auto-Derivation Rules

[30] A type automatically satisfies `Copy` when:

1. All fields satisfy `Copy` (for records and tuples)
2. All variants satisfy `Copy` (for enums)
3. The type does not satisfy the `Drop` behavior (§10.4.5.4)
4. The type does not contain non-`Copy` fields

[31] **Structural copy rule**:

[ Given: Record `R { f₁: T₁, ..., fₙ: Tₙ }` ]

$$
\frac{\forall i. \; \Gamma \vdash T_i : \text{Copy} \quad R \text{ does not satisfy } \text{Drop}}{\ Gamma \vdash R : \text{Copy}}
\tag{Prop-Copy-Struct}
$$

###### Primitive Types

[32] All primitive types satisfy `Copy` (§7.2):

$$
\forall T \in \text{PrimitiveTypes}. \; T : \text{Copy}
\tag{Prop-Copy-Prim}
$$

where $\text{PrimitiveTypes} = \{i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64, bool, char, (), !\}$.

###### Copy Semantics

[33] Types satisfying `Copy` may be duplicated using explicit `copy` keyword (§11.5.3):

```cursive
let a: i32 = 42
let b = copy a    // Bitwise duplication
```

[34] `Copy` types do not transfer cleanup responsibility when copied; each copy is an independent value with its own cleanup obligations.

###### Explicit Attachment

[35] Types explicitly attach `Copy` using the behavior clause:

```cursive
record Point with Copy {
    x: f64,
    y: f64,
}
```

[36] The attachment is validated: if structural requirements are not met, diagnostic E10-411 is emitted.

###### Examples

**Example 10.4.5.1 (Copy for simple record):**

```cursive
record Coordinate with Copy {
    x: f64,
    y: f64,
    z: f64,
}

let p1 = Coordinate { x: 1.0, y: 2.0, z: 3.0 }
let p2 = copy p1    // OK: Coordinate satisfies Copy
```

**Example 10.4.5.2 - invalid (Copy with non-Copy field):**

```cursive
record Container with Copy {
    data: Buffer,    // Buffer does not satisfy Copy
}
// error[E10-411]: cannot derive Copy, field `data` is not Copy
```

[ Note: **Thread safety through permissions, not markers**. Cursive does not provide Send and Sync marker behaviors. Thread safety is expressed through the permission system (§11.4):

- **`const` permission**: Safe to share across threads (immutable, unlimited aliasing)
- **`unique` permission**: Safe to transfer across threads (exclusive ownership via move)
- **`shared` permission**: Requires synchronization primitives for thread safety (Mutex, Channel, etc.)

This design avoids redundancy between permissions and marker behaviors. Complete concurrency semantics are specified in Clause 14 [concurrency].
— end note ]

##### §9.4.5.3 Sized Behavior [generic.behavior.marker.sized]

###### Definition

[47] The `Sized` behavior indicates that a type has statically known size and alignment.

```cursive
behavior Sized {
    // Marker only
}
```

###### Auto-Derivation Rules

[48] All types satisfy `Sized` except:

- Slice types `[T]` (size depends on runtime length)
- Future unsized types (trait objects in later editions)

[49] **Default sized**:

$$
\frac{\tau \notin \{\text{slice types}\}}{\Gamma \vdash \tau : \text{Sized}}
\tag{Prop-Sized-Default}
$$

###### Semantics

[50] `Sized` types may be stored in bindings directly, used as procedure parameters by value, and allocated on the stack. Unsized types must appear behind pointers:

```cursive
let array: [i32; 10] = [0; 10]    // OK: Sized
let slice: [i32] = array[..]      // error: unsized type in binding

let slice_ptr: Ptr<[i32]>@Valid = &array[..]  // OK: behind pointer
```

[51] Generic type parameters have an implicit `Sized` bound unless explicitly relaxed with `?Sized` (future extension, not current edition).

###### Examples

**Example 10.4.5.5 (Sized constraint):**

```cursive
procedure store<T: Sized>(value: T): T
{
    let stored = value
    result stored
}

store(42)              // OK: i32 is Sized
// store(array[..])    // error: [i32] is not Sized
```

##### §9.4.5.4 Drop Behavior [generic.behavior.marker.drop]

###### Definition

[37] The `Drop` behavior indicates that a type has a custom destructor. It provides the procedure invoked when a responsible binding goes out of scope (§11.2.5).

```cursive
behavior Drop {
    procedure drop(~!)
}
```

[ Note: Unlike other marker behaviors, `Drop` has a procedure signature. However, it remains a marker in the sense that it is automatically invoked by the runtime rather than called explicitly by user code.
— end note ]

###### Manual Implementation Only

[53] `Drop` is never auto-derived. Types must explicitly implement `Drop` by providing a `drop` procedure:

```cursive
record FileHandle {
    path: string@Managed,
    descriptor: i32,
}

behavior Drop for FileHandle {
    procedure drop(~!)
        [[ fs::close |- true => true ]]
    {
        os::close_fd(self.descriptor)
    }
}
```

[54] The `drop` procedure receives `unique Self` (exclusive access) and has no return value (implicitly returns `()`).

###### Drop and Copy Mutual Exclusion

[55] Types implementing `Drop` cannot satisfy `Copy`:

$$
\frac{\Gamma \vdash T : \text{Drop}}{\Gamma \vdash T \not: \text{Copy}}
\tag{Prop-Drop-Not-Copy}
$$

[56] Attempting to attach both `Copy` and `Drop` to the same type produces diagnostic E10-412.

###### Automatic Field Destruction

[57] After a type's `drop` procedure completes, the compiler automatically destroys fields in reverse declaration order (§11.2.5.3). Custom `drop` procedures need only perform type-specific cleanup; field cleanup is automatic.

###### Examples

**Example 10.4.5.6 (Drop for resource cleanup):**

```cursive
record Connection {
    address: string@Managed,
    socket: i32,
}

behavior Drop for Connection {
    procedure drop(~!)
        [[ net::close |- true => true ]]
    {
        net::close_socket(self.socket)
        // `address` automatically destroyed after drop() completes
    }
}
```

##### §9.4.5.5 Marker Behavior Summary

[38] Table 10.4.2 summarizes marker behavior properties:

| Behavior | Purpose               | Auto-Derived           | Has Procedures | Can Override |
| -------- | --------------------- | ---------------------- | -------------- | ------------ |
| `Copy`   | Bitwise copyable      | Yes (structural)       | No             | No           |
| `Sized`  | Statically known size | Yes (default for most) | No             | No           |
| `Drop`   | Custom destructor     | No (manual only)       | Yes (`drop`)   | Yes          |

[39] Marker behaviors with no procedures (Copy, Sized) are pure type-level properties with no runtime representation or procedure dispatch. Drop has a procedure but is considered a marker because it is automatically invoked by the runtime.

#### §9.4.6 Behavior Items [generic.behavior.items]

##### §9.4.6.1 Procedure Declarations

[60] Behavior procedures declare:

- Receiver parameter (`~`, `~%`, `~!`, or explicit `self: perm Self`)
- Additional parameters
- Return type
- Contractual sequent
- Procedure body (mandatory)

[61] All behavior procedures must include bodies. The body provides the default implementation available to all types attaching the behavior.

##### §9.4.6.2 Receiver Permissions

[62] Behavior procedures may use any receiver permission:

- `~` (`const Self`): Read-only access
- `~%` (`shared Self`): Shared mutable access
- `~!` (`unique Self`): Exclusive mutable access

[63] The receiver permission determines what operations the procedure may perform on `self` and constrains which bindings may invoke the procedure.

##### §9.4.6.3 Procedure Bodies and Self

[64] Within procedure bodies, `self` refers to the receiver and has type `perm Self` where `perm` matches the receiver permission. Operations on `self` are constrained by the permission:

```cursive
behavior Resettable {
    procedure reset(~!)
    {
        self = Self::default()  // OK: unique permission allows assignment
    }
}
```

##### §9.4.6.4 Examples

**Example 10.4.6.1 (Behavior with multiple procedures):**

```cursive
behavior Display {
    procedure show(~): string@View
    {
        result type_name::<Self>()  // Default: use type name
    }

    procedure show_verbose(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result self.show().to_managed()
    }
}
```

**Example 10.4.6.2 (Behavior procedures calling each other):**

```cursive
behavior Stringifiable {
    procedure to_string(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result string.from(self.to_str())
    }

    procedure to_str(~): string@View
    {
        result "Stringifiable"
    }
}
```

#### §9.4.7 Integration with Witnesses [generic.behavior.witness]

[66] Behaviors participate in the witness system for runtime polymorphism (Clause 13). A witness packages a value and behavior implementation for dynamic dispatch:

```cursive
// Forward reference to Clause 13
let drawable: witness<Display> = witness::heap(shape)
drawable.show()  // Dynamic dispatch to shape's show() implementation
```

[67] Witness construction, dispatch semantics, storage strategies, and modal witness integration are fully specified in Clause 13 [witness]. This clause establishes only that behaviors provide the compile-time structure that witnesses reify at runtime.

#### §9.4.8 Diagnostics [generic.behavior.diagnostics]

[68] Behavior declaration diagnostics:

| Code    | Condition                                                       |
| ------- | --------------------------------------------------------------- |
| E10-401 | Behavior procedure declared without body                        |
| E10-402 | Cyclic behavior extension (behavior extends itself)             |
| E10-403 | Associated type does not satisfy bound                          |
| E10-404 | Behavior extends non-behavior (e.g., contract)                  |
| E10-405 | Behavior name collision with existing binding                   |
| E10-406 | Duplicate associated type name in behavior                      |
| E10-407 | Behavior procedure has invalid receiver                         |
| E10-411 | Type claims Copy but does not satisfy structural requirements   |
| E10-412 | Type implements both Copy and Drop (mutual exclusion violation) |
| E10-413 | Conflicting procedures from extended behaviors                  |

#### §9.4.9 Examples [generic.behavior.examples]

**Example 10.4.9.1 (Complete behavior declaration):**

```cursive
behavior Drawable {
    type Canvas = DefaultCanvas

    procedure draw(~, canvas: Self::Canvas)
        [[ io::write |- true => true ]]
    {
        println("Drawing on canvas")
    }

    procedure draw_at(~, canvas: Self::Canvas, x: i32, y: i32)
        [[ io::write |- true => true ]]
    {
        println("Drawing at ({}, {})", x, y)
        self.draw(canvas)
    }
}
```

**Example 10.4.9.2 (Behavior extending another behavior):**

```cursive
behavior Display {
    procedure show(~): string@View
    {
        result "Display"
    }
}

behavior Debug with Display {
    procedure debug(~): string@View
    {
        result "Debug: " ++ self.show()
    }

    // Inherits show() from Display
    // Types may override show() or use inherited default
}
```

**Example 10.4.9.3 (Generic behavior):**

```cursive
behavior Converter<U> {
    procedure convert(~): U
    {
        panic("Converter::convert not implemented for this type")
    }
}

record IntWrapper with Converter<string@Managed> {
    value: i32,

    procedure convert(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result string.from_int(self.value)
    }
}
```

**Example 10.4.9.4 - invalid (Behavior with body-less procedure):**

```cursive
behavior Invalid {
    procedure abstract_method(~): i32
    // error[E10-401]: behavior procedure must have body
}
```

**Example 10.4.9.5 (Marker behaviors on type):**

```cursive
record Token with Copy {
    id: u64,
    timestamp: i64,
}

// Marker behaviors satisfied:
// - Copy: all fields are Copy (explicit attachment)
// - Sized: has known size (implicit for all non-slice types)
//
// Thread safety via permissions (not marker behaviors):
// - const Token: safe to share across threads (immutable)
// - unique Token: safe to transfer via move (exclusive ownership)
```

#### §9.4.10 Conformance Requirements [generic.behavior.requirements]

[69] Implementations shall:

1. Support behavior declarations with visibility modifiers per §5.6
2. Require all behavior procedures to have concrete bodies (E10-401)
3. Support behavior extension with `with` clause
4. Detect and reject cyclic behavior extensions (E10-402)
5. Support associated types in behaviors with optional defaults
6. Validate associated type bounds at implementation site (E10-403)
7. Support generic behaviors with type, const, and grant parameters
8. Provide `Self` type binding within behavior bodies
9. Implement marker behaviors (Copy, Sized, Drop) per §10.4.5
10. Auto-derive Copy and Sized when structural requirements met
11. Validate explicit marker attachments match structural requirements (E10-411)
12. Enforce Copy/Drop mutual exclusion (E10-412)
13. Not provide Send/Sync marker behaviors (thread safety via permissions, Clause 14)
14. Integrate behaviors with witness system (forward to Clause 13)
15. Emit structured diagnostics for behavior violations


### §9.5 Behavior Implementations and Coherence [generic.implementation]

#### §9.5.1 Overview

[1] Types attach behaviors to gain the behavior's procedures and associated types. Cursive provides two implementation mechanisms:

- **Inline implementation**: Using `with Behavior` in the type declaration
- **Standalone implementation**: Separate `behavior B for T` declarations

[2] Both mechanisms are subject to coherence and orphan rules that ensure each (Behavior, Type) pair has at most one implementation visible in any compilation context.

[3] This subclause specifies implementation syntax, compatibility checking, coherence rules, orphan rules, blanket implementations, and the interaction with monomorphization.

#### §9.5.2 Inline Implementation Syntax [generic.implementation.inline]

[4] Inline implementations use the behavior clause in type declarations (§5.5.2):

**Record declarations with behaviors** match the pattern:
```
[ <visibility_modifier> ] "record" <identifier> [ <generic_params> ]
    [ <contract_clause> ] [ <behavior_clause> ] <record_body>
```

**Behavior clauses** match the pattern:
```
"with" <behavior_reference> [ "," <behavior_reference> ... ]
```

where each **behavior reference** is a `<type_expression>` that must resolve to a behavior.

[5] Example:

```cursive
record Point with Display, Clone {
    x: f64,
    y: f64,

    procedure show(~): string@View
    {
        result "Point"
    }

    procedure clone(~): Self
        [[ alloc::heap |- true => true ]]
    {
        result Point { x: self.x, y: self.y }
    }
}
```

[6] The behavior clause `with Display, Clone` attaches both behaviors to `Point`. Procedures implementing behavior methods appear in the record body.

#### §9.5.3 Standalone Implementation Syntax [generic.implementation.standalone]

[7] Standalone implementations use the following syntax:

**Behavior implementations** match the pattern:
```
[ <visibility_modifier> ] "behavior" <behavior_name> [ <generic_params> ]
    "for" <for_type> [ <where_clause> ] <implementation_body>
```

**For-type clauses** take one of the following forms:
```
<type_expression>
"for" "<" <generic_param_list> ">" <type_expression>
```

**Implementation bodies** match the pattern:
```
"{" [ <implementation_item> ... ] "}"
```

where each **implementation item** takes one of the following forms:
```
<associated_type_spec>
<procedure_declaration>
```

**Associated type specifications** match the pattern:
```
"type" <identifier> "=" <type_expression>
```

[ Note: See Annex A §A.7 [grammar.declaration] for complete behavior implementation grammar.
— end note ]

[8] Example:

```cursive
behavior Display for Point {
    procedure show(~): string@View
    {
        result "Point({}, {})".format(self.x, self.y)
    }
}
```

[9] Standalone implementations may appear at module scope and are subject to the same visibility and coherence rules as inline implementations.

#### §9.5.4 Implementation Requirements [generic.implementation.requirements]

##### §9.5.4.1 Completeness

[10] Behavior implementations must provide:

1. All associated type specifications required by the behavior
2. Procedure implementations for all behavior procedures (or use inherited defaults)

[11] **Completeness checking**:

[ Given: Behavior `P` declaring items `{I₁, ..., Iₙ}`, implementation for type `T` ]

$$
\frac{\forall i. \; \text{item } I_i \text{ is specified in implementation or has default}}{\text{behavior } P \text{ for } T \text{ complete}}
\tag{WF-Impl-Complete}
$$

[12] Incomplete implementations produce diagnostic E10-501 listing missing items.

##### §9.5.4.2 Procedure Signature Compatibility

[13] Procedure implementations must match behavior signatures:

- Parameter types must be equivalent (after substituting `Self`)
- Return type must be equivalent
- Receiver permission must match exactly
- Grants must be a subset of behavior grants (or equal)
- Preconditions may be weaker (accept more inputs)
- Postconditions may be stronger (guarantee more)

[14] **Signature compatibility**:

$$
\frac{
\begin{array}{c}
\text{predicate procedure: } m(self: \pi_P\, Self, p_1: \tau_1, \ldots) : \tau_r \; ! \varepsilon_P \; [[ G_P |- M_P => W_P ]] \\
\text{implementation: } m(self: \pi_I\, T, p_1: \upsilon_1, \ldots) : \upsilon_r \; ! \varepsilon_I \; [[ G_I |- M_I => W_I ]] \\
\pi_P = \pi_I \quad \tau_i \equiv \upsilon_i \quad \tau_r \equiv \upsilon_r \quad \varepsilon_I \subseteq \varepsilon_P \\
M_P \Rightarrow M_I \quad W_I \Rightarrow W_P
\end{array}
}{\text{procedure } m \text{ compatible}}
\tag{WF-Impl-Sig-Compat}
$$

[15] Incompatible signatures produce diagnostic E10-502 identifying the mismatched component.

##### §9.5.4.3 Associated Type Specification

[16] Associated types declared in behaviors must be specified in implementations:

```cursive
behavior Iterator {
    type Item = ()

    procedure next(~%): Item
    { result () }
}

behavior Iterator for Range {
    type Item = i32    // Required specification

    procedure next(~%): i32
    {
        // Implementation
    }
}
```

[17] Omitting required associated types produces diagnostic E10-503.

#### §9.5.5 Blanket Implementations [generic.implementation.blanket]

##### §9.5.5.1 Overview

[18] Blanket implementations provide behavior implementations for all types satisfying specified bounds. They enable deriving functionality for entire type families.

##### §9.5.5.2 Syntax

[19] Blanket implementation syntax uses the generic for-clause:

```cursive
behavior ToString for<T> T where T: Display {
    procedure to_string(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result self.show().to_managed()
    }
}
```

[20] The syntax `for<T> T where T: Display` declares a generic implementation: for all types `T` satisfying `Display`, implement `ToString`.

##### §9.5.5.3 Blanket Constraints

[21] Blanket implementations must:

1. Include a where clause constraining the type variable
2. Satisfy the orphan rule (§10.5.6): behavior must be local
3. Not overlap with other implementations (coherence, §10.5.7)

[22] Blanket implementations without where clauses are forbidden (diagnostic E10-504) as they would match all types, violating coherence.

##### §9.5.5.4 Resolution with Blanket Implementations

[23] When resolving behavior implementations (§10.6), the compiler checks:

1. Specific implementations (concrete type `T`)
2. Blanket implementations matching `T`'s bounds

[24] Specific implementations take precedence over blanket implementations. If multiple blanket implementations match, the most specific one is chosen (based on bound specificity).

[ Note: This edition does not support specialization (§10.5.8). If multiple blanket implementations could match without a clear specificity ordering, the program is ill-formed.
— end note ]

##### §9.5.5.5 Examples

**Example 10.5.5.1 (Blanket implementation):**

```cursive
behavior Display {
    procedure show(~): string@View
    {
        result "Display"
    }
}

behavior Debug {
    procedure debug(~): string@View
    {
        result "Debug"
    }
}

// Blanket: all Display types get Debug
behavior Debug for<T> T where T: Display {
    procedure debug(~): string@View
    {
        result "Debug: " ++ self.show()
    }
}

record Point with Display {
    x: f64,
    y: f64,

    procedure show(~): string@View
    {
        result "Point"
    }
}

// Point automatically gets Debug through blanket implementation
let p = Point { x: 1.0, y: 2.0 }
println("{}", p.debug())  // "Debug: Point"
```

#### §9.5.6 Orphan Rule [generic.implementation.orphan]

##### §9.5.6.1 Orphan Rule Statement

[25] A behavior implementation `behavior P for T` is permitted if and only if at least one of the following holds:

1. Behavior `P` is defined in the current module, OR
2. The outermost type constructor of `T` is defined in the current module

[26] **Orphan rule judgment**:

[ Given: Behavior `P`, type `T`, implementing module `M` ]

$$
\frac{P \in \text{Module}(M) \lor \text{outer}(T) \in \text{Module}(M)}{\text{behavior } P \text{ for } T \text{ in } M \text{ permitted}}
\tag{WF-Orphan-Allowed}
$$

[27] Implementations violating the orphan rule are ill-formed (diagnostic E10-505).

##### §9.5.6.2 Outermost Type Constructor

[28] For generic types, the _outermost type constructor_ is the top-level type name:

- `List<T>` → outermost is `List`
- `Pair<i32, string>` → outermost is `Pair`
- `Ptr<Buffer>@Valid` → outermost is `Ptr` (built-in)
- `(i32, i32)` → tuple (built-in structural type)

[29] For nested generics `Container<Inner<T>>`, the outermost constructor is `Container`.

##### §9.5.6.3 Rationale

[ Rationale: The orphan rule prevents conflicting implementations from different modules. Without it, two modules could each provide an implementation of the same behavior for the same external type, causing ambiguity. By requiring local definition of either the behavior or the type, coherence is maintained across separate compilation units.
— end rationale ]

##### §9.5.6.4 Orphan Rule for Blanket Implementations

[30] Blanket implementations must satisfy the orphan rule:

```cursive
// Module A defines Display
behavior Display { ... }

// Module A can provide blanket implementation
behavior ToString for<T> T where T: Display {
    // OK: Display is local to module A
}

// Module B CANNOT provide blanket over Display
// behavior Logging for<T> T where T: Display {
//     // error[E10-505]: orphan violation (Display not local)
// }
```

[31] The behavior referenced in the blanket must be local to satisfy the orphan rule.

##### §9.5.6.5 Examples

**Example 10.5.6.1 (Valid: local behavior):**

```cursive
// Module: my_app::display

public behavior PrettyPrint {
    procedure pretty(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result "pretty"
    }
}

// Valid: PrettyPrint is local
behavior PrettyPrint for std::collections::List {
    procedure pretty(~): string@Managed
    {
        result "List pretty"
    }
}
```

**Example 10.5.6.2 (Valid: local type):**

```cursive
// Module: my_app::types

public record MyType {
    value: i32,
}

// Valid: MyType is local
behavior std::display::Display for MyType {
    procedure show(~): string@View
    {
        result "MyType"
    }
}
```

**Example 10.5.6.3 - invalid (Orphan violation):**

```cursive
// Module: my_app::bad

// error[E10-505]: orphan rule violation
// Neither std::display::Display nor std::collections::List is local
behavior std::display::Display for std::collections::List {
    // Cannot implement external behavior for external type
}
```

#### §9.5.7 Coherence Rule [generic.implementation.coherence]

##### §9.5.7.1 Coherence Statement

[32] For any (Behavior, Type) pair, at most one implementation shall be visible within a compilation context. Multiple implementations produce diagnostic E10-506.

[33] **Coherence judgment**:

[ Given: Behavior `P`, type `T`, compilation unit set `U` ]

$$
\frac{|\{\text{impls of } P \text{ for } T \text{ in } U\}| > 1}{\text{ERROR E10-506: duplicate behavior implementation}}
\tag{WF-Coherence-Unique}
$$

##### §9.5.7.2 Coherence Checking

[34] Coherence checking occurs during module compilation. The compiler verifies that:

1. No duplicate inline implementations (multiple `with P` clauses for same behavior)
2. No conflicts between inline and standalone implementations for the same behavior
3. No overlapping blanket implementations
4. Cross-module implementations respect orphan rules

[35] Coherence violations are fatal errors; the program is ill-formed until resolved.

##### §9.5.7.3 Blanket Implementation Overlap

[36] Two blanket implementations overlap when both could match the same type:

```cursive
// Overlapping blanket implementations (ill-formed)

behavior Printer for<T> T where T: Display {
    // Implementation 1
}

behavior Printer for<T> T where T: Debug {
    // Implementation 2
}

// error[E10-507]: overlapping blanket implementations
// If a type satisfies both Display and Debug, which behavior applies?
```

[37] Implementations shall not overlap. The compiler detects overlap by checking whether bound constraints could be simultaneously satisfied.

[38] **Overlap detection**:

$$
\frac{\exists \tau. \; \tau : B_1 \land \tau : B_2}{\text{blanket impls with bounds } B_1 \text{ and } B_2 \text{ overlap}}
\tag{WF-Overlap-Detect}
$$

[39] Overlapping blanket implementations produce diagnostic E10-507 identifying both implementations and suggesting bound refinement.

##### §9.5.7.4 Coherence Examples

**Example 10.5.7.1 (Valid: non-overlapping blankets):**

```cursive
behavior ShowInt {
    procedure show_as_int(~): i32
    {
        result 0
    }
}

// Non-overlapping: disjoint bounds
behavior ShowInt for<T> T where T: NumericType {
    // Only numeric types
}

behavior ShowInt for<T> T where T: Container {
    // Only container types
}

// OK if NumericType and Container are mutually exclusive
```

**Example 10.5.7.2 - invalid (Duplicate implementation):**

```cursive
record Data with Display {
    procedure show(~): string@View
    { result "Data1" }
}

behavior Display for Data {
    procedure show(~): string@View
    { result "Data2" }
}

// error[E10-506]: Data has two implementations of Display
```

#### §9.5.8 No Specialization [generic.implementation.specialization]

[40] Cursive does not support implementation specialization. Each (Behavior, Type) pair may have exactly one implementation; more specific implementations cannot override more general ones.

[41] The following pattern is **not** supported:

```cursive
// NOT SUPPORTED: Specialization

behavior Formatter for<T> T {
    // General implementation
}

behavior Formatter for i32 {
    // Specialized for i32 - NOT ALLOWED
}
```

[42] Attempting to provide specialized implementations alongside blanket implementations produces coherence error E10-506 or overlap error E10-507.

[ Rationale: Specialization adds substantial complexity to coherence checking and type resolution. The current specification prioritizes predictability and deterministic dispatch. Future editions may introduce specialization if field experience demonstrates clear necessity, but the design must maintain the deterministic resolution guarantee.
— end rationale ]

#### §9.5.9 Method Override and Associated Type Override [generic.implementation.override]

##### §9.5.9.1 Procedure Override

[43] When attaching a behavior with `with Behavior`, types may override behavior procedures by providing custom implementations in the type body:

```cursive
behavior Display {
    procedure show(~): string@View
    {
        result type_name::<Self>()  // Default
    }
}

record Custom with Display {
    value: i32,

    procedure show(~): string@View
    {
        result "Custom: " ++ self.value.to_string()  // Override
    }
}
```

[44] Overridden procedures must be signature-compatible per §10.5.4.2.

##### §9.5.9.2 Using Inherited Defaults

[45] Types may omit procedure implementations to inherit behavior defaults:

```cursive
record Simple with Display {
    // No show() implementation provided
    // Inherits default from Display behavior
}

let s = Simple {}
println("{}", s.show())  // Uses inherited default
```

##### §9.5.9.3 Associated Type Override

[46] Types override associated type defaults by specifying the associated type in the implementation:

```cursive
behavior Producer {
    type Output = ()

    procedure produce(~): Output
    { result () }
}

record IntProducer with Producer {
    type Output = i32    // Override default

    value: i32,

    procedure produce(~): i32
    {
        result self.value
    }
}
```

#### §9.5.10 Generic Implementations [generic.implementation.generic]

##### §9.5.10.1 Generic Behavior for Generic Type

[47] When both behavior and type are generic, implementation parameters must be compatible:

```cursive
behavior Converter<U> {
    procedure convert(~): U
    {
        panic("Not implemented")
    }
}

record Wrapper<T> {
    value: T,
}

behavior Converter<string@Managed> for<T> Wrapper<T> where T: Display {
    procedure convert(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result self.value.show().to_managed()
    }
}
```

[48] The implementation `for<T> Wrapper<T>` is generic over `T`. Instantiation of `Wrapper<ConcreteType>` requires `ConcreteType: Display` for the behavior implementation to apply.

##### §9.5.10.2 Parameter Substitution

[49] During implementation checking, generic parameters are substituted:

- Type parameters from the behavior are instantiated with implementation arguments
- Type parameters from the implementing type are universally quantified
- Bounds are checked after substitution

$$
\frac{
\begin{array}{c}
\text{behavior } P\langle\alpha\rangle \text{ for } T\langle\beta\rangle \quad \text{where } \beta : B \\
\text{behavior } P\langle\tau\rangle \text{ declared} \quad T\langle\beta\rangle \text{ declared}
\end{array}
}{\text{implementation valid if bounds and signatures match after substitution}}
\tag{WF-Impl-Generic}
$$

#### §9.5.11 Diagnostics [generic.implementation.diagnostics]

[50] Behavior implementation diagnostics:

| Code    | Condition                                               |
| ------- | ------------------------------------------------------- |
| E10-501 | Incomplete implementation (missing procedures or types) |
| E10-502 | Procedure signature incompatible with behavior          |
| E10-503 | Associated type specification missing                   |
| E10-504 | Blanket implementation lacks where clause               |
| E10-505 | Orphan rule violation                                   |
| E10-506 | Duplicate implementation (coherence violation)          |
| E10-507 | Overlapping blanket implementations                     |
| E10-508 | Implementation for non-predicate (e.g., contract)       |
| E10-509 | Implementation type does not exist or is not visible    |
| E10-510 | Generic implementation parameter mismatch               |

#### §9.5.12 Examples [generic.implementation.examples]

**Example 10.5.12.1 (Complete standalone implementation):**

```cursive
behavior Serializable {
    type Format = string@View

    procedure serialize(~): Self::Format
        [[ alloc::heap |- true => true ]]
    {
        result "default serialization"
    }
}

record User {
    id: u64,
    name: string@Managed,
}

behavior Serializable for User {
    type Format = string@Managed    // Override default

    procedure serialize(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result "User(id=" ++ self.id.to_string() ++ ", name=" ++ self.name ++ ")"
    }
}
```

**Example 10.5.12.2 (Inline implementation with override):**

```cursive
behavior Formatter {
    procedure format(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result type_name::<Self>()
    }

    procedure format_verbose(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result "Verbose: " ++ self.format()
    }
}

record Status with Formatter {
    code: i32,

    procedure format(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result "Status(" ++ self.code.to_string() ++ ")"
    }

    // format_verbose() inherited from Formatter behavior
}
```

**Example 10.5.12.3 (Blanket with nested generics):**

```cursive
behavior Display {
    procedure show(~): string@View
    { result "Display" }
}

behavior Display for<T> (T, T) where T: Display {
    procedure show(~): string@View
    {
        result "(" ++ self.0.show() ++ ", " ++ self.1.show() ++ ")"
    }
}

// Applies to any tuple (T, T) where T: Display
let pair = (Point {x: 1.0, y: 2.0}, Point {x: 3.0, y: 4.0})
println("{}", pair.show())  // Uses blanket implementation
```

**Example 10.5.12.4 - invalid (Orphan violation):**

```cursive
// Module: third_party

// error[E10-505]: orphan rule violation
// Cannot implement external behavior for external type
behavior std::fmt::Display for std::collections::List {
    procedure show(~): string@View
    {
        result "List"
    }
}
```

**Example 10.5.12.5 - invalid (Overlapping blankets):**

```cursive
behavior Logger {
    procedure log(~, message: string@View)
        [[ io::write |- true => true ]]
    {
        println("{}", message)
    }
}

// Implementation 1
behavior Logger for<T> T where T: Display {
    procedure log(~, message: string@View)
        [[ io::write |- true => true ]]
    {
        println("{}: {}", self.show(), message)
    }
}

// Implementation 2 - OVERLAPS with Implementation 1
behavior Logger for<T> T where T: Debug {
    procedure log(~, message: string@View)
        [[ io::write |- true => true ]]
    {
        println("{}: {}", self.debug(), message)
    }
}

// error[E10-507]: overlapping blanket implementations
// Type satisfying both Display and Debug is ambiguous
```

#### §9.5.13 Conformance Requirements [generic.implementation.requirements]

[51] Implementations shall:

1. Support inline behavior attachment via `with Behavior` clause
2. Support standalone behavior implementations via `behavior P for T`
3. Support blanket implementations via `behavior P for<T> T where ...`
4. Enforce that all behavior procedures and associated types are provided
5. Check procedure signature compatibility (parameters, return, receiver, grants, sequent)
6. Enforce orphan rule: require local behavior or local type constructor (E10-505)
7. Enforce coherence: reject duplicate implementations (E10-506)
8. Detect overlapping blanket implementations (E10-507)
9. Support procedure override in inline implementations
10. Support associated type override in implementations
11. Allow inherited defaults when override not provided
12. Integrate with monomorphization (§10.6) for code generation
13. Emit structured diagnostics for violations (Annex E §E.5)


### §9.6 Resolution and Monomorphization [generic.resolution]

#### §9.6.1 Overview

[1] Resolution is the process of determining concrete type, const, and grant arguments for generic parameters. Monomorphization generates specialized code for each distinct instantiation, ensuring zero runtime overhead for generic abstractions.

[2] This subclause specifies the resolution algorithm, type argument inference, explicit instantiation with turbofish syntax, monomorphization semantics, and the interaction with behavior dispatch.

[3] Resolution occurs during the type-checking phase (§2.2.4.3) after name resolution completes. Monomorphization occurs during code generation (§2.2.4.4), producing specialized procedures and types for each instantiation.

#### §9.6.2 Resolution Algorithm [generic.resolution.algorithm]

##### §9.6.2.1 Resolution Overview

[4] Generic resolution determines arguments for type, const, and grant parameters through:

1. **Explicit arguments**: Turbofish syntax `function::<Type>()`
2. **Inference from call site**: Argument types, return type context
3. **Inference from bounds**: Associated type constraints, grant usage
4. **Default values**: Parameters with defaults (§10.2.6)

[5] Resolution attempts these strategies in order. If all fail, diagnostic E09-601 requests explicit type arguments.

##### §9.6.2.2 Resolution Judgment

[6] Resolution is formalized as:

$$
\text{resolve}(\Gamma, e, \langle\alpha_1, \ldots, \alpha_n\rangle) = \langle\tau_1, \ldots, \tau_n\rangle
$$

where:

- $\Gamma$ is the typing environment
- $e$ is the expression requiring resolution
- $\langle\alpha_1, \ldots, \alpha_n\rangle$ are generic parameters
- $\langle\tau_1, \ldots, \tau_n\rangle$ are resolved concrete arguments

[7] The resolution algorithm is specified in Annex E §E.2.4 [implementation.algorithms.predicate]. The following paragraphs summarize the normative requirements.

##### §9.6.2.3 Explicit Type Arguments

[8] When explicit type arguments are provided via turbofish syntax, resolution uses them directly:

$$
\frac{\text{call } f::\langle\tau_1, \ldots, \tau_n\rangle(\ldots)}{\text{resolve}(f) = \langle\tau_1, \ldots, \tau_n\rangle}
\tag{Resolve-Explicit}
$$

[9] Explicit arguments bypass inference. The compiler validates that:

- Argument count matches parameter count (or defaults fill remaining)
- Each argument satisfies the corresponding parameter's bounds
- Arguments are well-formed types in the current context

##### §9.6.2.4 Type Inference from Arguments

[10] When explicit arguments are absent, the compiler infers type parameters from procedure arguments:

$$
\frac{
\begin{array}{c}
\text{procedure } f\langle T \rangle(x: T) \\
\text{call } f(e) \quad \Gamma \vdash e : \tau
\end{array}
}{\text{resolve}(T) = \tau}
\tag{Resolve-From-Arg}
$$

[11] The unification algorithm matches formal parameter types against actual argument types, solving for type variables.

##### §9.6.2.5 Type Inference from Context

[12] Return type context contributes to inference:

$$
\frac{
\begin{array}{c}
\text{procedure } f\langle T \rangle() : T \\
\text{binding } let x: \tau = f() \\
\end{array}
}{\text{resolve}(T) = \tau}
\tag{Resolve-From-Context}
$$

[13] Bidirectional type checking (§8.1.6) flows contextual type information into the resolution algorithm.

##### §9.6.2.6 Const Parameter Inference

[14] Const parameters are inferred from:

- Explicit arguments: `buffer::<1024>()`
- Array length context: `let arr: [T; 512] = create_array()` infers `N = 512`
- Default values when no other information is available

[15] Const inference follows the same unification rules as type inference, treating const values as compile-time constants.

##### §9.6.2.7 Grant Parameter Inference

[16] Grant parameters are inferred from callable arguments:

$$
\frac{
\begin{array}{c}
\text{procedure } g\langle\varepsilon\rangle(f: () \to T \; ! \varepsilon) \\
\text{call } g(h) \quad h : () \to U \; ! \varepsilon'
\end{array}
}{\text{resolve}(\varepsilon) = \varepsilon'}
\tag{Resolve-Grant}
$$

[17] The grant set of the actual callable argument becomes the grant parameter's value.

##### §9.6.2.8 Inference Failure

[18] When inference cannot determine a unique solution, the compiler emits diagnostic E09-601 requesting explicit type arguments:

$$
\frac{\text{resolve}(\Gamma, e, \langle\alpha_1, \ldots\rangle) = \text{ambiguous}}{\text{ERROR E09-601: cannot infer type arguments}}
\tag{Resolve-Fail}
$$

[19] The diagnostic includes:

- Which parameters could not be inferred
- Partial inference results (if any)
- Suggested turbofish syntax with inferred and placeholder arguments

#### §9.6.3 Bound Checking [generic.resolution.bounds]

[20] After type arguments are resolved, the compiler checks that each argument satisfies its parameter's bounds:

```
check_bounds(params, args):
    for each (param, arg) in zip(params, args):
        for bound in bounds(param):
            if bound is behavior P:
                verify: behavior P for arg exists
                if not: error E09-602
            if bound is contract C:
                verify: arg: C declared
                if not: error E09-603
            if bound is associated type equality T::A = U:
                resolve: arg::A
                verify: arg::A ≡ U
                if not: error E09-604
            if bound is grant bound ε ⊆ G:
                verify: arg ⊆ G
                if not: error E09-605
```

[21] Bound violations produce diagnostics identifying the parameter, bound, and actual argument.

#### §9.6.4 Monomorphization [generic.resolution.monomorphization]

##### §9.6.4.1 Overview

[22] Monomorphization generates specialized code for each distinct instantiation of a generic procedure or type. The process occurs during code generation (§2.2.4.4) after type checking completes.

[23] Each instantiation `Generic<ConcreteArgs>` produces a separate entity in the generated code. Generic source code exists only at compile time; runtime code contains only monomorphized specializations.

##### §9.6.4.2 Monomorphization Process

[24] The monomorphization algorithm:

```
monomorphize(entity, type_args, const_args, grant_args):
    1. Substitute type parameters with type arguments
    2. Substitute const parameters with const values
    3. Substitute grant parameters with grant sets
    4. Resolve associated type projections to concrete types
    5. Generate specialized entity with substituted types
    6. Perform type checking on specialized entity
    7. Emit specialized code
```

[25] **Substitution judgment**:

$$
\frac{
\begin{array}{c}
\text{procedure } f\langle T, \text{const } N, \varepsilon \rangle \\
\text{instantiation } f\langle\tau, n, G\rangle
\end{array}
}{f\langle\tau, n, G\rangle \equiv f[\alpha \mapsto \tau, N \mapsto n, \varepsilon \mapsto G]}
\tag{Mono-Subst}
$$

[26] After substitution, the specialized entity is a concrete procedure or type with no remaining generic parameters.

##### §9.6.4.3 Distinct Instantiations

[27] Each distinct combination of type, const, and grant arguments produces a separate instantiation:

```cursive
procedure identity<T>(value: T): T
{
    result value
}

let a = identity(42)          // Instantiation 1: T = i32
let b = identity("hello")     // Instantiation 2: T = string@View
let c = identity(3.14)        // Instantiation 3: T = f64
```

[28] Three instantiations are generated: `identity_i32`, `identity_string_View`, `identity_f64` (names are illustrative; actual mangled names are implementation-defined).

##### §9.6.4.4 Code Sharing and Optimization

[29] Implementations may share code between compatible instantiations provided observable behavior is preserved. For example, pointer instantiations `Generic<T>` and `Generic<U>` with identical layouts may share compiled code.

[30] Such sharing is a quality-of-implementation optimization and shall not affect semantics. Programs must behave as if each instantiation were compiled independently.

##### §9.6.4.5 Monomorphization and Behaviors

[31] Behavior procedure calls are monomorphized: the compiler selects the specific implementation for the concrete type and generates a direct call:

$$
\frac{
\begin{array}{c}
\Gamma \vdash e : T \quad \text{behavior } P \text{ for } T \text{ exists} \\
\text{behavior } P \{ \text{procedure } m \}
\end{array}
}{\Gamma \vdash e.m() \Rightarrow T.m() \text{ (direct call)}}
\tag{Mono-Pred-Call}
$$

[32] No vtable lookup or indirection occurs; behavior dispatch is fully static.

#### §9.6.5 Associated Type Resolution [generic.resolution.assoc]

##### §9.6.5.1 Projection Resolution

[33] Associated type projections `T::AssocType` are resolved during monomorphization:

```
resolve_projection(T::A):
    1. Resolve T to concrete type τ
    2. Find behavior or contract implementation for τ
    3. Extract associated type specification: type A = υ
    4. Replace T::A with υ
    5. Recursively resolve if υ contains projections
```

[34] **Resolution rule**:

$$
\frac{
\begin{array}{c}
\Gamma \vdash T \equiv \tau \quad \text{behavior } P \text{ for } \tau \{ \text{type } A = \upsilon \}
\end{array}
}{\Gamma \vdash T::A \equiv \upsilon}
\tag{Resolve-Assoc}
$$

##### §9.6.5.2 Nested Projections

[35] Projections may be nested: `T::Container::Element`. Resolution proceeds left-to-right:

1. Resolve `T::Container` to type `τ₁`
2. Resolve `τ₁::Element` to type `τ₂`
3. Final result is `τ₂`

[36] Cyclic projections are detected during resolution and produce diagnostic E09-606.

##### §9.6.5.3 Examples

**Example 10.6.5.1 (Associated type resolution):**

```cursive
behavior Container {
    type Element = ()

    procedure get(~, index: usize): Element
    { result () }
}

behavior Container for List<T> {
    type Element = T

    procedure get(~, index: usize): T
    {
        result self.data[index]
    }
}

procedure first<C>(container: C): C::Element
    where C: Container
{
    result container.get(0)
}

let list: List<i32> = List::from([1, 2, 3])
let value = first(list)
// C = List<i32>
// C::Element = i32 (via projection resolution)
// value: i32
```

#### §9.6.6 Zero-Cost Abstraction [generic.resolution.zerocost]

##### §9.6.6.1 Zero-Cost Guarantee

[37] Generic abstractions shall impose no runtime overhead beyond the equivalent hand-written specialized code. Monomorphization ensures:

- No indirection or vtable lookup for behavior calls
- No runtime type information for generic parameters
- No boxing or allocation for generic values
- Identical assembly output to specialized non-generic code

[38] **Performance property**:

$$
\text{perf}(\text{generic code}) = \text{perf}(\text{hand-specialized equivalent})
\tag{Prop-Zero-Cost}
$$

[39] The only cost is compile time (monomorphization analysis) and code size (multiple instantiations).

##### §9.6.6.2 Code Size Implications

[40] Each distinct instantiation generates separate machine code. Programs with many generic instantiations may have larger binaries:

```cursive
procedure process<T>(value: T): T
{
    result value
}

// 100 different types used with process
// → 100 instantiations in binary
```

[41] Implementations may apply code sharing optimizations (§10.6.4.4) provided semantics are preserved. Programs requiring minimal code size should limit generic usage or use dynamic dispatch via witnesses (Clause 12).

#### §9.6.7 Behavior Method Resolution [generic.resolution.behavior]

##### §9.6.7.1 Resolution Algorithm

[42] When a behavior method is called, resolution proceeds:

```
resolve_predicate_call(receiver_type, behavior, method):
    1. Determine concrete type τ of receiver
    2. Find behavior implementation: behavior P for τ
    3. Locate method in implementation:
       a. Check for override in implementation body
       b. If not found, use default from behavior declaration
    4. Generate direct call to selected method
    5. Validate grants and permissions
```

[43] Method resolution is deterministic and occurs at compile time. No runtime dispatch is involved.

##### §9.6.7.2 Override Selection

[44] When a type overrides a behavior method, the override takes precedence:

$$
\frac{
\begin{array}{c}
\text{behavior } P \text{ for } \tau \{ \text{procedure } m \{ \text{body}_{\text{override}} \} \} \\
\text{predicate } P \{ \text{procedure } m \{ \text{body}_{\text{default}} \} \}
\end{array}
}{\text{call } \tau.m() \Rightarrow \text{body}_{\text{override}}}
\tag{Resolve-Override}
$$

[45] Inherited defaults are used only when no override is provided:

$$
\frac{
\begin{array}{c}
\text{behavior } P \text{ for } \tau \{ \text{no procedure } m \} \\
\text{predicate } P \{ \text{procedure } m \{ \text{body}_{\text{default}} \} \}
\end{array}
}{\text{call } \tau.m() \Rightarrow \text{body}_{\text{default}}[\text{Self} \mapsto \tau]}
\tag{Resolve-Inherit}
$$

##### §9.6.7.3 Blanket Implementation Resolution

[46] When multiple behavior implementations could apply (specific vs blanket), resolution prefers specific implementations:

1. Check for direct implementation: `behavior P for ConcreteType`
2. If not found, check blanket implementations matching type's bounds
3. If multiple blankets match, error E09-607 (ambiguous implementation)
4. If no implementation found, error E09-608 (behavior not satisfied)

[47] This ordering ensures that specific implementations can specialize behavior without conflicting with blanket defaults.

##### §9.6.7.4 Examples

**Example 10.6.7.1 (Method resolution with override):**

```cursive
behavior Display {
    procedure show(~): string@View
    {
        result type_name::<Self>()  // Default
    }
}

record Point with Display {
    x: f64,
    y: f64,

    procedure show(~): string@View
    {
        result "Point"  // Override
    }
}

record Generic with Display {
    // No override - uses inherited default
}

println("{}", Point{x:1.0, y:2.0}.show())  // "Point" (override)
println("{}", Generic{}.show())             // "Generic" (inherited default)
```

#### §9.6.8 Constraint Solving [generic.resolution.constraints]

##### §9.6.8.1 Constraint Generation

[48] During type checking, the compiler generates constraints for generic parameters:

```
Constraint ::= τ₁ ≡ τ₂              (equality)
             | τ : Behavior         (bound)
             | τ::A ≡ υ              (associated type)
             | ε ⊆ G                 (grant subset)
```

[49] Constraints are collected from:

- Procedure call arguments and return types
- Pattern matches and variable bindings
- Behavior bounds and where clauses
- Associated type projections

##### §9.6.8.2 Constraint Solving

[50] The solver attempts to find a solution satisfying all constraints:

```
solve_constraints(constraints):
    unification_map = {}

    // Phase 1: Equality constraints
    for constraint (τ₁ ≡ τ₂):
        unify(τ₁, τ₂, unification_map)
        if unification fails:
            error E09-609 (type mismatch)

    // Phase 2: Bound constraints
    for constraint (τ : P):
        verify: behavior P for τ exists after substitution
        if not found:
            error E09-602 (unsatisfied bound)

    // Phase 3: Associated type constraints
    for constraint (τ::A ≡ υ):
        resolve: τ::A to concrete type υ'
        verify: υ' ≡ υ
        if not: error E10-604

    // Phase 4: Grant constraints
    for constraint (ε ⊆ G):
        verify: ε ⊆ G after substitution
        if not: error E10-605

    return unification_map
```

[51] The algorithm is specified formally in Annex E §E.2.4 with correctness proofs.

##### §9.6.8.3 Principal Type

[52] When constraint solving succeeds, the result is the _principal type_ (§1.3[25]): the most general type satisfying all constraints.

$$
\text{principal}(\Gamma, e) = \tau \quad \text{iff} \quad \Gamma \vdash e : \tau \text{ and } \forall \tau'. \; \Gamma \vdash e : \tau' \Rightarrow \tau' <: \tau
\tag{Principal-Type}
$$

[53] The principal type is unique when it exists. Ambiguous cases where no principal type exists produce diagnostic E09-610.

#### §9.6.9 Monomorphization Instantiation [generic.resolution.instantiation]

##### §9.6.9.1 Instantiation Cache

[54] The compiler maintains a cache of instantiated generics. When a generic is used with previously seen arguments, the existing instantiation is reused:

```
instantiate(generic, args):
    cache_key = (generic, args)
    if cache_key in instantiation_cache:
        return instantiation_cache[cache_key]

    specialized = monomorphize(generic, args)
    instantiation_cache[cache_key] = specialized
    return specialized
```

[55] This ensures that `List<i32>` used in multiple locations generates code only once.

##### §9.6.9.2 Recursive Instantiation

[56] Generic types may recursively instantiate themselves:

```cursive
record Tree<T> {
    value: T,
    left: Ptr<Tree<T>>@Valid,
    right: Ptr<Tree<T>>@Valid,
}
```

[57] Recursive instantiation is permitted provided the recursion is guarded by indirection (pointers). Direct recursion without indirection creates infinite-size types and is rejected (diagnostic E10-611, inherited from §5.5.3[15]).

##### §9.6.9.3 Monomorphization Limits

[58] Implementations shall support at least:

- 1024 distinct instantiations of a single generic entity
- 32 levels of nested generic instantiation depth
- 256 generic parameters in a single entity

[59] Exceeding these limits may produce diagnostic E10-612 (monomorphization limit exceeded). Implementations should document actual limits.

#### §9.6.10 Diagnostics [generic.resolution.diagnostics]

[60] Resolution and monomorphization diagnostics:

| Code    | Condition                                                |
| ------- | -------------------------------------------------------- |
| E10-601 | Cannot infer type arguments; explicit turbofish required |
| E10-602 | Type argument does not satisfy behavior bound            |
| E10-603 | Type argument does not satisfy contract bound            |
| E10-604 | Associated type constraint not satisfied                 |
| E10-605 | Grant parameter exceeds bound                            |
| E10-606 | Cyclic associated type projection                        |
| E10-607 | Ambiguous blanket implementation (multiple match)        |
| E10-608 | Behavior not satisfied for type                          |
| E10-609 | Type unification failed                                  |
| E10-610 | No principal type exists (ambiguous inference)           |
| E10-611 | Infinite-size recursive type                             |
| E10-612 | Monomorphization limit exceeded                          |

#### §9.6.11 Examples [generic.resolution.examples]

**Example 10.6.11.1 (Complete resolution example):**

```cursive
behavior Converter<U> {
    procedure convert(~): U
    {
        panic("not implemented")
    }
}

behavior Converter<string@Managed> for i32 {
    procedure convert(~): string@Managed
        [[ alloc::heap |- true => true ]]
    {
        result string.from_int(self)
    }
}

procedure transform<T, U>(value: T): U
    where T: Converter<U>
{
    result value.convert()
}

let s: string@Managed = transform(42)
// T inferred as i32 from argument
// U inferred as string@Managed from return context
// Bound check: i32: Converter<string@Managed> ✓
// Monomorphize: transform_i32_string_Managed
// Behavior call: 42.convert() → i32::convert() → direct call
```

**Example 10.6.11.2 (Grant parameter resolution):**

```cursive
procedure apply<T, U, ε>(value: T, f: (T) -> U ! ε): U
    [[ ε |- true => true ]]
{
    result f(value)
}

let pure = |x: i32| { result x * 2 }
let doubled = apply(5, pure)
// T = i32 (from first argument)
// U = i32 (from closure return)
// ε = ∅ (from closure grant set)
// Monomorphize: apply_i32_i32_empty

let logger = |x: i32| [[ io::write |- true => true ]] {
    println("{}", x)
    result x
}
let logged = apply(5, logger)
// T = i32
// U = i32
// ε = {io::write}
// Monomorphize: apply_i32_i32_io_write
```

**Example 10.6.11.3 (Inference failure requiring turbofish):**

```cursive
procedure convert<T, U>(): U
    where T: Into<U>
{
    result T::default().into()
}

// error[E10-601]: cannot infer T (no argument provides hint)
// let value = convert()

// Fixed with turbofish:
let value = convert::<i32, string@Managed>()
```

#### §9.6.12 Conformance Requirements [generic.resolution.requirements]

[61] Implementations shall:

1. Implement resolution algorithm inferring type, const, and grant arguments
2. Support explicit type arguments via turbofish syntax
3. Perform bound checking after resolution completes
4. Generate specialized code for each distinct instantiation via monomorphization
5. Cache and reuse instantiations with identical arguments
6. Resolve associated type projections to concrete types
7. Select behavior method implementations (override > inherited default)
8. Prefer specific implementations over blanket implementations
9. Guarantee zero runtime overhead: monomorphized code equivalent to hand-specialized
10. Support recursive generic types with indirection
11. Document and enforce monomorphization limits
12. Emit diagnostics E10-601 through E10-612 for resolution and monomorphization failures
13. Provide structured diagnostic payloads (Annex E §E.5) including inference state
14. Integrate with code generation phase (§2.2.4.4) for emission


### §9.7 Variance and Its Inference [generic.variance]

#### §9.7.1 Overview

[1] Variance describes how subtyping of type parameters relates to subtyping of generic type constructors. Understanding variance is essential for determining when generic types may substitute for one another and for ensuring type safety in the presence of mutable references and permissions.

[2] Cursive employs a conservative variance model: most type constructors are invariant, ensuring that generic types are used with precise type arguments. Variance becomes relevant primarily for callable types, where contravariance in parameters and covariance in results enable flexible higher-order programming.

[3] This subclause defines variance categories, specifies variance for each Cursive type constructor, describes the inference algorithm, and provides examples illustrating variance in practice.

#### §9.7.2 Variance Definitions [generic.variance.definitions]

##### §9.7.2.1 Covariance

[4] A type constructor `F` is _covariant_ in parameter `T` when subtyping is preserved:

$$
\frac{\tau <: \upsilon}{F\langle\tau\rangle <: F\langle\upsilon\rangle}
\tag{Variance-Covariant}
$$

[5] Covariant positions allow substituting more specific types with more general types. Example: if `F` is covariant and `Cat <: Animal`, then `F<Cat> <: F<Animal>`.

##### §9.7.2.2 Contravariance

[6] A type constructor `F` is _contravariant_ in parameter `T` when subtyping is reversed:

$$
\frac{\tau <: \upsilon}{F\langle\upsilon\rangle <: F\langle\tau\rangle}
\tag{Variance-Contravariant}
$$

[7] Contravariant positions flip the subtyping direction. Example: if `F` is contravariant and `Cat <: Animal`, then `F<Animal> <: F<Cat>`.

##### §9.7.2.3 Invariance

[8] A type constructor `F` is _invariant_ in parameter `T` when no subtyping relationship holds except through equivalence:

$$
\frac{\tau \equiv \upsilon}{F\langle\tau\rangle <: F\langle\upsilon\rangle} \quad \text{(no other subtyping)}
\tag{Variance-Invariant}
$$

[9] Invariant positions require exact type matching. Most Cursive type constructors are invariant to preserve safety with mutable references and permissions.

#### §9.7.3 Variance Table [generic.variance.table]

[10] Table 10.7.1 specifies variance for all Cursive type constructors:

**Table 10.7.1 — Type constructor variance**

| Type Constructor                    | Variance in Parameters                              | Rationale                                        |
| ----------------------------------- | --------------------------------------------------- | ------------------------------------------------ |
| Primitives (`i32`, `bool`, etc.)    | N/A (not generic)                                   | No parameters                                    |
| Tuples `(T₁, ..., Tₙ)`              | Invariant in all `Tᵢ`                               | Mutation requires exact type matching            |
| Records `Record<T>`                 | Invariant in all parameters                         | Nominal types, field mutation requires exactness |
| Enums `Enum<T>`                     | Invariant in all parameters                         | Variant safety, discriminant integrity           |
| Modal types `Modal<T>@State`        | Invariant in `T`, state-specific                    | State machine integrity                          |
| Arrays `[T; n]`                     | Invariant in `T`                                    | Element mutation requires type preservation      |
| Slices `[T]`                        | Invariant in `T`                                    | Mutation through slices requires exact type      |
| Pointers `Ptr<T>@State`             | Invariant in `T`, covariant in state widening       | Dereference safety, modal subtyping (§7.7.3)     |
| Union types `T₁ \/ T₂ \/ ... \/ Tₙ` | Covariant in all `Tᵢ`                               | Each `Tᵢ <: T₁ \/ ... \/ Tₙ` by construction     |
| Callable types (parameters)         | Contravariant in each parameter `Tᵢ`                | Accept more general inputs                       |
| Callable types (return)             | Covariant in return type `R`                        | Return more specific outputs                     |
| Callable types (grants)             | Contravariant in grant set `ε` (fewer is stronger)  | Fewer grants = more specific callable            |
| Callable types (must)               | Contravariant in preconditions                      | Weaker preconditions accept more inputs          |
| Callable types (will)               | Covariant in postconditions                         | Stronger postconditions guarantee more           |
| Permission qualification            | Covariant in downgrade: `unique <: shared <: const` | Permission lattice (§11.4.3)                     |

[11] Generic parameters in user-defined types default to invariant unless the type constructor is purely read-only and structurally covariant.

#### §9.7.4 Callable Type Variance [generic.variance.callable]

##### §9.7.4.1 Function Subtyping with Variance

[12] Callable types exhibit complex variance patterns captured by the subtyping rule:

$$
\frac{
\begin{array}{c}
\upsilon_1 <: \tau_1 \quad \cdots \quad \upsilon_n <: \tau_n \\
\tau_r <: \upsilon_r \\
\varepsilon_1 \subseteq \varepsilon_2 \\
M_2 \Rightarrow M_1 \quad W_1 \Rightarrow W_2
\end{array}
}{
(\tau_1, \ldots, \tau_n) \to \tau_r \; ! \varepsilon_1 \; [[ |- M_1 => W_1 ]]
<:
(\upsilon_1, \ldots, \upsilon_n) \to \upsilon_r \; ! \varepsilon_2 \; [[ |- M_2 => W_2 ]]
}
\tag{Sub-Function-Variance}
$$

[13] Variance summary for callable types:

- **Parameters**: Contravariant (accept more general inputs)
- **Return**: Covariant (return more specific outputs)
- **Grants**: Contravariant (fewer grants is stronger/more specific)
- **Preconditions (must)**: Contravariant (weaker preconditions accept more)
- **Postconditions (will)**: Covariant (stronger postconditions guarantee more)

##### §9.7.4.2 Examples

**Example 10.7.4.1 (Function parameter contravariance):**

```cursive
record Animal {
    name: string@Managed,
}

record Cat {
    name: string@Managed,
    meow_volume: i32,
}

// Assuming Cat <: Animal (structural subtyping hypothetically)
// (Animal) -> () is a supertype of (Cat) -> ()
// Functions accepting animals can accept functions expecting cats? No.

// In Cursive: nominal types are invariant
// This example illustrates the principle, not actual Cursive subtyping
```

**Example 10.7.4.2 (Function grant contravariance):**

```cursive
// Pure function (no grants)
let pure: (i32) -> i32 = |x| { result x * 2 }

// Function with grants
let writer: (i32) -> i32 ! {io::write} = pure

// Subtyping: (i32) -> i32 ! ∅ <: (i32) -> i32 ! {io::write}
// Pure function (fewer grants) is more specific than grant-requiring function
```

#### §9.7.5 Permission Variance [generic.variance.permission]

##### §9.7.5.1 Permission Lattice Variance

[14] Permission qualifiers exhibit covariant subtyping following the permission lattice (§11.4.3):

$$
\text{unique } T <: \text{shared } T <: \text{const } T
\tag{Sub-Permission}
$$

[15] More restrictive permissions subtype less restrictive permissions. This allows passing `unique` values where `shared` or `const` is expected (permission downgrade).

##### §9.7.5.2 Permission in Generic Types

[16] Permission annotations compose with generic type parameters:

```cursive
record Container<T> {
    data: Ptr<T>@Valid,
}

let unique_container: unique Container<i32> = Container::new()
let shared_container: shared Container<i32> = unique_container  // Downgrade
let const_container: const Container<i32> = shared_container   // Downgrade
```

[17] The generic parameter `T` remains invariant; permission downgrades apply to the binding, not the type constructor.

#### §9.7.6 Variance Inference [generic.variance.inference]

##### §9.7.6.1 Variance Inference Algorithm

[18] For user-defined generic types, variance is inferred by analyzing how type parameters appear in the type's definition:

```
infer_variance(type_definition, param):
    occurrences = find_all_occurrences(param, type_definition)

    for occurrence in occurrences:
        position = classify_position(occurrence)
        match position:
            CovariantPosition:
                contribute Covariant
            ContravariantPosition:
                contribute Contravariant
            InvariantPosition:
                contribute Invariant

    combine contributions:
        if all Covariant:
            return Covariant
        else if all Contravariant:
            return Contravariant
        else:
            return Invariant  // Mixed or any invariant forces invariant
```

##### §9.7.6.2 Position Classification

[19] Type parameter occurrences are classified by position:

- **Covariant positions**: Return types, immutable fields (if type is read-only)
- **Contravariant positions**: Procedure parameter types, callable parameter types
- **Invariant positions**: Mutable fields, array elements, slice elements, record fields

[20] Any occurrence in an invariant position forces the entire parameter to be invariant.

##### §9.7.6.3 Inferred Variance is Conservative

[21] The inference algorithm is conservative: when in doubt, it defaults to invariant. This preserves safety at the cost of some flexibility.

[ Note: User-defined types cannot override inferred variance. Variance is a property derived from the type's structure, not a declared attribute. This ensures that variance annotations cannot introduce unsoundness.
— end note ]

#### §9.7.7 Variance Safety [generic.variance.safety]

##### §9.7.7.1 Safety Rationale

[22] Invariance in most positions prevents type confusion through mutable references:

```cursive
// Hypothetical (if arrays were covariant):
// let cats: [Cat] = [Cat::new(), Cat::new()]
// let animals: [Animal] = cats  // If covariant
// animals[0] = Dog::new()       // Store Dog in Cat array!
// let cat: Cat = cats[0]        // Type confusion!

// Cursive: arrays are invariant, preventing this
```

[23] By making mutable structures invariant, Cursive ensures that references to generic containers remain type-safe.

##### §9.7.7.2 Read-Only Covariance

[24] Purely read-only structures could be covariant, but Cursive defaults to invariance for user-defined types. The only built-in covariant structure is the discriminated union `\/`:

$$
\frac{\tau_i <: \tau_1 \/ \cdots \/ \tau_n}{F\langle\tau_i\rangle <: F\langle\tau_1 \/ \cdots \/ \tau_n\rangle}
\tag{Variance-Union-Covariant}
$$

[25] Union types are inherently covariant because each component is a subtype of the union by construction (§7.3.6, §7.7.3).

#### §9.7.8 Variance and Permissions [generic.variance.permissions]

##### §9.7.8.1 Permission Impact on Variance

[26] Permission qualifiers affect variance through the subtyping lattice. While generic type parameters remain invariant, the permission applied to the entire type can vary:

```cursive
record Buffer<T> {
    data: [T],
}

// T is invariant (Buffer<i32> ≠ Buffer<i64>)
// But permissions downgrade:
let unique_buf: unique Buffer<i32> = Buffer::new()
let shared_buf: shared Buffer<i32> = unique_buf  // Permission downgrade
```

[27] The type parameter invariance is separate from permission covariance. Both systems compose without interference.

##### §9.7.8.2 Permission Variance Rule

[28] Permission downgrades are always safe regardless of type parameter variance:

$$
\frac{P_1 <: P_2 \text{ in permission lattice}}{P_1\, F\langle\tau\rangle <: P_2\, F\langle\tau\rangle}
\tag{Variance-Permission-Downgrade}
$$

where $P_1, P_2 \in \{\text{unique}, \text{shared}, \text{const}\}$ and $P_1 <: P_2$ follows the permission lattice (§11.4.3).

#### §9.7.9 Variance Examples [generic.variance.examples]

**Example 10.7.9.1 (Invariant parameters in records):**

```cursive
record Container<T> {
    items: [T],
}

let int_container: Container<i32> = Container { items: [1, 2, 3] }

// Invalid: Container is invariant in T
// let num_container: Container<i64> = int_container
// error[E07-700]: type mismatch, Container<i32> ≠ Container<i64>
```

**Example 10.7.9.2 (Function variance):**

```cursive
// Callable contravariant in parameters, covariant in results

procedure accepts_callback(f: (i32) -> string@View)
{
    let result = f(42)
}

// More specific parameter, more specific return
let specific: (i16) -> string@Managed = |x: i16| [[ alloc::heap ]] {
    result string.from_int(x as i32)
}

// Less specific parameter, less specific return
let general: (i64) -> string@View = |x: i64| {
    result "value"
}

// Variance allows flexible callable substitution
```

**Example 10.7.9.3 (Grant variance in callables):**

```cursive
procedure run_pure(f: () -> i32): i32
{
    result f()
}

let pure_fn = || { result 42 }
run_pure(pure_fn)  // ∅ ⊆ ∅ ✓

// Cannot pass grant-requiring function to pure context
let grant_fn = || [[ io::write |- true => true ]] {
    println("computing")
    result 42
}
// run_pure(grant_fn)  // error: {io::write} ⊄ ∅
```

**Example 10.7.9.4 (Union covariance):**

```cursive
let value: i32 = 42
let union: i32 \/ string@Managed = value  // i32 <: i32 \/ string@Managed

procedure process(input: i32 \/ string@View \/ bool)
{
    match input {
        n: i32 => println("Number: {}", n),
        s: string@View => println("String: {}", s),
        b: bool => println("Boolean: {}", b),
    }
}

let narrow: i32 \/ string@View = 42
process(narrow)  // OK: i32 \/ string@View <: i32 \/ string@View \/ bool
```

**Example 10.7.9.5 (Permission and type variance composition):**

```cursive
record Data<T> {
    value: T,
}

let unique_data: unique Data<i32> = Data { value: 42 }
let shared_data: shared Data<i32> = unique_data      // Permission downgrade ✓
// let wrong: shared Data<i64> = unique_data         // Type invariance violation ✗
```

#### §9.7.10 Variance Checking [generic.variance.checking]

##### §9.7.10.1 Subtyping with Generic Types

[30] When checking whether `F<τ₁> <: F<τ₂>`, the compiler:

1. Retrieves variance of `F` in its parameter
2. Applies variance rule:
   - Covariant: check `τ₁ <: τ₂`
   - Contravariant: check `τ₂ <: τ₁`
   - Invariant: check `τ₁ ≡ τ₂`

[31] For multi-parameter generics, each parameter is checked independently and all must satisfy their variance requirements.

##### §9.7.10.2 Variance Checking Rule

$$
\frac{
\begin{array}{c}
F \text{ has variance } V_1, \ldots, V_n \text{ in parameters } \alpha_1, \ldots, \alpha_n \\
\forall i. \; \text{check}(V_i, \tau_i, \upsilon_i) \text{ succeeds}
\end{array}
}{F\langle\tau_1, \ldots, \tau_n\rangle <: F\langle\upsilon_1, \ldots, \upsilon_n\rangle}
\tag{WF-Variance-Check}
$$

where:

$$
\text{check}(V, \tau, \upsilon) = \begin{cases}
\tau <: \upsilon & \text{if } V = \text{Covariant} \\
\upsilon <: \tau & \text{if } V = \text{Contravariant} \\
\tau \equiv \upsilon & \text{if } V = \text{Invariant}
\end{cases}
$$

##### §9.7.10.3 Variance Violations

[32] Attempting subtyping that violates variance produces diagnostic E10-701:

```cursive
let container: Container<i32> = Container::new()
// let wrong: Container<i64> = container  // error[E10-701]: variance violation
```

[33] The diagnostic includes the type constructor, its variance, and the attempted substitution.

#### §9.7.11 Variance Inference Algorithm [generic.variance.inference]

##### §9.7.11.1 Algorithm Specification

[34] Variance inference analyzes type definitions to determine parameter variance:

```
infer_variance(type T<α₁, ..., αₙ>):
    for each parameter αᵢ:
        positions = []

        // Collect all positions where αᵢ appears
        for occurrence of αᵢ in T's definition:
            classify occurrence as Covariant, Contravariant, or Invariant
            append to positions

        // Combine positions
        if all positions are Covariant:
            variance[αᵢ] = Covariant
        else if all positions are Contravariant:
            variance[αᵢ] = Contravariant
        else:
            variance[αᵢ] = Invariant

    return variance
```

##### §9.7.11.2 Position Classification Rules

[35] Type parameter positions are classified recursively:

- **Covariant context**:

  - Return type of procedure
  - Right side of union `\/`
  - Inside covariant type constructor
  - Negated contravariant position (double flip)

- **Contravariant context**:

  - Parameter type of procedure
  - Inside contravariant type constructor
  - Negated covariant position

- **Invariant context**:
  - Mutable field in record
  - Array element type `[T; n]`
  - Slice element type `[T]`
  - Any position in invariant type constructor

[36] Once a parameter appears in an invariant position anywhere in the type definition, the parameter is invariant for the entire type.

##### §9.7.11.3 Examples

**Example 10.7.11.1 (Variance inference for read-only wrapper):**

```cursive
record ReadOnly<T> {
    value: const T,    // Immutable field
}

// Variance inference:
// T appears in immutable field position
// But records are nominal and default to invariant
// Result: ReadOnly is invariant in T

// Even though semantically could be covariant, structural analysis forces invariant
```

**Example 10.7.11.2 (Callable parameter variance):**

```cursive
record Callback<T, U> {
    func: (T) -> U,
}

// Variance inference:
// T appears in parameter position of func (contravariant)
// U appears in return position of func (covariant)
// func is in immutable field (would preserve variance)
// BUT: Callback is nominal record → invariant in all parameters
// Result: Callback is invariant in both T and U
```

#### §9.7.12 Diagnostics [generic.variance.diagnostics]

[37] Variance-related diagnostics:

| Code    | Condition                                          |
| ------- | -------------------------------------------------- |
| E10-701 | Variance violation in generic type substitution    |
| E10-702 | Conflicting variance requirements (internal error) |

#### §9.7.13 Conformance Requirements [generic.variance.requirements]

[38] Implementations shall:

1. Enforce variance rules per Table 10.7.1 for all type constructors
2. Implement variance inference algorithm for user-defined generic types
3. Default user-defined types to invariant unless proven otherwise
4. Check variance during subtyping (§7.7) and type checking
5. Support permission variance through permission lattice (§11.4.3)
6. Recognize callable types as contravariant in parameters, covariant in results
7. Support grant variance (fewer grants is more specific)
8. Enforce precondition contravariance and postcondition covariance
9. Detect variance violations and emit E10-701 with detailed substitution info
10. Integrate variance with monomorphization (§10.6) and bound checking (§10.3)
11. Document variance behavior in implementation guidance


### §10.1 Memory Model Overview [memory.overview]

#### §10.1.1 Overview and Design Goals

[1] Cursive achieves memory safety through compile-time enforcement of cleanup responsibility, permission-based access control, and region-scoped allocation—without garbage collection or borrow checking. The memory model ensures that well-typed programs cannot produce use-after-free errors, double-free errors, or dangling references.

[2] The model is built on three foundational principles:

- **Deterministic cleanup**: Resources are released at statically determined program points via RAII (Resource Acquisition Is Initialization)
- **Explicit transfers**: Cleanup responsibility transfers require the explicit `move` keyword at call sites
- **Zero runtime overhead**: All safety mechanisms operate at compile time with no runtime cost

#### §10.1.2 Two-Axis Orthogonal Design

[4] Cursive's memory model separates two independent concerns into orthogonal axes:

**Axis 1: Cleanup Responsibility** (§5.2.5 [decl.variable.operator]) — Determined by assignment operator (`=` vs `<-`)

**Axis 2: Permissions** (§11.4 [memory.permission]) — Access control qualifiers (`const`, `unique`, `shared`)

[5] These axes are completely orthogonal and may be combined freely. Complete binding operator semantics, including invalidation rules for non-responsible bindings, are specified in §5.2.5 [decl.variable.operator]. Complete permission semantics and the permission lattice are specified in §11.4 [memory.permission].

#### §10.1.3 No Garbage Collection

[7] Cursive does not employ garbage collection (§1.8.1).

#### §10.1.4 No Borrow Checker

[10] Cursive achieves memory safety without borrow checking (§1.8.2).


#### §10.1.6 Zero Runtime Overhead

[16] All memory safety mechanisms operate at compile time. The memory model guarantees:

- **No runtime checks**: Permission violations detected at compile time
- **No metadata**: Objects carry no runtime permission or responsibility tags
- **No reference counting**: Cleanup responsibility is static, not dynamic
- **No GC metadata**: No garbage collector infrastructure
- **Equivalent assembly**: Safe code compiles to identical assembly as unsafe code performing the same operations

[17] Field-level partitioning, unique enforcement, region escape analysis, and move tracking are purely compile-time analyses with zero runtime representation.

#### §10.1.7 Non-Responsible Binding Tracking Without Runtime Cost

[21] A key innovation in Cursive's memory model is tracking object lifetimes for non-responsible bindings **without runtime overhead**. The mechanism:

1. **Compile-time dependency tracking**: Non-responsible bindings (`<-`) recorded as dependent on their source bindings
2. **Parameter responsibility signal**: Procedure parameters declare whether they will destroy objects (`move` modifier)
3. **Invalidation propagation**: Move to responsible parameter → invalidate all non-responsible bindings to that object
4. **Validity preservation**: Pass to non-responsible parameter → non-responsible bindings remain valid

This provides the **safety of garbage collection** (no dangling pointers) with the **cost of manual management** (zero runtime overhead) by leveraging information already present in procedure signatures.

**Comparison to other approaches**:

| Approach                          | Safety | Cost       | How Achieved                 |
| --------------------------------- | ------ | ---------- | ---------------------------- |
| Garbage Collection                | ✅     | Runtime GC | Runtime pointer tracking     |
| Rust Borrow Checker               | ✅     | Zero       | Compile-time lifetime params |
| **Cursive Non-Responsible Bindings** | ✅     | **Zero**   | **Parameter responsibility** |

Cursive achieves safe non-responsible bindings through explicit parameter annotations rather than lifetime parameters or runtime tracking.

#### §10.1.8 Conformance Requirements

[22] Implementations shall guarantee zero runtime overhead for all safety mechanisms and reject programs with memory safety violations at compile time.


### §10.2 Objects and Storage Duration [memory.object]

#### §10.2.1 Overview

[1] This section specifies object properties, storage duration categories, memory locations, and the RAII-based cleanup mechanism that ensures deterministic resource release.

[2] Objects are runtime entities with type, storage, and bounded lifetimes. Bindings establish relationships to objects: responsible bindings call destructors at scope exit; non-responsible bindings provide access without cleanup obligations.

#### §10.2.2 Object Model [memory.object.model]

##### §10.2.2.1 Object Definition

[3] An _object_ is a region of storage with the following properties:

1. **Type**: Exactly one type governing representation, size, and operations
2. **Storage location**: Contiguous bytes at a specific memory address
3. **Lifetime**: Bounded interval from creation to destruction
4. **Alignment**: Address alignment constraint matching type requirements
5. **Cleanup responsibility**: Association with zero or more responsible bindings

[4] Objects are created by:

- Variable declarations with `=` operator (§5.2)
- Region allocation via `^` operator (§11.3)
- Procedure parameters receiving moved values
- Temporary expressions during evaluation

[5] Objects are destroyed when:

- A responsible binding goes out of scope (RAII)
- A region exits (bulk deallocation)
- A `var` binding is reassigned (old value destroyed first)

##### §10.2.2.2 Memory Locations

[6] A _memory location_ is an addressable storage unit. Objects occupy one or more contiguous memory locations determined by their type:

- **Scalar types** (§7.2): One memory location
- **Composite types** (§7.3): Multiple locations (one per field/element)
- **Pointer types** (§7.5): One memory location (size of address)

[7] Two bindings _alias_ when they refer to overlapping memory locations. Aliasing is permitted for `const` and `shared` permissions; `unique` permission prevents aliasing through compile-time enforcement (§11.7).

##### §10.2.2.3 Binding Responsibility

[8] Binding cleanup responsibility is determined by the assignment operator per §4.2.5 [decl.variable.operator].

#### §10.2.3 Storage Duration Categories [memory.object.storage]

##### §10.2.3.1 Overview

[11] Storage duration determines when object storage is allocated and deallocated. Cursive provides four categories: static, automatic, region, and heap.

##### §10.2.3.2 Static Storage Duration

[12] **Static storage duration**: Objects allocated before `main` executes and deallocated after `main` returns. Module-scope bindings (§2.5) have static storage duration.

[13] **Allocation timing**: Static objects are allocated during program initialization, before the entry point begins.

[14] **Initialization order**: Static bindings initialize according to module dependency order (§4.6).

[15] **Lifetime**: Static objects live for the entire program execution.

**Example 11.2.3.1 (Static storage):**

```cursive
// Module-scope: static storage duration
let MODULE_CONFIG: const Config = load_initial_config()
var GLOBAL_COUNTER: const i32 = 0

public procedure main(): i32
    [[ io::write |- true => true ]]
{
    println("Config version: {}", MODULE_CONFIG.version)
    result 0
}
// Static objects destroyed after main returns
```

##### §10.2.3.3 Automatic Storage Duration

[16] **Automatic storage duration**: Objects allocated when control reaches their declaration and deallocated when their scope exits.

[17] **Allocation timing**: Automatic objects are allocated on the call stack (or equivalent) when execution reaches the binding statement.

[18] **Deallocation timing**: At scope exit (block end, procedure return), automatic objects are destroyed in LIFO order.

**Example 11.2.3.2 (Automatic storage with LIFO):**

```cursive
procedure demo()
    [[ alloc::heap |- true => true ]]
{
    let first = Resource::new("A")    // Allocated first
    let second = Resource::new("B")   // Allocated second
    let third = Resource::new("C")    // Allocated third

    // Destruction order: third, second, first (LIFO)
}
```

##### §10.2.3.4 Region Storage Duration

[19] **Region storage duration**: Objects allocated in an explicit region block using the `^` operator. All region allocations are freed simultaneously when the region exits.

[20] **Allocation timing**: Objects are allocated in the active region when the `^` operator executes.

[21] **Deallocation timing**: When the region block exits, all allocations within that region are freed in O(1) bulk deallocation.

[22] Complete region semantics are specified in §11.3 [memory.region].

##### §10.2.3.5 Heap Storage Duration

[23] **Heap storage duration**: Objects explicitly escaped to the heap via `.to_heap()` methods. These objects remain allocated until the responsible binding holding them is destroyed.

[24] Heap allocation is a secondary mechanism used when data must outlive its creating scope. The primary mechanism is region allocation (§11.3).

#### §10.2.4 RAII and Deterministic Cleanup [memory.object.raii]

##### §10.2.4.1 RAII Principle

[25] Cursive employs RAII: when a responsible binding goes out of scope, the binding's destructor (if any) executes automatically before the binding is removed.

[26] **RAII guarantee**: Resources are acquired during object initialization and released during object destruction. No explicit cleanup calls are needed; the compiler inserts destructor calls automatically.

##### §10.2.4.2 LIFO Destruction Order

[27] Within a scope, responsible bindings are destroyed in reverse declaration order (LIFO):

[ Given: Scope with responsible bindings $x_1, \ldots, x_n$ in declaration order ]

$$
\frac{\text{scope exits}}{\text{destroy } x_n, \text{ then } x_{n-1}, \ldots, \text{ then } x_1}
\tag{E-LIFO-Cleanup}
$$

[28] This order ensures that dependencies between objects are respected: objects created later (which may depend on earlier objects) are destroyed first.

##### §10.2.4.3 Destructor Execution

[29] When a responsible binding's scope exits:

1. The binding's destructor (if any) executes
2. Subobjects are destroyed in reverse field declaration order
3. Storage is released according to storage duration category

[30] Destructor execution is guaranteed for normal scope exit and early exit via `return`, `break`, or `continue`. Defer statements (§8.2.6) execute before destructors.

##### §10.2.4.4 Non-Responsible Bindings

[31] Non-responsible bindings created with `<-` do not invoke destructors. The original responsible binding retains cleanup responsibility. Multiple non-responsible bindings can reference the same object without creating cleanup obligations. See §4.2.5 Example 4.2.5.2 for binding operator semantics.

#### §10.2.5 Destructor Protocol [memory.object.destructor]

##### §10.2.5.1 Overview

[33] Types may implement custom cleanup logic through the `Drop` behavior (Clause 9). When a responsible binding goes out of scope, the runtime invokes the type's `drop` method if present, then automatically destroys all fields.

[34] The destructor protocol ensures deterministic resource release while allowing types to perform custom cleanup (closing file handles, releasing locks, logging shutdown, etc.).

##### §10.2.5.2 Drop Predicate [memory.object.destructor.predicate]

[35] The `Drop` behavior is defined in Clause 9 §9.4.5.6 [generic.behavior.marker.drop] with the following signature:

```cursive
behavior Drop {
    procedure drop(~!)
}
```

[36] Types implement `Drop` by providing a `drop` method with receiver `~!` (shorthand for `self: unique Self`). The method receives exclusive access to the object and may perform any cleanup operations required. The contractual sequent may include grants necessary for cleanup (e.g., `[[ fs::close |- ... ]]`).

**Example 11.2.5.1 (Drop implementation):**

```cursive
record FileHandle {
    path: string@Managed,
    handle: os::Handle,
}

behavior Drop for FileHandle {
    procedure drop(~!)
        [[ fs::close |- true => true ]]
    {
        os::close(self.handle)
        // Fields (path, handle) automatically destroyed after drop() completes
    }
}
```

##### §10.2.5.3 Automatic Field Destruction [memory.object.destructor.fields]

[37] After a type's `drop` method completes (if present), the compiler automatically invokes destructors for each field in reverse declaration order. Field destruction occurs regardless of whether the parent type implements `Drop`.

[ Given: Record `R { f₁: T₁, ..., fₙ: Tₙ }` with responsible binding ]

$$
\frac{R.\text{drop}() \text{ completes (if present)}}{\text{destroy } f_n, \text{ then } f_{n-1}, \ldots, \text{ then } f_1}
\tag{E-Field-Cleanup}
$$

[38] For types without custom `drop` methods, only automatic field destruction occurs. This ensures all subobjects are properly cleaned up in all cases.

##### §10.2.5.4 Destruction Order in Scopes [memory.object.destructor.order]

[39] Within a scope containing multiple responsible bindings, destruction follows strict LIFO (last-in, first-out) order as specified in §11.2.4.2. For each binding:

1. The binding's custom `drop` method executes (if `Drop` is implemented)
2. Fields are destroyed in reverse declaration order (recursively applying this protocol)
3. Storage is released according to storage duration category

[40] This order ensures that dependencies between objects are respected: objects created later (which may depend on earlier objects) are destroyed first.

##### §10.2.5.5 Panic and Unwinding [memory.object.destructor.panic]

[41] When a panic occurs during normal execution, destructors execute during stack unwinding (if unwinding is enabled). This section specifies the complete unwinding algorithm, destructor execution order, and interaction with region cleanup.

**Unwinding Algorithm:**

[41.1] When a panic occurs at location $L$ in scope $S$:

1. **Unwind initialization**: Mark the panic site and begin unwinding from innermost scope to outermost
2. **For each scope** $S_i$ being unwound (from innermost to outermost):
   a. Execute all `defer` statements in reverse order of declaration (last-declared executes first)
   b. Execute destructors for all responsible bindings in reverse declaration order (LIFO)
   c. If the scope is a region block, invoke `arena.free()` for bulk deallocation
   d. Continue to parent scope
3. **Termination**: Unwinding stops when:
   - A scope catches the panic (future feature), OR
   - The entry point `main` is reached (process exits with non-zero status)

[41.2] **Destructor panic during unwinding.** If any destructor invoked during unwinding panics:

- The process **aborts immediately** without executing remaining destructors
- No further unwinding occurs
- The process exits with implementation-defined non-zero status
- This prevents double-panic scenarios and undefined stack states

[41.3] **Defer execution order.** `defer` statements execute **before** destructors in the same scope:

```
Scope exit order:
1. defer blocks (reverse declaration order)
2. responsible binding destructors (reverse declaration order)
```

This ensures cleanup code in `defer` can access still-valid objects.

[42] **Region cleanup during unwinding.** Region blocks being unwound are freed via `arena.free()` after all responsible bindings in that scope are destroyed. This ensures:

- Responsible bindings can access region-allocated data during cleanup
- Arena memory is reclaimed after all cleanup completes
- O(1) bulk deallocation occurs even during panic scenarios

[43] **Abort-on-panic mode.** Implementations may provide an abort-on-panic mode (compilation flag `--panic=abort`) where panics immediately terminate the process without unwinding. In this mode:

- Destructors are **not guaranteed to execute**
- `defer` blocks are **not executed**
- Process exits immediately with non-zero status
- Programs requiring guaranteed cleanup should design for graceful shutdown rather than relying on panic unwinding

[43.1] **Conformance note**: Implementations shall document whether default panic behavior is unwinding or abort. Both modes are conforming; the choice affects reliability guarantees for resource cleanup.

##### §10.2.5.6 Types Without Custom Destructors [memory.object.destructor.auto]

[44] Types that do not implement `Drop` still participate in RAII through automatic field destruction. Primitive types (§7.2) have trivial destructors (no-op). Composite types recursively destroy their components.

[45] Most types do not need custom destructors; automatic field destruction handles cleanup correctly. Custom `drop` methods are needed only when:

- Releasing external resources (files, sockets, locks)
- Logging or metrics on object lifetime
- Performing cleanup operations beyond simple deallocation

##### §10.2.5.7 Diagnostics [memory.object.destructor.diagnostics]

[Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.10. — end note]

##### §10.2.5.8 Examples [memory.object.destructor.examples]

**Example 11.2.5.2 (Automatic field destruction):**

```cursive
record Resource {
    name: string@Managed,
    data: Buffer,
}

// No custom Drop implementation needed
// Fields destroyed automatically in reverse order: data, then name
```

**Example 11.2.5.3 (Nested destruction):**

```cursive
procedure demo()
    [[ alloc::heap |- true => true ]]
{
    let outer = Resource {
        name: string.from("outer"),
        data: Buffer::new(),
    }
    // At scope exit:
    // 1. outer.drop() if implemented
    // 2. outer.data destroyed (Buffer::drop() called if implemented)
    // 3. outer.name destroyed (string@Managed::drop() called)
}
```

#### §10.2.6 Conformance Requirements

[52] Implementations shall handle panic during unwinding per §10.2.5.5, aborting on double-panic scenarios.


### §10.3 Regions [memory.region]

#### §10.3.1 Overview

[1] Regions provide lexically-scoped, stack-like allocation arenas with O(1) bulk deallocation. They enable efficient temporary allocation without garbage collection or manual memory management.

[2] Cursive implements regions through the `Arena` modal type - a built-in modal type with states representing the arena lifecycle (@Active, @Frozen, @Freed). The `region` keyword is syntactic sugar for creating a scoped `Arena@Active` with automatic cleanup.

[3] This section specifies the Arena modal type, region block syntax, allocation semantics, escape analysis, and arena state transitions.

#### §10.3.2 Arena Modal Type [memory.region.arena]

##### §10.3.2.1 Arena States and Structure

[4] The `Arena` type is a built-in modal type with three states representing the arena lifecycle:

```cursive
modal Arena {
    @Active {
        ptr: Ptr<u8>,
        capacity: usize,
        allocated: usize,
    }

    @Active::alloc<T>(~!, value: T) -> @Active
    @Active::alloc_array<T>(~!, count: usize) -> @Active
    @Active::reset(~!) -> @Active
    @Active::freeze(~) -> @Frozen
    @Active::free(~!) -> @Freed

    @Frozen {
        ptr: Ptr<u8>,
        allocated: usize,
    }

    @Frozen::thaw(~!) -> @Active
    @Frozen::free(~!) -> @Freed

    @Freed { }
}
```

[5] **State semantics**:

- **@Active**: Arena is active and accepting allocations. Supports allocation, reset (bulk free + reuse), freeze (prevent further allocation), and terminal free.
- **@Frozen**: Arena is read-only; allocated data remains valid but no new allocations permitted. Supports thaw (resume allocation) and terminal free.
- **@Freed**: Terminal state after arena is deallocated. No operations available.

[6] **State transition diagram**:

```
@Active ──reset()──> @Active    (bulk free, reuse memory)
   │
   │ freeze()
   ↓
@Frozen ──thaw()───> @Active    (resume allocation)
   │              │
   │ free()   free()
   ↓              ↓
@Freed <────────────            (terminal state)
```

##### §10.3.2.2 Arena Allocation Methods

[7] The `alloc` method allocates a value in the arena and returns the arena in @Active state:

```cursive
procedure Arena.alloc<T>(~!, value: T): Self@Active
    [[ alloc::region |- true => true ]]
{
    // Implementation: bump-allocate space for T, write value
    result self  // Returns same arena instance, still @Active
}
```

[8] Type rule for allocation:

$$\frac{\Gamma \vdash arena : \text{Arena}@\text{Active} \quad \Gamma \vdash v : \tau}{\Gamma \vdash arena\texttt{.alloc}(v) : \text{Arena}@\text{Active}}$$

[9] The allocated value is stored in the arena's memory; the arena itself is returned to enable method chaining and continued allocation.

##### §10.3.2.3 Arena Reset and Lifecycle

[10] The `reset` method bulk-frees all allocations and returns the arena to empty @Active state:

```cursive
procedure Arena.reset(~!): Self@Active
{
    // Reset allocation pointer to beginning
    // All previously allocated values become invalid
    result self
}
```

[11] After `reset()`, all pointers previously allocated in the arena become invalid. Accessing such pointers produces undefined behavior [UB-ID: B.2.01].

[12] The `free` method transitions the arena to @Freed state, deallocating the arena's backing memory:

```cursive
procedure Arena.free(~!): Self@Freed
{
    // Deallocate arena backing memory
    result Arena@Freed { }
}
```

#### §10.3.3 Region Block Syntax [memory.region.syntax]

##### §10.3.3.1 Region Blocks

[13] Region block syntax:

**Region blocks** match the pattern:
```
"region" <identifier> [ "as" <identifier> ] <block_stmt>
```

[ Note: See Annex A §A.5 [grammar.statement] for complete region grammar.
— end note ]

[14] The first identifier names the region for parent-region allocation (caret stacking, §11.3.5). The optional `as identifier` clause binds the arena to the specified name, creating a non-responsible binding to the `Arena@Active` object.

[15] **Desugaring**: Region blocks desugar to arena creation with automatic cleanup:

```cursive
// Source syntax:
region temp as workspace {
    let x = ^Value::new()
}

// Desugars to:
{
    let workspace = Arena::new_scoped()  // Arena@Active, non-responsible binding
    defer { workspace.free() }
    let x = workspace.alloc(Value::new())
}
```

[16] When the `as identifier` clause is omitted, an implicit arena binding is created but not accessible by name. The `^` operator allocates through this implicit arena.

**Example 11.3.2.1 (Region blocks):**

```cursive
region temp {
    let data = ^Buffer::new(1024)
    process(data)
}
// All allocations in temp freed here (O(1))

region outer {
    region inner {
        let a = ^Data::new()   // Allocated in inner
    }
    // inner region freed
    let b = ^Data::new()       // Allocated in outer
}
// outer region freed
```

##### §10.3.3.2 The Caret Operator (Syntactic Sugar)

[17] The `^` prefix operator is syntactic sugar for arena allocation:

**Region allocation expressions** take one of the following forms:
```
"^" <expression>
"^" "^" ... <expression>    // Multiple carets for parent arenas
```

[18] **Desugaring rule**: Within a region block, `^expr` desugars to `arena.alloc(expr)` where `arena` is the active arena binding (named or implicit):

```cursive
region temp as workspace {
    let x = ^Value::new()
    let y = workspace.alloc(Value::new())
    // Equivalent: both desugar to workspace.alloc()
}

region temp {
    let x = ^Value::new()
    // Desugars to: __implicit_arena.alloc(Value::new())
    // where __implicit_arena is the compiler-generated arena binding
}
```

[19] **Type preservation**: The caret operator (via `arena.alloc()`) evaluates the expression and allocates the resulting value in the arena. The type remains `T`:

$$
\frac{\Gamma \vdash e : \tau \quad arena : \text{Arena}@\text{Active}}{\Gamma \vdash \texttt{^} e : \tau}
\tag{T-Region-Alloc}
$$

The return type is the allocated value's type `τ`, not a pointer type. The `alloc` method stores the value in arena memory and returns the arena itself (type `Arena@Active`), but the `^` operator discards the returned arena and yields the allocated value.

[20] **Provenance assignment**: Values allocated via `^` or `arena.alloc()` receive provenance `Region(r)` where `r` is the region identifier. This provenance is compiler metadata (not part of the type system) used for escape analysis (§11.3.4).

[ Note: The `^` operator is purely syntactic convenience. It desugars to `arena.alloc(expression)` during parsing. The allocation semantics, escape analysis, and bulk deallocation are all properties of the underlying `Arena@Active` modal value, not special behaviors of the caret operator.
— end note ]

**Example 11.3.3.2 (Caret operator and explicit allocation equivalence):**

```cursive
region batch as workspace {
    // All four allocations are equivalent:
    let buf1 = ^Buffer::new()
    let buf2 = workspace.alloc(Buffer::new())

    // Both have:
    // - Type: Buffer
    // - Provenance: Region(batch)
    // - Allocated in: batch arena

    // To get pointers:
    let ptr1: Ptr<Buffer>@Valid = &buf1
    let ptr2: Ptr<Buffer>@Valid = &buf2
}
```

#### §10.3.4 Escape Analysis [memory.region.escape]

##### §10.3.4.1 Overview

[21] Escape analysis prevents region-allocated values from outliving their region. The compiler statically verifies that region-allocated data does not escape the region block through provenance tracking and escape checking at region boundaries.

[22] Escape analysis operates on compile-time **provenance metadata** associated with each value. Provenance tracks the allocation source (stack, region, or heap) and is propagated through operations. Complete algorithm specifications appear in Annex E §E.2.6 [implementation.algorithms.region].

##### §10.3.4.2 Provenance Metadata [memory.region.provenance]

[23] Every value has associated provenance metadata indicating its allocation source:

**Provenance Type:**

$$
\text{Provenance} ::= \text{Stack} \mid \text{Region}(r) \mid \text{Heap}
$$

where $r$ is a region identifier bound to a lexical region scope.

[24] **Provenance assignment rules**:

- Values allocated via `^` or `arena.alloc()` in region $r$ have provenance $\text{Region}(r)$
- Local variables (without `^` or `arena.alloc()`) have provenance $\text{Stack}$
- Values converted via `.to_heap()` have provenance $\text{Heap}$
- Module-scope values have provenance $\text{Static}$ (treated as Heap for escape purposes)

[25] **Provenance is metadata**: Provenance information is tracked by the compiler but is not part of the type system. A value of type `T` has the same type regardless of whether it has provenance Stack, Region(r), or Heap. Provenance affects only escape analysis, not type checking.

[ Note: The `Arena` modal type itself does not carry provenance - it is a heap-allocated object managing an arena. Values allocated THROUGH the arena (via `alloc()` or `^`) receive Region(r) provenance based on which region block created the arena.
— end note ]

##### §10.3.3.3 Provenance Propagation [memory.region.propagation]

[15] Provenance propagates through operations according to these rules:

**Address-of propagation:**

[ Given: Value $v$ with provenance $\pi$ ]

$$
\frac{\text{prov}(v) = \pi}{\text{prov}(\&v) = \pi}
\tag{Prov-Addr}
$$

Taking the address of a value produces a pointer with the same provenance as the value.

**Field access propagation:**

[ Given: Structure $s$ with provenance $\pi$, field $f$ ]

$$
\frac{\text{prov}(s) = \pi}{\text{prov}(s.f) = \pi}
\tag{Prov-Field}
$$

Accessing a field inherits the structure's provenance.

**Procedure return propagation:**

[ Given: Procedure call $p(\text{args})$ with conservative provenance ]

$$
\frac{}{\text{prov}(p(\text{args})) = \text{Heap}}
\tag{Prov-Call-Conservative}
$$

Procedure calls conservatively assume Heap provenance unless the procedure's signature specifies otherwise (future extension). Implementations may refine this with interprocedural analysis.

[16] Complete provenance propagation rules for all expression forms are specified in Annex E §E.2.6 [implementation.algorithms.region].

##### §10.3.3.4 Escape Checking [memory.region.escape.checking]

[17] **Escape prohibition**: Values with region provenance shall not escape their region. Implementations shall check escape at:

1. **Return statements**: Returning a Region(r)-provenance value when r is local
2. **Region block exit**: Storing region-allocated values in outer scopes
3. **Closure capture**: Capturing region values in closures that outlive the region
4. **Field assignment**: Assigning region values to fields of longer-lived structures

[18] **Formal escape constraint**:

[ Given: Expression $e$ with provenance $\pi$, target scope $s$ ]

$$
\frac{\text{prov}(e) = \text{Region}(r) \quad r \text{ is lexically nested in } s}
     {\text{escape}_s(e) \Rightarrow \text{ERROR E11-101}}
\tag{WF-No-Region-Escape}
$$

The rule states: if a value has region provenance and the region is local to the current analysis scope, escaping that value to the target scope is forbidden.

[19] **Diagnostic E11-101**: "Cannot escape region-allocated value from region `{region_id}`"

The diagnostic shall include:

- Region identifier
- Allocation site (where `^` occurred)
- Escape site (where escape was attempted)
- Provenance path (how provenance propagated to escape site)

##### §10.3.3.5 Permitted Escape via Heap Conversion [memory.region.escape.heap]

[20] Region-allocated values may escape only after explicit conversion to heap allocation:

**Heap conversion rule:**

[ Given: Value $v$ with provenance $\text{Region}(r)$ ]

$$
\frac{\text{prov}(v) = \text{Region}(r)}{\text{prov}(v\texttt{.to\_heap()}) = \text{Heap}}
\tag{Prov-Heap-Convert}
$$

[21] The `.to_heap()` operation (standard library) copies the value to heap storage and returns a heap-allocated value with provenance Heap. The original region-allocated value remains valid until the region exits.

[22] Heap conversion requires the `alloc::heap` grant in the procedure's contractual sequent. Attempting to call `.to_heap()` without the grant produces diagnostic E11-102 (heap allocation requires alloc::heap grant).

##### §10.3.3.6 Examples [memory.region.escape.examples]

**Example 11.3.3.1 - invalid (Region escape):**

```cursive
procedure create_data(): Buffer
    [[ alloc::region |- true => true ]]
{
    region temp {
        let data = ^Buffer::new()
        result data  // error[E11-101]: region-allocated value cannot escape
    }
}
```

**Example 11.3.3.2 (Heap conversion allows escape):**

```cursive
procedure create_data(): Buffer
    [[ alloc::region, alloc::heap |- true => true ]]
{
    region temp {
        let data = ^Buffer::new()
        data.prepare()
        result data.to_heap()  // ✅ OK: explicit heap conversion
    }
}
```

**Example 11.3.3.3 (Pointer escape prevention):**

```cursive
procedure get_pointer(): Ptr<i32>@Valid
    [[ alloc::region |- true => true ]]
{
    region r {
        let value = ^42
        let ptr = &value           // ptr has provenance Region(r)
        result ptr                 // error[E11-101]: pointer provenance is Region(r)
    }
}
```

**Example 11.3.3.4 (Stack values can escape):**

```cursive
procedure create_value(): i32
{
    region r {
        let stack_value = 42       // Provenance: Stack (no ^)
        result stack_value         // ✅ OK: stack values can escape
    }
}
```

##### §10.3.3.7 Algorithm Reference [memory.region.escape.algorithm]

[23] The complete escape analysis algorithm, including:

- Provenance propagation for all expression forms
- Interprocedural provenance tracking
- Escape checking at all control-flow points
- Conservative analysis for complex cases

is specified in Annex E §E.2.6 [implementation.algorithms.region]. Implementations shall follow the algorithm or a refinement that rejects strictly more programs (i.e., more conservative).

#### §10.3.5 Caret Stacking for Parent Arenas [memory.region.stacking]

##### §10.3.5.1 Parent Arena Allocation

[26] Multiple caret operators allocate in parent arenas:

- `^expr` — Allocate in innermost region
- `^^expr` — Allocate in parent region (one level up)
- `^^^expr` — Allocate in grandparent region (two levels up)

[16] This enables allocating data with longer lifetimes without escaping to the heap.

**Example 11.3.4.1 (Caret stacking):**

```cursive
region outer {
    let outer_data = ^Data::new()  // Allocated in outer

    region inner {
        let inner_data = ^Data::new()   // Allocated in inner
        let parent_data = ^^Data::new()  // Allocated in outer (parent)
    }
    // inner region freed (inner_data destroyed)
    // parent_data still alive (allocated in outer)

    use(parent_data)
}
// outer region freed (outer_data and parent_data destroyed)
```

[17] Caret stacking requires named regions in future versions for explicit parent references. The current version uses implicit parent resolution based on lexical nesting.

[ Note: Region parameters and explicit parent naming are deferred to a future version of this specification.
— end note ]

#### §10.3.6 Bulk Deallocation [memory.region.bulk]

##### §10.3.6.1 O(1) Deallocation

[27] When a region exits, all allocations within that region are freed simultaneously in O(1) constant time. This is achieved through the `Arena@Active` implementation which maintains a single allocation pointer.

[28] **Performance characteristic**:

- **Allocation**: O(1) pointer bump via `arena.alloc()`
- **Individual deallocation**: Not supported (bulk only)
- **Bulk deallocation**: O(1) via `arena.reset()` or automatic at region exit

[29] This makes arenas ideal for temporary allocations in tight loops or recursive procedures.

[30] **Automatic vs explicit reset**: Region blocks automatically call `arena.free()` at scope exit (via desugared `defer` block, §11.3.3.1[15]). Named arena bindings also support explicit `reset()` for reusing arena memory mid-scope:

```cursive
region batch as workspace {
    // Phase 1: Allocate and process
    loop item in phase1_items {
        let data = workspace.alloc(process(item))
        output(data)
    }

    workspace.reset()  // Bulk free, keep arena

    // Phase 2: Reuse same memory
    loop item in phase2_items {
        let data = workspace.alloc(process(item))
        output(data)
    }
}
// workspace.free() called automatically
```

**Example 11.3.5.1 (Efficient batch processing):**

```cursive
procedure process_items(items: [Item])
    [[ alloc::region, io::write |- items.len() > 0 => true ]]
{
    loop item: Item in items {
        region iteration {
            let buffer = ^Buffer::new(4096)
            let processed = ^transform(item)
            output(buffer, processed)
        }
        // O(1) bulk free - no accumulation across iterations
    }
}
```

#### §10.3.7 Arena Passing and Pools [memory.region.pools]

##### §10.3.7.1 Passing Arenas to Procedures

[31] Named arena bindings can be passed to procedures as parameters of type `Arena@Active`:

```cursive
procedure fill_arena(workspace: Arena@Active, items: [Item])
    [[ alloc::region |- items.len() > 0 => true ]]
{
    loop item in items {
        let allocated = workspace.alloc(transform(item))
        store(allocated)
    }
}

region batch as arena {
    fill_arena(arena, data)
    // All allocations performed in batch arena
}
```

[32] **Parameter semantics**: Arena parameters are non-responsible bindings (§11.2.2.3). The procedure receives access to the arena but does not control its lifetime. The arena is destroyed when the originating `region` block exits, not when the parameter goes out of scope.

[33] **Escape prevention**: Arena bindings cannot escape their defining region block. Attempting to return or store an arena parameter produces diagnostic E11-110 (arena binding escapes region).

##### §10.3.7.2 Multiple Independent Arenas

[34] Multiple arenas with independent lifetimes use nested region blocks:

```cursive
region long_lived as persist {
    region short_lived as temp {
        persist.alloc(permanent_data())
        temp.alloc(temporary_data())
    }
    // temp freed, persist still active
}
// persist freed
```

[35] Nested arenas have LIFO lifetimes: inner arenas are freed before outer arenas.

##### §10.3.7.3 Arena Collections

[36] For multiple arenas with identical lifetimes (freed together), arenas can be collected in arrays or records. Since arena bindings from `region` blocks are non-responsible and cannot escape, arena collections require explicit arena creation (standard library feature):

```cursive
// Conceptual arena pool (standard library, not core language):
record ArenaPool {
    arenas: [Arena@Active],

    procedure with_arenas<T>(count: usize, action: ([Arena@Active]) -> T): T
        [[ alloc::region |- count > 0 => true ]]
}
```

[37] Arena collections and advanced arena management patterns are library features built on the core `Arena` modal type and `region` syntax defined in this clause. Complete specifications appear in Clause 17 (Standard Library).

#### §10.3.8 Diagnostics

[38] Region and arena diagnostics:

| Code    | Condition                                     |
| ------- | --------------------------------------------- |
| E11-101 | Region-allocated value escapes region         |
| E11-102 | Invalid caret stacking (too many ^ for depth) |
| E11-103 | Region allocation outside region block        |
| E11-110 | Arena binding escapes region                  |

#### §10.3.9 Conformance Requirements

[39] Implementations shall:

1. Implement `Arena` as a built-in modal type with @Active, @Frozen, and @Freed states per §11.3.2
2. Provide arena allocation methods: `alloc<T>`, `alloc_array<T>`, `reset`, `freeze`, `thaw`, `free`
3. Support region blocks with optional arena binding syntax (`region id as arena`)
4. Desugar region blocks to arena creation with automatic cleanup via `defer`
5. Desugar `^` operator to `arena.alloc()` calls on the active (named or implicit) arena
6. Support caret stacking (`^^`, `^^^`) for parent arena allocation
7. Perform static escape analysis rejecting region-allocated value escapes with E11-101
8. Prevent arena bindings from escaping their region blocks with E11-110
9. Provide O(1) bulk deallocation when arenas are freed or reset
10. Track region provenance as compiler metadata for escape checking (§7.5.3)
11. Integrate arena lifecycle with binding responsibility and RAII cleanup
12. Support passing arenas as `Arena@Active` parameters to procedures (non-responsible)


### §10.4 Permissions [memory.permission]

#### §10.4.1 Overview

[14] The memory model embodies the "explicit over implicit" design principle:

(14.1) **Explicit responsibility transfer**: The `move` keyword is required at call sites to transfer cleanup responsibility. Implicit transfers are forbidden.

(14.2) **Explicit permissions**: Type annotations include permission qualifiers (`const`, `unique`, `shared`) when needed. `const` is the default permission in all contexts (bindings, parameters, return types, fields); mutability requires explicit `unique` or `shared` qualifiers. The `const` qualifier may be stated explicitly for documentation but is redundant.

(14.3) **Explicit allocation**: Region allocation requires the `^` operator; there are no hidden heap allocations.

(14.4) **Explicit coordination**: The `shared` permission requires programmers to coordinate access; the compiler does not hide synchronization.

(14.5) **Explicit escape**: Escaping region-allocated data to the heap requires explicit `.to_heap()` calls.

[15] These explicit markers make memory behavior locally visible without global analysis.

[1] Permissions control what operations are allowed on values. Cursive provides three permissions: `const` (read-only), `unique` (exclusive mutable access, no aliasing), and `shared` (shared mutable with programmer coordination).

[2] Permissions are orthogonal to cleanup responsibility (§9.2). A binding can be responsible yet immutable, or non-responsible yet mutable. Permissions attach to types at binding sites as specified in §6.1.2.

[ Note: Permissions are type qualifiers, not binding modifiers. The syntax `let x: const Type` means the binding `x` has type `const Type`, where `const` is part of the type itself. Similarly, `let x: unique Type` means `x` has type `unique Type`. The permission qualifier (`const`, `unique`, or `shared`) is part of the type system, not a separate binding attribute. This distinction is important: permissions control what operations are allowed on values, while binding responsibility (determined by `=` vs `<-`) controls cleanup semantics.
— end note ]

[3] This section specifies permission semantics, the permission lattice, compile-time enforcement rules, and field-level partitioning for safe `shared` usage.

#### §10.4.2 Permission Definitions [memory.permission.definitions]

##### §10.4.2.1 Const Permission

[4] The `const` permission provides read-only access with unlimited aliasing. Multiple `const` bindings can reference the same object safely.

**Semantics:**

- ✅ Read object fields and call const methods
- ❌ Mutate object fields
- ❌ Call methods requiring unique or shared
- ✅ Create multiple `const` bindings to same object (unlimited aliasing)

[5] Permission qualifiers may be omitted; the compiler infers permissions from context. Complete inference rules are specified in §9.4.2.5 [memory.permission.inference].

[5.1] **Summary**: When permission annotation is omitted:

- If initializer has permission-qualified type: permission is inherited from initializer
- Otherwise: permission defaults to `const`
- Explicit annotations override inference

Mutability is strictly opt-in: to enable mutation, `unique` or `shared` must be explicitly specified. This ensures that all code is immutable by default, making mutation explicit and visible.

**Example 11.4.2.1 (Const permission):**

```cursive
let data: const Buffer = Buffer::new()
let ref1: const <- data
let ref2: const <- data
let ref3: const <- data      // Multiple const bindings allowed

println("{}", data.size())   // Read-only access OK
// data.modify()             // error[E10-301]: cannot mutate through const
```

##### §10.4.2.2 Unique Permission

[6] **Semantics:**

- ✅ Read and mutate object fields
- ✅ Call any methods (const, unique, shared)
- ❌ Create second `unique` binding while first is active
- ❌ Create `shared` binding while `unique` is active
- ✅ Create temporary `const` binding (downgrade)

[6.1] **Exclusivity clarification**: `unique` exclusivity means no other `unique` OR `shared` bindings to the same object can coexist. Temporary downgrades to `const` are permitted; during the downgrade, the `unique` binding becomes inactive and regains exclusive access when the `const` binding exits scope.

[6.2] **Formal constraint:**

[ Given: Active `unique` binding $x$ to object $o$ ]

$$
\frac{x : \text{unique } \tau \text{ active} \quad y \text{ attempts binding to } o}
     {\text{Permission}(y) \in \{\text{unique}, \text{shared}\} \Rightarrow \text{ERROR E10-302}}
\tag{WF-Unique-Exclusive}
$$

Creating `const` bindings is permitted (downgrade), but `unique` becomes temporarily inactive.

**Example 11.4.2.2 (Unique permission):**

```cursive
let data: unique Buffer = Buffer::new()

data.append(42)              // Mutation allowed

let second: unique <- data   // error[E10-302]: unique already active
```

##### §10.4.2.3 Shared Permission

[7] The `shared` permission provides shared mutable access. Multiple `shared` bindings can coexist; programmers coordinate to prevent conflicts.

**Semantics:**

- ✅ Read and mutate object fields
- ✅ Create multiple `shared` bindings
- ⚠️ Programmer responsible for coordination
- ✅ Field-level partitioning prevents same-field multi-access (§11.4.6)

**Example 11.4.2.3 (Shared permission):**

```cursive
let data: shared Buffer = Buffer::new()
let ref1: shared <- data
let ref2: shared <- data     // Multiple shared bindings allowed

ref1.set_flag(true)          // Both can mutate
ref2.set_counter(10)         // Programmer ensures no conflicts
```

##### §10.4.2.4 No Interior Mutability

[8] **Design principle**: `const` means const. There is no interior mutability: if a value has `const` permission, it is immutable. No hidden mutation through `const` is permitted.

[ Rationale: Some languages provide interior mutability mechanisms that allow mutation through immutable references. Cursive explicitly rejects this pattern to maintain the "explicit over implicit" design principle. If mutation is needed, use `unique` or `shared` permission explicitly.
— end rationale ]

##### §10.4.2.5 Permission Inference Rules [memory.permission.inference]

[9] **THIS SECTION IS AUTHORITATIVE** for permission inference. When a binding omits explicit permission annotation, the compiler infers permission using the following precedence:

**Rule 1: Explicit annotation** (highest precedence)

If permission is explicitly specified, use it: `let x: unique T = value`

**Rule 2: Inheritance from initializer**

If initializer has permission-qualified type, inherit that permission:

```cursive
let unique_data: unique Buffer = Buffer::new()
let inherits = unique_data       // Inferred: unique Buffer
```

**Rule 3: Default to const** (fallback)

Otherwise, default to `const`:

```cursive
let x: i32 = 42                  // Inferred: const i32
procedure f(p: Buffer)           // Inferred: const Buffer
procedure make(): Buffer         // Inferred: const Buffer
```

**Formal Inference Rule:**

[ Given: Binding declaration $x$ with optional annotation $A$ and initializer $e$ of type $\tau_e$ ]

$$
\frac{\Gamma \vdash e : \text{perm}_e\, \tau_e \quad A = \text{none}}{\Gamma \vdash x : \text{perm}_e\, \tau_e}
\tag{Infer-Perm-Inherit}
$$

$$
\frac{\Gamma \vdash e : \tau_e \quad A = \text{none}}{\Gamma \vdash x : \text{const}\, \tau_e}
\tag{Infer-Perm-Default}
$$

**Permission Inference Examples:**

**Example 11.4.2.5 (Permission inference):**

```cursive
let explicit: unique Buffer = Buffer::new()    // Explicit unique
let inherits = explicit                        // Inferred: unique (inherits from explicit)
let downgrades: const = explicit               // Explicit: const (downgrade)

procedure process(data: Buffer)                // Inferred: const Buffer
procedure modify(data: unique Buffer)          // Explicit: unique Buffer

let param_const = process(explicit)            // OK: unique → const coercion at call
```

**Diagnostic E10-320: Ambiguous permission inference**

[9.1] When permission cannot be uniquely inferred (for example, in complex generic contexts), the compiler shall emit diagnostic E10-320 requesting an explicit annotation:

```cursive
// Ambiguous: Cannot infer permission from context
// let ambig = if cond { unique_val } else { shared_val }  // error[E10-320]

// Resolved: Explicit annotation
let resolved: const = if cond { unique_val } else { shared_val }  // OK: downgrade both
```

#### §10.4.3 Permission Lattice [memory.permission.lattice]

##### §10.4.3.1 Subtyping Relations

[10] Permissions form a lattice with subtyping relations:

$$
\text{unique} <: \text{shared} <: \text{const}
$$

[11] **Downgrade rules**: Permissions can downgrade (stronger → weaker) implicitly:

$$
\frac{\Gamma \vdash e : \text{unique } \tau}{\Gamma \vdash e : \text{shared } \tau}
\tag{Coerce-Unique-Shared}
$$

$$
\frac{\Gamma \vdash e : \text{unique } \tau}{\Gamma \vdash e : \text{const } \tau}
\tag{Coerce-Unique-Const}
$$

$$
\frac{\Gamma \vdash e : \text{shared } \tau}{\Gamma \vdash e : \text{const } \tau}
\tag{Coerce-Shared-Const}
$$

[12] **No upgrades**: Permissions cannot upgrade (weaker → stronger). Attempting to treat `const` as `unique` produces diagnostic E10-303.

##### §10.4.3.2 Permission Lattice Diagram

[13] Visual representation:

```
        unique (most restrictive)
         /  \
        /    \
    shared   (middle)
        \    /
         \  /
        const (least restrictive)
```

#### §10.4.4 Permission Checking [memory.permission.checking]

##### §10.4.4.1 Active Reference Tracking

[14] The compiler tracks active bindings with non-`const` permissions to enforce uniqueness and detect conflicts:

(14.1) When a `unique` binding is created, the compiler records it as active.

(14.2) While a `unique` binding is active, creating another `unique` or `shared` binding to the same object is forbidden.

(14.3) When the `unique` binding goes out of scope, it becomes inactive.

[15] **Unique enforcement rule**:

[ Given: Object $o$, active `unique` binding $x$ ]

$$
\frac{x : \text{unique } \tau \text{ active} \quad y \text{ attempts } \text{unique or shared binding to same object}}{\text{ERROR E10-302: unique permission already active}}
\tag{WF-Unique-Exclusive}
$$

##### §10.4.4.2 Temporary Downgrade

[16] A `unique` binding can temporarily downgrade to `const`:

**Example 11.4.4.1 (Temporary const downgrade):**

```cursive
let data: unique Buffer = Buffer::new()

{
    let reader: const <- data   // Temporarily downgrade to const
    println("{}", reader.size())
    // data.modify()             // error: cannot use unique while const active
}

// Const binding out of scope
data.modify()                    // OK: unique restored
```

#### §10.4.5 Field-Level Partitioning [memory.permission.partitioning]

##### §10.4.5.1 Overview

[17] Field-level partitioning prevents accessing the same field multiple times through `shared` bindings, eliminating iterator invalidation and aliasing hazards while preserving the ability to access different fields simultaneously.

##### §10.4.5.2 Partition Directive Syntax

[18] Partition directives appear in record bodies:

**Partition directives** take one of the following forms:
```
"<<" <identifier> ">>"
"<<" "_" ">>"    // Reset to default
```

**Record bodies** match the pattern:
```
"{" [ <partition_directive> | <record_field> ... ] "}"
```

[ Note: See Annex A §A.6 [grammar.declaration] for complete record grammar with partition directives.
— end note ]

[19] **Default behavior**: Each field is its own partition unless a directive groups them.

**Example 11.4.5.1 (Partition directives):**

```cursive
record World {
    entities: [Entity],      // Default: World::entities partition

    <<Physics>>
    positions: [Position],   // Physics partition
    velocities: [Velocity],  // Physics partition

    <<Combat>>
    healths: [Health],       // Combat partition
}
```

##### §10.4.5.3 Partition Access Rules

[20] **Single-access rule**: Through a `shared` binding, each partition can be accessed at most once in a scope.

[ Given: Shared binding $s$, field $f$ in partition $p$ ]

$$
\frac{s : \text{shared } R \quad f \in \text{partition } p \quad \text{active access to partition } p}{\text{ERROR E10-310: partition already accessed}}
\tag{WF-Partition-Single}
$$

[21] **Different-partition freedom**: Accessing fields in different partitions is allowed:

**Example 11.4.5.2 (Partition access):**

```cursive
let world: shared World = World::new()

let pos_ref: shared <- world.positions     // Access Physics partition
let health_ref: shared <- world.healths    // Access Combat partition (OK: different)

// let vel_ref: shared <- world.velocities  // error[E10-310]: Physics partition already active
```

[22] The `<<_>>` directive resets to default partitioning (each field separate).

##### §10.4.5.4 Nested Field Access and Partitions [memory.permission.partitioning.nested]

[23] **Nested field access behavior.** Partition access tracking applies only to direct field access on the `shared` binding itself. Once a field reference is obtained, further nested field access through that reference does not count as re-accessing the partition.

[ Given: Shared binding $s$ with field $f$ in partition $p$, resulting reference $r$ ]

$$
\frac{s: \text{shared } R \quad r \gets s.f \quad f \in \text{partition } p}{\text{nested accesses through } r \text{ do not re-check partition } p}
\tag{P-Partition-Nested}
$$

[24] The partition constraint is enforced at the initial field access point. Subsequent operations through the obtained reference (further field access, method calls, indexing) are unrestricted by partition rules.

**Example 11.4.5.3 (Nested access through partition):**

```cursive
record Inner { x: i32, y: i32 }
record Outer {
    <<PartA>>
    field1: Inner,
    field2: Inner,
}

let obj: shared Outer = Outer::new()
let ref1: shared <- obj.field1       // Accesses PartA partition
let x_coord = ref1.x                 // OK: accessing through ref1, not obj
let y_coord = ref1.y                 // OK: nested access doesn't re-check partition

// let ref2: shared <- obj.field2    // error[E10-310]: PartA partition already accessed
```

[25] This design allows normal operation on obtained references while preventing multiple direct accesses to the same partition, balancing safety with usability.

#### §10.4.6 Diagnostics

[26] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.10. — end note]

#### §10.4.7 Conformance Requirements

[27] Implementations shall provide compile-time permission checking with zero runtime overhead.


### §10.5 Move, Copy, and Clone Semantics [memory.move]

#### §10.5.1 Overview

[1] This section specifies how values transfer between bindings, when cleanup responsibility transfers, and how types opt into copying behavior. Cursive uses explicit `move` for responsibility transfer and explicit `Copy`/`Clone` behaviors for duplication.

[2] The binding category (`let` vs `var`) combined with assignment operator (`=` vs `<-`) determines transfer behavior. Permissions (§11.4) are orthogonal to transfer semantics.

#### §10.5.2 Move Semantics [memory.move.move]

##### §10.5.2.1 Overview

[3] The `move` keyword explicitly transfers cleanup responsibility from one binding to another. After a move, the source binding becomes invalid.

##### §10.5.2.2 Syntax

[4] Move expression syntax:

**Move expressions** match the pattern:

```
"move" <identifier>
```

[ Note: See Annex A §A.4 [grammar.expression] for complete move syntax.
— end note ]

##### §10.5.2.3 Transfer Rules by Binding Category

[5] Transfer eligibility follows the binding semantics specified in §4.2.5 [decl.variable.operator], Table 4.2.5 in that section.

##### §10.5.2.4 Move Semantics

[7] Move execution:

[ Given: Source binding $x$ with cleanup responsibility ]

$$
\frac{\Gamma \vdash x : \tau \quad x \text{ is responsible and transferable}}{\Gamma \vdash \texttt{move } x : \tau \quad x \text{ becomes invalid}}
\tag{E-Move}
$$

[8] After `move x`:

- Cleanup responsibility transfers to the receiving binding
- `x` becomes invalid (moved-from state)
- Using `x` produces diagnostic E10-503 (use of moved value)

**Example 11.5.2.1 (Move transfers responsibility):**

```cursive
procedure consume(data: Buffer)
    [[ |- true => true ]]
{
    // data is responsible; will call destructor at end
}

procedure demo()
    [[ alloc::heap |- true => true ]]
{
    let buffer = Buffer::new()      // buffer is responsible
    consume(move buffer)             // Responsibility transferred to parameter
    // buffer is now invalid
    // buffer.size()                 // error[E10-503]: use of moved value
}
```

**Example 11.5.2.2 - invalid (Move from var):**

```cursive
var counter = Buffer::new()
consume(move counter)  // error[E10-501]: cannot transfer from var binding
```

[1] `var` bindings cannot transfer because allowing moves would require whole-function analysis to track whether the binding might be rebound after the move, violating Cursive's local reasoning principle.

#### §10.5.3 Copy Semantics [memory.move.copy]

##### §10.5.3.1 Copy Behavior

[9] Types satisfying the `Copy` behavior can be duplicated bitwise. Copying creates a new independent object with its own cleanup responsibility.

[10] **Copy behavior**: The `Copy` behavior is defined in Clause 8 (Generics and Behaviors). This section specifies how Copy interacts with the memory model.

[11] Types that satisfy `Copy`:

- All primitive types (§7.2): integers, floats, bool, char, ()
- Tuples and records where all fields satisfy `Copy`
- Types without custom destructors

[12] Types that do NOT satisfy `Copy`:

- Types with custom destructors
- Types containing non-Copy fields
- Most resource-managing types (File, Socket, Buffer)

##### §10.5.3.2 Copy Syntax

[13] Copying requires explicit `copy` keyword:

```cursive
let original: i32 = 42
let duplicate = copy original    // Explicit bitwise copy
```

[14] Attempting to copy non-Copy types produces diagnostic E10-510.

**Example 11.5.3.1 (Copy for primitive types):**

```cursive
let a: i32 = 10
let b = copy a       // OK: i32 satisfies Copy
let c = copy a       // OK: can copy multiple times

// All three bindings (a, b, c) are responsible for their own values
```

#### §10.5.4 Clone Semantics [memory.move.clone]

##### §10.5.4.1 Clone Behavior

[15] The `Clone` behavior enables deep copying for types that cannot use bitwise `Copy`. Clone creates a semantically equivalent but independent object. The `Clone` behavior is defined in Clause 8 (Generics and Behaviors).

[16] Types implement `Clone` by providing a `clone` method that performs type-specific duplication (allocating new resources, copying contents, etc.).

**Example 11.5.4.1 (Clone for complex types):**

```cursive
let original: Buffer = Buffer::from_data(data)
let cloned = original.clone()    // Deep copy: allocates new buffer

// Both original and cloned are responsible for their own buffers
```

#### §10.5.5 Moved-From State [memory.move.movedFrom]

##### §10.5.5.1 Invalid Binding State

[17] After `move x`, the binding `x` enters moved-from state. Definite assignment analysis (§4.7) tracks this state and prevents further use.

[18] **Moved-from constraint**:

[ Given: Binding $x$ in moved-from state ]

$$
\frac{x \text{ in moved-from state} \quad \text{attempt to use } x}{\text{ERROR E10-503: use of moved value}}
\tag{WF-No-Use-After-Move}
$$

##### §10.5.5.2 Invalidation of Derived Non-Responsible Bindings

[18.1] Non-responsible bindings become invalid when their source binding is moved to a responsible parameter. Complete invalidation rules and validity tracking are specified in §4.7.5 [decl.initialization].

##### §10.5.5.3 Rebinding Var Without Transfer

[19] While `var` bindings cannot be moved (they are non-transferable per §4.2.5 [decl.variable.operator]), they can be reassigned in place, with the old value being destroyed before the new value is bound:

**Example 11.5.5.3 (Var rebinding without move):**

```cursive
var data = Buffer::new()      // data is responsible
// consume(move data)         // error[E10-501]: cannot transfer from var

// However, var bindings can be reassigned:
data = Buffer::new()           // Old buffer destroyed, new buffer bound
data.size()                    // OK: data is valid with new buffer
```

[20] When rebinding a `var`, the old value (if valid) is automatically cleaned up before the new value is assigned. This is distinct from transfer: the binding retains cleanup responsibility for both the old and new values.

**Example 11.5.5.4 (Pattern: Use let + unique for mutable+transferable):**

```cursive
// When you need both mutation AND transfer:
let builder: unique = Builder::new()   // Use let + unique, not var
builder.add(1)                         // Can mutate via unique
builder.add(2)
consume(move builder)                  // Can transfer via let
```

[20] `let` bindings cannot be reassigned (§4.2); once moved, they remain invalid for their entire scope. See §4.2.5 Example 4.2.5.1 for binding operator semantics.

#### §10.5.6 Diagnostics

[21] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.10. — end note]

#### §10.5.7 Conformance Requirements

[22] Implementations shall integrate move tracking with definite assignment analysis (§4.7) and maintain orthogonality between transfer rules and permissions.


### §10.6 Layout and Alignment [memory.layout]

#### §10.6.1 Overview

[1] This section provides normative rules for calculating sizes, alignments, field offsets, and padding for all type categories.

[2] Layout determines ABI compatibility (Clause 15), memory efficiency, and platform-specific representations. Alignment ensures correct hardware access and prevents undefined behavior on strict-alignment platforms.

#### §10.6.2 Alignment Rules [memory.layout.alignment]

##### §10.6.2.1 Alignment Definition

[3] The alignment of type `T`, denoted $\text{align}(T)$, is a power of two indicating that objects of type `T` must be placed at addresses divisible by that value.

$$
\text{align}(T) = 2^k \quad \text{where } k \in \mathbb{N} \cup \{0\}
$$

[4] Violating alignment produces undefined behavior [UB-ID: B.2.10] on platforms with strict alignment.

##### §10.6.2.2 Alignment by Type

[5] Table 11.6 specifies alignment for each type category:

**Table 11.6 — Alignment by type**

| Type Category       | Alignment Rule     | Example                        |
| ------------------- | ------------------ | ------------------------------ |
| `i8`, `u8`, `bool`  | 1 byte             | `align(i8) = 1`                |
| `i16`, `u16`        | 2 bytes            | `align(i16) = 2`               |
| `i32`, `u32`, `f32` | 4 bytes            | `align(i32) = 4`               |
| `i64`, `u64`, `f64` | 8 bytes            | `align(f64) = 8`               |
| `i128`, `u128`      | 8 or 16 bytes\*    | Implementation-defined         |
| `char`, `()`        | 1 byte             | Implementation-defined ≥ 1     |
| Pointers            | Word size          | `align(Ptr<T>) = align(usize)` |
| Tuples              | max(align(fields)) | `align((i8, i32)) = 4`         |
| Records             | max(align(fields)) | Based on field alignments      |
| Arrays              | align(element)     | `align([T; n]) = align(T)`     |

\*Implementations shall document whether `i128`/`u128` use 8 or 16-byte alignment.

##### §10.6.2.3 Explicit Alignment

[6] The `[[repr(align(N))]]` attribute forces minimum alignment:

$$
N \geq \text{align}_{\text{natural}}(T)
$$

[7] Violating this constraint (specifying alignment smaller than natural) produces diagnostic E11-601.

**Example 11.6.2.1 (Explicit alignment):**

```cursive
[[repr(align(64))]]
record CacheLine {
    data: [u8; 64],
}
// CacheLine objects guaranteed 64-byte alignment (cache-line aligned)
```

#### §10.6.3 Size and Layout [memory.layout.size]

##### §10.6.3.1 Size Calculation

[8] The size of type `T`, denoted $\text{size}(T)$, includes all fields plus padding to maintain alignment for arrays.

[9] For records, size is calculated:

$$
\text{size}(R) = \text{last\_field\_end} + \text{tail\_padding}
$$

where:

$$
\text{tail\_padding} = (-\text{last\_field\_end}) \bmod \text{align}(R)
$$

[10] This ensures $\text{size}(T)$ is always a multiple of $\text{align}(T)$.

##### §10.6.3.2 Field Layout

[11] Record fields are laid out in declaration order with padding inserted to satisfy alignment:

[ Given: Record `R { f₁: T₁, ..., fₙ: Tₙ }` ]

$$
\text{offset}(R, f_i) \equiv 0 \pmod{\text{align}(T_i)}
$$

[12] Each field offset is the minimum value satisfying the field's alignment constraint and following all previous fields.

**Example 11.6.3.1 (Field layout with padding):**

```cursive
record Example {
    a: u8,      // Offset 0, size 1
    // 3 bytes padding
    b: i32,     // Offset 4, size 4
    c: u8,      // Offset 8, size 1
    // 3 bytes tail padding
}
// size(Example) = 12, align(Example) = 4
```

#### §10.6.4 Representation Attributes [memory.layout.repr]

##### §10.6.4.1 Overview

[13] Representation attributes control memory layout. They modify size, alignment, and field ordering without changing type semantics.

##### §10.6.4.2 Packed Layout

[14] `[[repr(packed)]]` removes all padding, setting alignment to 1:

$$
\text{align}(\text{packed } R) = 1
$$

[15] Packed layouts may cause performance penalties on platforms preferring aligned access.

**Example 11.6.4.1 (Packed layout):**

```cursive
[[repr(packed)]]
record Packed {
    a: u8,      // Offset 0
    b: i32,     // Offset 1 (no padding!)
    c: u8,      // Offset 5
}
// size(Packed) = 6, align(Packed) = 1
```

##### §10.6.4.3 C-Compatible Layout

[16] `[[repr(C)]]` uses C-compatible field layout for FFI (Clause 15):

- Fields in declaration order
- Platform-specific padding rules (C ABI)
- Ensures interoperability with C code

##### §10.6.4.4 Transparent Layout

[17] `[[repr(transparent)]]` adopts the layout of a single non-zero-sized field. Valid only for single-field wrappers.

#### §10.6.5 Diagnostics

[18] Layout diagnostics:

| Code    | Condition                                         |
| ------- | ------------------------------------------------- |
| E11-601 | Explicit alignment smaller than natural alignment |
| E11-602 | Invalid repr attribute combination                |
| E11-603 | Transparent applied to multi-field type           |

#### §10.6.6 Conformance Requirements

[19] Implementations shall:

1. Calculate alignment as power of two per §11.6.2
2. Compute field offsets satisfying alignment constraints
3. Insert padding between fields and at struct end
4. Support repr attributes (packed, align, C, transparent)
5. Document platform-specific alignment for i128/u128
6. Provide sizeof and alignof compile-time queries
7. Ensure arrays maintain element alignment


### §10.7 Aliasing and Uniqueness Rules [memory.aliasing]

#### §10.7.1 Overview

[1] This section specifies when multiple bindings may reference the same memory location (aliasing), how the `unique` permission prevents aliasing, and how field-level partitioning enables safe `shared` usage.

[2] Aliasing is controlled through permissions: `const` allows unlimited aliasing, `shared` allows coordinated aliasing, and `unique` prevents aliasing through compile-time enforcement.

#### §10.7.2 Aliasing Definition [memory.aliasing.definition]

##### §10.7.2.1 Formal Definition

[3] Two bindings $x$ and $y$ _alias_ when they reference overlapping memory locations:

$$
\text{alias}(x, y) \iff \text{location}(x) \cap \text{location}(y) \ne \emptyset
$$

[4] For scalar types (§7.2), bindings alias when they reference the exact same location. For composite types (§7.3), bindings alias when they reference overlapping fields or elements.

##### §10.7.2.2 Aliasing Examples

**Example 11.7.2.1 (Aliasing through non-responsible bindings):**

```cursive
let data = Buffer::new()      // data is responsible
let ref1 <- data              // ref1 aliases data
let ref2 <- data              // ref2 aliases data and ref1

// All three bindings reference the same Buffer object
// Only data has cleanup responsibility
```

##### §10.7.2.3 Field Aliasing

[5] Field access creates aliases:

**Example 11.7.2.2 (Field aliasing):**

```cursive
record Point { x: f64, y: f64 }

let point = Point { x: 3.0, y: 4.0 }
let x_ref <- point.x          // Aliases point's x field
let y_ref <- point.y          // Aliases point's y field (different location)

// x_ref and y_ref do NOT alias each other (different fields)
```

#### §10.7.3 Unique Permission Enforcement [memory.aliasing.unique]

##### §10.7.3.1 Overview

[6] The `unique` permission guarantees exclusive access: no other `unique` or `shared` bindings to the same object can coexist. The compiler enforces this through active reference tracking. Temporary downgrades to `const` are permitted.

##### §10.7.3.2 Unique Exclusivity Rule

[7] When a `unique` binding is active, creating another `unique` or `shared` binding to the same object is forbidden:

[ Given: Active `unique` binding $x$ to object $o$ ]

$$
\frac{x : \text{unique } \tau \text{ active} \quad y \text{ attempts binding to } o \quad y : (\text{unique} \mid \text{shared}) \tau}{\text{ERROR E11-302: unique permission already active}}
\tag{WF-Unique-No-Alias}
$$

[8] The exclusivity holds until $x$ goes out of scope or is moved.

##### §10.7.3.3 Temporary Const Allowed

[9] Creating `const` bindings from `unique` is allowed (permission downgrade):

**Example 11.7.3.1 (Unique with const downgrade):**

```cursive
let data: unique Buffer = Buffer::new()

{
    let reader: const <- data     // OK: downgrade to const
    println("{}", reader.size())
    // data.modify()               // error: cannot use unique while const active
}

data.modify()                      // OK: unique restored after const out of scope
```

#### §10.7.4 Shared Permission Coordination [memory.aliasing.shared]

##### §10.7.4.1 Overview

[10] The `shared` permission allows multiple mutable bindings. The compiler does NOT prevent aliasing for `shared`; programmers coordinate access to prevent conflicts.

##### §10.7.4.2 Field-Level Protection

[11] Field-level partitioning (§11.4.5) prevents accessing the same field multiple times through `shared`, while allowing different-field access:

**Example 11.7.4.1 (Shared with partition protection):**

```cursive
record World {
    <<Physics>>
    positions: [Position],
    velocities: [Velocity],

    <<Rendering>>
    sprites: [Sprite],
}

let world: shared World = World::new()

let pos: shared <- world.positions      // Access Physics partition
let spr: shared <- world.sprites        // Access Rendering partition (OK: different)

// let vel: shared <- world.velocities  // error[E11-310]: Physics partition already active
```

#### §10.7.5 Active Reference Tracking [memory.aliasing.tracking]

##### §10.7.5.1 Tracking Algorithm

[12] The compiler tracks active non-`const` bindings to enforce uniqueness and partition rules:

**Tracking state per object:**

- **Unique active**: One `unique` binding exists; no other `unique` or `shared` allowed
- **Shared active**: One or more `shared` bindings exist; tracks which partitions are active
- **Const only**: Zero or more `const` bindings; any permission can be added

[13] **State transitions**:

$$
\begin{align*}
\text{None} &\xrightarrow{\text{create unique}} \text{Unique}(x) \\
\text{None} &\xrightarrow{\text{create shared}} \text{Shared}(\{p_1, \ldots\}) \\
\text{Unique}(x) &\xrightarrow{x \text{ out of scope}} \text{None} \\
\text{Shared}(P) &\xrightarrow{\text{all out of scope}} \text{None}
\end{align*}
$$

#### §10.7.6 Diagnostics

[14] Aliasing diagnostics:

| Code    | Condition                                 |
| ------- | ----------------------------------------- |
| E11-701 | Multiple `unique` bindings to same object |
| E11-702 | `shared` binding while `unique` active    |
| E11-703 | `unique` binding while `shared` active    |

[ Note: E11-302 (duplicate unique) is defined in §11.4. E11-310 (partition conflict) is defined in §11.4.5.
— end note ]

#### §10.7.7 Conformance Requirements

[15] Implementations shall:

1. Track active bindings with `unique` and `shared` permissions
2. Enforce unique exclusivity: reject multiple `unique` or `shared` while `unique` active
3. Allow unlimited `const` aliasing
4. Implement partition tracking for `shared` field access
5. Provide compile-time aliasing checks with zero runtime cost
6. Integrate with escape analysis (§11.3) for pointer aliasing
7. Maintain aliasing rules across all binding forms (let/var, =/←)


### §10.8 Unsafe Blocks and Safety Obligations [memory.unsafe]

#### §10.8.1 Overview

[1] Unsafe blocks explicitly mark code where the programmer assumes responsibility for memory safety. They enable operations that the compiler cannot verify safe: raw pointer dereference, pointer arithmetic, transmute, and FFI calls.

[2] Safety obligations in unsafe code are programmer responsibilities. The compiler does not enforce memory safety within `unsafe` blocks but still requires syntactic and type correctness.

[3] Unsafe code is necessary for FFI (Clause 15), performance-critical operations, and implementing safe abstractions over unsafe primitives.

#### §10.8.2 Unsafe Block Syntax [memory.unsafe.syntax]

##### §10.8.2.1 Block Form

[4] Unsafe block syntax:

**Unsafe blocks** match the pattern:
```
"unsafe" <block_stmt>
```

[ Note: See Annex A §A.5 [grammar.statement] for complete unsafe syntax.
— end note ]

[5] The `unsafe` keyword marks a block where memory safety is programmer-verified rather than compiler-verified.

**Example 11.8.2.1 (Unsafe block):**

```cursive
procedure raw_write(ptr: *mut i32, value: i32)
    [[ unsafe::ptr |- true => true ]]
{
    unsafe {
        *ptr = value    // Raw pointer write
    }
}
```

#### §10.8.3 Unsafe Operations [memory.unsafe.operations]

##### §10.8.3.1 Operations Requiring Unsafe

[6] The following operations are permitted only within `unsafe` blocks:

(6.1) **Raw pointer dereference**: `*ptr` where `ptr: *const T` or `*mut T`

(6.2) **Raw pointer write**: `*ptr = value` where `ptr: *mut T`

(6.3) **Pointer arithmetic**: `ptr.offset(n)`, `ptr.add(n)`, `ptr.sub(n)`

(6.4) **Transmute**: `transmute::<From, To>(value)` (bitwise reinterpretation)

(6.5) **Calling unsafe functions**: Functions marked `unsafe` in their signature

(6.6) **Inline assembly**: Platform-specific assembly blocks (Clause 15)

[7] Attempting these operations outside `unsafe` blocks produces diagnostics (E11-801 series).

##### §10.8.3.2 Raw Pointers

[8] Raw pointer types `*const T` and `*mut T` (§7.5.5) bypass safety guarantees:

- No lifetime tracking
- No provenance verification
- No null checking
- No alignment verification
- Dereference requires `unsafe` block

**Example 11.8.3.1 (Raw pointer usage):**

```cursive
procedure unsafe_read(ptr: *const i32): i32
    [[ unsafe::ptr |- true => true ]]
{
    unsafe {
        result *ptr  // Programmer ensures: ptr valid, aligned, initialized
    }
}
```

##### §10.8.3.3 Transmute

[9] Transmute reinterprets bit patterns between types:

```cursive
unsafe {
    let bits: u32 = 0x4048_0000
    let float: f32 = transmute::<u32, f32>(bits)  // Reinterpret as f32
}
```

[10] **Safety obligations**:

- Source and target types must have same size
- Bit pattern must be valid for target type
- Alignment must be compatible

[11] Violating transmute safety produces undefined behavior [UB-ID: B.2.25].

#### §10.8.4 Safety Obligations [memory.unsafe.obligations]

##### §10.8.4.1 Programmer Responsibilities

[12] Within `unsafe` blocks, programmers must manually ensure:

(12.1) **Pointer validity**: Dereferenced pointers are valid, aligned, and initialized

(12.2) **Lifetime correctness**: Accessed memory has not been freed

(12.3) **Type safety**: Transmute target types match bit patterns

(12.4) **Alignment**: Pointer addresses satisfy type alignment requirements

(12.5) **Initialization**: Read values are properly initialized

[13] Violating these obligations produces undefined behavior. The compiler provides no safety net.

##### §10.8.4.2 Unsafe Function Declaration

[14] Functions containing unsafe operations shall declare required grants:

**Example 11.8.4.1 (Unsafe function signature):**

```cursive
procedure unsafe_operation(ptr: *mut Data)
    [[ unsafe::ptr |- true => true ]]  // Declares unsafe grant requirement
{
    unsafe {
        (*ptr).field = compute_value()
    }
}
```

[15] The `unsafe::ptr` grant documents that the function performs unsafe pointer operations.

#### §10.8.5 Unsafe and FFI [memory.unsafe.ffi]

##### §10.8.5.1 FFI Integration

[16] Foreign function calls (Clause 15) implicitly require unsafe:

```cursive
extern "C" procedure c_function(ptr: *const i32): i32

procedure call_c()
    [[ ffi::call |- true => true ]]
{
    let value: i32 = 42
    unsafe {
        let result = c_function(&value as *const i32)
    }
}
```

[17] Complete FFI safety obligations are specified in Clause 15 §15.1 [interop.ffi] and §15.2 [interop.unsafe].

#### §10.8.6 Diagnostics

[18] Unsafe diagnostics:

| Code    | Condition                                |
| ------- | ---------------------------------------- |
| E11-801 | Raw pointer dereference outside `unsafe` |
| E11-802 | Raw pointer write outside `unsafe`       |
| E11-803 | Transmute outside `unsafe`               |
| E11-804 | Transmute size mismatch                  |
| E11-805 | Inline assembly outside `unsafe`         |

#### §10.8.7 Conformance Requirements

[19] Implementations shall:

1. Support `unsafe { }` blocks marking unchecked operations
2. Require `unsafe` blocks for raw pointer operations
3. Require `unsafe` blocks for transmute operations
4. Enforce grant requirements (unsafe::ptr, ffi::call) in contractual sequents
5. Document undefined behavior triggered by unsafe violations
6. Provide diagnostic guidance for common unsafe pitfalls
7. Integrate unsafe with FFI (Clause 15)
8. Maintain type checking within unsafe blocks (syntax must still be valid)


### §11.1 Overview and Model [contract.overview]

#### §11.1.1 Overview

[1] The contract system provides mechanisms for specifying and verifying behavioral requirements on procedures and types through _sequents_. A sequent is a formal specification attached to procedure declarations that expresses required capabilities (grants), caller obligations (preconditions), and callee guarantees (postconditions).

[2] Sequents enable grant tracking, interface specification, static and dynamic verification, documentation, and optimization based on proven contract guarantees.

[3] Cursive's contract system uses sequent calculus notation: ⟦ G ⊢ P ⇒ Q ⟧ where G represents capability requirements (grants), P represents preconditions, and Q represents postconditions. Complete syntax and semantics are specified in §11.2 [contract.sequent].

#### §11.1.2 Contracts vs Behaviors [contract.overview.distinction]

[4] Cursive employs two distinct polymorphism mechanisms that serve complementary purposes:

- **Contracts** (this clause): Abstract interface specifications with no implementations
- **Behaviors** (Clause 9 §9.4): Concrete code reuse with default implementations

[5] **For complete comparison of contracts vs behaviors, including syntax, dispatch mechanisms, and use cases, see Table 9.4.1 in §9.4.1.2 [generic.behavior.overview].**

[6] The key distinction: Contracts specify requirements (procedures have NO bodies), while behaviors provide implementations (procedures MUST have bodies). Types may attach both:

```cursive
record Account: Ledgered, Auditable with Serializable, Display {
    // Ledgered, Auditable: contracts (abstract requirements)
    // Serializable, Display: behaviors (concrete code reuse)
}
```

[7] The separation ensures that interface obligations remain distinct from implementation sharing.

#### §11.1.3 Sequent Structure and Components [contract.overview.structure]

[8] A complete sequent has three components:

**Grant component** (before turnstile):
[9] The grant component lists capability tokens that must be available for the procedure to execute. Grants represent permissions to perform observable effects: file I/O, network access, heap allocation, etc. The grant system is specified in detail in §11.3.

**Preconditions** (must clause):
[10] Preconditions specify conditions that must hold when the procedure is called. They represent _caller obligations_: the caller must ensure preconditions are satisfied before invoking the procedure. Preconditions are specified in §11.4.

**Postconditions** (will clause):
[11] Postconditions specify conditions that will hold when the procedure returns normally. They represent _callee guarantees_: the procedure implementation must ensure postconditions are satisfied on all non-diverging exit paths. Postconditions are specified in §11.5.

[12] All three components are optional with smart defaulting (§11.2.2.2):

- Omitted grant component: Empty grant set `∅` (pure procedure)
- Omitted preconditions: `true` (no requirements)
- Omitted postconditions: `true` (no guarantees)
- Entirely omitted sequent: `[[ |- true => true ]]`

[13] Cursive provides `where` clauses for declaring _invariants_: conditions that must always hold at observable program points. Invariants desugar to conjunctions in sequent postconditions.

**Type invariants**:
[14] Type declarations may include `where` clauses specifying type-level invariants. These desugar to implicit postcondition conjunctions on all constructors and mutating methods:

```cursive
record BankAccount {
    balance: i64,

    where {
        balance >= 0
    }

    procedure deposit(~!, amount: i64)
        [[ ledger::post |- amount > 0 => self.balance >= amount ]]
    {
        self.balance += amount
    }
}
```

[15] The `where { balance >= 0 }` invariant automatically extends the postcondition of `deposit` to:

$$
\texttt{will} \; (\texttt{self.balance} \ge \texttt{amount}) \land (\texttt{self.balance} \ge 0)
$$

The compiler inserts the invariant check automatically; programmers need not write it explicitly.

**Loop invariants**:
[16] Loop statements may include `where` clauses specifying loop invariants. These conditions must hold on loop entry, at the start of each iteration, and on loop exit:

```cursive
loop i in 0..array.len() where { i >= 0, i <= array.len() } {
    // Invariant checked: entry, each iteration, exit
}
```

[17] Complete invariant semantics and desugaring rules are specified in §11.6.

#### §11.1.4 Verification and Contract Declarations [contract.overview.verification]

[18] Sequents are verified through a combination of static proof and dynamic checking:

**Static verification** (compile-time):
[19] The compiler attempts to prove contracts using dataflow analysis, symbolic execution, and optional SMT solvers. Provable contracts are verified at compile time with zero runtime overhead.

**Dynamic verification** (runtime):
[20] Contracts that cannot be proven statically are converted to runtime assertions. The verification mode (§11.8) controls when dynamic checks are inserted: always, debug-only, release-proven-only, or never.

**Verification modes**:
[21] Procedures may specify verification requirements via attributes:

- `[[verify(static)]]` — Must prove statically or compilation fails
- `[[verify(dynamic)]]` — Always insert runtime checks
- `[[verify(trusted)]]` — Trust contract, no checks (programmer responsibility)
- No attribute — Build-mode default (debug inserts checks, release only proven)

[22] Verification modes are metadata (not part of sequent syntax) and do not affect procedure type signatures. Two procedures with identical sequents but different verification modes have the same type.

[23] In addition to sequents on procedures, Cursive supports _contract declarations_: abstract interfaces that types may implement for polymorphism. Contract declarations define procedure signatures without implementations:

```cursive
public contract Serializable {
    type Format = string@View

    procedure serialize(~): Self::Format
        [[ alloc::heap |- true => result.len() > 0 ]]

    procedure deserialize(data: Self::Format): Self \/ ParseError
        [[ alloc::heap |- data.len() > 0 => true ]]
}
```

[24] Types attach contracts using `:` syntax in the type declaration header:

```cursive
record User: Serializable {
    id: u64,
    name: string@Managed,

    type Format = string@Managed

    procedure serialize(~): string@Managed
        [[ alloc::heap |- true => result.len() > 0 ]]
    {
        // Implementation must satisfy contract
    }

    procedure deserialize(data: string@Managed): Self \/ ParseError
        [[ alloc::heap |- data.len() > 0 => true ]]
    {
        // Implementation
    }
}
```

[25] Contract declarations, satisfaction rules, and coherence are integrated with the behavior system defined in Clause 9. This clause focuses on the sequent notation and verification; polymorphic dispatch is specified in Clause 12 (Witness System).

#### §11.1.5 Conformance Requirements [contract.overview.requirements]

[26] Implementations shall maintain contract metadata through compilation phases for reflection and tooling, and integrate contracts with the type system, generics, and witness system.


### §11.2 Sequent: Syntax and Structure [contract.sequent]

#### §11.2.1 Overview

[1] A _contractual sequent_ is the complete formal specification attached to a procedure declaration. It uses the form `[[ grants |- must => will ]]` where semantic brackets enclose a sequent calculus judgment expressing capability requirements, preconditions, and postconditions.

[2] This subclause specifies the concrete and abstract syntax of sequents, the smart defaulting rules that allow omitting components, the parsing and desugaring algorithms, and examples of all valid sequent forms.

#### §11.2.2 Syntax [contract.sequent.syntax]

##### §11.2.2.1 Complete Form

[3] The canonical contractual sequent syntax is:

```ebnf
sequent_clause
    ::= "[[" grant_clause "|-" must_clause "=>" will_clause "]]"

grant_clause
    ::= grant_reference ("," grant_reference)*
     | ε

must_clause
    ::= predicate_expression
     | "true"

will_clause
    ::= predicate_expression
     | "true"
```

[ Note: See Annex A §A.7 [grammar.sequent] for complete authoritative grammar.
— end note ]

[4] The semantic brackets `⟦ ⟧` (U+27E6, U+27E7) or their ASCII equivalent `[[ ]]` delimit formal specification content. The turnstile `⊢` (U+22A2) or ASCII `|-` separates the grant context from logical implications. Implication `⇒` (U+21D2) or ASCII `=>` separates preconditions from postconditions.

##### §11.2.2.2 Smart Defaulting Forms

[5] Components may be omitted with smart defaulting rules applied during parsing:

**Grant-only form**:

```ebnf
"[[" grant_clause "]]"
```

Expands to: `[[ grants |- true => true ]]`

**Precondition-only form**:

```ebnf
"[[" must_clause "]]"
```

Expands to: `[[ must => true ]]` (canonical form: `[[ |- must => true ]]`)

**Postcondition-only form**:

```ebnf
"[[" "=>" will_clause "]]"
```

Expands to: `[[ true => will ]]` (canonical form: `[[ |- true => will ]]`)

**Precondition and postcondition (no grants)**:

```ebnf
"[[" must_clause "=>" will_clause "]]"
```

Preferred form without turnstile. Canonical form: `[[ |- must => will ]]`

**Empty sequent**:
[6] Procedures without explicit sequent clauses default to `[[ ∅ |- true => true ]]` (empty grant set, pure procedure with no requirements or guarantees). The canonical internal form is `[[ |- true => true ]]` where the grant set is empty (∅).

##### §11.2.2.3 Examples of All Forms

**Example 12.2.2.1 (Complete form with all components)**:

```cursive
procedure transfer_funds(~!, to: unique Account, amount: i64)
    [[ ledger::post, ledger::validate |-
       amount > 0 && self.balance >= amount && self.id != to.id
       =>
       self.balance == @old(self.balance) - amount &&
       to.balance == @old(to.balance) + amount
    ]]
{
    self.balance -= amount
    to.balance += amount
}
```

**Example 12.2.2.2 (Grant-only form)**:

```cursive
procedure log_message(message: string@View)
    [[ io::write ]]
{
    println("{}", message)
}

// Desugars to: [[ io::write |- true => true ]]
```

**Example 12.2.2.3 (Precondition-only form)**:

```cursive
procedure divide(a: i32, b: i32): i32
    [[ b != 0 ]]
{
    result a / b
}

// Desugars to: [[ b != 0 => true ]]
```

**Example 12.2.2.4 (Postcondition-only form)**:

```cursive
procedure absolute_value(x: i32): i32
    [[ => result >= 0 ]]
{
    if x < 0 { result -x } else { result x }
}

// Desugars to: [[ true => result >= 0 ]]
```

**Example 12.2.2.5 (No turnstile when no grants)**:

```cursive
procedure clamp(value: i32, min: i32, max: i32): i32
    [[ min <= max => result >= min && result <= max ]]
{
    if value < min { result min }
    else if value > max { result max }
    else { result value }
}

// Desugars to: [[ min <= max => result >= min && result <= max ]] (canonical: `[[ |- min <= max => result >= min && result <= max ]]`)
```

**Example 12.2.2.6 (Omitted sequent - pure procedure)**:

```cursive
procedure add(a: i32, b: i32): i32
{
    result a + b
}

// Sequent omitted - defaults to [[ ∅ |- true => true ]] (canonical: `[[ |- true => true ]]` with empty grant set)
```

#### §11.2.3 Constraints [contract.sequent.constraints]

[1] _Semantic bracket requirement._ Contractual sequents shall use semantic brackets `⟦ ⟧` or ASCII `[[ ]]`. Other bracket forms (parentheses, square brackets, curly braces) are not valid for sequent delimiters and shall produce diagnostic E12-001.

[2] _Turnstile placement._ The turnstile `|-` shall separate the grant clause from the must clause. When grants are present, the turnstile is required. When no grants are present, the turnstile may be omitted, allowing the form `[[ must => will ]]` which desugars to `[[ |- must => will ]]`. The turnstile shall appear at most once per sequent. Violations produce diagnostic E12-002.

[3] _Implication placement._ The implication operator `=>` shall separate the must clause from the will clause. It shall appear exactly once per sequent. Violations produce diagnostic E12-003.

[4] _Component ordering._ Sequent components shall appear in the order: grants (optional), turnstile (required if grants present, optional if no grants), must, implication, will. When no grants are present, the form `[[ must => will ]]` is valid and desugars to `[[ |- must => will ]]`. Reordering components is ill-formed and produces diagnostic E12-004.

[5] _Predicate purity._ Expressions in must and will clauses shall be pure: they shall not perform I/O, mutate state, allocate memory, or have observable side effects. Effectful predicates produce diagnostic E12-005.

[6] _Grant reference validity._ All grants referenced in the grant clause shall be visible (§5.9 for user-defined grants, §12.3 for built-in grants). Undefined grants produce diagnostic E12-006.

[7] _Result identifier scope._ The `result` identifier is valid only in will clauses. Using `result` in must clauses produces diagnostic E12-007. The `result` identifier has the type of the procedure's declared return type.

[8] _@old scope._ The `@old(expression)` operator is valid only in will clauses. Using `@old` in must clauses produces diagnostic E12-008. The `@old` operator may not be nested: `@old(@old(x))` is ill-formed (diagnostic E12-009).

[9] _Smart defaulting determinism._ Smart defaulting rules shall be applied deterministically during parsing. The expanded form shall be unique and well-defined for every valid abbreviated sequent. Ambiguous forms are ill-formed (diagnostic E12-010).

#### §11.2.4 Semantics [contract.sequent.semantics]

##### §11.2.4.1 Sequent Interpretation

[10] A contractual sequent `[[ G |- P => Q ]]` has the following semantic interpretation:

$$
\frac{G \text{ available} \quad P \text{ holds at entry}}
     {Q \text{ holds at exit}}
\tag{Sequent-Interpretation}
$$

[11] In prose: "Given that grants $G$ are available in the calling context, if preconditions $P$ hold when the procedure is called, then postconditions $Q$ will hold when the procedure returns."

##### §11.2.4.2 Empty Components

[12] Empty or omitted components have standard interpretations:

- Empty grant clause: $G = \emptyset$ (no capabilities required)
- `must true`: No preconditions (always satisfied)
- `will true`: No postconditions (no guarantees)

[13] The trivial sequent `[[ ∅ |- true => true ]]` (canonical form: `[[ |- true => true ]]` with empty grant set) represents a pure procedure with no requirements and no guarantees. When sequents are omitted entirely, they default to this form. Such procedures may still perform local computation and return values; the sequent indicates only that there are no external requirements or observable guarantees beyond the type signature.

##### §11.2.4.3 Multiple Predicates

[14] Multiple predicates in must or will clauses are conjoined using the `&&` operator:

$$
\texttt{must} \; P_1 \;\&\&\; P_2 \;\&\&\; \cdots \;\&\&\; P_n \equiv \texttt{must} \; P_1 \land P_2 \land \cdots \land P_n
$$

$$
\texttt{will} \; Q_1 \;\&\&\; Q_2 \;\&\&\; \cdots \;\&\&\; Q_n \equiv \texttt{will} \; Q_1 \land Q_2 \land \cdots \land Q_n
$$

[15] The `&&` operator binds less tightly than comparison operators within predicates, so `must a > 0 && b > 0` means `(a > 0) ∧ (b > 0)`, not `a > (0 && b) > 0`.

##### §11.2.4.4 Desugaring Algorithm

[16] The desugaring algorithm for abbreviated sequents proceeds as follows:

```
desugar_sequent(input):
    grants = extract_grants(input) or ∅
    has_turnstile = contains(input, "|-")
    has_implication = contains(input, "=>")

    if has_turnstile:
        before_turnstile = extract_before(input, "|-")
        after_turnstile = extract_after(input, "|-")
        grants = before_turnstile or ∅

        if has_implication:
            before_arrow = extract_before(after_turnstile, "=>")
            after_arrow = extract_after(after_turnstile, "=>")
            must = before_arrow or "true"
            will = after_arrow or "true"
        else:
            must = after_turnstile or "true"
            will = "true"
    else if has_implication:
        before_arrow = extract_before(input, "=>")
        after_arrow = extract_after(input, "=>")
        must = before_arrow or "true"
        will = after_arrow or "true"
    else:
        // Only grants present
        grants = input
        must = "true"
        will = "true"

    return [[ grants |- must => will ]]
```

[17] This algorithm is deterministic and produces a unique canonical form for every valid abbreviated sequent.

#### §11.2.5 Examples [contract.sequent.examples]

**Example 12.2.5.1 (All smart defaulting forms)**:

```cursive
// Form 1: Complete sequent
procedure complete(x: i32)
    [[ io::write |- x > 0 => result >= 0 ]]
{ result x }

// Form 2: Grants only
procedure grants_only()
    [[ fs::read, fs::write ]]
{ }

// Form 3: Precondition only
procedure precond_only(b: i32)
    [[ b != 0 ]]
{ }

// Form 4: Postcondition only
procedure postcond_only(): i32
    [[ => result > 0 ]]
{ result 42 }

// Form 5: Must + will, no grants
procedure no_grants(x: i32): i32
    [[ x >= 0 => result >= x ]]
{ result x + 1 }

// Form 6: Implication without turnstile
procedure implicit_turnstile(n: i32): i32
    [[ n > 0 => result > n ]]
{ result n + 1 }

// Form 7: Omitted entirely (default)
procedure defaulted(a: i32, b: i32): i32
{ result a + b }
```

**Example 12.2.5.2 (Multi-predicate sequents)**:

```cursive
procedure validate_transfer(from: Account, to: Account, amount: i64): bool
    [[
        ledger::validate
        |-
        from.balance >= amount &&
        amount > 0 &&
        from.id != to.id
        =>
        result => from.balance >= amount &&
        result => to.id != from.id
    ]]
{
    result from.balance >= amount && amount > 0 && from.id != to.id
}
```

#### §11.2.6 Integration with Procedure Declarations [contract.sequent.integration]

[18] Contractual sequents attach to procedure declarations as specified in §5.4 [decl.function]. The sequent clause appears after the procedure signature, either on the same line (for simple sequents) or on the following line (recommended for complex sequents).

[19] Expression-bodied procedures (`= expression ;`) shall not include explicit sequents; they implicitly default to `[[ ∅ |- true => true ]]` (empty grant set, canonical: `[[ |- true => true ]]`). Including a sequent with expression bodies produces diagnostic E05-408 (defined in Clause 5).

[20] Extern procedures may include sequents specifying their contract. The sequent serves as documentation and verification obligation for callers; the implementation is external and assumed to satisfy the contract.

**Example 12.2.6.1 (Sequent placement)**:

```cursive
// Single-line sequent (simple)
procedure simple(x: i32): i32 [[ x > 0 => result > x ]]
{ result x + 1 }

// Multi-line sequent (recommended for readability)
procedure complex(~!, data: Buffer, size: usize)
    [[
        alloc::heap, io::write
        |-
        data.capacity() >= size &&
        size > 0
        =>
        self.data.len() >= size &&
        self.data.capacity() >= size
    ]]
{
    // Implementation
}

// Expression-bodied (no explicit sequent)
procedure double(x: i32): i32
= x * 2

// Extern procedure with contract
extern "C" procedure malloc(size: usize): Ptr<u8>@Valid
    [[ ffi::call, unsafe::ptr |- size > 0 => result.is_valid() ]]
```

#### §11.2.7 Formal Sequent Structure [contract.sequent.formal]

[21] The formal abstract syntax for sequents is:

$$
\text{Sequent} ::= G \vdash P \Rightarrow Q
$$

where:

- $G \in \mathcal{P}(\text{Grant})$ is a finite set of grant identifiers
- $P \in \text{Predicate}$ is a boolean-valued expression over parameters
- $Q \in \text{Predicate}$ is a boolean-valued expression over parameters, result, and `@old` expressions

$$
\text{Predicate} ::= \text{true} \mid \text{false} \mid e : \text{bool} \mid P_1 \land P_2 \mid P_1 \lor P_2 \mid \lnot P
$$

$$
\text{Grant} ::= \text{qualified\_grant\_path} \mid \text{grant\_parameter}
$$

[22] Sequent equivalence is defined up to logical equivalence of predicates and set equality of grants:

$$
G_1 \vdash P_1 \Rightarrow Q_1 \equiv G_2 \vdash P_2 \Rightarrow Q_2
$$

$$
\text{iff } G_1 = G_2 \land (P_1 \Leftrightarrow P_2) \land (Q_1 \Leftrightarrow Q_2)
$$

#### §11.2.8 Diagnostics [contract.sequent.diagnostics]

[23] Sequent syntax diagnostics:

| Code    | Condition                                                     | Constraint |
| ------- | ------------------------------------------------------------- | ---------- |
| E12-001 | Invalid sequent brackets (not [[]])                           | [1]        |
| E12-002 | Missing turnstile when grants present, or duplicate turnstile | [2]        |
| E12-003 | Missing or duplicate implication operator                     | [3]        |
| E12-004 | Sequent components in wrong order                             | [4]        |
| E12-005 | Effectful expression in must/will clause                      | [5]        |
| E12-006 | Undefined grant in grant clause                               | [6]        |
| E12-007 | `result` identifier used in must clause                       | [7]        |
| E12-008 | `@old` operator used in must clause                           | [8]        |
| E12-009 | Nested `@old` operators                                       | [8]        |
| E12-010 | Ambiguous abbreviated sequent                                 | [9]        |

#### §11.2.9 Conformance Requirements [contract.sequent.requirements]

[24] Implementations shall:

1. Parse contractual sequents using semantic brackets `⟦ ⟧` or ASCII `[[ ]]`
2. Recognize turnstile `⊢` or ASCII `|-` and implication `⇒` or ASCII `=>`
3. Support all smart defaulting forms listed in §12.2.2.2
4. Apply desugaring algorithm deterministically to produce canonical form
5. Validate sequent component ordering and delimiters
6. Enforce predicate purity (no side effects in must/will)
7. Scope `result` identifier to will clauses only
8. Scope `@old` operator to will clauses only
9. Reject nested `@old` operators
10. Emit diagnostics E12-001 through E12-010 for sequent syntax violations
11. Preserve sequent metadata through compilation for reflection and tooling


### §11.3 Grants (within Sequent) [contract.grant]

#### §11.3.1 Overview

[1] _Grants_ are capability tokens that represent permissions to perform observable computational effects. The grant clause of a contractual sequent lists the grants required for a procedure to execute. Grant checking ensures that procedures declare all effects they may perform, enabling static tracking of capabilities and side effects.

[2] Cursive provides two categories of grants:

- **Built-in grants** (§12.3.3): Predefined capability tokens for standard effects (I/O, allocation, networking, etc.)
- **User-defined grants** (§5.9): Module-specific capability tokens for domain-specific effects

[3] Grants are compile-time annotations with zero runtime representation. All grant checking occurs statically; there is no runtime grant validation or capability system.

#### §11.3.2 Syntax [contract.grant.syntax]

[4] Grant references in sequent grant clauses follow:

```ebnf
grant_clause
    ::= grant_reference ("," grant_reference)*
     | ε

grant_reference
    ::= qualified_grant_path
     | grant_parameter_reference

qualified_grant_path
    ::= identifier ("::" identifier)*

grant_parameter_reference
    ::= identifier
```

[ Note: See Annex A §A.9 [grammar.grant] for complete grant grammar.
— end note ]

[5] Grant paths are qualified with `::` separators. Built-in grants use reserved namespaces (`alloc::heap`, `fs::read`). User-defined grants use module paths (`database::query`, `auth::validate`).

[6] Grant parameters (§10.2.5) appear as identifiers in grant clauses and are substituted during monomorphization with concrete grant sets.

**Example 12.3.2.1 (Grant syntax forms)**:

```cursive
// Built-in grants
procedure allocate_buffer()
    [[ alloc::heap |- true => true ]]
{ }

// User-defined grant
public grant query

procedure execute_query(sql: string@View): [Row]
    [[ query |- sql.len() > 0 => true ]]
{ }

// Multiple grants
procedure process_file(path: string@View)
    [[ fs::read, fs::write, alloc::heap |- path.len() > 0 => true ]]
{ }

// Grant parameter
procedure apply<T, U, ε>(f: (T) -> U ! ε): U
    [[ ε |- true => true ]]
{ result f(value) }
```

#### §11.3.3 Built-In Grant Catalog [contract.grant.builtin]

[7] Implementations shall provide at least the following built-in grants:

##### §11.3.3.1 Allocation Grants

**alloc namespace**:

| Grant           | Capability                    |
| --------------- | ----------------------------- |
| `alloc::heap`   | Heap memory allocation        |
| `alloc::region` | Region-scoped allocation      |
| `alloc::global` | Global allocator access (FFI) |

##### §11.3.3.2 File System Grants

**fs namespace**:

| Grant          | Capability                       |
| -------------- | -------------------------------- |
| `fs::read`     | Read file contents               |
| `fs::write`    | Write file contents              |
| `fs::delete`   | Delete files                     |
| `fs::metadata` | Query file metadata (size, etc.) |
| `fs::create`   | Create new files/directories     |

##### §11.3.3.3 Network Grants

**net namespace**:

| Grant          | Capability             |
| -------------- | ---------------------- |
| `net::connect` | Establish connections  |
| `net::listen`  | Listen for connections |
| `net::send`    | Send data over network |
| `net::receive` | Receive network data   |
| `net::dns`     | DNS resolution         |

##### §11.3.3.4 I/O Grants

**io namespace**:

| Grant       | Capability                     |
| ----------- | ------------------------------ |
| `io::read`  | Read from stdin or streams     |
| `io::write` | Write to stdout/stderr/streams |

##### §11.3.3.5 Concurrency Grants

**thread namespace**:

| Grant           | Capability           |
| --------------- | -------------------- |
| `thread::spawn` | Spawn new threads    |
| `thread::join`  | Join threads         |
| `thread::sleep` | Sleep current thread |

**sync namespace**:

| Grant          | Capability            |
| -------------- | --------------------- |
| `sync::atomic` | Atomic operations     |
| `sync::lock`   | Acquire locks/mutexes |

##### §11.3.3.6 System Grants

**sys namespace**:

| Grant       | Capability                  |
| ----------- | --------------------------- |
| `sys::env`  | Environment variable access |
| `sys::time` | System time queries         |
| `sys::exit` | Process termination         |

##### §11.3.3.7 Unsafe and FFI Grants

**unsafe namespace**:

| Grant               | Capability             |
| ------------------- | ---------------------- |
| `unsafe::ptr`       | Raw pointer operations |
| `unsafe::transmute` | Type transmutation     |
| `unsafe::asm`       | Inline assembly        |

**ffi namespace**:

| Grant       | Capability             |
| ----------- | ---------------------- |
| `ffi::call` | Foreign function calls |

##### §11.3.3.8 Panic Grant

**panic** (top-level):

| Grant   | Capability            |
| ------- | --------------------- |
| `panic` | Panic/abort execution |

##### §11.3.3.9 Compile-Time Grants

[8] Compile-time execution contexts (§2.2.4.2) support comptime-specific grants:

**comptime namespace**:

| Grant               | Capability              |
| ------------------- | ----------------------- |
| `comptime::alloc`   | Compile-time allocation |
| `comptime::codegen` | Code generation         |
| `comptime::config`  | Configuration queries   |
| `comptime::diag`    | Diagnostic emission     |

[9] Comptime grants are available only within `comptime` blocks and `comptime procedure` bodies. Using comptime grants in runtime procedures produces diagnostic E12-020.

#### §11.3.4 User-Defined Grants [contract.grant.user]

[10] User-defined grants are declared at module scope using the `grant` keyword (§5.9 [decl.grant]). Grant declarations introduce capability tokens into the module's namespace with visibility controlled by modifiers (`public`, `internal`, `private`).

[11] User-defined grant paths are module-qualified. For grant `g` in module `M`, the fully qualified path is `M::g`.

**Example 12.3.4.1 (User-defined grants)**:

```cursive
// Module: database
public grant query
public grant write
internal grant admin

procedure execute_query(sql: string@View): [Row]
    [[ query |- sql.len() > 0 => true ]]
{ }

// Module: application
import database

procedure fetch_users(): [User]
    [[ database::query, alloc::heap |- true => true ]]
{
    result database::execute_query("SELECT * FROM users")
}
```

#### §11.3.5 Grant Subsumption [contract.grant.subsumption]

[12] Grant sets are ordered by subset inclusion. A procedure with grant set $G_1$ may be used where grant set $G_2$ is required if $G_1 \subseteq G_2$ (fewer grants is stronger/more specific).

[13] **Subsumption rule**:

$$
\frac{G_1 \subseteq G_2}
     {(\tau_1, \ldots, \tau_n) \to \tau_r \; ! G_1 \; \texttt{[[} \cdots \texttt{]]} \;<: (\tau_1, \ldots, \tau_n) \to \tau_r \; ! G_2 \; \texttt{[[} \cdots \texttt{]]}}
\tag{Sub-Grant}
$$

[14] This allows pure procedures (grant set $\emptyset$) to substitute for procedures requiring grants, and procedures with specific grants to substitute for procedures accepting broader grant sets.

**Example 12.3.5.1 (Grant subsumption)**:

```cursive
// Pure procedure
procedure pure_compute(x: i32): i32
    [[ |- true => true ]]
{ result x * 2 }

// Procedure accepting grants
procedure with_logging(f: (i32) -> i32 ! { io::write })
    [[ io::write |- true => true ]]
{
    println("Computing...")
    result f(42)
}

// Valid: ∅ ⊆ {io::write}
with_logging(pure_compute)
```

#### §11.3.6 Grant Composition [contract.grant.composition]

[15] When a procedure calls other procedures, the caller's grant set must include all grants required by callees. Grant accumulation follows set union:

$$
\frac{\Gamma \vdash f : (\ldots) \to \tau_f \; ! G_f \quad \Gamma \vdash g : (\ldots) \to \tau_g \; ! G_g}
     {\Gamma \vdash \texttt{procedure } h \{ f(); g(); \} \text{ requires grants } G_f \cup G_g}
\tag{Grant-Union}
$$

[16] Implementations shall verify that every procedure's grant clause includes the union of all grants required by called procedures, used operations, and intrinsic effects.

**Example 12.3.6.1 (Grant composition)**:

```cursive
procedure read_config(path: string@View): Config
    [[ fs::read, alloc::heap |- path.len() > 0 => true ]]
{ }

procedure write_log(message: string@View)
    [[ fs::write |- true => true ]]
{ }

procedure process_config(path: string@View)
    [[ fs::read, fs::write, alloc::heap |- path.len() > 0 => true ]]
    //  ^^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^  Union of callee grants
{
    let config = read_config(path)  // Requires: fs::read, alloc::heap
    write_log("Config loaded")       // Requires: fs::write
    // Caller must declare all grants used
}
```

#### §11.3.7 Grant Polymorphism [contract.grant.polymorphism]

[17] Grant parameters (§10.2.5) enable procedures polymorphic over grant sets. A grant parameter represents a variable grant set determined at instantiation:

```cursive
procedure map<T, U, ε>(values: [T], f: (T) -> U ! ε): [U]
    [[ alloc::heap, ε |- values.len() > 0 => result.len() == values.len() ]]
{
    let result = array::with_capacity(values.len())
    loop item: T in values {
        result.push(f(item))
    }
    result result
}
```

[18] At instantiation, the grant parameter $\varepsilon$ is substituted with the concrete grant set from the callable argument. The caller's grant clause must include both the explicit grants (`alloc::heap`) and the parameter grants ($\varepsilon$).

[19] Grant parameter bounds constrain which grants may be substituted (§10.3.7):

```cursive
procedure controlled<T, ε>(f: () -> T ! ε): T
    [[ ε |- true => true ]]
    where ε ⊆ {io::write, alloc::heap}
{
    result f()
}
```

#### §11.3.8 Grant Checking [contract.grant.checking]

[20] Grant checking occurs at call sites. For a call `f(args)` where $f$ has grant set $G_f$, the compiler verifies that the calling procedure's grant clause includes $G_f$:

$$
\frac{\text{procedure } caller \; \texttt{[[} G_{caller} \; \texttt{|-} \cdots \texttt{]]} \quad \Gamma \vdash f : \ldots \; ! G_f \quad G_f \subseteq G_{caller}}
     {\text{call } f(args) \text{ permitted}}
\tag{WF-Grant-Call}
$$

[21] If $G_f \not\subseteq G_{caller}$, the call is ill-formed and produces diagnostic E12-030 listing the missing grants.

**Example 12.3.8.1 (Grant checking)**:

```cursive
procedure helper()
    [[ io::write |- true => true ]]
{
    println("Helper")
}

procedure caller()
    [[ io::write |- true => true ]]
{
    helper()  // ✅ OK: {io::write} ⊆ {io::write}
}

procedure invalid_caller()
    [[ |- true => true ]]
{
    helper()  // ❌ ERROR E12-030: missing grant io::write
}
```

#### §11.3.9 Constraints [contract.grant.constraints]

[1] _Visibility._ User-defined grants must be visible in the scope where they are referenced. Cross-module grant usage requires the grant to be `public` in the defining module and the module to be imported. Private grants are accessible only within their defining module. Violations produce diagnostic E12-031.

[2] _No wildcards._ Grant clauses shall list grants explicitly. Wildcard expansion syntax (e.g., `fs::*`) is not supported. All grants must be explicitly enumerated. This ensures maximum explicitness and prevents ambiguity about which capabilities are required.

[3] _Grant set size._ Implementations shall support grant sets with at least 256 grant references. Exceeding this limit may produce diagnostic E12-032.

[4] _Reserved namespaces._ User-defined grants shall not use reserved top-level namespaces: `alloc`, `fs`, `net`, `io`, `thread`, `sync`, `sys`, `unsafe`, `ffi`, `panic`, `comptime`. Violations produce diagnostic E05-901 (defined in §5.9).

[5] _Grant path validity._ Every component of a qualified grant path shall be a valid identifier. Grant paths shall resolve to grant declarations visible in the current scope. Unresolved grants produce diagnostic E12-006.

#### §11.3.10 Semantics [contract.grant.semantics]

##### §11.3.10.1 Grant Availability

[6] At any point in a procedure body, the available grant set is the set declared in the procedure's sequent grant clause. Grant availability is lexically scoped: inner procedures have their own grant clauses and do not inherit grants from enclosing procedures.

[7] **Grant availability rule**:

[ Given: Procedure with grant clause $G$ ]

$$
\frac{\text{procedure } f \; \texttt{[[} G \; \texttt{|-} \cdots \texttt{]]} \{ \text{body} \}}
     {\text{In body: grants available} = G}
\tag{P-Grant-Available}
$$

##### §11.3.10.2 Grant Propagation

[8] Grants propagate through expressions according to the grant accumulation rule (§8.1.5). Each expression has a required grant set; compound expressions union the grant sets of their subexpressions:

$$
\frac{\Gamma \vdash e_1 : \tau_1 \; ! G_1 \quad \Gamma \vdash e_2 : \tau_2 \; ! G_2}
     {\Gamma \vdash (e_1; e_2) : \tau_2 \; ! (G_1 \cup G_2)}
\tag{Grant-Compose}
$$

[9] The accumulated grant set for the entire procedure body must be a subset of the declared grant clause. Violations indicate missing grants in the sequent and produce diagnostic E12-030.

##### §11.3.10.3 Grant Parameter Substitution

[10] When a procedure with grant parameters is instantiated, grant parameters are replaced with concrete grant sets:

$$
\frac{\text{procedure } f\langle\varepsilon\rangle \; \texttt{[[} \varepsilon \; \texttt{|-} \cdots \texttt{]]} \quad \text{instantiated with } G}
     {f\langle G \rangle \text{ has grants } G}
\tag{Grant-Param-Subst}
$$

[11] Grant parameter bounds (§10.3.7) constrain which grant sets may be substituted. The bound $\varepsilon \subseteq G_{bound}$ requires that the instantiated grant set satisfies $G_{concrete} \subseteq G_{bound}$.

#### §11.3.11 Intrinsic Operation Grants [contract.grant.intrinsic]

[12] Certain language constructs intrinsically require grants without explicit procedure calls:

**Table 12.2 — Intrinsic grant requirements**

| Operation                   | Required Grant  | Clause Reference |
| --------------------------- | --------------- | ---------------- |
| Region allocation `^expr`   | `alloc::region` | §11.3.2          |
| Heap conversion `to_heap()` | `alloc::heap`   | §11.3.3.5        |
| Raw pointer dereference     | `unsafe::ptr`   | §7.5.5.2         |
| Panic `panic(msg)`          | `panic`         | §9.x             |
| FFI call                    | `ffi::call`     | Clause 15        |

[13] Implementations shall accumulate intrinsic grants during expression typing and verify they are included in the procedure's grant clause.

#### §11.3.12 Examples [contract.grant.examples]

**Example 12.3.12.1 (Grant composition in complex procedure)**:

```cursive
public grant database_write

procedure save_user(user: User, path: string@View)
    [[
        database_write,      // User-defined grant
        fs::write,           // Built-in grant
        alloc::heap          // Built-in grant
    |-
        user.id > 0,
        path.len() > 0
    =>
        true
    ]]
{
    let serialized = user.serialize()     // Requires: alloc::heap
    write_to_database(user)                // Requires: database_write
    write_to_file(path, serialized)        // Requires: fs::write
}
```

**Example 12.3.12.2 (Grant parameter polymorphism)**:

```cursive
procedure twice<T, ε>(action: () -> T ! ε): (T, T)
    [[ ε |- true => true ]]
{
    result (action(), action())
}

// Usage with pure function
let pure_fn = || [[ |- true => true ]] { result 42 }
let pair1 = twice(pure_fn)  // ε = ∅

// Usage with grant-requiring function
let writer = || [[ io::write |- true => true ]] { println("hi") }
let pair2 = twice(writer)    // ε = {io::write}
```

**Example 12.3.12.3 (Intrinsic grants)**:

```cursive
procedure allocate_in_region(): Buffer
    [[ alloc::region, alloc::heap |- true => true ]]
{
    region temp {
        let buffer = ^Buffer::new()  // Intrinsic: requires alloc::region
        result buffer.to_heap()       // Intrinsic: requires alloc::heap
    }
}
```

#### §11.3.13 Diagnostics [contract.grant.diagnostics]

[14] Grant-related diagnostics:

| Code    | Condition                                     | Constraint |
| ------- | --------------------------------------------- | ---------- |
| E12-006 | Undefined grant in grant clause               | [5]        |
| E12-020 | Comptime grant used in runtime procedure      | [9]        |
| E12-030 | Call site missing required grants             | [21]       |
| E12-031 | Grant visibility violation (non-public grant) | [1]        |
| E12-032 | Grant set exceeds implementation limit        | [3]        |

#### §11.3.14 Conformance Requirements [contract.grant.requirements]

[15] Implementations shall:

1. Provide all built-in grants enumerated in §12.3.3
2. Support user-defined grants declared via §5.9 with module-qualified paths
3. Enforce grant visibility rules (public/internal/private)
4. Reject wildcard grant syntax; require explicit grant enumeration
5. Perform grant checking at call sites using subset inclusion
6. Accumulate grant sets through expressions via union
7. Support grant parameters with substitution and bounds checking
8. Track intrinsic operation grants and verify against grant clauses
9. Distinguish comptime grants from runtime grants
10. Emit diagnostics E12-006, E12-020, E12-030, E12-031, E12-032 for violations
11. Maintain grant metadata for reflection and callable type signatures


### §11.4 Preconditions: must [contract.precondition]

#### §11.4.1 Overview

[1] _Preconditions_ are boolean predicates that must hold when a procedure is called. They appear in the must clause of contractual sequents and specify _caller obligations_: conditions the caller must ensure before invoking the procedure.

[2] Preconditions enable:

- **Input validation**: Specify valid parameter ranges without defensive checks in procedure bodies
- **Contract-based programming**: Explicit division of responsibilities between caller and callee
- **Static verification**: Provable preconditions eliminate runtime checks
- **Safe assumptions**: Procedure implementations may assume preconditions hold
- **Documentation**: Machine-checkable specification of valid inputs

[3] This subclause specifies precondition syntax, well-formedness constraints, verification strategies, and integration with the broader contract system.

#### §11.4.2 Syntax [contract.precondition.syntax]

[4] Precondition syntax appears in the must clause of sequents:

```ebnf
must_clause
    ::= predicate_expression
     | predicate_expression ("," predicate_expression)*
     | "true"

predicate_expression
    ::= expression
```

[ Note: See Annex A §A.7 [grammar.sequent] for complete sequent grammar.
— end note ]

[5] Predicate expressions are boolean-valued expressions (type `bool`) that may reference:

- Procedure parameters (names and fields)
- Pure procedure calls
- Logical operators (`&&`, `||`, `!`, `=>`)
- Comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`)
- Arithmetic expressions (for numeric comparisons)
- Quantifiers `forall` and `exists` (optional extension)

[6] Preconditions shall not reference:

- The `result` identifier (use will clause for result properties)
- The `@old` operator (use will clause for temporal properties)
- Mutable operations or side effects
- Procedure-local bindings (parameters only)

**Example 12.4.2.1 (Precondition forms)**:

```cursive
// Simple numeric constraint
procedure sqrt(x: f64): f64
    [[ |- x >= 0.0 => true ]]
{ }

// Multiple preconditions
procedure divide(numerator: i32, denominator: i32): i32
    [[ |- numerator != i32::MIN, denominator != 0 => true ]]
{ result numerator / denominator }

// Relationship between parameters
procedure transfer(from: unique Account, to: unique Account, amount: i64)
    [[
        ledger::post
        |-
        amount > 0,
        from.balance >= amount,
        from.id != to.id
        =>
        true
    ]]
{ }

// Field access in precondition
procedure read_buffer(buffer: Buffer)
    [[ |- buffer.data.len() > 0 => true ]]
{ }
```

#### §11.4.3 Constraints [contract.precondition.constraints]

[1] _Type requirement._ Predicate expressions in must clauses shall have type `bool`. Non-boolean predicates produce diagnostic E12-040.

[2] _Purity requirement._ Preconditions shall be pure expressions: they shall not perform I/O, mutate state, allocate memory, or invoke procedures with non-empty grant sets. Effectful preconditions produce diagnostic E12-041.

[3] _Parameter scope._ Preconditions may reference procedure parameters and their fields but shall not reference procedure-local bindings, the result identifier, or `@old` expressions. Violations produce diagnostics E12-007 (result), E12-008 (@old), or E12-042 (local bindings).

[4] _Well-formedness._ All identifiers and procedure calls in preconditions shall resolve via name lookup (Clause 6). Undefined identifiers produce standard name resolution diagnostics (E06-401).

[5] _Logical form._ Preconditions shall be evaluable as boolean expressions. Implementations may restrict preconditions to decidable subsets for static verification but shall not reject well-typed boolean predicates.

#### §11.4.4 Semantics [contract.precondition.semantics]

##### §11.4.4.1 Caller Obligation

[6] Preconditions represent _caller obligations_. When procedure $f$ has precondition $P$, every call site `f(args)` must ensure $P[params \mapsto args]$ holds.

[7] **Precondition obligation rule**:

[ Given: Procedure $f$ with precondition $P$, call site `f(args)` ]

$$
\frac{\text{procedure } f(x_1: \tau_1, \ldots) \; \texttt{[[} \cdots \texttt{|-} P(x_1, \ldots) \texttt{=>} \cdots \texttt{]]}}
     {\text{At call } f(e_1, \ldots): \text{ must prove } P[x_1 \mapsto e_1, \ldots]}
\tag{WF-Must-Obligation}
$$

[8] The caller must either:

- Prove $P$ statically via compile-time analysis, OR
- Establish $P$ through control flow (conditional guards), OR
- Accept dynamic check insertion (verification mode dependent, §12.8)

##### §11.4.4.2 Static Verification

[9] The compiler attempts to prove preconditions statically using:

- Constant propagation for literal arguments
- Range analysis for bounded integer types
- Control-flow analysis for conditional contexts
- Definite assignment analysis integration
- Optional SMT solver queries

[10] **Static proof rule**:

[ Given: Call `f(args)` with precondition $P$ ]

$$
\frac{\Gamma \vdash P[params \mapsto args] = \text{true}}
     {\text{Precondition statically verified}}
\tag{Verify-Must-Static}
$$

[11] When static proof succeeds, no runtime check is inserted. The call proceeds directly to the procedure body.

**Example 12.4.4.1 (Static verification)**:

```cursive
procedure needs_positive(x: i32)
    [[ |- x > 0 => true ]]
{ }

procedure caller()
{
    needs_positive(42)      // ✅ Proven: 42 > 0

    let y: i32 = 10
    needs_positive(y)       // ✅ Proven: 10 > 0

    let z: i32 = compute()
    needs_positive(z)       // ⚠️ Cannot prove: inserts check
}
```

##### §11.4.4.3 Dynamic Checking

[12] When static proof fails, the compiler inserts a runtime precondition check according to the verification mode (§12.8):

$$
\text{Dynamic check:} \quad \texttt{if } \lnot P[params \mapsto args] \{ \texttt{panic}(\text{"precondition violated"}) \}
$$

[13] The check executes immediately before the procedure call. If the precondition evaluates to `false`, execution panics with a diagnostic message identifying the violated condition.

**Example 12.4.4.2 (Dynamic checking)**:

```cursive
procedure sqrt(x: f64): f64
    [[ |- x >= 0.0 => true ]]
{ }

procedure compute(input: f64)
{
    let result = sqrt(input)
    // Runtime check inserted:
    // if !(input >= 0.0) {
    //     panic("precondition violated: x >= 0.0")
    // }
}
```

##### §11.4.4.4 Control-Flow Sensitive Verification

[14] The compiler performs flow-sensitive analysis to prove preconditions within conditional contexts:

**Example 12.4.4.3 (Flow-sensitive proof)**:

```cursive
procedure divide(a: i32, b: i32): i32
    [[ |- b != 0 => true ]]
{ result a / b }

procedure safe_divide(x: i32, y: i32): i32 \/ string@View
{
    if y != 0 {
        result divide(x, y)  // ✅ Proven in this branch: y != 0
    } else {
        result "division by zero"
    }
}
```

[15] Within the `if y != 0` branch, the compiler knows `y != 0` holds, satisfying the precondition statically.

#### §11.4.5 Multiple Preconditions [contract.precondition.multiple]

[16] Multiple preconditions specified with commas are conjoined. All conditions must hold simultaneously:

$$
\texttt{must} \; P_1, P_2, \ldots, P_n \equiv \texttt{must} \; (P_1 \land P_2 \land \cdots \land P_n)
$$

[17] **Example 12.4.5.1 (Multiple preconditions)**:

```cursive
procedure array_get<T>(array: [T], index: usize): T
    [[
        |-
        index < array.len(),     // Precondition 1
        array.len() > 0,         // Precondition 2 (implied by 1, but explicit)
        T: Copy                  // Precondition 3 (type requirement)
        =>
        true
    ]]
{
    result array[index]
}
```

#### §11.4.6 Preconditions in Contracts [contract.precondition.contracts]

[18] Contract declarations may specify preconditions on abstract procedure signatures. Implementing types must provide implementations whose preconditions are _as weak or weaker_ than the contract's preconditions (Liskov substitution principle):

[19] **Precondition weakening rule**:

$$
\frac{\text{contract } C \{ \texttt{procedure } m \; \texttt{[[} \cdots \texttt{|-} P_{contract} \texttt{=>} \cdots \texttt{]]} \} \quad \text{type } T: C \{ \texttt{procedure } m \; \texttt{[[} \cdots \texttt{|-} P_{impl} \texttt{=>} \cdots \texttt{]]} \}}
     {P_{impl} \Rightarrow P_{contract}}
\tag{WF-Must-Weaken}
$$

[20] The implementation's precondition must imply the contract's precondition. Implementations may accept more inputs (weaker preconditions) but not fewer (stronger preconditions). Violations produce diagnostic E12-043.

**Example 12.4.6.1 (Precondition weakening in contract implementation)**:

```cursive
public contract Validator {
    procedure validate(~, value: i32): bool
        [[ |- value > 0 => true ]]
}

// Valid: Weaker precondition (accepts more inputs)
record LenientValidator: Validator {
    procedure validate(~, value: i32): bool
        [[ |- value >= 0 => true ]]  // ✅ OK: value >= 0 ⇒ value > 0
    {
        result value >= 0
    }
}

// Invalid: Stronger precondition (accepts fewer inputs)
record StrictValidator: Validator {
    procedure validate(~, value: i32): bool
        [[ |- value > 10 => true ]]  // ❌ ERROR: value > 10 does NOT imply value > 0
    {
        result value > 10
    }
}
```

#### §11.4.7 Diagnostics [contract.precondition.diagnostics]

[21] Precondition diagnostics:

| Code    | Condition                                          | Constraint |
| ------- | -------------------------------------------------- | ---------- |
| E12-007 | `result` identifier used in must clause            | [6]        |
| E12-008 | `@old` operator used in must clause                | [6]        |
| E12-040 | Precondition expression has non-bool type          | [1]        |
| E12-041 | Precondition performs side effects (not pure)      | [2]        |
| E12-042 | Precondition references local binding (not param)  | [3]        |
| E12-043 | Contract implementation has stronger precondition  | [20]       |
| E12-044 | Precondition cannot be evaluated (ill-formed expr) | [4]        |

#### §11.4.8 Conformance Requirements [contract.precondition.requirements]

[22] Implementations shall:

1. Parse must clauses as boolean predicate expressions
2. Enforce type requirement: predicates must have type `bool`
3. Enforce purity: reject effectful predicates in must clauses
4. Scope checking: parameters accessible, result/`@old`/locals inaccessible
5. Perform static verification using dataflow analysis and optional SMT solvers
6. Insert dynamic checks when static proof fails (per verification mode §12.8)
7. Support flow-sensitive analysis to prove preconditions in conditional contexts
8. Handle multiple preconditions via conjunction
9. Enforce Liskov substitution: implementation preconditions must weaken contract preconditions
10. Emit diagnostics E12-007, E12-008, E12-040 through E12-044 for violations
11. Provide diagnostic messages showing violated precondition and call site


### §11.5 Postconditions: will [contract.postcondition]

#### §11.5.1 Overview

[1] _Postconditions_ are boolean predicates that must hold when a procedure returns. They appear in the will clause of contractual sequents and specify _callee guarantees_: conditions the procedure implementation must ensure before returning.

[2] Postconditions enable:

- **Output validation**: Specify properties of return values and mutated parameters
- **Contract-based programming**: Explicit guarantees callers can rely upon
- **Static verification**: Provable postconditions enable optimization
- **Caller assumptions**: Callers may assume postconditions hold after calls
- **Documentation**: Machine-checkable specification of procedure effects

[3] This subclause specifies postcondition syntax, the `result` identifier, the `@old` temporal operator, verification strategies, and integration with contracts and behaviors.

#### §11.5.2 Syntax [contract.postcondition.syntax]

[4] Postcondition syntax appears in the will clause of sequents:

```ebnf
will_clause
    ::= predicate_expression
     | predicate_expression ("," predicate_expression)*
     | "true"

predicate_expression
    ::= expression

expression
    ::= "result" rel_op expression
     | "@old" "(" expression ")" rel_op expression
     | parameter_reference rel_op expression
     | logical_expression
```

[ Note: See Annex A §A.7 [grammar.sequent] and §A.8 [grammar.assertion] for complete grammar.
— end note ]

[5] Postcondition expressions may reference:

- The `result` identifier (procedure's return value)
- The `@old(expression)` operator (pre-state values)
- Procedure parameters (possibly mutated)
- Pure procedure calls
- Logical and comparison operators

[6] Postconditions shall not:

- Perform side effects (must be pure)
- Reference procedure-local bindings
- Nest `@old` operators: `@old(@old(x))` is ill-formed

**Example 12.5.2.1 (Postcondition forms)**:

```cursive
// Return value constraint
procedure absolute_value(x: i32): i32
    [[ |- true => result >= 0 ]]
{
    if x < 0 { result -x } else { result x }
}

// Relationship to input
procedure increment(x: i32): i32
    [[ |- true => result == x + 1 ]]
{
    result x + 1
}

// Using @old for mutation
procedure deposit(~!, amount: i64)
    [[
        ledger::post
        |-
        amount > 0
        =>
        self.balance == @old(self.balance) + amount,
        self.balance >= amount
    ]]
{
    self.balance += amount
}

// Multiple postconditions
procedure clamp(value: i32, min: i32, max: i32): i32
    [[
        |-
        min <= max
        =>
        result >= min,
        result <= max,
        (value >= min && value <= max) => result == value
    ]]
{
    if value < min { result min }
    else if value > max { result max }
    else { result value }
}
```

#### §11.5.3 The result Identifier [contract.postcondition.result]

[7] The `result` identifier is a special binding available exclusively in will clauses. It has the type of the procedure's declared return type and represents the value being returned.

[8] **result typing rule**:

[ Given: Procedure with return type $\tau$ ]

$$
\frac{\text{procedure } f(\ldots): \tau \; \texttt{[[} \cdots \texttt{=>} Q \texttt{]]}}
     {\text{In } Q: \texttt{result} : \tau}
\tag{T-Result}
$$

[9] Using `result` in must clauses is ill-formed (diagnostic E12-007). Using `result` in procedures with return type `()` (unit) is permitted; `result` has type `()` and value `()`.

**Example 12.5.3.1 (result identifier)**:

```cursive
// Numeric result
procedure factorial(n: i32): i32
    [[ |- n >= 0 => result >= 1 ]]
{
    // Implementation
}

// Union result (pattern matching in postcondition)
procedure parse_int(s: string@View): i32 \/ ParseError
    [[
        |-
        s.len() > 0
        =>
        match result {
            value: i32 => true,
            err: ParseError => s.contains_invalid_chars()
        }
    ]]
{
    // Implementation
}

// Unit result
procedure log(message: string@View)
    [[ io::write |- true => result == () ]]
    //                      ^^^^^^^^^^^^^^ Valid but trivial
{
    println("{}", message)
}
```

#### §11.5.4 The @old Temporal Operator [contract.postcondition.old]

[10] The `@old(expression)` operator evaluates `expression` in the procedure's pre-state (at entry, before the body executes) and captures its value for use in postconditions.

[11] **@old evaluation rule**:

[ Given: Procedure call at state $\sigma_{entry}$, body execution produces state $\sigma_{exit}$ ]

$$
\frac{\langle expr, \sigma_{entry} \rangle \Downarrow \langle v, \sigma_{entry} \rangle}
     {\texttt{@old}(expr) \text{ in postcondition} = v}
\tag{E-Old-Capture}
$$

[12] The expression is evaluated once at procedure entry and the resulting value is saved. When the postcondition is evaluated at return, `@old(expr)` refers to the captured value, not the current value.

##### §11.5.4.1 @old Constraints

[13] _Purity requirement._ Expressions within `@old(...)` shall be pure. Effectful expressions produce diagnostic E11-050.

[14] _Parameter scope._ @old expressions may reference parameters and their fields. They shall not reference procedure-local bindings or the `result` identifier. Violations produce diagnostic E11-051.

[15] _No nesting._ `@old` operators shall not nest. `@old(@old(x))` is ill-formed and produces diagnostic E11-009.

[16] _Will clause only._ `@old` is valid only in will clauses. Using it in must clauses produces diagnostic E11-008.

##### §11.5.4.2 @old Semantics

[17] Multiple `@old` expressions are evaluated independently at procedure entry:

**Example 12.5.4.1 (Multiple @old captures)**:

```cursive
procedure swap(a: unique Point, b: unique Point): (Point, Point)
    [[
        |-
        true
        =>
        result.0 == @old(b),
        result.1 == @old(a)
    ]]
{
    result (b, a)
}

// Evaluation:
// 1. Entry: Capture @old(a) → a_entry_value
// 2. Entry: Capture @old(b) → b_entry_value
// 3. Execute body: Swap values
// 4. Exit: Check result.0 == b_entry_value, result.1 == a_entry_value
```

[18] @old expressions may access fields of mutable parameters:

**Example 12.5.4.2 (Field access in @old)**:

```cursive
procedure increment_balance(~!, delta: i64)
    [[
        ledger::post
        |-
        delta > 0
        =>
        self.balance == @old(self.balance) + delta,
        self.balance >= @old(self.balance)
    ]]
{
    self.balance += delta
}

// @old(self.balance) captures the field value at entry
```

#### §11.5.5 Postcondition Verification [contract.postcondition.verification]

##### §11.5.5.1 Static Verification

[19] The compiler attempts to prove postconditions by analyzing all return paths in the procedure body:

$$
\frac{\forall \text{return path } \pi. \; \text{prove}(\pi \Rightarrow Q)}
     {\text{Postcondition } Q \text{ statically verified}}
\tag{Verify-Will-Static}
$$

[20] If all return paths provably satisfy the postcondition, no runtime check is needed.

**Example 12.5.5.1 (Static postcondition proof)**:

```cursive
procedure abs(x: i32): i32
    [[ |- true => result >= 0 ]]
{
    if x < 0 { result -x } else { result x }
}

// Compiler proves both paths:
// Path 1 (x < 0): result = -x, and -x >= 0 when x < 0 ✅
// Path 2 (x >= 0): result = x, and x >= 0 ✅
// No runtime check needed
```

##### §11.5.5.2 Dynamic Verification

[21] When static proof fails, the compiler inserts runtime postcondition checks at return points according to the verification mode (§12.8):

$$
\text{Dynamic check:} \quad \texttt{if } \lnot Q \{ \texttt{panic}(\text{"postcondition violated"}) \}
$$

[22] The check executes immediately before returning from the procedure. If the postcondition evaluates to `false`, execution panics with a diagnostic identifying the violated condition.

**Example 12.5.5.2 (Dynamic postcondition checking)**:

```cursive
procedure complex_calc(x: i32): i32
    [[ |- true => result > 0 ]]
{
    let computed = compute_value(x)
    result computed
    // Runtime check inserted:
    // if !(computed > 0) {
    //     panic("postcondition violated: result > 0")
    // }
}
```

##### §11.5.5.3 Multiple Return Paths

[23] Postconditions must hold on all non-diverging return paths. The compiler verifies each `result` statement and implicit return independently:

**Example 12.5.5.3 (Multiple return paths)**:

```cursive
procedure find_positive(numbers: [i32]): i32 \/ None
    [[
        |-
        numbers.len() > 0
        =>
        match result {
            value: i32 => value > 0,
            _: None => true
        }
    ]]
{
    loop n: i32 in numbers {
        if n > 0 {
            result n  // Check 1: n > 0 ✅
        }
    }
    result None { }   // Check 2: True (always) ✅
}
```

#### §11.5.6 Postconditions in Contracts [contract.postcondition.contracts]

[24] Contract declarations may specify postconditions on abstract procedure signatures. Implementing types must provide implementations whose postconditions are _as strong or stronger_ than the contract's postconditions:

[25] **Postcondition strengthening rule**:

$$
\frac{\text{contract } C \{ \texttt{procedure } m \; \texttt{[[} \cdots \texttt{=>} Q_{contract} \texttt{]]} \} \quad \text{type } T: C \{ \texttt{procedure } m \; \texttt{[[} \cdots \texttt{=>} Q_{impl} \texttt{]]} \}}
     {Q_{impl} \Rightarrow Q_{contract}}
\tag{WF-Will-Strengthen}
$$

[26] The implementation's postcondition must imply the contract's postcondition. Implementations may provide stronger guarantees but not weaker ones. Violations produce diagnostic E11-052.

**Example 12.5.6.1 (Postcondition strengthening)**:

```cursive
public contract PositiveProducer {
    procedure produce(~): i32
        [[ |- true => result > 0 ]]
}

// Valid: Stronger postcondition (better guarantee)
record StrictProducer: PositiveProducer {
    value: i32,

    procedure produce(~): i32
        [[ |- true => result > 10 ]]  // ✅ OK: result > 10 ⇒ result > 0
    {
        result self.value
    }
}

// Invalid: Weaker postcondition
record WeakProducer: PositiveProducer {
    procedure produce(~): i32
        [[ |- true => result >= 0 ]]  // ❌ ERROR: result >= 0 does NOT imply result > 0
    {
        result 0
    }
}
```

#### §11.5.7 Constraints [contract.postcondition.constraints]

[1] _Type requirement._ Predicate expressions in will clauses shall have type `bool`. Non-boolean predicates produce diagnostic E11-053.

[2] _Purity requirement._ Postconditions shall be pure expressions without side effects. Effectful postconditions produce diagnostic E11-054.

[3] _Scope restrictions._ Postconditions may reference parameters, `result`, and `@old` expressions. They shall not reference procedure-local bindings. Violations produce diagnostic E11-055.

[4] _result availability._ The `result` identifier is available in will clauses of procedures with non-unit return types. For procedures returning `()`, `result` is available but has trivial value `()`.

[5] _@old purity._ Expressions within `@old(...)` shall be pure and reference only parameters or parameter fields. Effectful @old expressions produce diagnostic E11-050; references to locals produce diagnostic E11-051.

[6] _No @old nesting._ The `@old` operator shall not contain nested `@old` operators. Violations produce diagnostic E11-009.

[7] _Postcondition coverage._ Postconditions shall be evaluable at all non-diverging exit points: every `result` statement and implicit procedure return. Unreachable code may omit postcondition satisfaction.

#### §11.5.8 Semantics [contract.postcondition.semantics]

##### §11.5.8.1 Guarantee Interpretation

[8] A postcondition $Q$ in sequent `[[ G |- P => Q ]]` provides a guarantee to callers:

$$
\frac{G \text{ available} \quad P \text{ holds at entry} \quad \text{procedure returns}}
     {Q \text{ holds at exit}}
\tag{Guarantee-Will}
$$

[9] After calling a procedure with postcondition $Q$, callers may assume $Q$ holds in the post-call state. This assumption is valid for subsequent static verification and enables compositional reasoning.

##### §11.5.8.2 @old Evaluation Semantics

[10] The `@old(expression)` operator is evaluated according to the following algorithm:

```
evaluate_postcondition_with_old(will_clause, entry_state, exit_state):
    // Phase 1: Capture @old expressions at entry
    old_values = {}
    for each @old(expr) in will_clause:
        value = evaluate(expr, entry_state)
        old_values[@old(expr)] = value

    // Phase 2: Evaluate postcondition at exit
    result_value = procedure_return_value
    postcond = substitute(will_clause, {
        "result" → result_value,
        @old(expr) → old_values[@old(expr)] for all @old in will_clause,
        parameters → exit_state[parameters]
    })

    // Phase 3: Check postcondition
    if evaluate(postcond, exit_state) == true:
        return Success
    else:
        return Failure("postcondition violated")
```

[11] Multiple `@old` expressions are captured independently. Each is evaluated exactly once at procedure entry.

**Example 12.5.8.1 (@old evaluation)**:

```cursive
procedure swap_balances(account1: unique Account, account2: unique Account)
    [[
        ledger::modify
        |-
        account1.balance > 0,
        account2.balance > 0
        =>
        account1.balance == @old(account2.balance),
        account2.balance == @old(account1.balance)
    ]]
{
    let temp = account1.balance
    account1.balance = account2.balance
    account2.balance = temp
}

// Execution:
// 1. Entry: Capture @old(account1.balance) = 100
// 2. Entry: Capture @old(account2.balance) = 200
// 3. Execute: Swap values
// 4. Exit: Verify account1.balance == 200, account2.balance == 100
```

##### §11.5.8.3 Multiple Postconditions

[12] Multiple postconditions are conjoined. All must hold simultaneously:

$$
\texttt{will} \; Q_1, Q_2, \ldots, Q_n \equiv \texttt{will} \; (Q_1 \land Q_2 \land \cdots \land Q_n)
$$

[13] If any postcondition fails verification, the procedure is ill-formed (if unprovable and mode is `static`) or inserts a check that may panic (if mode is `dynamic` or default).

#### §11.5.9 Postconditions on All Return Paths [contract.postcondition.paths]

[14] Procedures with multiple return points must satisfy postconditions on each path:

**Example 12.5.9.1 (Postconditions on multiple paths)**:

```cursive
procedure search(items: [i32], target: i32): i32 \/ None
    [[
        |-
        true
        =>
        match result {
            index: i32 => items[index] == target,
            _: None => true
        }
    ]]
{
    loop i in 0..items.len() {
        if items[i] == target {
            result i              // Path 1: Verify items[i] == target ✅
        }
    }
    result None { }               // Path 2: True (always) ✅
}
```

#### §11.5.10 Diagnostics [contract.postcondition.diagnostics]

[15] Postcondition diagnostics:

| Code    | Condition                                            | Constraint |
| ------- | ---------------------------------------------------- | ---------- |
| E11-009 | Nested `@old` operators                              | [6]        |
| E11-050 | Effectful expression in `@old(...)`                  | [5]        |
| E11-051 | `@old` references local binding (not parameter)      | [5]        |
| E11-052 | Contract implementation has weaker postcondition     | [26]       |
| E11-053 | Postcondition expression has non-bool type           | [1]        |
| E11-054 | Postcondition performs side effects (not pure)       | [2]        |
| E11-055 | Postcondition references local binding               | [3]        |
| E11-056 | Postcondition unprovable in static verification mode | [20]       |

#### §11.5.11 Conformance Requirements [contract.postcondition.requirements]

[16] Implementations shall:

1. Parse will clauses as boolean predicate expressions
2. Provide `result` identifier with procedure return type in will clauses
3. Implement `@old(expression)` operator capturing pre-state values
4. Evaluate @old expressions at procedure entry before body execution
5. Support multiple independent @old captures in single postcondition
6. Enforce type requirement: postconditions must have type `bool`
7. Enforce purity: reject effectful predicates and @old expressions
8. Scope checking: parameters and result accessible, locals inaccessible
9. Reject nested @old operators
10. Verify postconditions on all non-diverging return paths
11. Enforce Liskov substitution: implementation postconditions must strengthen contract postconditions
12. Insert dynamic checks when static proof fails (per verification mode)
13. Emit diagnostics E11-009, E11-050 through E11-056 for violations
14. Provide diagnostic messages showing violated postcondition and return point


### §11.6 Invariants: where [contract.invariant]

#### §11.6.1 Overview

[1] _Invariants_ are conditions that must hold persistently throughout an object's lifetime or at specific program points. Cursive uses the `where` keyword to declare invariants in multiple contexts: type declarations, loop statements, and potentially other scoping constructs.

[2] Invariants are syntactic sugar: they desugar to conjunctions in sequent postconditions. The `where { inv }` clause automatically extends postconditions of relevant procedures with `&& inv`, eliminating repetition and ensuring invariants are maintained automatically.

[3] This subclause specifies invariant syntax, desugaring rules, checking semantics, and the unified `where` terminology across all contexts.

#### §11.6.2 Type Invariants [contract.invariant.type]

##### §11.6.2.1 Overview

[4] Type invariants are declared on record, enum, and modal type bodies using `where` clauses. They specify conditions that must hold for all instances of the type at all observable program points.

##### §11.6.2.2 Syntax

[5] Type invariant syntax (from §5.5.3):

```ebnf
type_declaration
    ::= attribute* visibility? type_keyword identifier generic_params?
        type_body where_clause?

where_clause
    ::= "where" "{" invariant_list "}"

invariant_list
    ::= invariant_expression ("," invariant_expression)*

invariant_expression
    ::= expression
```

[6] Invariant expressions are boolean predicates that may reference type fields using `self` or field names directly.

**Example 12.6.2.1 (Type invariants)**:

```cursive
record BankAccount {
    balance: i64,
    overdraft_limit: i64,

    where {
        balance >= -overdraft_limit,
        overdraft_limit >= 0
    }
}

enum Status {
    Pending { priority: i32 },
    Active { started: Timestamp },
    Completed { duration: i64 },

    where {
        match self {
            Status::Pending { priority } => priority >= 0,
            Status::Active { started } => started.is_valid(),
            Status::Completed { duration } => duration > 0
        }
    }
}
```

##### §11.6.2.3 Desugaring Rules

[7] Type invariants automatically extend the postconditions of:

1. All constructors (record literal expressions, enum variant construction)
2. All mutating methods (procedures with receiver `~!` or `~%`)
3. All procedures that return instances of the type

[8] **Type invariant desugaring rule**:

[ Given: Type $T$ with invariant $I$ ]

$$
\frac{\text{record } T \{ \ldots \} \text{ where } \{ I \} \quad \text{procedure } m: T \; \texttt{[[} G \texttt{|-} P \texttt{=>} Q \texttt{]]}}
     {\text{Effective postcondition: } Q' = Q \land I}
\tag{Desugar-Type-Inv}
$$

[9] The compiler automatically conjoins the invariant with explicit postconditions. Programmers need not write the invariant in every method's will clause.

**Example 12.6.2.2 (Desugaring demonstration)**:

```cursive
record Counter {
    value: i32,

    where {
        value >= 0
    }

    // Original procedure sequent:
    procedure increment(~!)
        [[ |- true => true ]]
    {
        self.value += 1
    }

    // Compiler desugars to:
    // [[ |- true => (true && self.value >= 0) ]]
    // Simplified: [[ |- true => self.value >= 0 ]]
}

// Constructor literal
let counter = Counter { value: 0 }
// Desugars to check: counter.value >= 0

// Invalid construction
let invalid = Counter { value: -5 }
// Error: invariant violated (value >= 0)
```

##### §11.6.2.4 Checking Points

[10] Type invariants are verified at:

- **Construction**: Record/enum literal expressions
- **Mutation**: After any procedure modifying type fields (receivers `~!`, `~%`)
- **Assignment**: After field assignment statements
- **Return**: When procedures return instances of the type

[11] The compiler inserts checks according to verification mode (§12.8). Statically provable invariants have zero runtime cost; unprovable invariants insert assertions.

#### §11.6.3 Loop Invariants [contract.invariant.loop]

##### §11.6.3.1 Overview

[12] Loop invariants are conditions that must hold on loop entry, at the start of each iteration, and on loop exit. They are specified using `where` clauses on loop statements.

##### §11.6.3.2 Syntax

[13] Loop invariant syntax:

```ebnf
loop_statement
    ::= "loop" loop_condition? "where" "{" invariant_list "}" block

invariant_list
    ::= invariant_expression ("," invariant_expression)*
```

[14] Loop invariants may reference loop variables, parameters, and outer scope bindings visible at the loop site.

**Example 12.6.3.1 (Loop invariants)**:

```cursive
procedure sum_array(numbers: [i32]): i32
    [[ |- numbers.len() > 0 => result >= 0 ]]
{
    var total: i32 = 0
    var i: usize = 0

    loop i < numbers.len() where { total >= 0, i <= numbers.len() } {
        total = total + numbers[i]
        i = i + 1
    }

    result total
}
```

##### §11.6.3.3 Loop Invariant Verification

[15] Loop invariants are verified at three points:

1. **Entry**: Before first iteration
2. **Iteration**: At the start of each loop iteration
3. **Exit**: After loop completes

[16] **Loop invariant checking rule**:

[ Given: Loop with invariant $I$, loop body $B$ ]

$$
\frac{\text{Before loop: } I \quad \text{Each iteration: } I \land B \Rightarrow I \quad \text{After loop: } I}
     {\text{Loop invariant } I \text{ verified}}
\tag{WF-Loop-Inv}
$$

[17] The invariant must hold before entering the loop, be preserved by each iteration, and therefore hold upon exit.

**Example 12.6.3.2 (Loop invariant verification)**:

```cursive
procedure binary_search<T: Ord>(array: [T; n], target: T): i32 \/ None
    [[ |- array.is_sorted() => true ]]
{
    var low: usize = 0
    var high: usize = array.len()

    loop low < high where { low <= high, high <= array.len() } {
        let mid = (low + high) / 2
        match array[mid].compare(target) {
            cmp: i32 if cmp < 0 => { low = mid + 1 }
            cmp: i32 if cmp > 0 => { high = mid }
            _ => { result mid }
        }
    }
    result None { }
}

// Verification:
// Entry: low = 0, high = n → low <= high ✅, high <= n ✅
// Iteration: Updates preserve invariant
// Exit: Invariant still holds
```

#### §11.6.4 Invariant Desugaring [contract.invariant.desugaring]

##### §11.6.4.1 Type Invariant Desugaring

[18] For a type $T$ with invariant $I$, the compiler automatically extends sequents:

**Constructor desugaring**:

$$
\text{Literal: } T \{ \ldots \} \quad \Rightarrow \quad \texttt{check } I \text{ after construction}
$$

**Mutator desugaring**:

$$
\text{procedure } m(\sim!, \ldots) \; \texttt{[[} G \texttt{|-} P \texttt{=>} Q \texttt{]]} \quad \Rightarrow \quad \texttt{[[} G \texttt{|-} P \texttt{=>} Q \land I \texttt{]]}
$$

[19] The invariant $I$ is conjoined with the explicit postcondition $Q$. If $Q = \texttt{true}$, the effective postcondition becomes simply $I$.

##### §11.6.4.2 Loop Invariant Desugaring

[20] Loop invariants desugar to verification points:

```
loop condition where { I } body

Desugars to:

assert!(I)                    // Entry check
loop condition {
    assert!(I)                // Iteration check (start of each iteration)
    body
}
assert!(I)                    // Exit check
```

[21] Assertion insertion follows verification mode (§12.8). Static verification mode requires proving invariant maintenance at compile time.

#### §11.6.5 Constraints [contract.invariant.constraints]

[1] _Type requirement._ Invariant expressions shall have type `bool`. Non-boolean invariants produce diagnostic E12-060.

[2] _Purity requirement._ Invariants shall be pure expressions without side effects. Effectful invariants produce diagnostic E12-061.

[3] _Scope restrictions._ Type invariants may reference `self` and type fields. Loop invariants may reference loop variables and outer bindings. Referencing inaccessible bindings produces diagnostic E12-062.

[4] _No @old in invariants._ Invariants are not temporal predicates; they assert current state properties. Using `@old` in invariants produces diagnostic E12-063.

[5] _No result in type invariants._ Type invariants apply to all instances; `result` is specific to procedure returns. Using `result` in type invariants produces diagnostic E12-064.

[6] _Invariant maintainability._ For type invariants, the compiler shall verify that the invariant can be satisfied. Unsatisfiable invariants (e.g., `where { false }`) produce diagnostic E12-065 warning that the type is uninhabitable.

#### §11.6.6 Semantics [contract.invariant.semantics]

##### §11.6.6.1 Type Invariant Semantics

[7] A type invariant $I$ asserts that all observable instances of the type satisfy $I$. An instance is _observable_ after construction and between method calls.

[8] **Type invariant satisfaction**:

[ Given: Type $T$ with invariant $I$, instance $v: T$ ]

$$
\frac{\text{type } T \text{ where } \{ I \} \quad v : T \text{ observable}}
     {I[self \mapsto v] = \text{true}}
\tag{P-Type-Inv-Holds}
$$

[9] The invariant must hold for value $v$ at all observable points. Temporary violations during method execution (while `self` is uniquely held) are permitted; the invariant must be restored before the method returns.

**Example 12.6.6.1 (Temporary invariant violation)**:

```cursive
record SortedList<T: Ord> {
    elements: [T],

    where {
        is_sorted(elements)
    }

    procedure insert(~!, item: T)
        [[ alloc::heap |- true => is_sorted(self.elements) ]]
    {
        self.elements.push(item)      // Temporarily violates invariant
        self.elements.sort()           // Restores invariant
        // Exit: invariant checked → is_sorted(self.elements) ✅
    }
}
```

##### §11.6.6.2 Loop Invariant Semantics

[10] A loop invariant $I$ is an inductive assertion proved by:

1. **Base case**: $I$ holds before the first iteration
2. **Inductive case**: If $I$ holds at iteration start, it holds at iteration end
3. **Conclusion**: $I$ holds after loop exits

[11] **Loop invariant induction**:

$$
\frac{I_{entry} \quad \forall \text{iteration}. \; I_{start} \Rightarrow I_{end} \quad \lnot condition \Rightarrow I_{exit}}
     {\text{Loop invariant } I \text{ verified}}
\tag{Loop-Inv-Induction}
$$

**Example 12.6.6.2 (Loop invariant induction)**:

```cursive
procedure count_positive(numbers: [i32]): i32
    [[ |- true => result >= 0 ]]
{
    var count: i32 = 0
    var i: usize = 0

    loop i < numbers.len() where { count >= 0, i <= numbers.len() } {
        if numbers[i] > 0 {
            count = count + 1
        }
        i = i + 1
    }

    result count
}

// Verification:
// Entry: count = 0 → count >= 0 ✅, i = 0 → i <= len ✅
// Iteration: Assume (count >= 0, i <= len)
//            Execute body: count unchanged or +1 → count >= 0 ✅
//                         i = i + 1 → i <= len (by loop condition) ✅
// Exit: Invariant holds → count >= 0 ✅
```

#### §11.6.7 Automatic Invariant Checking [contract.invariant.automatic]

[12] The compiler automatically inserts invariant checks without programmer intervention:

**For type invariants**:

- After every constructor expression
- After every mutating method returns
- After field assignment to types with invariants

**For loop invariants**:

- Before loop entry
- At loop iteration boundaries (checked per verification mode)
- After loop exit

[13] Programmers write invariants once; the compiler enforces them everywhere automatically.

#### §11.6.8 Integration with Sequent Postconditions [contract.invariant.integration]

[14] When a procedure has both explicit postconditions and type invariants, they are conjoined:

**Example 12.6.8.1 (Invariant and postcondition conjunction)**:

```cursive
record Account {
    balance: i64,

    where {
        balance >= 0
    }

    procedure deposit(~!, amount: i64)
        [[
            ledger::post
            |-
            amount > 0
            =>
            self.balance >= amount      // Explicit postcondition
        ]]
    {
        self.balance += amount
    }
}

// Desugared sequent:
// [[
//     ledger::post
//     |-
//     amount > 0
//     =>
//     (self.balance >= amount) && (self.balance >= 0)
//     ^^^^^^^^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^
//     Explicit                    Type invariant (automatic)
// ]]
```

[15] The conjunction occurs automatically. Both conditions are verified using the same verification strategy (static proof or dynamic checking).

#### §11.6.9 Constraints [contract.invariant.constraints]

[1] _Boolean type._ Invariant expressions shall have type `bool`. Non-boolean invariants produce diagnostic E12-060.

[2] _Purity._ Invariants shall be pure expressions. Effectful invariants produce diagnostic E12-061.

[3] _Scope validity._ Type invariants may reference `self` and type fields. Loop invariants may reference loop variables and outer bindings. Invalid references produce diagnostic E12-062.

[4] _No temporal operators._ Invariants assert current state; `@old` is not valid in where clauses. Violations produce diagnostic E12-063.

[5] _No result in type invariants._ The `result` identifier is procedure-specific; type invariants are type-wide. Using `result` in type where clauses produces diagnostic E12-064.

[6] _Satisfiability._ Implementations should warn when type invariants are unsatisfiable (e.g., `where { false }`). Diagnostic E12-065 indicates the type is uninhabitable.

#### §11.6.10 Examples [contract.invariant.examples]

**Example 12.6.10.1 (Comprehensive type invariant)**:

```cursive
record Rectangle {
    width: f64,
    height: f64,

    where {
        width > 0.0,
        height > 0.0
    }

    procedure area(~): f64
        [[ |- true => result > 0.0 ]]
    {
        result self.width * self.height
    }

    procedure scale(~!, factor: f64)
        [[ |- factor > 0.0 => true ]]
    {
        self.width = self.width * factor
        self.height = self.height * factor
        // Automatic check: width > 0.0 && height > 0.0
    }
}

// Construction
let rect = Rectangle { width: 10.0, height: 5.0 }
// Check: 10.0 > 0.0 && 5.0 > 0.0 ✅

// Invalid construction
let bad = Rectangle { width: -1.0, height: 5.0 }
// Error: invariant violated (width > 0.0 fails)
```

**Example 12.6.10.2 (Loop invariant with verification)**:

```cursive
procedure find_max(numbers: [i32]): i32
    [[ |- numbers.len() > 0 => result >= numbers[0] ]]
{
    var max: i32 = numbers[0]
    var i: usize = 1

    loop i < numbers.len() where {
        max >= numbers[0],
        i > 0,
        i <= numbers.len()
    } {
        if numbers[i] > max {
            max = numbers[i]
        }
        i = i + 1
    }

    result max
}
```

**Example 12.6.10.3 (Invariant on enum)**:

```cursive
enum Temperature {
    Celsius { value: f64 },
    Fahrenheit { value: f64 },
    Kelvin { value: f64 },

    where {
        match self {
            Temperature::Kelvin { value } => value >= 0.0,  // Absolute zero
            _ => true
        }
    }
}

// Valid
let abs_zero = Temperature::Kelvin { value: 0.0 }

// Invalid
let impossible = Temperature::Kelvin { value: -1.0 }
// Error: invariant violated (Kelvin value must be >= 0.0)
```

#### §11.6.11 Diagnostics [contract.invariant.diagnostics]

[16] Invariant diagnostics:

| Code    | Condition                                         | Constraint |
| ------- | ------------------------------------------------- | ---------- |
| E12-060 | Invariant expression has non-bool type            | [1]        |
| E12-061 | Invariant performs side effects (not pure)        | [2]        |
| E12-062 | Invariant references inaccessible binding         | [3]        |
| E12-063 | `@old` operator used in where clause              | [4]        |
| E12-064 | `result` identifier used in type invariant        | [5]        |
| E12-065 | Unsatisfiable type invariant (type uninhabitable) | [6]        |
| E12-066 | Invariant violated at construction                | [10]       |
| E12-067 | Invariant violated after mutation                 | [10]       |
| E12-068 | Loop invariant violated at entry                  | [15]       |
| E12-069 | Loop invariant not preserved by iteration         | [15]       |

#### §11.6.12 Conformance Requirements [contract.invariant.requirements]

[17] Implementations shall:

1. Parse `where { ... }` clauses on type declarations and loop statements
2. Desugar type invariants to postcondition conjunctions on constructors and mutators
3. Desugar loop invariants to entry/iteration/exit verification points
4. Enforce boolean type requirement for all invariants
5. Enforce purity requirement for all invariants
6. Validate scope restrictions (self/fields for types, loop vars for loops)
7. Reject `@old` and inappropriate `result` uses in invariants
8. Verify invariants at all specified checking points
9. Insert dynamic checks when static proof fails (per verification mode)
10. Warn about unsatisfiable type invariants
11. Emit diagnostics E12-060 through E12-069 for violations
12. Maintain invariant metadata for tooling and documentation


### §11.7 Sequent Checking Flow [contract.checking]

#### §11.7.1 Overview

[1] This subclause specifies the algorithms for verifying contractual sequents at compilation and runtime. Checking occurs at three program points: procedure call sites (grant and precondition checking), procedure entry (precondition validation), and procedure exit (postcondition validation).

[2] The checking flow integrates with:

- Name resolution (Clause 6) for grant path lookup
- Type checking (Clause 7) for predicate expression typing
- Control-flow analysis (Clause 9) for flow-sensitive verification
- Verification modes (§12.8) for determining when to insert runtime checks

[3] This subclause provides normative algorithms that implementations shall follow or refine conservatively (rejecting strictly more programs).

#### §11.7.2 Call-Site Checking [contract.checking.callsite]

##### §11.7.2.1 Overview

[4] When a procedure $f$ is called, the compiler verifies that:

1. **Grant availability**: All grants required by $f$ are available in the calling context
2. **Precondition satisfaction**: The preconditions of $f$ hold for the provided arguments

[5] Grant checking is purely static. Precondition checking may be static or dynamic depending on provability and verification mode.

##### §11.7.2.2 Grant Checking Algorithm

[6] The grant checking algorithm:

```
check_grants_at_call(callee, caller_context):
    required_grants = callee.sequent.grants
    available_grants = caller_context.sequent.grants

    if required_grants ⊆ available_grants:
        return Success
    else:
        missing = required_grants \ available_grants
        return Error(E11-030, {
            callee: callee.name,
            required: required_grants,
            available: available_grants,
            missing: missing
        })
```

[7] **Grant availability rule**:

[ Given: Call to procedure $f$ with grants $G_f$ in procedure $g$ with grants $G_g$ ]

$$
\frac{G_f \subseteq G_g}
     {\text{Call } f() \text{ from } g \text{ permitted}}
\tag{WF-Grant-Available}
$$

[8] If $G_f \not\subseteq G_g$, the call is ill-formed and produces diagnostic E11-030 listing the missing grants.

**Example 12.7.2.1 (Grant checking)**:

```cursive
procedure write_log(message: string@View)
    [[ io::write |- true => true ]]
{ }

procedure process()
    [[ io::write, alloc::heap |- true => true ]]
{
    write_log("Processing...")  // ✅ {io::write} ⊆ {io::write, alloc::heap}
}

procedure invalid()
    [[ alloc::heap |- true => true ]]
{
    write_log("Error")  // ❌ E11-030: missing grant io::write
}
```

##### §11.7.2.3 Precondition Checking Algorithm

[9] The precondition checking algorithm:

```
check_precondition_at_call(callee, args, context):
    precondition = callee.sequent.must
    substituted = precondition[params ↦ args]

    // Attempt static proof
    if can_prove_statically(substituted, context):
        return Success  // No runtime check needed

    // Check verification mode
    match context.verification_mode:
        Static:
            return Error(E11-056, "Cannot prove precondition statically")

        Dynamic:
            insert_assertion(substituted, "precondition violated")
            return Success  // Check inserted

        Trusted:
            return Success  // No check

        Default:
            if debug_build():
                insert_assertion(substituted, "precondition violated")
            // Release: skip if unprovable
            return Success
```

[10] **Precondition verification judgment**:

[ Given: Call `f(args)` with precondition $P$ ]

$$
\frac{\Gamma \vdash P[params \mapsto args]}
     {\text{Precondition statically verified}}
\tag{Verify-Must}
$$

$$
\frac{\Gamma \not\vdash P[params \mapsto args] \quad \text{mode} = \text{dynamic}}
     {\text{Insert check: } \texttt{assert}(P[params \mapsto args])}
\tag{Insert-Must-Check}
$$

#### §11.7.3 Procedure Entry Checking [contract.checking.entry]

[11] At procedure entry, if dynamic precondition checks were inserted, they execute before the procedure body:

```
procedure_entry(callee, args):
    // Evaluate dynamic precondition checks
    for check in callee.dynamic_preconditions:
        if !evaluate(check[params ↦ args]):
            panic("precondition violated: {}", check.source)

    // Capture @old expressions for postconditions
    old_captures = {}
    for @old(expr) in callee.sequent.will:
        old_captures[@old(expr)] = evaluate(expr, current_state)

    // Execute procedure body
    execute_body(callee.body, args, old_captures)
```

[12] Precondition failures panic immediately with diagnostic messages identifying the violated condition and source location.

#### §11.7.4 Procedure Exit Checking [contract.checking.exit]

[13] At procedure exit (all `result` statements and implicit returns), the compiler verifies postconditions:

```
check_postcondition_at_exit(callee, result_value, old_captures, exit_state):
    postcondition = callee.sequent.will

    // Add type invariants if applicable
    if callee.return_type has invariant I:
        postcondition = postcondition && I

    // Substitute result and @old
    substituted = postcondition[
        result ↦ result_value,
        @old(expr) ↦ old_captures[@old(expr)],
        params ↦ exit_state[params]
    ]

    // Attempt static proof
    if can_prove_statically(substituted, callee.body):
        return Success  // No runtime check

    // Dynamic checking per mode
    match callee.verification_mode:
        Static:
            return Error(E11-056, "Cannot prove postcondition statically")

        Dynamic:
            insert_assertion_at_return(substituted, "postcondition violated")
            return Success

        Trusted:
            return Success  // No check

        Default:
            if debug_build():
                insert_assertion_at_return(substituted, "postcondition violated")
            return Success
```

[14] **Postcondition verification judgment**:

[ Given: Procedure return with postcondition $Q$ ]

$$
\frac{\text{All paths: } \text{body} \Rightarrow Q}
     {\text{Postcondition statically verified}}
\tag{Verify-Will}
$$

$$
\frac{\text{Cannot prove } \text{body} \Rightarrow Q \quad \text{mode} = \text{dynamic}}
     {\text{Insert check: } \texttt{assert}(Q) \text{ before return}}
\tag{Insert-Will-Check}
$$

#### §11.7.5 Flow-Sensitive Verification [contract.checking.flow]

[15] The compiler performs flow-sensitive analysis to prove contracts within conditional contexts and after definite assignments:

**Example 12.7.5.1 (Flow-sensitive precondition proof)**:

```cursive
procedure safe_divide(a: i32, b: i32): i32
    [[ |- b != 0 => true ]]
{ result a / b }

procedure caller(x: i32, y: i32): i32 \/ string@View
{
    if y == 0 {
        result "division by zero"
    }

    // Compiler knows: y != 0 in this branch
    result safe_divide(x, y)  // ✅ Proven: y != 0
}
```

[16] Flow-sensitive analysis tracks facts through control flow:

- **Conditional guards**: `if x > 0` establishes `x > 0` in then-branch
- **Pattern matching**: Match arms establish type refinement and value constraints
- **Definite assignment**: Initialized bindings have known values

#### §11.7.6 Compositional Checking [contract.checking.compositional]

[17] Contract checking is compositional: verifying a procedure's contract does not require inspecting called procedures' implementations. The compiler relies on callee contracts:

**Example 12.7.6.1 (Compositional verification)**:

```cursive
procedure validate(x: i32): bool
    [[ |- true => result == (x > 0) ]]
{ result x > 0 }

procedure process(value: i32)
    [[ |- value > 0 => true ]]
{ }

procedure caller(input: i32)
    [[ |- true => true ]]
{
    if validate(input) {
        // Compiler knows from validate's postcondition: input > 0
        process(input)  // ✅ Proven without inspecting validate's body
    }
}
```

[18] The postcondition of `validate` (`result == (input > 0)`) combined with the conditional `if validate(input)` establishes `input > 0`, satisfying `process`'s precondition.

#### §11.7.7 Grant Propagation Through Expressions [contract.checking.propagation]

[19] Grant sets propagate through expressions as specified in §8.1.5. The compiler accumulates grants bottom-up through the expression tree:

$$
\frac{\Gamma \vdash e_1 : \tau_1 \; ! G_1 \quad \Gamma \vdash e_2 : \tau_2 \; ! G_2}
     {\Gamma \vdash (e_1 \texttt{;} e_2) : \tau_2 \; ! (G_1 \cup G_2)}
\tag{Grant-Accumulate}
$$

[20] The accumulated grant set for the procedure body must be a subset of the declared grant clause. Missing grants produce diagnostic E11-030.

**Example 12.7.7.1 (Grant accumulation)**:

```cursive
procedure read_file(path: string@View): string@Managed
    [[ fs::read, alloc::heap |- true => true ]]
{ }

procedure write_file(path: string@View, content: string@View)
    [[ fs::write |- true => true ]]
{ }

procedure copy_file(source: string@View, dest: string@View)
    [[ fs::read, fs::write, alloc::heap |- true => true ]]
{
    let content = read_file(source)     // Requires: {fs::read, alloc::heap}
    write_file(dest, content.view())    // Requires: {fs::write}
    // Accumulated: {fs::read, alloc::heap} ∪ {fs::write}
    //            = {fs::read, fs::write, alloc::heap}
    // Must equal declared grants ✅
}
```

#### §11.7.8 Integration with Definite Assignment [contract.checking.definite]

[21] Precondition checking integrates with definite assignment analysis (§5.7). Conditionals that assign variables enable proving preconditions dependent on those variables:

**Example 12.7.8.1 (Definite assignment integration)**:

```cursive
procedure needs_positive(x: i32)
    [[ |- x > 0 => true ]]
{ }

procedure demo(input: i32)
{
    var validated: i32

    if input > 0 {
        validated = input
        needs_positive(validated)  // ✅ Proven: validated = input > 0
    } else {
        validated = 1
        needs_positive(validated)  // ✅ Proven: validated = 1 > 0
    }
}
```

#### §11.7.9 Diagnostics [contract.checking.diagnostics]

[22] Checking flow diagnostics:

| Code    | Condition                                  | Section |
| ------- | ------------------------------------------ | ------- |
| E11-030 | Call site missing required grants          | [8]     |
| E11-056 | Static verification failed (mode=static)   | [9, 13] |
| E11-070 | Grant accumulation exceeds declared grants | [20]    |

#### §11.7.10 Conformance Requirements [contract.checking.requirements]

[23] Implementations shall:

1. Implement call-site grant checking per §11.7.2 algorithm
2. Implement precondition checking per §11.7.2.3 algorithm
3. Implement postcondition checking per §11.7.4 algorithm
4. Support flow-sensitive analysis for conditional proof contexts
5. Enable compositional verification using callee postconditions
6. Accumulate grant sets through expression evaluation
7. Verify accumulated grants match declared grant clauses
8. Integrate with definite assignment analysis for verification
9. Emit diagnostics E11-030, E11-056, E11-070 for checking failures
10. Provide detailed diagnostic messages showing proof obligations and context


### §11.8 Verification Modes and Dynamic Hooks to Witnesses [contract.verification]

#### §11.8.1 Overview

[1] _Verification modes_ control when and how contractual sequents are checked. Cursive supports three explicit modes (`static`, `dynamic`, `trusted`) plus a build-mode-dependent default. Modes determine whether contracts are proven at compile time, checked at runtime, or trusted without verification.

[2] Verification modes balance safety, performance, and formal verification requirements. They are specified via attributes and do not affect procedure type signatures or sequent semantics—two procedures with identical sequents but different verification modes have the same type.

[3] This subclause specifies verification mode syntax, semantics, checking strategies, and integration with the witness system (Clause 12) for dynamic verification hooks.

#### §11.8.2 Verification Mode Specification [contract.verification.modes]

##### §11.8.2.1 Attribute Syntax

[4] Verification modes are specified using the `verify` attribute on procedure declarations:

```ebnf
verification_attribute
    ::= "[[" "verify" "(" verification_mode ")" "]]"

verification_mode
    ::= "static"
     | "dynamic"
     | "trusted"
```

[5] The attribute appears before the procedure declaration:

```cursive
[[verify(static)]]
procedure critical_operation(x: i32): i32
    [[ |- x > 0 => result > x ]]
{ }
```

##### §11.8.2.2 Mode Semantics

**static mode**:
[6] Contracts must be proven at compile time. If static verification fails, compilation fails with diagnostic E11-056. No runtime checks are inserted.

**dynamic mode**:
[7] Runtime checks are always inserted for preconditions and postconditions, regardless of whether they can be proven statically. This provides maximum safety at runtime cost.

**trusted mode**:
[8] Contracts are trusted without verification. No static proof is attempted and no runtime checks are inserted. The programmer assumes responsibility for contract satisfaction. This mode is for performance-critical code with externally verified contracts.

**default mode (no attribute)**:
[9] Verification strategy is build-mode dependent:

- **Debug builds** (`--build=debug` or `NDEBUG` undefined): Insert runtime checks for unprovable contracts
- **Release builds** (`--build=release` or `NDEBUG` defined): Only proven checks execute; unprovable contracts are skipped
- **Unsafe mode** (`--verify=none` flag): Skip all contract checking

#### §11.8.3 Verification Mode Selection [contract.verification.selection]

[10] The effective verification mode for a procedure is determined by:

```
select_verification_mode(procedure):
    if procedure has [[verify(mode)]] attribute:
        return mode  // Explicit override

    // Build-mode default
    if compiler_flag(--verify=none):
        return Trusted
    else if compiler_flag(--build=debug) or !defined(NDEBUG):
        return Dynamic  // Debug: insert checks
    else if compiler_flag(--build=release) or defined(NDEBUG):
        return ProvenOnly  // Release: proven checks only
    else:
        return Dynamic  // Conservative default
```

[11] Explicit mode attributes override build-mode defaults, enabling fine-grained control when needed.

#### §11.8.4 Static Verification Strategy [contract.verification.static]

[12] In `static` verification mode, the compiler must prove contracts or reject compilation. The verification strategy employs:

**Symbolic execution**:
[13] The compiler symbolically executes procedure bodies, propagating constraints through assignments, conditionals, and calls. Symbolic states track variable values and path conditions.

**SMT solver integration** (optional):
[14] Implementations may invoke SMT (Satisfiability Modulo Theories) solvers to discharge proof obligations. SMT integration is optional; implementations without solvers may reject more programs conservatively.

**Path-sensitive analysis**:
[15] The compiler analyzes each control-flow path independently, proving that postconditions hold on all paths and preconditions are satisfied at all call sites.

**Example 12.8.4.1 (Static verification)**:

```cursive
[[verify(static)]]
procedure factorial(n: i32): i32
    [[ |- n >= 0, n <= 12 => result >= 1 ]]
{
    if n <= 1 {
        result 1  // Path 1: result = 1 ≥ 1 ✅
    } else {
        result n * factorial(n - 1)
        // Path 2: Requires proof by induction
        // If provable: ✅
        // If not provable: ❌ E11-056
    }
}
```

#### §11.8.5 Dynamic Verification Strategy [contract.verification.dynamic]

[16] In `dynamic` verification mode, the compiler inserts runtime assertions for all contracts:

**Precondition checks**:
[17] Inserted immediately before procedure call:

```cursive
// Source
procedure divide(a: i32, b: i32): i32
    [[ |- b != 0 => true ]]
{ result a / b }

let result = divide(x, y)

// Compiled (dynamic mode)
if !(y != 0) {
    panic("precondition violated: b != 0")
}
let result = divide(x, y)
```

**Postcondition checks**:
[18] Inserted at all return points:

```cursive
// Source
procedure abs(x: i32): i32
    [[ |- true => result >= 0 ]]
{
    if x < 0 { result -x } else { result x }
}

// Compiled (dynamic mode)
procedure abs(x: i32): i32 {
    let __result = if x < 0 { -x } else { x }
    if !(__result >= 0) {
        panic("postcondition violated: result >= 0")
    }
    __result
}
```

#### §11.8.6 Trusted Mode [contract.verification.trusted]

[19] In `trusted` mode, no verification occurs. The programmer certifies that contracts are satisfied:

```cursive
[[verify(trusted)]]
procedure hot_path(data: Buffer): i32
    [[ |- data.len() > 0 => result >= 0 ]]
{
    // No checks inserted
    // Programmer responsible for ensuring contract
    result unsafe { data.unchecked_get(0) }
}
```

[20] Trusted mode is appropriate for:

- Performance-critical inner loops with externally verified contracts
- Procedures with contracts proven by external tools
- FFI boundaries where contracts are enforced by foreign code
- Micro-optimizations after extensive testing

[ Warning: Violating contracts in trusted mode may produce undefined behavior. Use trusted mode only when contract satisfaction can be assured through other means.
— end warning ]

#### §11.8.7 Build-Mode Defaults [contract.verification.buildmode]

[21] Without explicit `[[verify(...)]]` attributes, verification follows build-mode conventions:

**Table 12.3 — Build-mode verification defaults**

| Build Mode   | Compiler Flag     | Static Proof Attempted | Unprovable Contracts | Proven Contracts   |
| ------------ | ----------------- | ---------------------- | -------------------- | ------------------ |
| Debug        | `--build=debug`   | Yes                    | Insert checks        | No checks (proven) |
| Release      | `--build=release` | Yes                    | Skip checks          | No checks (proven) |
| Unsafe       | `--verify=none`   | No                     | Skip checks          | Skip checks        |
| Verification | `--verify=static` | Yes (required)         | Error E11-056        | No checks (proven) |

[22] The default mode when no flags are provided is Debug (conservative, safe).

#### §11.8.8 Verification Mode and Type Signatures [contract.verification.types]

[23] Verification modes are metadata and do not affect procedure types. Two procedures with identical sequents but different verification modes have identical types and are interchangeable for type checking purposes.

**Example 12.8.8.1 (Verification mode does not affect types)**:

```cursive
[[verify(static)]]
procedure strict_add(a: i32, b: i32): i32
    [[ |- a > 0, b > 0 => result > a ]]
{ result a + b }

[[verify(dynamic)]]
procedure checked_add(a: i32, b: i32): i32
    [[ |- a > 0, b > 0 => result > a ]]
{ result a + b }

// Both have type: (i32, i32) -> i32 ! ∅ [[ |- a > 0, b > 0 => result > a ]]
// Type equivalence: strict_add ≡ checked_add
```

#### §11.8.9 Dynamic Hooks to Witness System [contract.verification.witness]

[24] When dynamic verification is enabled, the compiler may generate _witness hooks_: runtime evidence that contracts are satisfied. Witnesses integrate with the witness system (Clause 12) for dynamic polymorphism.

[25] Witness hooks capture:

- Successful precondition validation (proves caller met obligations)
- Successful postcondition validation (proves callee met guarantees)
- Contract satisfaction evidence for polymorphic dispatch

[26] The witness system specification (Clause 12) defines how runtime evidence is represented, stored, and used for dynamic dispatch. The contract system provides the verification points where witnesses are generated. Complete witness integration semantics are specified in Clause 12 [witness].

#### §11.8.10 Constraints [contract.verification.constraints]

[1] _Attribute placement._ The `[[verify(...)]]` attribute shall appear directly before the procedure declaration it modifies. Placing it elsewhere produces diagnostic E11-080.

[2] _Mode validity._ The verification mode shall be one of: `static`, `dynamic`, `trusted`. Invalid modes produce diagnostic E11-081.

[3] _Static verification requirement._ When mode is `static`, all contracts in the procedure must be provable at compile time. Unprovable contracts in static mode produce diagnostic E11-056.

[4] _Trusted safety obligation._ When mode is `trusted`, the programmer assumes responsibility for contract satisfaction. Violating contracts in trusted mode may produce undefined behavior if the violation affects memory safety.

[5] _Build flag validity._ The compiler flags `--build=debug`, `--build=release`, and `--verify=none` are implementation-defined but shall follow the semantics in Table 11.3.

#### §11.8.11 Examples [contract.verification.examples]

**Example 12.8.11.1 (All verification modes)**:

```cursive
// Static mode: Must prove or fail compilation
[[verify(static)]]
procedure proven_square(x: i32): i32
    [[ |- x >= 0, x <= 46340 => result >= 0 ]]
{
    result x * x  // Provable: non-negative * non-negative ≥ 0
}

// Dynamic mode: Always insert checks
[[verify(dynamic)]]
procedure runtime_checked(value: i32): i32
    [[ |- value > 0 => result > value ]]
{
    result value + 1  // Check inserted even if provable
}

// Trusted mode: No verification
[[verify(trusted)]]
procedure performance_critical(data: [i32]): i32
    [[ |- data.len() > 0 => result >= 0 ]]
{
    // Programmer ensures contract; no checks inserted
    result data[0]
}

// Default mode: Build-dependent
procedure normal_procedure(x: i32): i32
    [[ |- x > 0 => result > x ]]
{
    result x + 1
    // Debug build: Insert check
    // Release build: Proven statically, no check
}
```

**Example 12.8.11.2 (Build-mode behavior)**:

```cursive
procedure compute(input: i32): i32
    [[ |- input != 0 => result != 0 ]]
{
    result input * 2
}

// Debug build (--build=debug):
// Inserts: if !(input != 0) { panic!("precondition violated") }
// Inserts: if !(result != 0) { panic!("postcondition violated") }

// Release build (--build=release):
// Static proof: input != 0 ⇒ input * 2 != 0 ✅
// No checks inserted (proven)

// Unsafe mode (--verify=none):
// No checks inserted (all contracts trusted)
```

#### §11.8.12 Diagnostics [contract.verification.diagnostics]

[6] Verification mode diagnostics:

| Code    | Condition                                              | Constraint |
| ------- | ------------------------------------------------------ | ---------- |
| E11-056 | Static verification failed (mode=static)               | [3]        |
| E11-080 | verify attribute misplaced (not before procedure)      | [1]        |
| E11-081 | Invalid verification mode (not static/dynamic/trusted) | [2]        |

#### §11.8.13 Conformance Requirements [contract.verification.requirements]

[7] Implementations shall:

1. Support three explicit verification modes: static, dynamic, trusted
2. Provide build-mode-dependent defaults per Table 11.3
3. Parse and apply `[[verify(mode)]]` attributes on procedures
4. Enforce static verification requirements: prove or reject in static mode
5. Insert runtime checks in dynamic mode for all contracts
6. Skip verification in trusted mode
7. Apply build-mode defaults when no explicit mode is specified
8. Ensure verification modes do not affect type signatures
9. Generate witness hooks when dynamic verification is enabled
10. Emit diagnostics E11-056, E11-080, E11-081 for mode violations
11. Document build flags and their verification behavior


### §11.9 Grammar Reference [contract.grammar]

[1] This subsection consolidates grammar cross-references for the contract system. All grammar productions are normatively defined in Annex A.

- Sequent syntax: Annex A §A.7 [grammar.sequent]
- Grant syntax: Annex A §A.9 [grammar.grant]
- Predicate expressions: Annex A §A.8 [grammar.assertion]

[2] For sequent formation rules and semantic interpretation, see §11.2 [contract.sequent].

#### §11.9.1 Complete Example [contract.grammar.example]

**Example 11.9.1.1 (All grammar elements)**:

```cursive
// Grant declaration
public grant database_modify

// Contract with sequents
public contract Repository<T: Serializable> {
    type Storage = string@View

    procedure save(~, item: T): Self::Storage \/ Error
        [[ database_modify, alloc::heap |- true => true ]]

    procedure load(data: Self::Storage): T \/ Error
        [[ alloc::heap |- data.len() > 0 => true ]]
}

// Type with invariant implementing contract
record UserRepository: Repository<User> {
    data: [User],

    where {
        data.len() <= 10_000
    }

    type Storage = string@Managed

    procedure save(~, item: User): string@Managed \/ Error
        [[
            database_modify,
            alloc::heap
            |-
            item.id > 0
            =>
            match result {
                storage: string@Managed => storage.len() > 0,
                _: Error => true
            }
        ]]
    {
        // Implementation
    }

    procedure load(data: string@Managed): User \/ Error
        [[ alloc::heap |- data.len() > 0 => true ]]
    {
        // Implementation
    }
}

// Procedure using all features
[[verify(static)]]
procedure process_users(repo: unique UserRepository, count: usize)
    [[
        database_modify,
        alloc::heap
        |-
        count > 0,
        count <= 100
        =>
        repo.data.len() >= @old(repo.data.len())
    ]]
    where count <= 100  // Type invariant ensures this
{
    var i: usize = 0
    loop i < count where { i >= 0, i <= count } {
        let user = create_user(i)
        match repo.save(user) {
            _: string@Managed => { },
            err: Error => { panic("Save failed") }
        }
        i = i + 1
    }
}
```


### §11.10 Conformance and Diagnostics [contract.diagnostics]

#### §11.10.1 Overview

[1] This subclause consolidates conformance requirements for the contract system, provides the complete diagnostic code catalog for Clause 11, and specifies integration requirements with other language subsystems.

[2] Conforming implementations shall satisfy all requirements enumerated in §§11.1-11.9 and shall emit the diagnostics defined in this subclause when contract violations occur.

#### §11.10.2 Consolidated Conformance Requirements [contract.diagnostics.conformance]

[3] A conforming implementation of the contract system shall:

**Sequent Support** (§11.2):

1. Parse contractual sequents with semantic brackets `⟦ ⟧` or `[[ ]]`
2. Support complete sequent form: `[[ grants |- must => will ]]`
3. Apply smart defaulting rules for abbreviated forms
4. Recognize turnstile `⊢`/`|-` and implication `⇒`/`=>`
5. Desugar abbreviated sequents deterministically to canonical form

**Grant System** (§11.3): 6. Provide all built-in grants enumerated in §11.3.3 7. Support user-defined grants declared via §4.9 8. Enforce grant visibility rules (public/internal/private) 9. Perform grant checking at call sites using subset inclusion 10. Reject wildcard grant syntax; require explicit grant lists 11. Support grant parameters with substitution and bounds

**Preconditions** (§11.4): 12. Parse must clauses as boolean predicates 13. Enforce caller obligations at call sites 14. Perform static verification when provable 15. Insert dynamic checks when verification mode requires 16. Support flow-sensitive precondition proof

**Postconditions** (§11.5): 17. Parse will clauses with `result` and `@old` support 18. Implement `@old(expression)` operator capturing pre-state 19. Verify postconditions on all non-diverging return paths 20. Insert dynamic checks per verification mode 21. Support multiple independent @old captures

**Invariants** (§11.6): 22. Parse `where` clauses on types and loops 23. Desugar type invariants to postcondition conjunctions 24. Desugar loop invariants to verification points 25. Automatically check invariants at construction and mutation 26. Maintain unified `where` terminology across all contexts

**Checking Flow** (§11.7): 27. Implement grant availability checking algorithm 28. Implement precondition obligation verification 29. Implement postcondition guarantee checking 30. Support compositional verification using callee contracts 31. Integrate with definite assignment analysis

**Verification Modes** (§11.8): 32. Support static, dynamic, trusted modes via attributes 33. Provide build-mode-dependent defaults 34. Enforce static verification requirements (prove or reject) 35. Insert runtime checks in dynamic mode 36. Skip checks in trusted mode 37. Generate witness hooks for dynamic verification

**Grammar** (§11.9): 38. Implement sequent, grant, and predicate grammars per Annex A 39. Support contract declarations with no procedure bodies 40. Integrate contracts with behavior system (Clause 9)

#### §11.10.3 Complete Diagnostic Catalog [contract.diagnostics.catalog]

[4] [Note: All diagnostic codes defined in Clause 11 are cataloged in Annex E §E.5.1.11. — end note]

#### §11.10.4 Diagnostic Payload Requirements [contract.diagnostics.payloads]

[5] Contract diagnostics shall follow payload schemas in Annex E §E.5.3, with the following required fields:

- **Grant diagnostics**: grant identifier, required/available sets
- **Precondition diagnostics**: expression, substituted arguments, violation context
- **Postcondition diagnostics**: expression, result value, @old captures
- **Invariant diagnostics**: expression, violated field or state, construction/mutation site

#### §11.10.5 Integration Summary [contract.diagnostics.integration]

[6] The contract system integrates with the following language subsystems:

**Declarations (Clause 5)**:

- Contractual sequents attach to procedures (§5.4)
- Grant declarations introduce capability tokens (§5.9)
- Contract declarations are type-like bindings

**Type System (Clause 7)**:

- Callable types include grant sets and sequents (§7.4)
- Contract bounds on generic parameters (§7.x)
- Subtyping respects sequent variance

**Expressions (Clause 8)**:

- Grant accumulation through expressions (§8.1.5)
- Predicate expressions type-checked as bool
- result and @old special identifiers

**Generics (Clause 10)**:

- Grant parameters for grant polymorphism (§10.2.5)
- Grant bounds in where clauses (§10.3.7)
- Contract vs behavior distinction (§10.4.1.2)

**Memory Model (Clause 11)**:

- Grant tracking for allocation operations
- Integration with RAII and cleanup
- Permissions orthogonal to contracts

**Witness System (Clause 13)**:

- Dynamic verification generates witnesses
- Polymorphic dispatch via contract witnesses
- Runtime evidence of contract satisfaction

#### §11.10.6 Complete Example [contract.diagnostics.example]

**Example 12.10.6.1 (Comprehensive contract usage)**:

```cursive
// User-defined grants
public grant ledger_read
public grant ledger_write

// Contract declaration
public contract Auditable {
    type AuditLog = string@View

    procedure audit_read(~): Self::AuditLog
        [[ ledger_read |- true => result.len() > 0 ]]

    procedure audit_write(~, entry: Self::AuditLog)
        [[ ledger_write |- entry.len() > 0 => true ]]
}

// Type with invariant implementing contract
record BankAccount: Auditable {
    balance: i64,
    transactions: [Transaction],

    where {
        balance >= 0,
        transactions.len() <= 10_000
    }

    type AuditLog = string@Managed

    procedure audit_read(~): string@Managed
        [[ ledger_read, alloc::heap |- true => result.len() > 0 ]]
    {
        result string.from("audit log")
    }

    procedure audit_write(~, entry: string@Managed)
        [[ ledger_write |- entry.len() > 0 => true ]]
    {
        // Log to audit system
    }

    [[verify(static)]]
    procedure deposit(~!, amount: i64)
        [[
            ledger_write
            |-
            amount > 0
            =>
            self.balance == @old(self.balance) + amount,
            self.balance >= amount
        ]]
    {
        self.balance += amount
        self.audit_write(string.from("deposit"))
        // Invariant automatically checked: balance >= 0, transactions.len() <= 10_000
    }

    [[verify(dynamic)]]
    procedure withdraw(~!, amount: i64): () \/ InsufficientFunds
        [[
            ledger_write
            |-
            amount > 0
            =>
            match result {
                _: () => self.balance == @old(self.balance) - amount,
                _: InsufficientFunds => self.balance == @old(self.balance)
            }
        ]]
    {
        if self.balance >= amount {
            self.balance -= amount
            self.audit_write(string.from("withdrawal"))
            result ()
        } else {
            result InsufficientFunds { requested: amount, available: self.balance }
        }
    }
}

// Grant-polymorphic procedure using contract bound
procedure process_auditable<T, ε>(item: unique T)
    [[
        ε,
        alloc::heap
        |-
        true
        =>
        true
    ]]
    where T: Auditable,
          ε ⊆ {ledger_read, ledger_write}
{
    let log = item.audit_read()
    println("Audit: {}", log)
}
```

#### §11.10.7 Diagnostic Code Summary [contract.diagnostics.summary]

[4] Clause 11 defines diagnostic codes E11-001 through E11-091 covering:

- **Syntax** (001-010): Sequent structure and formatting
- **Grants** (020-032): Grant availability and visibility
- **Preconditions** (040-044): Must clause requirements
- **Postconditions** (050-056): Will clause and @old operator
- **Invariants** (060-069): Where clauses and checking
- **Flow/Verification** (070-091): Checking and verification modes

[5] All diagnostics shall be registered in Annex E §E.5 with:

- Canonical code (E11-[NNN])
- Section reference
- Description
- Severity (all E for Error in current version)
- Structured payload schema

#### §11.10.8 Future Extensions [contract.diagnostics.future]

[6] Future editions of this specification may introduce:

- Quantified predicates (`forall`, `exists`) with verification support
- Contract derivation (automatic contract implementation)
- Refinement types (contracts in type expressions)
- Temporal operators beyond `@old` (e.g., `@eventually`, `@always`)
- Frame conditions (explicit specification of unchanged state)

[7] Such extensions shall be designed to maintain backward compatibility with existing contracts or shall be introduced in new major versions per §1.7 [intro.versioning].

#### §11.10.9 Conformance Testing [contract.diagnostics.testing]

[8] Conformance test suites should verify:

- All smart defaulting forms parse correctly
- Grant checking rejects missing grants
- Precondition violations are detected (statically or dynamically)
- Postcondition violations are detected
- Invariants are checked at all required points
- Verification modes behave as specified
- Contract/behavior distinction is enforced
- All diagnostic codes are emitted for corresponding violations

[9] Test coverage shall include positive cases (valid contracts) and negative cases (each diagnostic code triggered).

#### §11.10.10 Conformance Requirements [contract.diagnostics.requirements]

[10] Implementations claiming conformance to Clause 11 shall:

1. Satisfy all requirements in §11.10.2
2. Emit all diagnostics defined in §11.10.3
3. Provide structured diagnostic payloads per Annex E §E.5.3
4. Integrate contracts with all systems listed in §11.10.5
5. Support the complete grammar in §11.9 and Annex A
6. Document build flags and verification behavior
7. Maintain contract metadata for reflection and tooling
8. Pass conformance tests per §11.10.8


### §12.1 Overview and Purpose [witness.overview]

#### §12.1.1 Overview

[1] The _witness system_ provides runtime evidence of type-level properties, enabling dynamic polymorphism and runtime verification as an explicit opt-in feature. A witness is a dense pointer (multi-component pointer) that packages a value with proof of a property: behavior implementation, contract satisfaction, or modal state membership. The witness system integrates behaviors (Clause 9), contracts (Clause 11), and modal types (§6.6) into a unified runtime evidence mechanism. Static dispatch through monomorphization remains the zero-cost default; witnesses are an explicit opt-in for scenarios requiring runtime flexibility.

#### §12.1.2 Static vs Dynamic Verification [witness.overview.static]

[2] Cursive provides two verification strategies for type-level properties:

**Static verification** (default, zero-cost):

- Behavior implementation: Generic bounds `<T: Display>`
- Contract satisfaction: Generic bounds `<T: Serializable>`
- Modal states: Type system tracking `FileHandle@Open`
- Compile-time proof, monomorphization, no runtime overhead

**Dynamic verification** (opt-in, explicit cost):

- Behavior implementation: Witness type `witness<Display>`
- Contract satisfaction: Witness type `witness<Serializable>`
- Modal states: Witness type `witness<FileHandle@Open>`
- Runtime evidence via dense pointers, vtable dispatch, small overhead

[2] Table 12.1 compares the two strategies:

**Table 12.1 — Static vs dynamic verification**

| Aspect      | Static (Monomorphization)   | Dynamic (Witnesses)                  |
| ----------- | --------------------------- | ------------------------------------ |
| Syntax      | Generic bounds `<T: B>`     | Witness type `witness<B>`            |
| Type check  | Compile-time                | Runtime                              |
| Dispatch    | Direct call (inlined)       | Vtable indirect call                 |
| Memory      | Zero overhead               | 16 bytes per witness (dense pointer) |
| Flexibility | Homogeneous collections     | Heterogeneous collections            |
| Cost        | Zero                        | Small (one indirection)              |
| Use when    | Types known at compile time | Types determined at runtime          |

[3] The witness system makes the cost of dynamic dispatch **explicit**: the `witness<B>` type in signatures clearly indicates runtime polymorphism.

#### §12.1.3 Witness as Modal Type [witness.overview.modal]

[4] The `witness` type is a built-in modal type with three allocation states:

```cursive
modal witness<B> {
    @Stack   // Non-responsible reference to stack value
    @Region  // Responsible region-allocated value
    @Heap    // Responsible heap-allocated value
}
```

[5] Default: `witness<B>` without state annotation means `witness<B>@Stack` (conservative, local reference). Allocation states determine cleanup responsibility:

- `@Stack`: Non-responsible binding (like `let x <- value`), does not call destructor
- `@Region`: Responsible binding (like `let x = move value`), calls destructor at region exit
- `@Heap`: Responsible binding (like `let x = move value`), calls destructor at scope exit

[6] Transitions between states follow the chain: `@Stack → @Region → @Heap`, each transition requiring explicit method calls and appropriate grants.

#### §12.1.4 Dense Pointer Representation [witness.overview.representation]

[7] Witnesses use _dense pointer_ representation: a multi-component pointer containing both data and metadata. Dense pointers contrast with _sparse pointers_ (single-component pointers like `Ptr<T>`). A witness value contains:

```
witness<B> = {
    data_ptr: Ptr<T>,            // Pointer to concrete value (8 bytes)
    metadata: Ptr<WitnessTable>  // Pointer to witness metadata (8 bytes)
}

WitnessTable = {
    type_id: TypeId,                // Runtime type identification
    state_tag: Option<StateTag>,    // For modal witnesses
    vtable: [fn(*const ()) -> ...], // Method dispatch table
    drop: Option<fn(*mut ())>       // Destructor function
}
```

[8] Total size: 16 bytes on 64-bit platforms. The dense pointer representation enables type-safe dynamic dispatch with minimal overhead.

#### §12.1.5 Unified Witness Concept [witness.overview.unified]

[9] The witness system provides a **unified mechanism** for runtime evidence of different type-level properties:

**Behavior witnesses** (`witness<Display>`):

- Runtime evidence that a value satisfies behavior Display
- VTable contains pointers to behavior procedure implementations
- Enables heterogeneous collections of different types with common behavior

**Contract witnesses** (`witness<Serializable>`):

- Runtime evidence that a value satisfies contract Serializable
- VTable contains pointers to contract procedure implementations
- Same representation as behavior witnesses (behaviors and contracts distinguished at compile time)

**Modal state witnesses** (`witness<FileHandle@Open>`):

- Runtime evidence that a modal value is in state @Open
- State tag stored in witness metadata
- Enables dynamic state tracking when compile-time tracking insufficient

[10] All witness kinds use the same dense pointer representation and dispatch mechanism. The property in angle brackets (`<Display>`, `<Serializable>`, `<FileHandle@Open>`) determines what is being witnessed.

#### §12.1.6 Design Philosophy [witness.overview.philosophy]

[11] The witness system embodies Cursive's design principles (§1.9): explicit over implicit (dynamic dispatch is opt-in via explicit `witness<B>` types), zero-cost abstraction default (static dispatch is default), and local reasoning (witness types show complete dispatch strategy).

#### §12.1.7 Conformance Requirements [witness.overview.requirements]

[12] Implementations shall maintain witness as opt-in feature with zero cost when unused, and integrate witness cleanup responsibility with RAII (§10.2).


### §12.2 Witness Kinds [witness.kind]

#### §12.2.1 Overview

[1] Witnesses provide runtime evidence for three categories of type-level properties: behavior implementations, contract satisfactions, and modal state memberships. While all witness kinds use the same dense pointer representation and share common mechanisms, they differ in what property is being witnessed and how dispatch semantics operate.

[2] This subclause classifies witness kinds, specifies their semantic differences, and provides examples distinguishing their use cases. The classification is semantic (for documentation and understanding); all witnesses use the unified `witness<Property>` type system.

#### §12.2.2 Behavior Witnesses [witness.kind.behavior]

##### §12.2.2.1 Definition

[3] A _behavior witness_ provides runtime evidence that a value implements a behavior (§10.4). The witness type `witness<B>` where `B` is a behavior identifier packages a value with its behavior implementation vtable.

##### §12.2.2.2 Purpose

[4] Behavior witnesses enable:

- **Heterogeneous collections**: Arrays/lists containing different types sharing a behavior
- **Plugin systems**: Loading types at runtime that implement known behaviors
- **Dynamic dispatch**: Calling behavior procedures without knowing concrete type
- **Type erasure**: Hiding implementation details behind behavior interface

##### §12.2.2.3 Example

**Example 13.2.2.1 (Behavior witness)**:

```cursive
behavior Display {
    procedure show(~): string@View
    { result "Display" }
}

record Point with Display {
    x: f64,
    y: f64,

    procedure show(~): string@View
    { result "Point" }
}

record Circle with Display {
    radius: f64,

    procedure show(~): string@View
    { result "Circle" }
}

// Create behavior witnesses
let point = Point { x: 1.0, y: 2.0 }
let circle = Circle { radius: 5.0 }

let w1: witness<Display> = point    // Witness of Point implementing Display
let w2: witness<Display> = circle   // Witness of Circle implementing Display

// Heterogeneous collection
let shapes: [witness<Display>] = [w1, w2]

// Dynamic dispatch
loop shape: witness<Display> in shapes {
    println("{}", shape::show())  // Runtime dispatch to concrete implementation
}
```

#### §12.2.3 Contract Witnesses [witness.kind.contract]

##### §12.2.3.1 Definition

[5] A _contract witness_ provides runtime evidence that a value satisfies a contract (Clause 12). The witness type `witness<C>` where `C` is a contract identifier packages a value with its contract implementation vtable.

##### §12.2.3.2 Distinction from Behavior Witnesses

[6] Contract witnesses and behavior witnesses use identical runtime representation and dispatch mechanisms. The distinction is semantic only:

- **Behaviors** provide concrete default implementations (§10.4)
- **Contracts** specify abstract requirements (Clause 12)

[7] At runtime, both compile to vtables. A witness for a contract points to the type's implementation of the contract's required procedures.

##### §12.2.3.3 Example

**Example 13.2.3.1 (Contract witness)**:

```cursive
public contract Serializable {
    procedure serialize(~): string@Managed
        [[ alloc::heap |- true => result.len() > 0 ]]

    procedure deserialize(data: string@Managed): Self \/ ParseError
        [[ alloc::heap |- data.len() > 0 => true ]]
}

record User: Serializable {
    id: u64,
    name: string@Managed,

    procedure serialize(~): string@Managed
        [[ alloc::heap |- true => result.len() > 0 ]]
    { }

    procedure deserialize(data: string@Managed): Self \/ ParseError
        [[ alloc::heap |- data.len() > 0 => true ]]
    { }
}

// Create contract witness
let user = User { id: 1, name: string.from("Alice") }
let w: witness<Serializable> = user

// Dynamic dispatch to contract methods
let serialized = w::serialize()
```

#### §12.2.4 Modal State Witnesses [witness.kind.modal]

##### §12.2.4.1 Definition

[8] A _modal state witness_ provides runtime evidence that a modal value is in a specific state. The witness type `witness<T@State>` where `T` is a modal type and `@State` is a state identifier packages a value with runtime state verification.

##### §12.2.4.2 Purpose

[9] Modal state witnesses enable dynamic state tracking when compile-time state tracking is insufficient:

- **Deserialization**: Loading modal values from external sources with unknown states
- **Network protocols**: Receiving stateful values over network
- **Dynamic state machines**: State determined by runtime conditions
- **Plugin boundaries**: External code providing values in specific states

[10] **Static vs dynamic modal verification**:

**Static** (default, zero-cost):

```cursive
let file: FileHandle@Open = get_file()
// Type system proves file is @Open
// Zero runtime overhead
```

**Dynamic** (opt-in, runtime checking):

```cursive
let file_witness: witness<FileHandle@Open> = file
// Runtime state tag verifies file is @Open
// State checked dynamically
```

##### §12.2.4.3 Example

**Example 13.2.4.1 (Modal state witness)**:

```cursive
modal Connection {
    @Disconnected
    @Connected { socket: Socket }
}

// Static mode: Type system tracks state
let conn: Connection@Connected = establish_connection()
conn::send(data)  // Type system verifies @Connected

// Dynamic mode: Runtime state checking
procedure handle_connection(conn: witness<Connection@Connected>)
    [[ net::send |- true => true ]]
{
    conn::send(data)  // Runtime verifies state is @Connected before send
}

// Use case: State determined at runtime
let conn: Connection = load_from_config()  // State unknown at compile time

match conn {
    @Connected => {
        let w: witness<Connection@Connected> = conn
        handle_connection(w)
    }
    @Disconnected => {
        println("Not connected")
    }
}
```

#### §12.2.5 Witness Kind Classification [witness.kind.classification]

[11] Table 13.2 summarizes witness kind properties:

**Table 13.2 — Witness kind properties**

| Witness Kind | Syntax                     | What It Proves                  | VTable Contains           | State Tag |
| ------------ | -------------------------- | ------------------------------- | ------------------------- | --------- |
| Behavior     | `witness<Display>`         | Implements behavior Display     | Behavior procedures       | None      |
| Contract     | `witness<Serializable>`    | Satisfies contract Serializable | Contract procedures       | None      |
| Modal State  | `witness<FileHandle@Open>` | Is in state @Open               | State-specific procedures | @Open     |

[12] Despite these semantic differences, all use the unified witness type system with the same representation and construction mechanisms.

#### §12.2.6 When to Use Each Kind [witness.kind.usage]

**Behavior witnesses**:
[13] Use when you need heterogeneous collections of types sharing a behavior or when concrete types are determined at runtime (plugins, dynamic loading).

**Contract witnesses**:
[14] Use when you need dynamic polymorphism over contract-satisfying types, particularly for plugin systems with abstract interfaces defined by contracts.

**Modal state witnesses**:
[15] Use when modal states are determined at runtime (deserialization, network protocols, configuration-driven state machines) rather than tracked statically by the type system.

**Static verification preferred**:
[16] When types and states are known at compile time, use generic bounds (`<T: B>`) and type annotations (`T@State`) instead of witnesses. Static verification is zero-cost and should be the default.

#### §12.2.7 Conformance Requirements [witness.kind.requirements]

[17] Implementations shall:

1. Support all three witness kinds with unified `witness<Property>` syntax
2. Use identical dense pointer representation for all witness kinds
3. Compile behavior implementations to vtable entries for behavior witnesses
4. Compile contract implementations to vtable entries for contract witnesses
5. Track modal state tags for modal state witnesses
6. Distinguish witness kinds semantically while maintaining unified implementation
7. Maintain type safety for all witness operations regardless of kind
8. Document when each witness kind is appropriate vs static verification


### §12.3 Formation and Construction [witness.formation]

#### §12.3.1 Overview

[1] Witness construction creates dense pointer values from concrete types that satisfy behaviors, satisfy contracts, or inhabit modal states. Construction is type-driven: witness types in annotations trigger automatic coercion from concrete values to witness values.

[2] This subclause specifies witness formation rules, construction semantics for each allocation state, cleanup responsibility, grant requirements, and the explicit `move` requirement for responsible witnesses.

#### §12.3.2 Witness Type Formation [witness.formation.types]

##### §12.3.2.1 Syntax

[3] Witness types follow the modal type syntax (§7.6) with the property in angle brackets:

**Witness types** match the pattern:
```
"witness" "<" <witness_property> ">" [ <witness_allocation_state> ]
```

where **witness properties** take one of the following forms:
```
<behavior_identifier>
<contract_identifier>
<type_identifier> "@" <state_identifier>
```

and **witness allocation states** match the pattern:
```
"@" ( "Stack" | "Region" | "Heap" )
```

[4] Allocation state is optional; omitted state defaults to `@Stack`.

**Example 13.3.2.1 (Witness type forms)**:

```cursive
witness<Display>                     // Defaults to witness<Display>@Stack
witness<Display>@Stack               // Explicit stack allocation
witness<Display>@Region              // Region allocation
witness<Display>@Heap                // Heap allocation

witness<Serializable>                // Contract witness, defaults to @Stack
witness<FileHandle@Open>             // Modal state witness, defaults to @Stack
witness<FileHandle@Open>@Heap        // Modal state witness, heap allocated
```

##### §12.3.2.2 Well-Formedness

[5] A witness type is well-formed when:

$$
\frac{\Gamma \vdash B : \text{Behavior} \quad S \in \{\text{@Stack}, \text{@Region}, \text{@Heap}\}}
     {\Gamma \vdash \texttt{witness}\langle B \rangle@S : \text{Type}}
\tag{WF-Witness-Behavior}
$$

$$
\frac{\Gamma \vdash C : \text{Contract} \quad S \in \{\text{@Stack}, \text{@Region}, \text{@Heap}\}}
     {\Gamma \vdash \texttt{witness}\langle C \rangle@S : \text{Type}}
\tag{WF-Witness-Contract}
$$

$$
\frac{\Gamma \vdash T@State : \text{Type} \quad S \in \{\text{@Stack}, \text{@Region}, \text{@Heap}\}}
     {\Gamma \vdash \texttt{witness}\langle T@State \rangle@S : \text{Type}}
\tag{WF-Witness-Modal}
$$

[6] The property (`B`, `C`, or `T@State`) must be visible and well-formed in the current context.

#### §12.3.3 Witness Construction [witness.formation.construction]

##### §12.3.3.1 Automatic Coercion

[7] Witness construction occurs via automatic coercion when a value is assigned to a witness-typed binding:

$$
\frac{\Gamma \vdash v : T \quad \Gamma \vdash T : B \quad \text{target type: } \texttt{witness}\langle B \rangle@S}
     {\text{Coerce } v \text{ to } \texttt{witness}\langle B \rangle@S}
\tag{Coerce-Witness}
$$

[8] The coercion creates a dense pointer containing the value and its behavior/contract vtable or modal state tag.

**Example 13.3.3.1 (Automatic witness construction)**:

```cursive
let point = Point { x: 1.0, y: 2.0 }

// Type annotation triggers coercion
let w: witness<Display> = point
// Compiler inserts witness construction automatically
```

##### §12.3.3.2 Stack Witness Construction (Non-Responsible)

[9] Stack witnesses (`@Stack`) are non-responsible bindings. They reference the original value without transferring cleanup responsibility. No `move` keyword is required.

**Construction rule**:

[ Given: Value $v$ of type $T$ where $T : B$ ]

$$
\frac{\Gamma \vdash v : T \quad T : B}
     {\texttt{let } w : \texttt{witness}\langle B \rangle@\texttt{Stack} = v \text{ creates non-responsible witness}}
\tag{E-Witness-Stack}
$$

[10] The original binding remains valid and retains cleanup responsibility. The stack witness becomes invalid when the original binding goes out of scope.

**Example 13.3.3.2 (Stack witness - non-responsible)**:

```cursive
procedure demo()
    [[ io::write |- true => true ]]
{
    let shape = Point { x: 1.0, y: 2.0 }

    let w: witness<Display>@Stack = shape
    // No move needed
    // shape is still valid

    shape::show()  // ✅ OK: shape not moved
    w::show()      // ✅ OK: witness references shape

    // At scope exit: shape's destructor called
    //                w becomes invalid (non-responsible)
}
```

##### §12.3.3.3 Heap Witness Construction (Responsible)

[11] Heap witnesses (`@Heap`) are responsible bindings. They take cleanup responsibility from the source value via explicit `move`. The witness allocates heap storage and becomes responsible for calling the destructor.

**Construction rule**:

[ Given: Value $v$ of type $T$ where $T : B$ ]

$$
\frac{\Gamma \vdash v : T \quad T : B \quad v \text{ transferable}}
     {\texttt{let } w : \texttt{witness}\langle B \rangle@\texttt{Heap} = \texttt{move } v}
\tag{E-Witness-Heap}
$$

[12] Omitting `move` for heap witness construction produces diagnostic E13-010 (missing move for responsible witness). After construction, the source binding is invalid (moved).

[13] **Grant requirement**: Heap witness construction requires `alloc::heap` grant in the procedure's sequent.

**Example 13.3.3.3 (Heap witness - responsible)**:

```cursive
procedure create_heap_witness(): witness<Display>@Heap
    [[ alloc::heap |- true => true ]]
{
    let shape = Circle { radius: 5.0 }

    let w: witness<Display>@Heap = move shape  // Explicit move required
    // shape is now invalid (moved)
    // shape::show()  // ❌ ERROR: use of moved value

    result w  // Witness escapes scope (heap allocation)
}
// Caller receives responsible witness
// Caller's scope exit calls destructor
```

##### §12.3.3.4 Region Witness Construction (Responsible)

[14] Region witnesses (`@Region`) are responsible bindings allocated in the active region. They require explicit `move` and the `alloc::region` grant. The witness is destroyed when the region exits.

**Construction rule**:

[ Given: Value $v$ in active region $r$ ]

$$
\frac{\Gamma \vdash v : T \quad T : B \quad v \text{ transferable} \quad r \text{ active}}
     {\texttt{let } w : \texttt{witness}\langle B \rangle@\texttt{Region} = \texttt{move } v}
\tag{E-Witness-Region}
$$

[15] Region witnesses cannot escape their region. Attempting to return or store a region witness outside its region produces diagnostic E13-011 (witness escape violation), consistent with region escape analysis (§11.3.3).

**Example 13.3.3.4 (Region witness - responsible)**:

```cursive
procedure process_in_region()
    [[ alloc::region, io::write |- true => true ]]
{
    region temp {
        let shape = Rectangle { width: 10.0, height: 5.0 }

        let w: witness<Display>@Region = move shape  // Explicit move
        // shape is invalid

        w::show()  // OK within region

        // return w  // ❌ ERROR E13-011: witness escapes region
    }
    // Region exit: w destroyed
}
```

#### §12.3.4 Witness Construction from Different Source Types [witness.formation.sources]

##### §12.3.4.1 From Owned Values

[16] Responsible witnesses can be created from owned values (bindings created with `=`):

```cursive
let value = Type::new()
let w: witness<B>@Heap = move value  // Takes responsibility
```

##### §12.3.4.2 From Non-Responsible Bindings

[17] Stack witnesses can reference non-responsible bindings:

```cursive
let owner = Type::new()
let ref <- owner  // Non-responsible binding

let w: witness<B>@Stack = ref  // Stack witness references ref
// Both ref and w are non-responsible
// owner retains responsibility
```

[18] Heap/region witnesses cannot be created from non-responsible bindings because non-responsible bindings cannot transfer responsibility (§11.5.2.3). Attempting to move from non-responsible bindings produces diagnostic E11-502.

**Example 13.3.4.1 (Witness from non-responsible binding)**:

```cursive
let data = Buffer::new()
let view <- data  // Non-responsible

let w1: witness<Display>@Stack = view  // ✅ OK: stack witness
// let w2: witness<Display>@Heap = move view  // ❌ E11-502: cannot move non-responsible
```

#### §12.3.5 Permission Inheritance [witness.formation.permissions]

[19] Witnesses inherit the permission of the underlying value:

$$
\frac{v : \texttt{perm } T \quad \texttt{witness}\langle B \rangle@S \text{ from } v}
     {\texttt{witness}\langle B \rangle@S \text{ has permission perm}}
\tag{Witness-Permission-Inherit}
$$

[20] Permission qualifiers (const, unique, shared) attach to the witness type, not the witness itself:

**Example 13.3.5.1 (Permission inheritance)**:

```cursive
let point: unique Point = Point::new()
let w: unique witness<Display> = point
// Witness has unique permission (inherited from point)

w::mutate()  // ✅ OK if Display has mutating methods

let const_point: const Point = get_point()
let cw: const witness<Display> = const_point
// Witness has const permission
// cw::mutate()  // ❌ ERROR: const permission
```

#### §12.3.6 Constraints [witness.formation.constraints]

[1] _Satisfaction requirement._ The source value's type must satisfy the behavior, satisfy the contract, or be in the modal state specified by the witness property. Violations produce diagnostic E13-001.

[2] _Move requirement for responsible witnesses._ Creating `@Heap` or `@Region` witnesses requires explicit `move` keyword. Omitting `move` produces diagnostic E13-010.

[3] _Non-responsible limitation._ Stack witnesses may reference non-responsible bindings. Heap/region witnesses require transferable bindings. Attempting to create responsible witnesses from non-responsible bindings produces diagnostic E11-502.

[4] _Grant requirements._ Witness construction requires grants based on allocation state:

- `@Stack`: No grants (references only)
- `@Region`: `alloc::region` grant required
- `@Heap`: `alloc::heap` grant required

[5] _Escape restrictions._ Region witnesses are subject to region escape analysis (§11.3.3). They cannot escape their region. Violations produce diagnostic E13-011.

[6] _Permission compatibility._ The source value's permission must be compatible with the witness type's permission annotation. Permission upgrades are forbidden (§11.4.3).

#### §12.3.7 Diagnostics [witness.formation.diagnostics]

[7] Witness formation diagnostics:

| Code    | Condition                                                   | Constraint |
| ------- | ----------------------------------------------------------- | ---------- |
| E13-001 | Type does not satisfy behavior/satisfy contract/have state  | [1]        |
| E13-010 | Missing `move` for responsible witness (@Heap/@Region)      | [2]        |
| E13-011 | Region witness escapes region                               | [5]        |
| E13-012 | Grant missing for witness construction (alloc::heap/region) | [4]        |

#### §12.3.8 Conformance Requirements [witness.formation.requirements]

[8] Implementations shall:

1. Support automatic witness coercion from implementing types
2. Verify source type implements/satisfies witness property
3. Create non-responsible stack witnesses without `move`
4. Require explicit `move` for heap and region witnesses
5. Enforce grant requirements: @Region needs alloc::region, @Heap needs alloc::heap
6. Apply region escape analysis to region witnesses
7. Inherit permissions from source values to witnesses
8. Track cleanup responsibility per allocation state
9. Invalidate source bindings after move to responsible witnesses
10. Emit diagnostics E13-001, E13-010, E13-011, E13-012 for violations


### §12.4 Representation and Erasure [witness.representation]

#### §12.4.1 Overview

[1] This subclause specifies the memory representation of witness values, the structure of witness tables (vtables and metadata), size and alignment properties, and the conditions under which witnesses can be erased or optimized.

[2] Witnesses use _dense pointer_ representation: a pair of sparse pointers (data pointer and metadata pointer) occupying 16 bytes on 64-bit platforms. The dense pointer enables type-safe dynamic dispatch with minimal overhead.

#### §12.4.2 Dense Pointer Structure [witness.representation.dense]

##### §12.4.2.1 Memory Layout

[3] A witness value has the following memory layout:

```
witness<B>@State = {
    data_ptr: Ptr<T>@Valid,          // 8 bytes: pointer to concrete value
    metadata_ptr: Ptr<WitnessTable>, // 8 bytes: pointer to witness metadata
}
```

[4] **Size and alignment**:

$$
\text{sizeof}(\texttt{witness}\langle B \rangle@S) = 16 \text{ bytes (64-bit platforms)}
$$

$$
\text{alignof}(\texttt{witness}\langle B \rangle@S) = 8 \text{ bytes (pointer alignment)}
$$

[5] On 32-bit platforms: `sizeof(witness<B>) = 8 bytes`, `alignof = 4 bytes`.

[6] Implementations shall document platform-specific witness sizes and ensure they match two-pointer size for the target architecture.

##### §12.4.2.2 Data Pointer

[7] The data pointer references the concrete value. It has type `Ptr<T>@Valid` where `T` is the concrete implementing type (erased from the witness type signature).

[8] **Permission tracking**: The data pointer carries the permission inherited from the source value:

- const witness → `const Ptr<T>`
- unique witness → `unique Ptr<T>`
- shared witness → `shared Ptr<T>`

##### §12.4.2.3 Metadata Pointer

[9] The metadata pointer references a witness table containing type information and dispatch functions. The witness table structure is:

```
WitnessTable = {
    type_id: TypeId,                      // Runtime type identification
    size: usize,                          // Size of concrete type
    align: usize,                         // Alignment of concrete type
    state_tag: Option<StateDiscriminant>, // For modal witnesses
    drop: Option<fn(*mut ())>,           // Destructor (if needed)
    vtable: [ProcedurePtr],              // Method dispatch table
}
```

[10] **VTable entries**: One function pointer per behavior/contract procedure. For modal witnesses, vtable contains state-specific procedures.

[11] **State tag**: Modal witnesses (`witness<T@State>`) store the state discriminant in `state_tag`. Non-modal witnesses have `state_tag = None`.

#### §12.4.3 VTable Structure [witness.representation.vtable]

##### §12.4.3.1 Behavior/Contract VTable

[12] For behavior witness `witness<Display>` where Display has procedures `show` and `debug`:

```
VTable_Display = {
    show: fn(*const ()) -> string@View,
    debug: fn(*const ()) -> string@Managed,
}
```

[13] Each vtable entry is a function pointer with signature matching the behavior procedure's signature, with receiver replaced by sparse pointer `*const ()` (type-erased).

##### §12.4.3.2 Modal State VTable

[14] For modal witness `witness<FileHandle@Open>`:

```
VTable_FileHandle_Open = {
    read: fn(*shared (), buffer: [u8]) -> FileHandle@Open,
    close: fn(*unique ()) -> FileHandle@Closed,
    // Only @Open state procedures
}
```

[15] Modal witness vtables contain only procedures available in the specified state.

#### §12.4.4 Witness Table Sharing [witness.representation.sharing]

[16] Implementations may share witness tables across instances:

- All witnesses of the same concrete type implementing the same behavior share one witness table
- Witness tables are compile-time constants (allocated in static storage)
- Sharing reduces memory overhead for multiple witnesses

[17] **Sharing rule**:

$$
\frac{\texttt{witness}\langle B \rangle@S_1 \text{ from } T \quad \texttt{witness}\langle B \rangle@S_2 \text{ from } T}
     {\text{Both share } \texttt{WitnessTable}_B^T}
\tag{WitnessTable-Share}
$$

[18] Allocation states (@Stack/@Region/@Heap) do not affect witness table sharing. The vtable is the same regardless of allocation strategy.

#### §12.4.5 Type Erasure [witness.representation.erasure]

##### §12.4.5.1 Erasure Semantics

[19] Witnesses perform _type erasure_: the concrete type `T` is not part of the witness type signature. The witness type `witness<Display>` can hold values of any type implementing Display.

[20] **Type erasure rule**:

$$
\frac{T_1 : B \quad T_2 : B}
     {\texttt{witness}\langle B \rangle \text{ can hold both } T_1 \text{ and } T_2}
\tag{Witness-Erasure}
$$

[21] Heterogeneous collections use type erasure:

**Example 13.4.5.1 (Type erasure enabling heterogeneous collections)**:

```cursive
let point: witness<Display> = Point { x: 1.0, y: 2.0 }
let circle: witness<Display> = Circle { radius: 5.0 }
let rectangle: witness<Display> = Rectangle { width: 2.0, height: 3.0 }

// All have type witness<Display> despite different concrete types
let shapes: [witness<Display>] = [point, circle, rectangle]
```

##### §12.4.5.2 Type Recovery

[22] The concrete type can be recovered at runtime via pattern matching or type introspection (§7.8):

```cursive
match witness {
    w if w.type_id() == type_id<Point>() => {
        // Dynamically verified: witness contains Point
    }
    _ => { }
}
```

[23] Complete type recovery mechanisms and safe downcasting patterns are implementation-defined extensions. The core witness system provides type erasure; recovery is optional.

#### §12.4.6 Witness Optimization and Erasure [witness.representation.optimization]

##### §12.4.6.1 Monomorphization Erasure

[24] When a witness-using procedure is monomorphized with a known concrete type, implementations may erase the witness and use direct dispatch:

**Example 13.4.6.1 (Witness erasure optimization)**:

```cursive
procedure show_witness(w: witness<Display>)
    [[ io::write |- true => true ]]
{
    w::show()
}

// If called with only Point:
show_witness(point_witness)
show_witness(another_point_witness)

// Compiler MAY optimize to:
procedure show_witness_Point(p: Point) {
    p::show()  // Direct call, no vtable
}
```

[25] This optimization is permitted when all call sites use the same concrete type. It does not affect observable behavior (only performance).

##### §12.4.6.2 Erasure Limitations

[26] Witnesses stored in fields, returned from procedures, or appearing in truly heterogeneous collections cannot be erased. The witness representation must be preserved.

[27] Erasure is a quality-of-implementation optimization. Conforming programs shall not depend on whether erasure occurs; behavior must be identical with or without optimization.

#### §12.4.7 Size and Alignment [witness.representation.size]

[28] **Size properties**:

$$
\text{sizeof}(\texttt{witness}\langle B \rangle@S) = 2 \times \text{sizeof}(\texttt{Ptr}\langle T \rangle)
\tag{Witness-Size}
$$

[29] **Alignment properties**:

$$
\text{alignof}(\texttt{witness}\langle B \rangle@S) = \text{alignof}(\texttt{Ptr}\langle T \rangle)
\tag{Witness-Align}
$$

[30] Witnesses have uniform size regardless of the concrete type they contain. A `witness<Display>` holding a Point has the same size as a `witness<Display>` holding a Circle.

#### §12.4.8 Conformance Requirements [witness.representation.requirements]

[31] Implementations shall:

1. Represent witnesses as dense pointers (data pointer + metadata pointer)
2. Ensure witness size equals two sparse pointer sizes
3. Align witnesses to pointer alignment
4. Implement witness tables with type ID, size, alignment, optional state tag, drop function, and vtable
5. Share witness tables across instances of same type/behavior combination
6. Allocate witness tables in static storage
7. Support type erasure: witness type hides concrete type
8. May optimize witnesses to direct dispatch when monomorphizable
9. Preserve witness representation when needed (heterogeneous collections)
10. Document platform-specific sizes (32-bit vs 64-bit)


### §12.5 Dispatch Semantics [witness.dispatch]

#### §12.5.1 Overview

[1] _Dispatch_ is the process of invoking a procedure on a witness value. Witness dispatch is dynamic: the concrete implementation is determined at runtime by loading a function pointer from the witness vtable and performing an indirect call.

[2] This subclause specifies method invocation syntax, vtable lookup mechanics, the dispatch algorithm, performance characteristics, and comparison with static monomorphization.

#### §12.5.2 Method Invocation Syntax [witness.dispatch.syntax]

[3] Witness method invocation uses the scope operator `::` (same as all procedure calls):

**Witness method calls** match the pattern:
```
<witness_expression> "::" <method_identifier> "(" [ <argument_list> ] ")"
```

[4] The syntax is identical to static procedure calls. The witness type determines that dispatch is dynamic.

**Example 13.5.2.1 (Witness method calls)**:

```cursive
let w: witness<Display> = shape

w::show()                    // Dispatch to show()
let name = w::get_name()     // Dispatch to get_name()
w::render(canvas)            // Dispatch with arguments
```

#### §12.5.3 Dispatch Algorithm [witness.dispatch.algorithm]

[5] The dispatch algorithm for `witness::method(args)`:

```
dispatch_witness_method(witness, method_name, args):
    // 1. Load witness components
    data_ptr = witness.data_ptr
    metadata_ptr = witness.metadata_ptr

    // 2. Load witness table
    wtable = load(metadata_ptr)

    // 3. Lookup method in vtable
    method_fn = wtable.vtable[method_name]
    if method_fn == null:
        panic("method not found")  // Should not happen if type-checked

    // 4. Indirect call through function pointer
    result = method_fn(data_ptr, args)

    return result
```

[6] **Dispatch typing rule**:

[ Given: Witness $w : \texttt{witness}\langle B \rangle$, procedure $m$ in behavior $B$ ]

$$
\frac{\Gamma \vdash w : \texttt{witness}\langle B \rangle \quad B \text{ declares } m : (\tau_1, \ldots) \to \tau_r}
     {\Gamma \vdash w\texttt{::}m(args) : \tau_r}
\tag{T-Witness-Dispatch}
$$

[7] The method must exist in the behavior/contract being witnessed. Calling non-existent methods produces diagnostic E13-020 during type checking.

#### §12.5.4 Dynamic Dispatch Evaluation [witness.dispatch.evaluation]

[8] The evaluation semantics for witness dispatch:

[ Given: Witness $w$ wrapping concrete value $v : T$ ]

$$
\frac{
\begin{array}{c}
w = \{\text{data}: v, \text{metadata}: \text{wtable}\} \\
\text{wtable.vtable}[m] = f_m \\
\langle f_m(v, args), \sigma \rangle \Downarrow \langle \text{result}, \sigma' \rangle
\end{array}
}{
\langle w\texttt{::}m(args), \sigma \rangle \Downarrow \langle \text{result}, \sigma' \rangle
}
\tag{E-Witness-Dispatch}
$$

[9] The concrete function $f_m$ is the implementation of method $m$ for the concrete type $T$. The dispatch is resolved at runtime via vtable lookup.

**Example 13.5.4.1 (Dispatch evaluation)**:

```cursive
// Static (type known):
let point = Point { x: 1.0, y: 2.0 }
point::show()
// Compiles to: Point::show(&point)  // Direct call

// Dynamic (type erased):
let w: witness<Display> = point
w::show()
// Compiles to:
// let vtable = load(w.metadata_ptr)
// let show_fn = vtable.vtable["show"]
// show_fn(w.data_ptr)  // Indirect call through function pointer
```

#### §12.5.5 Method Resolution [witness.dispatch.resolution]

[10] Method resolution for witnesses follows behavior/contract declarations:

**For behavior witnesses**:

- Methods are those declared in the behavior (§10.4)
- Includes inherited methods from extended behaviors
- Overrides in concrete implementation are reflected in vtable

**For contract witnesses**:

- Methods are those required by the contract (Clause 12)
- Includes inherited methods from extended contracts
- Type's implementation provides vtable entries

**For modal state witnesses**:

- Methods are those available in the witnessed state (§7.6)
- State-specific procedures only
- Attempting to call methods from different states produces compile-time diagnostic

**Example 13.5.5.1 (Modal state method resolution)**:

```cursive
modal FileHandle {
    @Closed {
        procedure open(~!): FileHandle@Open
        [[ io::open |- true => true ]]
    }

    @Open {
        procedure read(~, buffer: [u8]): FileHandle@Open
        [[ io::read |- true => true ]]

        procedure close(~!): FileHandle@Closed
        [[ io::close |- true => true ]]
    }
}

let w: witness<FileHandle@Open> = file

w::read(buffer)  // ✅ OK: read available in @Open
w::close()       // ✅ OK: close available in @Open
// w::open()     // ❌ ERROR E13-021: open not available in @Open (only in @Closed)
```

#### §12.5.6 Performance Characteristics [witness.dispatch.performance]

[11] Witness dispatch has the following performance profile:

**Per method call**:

- 1 metadata pointer load (likely cached)
- 1 vtable entry load (function pointer)
- 1 indirect call (branch predictor penalty possible)

**Comparison to static dispatch**:

- Static: 0 indirections (direct call, inlinable)
- Witness: 1-2 pointer loads + 1 indirect call

**Optimization opportunities**:

- Vtable loads can be CSE'd (common subexpression elimination) across multiple calls
- Branch prediction can reduce indirect call overhead for stable patterns
- Monomorphization erasure eliminates all overhead when concrete type known

[12] The overhead is small but non-zero. Programs should prefer static dispatch (generics) unless dynamic behavior is actually required.

#### §12.5.7 Grant Propagation [witness.dispatch.grants]

[13] Witness method calls propagate grants from the method's sequent to the calling context:

$$
\frac{B \text{ declares } m \; \texttt{[[} G \texttt{|-} \cdots \texttt{]]} \quad w : \texttt{witness}\langle B \rangle}
     {w\texttt{::}m() \text{ requires grants } G}
\tag{Witness-Grant-Propagate}
$$

[14] The caller must have all grants required by the method being called, just as with static dispatch.

**Example 13.5.7.1 (Grant propagation through witnesses)**:

```cursive
behavior Processor {
    procedure process(~)
        [[ io::write, alloc::heap |- true => true ]]
    { }
}

procedure run_processor(w: witness<Processor>)
    [[ io::write, alloc::heap |- true => true ]]
{
    w::process()  // Requires io::write, alloc::heap from Processor::process
}

procedure invalid_caller(w: witness<Processor>)
    [[ |- true => true ]]
{
    // w::process()  // ❌ E12-030: missing grants io::write, alloc::heap
}
```

#### §12.5.8 Diagnostics [witness.dispatch.diagnostics]

[15] Dispatch diagnostics:

| Code    | Condition                                   | Section |
| ------- | ------------------------------------------- | ------- |
| E13-020 | Method not found in behavior/contract       | [7]     |
| E13-021 | Method not available in modal state         | [10]    |
| E13-022 | Insufficient grants for witness method call | [14]    |

#### §12.5.9 Conformance Requirements [witness.dispatch.requirements]

[16] Implementations shall:

1. Support witness method calls using `::` operator
2. Implement dynamic dispatch via vtable lookup
3. Load function pointers from witness tables
4. Perform indirect calls through vtable entries
5. Type-check method existence at compile time
6. Verify method availability for modal state witnesses
7. Propagate grants from method sequents to calling context
8. Optimize witness dispatch when concrete type known (optional)
9. Emit diagnostics E13-020, E13-021, E13-022 for dispatch violations
10. Maintain type safety throughout dispatch process


### §12.6 Regions, Permissions, and Grants Interplay [witness.memory]

#### §12.6.1 Overview

[1] This subclause specifies how witnesses integrate with Cursive's memory model: cleanup responsibility (§11.2), region allocation (§11.3), permissions (§11.4), and move semantics (§11.5). Witnesses follow the same memory safety rules as all Cursive values.

[2] The three witness allocation states (@Stack, @Region, @Heap) map directly to cleanup responsibility and region integration, maintaining consistency with the broader memory model.

#### §12.6.2 Cleanup Responsibility [witness.memory.responsibility]

[3] Witness cleanup responsibility is determined by allocation state:

**Table 13.3 — Witness cleanup responsibility**

| Allocation State | Cleanup Responsibility | Destructor Called    | Move Required | Binding Analogy      |
| ---------------- | ---------------------- | -------------------- | ------------- | -------------------- |
| @Stack           | Non-responsible        | NO                   | NO            | `let w <- value`     |
| @Region          | Responsible            | YES (at region exit) | YES           | `let w = move value` |
| @Heap            | Responsible            | YES (at scope exit)  | YES           | `let w = move value` |

[4] **RAII integration**:

$$
\frac{w : \texttt{witness}\langle B \rangle@\texttt{Heap} \text{ responsible}}
     {\text{At scope exit: call } w\text{.drop()}}
\tag{P-Witness-RAII}
$$

[5] Responsible witnesses (@Heap, @Region) invoke the underlying value's destructor when they are destroyed. Non-responsible witnesses (@Stack) do not invoke destructors.

**Example 13.6.2.1 (Cleanup responsibility)**:

```cursive
procedure demo_cleanup()
    [[ alloc::heap, io::write |- true => true ]]
{
    let data = Resource::new()

    // Stack witness: Non-responsible
    let stack_w: witness<Display>@Stack = data
    // data retains cleanup responsibility

    {
        let shape = Shape::new()
        let heap_w: witness<Display>@Heap = move shape
        // heap_w is responsible
        // shape is invalid (moved)
    }
    // Scope exit: heap_w's destructor called (Shape::drop)

    // Outer scope exit: data's destructor called
    //                   stack_w does NOT call destructor (non-responsible)
}
```

#### §12.6.3 Region Integration [witness.memory.regions]

##### §12.6.3.1 Region Witness Lifetime

[6] Region witnesses (`@Region`) are allocated in the active region and destroyed when the region exits:

**Example 13.6.3.1 (Region witness lifecycle)**:

```cursive
procedure process_batch(items: [Item])
    [[ alloc::region, io::write |- true => true ]]
{
    region batch {
        let processors: [witness<Processor>@Region] = []

        loop item: Item in items {
            let processor = create_processor(item)
            let w: witness<Processor>@Region = move processor
            processors.push(w)
        }

        // Use processors
        loop p: witness<Processor>@Region in processors {
            p::process()
        }
    }
    // Region exit: All region witnesses destroyed in O(1)
}
```

##### §12.6.3.2 Region Escape Prevention

[7] Region witnesses cannot escape their region, consistent with region escape analysis (§11.3.3):

$$
\frac{w : \texttt{witness}\langle B \rangle@\texttt{Region} \quad \text{region } r \text{ active}}
     {\text{Escaping } w \text{ from } r \Rightarrow \text{ERROR E13-011}}
\tag{WF-Witness-Region-NoEscape}
$$

[8] Attempting to return region witnesses or store them in outer scopes produces diagnostic E13-011.

**Example 13.6.3.2 (Region escape prevention)**:

```cursive
procedure invalid_escape(): witness<Display>@Region
    [[ alloc::region |- true => true ]]
{
    region temp {
        let shape = Circle { radius: 5.0 }
        let w: witness<Display>@Region = move shape
        result w  // ❌ E13-011: region witness escapes region
    }
}
```

##### §12.6.3.3 Heap Conversion

[9] Region witnesses may explicitly convert to heap witnesses via `to_heap()` transition:

```cursive
region temp {
    let shape = Circle { radius: 5.0 }
    let region_w: witness<Display>@Region = move shape

    let heap_w: witness<Display>@Heap = region_w::to_heap()  // Escape to heap
    result heap_w  // ✅ OK: heap witness can escape
}
```

[10] The `to_heap()` transition requires `alloc::heap` grant.

#### §12.6.4 Permission Inheritance [witness.memory.permissions]

[11] Witnesses inherit permissions from the source value at construction and maintain those permissions throughout their lifetime:

$$
\frac{v : \texttt{perm } T \quad w : \texttt{witness}\langle B \rangle \text{ from } v}
     {w : \texttt{perm witness}\langle B \rangle}
\tag{Witness-Perm-Inherit}
$$

[12] Permission qualifiers apply to the entire witness value:

**Example 13.6.4.1 (Permission on witnesses)**:

```cursive
// Unique witness
let point: unique Point = Point::new()
let w1: unique witness<Display> = point
w1::mutate()  // ✅ OK if Display has mutating methods

// Const witness
let shape: const Circle = get_circle()
let w2: const witness<Display> = shape
// w2::mutate()  // ❌ ERROR: const permission prohibits mutation

// Shared witness
let data: shared Buffer = get_shared_buffer()
let w3: shared witness<Processor> = data
w3::process()  // Shared access to process method
```

##### §12.6.4.1 Permission Downgrades

[13] Witnesses follow the permission lattice (§11.4.3):

$$
\texttt{unique witness}\langle B \rangle <: \texttt{shared witness}\langle B \rangle <: \texttt{const witness}\langle B \rangle
$$

[14] Permission downgrades are implicit; upgrades are forbidden.

**Example 13.6.4.2 (Permission downgrades)**:

```cursive
let unique_w: unique witness<Display> = shape
let shared_w: shared witness<Display> = unique_w  // ✅ Downgrade
let const_w: const witness<Display> = shared_w    // ✅ Downgrade

// let back_to_unique: unique witness<Display> = const_w  // ❌ Cannot upgrade
```

#### §12.6.5 Move Semantics [witness.memory.move]

[15] Heap and region witnesses require explicit `move` keyword at construction, following the move semantics in §11.5:

**Example 13.6.5.1 (Explicit move for responsible witnesses)**:

```cursive
let value = Type::new()

// Stack: No move (non-responsible)
let w1: witness<B>@Stack = value
// value still valid

// Heap: Requires move (responsible)
let value2 = Type::new()
let w2: witness<B>@Heap = move value2
// value2 invalid (moved)

// Region: Requires move (responsible)
region temp {
    let value3 = Type::new()
    let w3: witness<B>@Region = move value3
    // value3 invalid (moved)
}
```

[16] Omitting `move` for @Heap/@Region witnesses produces diagnostic E13-010.

#### §12.6.6 Grant Requirements [witness.memory.grants]

[17] Witness construction requires grants based on allocation state:

**Table 13.4 — Witness construction grants**

| Allocation State | Required Grant  | Reason                 |
| ---------------- | --------------- | ---------------------- |
| @Stack           | None            | Only creates reference |
| @Region          | `alloc::region` | Allocates in region    |
| @Heap            | `alloc::heap`   | Allocates on heap      |

[18] Missing grants produce diagnostic E13-012.

**Example 13.6.6.1 (Grant requirements)**:

```cursive
procedure make_stack_witness(shape: Shape): witness<Display>@Stack
    [[ |- true => true ]]  // No grants needed
{
    result shape  // Implicit: witness::stack coercion
}

procedure make_heap_witness(shape: Shape): witness<Display>@Heap
    [[ alloc::heap |- true => true ]]  // Requires alloc::heap
{
    result move shape  // Implicit: witness::heap coercion with allocation
}

procedure make_region_witness(shape: Shape): witness<Display>@Region
    [[ alloc::region |- true => true ]]  // Requires alloc::region
{
    result move shape  // Implicit: witness::region coercion with allocation
}
```

#### §12.6.7 Witness Transitions [witness.memory.transitions]

[19] Witnesses support state transitions following modal type semantics (§7.6):

**Transition methods**:

```cursive
// Built-in transitions
@Stack::to_region(~): witness<B>@Region      // Stack → Region
@Stack::to_heap(~): witness<B>@Heap          // Stack → Heap
@Region::to_heap(~): witness<B>@Heap         // Region → Heap
```

[20] Transitions create new witnesses with different allocation states. Each transition has grant requirements:

- `to_region()`: Requires `alloc::region`
- `to_heap()`: Requires `alloc::heap`

**Example 13.6.7.1 (Witness transitions)**:

```cursive
procedure extend_witness_lifetime(shape: Shape): witness<Display>@Heap
    [[ alloc::heap |- true => true ]]
{
    let stack_w: witness<Display>@Stack = shape

    let heap_w = stack_w::to_heap()  // Transition to heap
    result heap_w  // Can escape scope
}
```

#### §12.6.8 Conformance Requirements [witness.memory.requirements]

[21] Implementations shall:

1. Map witness allocation states to cleanup responsibility per Table 13.3
2. Invoke destructors for responsible witnesses (@Heap, @Region)
3. Skip destructors for non-responsible witnesses (@Stack)
4. Enforce explicit `move` for @Heap/@Region witness creation
5. Integrate region witnesses with region escape analysis
6. Prevent region witness escape with diagnostic E13-011
7. Inherit permissions from source values to witnesses
8. Support permission downgrades following permission lattice
9. Enforce grant requirements per Table 13.4
10. Support witness state transitions (@Stack→@Region→@Heap)
11. Require appropriate grants for transition methods


### §12.7 Grammar Hooks and References [witness.grammar]

#### §12.7.1 Overview

[1] This subclause consolidates the grammar for witness types, witness expressions, and witness-related constructs. The authoritative grammar appears in Annex A; this section provides a readable summary with cross-references.

#### §12.7.2 Witness Type Grammar [witness.grammar.type]

[2] Witness type syntax (simplified notation):

**Witness types** match the pattern:
```
"witness" "<" <WitnessProperty> ">" [ <AllocationState> ]
```

where **witness properties** take one of the following forms:
```
<BehaviorIdentifier>
<ContractIdentifier>
<Type> "@" <StateIdentifier>
```

and **allocation states** match the pattern:
```
"@" ( "Stack" | "Region" | "Heap" )
```

[3] The witness property (in angle brackets) specifies what is being witnessed. The allocation state (optional, defaults to @Stack) specifies where the witness is allocated.

[ Note: See Annex A §A.2 [grammar.type] for authoritative witness type grammar.
— end note ]

#### §12.7.3 Witness Construction Grammar [witness.grammar.construction]

[4] Witness construction via type coercion:

**Witness construction expressions** are simply:
```
<Expression>

// Where expression has type T
// And target type is witness<B>@State
// Compiler inserts coercion automatically
```

[5] No explicit construction syntax is needed. Type annotations trigger automatic coercion.

#### §12.7.4 Witness Method Call Grammar [witness.grammar.methodcall]

[6] Witness method invocation:

**Witness method calls** match the pattern:
```
<WitnessExpression> "::" <Identifier> "(" [ <ArgumentList> ] ")"
```

where **witness expressions** are any `<Expression>` with type `witness<B>`.

[7] Method calls use the scope operator `::` consistently with all Cursive procedure calls.

[ Note: See Annex A §A.4 [grammar.expression] for complete expression grammar including method calls.
— end note ]

#### §12.7.5 Witness Transition Grammar [witness.grammar.transitions]

[8] Witness state transitions:

**Witness transition calls** match the pattern:
```
<WitnessExpression> "::" <TransitionMethod> "(" ")"
```

where **transition methods** take one of the following forms:
```
"to_region"
"to_heap"
```

[9] Transitions are built-in methods on witness types, following modal transition syntax (§7.6).

#### §12.7.6 Complete Grammar Example [witness.grammar.example]

**Example 13.7.6.1 (All witness grammar elements)**:

```cursive
// Type annotations
procedure demo(
    stack_w: witness<Display>,               // Defaults to @Stack
    region_w: witness<Processor>@Region,     // Explicit @Region
    modal_w: witness<FileHandle@Open>@Heap   // Modal witness, @Heap
)
    [[ alloc::heap, io::write |- true => true ]]
{
    // Construction via coercion
    let shape = Circle { radius: 5.0 }
    let w1: witness<Display> = shape                  // Stack witness
    let w2: witness<Display>@Heap = move Circle::new()  // Heap witness

    // Method calls
    w1::show()
    w2::render(canvas)

    // Transitions
    let w3 = w1::to_heap()

    // Modal witness methods
    modal_w::read(buffer)

    // Heterogeneous array
    let witnesses: [witness<Display>] = [w1, stack_w]
}
```

#### §12.7.7 Integration with Annex A [witness.grammar.annex]

[10] Witness grammar integrates with Annex A productions:

**Type Grammar** (Annex A §A.2):

- `witness_type` added to `type` production
- Modal state annotations reused for allocation states

**Expression Grammar** (Annex A §A.4):

- Witness construction via type coercion (implicit in assignment)
- Method calls follow postfix expression syntax

**Pattern Grammar** (Annex A §A.3):

- Witnesses can be pattern matched (future extension)
- Currently: witnesses are opaque, no pattern matching on content

#### §12.7.8 Conformance Requirements [witness.grammar.requirements]

[11] Implementations shall:

1. Parse witness types with property in angle brackets
2. Support optional allocation state annotations (@Stack/@Region/@Heap)
3. Default omitted allocation state to @Stack
4. Parse witness method calls using `::` operator
5. Support transition methods (to_region, to_heap)
6. Integrate witness grammar with Annex A type and expression grammars
7. Emit syntax diagnostics for malformed witness types
8. Maintain grammar consistency with modal types and generic syntax


### §12.8 Diagnostics [witness.diagnostics]

#### §12.8.1 Overview

[1] This subclause consolidates all diagnostics for the witness system, provides conformance requirements, and specifies integration with other language subsystems.

[2] Witness system diagnostics cover formation errors, dispatch failures, permission violations, region escapes, and grant violations. All diagnostics follow the canonical format `E12-[NNN]` as specified in §1.6.6 [intro.document.diagnostics].

#### §12.8.2 Complete Diagnostic Catalog [witness.diagnostics.catalog]

[3] Clause 12 defines the following diagnostic codes:

##### §12.8.2.1 Formation and Construction Diagnostics (E12-001 through E12-012)

| Code    | Description                                                 | Section    |
| ------- | ----------------------------------------------------------- | ---------- |
| E12-001 | Type does not satisfy behavior/satisfy contract/have state  | §12.3.6[1] |
| E12-010 | Missing `move` for responsible witness (@Heap/@Region)      | §12.3.6[2] |
| E12-011 | Region witness escapes region                               | §12.3.6[5] |
| E12-012 | Grant missing for witness construction (alloc::heap/region) | §12.3.6[4] |

##### §12.8.2.2 Dispatch Diagnostics (E12-020 through E12-022)

| Code    | Description                                 | Section     |
| ------- | ------------------------------------------- | ----------- |
| E12-020 | Method not found in behavior/contract       | §12.5.8[7]  |
| E12-021 | Method not available in modal state         | §12.5.5[10] |
| E12-022 | Insufficient grants for witness method call | §12.5.7[14] |

##### §12.8.2.3 Memory Integration Diagnostics (E12-030 through E12-032)

| Code    | Description                                 | Section     |
| ------- | ------------------------------------------- | ----------- |
| E12-030 | Permission upgrade on witness               | §12.6.4[6]  |
| E12-031 | Witness transition requires grant           | §12.6.7[20] |
| E12-032 | Invalid witness transition (no such method) | §12.6.7[19] |

#### §12.8.3 Diagnostic Payloads [witness.diagnostics.payloads]

[4] Witness diagnostics shall follow payload schemas in Annex E §E.5.3, with required fields including source/target types, witness type, method names, modal states, permissions, and grants as applicable. Diagnostic codes E12-001 through E12-032 are defined in this clause.

#### §12.8.4 Consolidated Conformance Requirements [witness.diagnostics.conformance]

[5] A conforming implementation of the witness system shall:

**Type System** (§12.1-§12.2):

1. Provide `witness<Property>@State` as built-in modal type
2. Support behavior, contract, and modal state witnesses
3. Default witness types to @Stack allocation state
4. Unify all witness kinds with same dense pointer representation

**Formation** (§12.3): 5. Support automatic witness coercion from implementing types 6. Verify type implements/satisfies witness property 7. Create non-responsible @Stack witnesses without `move` 8. Require explicit `move` for @Heap/@Region witnesses 9. Enforce grant requirements for witness construction 10. Apply region escape analysis to region witnesses

**Representation** (§12.4): 11. Implement witnesses as dense pointers (16 bytes on 64-bit) 12. Structure witness tables with type ID, size, align, state tag, drop, vtable 13. Share witness tables across instances 14. Support type erasure hiding concrete types

**Dispatch** (§12.5): 15. Support method calls using `::` operator 16. Implement vtable-based dynamic dispatch 17. Type-check method existence and availability 18. Propagate grants from method sequents 19. Optimize to static dispatch when concrete type known (optional)

**Memory Integration** (§12.6): 20. Map allocation states to cleanup responsibility 21. Integrate with RAII for destructor calls 22. Enforce region escape prevention 23. Inherit permissions from source values 24. Support witness transitions between allocation states 25. Enforce grant requirements for transitions

**Grammar** (§12.7): 26. Parse witness types with angle bracket syntax 27. Support allocation state annotations 28. Integrate with Annex A type and expression grammars

**Diagnostics**: 29. Emit all diagnostics E12-001 through E12-032 30. Provide structured diagnostic payloads per Annex E §E.5 31. Maintain witness metadata for reflection and tooling

#### §12.8.5 Integration Summary [witness.diagnostics.integration]

[6] The witness system integrates with:

**Behaviors (Clause 8)**:

- Behavior declarations compile to witness tables
- Behavior implementations provide vtable entries
- Generic bounds (`<T: B>`) vs witness types (`witness<B>`) trade static/dynamic

**Contracts (Clause 10)**:

- Contract declarations compile to witness tables
- Contract implementations provide vtable entries
- Dynamic verification hooks generate witness evidence

**Modal Types (§6.6)**:

- Modal states trackable dynamically via witnesses
- State-specific procedures in modal witness vtables
- Witness state obligations in transition sequents

**Memory Model (Clause 9)**:

- Witness allocation states map to cleanup responsibility
- Region witnesses subject to escape analysis
- Permissions inherited from values
- Move semantics apply to witness construction

**Type System (Clause 5)**:

- Witnesses are modal types with allocation states
- Dense pointer representation defined
- Method dispatch typed through behavior/contract signatures

#### §12.8.6 Complete Example [witness.diagnostics.example]

**Example 13.8.6.1 (Comprehensive witness usage)**:

```cursive
behavior Drawable {
    procedure draw(~)
        [[ io::write |- true => true ]]
    { }

    procedure bounds(~): Rectangle
    { result Rectangle { x: 0.0, y: 0.0, width: 0.0, height: 0.0 } }
}

record Point with Drawable {
    x: f64,
    y: f64,

    procedure draw(~)
        [[ io::write |- true => true ]]
    {
        println("Point({}, {})", self.x, self.y)
    }

    procedure bounds(~): Rectangle
    {
        result Rectangle { x: self.x, y: self.y, width: 0.0, height: 0.0 }
    }
}

record Circle with Drawable {
    center: Point,
    radius: f64,

    procedure draw(~)
        [[ io::write |- true => true ]]
    {
        println("Circle(center: {}, radius: {})", self.center, self.radius)
    }

    procedure bounds(~): Rectangle
    {
        result Rectangle {
            x: self.center.x - self.radius,
            y: self.center.y - self.radius,
            width: self.radius * 2.0,
            height: self.radius * 2.0
        }
    }
}

// Witness construction and usage
procedure render_shapes(shapes: [witness<Drawable>])
    [[ io::write |- shapes.len() > 0 => true ]]
{
    loop shape: witness<Drawable> in shapes {
        shape::draw()                          // Dynamic dispatch
        let bounds = shape::bounds()          // Dynamic dispatch
        println("Bounds: {}x{}", bounds.width, bounds.height)
    }
}

// Usage
procedure main(): i32
    [[ alloc::heap, io::write |- true => true ]]
{
    let point = Point { x: 1.0, y: 2.0 }
    let circle = Circle {
        center: Point { x: 5.0, y: 5.0 },
        radius: 3.0
    }

    // Create heap witnesses explicitly (heterogeneous collection)
    let point_witness: witness<Drawable>@Heap = move point
    let circle_witness: witness<Drawable>@Heap = move circle

    // Array elements now have identical type
    let shapes: [witness<Drawable>@Heap] = [point_witness, circle_witness]

    render_shapes(shapes)

    result 0
}
```

#### §12.8.7 Conformance Requirements [witness.grammar.requirements]

[7] Implementations shall:

1. Parse witness types per §12.7.2 grammar
2. Support witness method calls per §12.7.4 grammar
3. Integrate witness grammar with Annex A
4. Emit syntax diagnostics for malformed witness types or calls
5. Maintain AST representation of witnesses for type checking


### §13.1 Concurrency Model [concurrency.model]

#### §13.1.1 Overview

[1] Cursive provides structured concurrency through thread spawning, synchronization primitives, and permission-based thread safety. The concurrency model integrates with the permission system (§9.4), modal types (§5.6), and grant tracking (Clause 10) to ensure data-race freedom without requiring separate thread-safety markers.

[2] **Design principles**:

- **Permission-based thread safety**: The existing permission system (`const`/`unique`/`shared`) encodes thread safety without additional markers
- **Modal types for lifecycle**: Threads, mutexes, channels, and other concurrent primitives are modal types tracking their lifecycle states
- **Explicit grants**: Concurrent operations require explicit capability grants (`thread::spawn`, `sync::lock`)
- **Data-race freedom**: Well-typed programs without unsafe code cannot produce data races

#### §13.1.2 Thread Safety Through Permissions

[4] Thread safety is encoded through the permission system (§10.4). The permission lattice directly determines thread safety properties as shown in Table 13.1.

**Table 13.1 — Permission-based thread safety**

| Permission | Thread Safety Meaning | Can Cross Thread Boundary | Synchronization Required |
|------------|----------------------|---------------------------|-------------------------|
| `const` | Immutable, unlimited aliasing | YES (safe to share) | NO (reads are safe) |
| `unique` | Exclusive ownership | YES (via transfer) | NO (exclusive access) |
| `shared` | Coordinated mutable access | YES (with sync primitive) | YES (Mutex, RwLock, etc.) |

[5] Complete permission semantics and enforcement rules are specified in §10.4 [memory.permission].

#### §13.1.3 Thread as Modal Type

[8] Threads are represented by the `Thread` built-in modal type:

```cursive
modal Thread<T> {
    @Spawned {
        id: ThreadId,
    }
    
    @Spawned::join(~!) -> @Joined
    @Spawned::detach(~!) -> @Detached
    
    @Joined {
        result: T,
    }
    
    @Detached { }
}
```

[9] **State semantics**:

- **@Spawned**: Thread is running. Supports join (wait for completion) or detach (run independently).
- **@Joined**: Thread has completed; result is available. Terminal state.
- **@Detached**: Thread runs independently; no result retrieval possible. Terminal state.

[10] **State transition diagram**:

```
@Spawned ──join()──> @Joined (result available)
   │
   │ detach()
   ↓
@Detached (independent execution)
```

#### §13.1.4 Thread Spawning

[11] Threads are spawned via the `spawn` procedure:

```cursive
procedure spawn<T, ε>(action: () -> T ! ε): Thread<T>@Spawned
    [[ thread::spawn, ε |- true => true ]]
    where T: const
{
    // Implementation creates OS thread executing action
}
```

[12] **Type constraint**: The return type `T` shall satisfy `T: const` (immutable permission). This ensures thread-safe return values without requiring separate Send markers.

[13] **Grant propagation**: The spawned closure's grant set `ε` is propagated to the spawning procedure's grant clause. The spawning procedure must have all grants required by the closure.

[14] **Closure constraints**: The spawned closure may capture:
- `const` bindings (safe to share across threads)
- Moved `unique` bindings (exclusive ownership transferred)
- No `shared` bindings without synchronization primitives

**Example 13.1.4.1 (Thread spawning with const data)**:

```cursive
procedure parallel_compute(config: const Config): (i32, i32)
    [[ thread::spawn, thread::join |- true => true ]]
{
    let thread1 = spawn(|| [[ |- true => true ]] {
        compute_first(config)  // OK: config is const (shareable)
    })
    
    let thread2 = spawn(|| [[ |- true => true ]] {
        compute_second(config)  // OK: multiple threads can read const
    })
    
    let result1 = thread1.join().result
    let result2 = thread2.join().result
    
    result (result1, result2)
}
```

**Example 13.1.4.2 (Thread spawning with unique transfer)**:

```cursive
procedure async_process(data: unique Buffer): i32
    [[ thread::spawn, thread::join, io::write |- true => true ]]
{
    let thread = spawn(move || [[ io::write |- true => true ]] {
        process_buffer(data)  // OK: unique ownership transferred
    })
    
    // data no longer accessible here (moved to thread)
    
    result thread.join().result
}
```

**Example 13.1.4.3 - invalid (Shared without synchronization)**:

```cursive
procedure invalid_parallel(data: shared Buffer)
    [[ thread::spawn |- true => true ]]
{
    let thread = spawn(|| {
        data.modify()  // error[E13-101]: shared data requires synchronization
    })
}
```

#### §13.1.5 Thread Joining and Detaching

##### §13.1.5.1 Join Operation

[15] The `join` method waits for thread completion and retrieves the result:

```cursive
procedure Thread.join<T>(self: unique Self@Spawned): Self@Joined
    [[ thread::join |- true => true ]]
{
    // Block until thread completes
    // Transition to @Joined with result available
}
```

[16] **Happens-before**: The join operation establishes a happens-before relationship (§13.2): all operations in the joined thread happen-before operations after the join in the joining thread.

[17] **Type rule**:

$$
\frac{\Gamma \vdash thread : \text{Thread}\langle T \rangle@\text{Spawned}}
     {\Gamma \vdash thread\texttt{.join()} : \text{Thread}\langle T \rangle@\text{Joined}}
\tag{T-Thread-Join}
$$

##### §13.1.5.2 Detach Operation

[18] The `detach` method allows a thread to run independently:

```cursive
procedure Thread.detach<T>(self: unique Self@Spawned): Self@Detached
    [[ thread::detach |- true => true ]]
{
    // Thread continues independently
    // Result is discarded
}
```

[19] **No result retrieval**: Detached threads cannot be rejoined. The result value is lost. Detach is appropriate for fire-and-forget tasks.

**Example 13.1.5.1 (Join and detach)**:

```cursive
procedure example()
    [[ thread::spawn, thread::join |- true => true ]]
{
    // Join pattern:
    let worker = spawn(|| [[ io::write ]] { compute_result() })
    let result = worker.join().result
    process(result)
    
    // Detach pattern:
    let logger = spawn(|| [[ io::write ]] { background_logging() })
    logger.detach()  // Runs independently, no result needed
}
```

#### §14.1.6 Thread-Local Storage

[20] Thread-local storage is managed through per-thread arena allocation (§10.3):

```cursive
procedure worker_thread(thread_id: usize)
    [[ alloc::region, io::write |- true => true ]]
{
    region thread_local as workspace {
        loop work_item in fetch_work(thread_id) {
            let data = workspace.alloc(Data::new(work_item))
            process(data)
        }
    }
    // Thread-local arena freed when thread exits
}
```

[21] Each thread has independent region stack. Arena allocations in one thread do not affect other threads.

#### §14.1.7 Constraints

[1] _Thread return type constraint._ The return type `T` of a spawned closure shall satisfy `T: const`. Non-const return types produce diagnostic E13-100.

[2] _Closure capture constraints._ Closures passed to `spawn` may capture:
- `const` bindings (immutable sharing)
- Moved `unique` bindings (ownership transfer via `move` keyword)

Capturing `shared` bindings without wrapping in synchronization primitives produces diagnostic E13-101.

[3] _Grant requirements._ Spawning threads requires the `thread::spawn` grant. Joining threads requires the `thread::join` grant. Detaching threads requires the `thread::detach` grant.

[4] _Thread lifecycle._ Threads shall either be joined or detached before the `Thread` value goes out of scope. Dropping a `Thread@Spawned` without join or detach produces diagnostic E13-102.

#### §14.1.8 Semantics

##### §14.1.8.1 Thread Creation

[5] The `spawn` procedure creates a new OS thread executing the provided closure:

[ Given: Closure `action : () -> T ! ε` ]

$$
\frac{\Gamma \vdash action : () \to T \; ! \varepsilon \quad T : \text{const}}
     {\Gamma \vdash \texttt{spawn}(action) : \text{Thread}\langle T \rangle@\text{Spawned}}
\tag{T-Spawn}
$$

[6] The spawned thread executes concurrently with the spawning thread. Execution order between threads is unspecified; synchronization is required for deterministic ordering.

##### §14.1.8.2 Thread Completion

[7] When a thread's closure returns, the thread transitions internally from running to completed state. The `join` method retrieves this completion:

$$
\frac{\langle thread, \sigma \rangle \Downarrow_{\text{join}} \langle \text{completed}, \sigma' \rangle}
     {\langle thread\texttt{.join()}, \sigma \rangle \Downarrow \langle \text{Thread}@\text{Joined}\{\text{result}: v\}, \sigma' \rangle}
\tag{E-Thread-Join}
$$

where $v$ is the value returned by the thread's closure.

##### §14.1.8.3 Grant Accumulation

[8] Grant sets accumulate across thread boundaries. The spawning procedure's grant clause shall include:
- `thread::spawn` (for the spawn operation)
- All grants `ε` required by the spawned closure

$$
\frac{\text{closure requires grants } \varepsilon}
     {\text{spawning procedure requires grants } \{\texttt{thread::spawn}\} \cup \varepsilon}
\tag{Grant-Thread-Accumulate}
$$

#### §13.1.9 Diagnostics

[9] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.13. — end note]

#### §14.1.10 Examples

**Example 14.1.10.1 (Parallel computation with const sharing)**:

```cursive
procedure parallel_sum(numbers: const [i32]): i32
    [[ thread::spawn, thread::join |- numbers.len() >= 2 => true ]]
{
    let mid = numbers.len() / 2
    
    let left_thread = spawn(|| [[ |- true => true ]] {
        sum_range(numbers, 0, mid)
    })
    
    let right_thread = spawn(|| [[ |- true => true ]] {
        sum_range(numbers, mid, numbers.len())
    })
    
    let left_sum = left_thread.join().result
    let right_sum = right_thread.join().result
    
    result left_sum + right_sum
}

procedure sum_range(numbers: const [i32], start: usize, end: usize): i32
    [[ |- start <= end && end <= numbers.len() => true ]]
{
    var total: i32 = 0
    loop i in start..end {
        total = total + numbers[i]
    }
    result total
}
```

**Example 14.1.10.2 (Background task with detach)**:

```cursive
procedure start_background_logger()
    [[ thread::spawn, thread::detach, io::write |- true => true ]]
{
    let logger = spawn(|| [[ io::write |- true => true ]] {
        loop {
            sleep(1000)
            log_status()
        }
    })
    
    logger.detach()  // Runs independently
    // Returns immediately; logging continues in background
}
```

**Example 14.1.10.3 (Transfer unique ownership to thread)**:

```cursive
procedure process_in_background(data: unique Buffer)
    [[ thread::spawn, thread::detach |- true => true ]]
{
    let processor = spawn(move || [[ alloc::heap |- true => true ]] {
        expensive_computation(data)
    })
    
    // data moved to thread (no longer accessible here)
    
    processor.detach()
}
```

**Example 14.1.10.4 - invalid (Non-const return type)**:

```cursive
procedure invalid_spawn()
    [[ thread::spawn |- true => true ]]
{
    let buffer: unique Buffer = Buffer::new()
    
    let thread = spawn(move || {
        result buffer  // error[E13-100]: return type 'unique Buffer' not const
    })
}
```

#### §14.1.11 Integration with Permission System

[10] The permission system (§11.4) provides thread safety guarantees:

**const types are thread-safe**:
[11] Types with `const` permission are inherently thread-safe because they are immutable. The compiler guarantees no mutable access exists, preventing data races.

$$
\frac{v : \text{const } T}
     {\text{Sharing } v \text{ across threads is safe}}
\tag{P-Const-ThreadSafe}
$$

**unique types are transferable**:
[12] Types with `unique` permission can be transferred between threads via `move`. The source thread loses access; the destination thread gains exclusive ownership. No aliasing exists, preventing data races.

$$
\frac{v : \text{unique } T \quad \text{move } v \text{ to thread}}
     {\text{Transfer is safe (exclusive ownership)}}
\tag{P-Unique-Transfer}
$$

**shared types require synchronization**:
[13] Types with `shared` permission require explicit synchronization when accessed from multiple threads. The programmer must wrap `shared` data in Mutex, RwLock, or other synchronization primitives (§14.4).

#### §13.1.12 No Send/Sync Markers

[14] Thread safety uses permissions, not markers (§1.8.3).

#### §13.1.13 Conformance Requirements

[16] Implementations shall establish happens-before relationships at spawn and join points (§13.2) and use permissions (const/unique/shared) for all thread safety checking without providing separate Send/Sync marker behaviors.


### §13.2 Memory Model [concurrency.memory]

#### §13.2.1 Overview

[1] The concurrent memory model defines the visibility and ordering of memory operations across threads. It specifies when writes from one thread become visible to reads in another thread, establishes the happens-before relation for program ordering, and guarantees data-race freedom for well-typed programs.

[2] This subclause integrates with the sequential memory model (Clause 11) to provide a complete specification of memory semantics in both single-threaded and multi-threaded contexts.

#### §13.2.2 Sequential Consistency for Data-Race-Free Programs

[3] Cursive guarantees **sequential consistency** for data-race-free (DRF) programs: programs execute as if operations from all threads were interleaved in some sequential order respecting the program order within each thread.

[4] **Data-race freedom**: A program is data-race-free when all pairs of concurrent operations accessing the same memory location satisfy at least one of:
1. Both operations are reads
2. Operations are ordered by synchronization (happens-before)
3. At least one operation is atomic (§14.3)

[5] **Guarantee**: Well-typed Cursive programs without `unsafe` blocks are data-race-free by construction. The permission system ensures this property.

#### §13.2.3 Happens-Before Relation

[6] The _happens-before_ relation orders operations across threads. If operation A happens-before operation B, then A's effects are visible to B.

[7] **Happens-before rules**:

**Intra-thread ordering**:
$$
\frac{\text{Op}_1 \text{ precedes } \text{Op}_2 \text{ in program order within thread}}
     {\text{Op}_1 \text{ happens-before } \text{Op}_2}
\tag{HB-Sequential}
$$

**Thread spawn**:
$$
\frac{\text{thread } t \text{ spawned at point } p}
     {\forall \text{ ops before } p \text{ happen-before all ops in } t}
\tag{HB-Spawn}
$$

**Thread join**:
$$
\frac{\text{thread } t \text{ joined at point } j}
     {\forall \text{ ops in } t \text{ happen-before all ops after } j}
\tag{HB-Join}
$$

**Synchronization**:
$$
\frac{\text{Release op } r \text{ on location } \ell \quad \text{Acquire op } a \text{ on } \ell \quad r \text{ synchronizes-with } a}
     {r \text{ happens-before } a}
\tag{HB-Sync}
$$

**Transitivity**:
$$
\frac{A \text{ happens-before } B \quad B \text{ happens-before } C}
     {A \text{ happens-before } C}
\tag{HB-Trans}
$$

#### §13.2.4 Synchronizes-With Relation

[8] The _synchronizes-with_ relation establishes ordering between release and acquire operations on the same location:

**Mutex unlock/lock**:
[9] Unlocking a mutex synchronizes-with the next lock acquisition on that mutex:

$$
\frac{\text{Thread}_1 \text{ unlocks mutex } m \quad \text{Thread}_2 \text{ locks mutex } m}
     {\text{unlock } m \text{ synchronizes-with lock } m}
\tag{SW-Mutex}
$$

**Channel send/receive**:
[10] Sending a value on a channel synchronizes-with receiving that value:

$$
\frac{\text{Thread}_1 \text{ sends } v \text{ on channel } c \quad \text{Thread}_2 \text{ receives from } c}
     {\text{send}(v) \text{ synchronizes-with receive}()}
\tag{SW-Channel}
$$

**Atomic release/acquire**:
[11] Atomic store with Release ordering synchronizes-with atomic load with Acquire ordering:

$$
\frac{\text{Atomic store}_{\text{Release}}(\ell, v) \quad \text{Atomic load}_{\text{Acquire}}(\ell) = v}
     {\text{store}_{\text{Release}} \text{ synchronizes-with load}_{\text{Acquire}}}
\tag{SW-Atomic}
$$

#### §13.2.5 Permission-Based Data Race Prevention

[12] The permission system prevents data races at compile time:

**const permission**:
[13] Multiple threads may read `const` data concurrently. Since `const` prohibits mutation (§11.4.2.1), no write/write or read/write races can occur.

[ Given: Value $v : \text{const } T$ shared across threads ]

$$
\frac{\text{All operations on } v \text{ are reads}}
     {\text{No data race on } v}
\tag{P-Const-NoRace}
$$

**unique permission**:
[14] `unique` data cannot be aliased (§11.7.3). When transferred to another thread via `move`, the source thread loses all access. Exclusive access in destination thread prevents races.

[ Given: Value $v : \text{unique } T$ transferred to thread ]

$$
\frac{\text{Source thread: } v \text{ becomes invalid} \quad \text{Dest thread: exclusive access}}
     {\text{No concurrent access} \Rightarrow \text{No data race}}
\tag{P-Unique-NoRace}
$$

**shared permission with synchronization**:
[15] `shared` data requires synchronization primitives (§14.4). Mutex, RwLock, and atomic operations provide the necessary happens-before edges to prevent races.

#### §13.2.6 Memory Operation Ordering

[16] Within a single thread, operations execute in program order (sequential consistency per thread). Across threads, only operations ordered by happens-before have guaranteed ordering.

[17] **Example of unordered operations**:

```cursive
// Thread 1:
x = 1
y = 2

// Thread 2:
let a = y  // Might see 0, 2, or intermediate state
let b = x  // Might see 0, 1, or intermediate state
```

Without synchronization, Thread 2 may observe operations from Thread 1 in any order.

[18] **Example with synchronization**:

```cursive
let lock = Mutex::new(())

// Thread 1:
x = 1
y = 2
lock.unlock()  // Release

// Thread 2:
lock.lock()    // Acquire
let a = y      // Guaranteed to see 2
let b = x      // Guaranteed to see 1
```

The mutex unlock synchronizes-with lock, establishing happens-before from all operations before unlock to all operations after lock.

#### §13.2.7 Conformance Requirements

[19] Implementations shall:

1. Guarantee sequential consistency for data-race-free programs
2. Implement happens-before relation per rules in §14.2.3
3. Implement synchronizes-with relation for all synchronization primitives
4. Ensure permission-based race prevention: const allows concurrent reads, unique prevents aliasing, shared requires synchronization
5. Prohibit data races in well-typed programs (races are undefined behavior: UB-ID: B.2.50)
6. Support memory orderings for atomic operations (§14.3): Relaxed, Acquire, Release, AcqRel, SeqCst
7. Document platform-specific memory model details (cache coherency, memory barriers)


### §13.3 Atomic Operations and Orderings [concurrency.atomic]

#### §13.3.1 Overview

[1] Atomic operations provide indivisible read-modify-write operations on primitive types without requiring locks. They enable lock-free algorithms, synchronization primitives, and fine-grained concurrent data structures.

[2] Cursive provides atomic operations as built-in procedures operating on `shared` primitive types. No wrapper types (`AtomicI32`, etc.) are needed—atomic operations work directly on shared integer and pointer types.

[3] This subclause specifies atomic operation syntax, memory ordering semantics, available operations, and integration with the happens-before memory model (§14.2).

#### §13.3.2 Memory Orderings

[4] Atomic operations accept a memory ordering parameter controlling synchronization strength:

```cursive
enum Ordering {
    Relaxed,   // No synchronization
    Acquire,   // Synchronize with Release stores
    Release,   // Synchronize with Acquire loads
    AcqRel,    // Both Acquire and Release
    SeqCst,    // Sequentially consistent
}
```

[5] **Ordering semantics**:

**Relaxed**:
[6] No synchronization guarantees. The operation is atomic (indivisible) but establishes no happens-before edges. Appropriate for counters where ordering doesn't matter.

**Acquire**:
[7] Used for loads. Synchronizes-with Release stores on the same location. All operations after the Acquire load in program order cannot be reordered before it.

**Release**:
[8] Used for stores. Synchronizes-with Acquire loads on the same location. All operations before the Release store in program order cannot be reordered after it.

**AcqRel**:
[9] Combines Acquire and Release. Used for read-modify-write operations. Acts as both Acquire (for the read) and Release (for the write).

**SeqCst**:
[10] Sequential consistency. Strongest ordering. All SeqCst operations have a single total order across all threads. Default when ordering is omitted.

#### §13.3.3 Atomic Operations

[11] Atomic operations are provided as built-in procedures in the `atomic` namespace:

##### §13.3.3.1 Atomic Load

```cursive
procedure atomic::load<T>(location: const T, ordering: Ordering): T
    [[ sync::atomic |- ordering in {Acquire, SeqCst, Relaxed} => true ]]
    where T: primitive integer or pointer type
```

[12] Atomically reads the value at `location` with specified memory ordering.

**Type rule**:

$$
\frac{\Gamma \vdash \ell : \text{const } T \quad T \in \text{AtomicTypes} \quad ord \in \{\text{Acquire}, \text{SeqCst}, \text{Relaxed}\}}
     {\Gamma \vdash \texttt{atomic::load}(\ell, ord) : T}
\tag{T-Atomic-Load}
$$

where $\text{AtomicTypes} = \{i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, \text{Ptr}\langle T \rangle\}$.

##### §13.3.3.2 Atomic Store

```cursive
procedure atomic::store<T>(location: shared T, value: T, ordering: Ordering)
    [[ sync::atomic |- ordering in {Release, SeqCst, Relaxed} => true ]]
    where T: primitive integer or pointer type
```

[13] Atomically writes `value` to `location` with specified memory ordering.

**Type rule**:

$$
\frac{\Gamma \vdash \ell : \text{shared } T \quad \Gamma \vdash v : T \quad ord \in \{\text{Release}, \text{SeqCst}, \text{Relaxed}\}}
     {\Gamma \vdash \texttt{atomic::store}(\ell, v, ord) : ()}
\tag{T-Atomic-Store}
$$

##### §13.3.3.3 Atomic Compare-Exchange

```cursive
procedure atomic::compare_exchange<T>(
    location: shared T,
    expected: T,
    desired: T,
    success_order: Ordering,
    failure_order: Ordering
): bool
    [[ sync::atomic |- true => true ]]
    where T: primitive integer or pointer type
```

[14] Atomically compares `location` with `expected`. If equal, stores `desired` and returns `true`. If not equal, returns `false` without modification.

[15] **Success ordering**: Used when comparison succeeds. May be any ordering.

[16] **Failure ordering**: Used when comparison fails. Shall not be stronger than success ordering. Shall not be Release or AcqRel (loads cannot release).

##### §13.3.3.4 Atomic Fetch-And-Op

```cursive
procedure atomic::fetch_add<T>(location: shared T, value: T, ordering: Ordering): T
    [[ sync::atomic |- true => true ]]
    where T: integer type

procedure atomic::fetch_sub<T>(location: shared T, value: T, ordering: Ordering): T
    [[ sync::atomic |- true => true ]]
    where T: integer type

procedure atomic::fetch_and<T>(location: shared T, value: T, ordering: Ordering): T
    [[ sync::atomic |- true => true ]]
    where T: integer type

procedure atomic::fetch_or<T>(location: shared T, value: T, ordering: Ordering): T
    [[ sync::atomic |- true => true ]]
    where T: integer type

procedure atomic::fetch_xor<T>(location: shared T, value: T, ordering: Ordering): T
    [[ sync::atomic |- true => true ]]
    where T: integer type
```

[17] Atomically performs the operation and returns the previous value.

#### §13.3.4 Constraints

[1] _Atomic type requirement._ Atomic operations shall operate only on primitive integer types and pointer types. Attempting atomic operations on composite types (records, tuples, arrays) produces diagnostic E13-200.

[2] _Permission requirement._ Atomic loads require `const` permission. Atomic stores and RMW operations require `shared` permission. Using atomic operations on `unique` produces diagnostic E13-201.

[3] _Ordering validity._ Memory orderings shall be valid for the operation:
- Load: Acquire, SeqCst, Relaxed
- Store: Release, SeqCst, Relaxed  
- RMW: Any ordering

Invalid orderings produce diagnostic E13-202.

[4] _Alignment requirement._ Atomic operations require natural alignment for the type. Misaligned atomic access produces undefined behavior [UB-ID: B.2.51].

[5] _Size limits._ Atomic operations are guaranteed for types up to pointer width (32-bit or 64-bit). Larger types (i128, u128) may not support atomic operations on all platforms. Using atomic operations on unsupported types produces diagnostic E13-203.

#### §13.3.5 Semantics

##### §13.3.5.1 Atomicity Guarantee

[6] Atomic operations are indivisible: no thread can observe partial completion. For operation $\text{atomic\_op}(\ell)$:

$$
\frac{\langle \text{atomic\_op}(\ell), \sigma \rangle \Downarrow \langle v, \sigma' \rangle}
     {\text{No intermediate state observable}}
\tag{E-Atomic-Indivisible}
$$

##### §13.3.5.2 Ordering Semantics

[7] **Relaxed**: No synchronization. Only atomicity guaranteed:

```cursive
var counter: shared i32 = 0

// Thread 1:
atomic::store(counter, 1, Ordering::Relaxed)

// Thread 2:
let value = atomic::load(counter, Ordering::Relaxed)
// Might see 0 or 1, no synchronization guarantee
```

[8] **Acquire/Release**: Establishes synchronization:

```cursive
var flag: shared i32 = 0
var data: shared i32 = 0

// Thread 1 (producer):
atomic::store(data, 42, Ordering::Relaxed)
atomic::store(flag, 1, Ordering::Release)  // Synchronizes

// Thread 2 (consumer):
loop {
    if atomic::load(flag, Ordering::Acquire) == 1 {  // Synchronizes
        let value = atomic::load(data, Ordering::Relaxed)
        // Guaranteed to see 42 (happens-before from Release to Acquire)
        break
    }
}
```

[9] **SeqCst**: Total order across all threads:

```cursive
var x: shared i32 = 0
var y: shared i32 = 0

// Thread 1:
atomic::store(x, 1, Ordering::SeqCst)

// Thread 2:
atomic::store(y, 1, Ordering::SeqCst)

// Thread 3:
let r1 = atomic::load(x, Ordering::SeqCst)
let r2 = atomic::load(y, Ordering::SeqCst)

// Thread 4:
let r3 = atomic::load(y, Ordering::SeqCst)
let r4 = atomic::load(x, Ordering::SeqCst)

// SeqCst guarantees: NOT possible for r1=r2=0 AND r3=r4=0
// (There exists a total order consistent with all observations)
```

#### §13.3.6 Examples

**Example 14.3.6.1 (Atomic counter)**:

```cursive
var global_counter: shared i32 = 0

procedure increment_counter()
    [[ sync::atomic |- true => true ]]
{
    atomic::fetch_add(global_counter, 1, Ordering::Relaxed)
}

procedure parallel_count(threads: usize)
    [[ thread::spawn, thread::join, sync::atomic |- threads > 0 => true ]]
{
    var handles: [Thread<()>@Spawned] = []
    
    loop i in 0..threads {
        let thread = spawn(|| [[ sync::atomic ]] {
            loop j in 0..1000 {
                increment_counter()
            }
        })
        handles.push(thread)
    }
    
    loop thread in handles {
        thread.join()
    }
    
    let total = atomic::load(global_counter, Ordering::Relaxed)
    println("Total: {}", total)  // Guaranteed: threads * 1000
}
```

**Example 14.3.6.2 (Lock-free stack)**:

```cursive
record Node<T> {
    value: T,
    next: shared Ptr<Node<T>>@Valid,
}

record LockFreeStack<T> {
    head: shared Ptr<Node<T>>@Valid,
}

procedure LockFreeStack.push<T>(~%, value: T)
    [[ sync::atomic, alloc::heap |- true => true ]]
{
    let node = Node {
        value,
        next: Ptr::null(),
    }
    
    loop {
        let old_head = atomic::load(self.head, Ordering::Acquire)
        node.next = old_head
        
        if atomic::compare_exchange(
            self.head,
            old_head,
            &node,
            Ordering::Release,
            Ordering::Relaxed
        ) {
            break  // Successfully pushed
        }
        // CAS failed, retry
    }
}
```

#### §13.3.7 Diagnostics

[10] Atomic operation diagnostics:

| Code    | Condition                                      | Constraint |
| ------- | ---------------------------------------------- | ---------- |
| E13-200 | Atomic operation on non-atomic type            | [1]        |
| E13-201 | Atomic operation with incorrect permission     | [2]        |
| E13-202 | Invalid memory ordering for operation          | [3]        |
| E13-203 | Atomic operation on unsupported type (e.g. i128) | [5]      |
| E13-204 | Misaligned atomic access                       | [4]        |

#### §13.3.8 Conformance Requirements

[11] Implementations shall:

1. Provide atomic operations for all primitive integer types up to pointer width
2. Support atomic operations on pointer types (Ptr<T>)
3. Implement all five memory orderings (Relaxed, Acquire, Release, AcqRel, SeqCst)
4. Enforce permission requirements: const for loads, shared for stores/RMW
5. Validate memory orderings for each operation type
6. Require natural alignment for atomic operations
7. Document platform support for i128/u128 atomics
8. Guarantee atomicity (indivisibility) for all atomic operations
9. Implement synchronizes-with relation for Acquire/Release orderings
10. Integrate atomic operations with happens-before memory model
11. Emit diagnostics E14-200 through E14-204 for violations


### §13.4 Synchronization Primitives [concurrency.synchronization]

#### §13.4.1 Overview

[1] Synchronization primitives coordinate access to `shared` data across threads. Cursive provides mutex locks, read-write locks, channels, and barriers as built-in modal types integrating with the permission system and happens-before memory model.

[2] All synchronization primitives are modal types tracking their lifecycle states. Lock acquisition and release are state transitions enforced by the type system.

[3] This subclause specifies the core synchronization primitives provided by the language. Additional primitives (semaphores, condition variables, barriers) are standard library types built on the same modal foundation.

#### §13.4.2 Mutex (Mutual Exclusion Lock)

##### §13.4.2.1 Mutex Modal Type

[4] `Mutex` is a built-in modal type providing exclusive access to shared data:

```cursive
modal Mutex<T> {
    @Unlocked {
        data: T,
    }
    
    @Unlocked::lock(~!) -> @Locked
    @Unlocked::try_lock(~!) -> @Locked \/ LockError
    
    @Locked {
        data: T,
    }
    
    @Locked::unlock(~!) -> @Unlocked
}
```

[5] **State semantics**:

- **@Unlocked**: Mutex is available for locking. Data is inaccessible.
- **@Locked**: Mutex is locked; data is accessible exclusively. Only the thread holding the lock may access the data.

[6] **RAII Guard Pattern**: The standard library provides `MutexGuard` for automatic unlocking:

```cursive
record MutexGuard<T> {
    mutex: unique Mutex<T>@Locked,
    
    procedure get(~!): unique T
        [[ |- true => true ]]
    {
        result self.mutex.data
    }
}

behavior Drop for MutexGuard<T> {
    procedure drop(~!)
        [[ sync::lock |- true => true ]]
    {
        self.mutex.unlock()
    }
}
```

##### §13.4.2.2 Usage

**Example 14.4.2.1 (Mutex protecting shared counter)**:

```cursive
var counter_mutex: Mutex<i32>@Unlocked = Mutex::new(0)

procedure increment_with_lock()
    [[ sync::lock |- true => true ]]
{
    let locked = counter_mutex.lock()  // Mutex<i32>@Locked
    locked.data = locked.data + 1
    locked.unlock()  // Back to @Unlocked
}

procedure safe_increment()
    [[ sync::lock |- true => true ]]
{
    let guard = MutexGuard { mutex: counter_mutex.lock() }
    guard.get() = guard.get() + 1
    // guard.drop() called automatically - unlocks mutex
}
```

**Example 14.4.2.2 (Mutex across threads)**:

```cursive
procedure parallel_increment(iterations: usize)
    [[ thread::spawn, thread::join, sync::lock, alloc::heap |- true => true ]]
{
    let mutex = Mutex::new(0)  // Mutex<i32>@Unlocked
    let thread_count = 4
    
    var threads: [Thread<()>@Spawned] = []
    
    loop i in 0..thread_count {
        let thread = spawn(|| [[ sync::lock |- true => true ]] {
            loop j in 0..iterations {
                let locked = mutex.lock()
                locked.data = locked.data + 1
                locked.unlock()
            }
        })
        
        threads.push(thread)
    }
    
    loop thread in threads {
        thread.join()
    }
    
    let final_locked = mutex.lock()
    println("Final count: {}", final_locked.data)  // thread_count * iterations
    final_locked.unlock()
}
```

##### §13.4.2.3 Synchronization Semantics

[7] Mutex unlock synchronizes-with the next mutex lock:

$$
\frac{\text{Thread}_1: \texttt{unlock}(m) \quad \text{Thread}_2: \texttt{lock}(m)}
     {\texttt{unlock}(m) \text{ synchronizes-with } \texttt{lock}(m)}
\tag{SW-Mutex}
$$

[8] All operations before unlock in Thread 1 happen-before all operations after lock in Thread 2.

#### §13.4.3 Channel (Message Passing)

##### §13.4.3.1 Channel Modal Type

[9] `Channel` is a built-in modal type for message passing between threads:

```cursive
modal Channel<T> {
    @Open {
        sender_count: usize,
        receiver_count: usize,
    }
    
    @Open::send(~%, value: T) -> @Open
    @Open::receive(~%) -> T \/ ChannelError
    @Open::close_sender(~!) -> @SenderClosed
    @Open::close_receiver(~!) -> @ReceiverClosed
    
    @SenderClosed {
        receiver_count: usize,
    }
    
    @SenderClosed::receive(~%) -> T \/ ChannelError
    
    @ReceiverClosed {
        sender_count: usize,
    }
    
    @Closed { }
}

enum ChannelError {
    Disconnected,
    Closed,
}
```

[10] **State semantics**:

- **@Open**: Channel is active; can send and receive
- **@SenderClosed**: Sender closed; can still receive pending values
- **@ReceiverClosed**: Receiver closed; sends will fail
- **@Closed**: Channel fully closed; no operations possible

##### §13.4.3.2 Usage

**Example 14.4.3.1 (Producer-consumer with channel)**:

```cursive
procedure producer_consumer()
    [[ thread::spawn, thread::join, sync::channel, io::write |- true => true ]]
{
    let channel: Channel<i32>@Open = Channel::new()
    
    let producer = spawn(move || [[ sync::channel |- true => true ]] {
        loop i in 0..100 {
            channel.send(i)
        }
        channel.close_sender()
    })
    
    let consumer = spawn(move || [[ sync::channel, io::write |- true => true ]] {
        loop {
            match channel.receive() {
                value: i32 => println("Received: {}", value),
                err: ChannelError::Disconnected => break,
                err: ChannelError::Closed => break,
            }
        }
    })
    
    producer.join()
    consumer.join()
}
```

##### §13.4.3.3 Synchronization Semantics

[11] Channel send synchronizes-with channel receive:

$$
\frac{\texttt{send}(c, v) \text{ in Thread}_1 \quad \texttt{receive}(c) = v \text{ in Thread}_2}
     {\texttt{send}(v) \text{ synchronizes-with } \texttt{receive}()}
\tag{SW-Channel}
$$

[12] All operations before send happen-before all operations after receive.

#### §13.4.4 RwLock (Read-Write Lock)

##### §13.4.4.1 RwLock Modal Type

[13] `RwLock` allows multiple readers or single writer:

```cursive
modal RwLock<T> {
    @Unlocked {
        data: T,
    }
    
    @Unlocked::read_lock(~%) -> @ReadLocked
    @Unlocked::write_lock(~!) -> @WriteLocked
    
    @ReadLocked {
        data: const T,
        reader_count: usize,
    }
    
    @ReadLocked::read_unlock(~%) -> @Unlocked \/ @ReadLocked
    
    @WriteLocked {
        data: unique T,
    }
    
    @WriteLocked::write_unlock(~!) -> @Unlocked
}
```

[14] **State semantics**:

- **@Unlocked**: No locks held; available for read or write lock
- **@ReadLocked**: One or more read locks held; data accessible as const
- **@WriteLocked**: Write lock held; data accessible as unique

[15] **Permission reflection**: The locked state determines data permission:
- @ReadLocked: data has `const` permission (multiple readers)
- @WriteLocked: data has `unique` permission (exclusive writer)

**Example 14.4.4.1 (RwLock for shared configuration)**:

```cursive
var config_lock: RwLock<Config>@Unlocked = RwLock::new(default_config())

procedure read_config(): Config
    [[ sync::lock |- true => true ]]
{
    let read_locked = config_lock.read_lock()  // @ReadLocked
    let config_copy = read_locked.data.clone()
    read_locked.read_unlock()
    result config_copy
}

procedure update_config(new_config: Config)
    [[ sync::lock |- true => true ]]
{
    let write_locked = config_lock.write_lock()  // @WriteLocked
    write_locked.data = new_config
    write_locked.write_unlock()
}
```

#### §13.4.5 Constraints

[1] _Type constraint for synchronization primitives._ Types stored in Mutex, RwLock, or sent through channels shall satisfy permission requirements:
- Mutex<T>: T may be any type
- RwLock<T>: T may be any type
- Channel<T>: T shall satisfy `T: const` for safe message passing

Violating type constraints produces diagnostic E13-300.

[2] _Deadlock prevention._ The specification does not prevent deadlocks at compile time. Programmers are responsible for avoiding circular lock dependencies. Implementations should provide runtime deadlock detection in debug builds.

[3] _Grant requirements._ Synchronization operations require grants:
- Mutex lock/unlock: `sync::lock`
- Channel send/receive: `sync::channel`
- RwLock operations: `sync::lock`

Missing grants produce diagnostic E14-301.

[4] _Lifecycle requirements._ Mutexes shall be unlocked before being dropped. Dropping a locked mutex produces undefined behavior [UB-ID: B.2.52].

#### §13.4.6 Conformance Requirements

[5] Implementations shall:

1. Provide Mutex<T>, Channel<T>, and RwLock<T> as built-in modal types
2. Implement lock/unlock as state transitions enforced by type system
3. Establish synchronizes-with relations for all synchronization operations
4. Integrate permissions with lock states (const for read locks, unique for write locks)
5. Support channel message passing with synchronization guarantees
6. Enforce type constraints (const requirement for channel messages)
7. Require appropriate grants for all synchronization operations
8. Emit diagnostics E13-300, E13-301 for constraint violations
9. Provide runtime deadlock detection in debug builds (recommended)
10. Document synchronization primitive performance characteristics


### §14.1 FFI Declarations and Safety Obligations [interop.ffi]

#### §14.1.1 Overview

[1] The Foreign Function Interface (FFI) enables Cursive programs to interoperate with code written in other languages, primarily C. FFI declarations specify foreign procedures, their signatures, calling conventions, and safety obligations that programmers must satisfy when crossing language boundaries. FFI introduces controlled unsafety: the compiler cannot verify that foreign code respects Cursive's memory model, permission system, or contracts. Programmers assume responsibility for ensuring foreign functions maintain safety invariants.

#### §14.1.2 Syntax

[4] FFI declarations use the `extern` attribute with calling convention specification, matching the pattern:

```
"[[" "extern" "(" <calling_convention> ")" [ "," <ffi_attributes> ] "]]"
    [ <visibility> ] "procedure" <identifier>
    [ <generic_params> ] "(" [ <parameter_list> ] ")" [ ":" <type> ]
    [ <sequent_clause> ]
    <callable_body>
```

where **calling conventions** are:

```
<string_literal>    // e.g., "C", "stdcall", "fastcall", "system"
```

**FFI attributes** match the pattern:

```
<ffi_attribute> [ "," <ffi_attribute> ... ]
```

**FFI attribute forms** are:

```
"unwind" "(" <unwind_behavior> ")"
"no_mangle"
"weak"
```

**Unwind behaviors** are:

```
"abort"
"catch"
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `procedure_decl` production with extern attributes.
— end note ]

[5] The `extern` attribute marks a procedure as using a foreign calling convention. The calling convention string specifies the ABI: `"C"` for C calling convention, `"stdcall"` for Windows stdcall, `"fastcall"` for fastcall, `"system"` for platform system ABI.

[6] FFI procedures may provide bodies (Cursive implementations exported to foreign code) or omit bodies (foreign implementations imported to Cursive code):

```cursive
// Foreign import (no body)
[[extern(C)]]
procedure malloc(size: usize): *mut u8
    [[ ffi::call, unsafe::ptr |- size > 0 => result != null ]]

// Cursive export to C (with body)
[[extern(C)]]
public procedure cursive_add(a: i32, b: i32): i32
    [[ |- true => true ]]
{
    result a + b
}
```

#### §15.1.3 Constraints

[1] _Extern attribute requirement._ Procedures declared with `[[extern(...)]]` shall specify a valid calling convention string. Invalid conventions produce diagnostic E14-001. The calling convention shall be one of: `"C"`, `"stdcall"`, `"fastcall"`, `"system"`, or an implementation-defined platform-specific convention documented by the implementation.

[2] _FFI-safe type restriction._ Extern procedure signatures shall use only FFI-safe types (§14.1.4). Non-FFI-safe types in extern signatures produce diagnostic E14-002. FFI-safe types include:

- Primitive integer types: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
- Primitive floating-point types: `f32`, `f64`
- Boolean type: `bool` (represented as `u8` in FFI)
- Unit type: `()` (represented as C `void`)
- Raw pointers: `*const T`, `*mut T` where `T` is FFI-safe
- Records with `[[repr(C)]]` attribute
- Enums with `[[repr(C)]]` attribute
- Function pointers with extern calling conventions

[3] _Grant requirements._ Extern procedures shall declare the `ffi::call` grant in their contractual sequent. Foreign procedures accepting or returning pointers shall additionally declare `unsafe::ptr`. Omitting required grants produces diagnostic E14-003.

[4] _Visibility requirements._ Extern procedures with bodies (exports) shall be declared `public` to be callable from foreign code. Non-public extern procedures with bodies produce diagnostic E14-004 with note suggesting either making the procedure public or removing the extern attribute.

[5] _No variadic support._ Cursive does not support calling C variadic functions (e.g., `printf`) directly. Extern signatures shall not include ellipsis (`...`) or variadic parameters. Attempting to declare variadic extern procedures produces diagnostic E14-005.

[ Note: Users requiring variadic C function calls should wrap them in non-variadic C helper functions that accept explicit parameters. For example, instead of calling `printf` directly, create a C wrapper `printf_int(format, value)` that calls `printf` internally.
— end note ]

[6] _Body requirements._ Extern procedures without bodies (foreign imports) are declarations only; they shall be defined externally and linked at link time. Extern procedures with bodies (Cursive exports) shall provide complete implementations following standard procedure semantics (Clause 4 §4.4).

[7] _Permission stripping._ Extern procedure parameters and return types shall not include permission qualifiers (`const`, `unique`, `shared`). Permissions are Cursive-specific and have no C representation. Using permissions in extern signatures produces diagnostic E14-006.

[8] _Modal type prohibition._ Extern signatures shall not use modal types (state-annotated types like `File@Open`) or safe modal pointers (`Ptr<T>@Valid`). Modal states are Cursive-specific and cannot be represented in foreign ABIs. Violations produce diagnostic E14-007.

[9] _No captures for extern procedures._ Extern procedures shall not capture variables from enclosing scopes. Closures cannot be declared as extern. Violations produce diagnostic E14-008.

[10] _Unwind attribute placement._ The `unwind(...)` attribute may only appear on extern procedures. Using it on non-extern procedures produces diagnostic E14-009.

#### §15.1.4 FFI-Safe Types

##### §15.1.4.1 Definition

[11] A type is _FFI-safe_ when it has a defined representation compatible with foreign calling conventions and can be passed across language boundaries without special handling.

##### §15.1.4.2 FFI-Safe Type Catalog

[12] The following types are FFI-safe:

**Primitive types** (§7.2):

- All integer types: `i8`, `i16`, `i32`, `i64`, `i128`, `isize`, `u8`, `u16`, `u32`, `u64`, `u128`, `usize`
- Floating-point types: `f32` (as C `float`), `f64` (as C `double`)
- Boolean: `bool` (represented as C `uint8_t` with values 0 or 1)
- Unit: `()` (represented as C `void`)

**Pointer types** (§7.5):

- Raw pointers: `*const T`, `*mut T` where `T` is FFI-safe
- Function pointers with extern calling conventions: `[[extern(C)]] procedure(...): T`

**Composite types with repr(C)** (§15.3.2):

- Records: `[[repr(C)]] record Name { ... }` with FFI-safe fields
- Enums: `[[repr(C)]] enum Name { ... }` with explicit discriminant representation

**Never type**:

- `!` (represented as C `void` in return position, indicates non-returning function)

##### §15.1.4.3 Non-FFI-Safe Types

[13] The following types are **not** FFI-safe and shall not appear in extern signatures:

- String types: `string@Managed`, `string@View` (use `*const u8` with `[[null_terminated]]` instead)
- Safe pointers: `Ptr<T>@State` (use raw pointers `*const T`, `*mut T` instead)
- Modal types: `Type@State` (no foreign equivalent)
- Witness types: `witness<B>` (no foreign equivalent)
- Union types: `T \/ U` (use repr(C) enum instead)
- Slices: `[T]` (use pointer + length pair in repr(C) struct)
- Arrays without repr(C): `[T; n]` alone is not guaranteed FFI-safe without repr(C) on containing struct
- Tuples: `(T, U)` (no guaranteed C layout, use repr(C) struct instead)
- Permission-qualified types: `const T`, `unique T`, `shared T` (permissions are Cursive-only)

##### §15.1.4.4 Type Compatibility Checking

[14] The compiler shall enforce FFI-safe type requirements at compile time:

[ Given: Extern procedure signature with parameter type $\tau$ or return type $\tau$ ]

$$
\frac{\tau \in \text{FFISafeTypes}}
     {\text{extern signature valid}}
\tag{WF-FFI-Type-Safe}
$$

[15] When $\tau \notin \text{FFISafeTypes}$, the compiler shall emit diagnostic E14-002 identifying the non-FFI-safe type and suggesting FFI-safe alternatives.

#### §15.1.5 Grant and Contract Requirements

##### §15.1.5.1 FFI Grants

[16] Extern procedures require explicit capability grants documenting their foreign interactions:

**Required grants**:

- `ffi::call`: Required for all extern procedure declarations and calls
- `unsafe::ptr`: Required when signature includes raw pointers
- `panic`: Required for extern procedures that may panic (if `unwind(catch)` specified)

[17] **Grant checking rule**:

[ Given: Extern procedure with signature including pointers ]

$$
\frac{\text{extern signature uses } *\text{const } T \text{ or } *\text{mut } T}
     {\text{sequent shall include } \texttt{ffi::call} \cup \texttt{unsafe::ptr}}
\tag{WF-FFI-Grant-Ptr}
$$

[18] Missing grants produce diagnostic E14-003 listing required grants.

##### §15.1.5.2 Contractual Sequents on Extern Procedures

[19] Extern procedures should declare contractual sequents documenting:

- **Grants**: Capabilities required (ffi::call, unsafe::ptr, etc.)
- **Preconditions**: Caller obligations (pointer validity, null checks, alignment)
- **Postconditions**: Foreign function guarantees (return value properties, side effects)

[20] Sequents on extern procedures serve as machine-readable documentation of foreign function contracts. The compiler cannot verify foreign code satisfies these contracts; programmers assume responsibility.

**Example 15.1.5.1 (Extern contracts):**

```cursive
[[extern(C)]]
procedure malloc(size: usize): *mut u8
    [[
        ffi::call, unsafe::ptr
        |-
        size > 0
        =>
        (result != null) \/ (result == null)
    ]]

[[extern(C)]]
procedure free(ptr: *mut u8)
    [[
        ffi::call, unsafe::ptr
        |-
        ptr != null
        =>
        true
    ]]
```

#### §15.1.6 Calling Foreign Functions

[21] Calls to extern procedures require `unsafe` blocks (§11.8) because the compiler cannot verify foreign code maintains Cursive invariants:

```cursive
let ptr: *mut u8 = unsafe {
    malloc(1024)  // FFI call in unsafe block
}

unsafe {
    free(ptr)
}
```

[22] **Call site requirements**:

(22.1) All calls to extern procedures shall occur within `unsafe` blocks. Calling extern procedures outside unsafe produces diagnostic E14-010.

(22.2) Caller's grant clause shall include all grants required by the extern procedure's sequent. Missing grants produce diagnostic E10-030 (standard grant checking, Clause 10).

(22.3) Preconditions in the extern procedure's sequent shall be satisfied at the call site. The compiler performs standard precondition checking (§11.7) but cannot verify the foreign implementation respects postconditions.

#### §15.1.7 Exporting Cursive Procedures to Foreign Code

[23] Cursive procedures marked with `[[extern(C)]]` and providing bodies are exported for foreign code to call:

**Example 15.1.7.1 (Cursive export to C):**

```cursive
[[extern(C)]]
public procedure cursive_compute(x: i32, y: i32): i32
    [[ |- x > 0, y > 0 => result > 0 ]]
{
    result x * y + x + y
}
```

[24] **Export requirements**:

(24.1) Exported procedures shall be declared `public` (visible for export).

(24.2) Exported procedures shall have FFI-safe signatures (primitives, raw pointers, repr(C) types only).

(24.3) Exported procedures should be pure or have minimal grants. Foreign code cannot provide grants; complex Cursive operations (I/O, allocation) may fail when called from foreign contexts.

(24.4) Exported procedures shall not panic unless `unwind(catch)` is specified. The default `unwind(abort)` causes process termination on panic (§15.2.4).

#### §15.1.8 Unwind Behavior

[25] The `unwind` attribute controls panic behavior when extern procedures are called from foreign code:

**unwind(abort)** (default):
[26] If a panic occurs while executing an extern procedure called from foreign code, the process aborts immediately. Unwinding does not cross the FFI boundary into foreign stack frames.

$$
\frac{\text{extern proc called from foreign} \quad \text{panic occurs}}
     {\text{process aborts (never unwinds into foreign code)}}
\tag{E-FFI-Unwind-Abort}
$$

**unwind(catch)**:
[27] Panics are caught at the FFI boundary. The extern procedure returns via a designated error path (union return type or error code). Implementations shall document how caught panics map to return values.

**Example 15.1.8.1 (Unwind behavior):**

```cursive
// Default: abort on panic
[[extern(C)]]
public procedure may_panic(x: i32): i32
    [[ panic |- true => true ]]
{
    if x < 0 {
        panic("negative value")  // Aborts process if called from C
    }
    result x * 2
}

// Explicit catch: return error code
[[extern(C), unwind(catch)]]
public procedure safe_ffi(x: i32): i32 \/ i32
    [[ panic |- true => match result { _: i32 => true, err: i32 => err == -1 } ]]
{
    if x < 0 {
        panic("negative")  // Caught; returns -1
    }
    result x * 2
}
```

[28] When `unwind(catch)` is specified, the return type should be a union accommodating both success values and panic-error indicators. The mapping from panic to error value is implementation-defined.

#### §14.1.9 Diagnostics

[29] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.14. — end note]

#### §15.1.10 Safety Obligations

[30] Programmers using FFI assume the following safety obligations:

##### §15.1.10.1 Pointer Validity

[31] **Obligation**: Pointers passed to or returned from foreign functions must be valid:

- Non-null (unless null is explicitly permitted by contract)
- Properly aligned for the pointed-to type
- Point to initialized memory (for reads)
- Point to live storage (not freed or out of scope)

[32] **Violation consequences**: Passing invalid pointers to foreign functions or dereferencing invalid pointers returned from foreign functions produces undefined behavior [UB-ID: B.2.01].

##### §15.1.10.2 Memory Ownership

[33] **Obligation**: Clarify memory ownership at FFI boundaries:

- Pointers passed to foreign functions: Foreign code shall not free memory unless contract specifies ownership transfer
- Pointers returned from foreign functions: Cursive code must free memory if contract specifies ownership transfer (via explicit free call or wrapper)

[34] Foreign functions returning allocated memory shall document ownership in postconditions:

```cursive
[[extern(C)]]
procedure malloc(size: usize): *mut u8
    [[
        ffi::call, unsafe::ptr
        |-
        size > 0
        =>
        result != null \/ result == null,
        result != null => caller_must_free(result)
    ]]
```

[35] The predicate `caller_must_free(result)` is documentation; the compiler cannot enforce it. Programmers must manually call `free(result)` before the pointer goes out of scope.

##### §15.1.10.3 Thread Safety

[36] **Obligation**: Foreign functions accessed from multiple Cursive threads must be thread-safe. The compiler cannot verify foreign code thread safety.

[37] Permissions are Cursive-specific and do not cross FFI boundaries. At the FFI boundary:

- Cursive `const` → C does not see permission (just pointer)
- Cursive `unique` → C does not see exclusivity guarantee
- Cursive `shared` → C does not see coordination requirement

[38] Programmers must ensure foreign code respects Cursive semantics documented in contracts. If a foreign function is documented as thread-safe, Cursive code may call it concurrently; otherwise, Cursive code must serialize access.

##### §15.1.10.4 Panic Safety

[39] **Obligation**: Extern procedures called from foreign code should avoid panicking unless `unwind(catch)` is specified and the return type accommodates error indicators.

[40] Default `unwind(abort)` provides safety (never corrupts foreign stack) but poor debuggability (aborts process). Use `unwind(catch)` for recoverable errors when foreign code can handle error returns.

#### §15.1.11 Examples

**Example 15.1.11.1 (Complete FFI import):**

```cursive
// Import C standard library functions

[[extern(C)]]
procedure strlen(s: *const u8): usize
    [[
        ffi::call, unsafe::ptr
        |-
        s != null, is_null_terminated(s)
        =>
        result >= 0
    ]]

[[extern(C)]]
procedure memcpy(dest: *mut u8, src: *const u8, n: usize): *mut u8
    [[
        ffi::call, unsafe::ptr
        |-
        dest != null,
        src != null,
        n > 0,
        no_overlap(dest, src, n)
        =>
        result == dest
    ]]

procedure safe_strlen(s: string@View): usize
    [[ ffi::call, unsafe::ptr |- s.len() > 0 => result == s.len() ]]
{
    unsafe {
        strlen(s.as_c_ptr())
    }
}
```

**Example 15.1.11.2 (Cursive export to C):**

```cursive
[[extern(C)]]
public procedure add_numbers(a: i32, b: i32): i32
    [[ |- true => result == a + b ]]
{
    result a + b
}

[[extern(C), no_mangle]]
public procedure multiply(x: i32, y: i32): i32
    [[ |- true => true ]]
{
    result x * y
}
// Exported symbol name: exactly "multiply" (no mangling)
```

**Example 15.1.11.3 - invalid (Non-FFI-safe type):**

```cursive
[[extern(C)]]
procedure bad_signature(s: string@View): i32
    [[ ffi::call |- true => true ]]
{
    result s.len() as i32
}
// error[E14-002]: string@View is not FFI-safe
// Use *const u8 with [[null_terminated]] instead
```

**Example 15.1.11.4 - invalid (Permission in signature):**

```cursive
[[extern(C)]]
procedure invalid(data: const Buffer): ()
    [[ ffi::call |- true => true ]]
{
    // error[E14-006]: permission qualifier 'const' in extern signature
}
```

**Example 15.1.11.5 - invalid (Variadic not supported):**

```cursive
[[extern(C)]]
procedure printf(format: *const u8, ...): i32
    [[ ffi::call, unsafe::ptr |- format != null => true ]]
// error[E14-005]: variadic parameters not supported
// Wrap in C helper: printf_int, printf_str, etc.
```

#### §14.1.12 Conformance Requirements

[41] Implementations shall generate correct calling convention code per §14.6 and document safety obligations for FFI users.


### §14.2 FFI-Specific Unsafe Usage [interop.unsafe]

#### §14.2.1 Overview

[1] FFI operations require `unsafe` blocks (§11.8) because foreign code operates outside Cursive's safety guarantees. This subclause specifies the additional unsafe obligations specific to FFI contexts: raw pointer handling, memory lifetime management across language boundaries, and panic unwinding behavior.

[2] While Clause 11 §11.8 defines general unsafe block semantics, this subclause focuses on FFI-specific concerns where Cursive's type system and permission model interact with foreign memory management and calling conventions.

#### §14.2.2 Raw Pointers in FFI Context

##### §14.2.2.1 Pointer Validity Obligations

[3] When passing raw pointers to foreign functions or receiving them as return values, programmers must ensure:

**Passing pointers to foreign code**:
[4] Pointers passed as arguments must be valid for the duration of the foreign call:

```cursive
[[extern(C)]]
procedure c_process(data: *const Data): ()
    [[ ffi::call, unsafe::ptr |- data != null => true ]]

procedure use_ffi()
    [[ ffi::call, unsafe::ptr, alloc::heap |- true => true ]]
{
    let value = Data::new()

    unsafe {
        let ptr: *const Data = &value as *const Data
        c_process(ptr)  // OK: value lives for entire call
    }
    // value destroyed here; ptr would be invalid
}
```

[5] Passing pointers to stack-allocated or region-allocated values requires ensuring the pointed-to memory remains valid for the foreign call's duration.

**Receiving pointers from foreign code**:
[6] Pointers returned from foreign functions have unknown provenance and lifetime:

```cursive
[[extern(C)]]
procedure c_allocate(): *mut Buffer
    [[ ffi::call, unsafe::ptr |- true => result != null \/ result == null ]]

procedure use_foreign_alloc()
    [[ ffi::call, unsafe::ptr |- true => true ]]
{
    let ptr: *mut Buffer = unsafe {
        c_allocate()
    }

    if !ptr.is_null() {
        unsafe {
            (*ptr).use()
            // Programmer responsible for calling c_free(ptr) eventually
        }
    }
}
```

[7] Programmers must manually track foreign-allocated memory and call appropriate cleanup functions (e.g., `free`, foreign destructors).

##### §14.2.2.2 Pointer Alignment

[8] Foreign functions may have alignment requirements. Programmers must ensure passed pointers satisfy alignment constraints:

$$
\frac{\text{foreign func expects alignment } a \quad \text{pointer } p \text{ has alignment } a'}
     {a' \bmod a = 0 \text{ required}}
\tag{FFI-Align-Requirement}
$$

[9] Violating alignment requirements produces undefined behavior [UB-ID: B.2.10]. The compiler cannot verify foreign code alignment requirements; they must be documented in contracts.

**Example 15.2.2.1 (Alignment obligation):**

```cursive
[[extern(C)]]
procedure c_vectorized(data: *const f32): ()
    [[
        ffi::call, unsafe::ptr
        |-
        data != null,
        align_of(data) >= 16  // SSE alignment requirement
        =>
        true
    ]]

procedure call_vectorized(numbers: [f32; 8])
    [[ ffi::call, unsafe::ptr |- true => true ]]
{
    // Ensure array is 16-byte aligned for SSE
    unsafe {
        let aligned_ptr = numbers.as_ptr()  // May not be aligned!
        c_vectorized(aligned_ptr)  // UB if misaligned
    }
}
```

[10] The contract documents alignment requirement; the compiler cannot enforce it. Programmers must use aligned allocation or repr(align(N)) to guarantee alignment.

#### §14.2.3 Memory Lifetime Management

##### §14.2.3.1 Stack Pointers to Foreign Code

[11] Passing stack-allocated data to foreign functions is permitted provided the data remains live for the call duration:

```cursive
procedure pass_stack_value()
    [[ ffi::call, unsafe::ptr |- true => true ]]
{
    let local = 42

    unsafe {
        let ptr: *const i32 = &local as *const i32
        c_function(ptr)  // OK: local lives for call duration
    }
    // local destroyed here
}
```

[12] **Prohibition**: Foreign functions shall not store stack pointers for later use. If a foreign function stores a pointer, the pointed-to data must have static or heap lifetime. Violations produce undefined behavior [UB-ID: B.2.01].

##### §14.2.3.2 Foreign-Allocated Memory

[13] Memory allocated by foreign functions (e.g., C `malloc`) has unknown provenance from Cursive's perspective:

$$
\text{prov}(\text{foreign\_alloc}()) = \text{Foreign}
$$

[14] Foreign-allocated memory does not participate in Cursive's RAII system. Programmers must manually free such memory using appropriate foreign functions:

**Example 15.2.3.1 (Foreign memory management):**

```cursive
[[extern(C)]]
procedure malloc(size: usize): *mut u8
    [[ ffi::call, unsafe::ptr |- size > 0 => result != null \/ result == null ]]

[[extern(C)]]
procedure free(ptr: *mut u8)
    [[ ffi::call, unsafe::ptr |- ptr != null => true ]]

procedure use_c_memory()
    [[ ffi::call, unsafe::ptr |- true => true ]]
{
    let ptr: *mut u8 = unsafe { malloc(1024) }

    if !ptr.is_null() {
        unsafe {
            // Use memory...
            *ptr = 42
        }

        unsafe {
            free(ptr)  // Manual cleanup required
        }
    }
}
```

[15] Failing to free foreign-allocated memory produces memory leaks. Dereferencing freed foreign memory produces undefined behavior [UB-ID: B.2.01].

##### §14.2.3.3 Region-Allocated Data to Foreign Code

[16] **Prohibition**: Region-allocated Cursive values shall not be passed to foreign functions that store pointers for later access. Region lifetimes are Cursive-specific; foreign code cannot respect region destruction:

```cursive
[[extern(C)]]
procedure c_store_pointer(ptr: *const Data)
    [[ ffi::call, unsafe::ptr |- ptr != null => stores_for_later_access(ptr) ]]

procedure invalid_region_pass()
    [[ ffi::call, unsafe::ptr, alloc::region |- true => true ]]
{
    region temp {
        let data = ^Data::new()

        unsafe {
            let ptr: *const Data = &data as *const Data
            c_store_pointer(ptr)  // ⚠️ DANGER: C stores pointer to region memory
        }
    }
    // temp region destroyed - C now has dangling pointer!
}
```

[17] If the contract specifies the foreign function stores pointers, only pass heap-allocated or static data. The compiler cannot enforce this; it is a programmer obligation documented in safety notes.

#### §14.2.4 Panic and Unwinding

##### §14.2.4.1 Default Abort Behavior

[18] By default, panics in extern procedures called from foreign code abort the process:

$$
\frac{\text{[[extern(C)]] proc called from foreign} \quad \text{panic occurs} \quad \text{no unwind attr}}
     {\text{std::process::abort()}}
\tag{E-FFI-Panic-Abort}
$$

[19] Abort prevents unwinding through foreign stack frames, which could corrupt foreign program state. The process terminates immediately without running destructors for foreign-held resources.

##### §14.2.4.2 Catch Behavior

[20] When `[[unwind(catch)]]` is specified, panics are caught at the FFI boundary:

$$
\frac{\text{[[extern(C), unwind(catch)]] proc} \quad \text{panic occurs}}
     {\text{return error value (implementation-defined mapping)}}
\tag{E-FFI-Panic-Catch}
$$

[21] The caught panic shall not propagate into foreign code. The implementation converts the panic into a return value:

- For procedures returning `T \/ ErrorCode`, return the error variant
- For procedures returning primitive integers, return a designated error value (e.g., `-1`, `0`)
- For procedures returning pointers, return null

[22] The exact panic-to-error mapping is implementation-defined and shall be documented. Programmers should use explicit union return types to make error cases clear:

**Example 15.2.4.1 (Catch with explicit error type):**

```cursive
[[extern(C), unwind(catch)]]
public procedure safe_divide(a: i32, b: i32): i32 \/ i32
    [[
        panic
        |-
        true
        =>
        match result {
            quotient: i32 => b != 0,
            error: i32 => error == -1 && b == 0
        }
    ]]
{
    if b == 0 {
        panic("division by zero")  // Caught; returns -1
    }
    result a / b
}
```

#### §14.2.5 Null Pointer Handling

[23] Foreign functions may return null pointers to indicate errors or absence. Cursive provides null checking via raw pointer methods:

```cursive
let ptr: *mut u8 = unsafe { c_allocate() }

if ptr.is_null() {
    // Handle allocation failure
} else {
    unsafe {
        *ptr = 42  // Safe: checked non-null
    }
}
```

[24] **Null dereference**: Dereferencing null pointers produces undefined behavior [UB-ID: B.2.01]. Programmers must check pointers before dereferencing.

[25] Contracts may document null return conditions:

```cursive
[[extern(C)]]
procedure maybe_allocate(size: usize): *mut u8
    [[
        ffi::call, unsafe::ptr
        |-
        size > 0
        =>
        result != null \/ (result == null && allocation_failed())
    ]]
```

#### §14.2.6 Calling Convention Mismatch

[26] **Obligation**: Extern procedure calling conventions must match foreign function expectations. Mismatched calling conventions produce undefined behavior [UB-ID: B.2.53].

```cursive
// C function uses stdcall convention on Windows
[[extern(stdcall)]]  // MUST match C declaration
procedure WindowsAPI(hwnd: *mut (),  message: u32): i32
    [[ ffi::call, unsafe::ptr |- true => true ]]
```

[27] The compiler generates code for the specified calling convention but cannot verify the foreign function actually uses that convention. Programmers must ensure correctness.

#### §14.2.7 Data Races Across FFI

[28] **Obligation**: Foreign functions accessed from multiple threads must be thread-safe. Cursive's permission system does not apply to foreign code:

```cursive
[[extern(C)]]
procedure c_global_counter(): i32
    [[ ffi::call |- true => true ]]

// If c_global_counter uses global state without synchronization:
// Calling from multiple Cursive threads produces data race
```

[29] Thread safety is a contractual obligation documented in sequents. The compiler cannot verify foreign thread safety.

#### §14.2.8 Diagnostics

[30] FFI unsafe usage diagnostics:

| Code    | Condition                                   | Section |
| ------- | ------------------------------------------- | ------- |
| E15-020 | Dereference of potentially null FFI pointer | [24]    |
| E15-021 | FFI call with mismatched calling convention | [26]    |
| E15-022 | Region pointer passed to storing FFI        | [17]    |

Diagnostics E15-020 through E15-022 are quality-of-implementation warnings; violations produce UB but may not be detectable statically.

#### §14.2.9 Conformance Requirements

[31] Implementations shall:

1. Require unsafe blocks for all FFI pointer operations
2. Document panic behavior (abort vs catch) clearly
3. Implement `unwind(abort)` and `unwind(catch)` per §15.2.4
4. Generate calling convention code matching [[extern(...)]] specification
5. Document safety obligations for FFI users in implementation guide
6. Warn about common FFI pitfalls (null derefs, lifetime issues) as quality-of-implementation feature
7. Preserve Cursive panic messages when catching (for debugging)


### §14.3 C Compatibility [interop.c]

#### §14.3.1 Overview

[1] C compatibility enables Cursive programs to interoperate with C libraries and system APIs. This subclause specifies type representation compatibility through the `repr(C)` attribute, string conversion mechanisms, function pointer compatibility, and the restrictions inherent in C interoperability.

[2] C compatibility is achieved through explicit opt-in: types must be marked `[[repr(C)]]` to guarantee C-compatible layout. This ensures Cursive's native layout optimizations do not break FFI while maintaining zero-cost abstractions for non-FFI code.

#### §14.3.2 Type Representation Compatibility

##### §14.3.2.1 The repr(C) Attribute

[3] The `[[repr(C)]]` attribute instructs the compiler to lay out a type using C-compatible rules, matching the pattern:

```
"[[" "repr" "(" "C" ")" "]]"
```

[ Note: See §1.4.3 [intro.attributes] for the general attribute grammar.
— end note ]

[4] repr(C) may be applied to records and enums. It guarantees the type's memory layout matches what a C compiler would produce on the target platform.

**Example 15.3.2.1 (repr(C) record):**

```cursive
[[repr(C)]]
public record Point {
    x: f32,
    y: f32,
}

// Guaranteed C-compatible:
// struct Point {
//     float x;
//     float y;
// };
```

##### §14.3.2.2 repr(C) Padding Rules

[5] Records with `[[repr(C)]]` follow platform C compiler padding rules:

- Fields laid out in declaration order
- Padding inserted between fields to satisfy alignment
- Tail padding ensures struct size is multiple of alignment
- Padding bytes have indeterminate values

[6] **Automatic padding** (Decision D15): The compiler automatically inserts padding matching the platform's C compiler. Programmers need not calculate padding manually.

[7] **Manual padding** (optional): For complete control, programmers may insert explicit padding fields:

**Example 15.3.2.2 (Explicit padding fields):**

```cursive
[[repr(C)]]
record ExplicitPadding {
    a: u8,
    _pad1: [u8; 3],    // Explicit padding (3 bytes)
    b: i32,
    c: u8,
    _pad2: [u8; 3],    // Explicit tail padding
}
// Total size: 12 bytes, alignment: 4
```

[8] Explicit padding fields provide documentation and ensure exact layout matching legacy C structures with unusual padding.

##### §14.3.2.3 repr(C) Enum Representation

[9] Enums with `[[repr(C)]]` require explicit discriminant type specification:

```cursive
[[repr(C, tag_type = "u32")]]
enum Status {
    Idle = 0,
    Running = 1,
    Complete = 2,
}

// C equivalent:
// enum Status {
//     STATUS_IDLE = 0,
//     STATUS_RUNNING = 1,
//     STATUS_COMPLETE = 2,
// };
```

[10] The `tag_type` specifies the discriminant representation. Valid tag types: `u8`, `u16`, `u32`, `u64`, `i8`, `i16`, `i32`, `i64`.

[11] Enums without explicit discriminant values are assigned sequentially from 0. Explicit values may be assigned using `= N` syntax.

[ Rationale: Tuple-records are not FFI-safe because C does not have a direct equivalent and their layout, even with `repr(C)`, is not guaranteed to be compatible across different C compilers and platforms. Standard `record` types with `repr(C)` provide the necessary layout stability for reliable FFI. — end rationale ]

##### §14.3.2.4 repr(C) Restrictions

[12] Types marked `[[repr(C)]]` shall satisfy:

(12.1) All fields have FFI-safe types (primitives, raw pointers, other repr(C) types)

(12.2) No fields with permissions (`const`, `unique`, `shared`) - use raw types instead

(12.3) No modal states - C has no state machine representation

(12.4) No union types (`T \/ U`) - use repr(C) enum with explicit variants instead

[13] Violations produce diagnostic E15-030 identifying the non-C-compatible field.

#### §14.3.3 String Conversion

##### §14.3.3.1 Null-Terminated String Attribute

[14] C strings are null-terminated byte arrays. The `[[null_terminated]]` attribute documents this requirement:

```cursive
[[extern(C)]]
procedure c_strlen(s: *const u8 [[null_terminated]]): usize
    [[
        ffi::call, unsafe::ptr
        |-
        s != null, is_null_terminated(s)
        =>
        result >= 0
    ]]
```

[15] The attribute is documentation; the compiler does not insert null terminators automatically. Programmers must ensure passed strings are null-terminated.

##### §14.3.3.2 String Conversion Methods

[16] Converting between Cursive strings and C strings requires explicit methods (standard library, not language built-ins):

**Cursive → C** (Decision D3):

```cursive
let cursive_str: string@View = "hello"

unsafe {
    let c_ptr: *const u8 = cursive_str.as_c_ptr()
    // Returns pointer to null-terminated UTF-8 data
    // Valid for cursive_str's lifetime

    c_function(c_ptr)
}
```

[17] The `as_c_ptr()` method (standard library) ensures null termination and returns a raw pointer. The pointer is valid while the Cursive string lives.

**C → Cursive**:

```cursive
[[extern(C)]]
procedure c_get_string(): *const u8 [[null_terminated]]
    [[ ffi::call, unsafe::ptr |- true => result != null ]]

procedure convert_from_c(): string@Managed
    [[ ffi::call, unsafe::ptr, alloc::heap |- true => true ]]
{
    let c_str: *const u8 = unsafe { c_get_string() }

    // Convert to Cursive string (copies data)
    let cursive_str: string@Managed = unsafe {
        string::from_c_str(c_str)  // Validates UTF-8, copies, adds null check
    }

    result cursive_str
}
```

[18] The `string::from_c_str()` function (standard library) validates UTF-8, copies the null-terminated data, and produces a Cursive `string@Managed`. Invalid UTF-8 produces an error (panic or error return, depending on method variant).

##### §14.3.3.3 String Lifetime Obligations

[19] **Obligation**: Pointers from `as_c_ptr()` are valid only while the source Cursive string lives:

```cursive
let ptr: *const u8 = unsafe {
    let temp: string@View = "temporary"
    temp.as_c_ptr()
    // ⚠️ DANGER: temp destroyed, ptr is dangling!
}
```

[20] To pass strings with extended lifetime, use static strings or managed strings that outlive the FFI call:

```cursive
let managed: string@Managed = string::from("persistent")

unsafe {
    let ptr: *const u8 = managed.as_c_ptr()
    c_function(ptr)  // OK: managed outlives call
}
```

#### §14.3.4 Function Pointers and Callbacks

##### §14.3.4.1 Extern Procedure Pointers

[21] Only procedures declared with `[[extern(C)]]` can be used as C function pointers:

```cursive
[[extern(C)]]
procedure cursive_callback(value: i32): i32
    [[ |- value >= 0 => result >= value ]]
{
    result value + 1
}

[[extern(C)]]
procedure register_callback(cb: [[extern(C)]] procedure(i32): i32)
    [[ ffi::call |- cb != null => true ]]

procedure use_callback()
    [[ ffi::call |- true => true ]]
{
    unsafe {
        register_callback(cursive_callback)  // OK: both extern(C)
    }
}
```

[22] **Restriction** (Decision D4): Only procedures explicitly declared `[[extern(C)]]` can be passed as C function pointers. Regular Cursive procedures, including non-capturing closures, cannot be converted to C callbacks. Attempting conversion produces diagnostic E15-040.

##### §14.3.4.2 Function Pointer Types

[23] Function pointer types in FFI contexts use extern calling convention:

```cursive
type CCallback = [[extern(C)]] procedure(i32): i32

[[repr(C)]]
record Handler {
    callback: CCallback,
    context: *mut (),
}
```

[24] Function pointers without extern declarations are not FFI-compatible.

##### §14.3.4.3 Callback Safety Obligations

[25] **Obligation**: Cursive callbacks called from C code must not:

- Panic (unless using `unwind(catch)` and C code handles errors)
- Access Cursive-specific features (regions, witnesses, contracts) that C cannot understand
- Capture Cursive closures (C cannot manage captured environments)
- Return non-FFI-safe types

[26] Callbacks should be pure or have minimal effects. Complex Cursive operations may fail when invoked from foreign contexts without grant availability.

#### §14.3.5 Size and Alignment Compatibility

[27] repr(C) types guarantee size and alignment match C:

$$
\text{sizeof}_{\text{Cursive}}(\text{repr(C) } T) = \text{sizeof}_{\text{C}}(T)
$$

$$
\text{alignof}_{\text{Cursive}}(\text{repr(C) } T) = \text{alignof}_{\text{C}}(T)
$$

[28] Implementations shall ensure repr(C) types have identical layout to equivalent C structures compiled with the platform's C compiler.

**Example 15.3.5.1 (Platform C compatibility):**

```cursive
[[repr(C)]]
record sockaddr_in {
    sin_family: u16,
    sin_port: u16,
    sin_addr: u32,
    sin_zero: [u8; 8],
}

// Matches C: struct sockaddr_in from <netinet/in.h>
// Size: 16 bytes, Alignment: 4 bytes (on typical platforms)
```

#### §14.3.6 Constraints

[1] _repr(C) field types._ All fields in a repr(C) record shall have FFI-safe types. Non-FFI-safe fields produce diagnostic E15-030.

[2] _Discriminant specification._ repr(C) enums shall specify `tag_type`. Missing tag_type produces diagnostic E15-031.

[3] _Callback signature compatibility._ Function pointers in extern contexts shall use extern calling conventions. Non-extern function types produce diagnostic E15-040.

[4] _String conversion requirement._ Cursive strings shall not appear directly in extern signatures. Use `*const u8` with `[[null_terminated]]` attribute instead. Violations produce diagnostic E15-002 (non-FFI-safe type).

#### §14.3.7 Examples

**Example 15.3.7.1 (Complete C interop scenario):**

```cursive
// C header: example.h
// void process_data(const char *name, int32_t value);
// struct Point { float x; float y; };
// void draw_point(const struct Point *p);

// Cursive declarations:

[[repr(C)]]
public record Point {
    x: f32,
    y: f32,
}

[[extern(C)]]
procedure process_data(name: *const u8 [[null_terminated]], value: i32)
    [[ ffi::call, unsafe::ptr |- name != null => true ]]

[[extern(C)]]
procedure draw_point(p: *const Point)
    [[ ffi::call, unsafe::ptr |- p != null => true ]]

procedure use_c_library()
    [[ ffi::call, unsafe::ptr |- true => true ]]
{
    let name: string@View = "example"
    let point = Point { x: 10.0, y: 20.0 }

    unsafe {
        process_data(name.as_c_ptr(), 42)
        draw_point(&point as *const Point)
    }
}
```

**Example 15.3.7.2 - invalid (Non-repr(C) in FFI):**

```cursive
record RegularPoint {  // No repr(C)!
    x: f32,
    y: f32,
}

[[extern(C)]]
procedure bad_draw(p: *const RegularPoint)
    [[ ffi::call, unsafe::ptr |- p != null => true ]]
// error[E15-030]: RegularPoint is not repr(C)
```

#### §14.3.8 Conformance Requirements

[29] Implementations shall:

1. Support `[[repr(C)]]` attribute on records and enums
2. Generate C-compatible layouts matching platform C compiler
3. Follow platform C padding and alignment rules
4. Support explicit padding fields for exact layout control
5. Require `tag_type` specification for repr(C) enums
6. Enforce FFI-safe type restrictions for repr(C) fields
7. Provide `as_c_ptr()` and `from_c_str()` string conversion (standard library)
8. Document platform-specific C layout details (padding, alignment, sizes)
9. Emit diagnostics E15-030, E15-031, E15-040 for C compatibility violations


### §14.4 Platform-Specific Features [interop.platform]

#### §14.4.1 Overview

[1] Platform-specific features enable Cursive programs to access platform-dependent capabilities: inline assembly (future edition), SIMD intrinsics (future edition), and platform-conditional compilation. This subclause specifies the mechanisms for handling platform variability while maintaining portability where possible.

[2] Cursive's approach to platform-specific code emphasizes explicit opt-in through compile-time evaluation rather than preprocessor directives or attributes. This maintains the language's "execution over declaration" philosophy.

#### §14.4.2 Platform-Conditional Compilation

##### §14.4.2.1 Comptime Platform Queries

[3] Platform-specific code uses comptime blocks with platform queries (Decision D9):

```cursive
comptime {
    if platform::os() == "linux" {
        // Linux-specific declarations
        codegen::declare_extern(
            calling_convention: "C",
            name: "epoll_create",
            params: [(id: "maxevents", ty: codegen::type_i32())],
            return_ty: codegen::type_i32()
        )
    } else if platform::os() == "windows" {
        // Windows-specific declarations
        codegen::declare_extern(
            calling_convention: "stdcall",
            name: "CreateIoCompletionPort",
            params: [
                (id: "handle", ty: codegen::type_ptr()),
                // ...
            ],
            return_ty: codegen::type_ptr()
        )
    }
}
```

[4] Platform queries are available in comptime contexts only. Runtime platform detection uses standard library facilities, not language features.

##### §14.4.2.2 Available Platform Queries

[5] The `platform` module (provided by comptime environment) offers:

**OS detection**:

```cursive
platform::os(): string@View
// Returns: "linux", "windows", "macos", "freebsd", etc.
```

**Architecture detection**:

```cursive
platform::arch(): string@View
// Returns: "x86_64", "aarch64", "x86", "arm", etc.
```

**Pointer width**:

```cursive
platform::pointer_width(): usize
// Returns: 32, 64, etc.
```

**Endianness**:

```cursive
platform::endian(): string@View
// Returns: "little", "big"
```

[6] Complete platform query APIs are specified in Clause 16 §16.2 [comptime.reflection].

##### §14.4.2.3 Comptime Code Generation

[7] Platform-specific declarations use the `codegen` API (Clause 16 §16.3):

```cursive
comptime {
    let os = platform::os()

    match os {
        "linux" => {
            codegen::declare_extern(
                calling_convention: "C",
                name: "pthread_create",
                // ...
            )
        }
        "windows" => {
            codegen::declare_extern(
                calling_convention: "stdcall",
                name: "CreateThread",
                // ...
            )
        }
        _ => {
            // Fallback or error
            codegen::error("Unsupported platform: {}", os)
        }
    }
}
```

[8] The `codegen` API generates FFI declarations at compile time based on platform characteristics.

#### §14.4.3 Inline Assembly (Future Edition)

[9] Inline assembly is deferred to a future edition of this specification (Decision D6).

[ Note: Cursive version 1.0 does not support inline assembly. Users requiring assembly code should:

1. Write assembly in separate `.s` or `.asm` files and link them, OR
2. Wrap assembly in C functions and call via FFI, OR
3. Use platform-specific intrinsics when available (future feature)

Future editions (v1.1+) may introduce inline assembly with syntax like:

```cursive
procedure atomic_fence()
    [[ unsafe::asm |- true => true ]]
{
    unsafe {
        asm! {
            template: "mfence",
            clobbers: ["memory"],
        }
    }
}
```

The exact syntax and semantics will be designed based on field experience and community feedback, ensuring the feature aligns with Cursive's explicit and safe-by-default philosophy.
— end note ]

#### §14.4.4 SIMD Intrinsics (Future Edition)

[10] SIMD (Single Instruction Multiple Data) intrinsics are deferred to a future edition.

[ Note: SIMD support is planned for future editions. The design will likely use:

- Explicit vector types: `v128`, `v256` (bit-width types)
- Intrinsic functions in `simd::` namespace
- Platform-conditional availability via comptime queries

Example (future):

```cursive
comptime {
    if platform::has_feature("avx2") {
        codegen::import_intrinsics("simd::avx2")
    }
}

procedure vectorized_add(a: v256, b: v256): v256
    [[ unsafe::simd |- true => true ]]
{
    result simd::avx2::add_ps(a, b)
}
```

Design will be finalized in v1.1+ based on implementation experience.
— end note ]

#### §14.4.5 Platform-Specific Attributes

[11] Platform-specific attributes are implementation-defined extensions. Implementations may provide attributes for:

- Target-specific optimizations: `[[target_feature("+avx2")]]`
- Calling conventions: `[[extern("vectorcall")]]` (Windows)
- Memory layout: `[[repr(align(64))]]` for cache-line alignment

[12] Implementation-defined attributes shall be documented in implementation guides and shall not alter standard language semantics beyond their documented effects.

#### §14.4.6 Diagnostics

[13] Platform feature diagnostics:

| Code    | Condition                                         | Section |
| ------- | ------------------------------------------------- | ------- |
| E15-050 | Platform query used outside comptime context      | [3]     |
| E15-051 | Inline assembly attempted (not supported in v1.0) | [9]     |
| E15-052 | SIMD intrinsic attempted (not supported in v1.0)  | [10]    |
| E15-053 | Unsupported platform-specific attribute           | [11]    |

#### §14.4.7 Examples

**Example 15.4.7.1 (Platform-conditional extern declarations):**

```cursive
// Platform-specific system calls

comptime {
    if platform::os() == "linux" {
        codegen::emit("""
            [[extern(C)]]
            procedure open(path: *const u8 [[null_terminated]], flags: i32): i32
                [[ ffi::call, unsafe::ptr |- path != null => true ]]
        """)
    } else if platform::os() == "windows" {
        codegen::emit("""
            [[extern(stdcall)]]
            procedure CreateFileA(
                filename: *const u8 [[null_terminated]],
                access: u32,
                share_mode: u32,
                security: *const (),
                creation: u32,
                flags: u32,
                template: *const ()
            ): *mut ()
                [[ ffi::call, unsafe::ptr |- filename != null => true ]]
        """)
    }
}
```

**Example 15.4.7.2 (Platform-specific constants):**

```cursive
let PATH_SEPARATOR: const string@View = comptime {
    if platform::os() == "windows" {
        result "\\"
    } else {
        result "/"
    }
}
```

#### §14.4.8 Conformance Requirements

[14] Implementations shall:

1. Provide `platform::os()`, `platform::arch()`, `platform::pointer_width()`, `platform::endian()` in comptime contexts
2. Support comptime-based platform-conditional code generation
3. Document all implementation-defined platform-specific attributes
4. Reserve inline assembly and SIMD for future editions
5. Emit diagnostic E15-051 if inline assembly is attempted
6. Emit diagnostic E15-052 if SIMD intrinsics are attempted
7. Integrate platform queries with Clause 16 comptime evaluation


### §14.5 Linkage and Symbol Visibility [interop.linkage]

#### §14.5.1 Overview

[1] Linkage determines whether a symbol (the name of an entity) is visible across compilation unit boundaries in the compiled binary and at link time. Linkage is distinct from but related to visibility: visibility controls compile-time name resolution and access control (§5.6), while linkage controls symbol table entries in compiled binaries and cross-unit linking behavior.

[2] This subclause specifies linkage categories (external, internal, no linkage), the relationship between visibility and linkage, the One Definition Rule (ODR), and linkage control attributes.

#### §14.5.2 Linkage Categories

##### §14.5.2.1 Definition

[3] _Linkage_ is the property of a declared entity that determines whether its symbol appears in the binary symbol table and whether that symbol is visible across compilation unit boundaries.

[4] Every declared entity has exactly one of three linkage categories:

- **External linkage**: Symbol exported in binary, visible across compilation units
- **Internal linkage**: Symbol local to compilation unit or package, not exported
- **No linkage**: No symbol in binary (inline or eliminated)

##### §14.5.2.2 Linkage Determination Rule

[5] Linkage is determined by visibility modifiers and entity kind:

| Visibility | Entity Kind        | Linkage  | Symbol Exported |
| ---------- | ------------------ | -------- | --------------- |
| `public`   | Module-scope       | External | YES             |
| `internal` | Module-scope       | Internal | NO              |
| `private`  | Module-scope       | None     | NO              |
| (any)      | Block-scope (local | ) None   | NO              |
| (any)      | Parameter          | None     | NO              |

[6] **Linkage determination judgment**:

[ Given: Entity $E$ with visibility $V$ and scope $S$ ]

$$
\frac{V = \texttt{public} \quad S = \texttt{module}}
     {\text{linkage}(E) = \texttt{External}}
\tag{Linkage-External}
$$

$$
\frac{V = \texttt{internal} \quad S = \texttt{module}}
     {\text{linkage}(E) = \texttt{Internal}}
\tag{Linkage-Internal}
$$

$$
\frac{V = \texttt{private} \lor S = \texttt{block}}
     {\text{linkage}(E) = \texttt{None}}
\tag{Linkage-None}
$$

#### §14.5.3 External Linkage

##### §14.5.3.1 Definition

[7] An entity has _external linkage_ when its symbol is exported in the compiled binary and can be referenced from other compilation units after linking.

[8] **Properties of external linkage**:

(8.1) Symbol appears in binary's exported symbol table

(8.2) Entity may be referenced from other compilation units via qualified names

(8.3) Name mangling may be applied (§15.5.6) unless overridden by attributes

(8.4) Subject to One Definition Rule across entire program (§15.5.5)

##### §14.5.3.2 External Linkage Example

**Example 15.5.3.1 (External linkage):**

```cursive
// File: math.cursive
public procedure add(x: i32, y: i32): i32
    [[ |- true => true ]]
{
    result x + y
}
// Symbol exported with external linkage
// Binary symbol: _Cursive_math_add (example mangled name)

// File: main.cursive
import math

procedure main(): i32
    [[ |- true => true ]]
{
    let sum = math::add(5, 3)  // Links to external symbol
    result 0
}
```

#### §14.5.4 Internal Linkage

##### §14.5.4.1 Definition

[9] An entity has _internal linkage_ when its symbol may appear in the binary as a local symbol but is not exported for cross-compilation-unit access.

[10] **Properties of internal linkage**:

(10.1) Symbol may appear in binary as local (non-exported) symbol

(10.2) Not accessible from other compilation units outside the package

(10.3) Compiler may inline, optimize, or eliminate as dead code

(10.4) Not subject to ODR across compilation units (may have multiple definitions in different units)

##### §14.5.4.2 Internal Linkage Example

**Example 15.5.4.1 (Internal linkage):**

```cursive
// File: math.cursive
internal procedure helper(x: i32): i32
    [[ |- true => true ]]
{
    result x * 2
}
// Internal linkage: local to this compilation unit

public procedure compute(x: i32): i32
    [[ |- true => true ]]
{
    result helper(x) + 1  // OK: same compilation unit
}

// File: main.cursive
import math

procedure main(): i32
{
    // math::helper(5)  // ERROR: not visible (internal linkage)
    let result = math::compute(5)  // OK: public (external linkage)
    result 0
}
```

#### §14.5.5 One Definition Rule (ODR)

##### §14.5.5.1 ODR for Types

[11] Types with external linkage shall have exactly one definition across the entire program:

[ Given: Program $P$ with type definitions $D_1$, $D_2$ both defining type $T$ ]

$$
\frac{D_1 \neq D_2 \text{ (structurally distinct)} \quad \text{both have external linkage}}
     {\text{ERROR E15-060: Multiple conflicting definitions of } T}
\tag{WF-ODR-Type}
$$

[12] Structural equivalence: Two type definitions are identical when they have the same fields, field types, field order, and representation attributes.

**Example 15.5.5.1 - invalid (ODR violation for types):**

```cursive
// File: types_a.cursive
public record Point {
    x: f64,
    y: f64,
}

// File: types_b.cursive
public record Point {  // Same name
    x: f32,            // Different structure
    y: f32,
}

// ERROR E15-060: Multiple definitions of Point with different structure
```

##### §14.5.5.2 ODR for Procedures

[13] Procedures with external linkage shall have exactly one definition. Multiple declarations (signatures without bodies) are permitted; multiple definitions (with bodies) violate ODR:

[ Given: Procedure definitions $D_1$, $D_2$ both defining procedure $f$ with external linkage ]

$$
\frac{D_1 \text{ has body} \quad D_2 \text{ has body} \quad D_1 \neq D_2}
     {\text{ERROR E15-061: Multiple definitions of procedure } f}
\tag{WF-ODR-Procedure}
$$

[14] **Exception**: Inline procedures and generic procedure instantiations may have multiple definitions. The linker deduplicates identical definitions.

##### §14.5.5.3 ODR Violation Consequences

[15] ODR violations detected at link time produce errors. Undetected violations cause undefined behavior [UB-ID: B.2.54].

#### §14.5.6 Name Mangling

##### §14.5.6.1 Purpose and Mechanism

[16] _Name mangling_ encodes additional information (module path, parameter types, generic arguments) into symbol names to support overloading and avoid naming conflicts.

[17] **Mangling is implementation-defined** (Decision D10): Implementations may apply name mangling to symbols with external linkage. The mangling scheme is implementation-defined and must be documented.

[18] **Optional mangling**: Implementations may choose not to mangle symbols or to provide multiple mangling schemes (e.g., "stable" vs "optimized"). The choice shall be documented and selectable via compiler flags.

[19] **Demangling**: Implementations should provide tooling to demangle symbols for debugging and diagnostics.

##### §14.5.6.2 Mangling Bypass Attributes

[20] The `[[no_mangle]]` attribute disables name mangling:

```cursive
[[no_mangle]]
public procedure exact_symbol_name(): i32
    [[ |- true => true ]]
{
    result 42
}
// Binary symbol: exactly "exact_symbol_name" (no mangling)
```

[21] **Use cases**:

- FFI exports with specific symbol names
- Debugging (predictable symbols)
- Dynamic loading with dlsym/GetProcAddress

##### §14.5.6.3 Extern Implies No Mangle

[22] Procedures marked `[[extern(C)]]` have mangling automatically disabled. The C calling convention expects unmangled symbols:

```cursive
[[extern(C)]]
public procedure c_compatible(): i32
    [[ |- true => true ]]
{
    result 100
}
// Binary symbol: "c_compatible" (extern(C) implies no_mangle)
```

[23] Combining `[[extern(C)]]` with `[[no_mangle]]` is redundant but permitted.

#### §14.5.7 Weak Symbols

##### §14.5.7.1 Definition

[24] The `[[weak]]` attribute declares a weak symbol that may be overridden by a strong symbol with the same name at link time.

```cursive
[[weak]]
public procedure default_handler(msg: string@View)
    [[ io::write |- true => true ]]
{
    println("Default: {}", msg)
}
```

[25] If another compilation unit provides a strong (non-weak) definition of `default_handler`, the strong definition takes precedence. If only weak definitions exist, one is chosen arbitrarily.

##### §14.5.7.2 Platform Dependency

[26] Weak symbol support is platform-dependent:

- **Unix/Linux (ELF)**: Widely supported
- **macOS (Mach-O)**: Supported
- **Windows (PE)**: Limited support

[27] Implementations shall document weak symbol support for target platforms. Using `[[weak]]` on unsupported platforms produces diagnostic E15-070 (warning severity, not error).

##### §14.5.7.3 Use Cases

[28] Weak symbols enable:

- Default implementations overridable by users
- Plugin architectures (plugins provide strong symbols overriding weak defaults)
- Optional dependencies (weak symbols for missing libs fail gracefully)

**Example 15.5.7.1 (Weak symbol for default handler):**

```cursive
// Library provides weak default:
[[weak, no_mangle]]
public procedure custom_allocator(size: usize): *mut u8
    [[ unsafe::ptr, alloc::heap |- size > 0 => true ]]
{
    // Default allocator
    unsafe { system_malloc(size) }
}

// User can override with strong definition:
// (In user code)
[[no_mangle]]
public procedure custom_allocator(size: usize): *mut u8
    [[ unsafe::ptr, alloc::heap |- size > 0 => true ]]
{
    // Custom allocator replaces default
    unsafe { my_allocator(size) }
}
```

#### §14.5.8 Attribute Combinations

[29] Linkage control attributes may be combined subject to constraints:

| Combination             | Valid | Notes                                |
| ----------------------- | ----- | ------------------------------------ |
| `extern(C)`             | ✅    | C calling convention, no mangle      |
| `no_mangle`             | ✅    | Preserve symbol name                 |
| `weak`                  | ✅    | Weak symbol                          |
| `extern(C) + weak`      | ✅    | Weak C-compatible symbol             |
| `no_mangle + weak`      | ✅    | Weak symbol with exact name          |
| `extern(C) + no_mangle` | ⚠️    | Redundant (extern implies no_mangle) |

[30] All linkage attributes require `public` visibility. Using them on non-public declarations produces diagnostic E15-004.

#### §14.5.9 Diagnostics

[31] Linkage diagnostics:

| Code    | Condition                                     | Constraint |
| ------- | --------------------------------------------- | ---------- |
| E15-060 | Multiple definitions of type (ODR violation)  | [11]       |
| E15-061 | Multiple definitions of procedure (ODR)       | [13]       |
| E15-062 | Linkage attribute on non-public entity        | [30]       |
| E15-070 | Weak symbols not supported on target platform | [27]       |

#### §14.5.10 Conformance Requirements

[32] Implementations shall:

1. Determine linkage from visibility and entity kind per Table in §15.5.2.2
2. Export symbols with external linkage in binary symbol table
3. Keep symbols with internal linkage local to compilation unit
4. Omit symbols for entities with no linkage
5. Enforce One Definition Rule for external linkage entities (E15-060, E15-061)
6. Support `[[no_mangle]]` attribute disabling name mangling
7. Support `[[weak]]` attribute on platforms where available
8. Document name mangling scheme (if any) used by implementation
9. Provide demangling tools for debugging
10. Respect `[[extern(C)]]` implying no mangling


### §14.6 ABI Specification [interop.abi]

#### §14.6.1 Overview

[1] The Application Binary Interface (ABI) defines the low-level interface between compiled code modules: calling conventions, register usage, stack layout, data representation, and symbol naming. ABI compliance enables linking Cursive code with foreign code and using system libraries.

[2] Cursive's ABI is platform-specific and implementation-defined. Implementations shall document their ABI choices and ensure consistency with platform conventions (System V ABI, Windows x64 calling convention, ARM AAPCS, etc.).

[3] This subclause specifies ABI requirements for calling conventions, data layout, register allocation, and platform-specific details.

#### §14.6.2 Calling Conventions

##### §14.6.2.1 Overview

[4] _Calling conventions_ define how procedures receive parameters, return results, and manage the call stack. Cursive supports multiple calling conventions via explicit `[[extern(...)]]` attributes (Decision D16).

##### §14.6.2.2 Supported Calling Conventions

[5] Implementations shall support at least the following calling conventions:

**"C" — C calling convention** (mandatory):
[6] The standard C calling convention for the target platform:

- **Linux/Unix**: System V AMD64 ABI (x86-64), ARM AAPCS (ARM64)
- **Windows**: Microsoft x64 calling convention (x86-64), ARM64 calling convention (ARM64)
- **32-bit platforms**: Platform-specific C ABI (cdecl, etc.)

[7] The "C" convention is mandatory for all implementations. It enables calling standard C libraries and system APIs.

**"stdcall"** (Windows platforms):
[8] Windows standard call convention (callee cleans stack on 32-bit, identical to C on 64-bit):

```cursive
[[extern(stdcall)]]
procedure WindowsAPI(param: i32): i32
    [[ ffi::call |- true => true ]]
```

[9] On 64-bit Windows, stdcall is equivalent to the C calling convention. On 32-bit Windows, stdcall differs in stack cleanup responsibility.

**"system"** (platform default):
[10] Use the platform's system calling convention:

- Unix/Linux: Same as "C"
- Windows: Same as "stdcall" (32-bit) or "C" (64-bit)

[11] The "system" convention allows platform-agnostic code when the specific convention doesn't matter.

**Platform-specific conventions** (optional):
[12] Implementations may support additional conventions:

- `"fastcall"`: Fast calling convention (registers for first args)
- `"vectorcall"`: SIMD-optimized convention (Windows)
- `"aapcs"`: ARM Architecture Procedure Call Standard
- `"sysv64"`: Explicit System V AMD64

[13] Platform-specific conventions are implementation-defined. Using unsupported conventions produces diagnostic E15-080.

##### §14.6.2.3 Parameter Passing

[14] Calling conventions specify how parameters are passed:

**System V AMD64 (Linux x86-64)**:

- First 6 integer/pointer args: RDI, RSI, RDX, RCX, R8, R9
- First 8 floating args: XMM0-XMM7
- Remaining args: Stack (right-to-left)

**Microsoft x64 (Windows x86-64)**:

- First 4 integer/pointer args: RCX, RDX, R8, R9
- First 4 floating args: XMM0-XMM3
- Stack shadow space: 32 bytes
- Remaining args: Stack

**ARM64 (AAPCS)**:

- First 8 integer/pointer args: X0-X7
- First 8 floating args: V0-V7
- Remaining args: Stack

[15] Implementations shall follow platform ABI specifications exactly. Deviations produce link errors or undefined behavior.

##### §14.6.2.4 Return Values

[16] Return value conventions:

- **Integer/pointer returns**: Returned in RAX (x86-64), X0 (ARM64), etc.
- **Floating returns**: Returned in XMM0 (x86-64), V0 (ARM64)
- **Large structures**: Returned via hidden pointer parameter (caller allocates space)

[17] The never type `!` indicates non-returning procedures (noreturn attribute in C).

##### §14.6.2.5 Stack Alignment

[18] The call stack shall be aligned per platform ABI:

- **System V AMD64**: 16-byte alignment before call
- **Microsoft x64**: 16-byte alignment before call
- **ARM64**: 16-byte alignment

[19] Implementations shall ensure stack alignment is maintained across FFI boundaries.

#### §14.6.3 Data Layout

##### §14.6.3.1 Primitive Type Representation

[20] Primitive types in FFI contexts use platform C representations:

**Table 15.6.1 — C type mappings**

| Cursive Type | C Type      | Size (64-bit) | Alignment |
| ------------ | ----------- | ------------- | --------- |
| `i8`         | `int8_t`    | 1             | 1         |
| `i16`        | `int16_t`   | 2             | 2         |
| `i32`        | `int32_t`   | 4             | 4         |
| `i64`        | `int64_t`   | 8             | 8         |
| `isize`      | `intptr_t`  | 8             | 8         |
| `u8`         | `uint8_t`   | 1             | 1         |
| `u16`        | `uint16_t`  | 2             | 2         |
| `u32`        | `uint32_t`  | 4             | 4         |
| `u64`        | `uint64_t`  | 8             | 8         |
| `usize`      | `uintptr_t` | 8             | 8         |
| `f32`        | `float`     | 4             | 4         |
| `f64`        | `double`    | 8             | 8         |
| `bool`       | `uint8_t`   | 1             | 1         |
| `()`         | `void`      | 0             | 1         |
| `*const T`   | `const T*`  | 8             | 8         |
| `*mut T`     | `T*`        | 8             | 8         |

[21] On 32-bit platforms, pointer types and `isize`/`usize` are 4 bytes.

##### §14.6.3.2 repr(C) Structure Layout

[22] Records with `[[repr(C)]]` use C structure layout rules:

**Layout algorithm** (Decision D15):

```
For record R { f₁: T₁, ..., fₙ: Tₙ } with [[repr(C)]]:

offset₀ = 0
For i = 1 to n:
    alignᵢ = alignof(Tᵢ)
    offsetᵢ = next_multiple(offsetᵢ₋₁ + sizeof(Tᵢ₋₁), alignᵢ)

total_size = offsetₙ + sizeof(Tₙ)
struct_align = max(align₁, ..., alignₙ)
padded_size = next_multiple(total_size, struct_align)
```

[23] This matches C compilers for the target platform. Implementations shall test repr(C) compatibility against platform C compiler.

**Example 15.6.3.1 (repr(C) layout matching C):**

```cursive
[[repr(C)]]
record Example {
    a: u8,      // Offset 0
    // 3 bytes padding (automatic)
    b: i32,     // Offset 4
    c: u16,     // Offset 8
    // 2 bytes tail padding
}
// Size: 12, Alignment: 4
// Matches: struct Example { uint8_t a; int32_t b; uint16_t c; };
```

#### §14.6.4 Endianness

[24] Integer and floating-point representation endianness follows the target platform:

- **x86/x86-64**: Little-endian
- **ARM64**: Little-endian (typically)
- **Some platforms**: Big-endian or bi-endian

[25] Implementations shall document endianness for each target platform. Cross-platform serialization must handle endianness explicitly (not a language feature).

#### §14.6.5 Platform-Specific ABI Details

##### §14.6.5.1 System V AMD64 ABI (Linux/Unix x86-64)

[26] **Reference**: System V Application Binary Interface AMD64 Architecture Processor Supplement (§1.2.3[12]).

**Key features**:

- Parameter passing: Registers then stack
- Red zone: 128 bytes below stack pointer (leaf functions may use)
- Stack alignment: 16 bytes before call

##### §14.6.5.2 Microsoft x64 Calling Convention (Windows x86-64)

[27] **Reference**: Microsoft x64 Calling Convention documentation (§1.2.3[13]).

**Key features**:

- Parameter passing: First 4 in registers (RCX, RDX, R8, R9)
- Shadow space: 32 bytes on stack for register parameters
- Stack alignment: 16 bytes before call
- No red zone

##### §14.6.5.3 ARM AAPCS (ARM 32-bit and 64-bit)

[28] **Reference**: ARM Architecture Procedure Call Standard.

**Key features**:

- ARM64: X0-X7 for integer args, V0-V7 for float args
- ARM32: R0-R3 for integer args
- Stack alignment: 16 bytes (ARM64), 8 bytes (ARM32)

##### §14.6.5.4 Implementation Obligations

[29] Implementations shall:

(29.1) Document which platform ABIs are supported

(29.2) Ensure extern(C) procedures use correct platform C ABI

(29.3) Provide ABI compliance test suite verifying interoperability with C

(29.4) Document deviations from standard ABIs (if any)

#### §14.6.6 Diagnostics

[30] ABI diagnostics:

| Code    | Condition                         | Section |
| ------- | --------------------------------- | ------- |
| E15-080 | Unsupported calling convention    | [13]    |
| E15-081 | ABI mismatch (incompatible types) | [22]    |
| E15-082 | Stack misalignment detected       | [19]    |

#### §14.6.7 Conformance Requirements

[31] Implementations shall:

1. Support "C" calling convention on all platforms
2. Implement platform-specific calling conventions correctly
3. Follow platform ABI specifications (System V, Microsoft x64, AAPCS)
4. Generate correct register usage and stack layout
5. Maintain stack alignment per platform requirements
6. Document supported calling conventions
7. Document platform ABI choices
8. Ensure repr(C) types match C compiler layouts
9. Provide ABI compatibility test suite


### §14.7 Binary Compatibility [interop.compatibility]

#### §14.7.1 Overview

[1] Binary compatibility determines whether compiled code from different language versions or compiler versions can be linked together and execute correctly. This subclause specifies stable ABI guarantees, breaking vs non-breaking changes, and versioning considerations for binary compatibility.

[2] Cursive aims for source-level compatibility across minor versions (§1.7) but does not guarantee binary compatibility. Binary compatibility is an implementation-defined quality-of-implementation feature that implementations may provide with documented limitations.

#### §14.7.2 ABI Stability

##### §14.7.2.1 No Guaranteed Binary Compatibility

[3] **Normative**: Cursive does not guarantee binary compatibility across:

- Different compiler versions
- Different language versions (even minor versions)
- Different compilation modes (debug vs release)
- Different optimization levels

[4] Source-level compatibility (§1.7) is guaranteed for minor versions; binary compatibility is not. Programs should be recompiled when upgrading compilers or language versions.

##### §14.7.2.2 Implementation-Defined Stability

[5] Implementations may provide binary compatibility guarantees for specific scenarios:

- Stable ABI for a compiler's lifetime
- Compatible binaries within a major language version
- ABI versioning for library distribution

[6] Such guarantees are implementation-defined and shall be documented. Implementations providing stability guarantees shall specify:

(6.1) Which ABI elements are stable (calling convention, type layout, symbol names)

(6.2) Under what conditions compatibility is maintained

(6.3) How ABI breaks are communicated to users

(6.4) Migration strategies when ABI changes

##### §14.7.2.3 Explicit ABI Versioning

[7] Implementations may use ABI version markers in symbol names or metadata:

```
_Cursive_v1_math_add      // ABI version 1
_Cursive_v2_math_add      // ABI version 2 (incompatible)
```

[8] ABI versioning allows multiple versions to coexist in the same binary.

#### §14.7.3 Breaking Changes

##### §14.7.3.1 ABI-Breaking Changes

[9] The following changes break binary compatibility:

**Type layout changes**:

- Changing field order in records
- Changing field types
- Adding or removing fields from repr(C) types
- Changing enum discriminant representation

**Calling convention changes**:

- Changing extern calling convention
- Changing parameter order
- Changing return type

**Symbol changes**:

- Changing name mangling scheme
- Renaming exported symbols (without aliases)
- Changing symbol visibility (public → internal)

[10] Any of these changes require recompilation of all dependent code.

##### §14.7.3.2 Non-Breaking Changes

[11] The following changes do NOT break binary compatibility (when stability is provided):

**Additive changes**:

- Adding new procedures (new symbols)
- Adding new types
- Adding private fields to types without repr(C)
- Adding inline procedure bodies

**Documentation changes**:

- Changing contracts (grants, preconditions, postconditions)
- Changing comments and documentation
- Adding attributes that don't affect ABI

[12] Non-breaking changes allow library updates without recompiling clients (when implementations provide ABI stability).

#### §14.7.4 Separate Compilation

[13] Cursive supports separate compilation: each compilation unit compiles independently to an object file. The linker combines object files, resolves symbols, and produces the final binary.

**Compilation model**:

```
Source files → Compiler → Object files (.o, .obj)
                          ↓
                       Linker
                          ↓
                    Executable or Library
```

[14] **Object file contents**:

- Compiled code for procedures
- Exported symbols (external linkage)
- Local symbols (internal linkage)
- Relocation information
- Debug information (optional)

[15] Object file formats are platform-specific (ELF on Unix, PE on Windows, Mach-O on macOS). Cursive compilers shall generate valid object files for the target platform.

#### §14.7.5 Dynamic Libraries

[16] Cursive code may be compiled into dynamic libraries (shared objects):

- **Linux**: `.so` files
- **Windows**: `.dll` files
- **macOS**: `.dylib` files

[17] Dynamic libraries export symbols with external linkage. Symbol visibility is controlled by linkage and may be further restricted by platform-specific mechanisms (ELF visibility, Windows \_\_declspec(dllexport)).

[18] **Version compatibility**: Dynamic libraries should maintain ABI compatibility across updates to avoid breaking dependent applications. This is an implementation concern; the specification does not mandate versioning schemes.

#### §14.7.6 Static Libraries

[19] Cursive code may be compiled into static libraries (archives):

- **Linux/macOS**: `.a` files (ar archives)
- **Windows**: `.lib` files

[20] Static libraries contain object files that are linked directly into the final binary. ABI compatibility is less critical for static linking (code is relinked each build).

#### §14.7.7 Practical Guidelines

[21] For maximum binary compatibility, libraries should:

**Use stable types**:

- Mark public FFI types with `[[repr(C)]]`
- Avoid changing field order or types
- Use opaque pointers for implementation details

**Use stable symbols**:

- Use `[[no_mangle]]` for critical symbols
- Avoid renaming public APIs
- Provide symbol aliases for renamed functions

**Version conservatively**:

- Use semantic versioning (§1.7)
- Treat ABI changes as major version bumps
- Provide migration guides for breaking changes

**Document ABI**:

- Specify which symbols are stable
- Document calling conventions
- Provide C header files for FFI-exposed APIs

#### §14.7.8 Examples

**Example 15.7.8.1 (Stable library design):**

```cursive
// version 1.0 - Initial stable API

[[repr(C)]]
public record Config {
    version: u32,
    flags: u32,
    // Future: Can add fields at end if documented as ABI-unstable region
}

[[no_mangle, extern(C)]]
public procedure lib_init(config: *const Config): i32
    [[ ffi::call, unsafe::ptr |- config != null => result >= 0 ]]
{
    unsafe {
        if (*config).version != 1 {
            result -1  // Version mismatch
        }
        // Initialize library
        result 0
    }
}

// version 1.1 - Compatible addition

[[no_mangle, extern(C)]]
public procedure lib_init_v2(config: *const Config, options: u32): i32
    [[ ffi::call, unsafe::ptr |- config != null => result >= 0 ]]
{
    // New function - doesn't break v1.0 users
    result lib_init(config)
}
```

**Example 15.7.8.2 (Opaque pointer pattern for ABI stability):**

```cursive
// Opaque handle - implementation details hidden

record ConnectionImpl {
    socket: i32,
    buffer: Buffer,
    state: ConnectionState,
}

[[no_mangle, extern(C)]]
public procedure connection_create(): *mut ()
    [[ ffi::call, unsafe::ptr, alloc::heap |- true => true ]]
{
    let conn = ConnectionImpl::new()
    result &conn as *mut ()  // Opaque pointer to C
}

[[no_mangle, extern(C)]]
public procedure connection_send(handle: *mut (), data: *const u8, len: usize): i32
    [[ ffi::call, unsafe::ptr |- handle != null, data != null => true ]]
{
    unsafe {
        let conn: *mut ConnectionImpl = handle as *mut ConnectionImpl
        (*conn).send(data, len)
    }
}

// C code sees opaque handle; internal structure can change without ABI break
```

#### §14.7.9 Diagnostics

[22] Binary compatibility diagnostics:

| Code    | Condition                                          | Section |
| ------- | -------------------------------------------------- | ------- |
| E14-090 | Link-time symbol conflict (ODR violation detected) | [10]    |
| E14-091 | ABI version mismatch                               | [8]     |
| E14-092 | Incompatible object file format                    | [15]    |

These are link-time or load-time errors, not compile-time.

#### §14.7.10 Conformance Requirements

[23] Implementations shall:

1. Document binary compatibility guarantees (or lack thereof)
2. Follow platform ABI specifications (System V, Windows x64, etc.)
3. Generate valid object files for target platform
4. Support static and dynamic library generation
5. Detect ODR violations at link time when possible
6. Document ABI versioning scheme (if any)
7. Provide tools for symbol inspection and demangling
8. Maintain repr(C) layout compatibility with platform C compiler
9. Warn when ABI-breaking changes occur (quality-of-implementation)


### §15.1 Overview and Integration [comptime.overview]

#### §15.1.1 Scope [comptime.overview.scope]

[1] This clause specifies Cursive's compile-time evaluation and reflection system: mechanisms for executing code during compilation, introspecting type structure, and programmatically generating declarations. The system provides compile-time execution through comptime procedures and blocks, opt-in type reflection, programmatic code generation through explicit APIs, and zero-cost abstraction (no runtime overhead when unused).

#### §15.1.2 Design Principles [comptime.overview.principles]

[2] Cursive's compile-time system adheres to core language principles (§1.9). Comptime code uses an explicit grant system (§11.3.3.9) that permits only compile-time-safe operations. All comptime computation must complete within implementation-defined resource limits.

#### §15.1.3 Integration with Language Features [comptime.overview.integration]

[3] The compile-time system integrates with translation phases, declarations, type system, expressions, generics, memory model, and contracts.


### §15.2 Comptime Procedures [comptime.procedures]

#### §15.2.1 Overview [comptime.procedures.overview]

[1] _Comptime procedures_ are procedures that execute exclusively during compilation. They enable pure, deterministic computation at compile time to produce constants, drive code generation, and perform type introspection.

[2] This subclause extends §8.7 [expr.constant] (constant expressions) and §5.4 [decl.function] (procedure declarations) with the semantics specific to compile-time execution: grant restrictions, purity requirements, and termination guarantees.

[3] Comptime procedures differ from runtime procedures in execution context and permitted operations. They share the same declaration syntax (§5.4) with the addition of the `comptime` keyword modifier.

#### §15.2.2 Syntax [comptime.procedures.syntax]

[4] Comptime procedure syntax extends procedure declarations (§5.4.2):

**Comptime procedure declarations** match the pattern:
```
[ <attributes> ] [ <visibility> ] "comptime" "procedure" <identifier>
    [ <generic_params> ] "(" [ <parameter_list> ] ")" [ ":" <type> ] [ <sequent_clause> ]
    <callable_body>
```

**Callable bodies** take one of the following forms:
```
<block_stmt>
"=" <expression>
```

[ Note: See Annex A §A.6 [grammar.declaration] for the normative `procedure_decl` production with `comptime` modifier.
— end note ]

[5] The `comptime` keyword appears immediately before `procedure`. All other syntax elements (parameters, return types, sequents, bodies) follow standard procedure rules.

[6] Expression-bodied form (`= expression`) is permitted for simple comptime procedures and implies pure sequent `[[ |- true => true ]]`.

#### §15.2.3 Constraints [comptime.procedures.constraints]

##### §15.2.3.1 Grant Restrictions

[7] _Comptime-safe grants only._ Comptime procedures shall declare only compile-time-safe grants in their contractual sequents. The permitted grants are:

- `comptime::alloc` — Compile-time memory allocation
- `comptime::codegen` — Code generation operations
- `comptime::config` — Configuration and platform queries
- `comptime::diag` — Diagnostic emission

[8] **Grant restriction rule:**

[ Given: Comptime procedure with sequent grants $G$ ]

$$
\frac{G \not\subseteq \{\texttt{comptime::alloc}, \texttt{comptime::codegen}, \texttt{comptime::config}, \texttt{comptime::diag}\}}{\text{ERROR E16-001: runtime grant in comptime procedure}}
\tag{WF-Comptime-Grants}
$$

[9] Attempting to declare runtime grants (`alloc::heap`, `fs::read`, `io::write`, `net::connect`, `thread::spawn`, etc.) in comptime procedure sequents produces diagnostic E16-001.

**Example 16.2.3.1 - invalid** (Runtime grant in comptime procedure):

```cursive
comptime procedure read_config_file(): string@View
    [[ fs::read |- true => true ]]  // error[E16-001]
{
    fs::read_to_string("config.toml")
}
```

[1] The `fs::read` grant is a runtime grant and cannot be used in comptime procedures.

##### §15.2.3.2 Purity Requirement

[10] _No observable side effects._ Comptime procedures shall be pure: they may not perform operations with observable runtime side effects beyond code generation (which is controlled by the `comptime::codegen` grant).

[11] Prohibited operations in comptime procedures:

- File system operations (reading/writing files)
- Network operations
- Process spawning or termination
- Accessing mutable static variables
- FFI calls
- Unsafe operations (except comptime-safe transmute for type conversions)

[12] Attempting prohibited operations produces diagnostic E16-002 identifying the specific violation.

##### §15.2.3.3 Termination Requirement

[13] _Bounded execution._ Comptime procedures shall terminate within implementation-defined resource limits:

- Recursion depth: minimum 256 levels
- Evaluation steps: minimum 1,000,000 per procedure invocation
- Memory allocation: minimum 64 MiB per compilation unit

[14] These limits align with the compile-time execution phase requirements in §2.2.3. Exceeding limits produces diagnostics E16-003 (recursion), E16-004 (steps), or E16-005 (memory).

##### §15.2.3.4 Type Restrictions

[15] _Return type evaluability._ Comptime procedure return types shall be compile-time representable:

- Primitive types (integers, floats, bool, char, unit)
- Strings (`string@View` for compile-time constants)
- Arrays of compile-time representable types
- Tuples of compile-time representable types
- TypeRef, ProcedureSpec, TypeSpec (codegen types)
- Union types where all components are compile-time representable

[16] Modal types with non-trivial states, witness types, and other runtime-only types cannot be returned from comptime procedures. Violations produce diagnostic E16-008.

##### §15.2.3.5 Parameter Restrictions

[17] _Comptime parameter types._ Parameters to comptime procedures shall have compile-time representable types (same constraint as return types, [15]).

[18] _No receivers._ Comptime procedures shall not have receiver parameters (`~`, `~%`, `~!`). They are always static. Attempting to declare a comptime procedure with a receiver produces diagnostic E16-009.

#### §15.2.4 Semantics [comptime.procedures.semantics]

##### §15.2.4.1 Execution Environment

[19] Comptime procedures execute in a compile-time evaluation environment separate from runtime execution:

[ Given: Comptime procedure `p` with parameters $x_1: \tau_1, \ldots, x_n: \tau_n$ and body $e$ ]

$$
\frac{\Gamma_{\text{ct}}, x_1: \tau_1, \ldots, x_n: \tau_n \vdash e : \tau_r \quad \langle e, \sigma_{\emptyset} \rangle \Downarrow_{\text{comptime}} \langle v, \sigma' \rangle}{\text{comptime}(p)(v_1, \ldots, v_n) = v}
\tag{E-Comptime-Proc-Call}
$$

[20] The compile-time store $\sigma$ contains bindings created during comptime execution. It is separate from the runtime store and is discarded after compilation completes.

##### §15.2.4.2 Grant Checking

[21] Grant checking for comptime procedures follows the general grant checking algorithm (§12.7.2) with the additional restriction that all grants must be comptime-safe:

$$
\frac{\text{procedure } p \text{ sequent grants } G \quad G \subseteq \text{ComptimeGrants}}{\text{Comptime grant check passes}}
\tag{WF-Comptime-Grant-Valid}
$$

where $\text{ComptimeGrants} = \{\texttt{comptime::alloc}, \texttt{comptime::codegen}, \texttt{comptime::config}, \texttt{comptime::diag}\}$.

##### §15.2.4.3 Recursion and Control Flow

[22] Comptime procedures may use recursion and all control flow constructs (if, match, loop) subject to recursion depth limits (§16.2.3.3).

[23] **Recursive comptime procedure:**

**Example 16.2.4.1** (Recursive factorial):

```cursive
comptime procedure factorial(n: usize): usize
    [[ |- n <= 20 => result > 0 ]]
{
    if n <= 1 {
        result 1
    } else {
        result n * factorial(n - 1)
    }
}

let FACT_10: const usize = factorial(10)  // Evaluates at compile time
```

[1] Recursion is bounded by the depth limit (256 levels). Factorial(30) would exceed limit for typical stack depths.

##### §15.2.4.4 Generic Comptime Procedures

[24] Comptime procedures may be generic over types, const parameters, and grant parameters:

**Example 16.2.4.2** (Generic comptime procedure):

```cursive
comptime procedure array_repeat<T, const N: usize>(value: T): [T; N]
    [[ comptime::alloc |- N > 0, N <= 10000 => true ]]
{
    var result: [T; N] = [value; N]
    result result
}

let ZEROS: const [i32; 100] = array_repeat::<i32, 100>(0)
```

#### §15.2.5 Comptime Procedure Invocation [comptime.procedures.invocation]

##### §15.2.5.1 Call Contexts

[25] Comptime procedures may be called from:

- Other comptime procedures
- Comptime blocks (`comptime { ... }`)
- Const binding initializers: `let X: const T = comptime_proc()`
- Array length expressions: `[T; comptime_size()]`
- Generic const parameter defaults
- Attribute arguments

[26] Calling comptime procedures from runtime contexts produces diagnostic E16-010.

##### §15.2.5.2 Evaluation Timing

[27] Comptime procedure calls evaluate during the compile-time execution phase (§2.2.4.2), in dependency order. Each call is memoized: repeated calls with identical arguments return cached results.

##### §15.2.5.3 Examples

**Example 16.2.5.1** (Comptime procedure in array length):

```cursive
comptime procedure next_power_of_two(n: usize): usize
    [[ |- n > 0 => result >= n ]]
{
    var power: usize = 1

    loop power < n {
        power = power * 2
    }

    result power
}

type AlignedBuffer<const SIZE: usize> = [u8; next_power_of_two(SIZE)]

let buffer: AlignedBuffer<100> = [0; 128]  // SIZE=100 → 128
```

**Example 16.2.5.2** (Comptime procedure in const binding):

```cursive
comptime procedure compute_checksum(data: [u8]): u32
    [[ comptime::alloc |- data.len() > 0 => true ]]
{
    var sum: u32 = 0

    loop byte: u8 in data {
        sum = sum + (byte as u32)
    }

    result sum
}

let HEADER: const [u8; 4] = [0x4D, 0x5A, 0x00, 0x00]
let HEADER_CHECKSUM: const u32 = compute_checksum(HEADER)
```

#### §15.2.6 Comptime-Only Data Structures [comptime.procedures.structures]

##### §15.2.6.1 Compile-Time Collections

[28] Comptime procedures may manipulate collections (arrays, tuples) allocated with `comptime::alloc`:

**Example 16.2.6.1** (Building lookup table):

```cursive
comptime procedure build_lookup_table<const N: usize>(): [u8; N]
    [[ comptime::alloc |- N > 0, N <= 256 => true ]]
{
    var table: [u8; N] = [0; N]
    var i: usize = 0

    loop i < N {
        table[i] = ((i * i) % 256) as u8
        i = i + 1
    }

    result table
}

let SQUARES: const [u8; 256] = build_lookup_table::<256>()
```

##### §15.2.6.2 Comptime String Manipulation

[29] String operations in comptime procedures use `string@View` for immutable compile-time strings:

**Example 16.2.6.2** (String concatenation at compile time):

```cursive
comptime procedure build_message(prefix: string@View, suffix: string@View): string@View
    [[ comptime::alloc |- prefix.len() + suffix.len() < 1048576 => true ]]
{
    result string_concat(prefix, suffix)
}

let GREETING: const string@View = build_message("Hello, ", "Cursive!")
```

#### §15.2.7 Diagnostics [comptime.procedures.diagnostics]

[30] Comptime procedure diagnostics:

**Table 16.2 — Comptime procedure diagnostics**

| Code    | Condition                                      | Constraint |
| ------- | ---------------------------------------------- | ---------- |
| E16-001 | Runtime grant in comptime procedure sequent    | [8]        |
| E16-002 | Non-pure operation in comptime procedure       | [12]       |
| E16-003 | Recursion depth exceeded (>256)                | [14]       |
| E16-004 | Evaluation steps exceeded (>1M)                | [14]       |
| E16-005 | Memory allocation exceeded (>64MiB)            | [14]       |
| E16-008 | Return type not compile-time representable     | [16]       |
| E16-009 | Comptime procedure with receiver               | [18]       |
| E16-010 | Comptime procedure called from runtime context | [26]       |

#### §15.2.8 Conformance Requirements [comptime.procedures.requirements]

[31] A conforming implementation SHALL:

1. Support `comptime procedure` declarations with syntax per §16.2.2
2. Restrict comptime procedure grants to comptime-safe grants only (E16-001)
3. Enforce purity: prohibit runtime-observable side effects (E16-002)
4. Enforce minimum resource limits: 256 recursion depth, 1M steps, 64MiB memory
5. Execute comptime procedures during compile-time execution phase (§2.2.4.2)
6. Memoize comptime procedure results for identical arguments
7. Support generic comptime procedures (type, const, grant parameters)
8. Allow comptime procedures in const bindings, array lengths, type expressions
9. Prohibit comptime procedures with receivers (E16-009)
10. Emit diagnostics E16-001 through E16-010 for violations

[32] A conforming implementation MAY:

1. Exceed minimum resource limits
2. Provide additional comptime intrinsics
3. Optimize comptime evaluation for performance
4. Cache results across compilation units

[33] A conforming implementation SHALL NOT:

1. Allow runtime grants in comptime procedures
2. Execute comptime procedures non-deterministically
3. Permit non-terminating comptime procedures without diagnostics
4. Allow comptime procedures to observe or modify runtime state (except via codegen)


### §15.3 Comptime Blocks and Contexts [comptime.blocks]

#### §15.3.1 Overview [comptime.blocks.overview]

[1] _Comptime blocks_ are block expressions prefixed with the `comptime` keyword that execute during the compile-time execution phase. They provide inline compile-time computation for generating constants, conditional compilation, and code generation without requiring separate comptime procedures.

[2] Comptime blocks were introduced in §8.7 [expr.constant]; this subclause provides complete specification of their execution model, scope rules, grant accumulation, and integration with module initialization and code generation.

[3] Comptime blocks may appear at module scope (participating in module initialization, §4.6) or within procedure bodies (for local compile-time computation).

#### §15.3.2 Syntax [comptime.blocks.syntax]

[4] Comptime block syntax:

**Comptime blocks** match the pattern:
```
"comptime" <block_expr>
```

**Block expressions** take one of the following forms:
```
"{" <statement>* "}"
"{" <statement>* "result" <expression> "}"
```

[ Note: See Annex A §A.4 [grammar.expression] for the normative `comptime_block` production.
— end note ]

[5] The `comptime` keyword immediately precedes a block expression. The block introduces a lexical scope (§6.2) that exists only during compilation.

[6] **Result expression.** Blocks with `result expr` have type `typeof(expr)`. Blocks without `result` have type `()` (unit).

#### §15.3.3 Constraints [comptime.blocks.constraints]

##### §15.3.3.1 Grant Accumulation

[7] _Grant union._ The grant set of a comptime block is the union of grants from all operations within the block:

$$
\text{grants}(\texttt{comptime } \{ s_1; \ldots; s_n \}) = \bigcup_{i=1}^{n} \text{grants}(s_i)
$$

[8] All accumulated grants must be comptime-safe. Any runtime grant produces diagnostic E15-001.

##### §15.3.3.2 Scope Isolation

[9] _Compile-time scope._ Bindings declared within comptime blocks are compile-time only and do not persist to runtime:

$$
\frac{x \text{ declared in comptime block}}{\text{runtime code cannot reference } x}
\tag{WF-Comptime-Scope-Isolated}
$$

[10] Attempting to reference comptime bindings from runtime code produces diagnostic E15-020 (undefined identifier, via standard name resolution).

[11] _Outer scope access._ Comptime blocks may reference outer-scope bindings (module constants, procedure parameters, earlier comptime-generated constants). The accessed bindings must have compile-time-known values.

##### §15.3.3.3 Result Type Constraints

[12] _Type evaluability._ When a comptime block includes `result expr`, the expression shall be compile-time evaluable and have compile-time representable type (§16.2.3.4[15]).

[13] _Context integration._ Comptime blocks used in type positions (array lengths, type alias RHS) shall have appropriate types:

- Array length context: requires `usize` result
- Type alias context: requires `TypeRef` result (§16.8)
- Const binding initializer: requires any compile-time representable type

##### §15.3.3.4 Module-Scope Placement

[14] _Module-level comptime blocks._ Comptime blocks at module scope participate in module initialization (§4.6). They may:

- Generate constants via `codegen::declare_constant`
- Generate types and procedures via codegen APIs (§16.8)
- Perform compile-time assertions
- Query configuration and conditionally generate code

[15] Module-level comptime blocks are evaluated in dependency order before type checking begins.

#### §15.3.4 Semantics [comptime.blocks.semantics]

##### §15.3.4.1 Evaluation Model

[16] Comptime blocks execute during the compile-time execution phase (§2.2.4.2):

[ Given: Comptime block `comptime { body }` with environment $\Gamma$ ]

$$
\frac{\Gamma_{\text{ct}} \vdash body : \tau \quad \langle body, \sigma_{\text{ct}} \rangle \Downarrow_{\text{comptime}} \langle v, \sigma'_{\text{ct}} \rangle}{\langle \texttt{comptime } \{ body \}, \sigma \rangle \Downarrow_{\text{compile}} v}
\tag{E-Comptime-Block}
$$

[17] The compile-time store $\sigma_{\text{ct}}$ is local to the block. After evaluation, the result value $v$ is embedded as a compile-time constant. The store is discarded.

##### §15.3.4.2 Dependency Analysis

[18] Comptime blocks form a dependency graph where block $B_1$ depends on block $B_2$ if:

- $B_1$ references constants generated by $B_2$
- $B_1$ references types generated by $B_2$
- $B_1$ calls comptime procedures that depend on $B_2$

[19] **Acyclic requirement:**

$$
\frac{\exists \text{ cycle in comptime dependency graph}}{\text{ERROR E15-021: cyclic comptime dependency}}
\tag{WF-Comptime-Acyclic}
$$

[20] Cyclic dependencies among comptime blocks are ill-formed and produce diagnostic E15-021.

##### §15.3.4.3 Statement Execution

[21] Statements within comptime blocks execute sequentially in textual order, following the execution model in Clause 7. Side effects visible during comptime evaluation include:

- Binding creation and mutation
- Comptime allocation (via `comptime::alloc`)
- Code generation (via `comptime::codegen`)
- Diagnostic emission (via `comptime::diag`)

[22] All side effects are compile-time only. No runtime state is modified.

#### §15.3.5 Examples [comptime.blocks.examples]

##### §15.3.5.1 Conditional Compilation

**Example 16.3.5.1** (Platform-conditional constants):

```cursive
comptime {
    let os <- target_os()

    if os == "linux" {
        codegen::declare_constant(
            name: "PATH_SEPARATOR",
            ty: codegen::type_named("string@View"),
            value: quote { "/" }
        )
    } else if os == "windows" {
        codegen::declare_constant(
            name: "PATH_SEPARATOR",
            ty: codegen::type_named("string@View"),
            value: quote { "\\" }
        )
    } else {
        comptime_error("Unsupported OS")
    }
}

// Generated constant available:
let sep: const string@View = PATH_SEPARATOR
```

##### §15.3.5.2 Compile-Time Assertions

**Example 16.3.5.2** (Validating type layout):

```cursive
[[repr(C)]]
[[reflect]]
record NetworkPacket {
    header: [u8; 16],
    payload: [u8; 1024],
    checksum: u32,
}

comptime {
    let info <- reflect_type::<NetworkPacket>()

    comptime_assert(
        info.size == 1044,
        "NetworkPacket size must be 1044 bytes"
    )

    comptime_assert(
        info.align == 4,
        "NetworkPacket must be 4-byte aligned"
    )

    comptime_note("Network packet layout validated")
}
```

##### §15.3.5.3 Dependency Ordering

**Example 16.3.5.3** (Dependent comptime blocks):

```cursive
// Block 1: Generate base constant
comptime {
    codegen::declare_constant(
        name: "BASE_SIZE",
        ty: codegen::type_named("usize"),
        value: quote { 1024 }
    )
}

// Block 2: Depends on BASE_SIZE
let BUFFER_SIZE: const usize = comptime {
    result BASE_SIZE * 4  // References generated constant
}

// Block 3: Depends on BUFFER_SIZE
type Buffer = [u8; BUFFER_SIZE]
```

[1] Evaluation order: Block 1 (generates BASE_SIZE) → Block 2 (computes BUFFER_SIZE) → Block 3 (uses BUFFER_SIZE).

#### §15.3.6 Comptime Blocks at Module Scope [comptime.blocks.module]

##### §15.3.6.1 Module Initialization Integration

[23] Module-scope comptime blocks participate in module initialization (§4.6). They are classified as eager dependencies when they:

- Generate constants referenced by other module-level bindings
- Generate types or procedures used in the module
- Call comptime procedures that produce values used in initialization

[24] **Eager dependency classification:**

[ Given: Module $M$ with comptime block $B$ ]

$$
\frac{B \text{ generates constants/types used in module initialization}}{M \text{ has eager dependency on } B}
\tag{Eager-Comptime-Block}
$$

##### §15.3.6.2 Code Generation at Module Scope

[25] Module-scope comptime blocks with `comptime::codegen` grant may generate declarations that become part of the module's export set (if marked public):

**Example 16.3.6.1** (Generating public procedures at module scope):

```cursive
comptime {
    let types: [string@View] = ["i32", "i64", "f32", "f64"]

    loop type_name: string@View in types {
        codegen::declare_procedure(codegen::ProcedureSpec {
            name: string_concat("abs_", type_name),
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::None,
            params: [
                codegen::ParamSpec {
                    name: "value",
                    ty: TypeRef::Named(type_name),
                    permission: Permission::Const,
                    responsible: false,
                },
            ],
            return_type: TypeRef::Named(type_name),
            sequent: codegen::sequent_pure(),
            body: quote {
                result if value < 0 { -value } else { value }
            },
        })
    }
}

// Generated public procedures:
// public procedure abs_i32(value: const i32): i32 { ... }
// public procedure abs_i64(value: const i64): i64 { ... }
// public procedure abs_f32(value: const f32): f32 { ... }
// public procedure abs_f64(value: const f64): f64 { ... }

let x = abs_i32(-42)  // 42
```

#### §15.3.7 Comptime Blocks in Procedure Bodies [comptime.blocks.local]

##### §15.3.7.1 Local Comptime Computation

[26] Comptime blocks within procedure bodies compute local constants:

**Example 16.3.7.1** (Procedure-local comptime):

```cursive
procedure process_data(input: [u8]): [u8]
    [[ alloc::heap |- input.len() > 0 => true ]]
{
    let CHUNK_SIZE: const usize = comptime {
        let optimal <- target_pointer_width()
        result optimal * 8  // 64 or 256 depending on platform
    }

    // Use CHUNK_SIZE as compile-time constant
    var chunks: [[u8; CHUNK_SIZE]] = []

    // Process in chunks...
    result processed
}
```

[1] The comptime block computes a procedure-local constant based on platform characteristics.

##### §15.3.7.2 Conditional Assertions

[27] Comptime blocks enable conditional compile-time assertions based on context:

**Example 16.3.7.2** (Context-dependent validation):

```cursive
procedure create_buffer<const SIZE: usize>(): [u8; SIZE]
    [[ alloc::heap |- true => true ]]
{
    comptime {
        if cfg("strict_validation") {
            comptime_assert(
                SIZE > 0 && SIZE <= 65536,
                "Buffer size out of valid range"
            )
            comptime_assert(
                is_power_of_two(SIZE),
                "Buffer size must be power of 2 in strict mode"
            )
        }
    }

    result [0; SIZE]
}
```

#### §15.3.8 Diagnostics [comptime.blocks.diagnostics]

[28] Comptime block diagnostics:

[Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.15. — end note]

#### §15.3.9 Conformance Requirements [comptime.blocks.requirements]

[29] A conforming implementation SHALL:

1. Support `comptime { ... }` block expression syntax
2. Execute comptime blocks during compile-time execution phase (§2.2.4.2)
3. Enforce grant restrictions: only comptime-safe grants permitted
4. Isolate comptime block scope from runtime code
5. Allow comptime blocks to reference outer compile-time bindings
6. Evaluate module-scope comptime blocks in dependency order
7. Detect cyclic dependencies and emit diagnostic E15-021
8. Support comptime blocks in all expression contexts where compile-time values permitted
9. Enforce result type constraints for typed contexts
10. Emit diagnostics E15-001, E15-020, E15-021, E15-022 for violations

[30] A conforming implementation MAY:

1. Optimize comptime block evaluation
2. Cache comptime block results
3. Parallelize independent comptime blocks (maintaining observable determinism)

[31] A conforming implementation SHALL NOT:

1. Execute comptime blocks at runtime
2. Allow runtime code to reference comptime-only bindings
3. Evaluate comptime blocks non-deterministically
4. Permit comptime blocks to modify runtime state except via codegen


### §15.4 Comptime Intrinsics and Configuration [comptime.intrinsics]

#### §15.4.1 Overview [comptime.intrinsics.overview]

[1] _Comptime intrinsics_ are built-in procedures provided by the compiler for compile-time validation, diagnostic emission, and platform/configuration queries. They enable assertion-based validation, conditional compilation, and platform-specific code generation.

[2] This subclause specifies all comptime intrinsic procedures, their signatures, semantics, grant requirements, and usage patterns.

#### §15.4.2 Assertion and Validation Intrinsics [comptime.intrinsics.assertions]

##### §15.4.2.1 comptime_assert

[3] Compile-time assertion procedure:

```cursive
comptime procedure comptime_assert(condition: bool, message: string@View): ()
    [[ comptime::diag |- true => true ]]
```

[4] **Semantics.** Evaluates `condition` at compile time:

- If `condition == true`: Execution continues normally
- If `condition == false`: Compilation fails with diagnostic E15-030 and the provided `message`

[5] **Typing rule:**

$$
\frac{\Gamma_{\text{ct}} \vdash condition : \texttt{bool} \quad \Gamma_{\text{ct}} \vdash message : \texttt{string@View}}{\Gamma_{\text{ct}} \vdash \texttt{comptime\_assert}(condition, message) : ()}
\tag{T-Comptime-Assert}
$$

[6] **Evaluation rule (success case):**

$$
\frac{\langle condition, \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \langle \texttt{true}, \sigma_{\text{ct}} \rangle}{\langle \texttt{comptime\_assert}(condition, message), \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \langle (), \sigma_{\text{ct}} \rangle}
\tag{E-Assert-Success}
$$

[7] **Evaluation rule (failure case):**

$$
\frac{\langle condition, \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \langle \texttt{false}, \sigma_{\text{ct}} \rangle}{\langle \texttt{comptime\_assert}(condition, message), \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \text{ERROR E15-030}}
\tag{E-Assert-Fail}
$$

**Example 16.4.2.1** (Type layout assertion):

```cursive
[[reflect]]
record Packet {
    header: [u8; 16],
    payload: [u8; 1024],
}

comptime {
    let info <- reflect_type::<Packet>()
    comptime_assert(info.size == 1040, "Packet size must be 1040 bytes")
}
```

##### §15.4.2.2 comptime_error

[8] Unconditional compile-time error:

```cursive
comptime procedure comptime_error(message: string@View): !
    [[ comptime::diag |- true => false ]]
```

[9] **Semantics.** Unconditionally fails compilation with diagnostic E16-031 and the provided `message`. Returns never type `!` because execution does not continue.

[10] **Evaluation rule:**

$$
\frac{\langle message, \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \langle msg, \sigma_{\text{ct}} \rangle}{\langle \texttt{comptime\_error}(message), \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \text{ERROR E16-031}(msg)}
\tag{E-Comptime-Error}
$$

**Example 16.4.2.2** (Configuration validation):

```cursive
comptime {
    let feature_enabled <- cfg("required_feature")

    if !feature_enabled {
        comptime_error("This module requires 'required_feature' to be enabled")
    }
}
```

##### §15.4.2.3 comptime_warning

[11] Compile-time warning emission:

```cursive
comptime procedure comptime_warning(message: string@View): ()
    [[ comptime::diag |- true => true ]]
```

[12] **Semantics.** Emits warning diagnostic E16-032 with the provided `message`. Compilation continues normally.

**Example 16.4.2.3** (Deprecation warning):

```cursive
comptime {
    if cfg("legacy_mode") {
        comptime_warning("legacy_mode is deprecated, use new_mode instead")
    }
}
```

##### §15.4.2.4 comptime_note

[13] Informational note emission:

```cursive
comptime procedure comptime_note(message: string@View): ()
    [[ comptime::diag |- true => true ]]
```

[14] **Semantics.** Emits informational note to compilation output. Does not affect compilation success. Useful for debugging and documenting compile-time decisions.

**Example 16.4.2.4** (Logging code generation):

```cursive
comptime {
    let type_count: usize = 5

    comptime_note("Generating specialized procedures...")

    loop i in 0..type_count {
        comptime_note(string_concat("  Processing type ", usize_to_string(i)))
        // Generate code...
    }

    comptime_note("Code generation complete")
}
```

#### §15.4.3 Configuration Query Intrinsics [comptime.intrinsics.config]

##### §15.4.3.1 Boolean Configuration Queries

[15] Check whether configuration flags are enabled:

```cursive
comptime procedure cfg(key: string@View): bool
    [[ comptime::config |- true => true ]]
```

[16] **Semantics.** Returns `true` if the configuration flag identified by `key` is enabled for the current compilation, `false` otherwise.

[17] **Common configuration keys:**

- `"debug_assertions"` — Debug mode enabled
- `"test"` — Test compilation mode
- `"feature_{name}"` — Custom feature flags
- Platform-specific features (implementation-defined)

**Example 16.4.3.1** (Debug-mode code generation):

```cursive
comptime {
    if cfg("debug_assertions") {
        codegen::declare_constant(
            name: "DEBUG_CHECKS",
            ty: codegen::type_named("bool"),
            value: quote { true }
        )
    } else {
        codegen::declare_constant(
            name: "DEBUG_CHECKS",
            ty: codegen::type_named("bool"),
            value: quote { false }
        )
    }
}
```

##### §15.4.3.2 String Configuration Queries

[18] Retrieve configuration values as strings:

```cursive
comptime procedure cfg_value(key: string@View): string@View
    [[ comptime::config |- true => true ]]
```

[19] **Semantics.** Returns the string value associated with configuration `key`. If the key is not set, returns empty string `""`.

**Example 16.4.3.2** (Retrieving version from config):

```cursive
let VERSION: const string@View = comptime {
    let ver <- cfg_value("package_version")

    if ver.len() == 0 {
        result "0.0.0"  // Default
    } else {
        result ver
    }
}
```

##### §15.4.3.3 Platform Query Intrinsics

[20] Query target platform characteristics:

**target_os**:

```cursive
comptime procedure target_os(): string@View
    [[ comptime::config |- true => true ]]
```

[21] **Semantics.** Returns the target operating system identifier. Common values include:

- `"linux"` — Linux systems
- `"windows"` — Windows systems
- `"macos"` — macOS systems
- `"freebsd"` — FreeBSD systems
- Other values are implementation-defined

**target_arch**:

```cursive
comptime procedure target_arch(): string@View
    [[ comptime::config |- true => true ]]
```

[22] **Semantics.** Returns the target CPU architecture. Common values:

- `"x86_64"` — x86-64 (AMD64)
- `"aarch64"` — ARM64
- `"x86"` — 32-bit x86
- `"arm"` — 32-bit ARM

**target_endian**:

```cursive
comptime procedure target_endian(): string@View
    [[ comptime::config |- true => true ]]
```

[23] **Semantics.** Returns `"little"` for little-endian platforms, `"big"` for big-endian platforms.

**target_pointer_width**:

```cursive
comptime procedure target_pointer_width(): usize
    [[ comptime::config |- true => true ]]
```

[24] **Semantics.** Returns pointer width in bits: `32` for 32-bit platforms, `64` for 64-bit platforms.

##### §15.4.3.4 Platform-Conditional Code

**Example 16.4.3.3** (OS-specific constants):

```cursive
let LINE_ENDING: const string@View = comptime {
    let os <- target_os()

    match os {
        "windows" => result "\r\n",
        "linux" => result "\n",
        "macos" => result "\n",
        _ => {
            comptime_warning("Unknown OS, using Unix line ending")
            result "\n"
        }
    }
}
```

**Example 16.4.3.4** (Architecture-specific buffer sizes):

```cursive
let CACHE_LINE_SIZE: const usize = comptime {
    let arch <- target_arch()

    if arch == "x86_64" || arch == "aarch64" {
        result 64  // 64-byte cache lines
    } else {
        result 32  // Conservative default
    }
}

[[repr(align(CACHE_LINE_SIZE))]]
record CacheAligned {
    data: [u8; CACHE_LINE_SIZE],
}
```

#### §15.4.4 Type Property Intrinsics [comptime.intrinsics.types]

##### §15.4.4.1 Basic Type Queries

[25] These intrinsics extend §7.8 [type.introspection] for comptime contexts:

**type_name**:

```cursive
comptime procedure type_name<T>(): string@View
    [[ |- true => true ]]
```

[26] Returns the fully-qualified name of type `T`.

**type_id**:

```cursive
comptime procedure type_id<T>(): u64
    [[ |- true => true ]]
```

[27] Returns a unique identifier for type `T`. Identical types have identical IDs.

**size_of**:

```cursive
comptime procedure size_of<T>(): usize
    [[ |- true => true ]]
```

[28] Returns the size of type `T` in bytes (§10.6 [memory.layout]).

**align_of**:

```cursive
comptime procedure align_of<T>(): usize
    [[ |- true => true ]]
```

[29] Returns the alignment requirement of type `T` as a power of two.

##### §15.4.4.2 Type Property Predicates

[30] Query type properties at compile time:

```cursive
comptime procedure is_copy<T>(): bool
    [[ |- true => true ]]

comptime procedure is_sized<T>(): bool
    [[ |- true => true ]]
```

[31] **Semantics:**

- `is_copy<T>()`: Returns `true` if `T` satisfies the `Copy` behavior (§10.4.5.2)
- `is_sized<T>()`: Returns `true` if `T` is a sized type (§10.4.5.2 [generic.behavior.sized])

**Example 16.4.4.1** (Conditional compilation based on Copy):

```cursive
comptime procedure generate_clone<T>(): ()
    [[ comptime::codegen |- true => true ]]
{
    if !is_copy::<T>() {
        // Generate explicit clone procedure for non-Copy types
        codegen::add_procedure(
            target: TypeRef::TypeId(type_id<T>()),
            spec: build_clone_spec::<T>()
        )
    }
    // Copy types get default clone behavior
}
```

#### §15.4.5 Utility Intrinsics [comptime.intrinsics.utilities]

##### §15.4.5.1 String Manipulation

[32] Compile-time string operations:

```cursive
comptime procedure string_concat(a: string@View, b: string@View): string@View
    [[ comptime::alloc |- a.len() + b.len() < 1048576 => true ]]
```

[33] **Semantics.** Concatenates strings `a` and `b`. Result is a compile-time constant string. Total length shall not exceed 1 MiB (§16.2.3.3[14]).

**Example 16.4.5.1** (Building identifiers):

```cursive
comptime {
    let prefix: const string@View = "get_"
    let field_name: const string@View = "balance"
    let getter_name = string_concat(prefix, field_name)

    // getter_name = "get_balance"
}
```

##### §15.4.5.2 Numeric Conversions

[34] Convert between numbers and strings at compile time:

```cursive
comptime procedure usize_to_string(value: usize): string@View
    [[ comptime::alloc |- true => true ]]

comptime procedure parse_usize(text: string@View): usize \/ Unit
    [[ |- text.len() > 0 => true ]]
```

[35] **Semantics:**

- `usize_to_string`: Converts integer to decimal string representation
- `parse_usize`: Parses decimal string to integer; returns unit on failure

**Example 16.4.5.2** (Numeric configuration):

```cursive
let THREAD_COUNT: const usize = comptime {
    let config_value <- cfg_value("thread_count")

    match parse_usize(config_value) {
        count: usize => {
            if count > 0 && count <= 64 {
                result count
            } else {
                comptime_warning("Invalid thread count, using default")
                result 4
            }
        },
        _: () => result 4,  // Default
    }
}
```

##### §15.4.5.3 Arithmetic Utilities

[36] Helper procedures for comptime arithmetic:

```cursive
comptime procedure is_power_of_two(n: usize): bool
    [[ |- true => true ]]
{
    result n > 0 && (n & (n - 1)) == 0
}

comptime procedure round_up_to_power_of_two(n: usize): usize
    [[ |- n > 0 => result >= n ]]
{
    var power: usize = 1

    loop power < n {
        power = power * 2
    }

    result power
}
```

#### §15.4.6 Comprehensive Examples [comptime.intrinsics.examples]

##### §15.4.6.1 Configuration-Driven Code Generation

**Example 16.4.6.1** (Feature-gated procedures):

```cursive
comptime {
    if cfg("experimental_features") {
        comptime_warning("Experimental features enabled")

        codegen::declare_procedure(codegen::ProcedureSpec {
            name: "experimental_optimize",
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::None,
            params: [
                codegen::ParamSpec {
                    name: "data",
                    ty: TypeRef::Slice(TypeRef::Named("u8")),
                    permission: Permission::Const,
                    responsible: false,
                },
            ],
            return_type: TypeRef::Slice(TypeRef::Named("u8")),
            sequent: codegen::sequent_pure(),
            body: quote {
                // Experimental optimization logic
                result optimized_data
            },
        })
    } else {
        comptime_note("Experimental features disabled")
    }
}
```

##### §15.4.6.2 Platform-Specific Optimization

**Example 16.4.6.2** (SIMD-aware buffer size):

```cursive
let SIMD_WIDTH: const usize = comptime {
    let arch <- target_arch()

    if arch == "x86_64" {
        if cfg("avx2") {
            comptime_note("Using AVX2 SIMD width")
            result 32  // 256-bit AVX2
        } else {
            result 16  // 128-bit SSE
        }
    } else if arch == "aarch64" {
        result 16  // 128-bit NEON
    } else {
        comptime_warning("Unknown architecture for SIMD")
        result 8  // Conservative
    }
}

type SimdBuffer = [f32; SIMD_WIDTH]
```

#### §15.4.7 Diagnostics [comptime.intrinsics.diagnostics]

[37] Intrinsic-related diagnostics:

[Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.15. — end note]

#### §15.4.8 Conformance Requirements [comptime.intrinsics.requirements]

[38] A conforming implementation SHALL:

1. Provide comptime_assert, comptime_error, comptime_warning, comptime_note intrinsics
2. Provide cfg and cfg_value configuration query intrinsics
3. Provide target_os, target_arch, target_endian, target_pointer_width platform queries
4. Provide type property intrinsics: type_name, type_id, size_of, align_of, is_copy, is_sized
5. Provide string manipulation: string_concat
6. Provide numeric conversion: usize_to_string, parse_usize
7. Execute intrinsics during compile-time execution phase only
8. Emit diagnostics E16-030, E16-031, E16-032 for assertion/error/warning intrinsics
9. Return accurate platform information consistent with compilation target
10. Guarantee deterministic results for all intrinsic calls

[39] A conforming implementation MAY:

1. Provide additional comptime intrinsics as extensions
2. Provide additional configuration keys beyond standard set
3. Optimize intrinsic execution for performance

[40] A conforming implementation SHALL NOT:

1. Execute intrinsics non-deterministically
2. Allow platform queries in runtime contexts
3. Return inaccurate platform information


### §15.5 Reflection Opt-In and Attributes [comptime.reflect.optin]

#### §15.5.1 Overview [comptime.reflect.optin.overview]

[1] Type reflection in Cursive is opt-in per type via the `[[reflect]]` attribute. This design ensures zero metadata overhead for types that do not use reflection while enabling comprehensive introspection for types that explicitly opt in.

[2] This subclause specifies the `[[reflect]]` attribute syntax, zero-cost guarantees, opt-in constraints, and the security/privacy implications of reflection visibility.

#### §15.5.2 Syntax [comptime.reflect.optin.syntax]

[3] The `[[reflect]]` attribute syntax:

**Reflect attributes** match the pattern:
```
"[[" "reflect" "]]"
```

**Reflected type declarations** match the pattern:
```
<reflect_attribute> [ <reflect_attribute> ... ] <type_declaration>
```

[ Note: See §1.4.3 [intro.attributes] for the general attribute grammar.
— end note ]

[4] The attribute appears immediately before the type declaration it modifies. Multiple attributes may precede a type; `[[reflect]]` may combine with other attributes (`[[repr(C)]]`, `[[repr(packed)]]`, etc.).

**Example 16.5.2.1** (Attribute placement):

```cursive
[[reflect]]
record Point {
    x: f64,
    y: f64,
}

[[repr(C)]]
[[reflect]]
record CCompatibleData {
    flags: u32,
    value: i64,
}
```

#### §15.5.3 Constraints [comptime.reflect.optin.constraints]

##### §15.5.3.1 Applicable Declarations

[5] _Type declarations only._ The `[[reflect]]` attribute shall apply exclusively to:

- Record declarations (`record Name { ... }`)
- Enum declarations (`enum Name { ... }`)
- Modal type declarations (`modal Name { ... }`)

[6] Applying `[[reflect]]` to other declarations (procedures, const bindings, primitive types, type aliases) produces diagnostic E16-100:

$$
\frac{\texttt{[[reflect]]} \text{ applied to non-type declaration}}{\text{ERROR E16-100: reflect attribute misplaced}}
\tag{WF-Reflect-Type-Only}
$$

##### §15.5.3.2 Reflection Permission

[7] _Opt-in requirement._ Reflection APIs (§16.6) shall operate only on types marked with `[[reflect]]`. Attempting to reflect on types without the attribute produces diagnostic E16-101:

$$
\frac{T \text{ not marked } \texttt{[[reflect]]} \quad \text{reflection query on } T}{\text{ERROR E16-101: type not marked for reflection}}
\tag{WF-Reflect-Opt-In}
$$

[8] This constraint ensures that reflection is explicit and prevents accidental exposure of type internals.

##### §15.5.3.3 Visibility Interaction

[9] _Reflection and visibility._ The `[[reflect]]` attribute does not override visibility modifiers (§5.6). Reflection queries from outside the defining module shall respect field and procedure visibility:

- Public fields/procedures: Full metadata available
- Internal/private fields/procedures: Names and types visible, offsets and details restricted

[10] Attempting to access private field offsets or detailed metadata from outside the defining module produces diagnostic E16-111 (specified in §16.6).

##### §15.5.3.4 Generic Type Reflection

[11] _Generic instantiation._ Generic types marked `[[reflect]]` may be reflected when instantiated with concrete type arguments:

```cursive
[[reflect]]
record Container<T> {
    items: [T],
}

comptime {
    let info <- reflect_type::<Container<i32>>()  // OK: concrete instantiation
    // info reflects Container<i32>, not Container<T>
}
```

[12] Attempting to reflect on uninstantiated generic types produces diagnostic E16-112.

#### §15.5.4 Semantics [comptime.reflect.optin.semantics]

##### §15.5.4.1 Zero-Cost Guarantee

[13] **Normative guarantee.** Types without the `[[reflect]]` attribute SHALL incur zero instance overhead:

$$
\frac{T \text{ not marked } \texttt{[[reflect]]}}{\text{sizeof}(T)_{\text{with\_reflection}} = \text{sizeof}(T)_{\text{without\_reflection}}}
\tag{P-Reflect-Zero-Instance-Cost}
$$

[14] Implementations shall not generate reflection metadata, increase type instance size, change alignment, or modify runtime representation for non-reflected types.

[15] **Metadata generation.** Types marked with `[[reflect]]` generate compile-time metadata structures. The metadata is embedded in the compilation unit's debug information or a separate reflection section, contributing to binary size but NOT increasing the size of type instances:

$$
\frac{T \text{ marked } \texttt{[[reflect]]}}{\text{sizeof}(T)_{\text{instance}} = \text{sizeof}(T)_{\text{without\_reflect}}}
\tag{P-Reflect-No-Instance-Overhead}
$$

[16] The metadata exists separately from instances; each instance has the same size regardless of reflection. Reflection metadata contributes to binary size (stored in debug information or dedicated sections) but does not affect runtime instance size or performance.

##### §15.5.4.2 Metadata Accessibility

[17] Reflection metadata is accessible only at compile time through reflection query procedures (§16.6). Runtime access to reflection metadata is an optional implementation feature outside the specification scope.

[18] **Compile-time only rule:**

$$
\frac{\text{reflection query on } T \text{ in runtime context}}{\text{ERROR E16-110: reflection requires comptime context}}
\tag{WF-Reflect-Comptime}
$$

#### §15.5.5 Security and Privacy Considerations [comptime.reflect.optin.security]

##### §15.5.5.1 Intentional Exposure

[19] The opt-in design prevents accidental exposure of internal type structure. Types containing sensitive data (cryptographic keys, passwords, internal caches) may omit `[[reflect]]` to prevent reflection:

**Example 16.5.5.1** (Sensitive type without reflection):

```cursive
record CryptoKey {
    private key_material: [u8; 32],
    private salt: [u8; 16],
}

// No [[reflect]] attribute
// Reflection queries on CryptoKey will fail with E16-101
```

##### §15.5.5.2 Selective Reflection

[20] Types may selectively opt into reflection while keeping related types opaque:

**Example 16.5.5.2** (Selective reflection):

```cursive
[[reflect]]
record PublicConfig {
    public host: string@View,
    public port: u16,
}

record InternalState {
    // No [[reflect]] - internal implementation details
    cache: [Entry; 1024],
    last_update: u64,
}
```

#### §15.5.6 Examples [comptime.reflect.optin.examples]

**Example 16.5.6.1** (Multiple reflected types):

```cursive
[[reflect]]
record Point {
    x: f64,
    y: f64,
}

[[reflect]]
record Circle {
    center: Point,
    radius: f64,
}

comptime {
    let point_info <- reflect_type::<Point>()
    let circle_info <- reflect_type::<Circle>()

    comptime_note(string_concat(
        "Point size: ",
        usize_to_string(point_info.size)
    ))

    comptime_note(string_concat(
        "Circle size: ",
        usize_to_string(circle_info.size)
    ))
}
```

**Example 16.5.6.2** (Reflection with repr attributes):

```cursive
[[repr(C)]]
[[repr(packed)]]
[[reflect]]
record PackedHeader {
    magic: u32,
    version: u16,
    flags: u16,
}

comptime {
    let info <- reflect_type::<PackedHeader>()

    comptime_assert(info.size == 8, "Packed header must be 8 bytes")
    comptime_assert(info.align == 1, "Packed alignment must be 1")
}
```

#### §15.5.7 Diagnostics [comptime.reflect.optin.diagnostics]

[21] Reflection opt-in diagnostics:

**Table 16.5 — Reflection opt-in diagnostics**

| Code    | Condition                                        | Constraint |
| ------- | ------------------------------------------------ | ---------- |
| E16-100 | [[reflect]] on non-type declaration              | [6]        |
| E16-101 | Reflection query on non-reflected type           | [7]        |
| E16-110 | Reflection API in runtime context                | [18]       |
| E16-111 | Private reflection details accessed cross-module | [10]       |
| E16-112 | Reflection on uninstantiated generic             | [12]       |

#### §15.5.8 Conformance Requirements [comptime.reflect.optin.requirements]

[22] A conforming implementation SHALL:

1. Support `[[reflect]]` attribute on record, enum, and modal type declarations
2. Reject `[[reflect]]` on non-type declarations with diagnostic E16-100
3. Enforce opt-in requirement: reject reflection queries on non-reflected types (E16-101)
4. Guarantee zero runtime overhead for types without `[[reflect]]`
5. Ensure reflected type instances have same size as non-reflected instances
6. Generate compile-time metadata only for types with `[[reflect]]`
7. Restrict reflection APIs to comptime contexts (E16-110)
8. Respect visibility modifiers during reflection queries (E16-111)
9. Support reflection on instantiated generic types
10. Reject reflection on uninstantiated generics (E16-112)

[23] A conforming implementation MAY:

1. Provide runtime reflection as an optional feature (not specified here)
2. Optimize metadata storage format
3. Share metadata across compilation units

[24] A conforming implementation SHALL NOT:

1. Generate metadata for non-reflected types
2. Increase instance size for reflected types
3. Allow reflection queries in runtime contexts
4. Automatically add `[[reflect]]` without programmer consent


### §15.6 Type Reflection and Metadata Queries [comptime.reflect.queries]

#### §15.6.1 Overview [comptime.reflect.queries.overview]

[1] This subclause specifies the complete API for querying type metadata at compile time. Reflection queries build upon the basic type introspection in §6.8 and the opt-in mechanism in §15.5 to provide comprehensive access to type structure.

[2] Reflection queries operate exclusively at compile time and require types to be marked with `[[reflect]]`. The queries return structured metadata describing fields, procedures, variants, modal states, and other type properties.

[3] The reflection API enables metaprogramming patterns: automatic serialization, debug formatting, builder pattern generation, ECS component registration, and other derive-like functionality.

#### §15.6.2 Core Type Reflection [comptime.reflect.queries.core]

##### §15.6.2.1 TypeInfo Structure

[4] The `TypeInfo` record (introduced in §16.2.3) provides core type metadata:

```cursive
record TypeInfo {
    name: string@View,
    size: usize,
    align: usize,
    kind: TypeKind,
}

enum TypeKind {
    Primitive,
    Record,
    Enum,
    Modal,
    Tuple,
    Array,
    Slice,
    Pointer,
    Function,
}
```

[5] **Field semantics:**

- `name`: Fully-qualified type name including module path
- `size`: Size in bytes per §10.6 [memory.layout]
- `align`: Alignment requirement (power of two)
- `kind`: Type category for dispatch in metaprogramming

##### §15.6.2.2 reflect_type Procedure

[6] Core reflection procedure:

```cursive
comptime procedure reflect_type<T>(): TypeInfo
    [[ comptime::alloc |- true => true ]]
```

[7] **Constraints:**

- Type `T` shall be marked with `[[reflect]]` (diagnostic E15-101 if not)
- Shall be called in comptime context (diagnostic E15-110 if runtime)
- Generic type `T` shall be instantiated with concrete arguments (diagnostic E15-112 if uninstantiated)

[8] **Typing rule:**

$$
\frac{\Gamma \vdash T : \text{Type} \quad T \text{ marked } \texttt{[[reflect]]}}{\Gamma_{\text{ct}} \vdash \texttt{reflect\_type}\langle T \rangle() : \texttt{TypeInfo}}
\tag{T-Reflect-Type}
$$

[9] **Semantics.** Returns a `TypeInfo` record populated with type metadata. The procedure executes at compile time using `comptime::alloc` grant to construct the result.

**Example 16.6.2.1** (Basic type reflection):

```cursive
[[reflect]]
record Vector3 {
    x: f32,
    y: f32,
    z: f32,
}

comptime {
    let info <- reflect_type::<Vector3>()

    comptime_assert(info.name == "Vector3", "Type name")
    comptime_assert(info.size == 12, "3 floats = 12 bytes")
    comptime_assert(info.align == 4, "f32 alignment")
    comptime_assert(info.kind == TypeKind::Record, "Is record")
}
```

#### §15.6.3 Field Reflection [comptime.reflect.queries.fields]

##### §15.6.3.1 FieldInfo Structure

[10] Field metadata structure:

```cursive
record FieldInfo {
    name: string@View,
    ty_name: string@View,
    offset: usize,
    visibility: Visibility,
}

enum Visibility {
    Public,
    Internal,
    Private,
    Protected,
}
```

[11] **Field semantics:**

- `name`: Field identifier
- `ty_name`: Fully-qualified type name of the field
- `offset`: Byte offset from structure base address (§11.6)
- `visibility`: Visibility modifier per §5.6

##### §15.6.3.2 Field Query Procedures

[12] Field reflection procedures:

```cursive
comptime procedure fields_of<T>(): [FieldInfo]
    [[ comptime::alloc |- true => true ]]

comptime procedure has_field<T>(name: string@View): bool

comptime procedure field_info_of<T>(name: string@View): FieldInfo \/ Unit
    [[ comptime::alloc |- true => true ]]

comptime procedure field_offset<T>(name: string@View): usize \/ Unit
```

[13] **Semantics:**

- `fields_of<T>()`: Returns array of `FieldInfo` for all fields in declaration order
- `has_field<T>(name)`: Returns `true` if field with identifier `name` exists
- `field_info_of<T>(name)`: Returns `FieldInfo` for field, or unit if not found
- `field_offset<T>(name)`: Returns byte offset for field, or unit if not found

[14] For non-record types (primitives, enums without fields), `fields_of` returns empty array.

##### §15.6.3.3 Examples

**Example 16.6.3.1** (Field iteration):

```cursive
[[reflect]]
record Person {
    public name: string@Managed,
    public age: u32,
    private ssn: string@Managed,
}

comptime {
    let fields <- fields_of::<Person>()

    loop field: FieldInfo in fields {
        comptime_note(string_concat("Field: ", field.name))
        comptime_note(string_concat("  Type: ", field.ty_name))
        comptime_note(string_concat("  Offset: ", usize_to_string(field.offset)))
    }
}
```

**Example 16.6.3.2** (Offset validation):

```cursive
[[repr(C)]]
[[reflect]]
record CHeader {
    magic: u32,
    version: u16,
    padding: u16,
    length: u32,
}

comptime {
    match field_offset::<CHeader>("magic") {
        offset: usize => comptime_assert(offset == 0, "magic at offset 0"),
        _: () => comptime_error("magic field missing"),
    }

    match field_offset::<CHeader>("version") {
        offset: usize => comptime_assert(offset == 4, "version at offset 4"),
        _: () => comptime_error("version field missing"),
    }
}
```

#### §15.6.4 Procedure Reflection [comptime.reflect.queries.procedures]

##### §15.6.4.1 ProcedureInfo Structure

[15] Procedure metadata structure:

```cursive
record ProcedureInfo {
    name: string@View,
    receiver_permission: Permission \/ Unit,
    params: [ParamInfo],
    return_type: string@View,
    grants: [string@View],
}

enum Permission {
    Const,
    Unique,
    Shared,
}

record ParamInfo {
    name: string@View,
    ty_name: string@View,
    permission: Permission,
    responsible: bool,
}
```

[16] **ProcedureInfo field semantics:**

- `name`: Procedure identifier
- `receiver_permission`: Permission if procedure has receiver (Const/Unique/Shared), unit if static procedure
- `params`: Array of parameter metadata in declaration order
- `return_type`: Fully-qualified return type name
- `grants`: Array of grant identifiers from sequent grants clause

[17] **ParamInfo field semantics:**

- `name`: Parameter identifier
- `ty_name`: Fully-qualified parameter type name
- `permission`: Parameter permission (const, unique, or shared)
- `responsible`: `true` if parameter has `move` modifier, `false` for non-responsible parameters

##### §15.6.4.2 Procedure Query Procedures

[18] Procedure reflection procedures:

```cursive
comptime procedure procedures_of<T>(): [ProcedureInfo]
    [[ comptime::alloc |- true => true ]]

comptime procedure has_procedure<T>(name: string@View): bool

comptime procedure procedure_info_of<T>(name: string@View): ProcedureInfo \/ Unit
    [[ comptime::alloc |- true => true ]]
```

[19] **Semantics:**

- `procedures_of<T>()`: Returns array of `ProcedureInfo` for all procedures on type `T`
- `has_procedure<T>(name)`: Returns `true` if procedure exists on type
- `procedure_info_of<T>(name)`: Returns `ProcedureInfo` for procedure, or unit if not found

##### §15.6.4.3 Examples

**Example 16.6.4.1** (Procedure reflection with grant inspection):

```cursive
[[reflect]]
record Database {
    connection: i32,

    procedure query(~%, sql: string@View): [Row]
        [[ db::query |- sql.len() > 0 => result.len() >= 0 ]]
    {
        // Implementation
    }

    procedure execute(~!, command: string@View): ()
        [[ db::execute |- command.len() > 0 => true ]]
    {
        // Implementation
    }
}

comptime {
    let procedures <- procedures_of::<Database>()

    loop proc: ProcedureInfo in procedures {
        comptime_note(string_concat("Procedure: ", proc.name))
        comptime_note(string_concat("  Grants: ", string_join(proc.grants, ", ")))

        match proc.receiver_permission {
            perm: Permission => {
                let perm_name = match perm {
                    Permission::Const => "const",
                    Permission::Unique => "unique",
                    Permission::Shared => "shared",
                }
                comptime_note(string_concat("  Receiver: ", perm_name))
            },
            _: () => comptime_note("  Static procedure"),
        }
    }
}
```

**Example 16.6.4.2** (Checking parameter responsibility):

```cursive
[[reflect]]
record Buffer {
    data: [u8],

    procedure consume(move ~!): ()
    {
        // Consumes buffer
    }

    procedure inspect(~): usize
    {
        result self.data.len()
    }
}

comptime {
    match procedure_info_of::<Buffer>("consume") {
        info: ProcedureInfo => {
            comptime_assert(info.params.len() == 1, "consume has self param")
            comptime_assert(info.params[0].responsible, "consume parameter is responsible")
        },
        _: () => comptime_error("consume not found"),
    }

    match procedure_info_of::<Buffer>("inspect") {
        info: ProcedureInfo => {
            comptime_assert(info.params.len() == 1, "inspect has self param")
            comptime_assert(!info.params[0].responsible, "inspect parameter non-responsible")
        },
        _: () => comptime_error("inspect not found"),
    }
}
```

#### §15.6.5 Enum Variant Reflection [comptime.reflect.queries.variants]

##### §15.6.5.1 VariantInfo Structure

[20] Enum variant metadata:

```cursive
record VariantInfo {
    name: string@View,
    discriminant: i64 \/ Unit,
    payload: [string@View],
}
```

[21] **Field semantics:**

- `name`: Variant identifier
- `discriminant`: Explicit discriminant value if specified, unit if sequential/default
- `payload`: Array of payload type names (empty for unit variants, length N for tuple variants, field type names for record variants)

##### §15.6.5.2 Variant Query Procedures

[22] Variant reflection procedures:

```cursive
comptime procedure variants_of<T>(): [VariantInfo]
    [[ comptime::alloc |- true => true ]]

comptime procedure has_variant<T>(name: string@View): bool

comptime procedure variant_info_of<T>(name: string@View): VariantInfo \/ Unit
    [[ comptime::alloc |- true => true ]]
```

[23] **Semantics:** Query enum variants. For non-enum types, `variants_of` returns empty array.

##### §15.6.5.3 Examples

**Example 16.6.5.1** (Enum variant reflection):

```cursive
[[reflect]]
enum Status {
    Pending = 0,
    Running = 1,
    Success = 2,
    Failed = 3,
}

comptime {
    let variants <- variants_of::<Status>()

    comptime_assert(variants.len() == 4, "4 variants")
    comptime_assert(variants[0].name == "Pending", "First variant")

    match variants[0].discriminant {
        disc: i64 => comptime_assert(disc == 0, "Pending discriminant"),
        _: () => comptime_error("Discriminant should be set"),
    }
}
```

**Example 16.6.5.2** (Payload type reflection):

```cursive
[[reflect]]
enum Message {
    Text(string@Managed),
    Data { id: u64, payload: [u8] },
    Close,
}

comptime {
    match variant_info_of::<Message>("Text") {
        info: VariantInfo => {
            comptime_assert(info.payload.len() == 1, "Text has 1 payload")
            comptime_assert(info.payload[0] == "string@Managed", "Payload type")
        },
        _: () => comptime_error("Text variant not found"),
    }

    match variant_info_of::<Message>("Data") {
        info: VariantInfo => {
            comptime_assert(info.payload.len() == 2, "Data has 2 fields")
        },
        _: () => comptime_error("Data variant not found"),
    }

    match variant_info_of::<Message>("Close") {
        info: VariantInfo => {
            comptime_assert(info.payload.len() == 0, "Close is unit variant")
        },
        _: () => comptime_error("Close variant not found"),
    }
}
```

#### §15.6.6 Modal State Reflection [comptime.reflect.queries.modal]

##### §15.6.6.1 Modal Reflection Structures

[24] Modal type metadata structures:

```cursive
record StateInfo {
    name: string@View,
    fields: [FieldInfo],
}

record TransitionInfo {
    procedure_name: string@View,
    from_state: string@View,
    to_state: string@View,
}
```

[25] **StateInfo field semantics:**

- `name`: State identifier (without @ prefix, e.g., "Open" not "@Open")
- `fields`: Array of state-specific field metadata

[26] **TransitionInfo field semantics:**

- `procedure_name`: Procedure implementing the state transition
- `from_state`: Source state identifier (without @ prefix)
- `to_state`: Target state identifier (without @ prefix)

##### §15.6.6.2 Modal Query Procedures

[27] Modal reflection procedures:

```cursive
comptime procedure states_of<T>(): [StateInfo]
    [[ comptime::alloc |- true => true ]]

comptime procedure transitions_of<T>(): [TransitionInfo]
    [[ comptime::alloc |- true => true ]]
```

[28] **Semantics:**

- `states_of<T>()`: Returns array of `StateInfo` for all modal states
- `transitions_of<T>()`: Returns array of `TransitionInfo` for all declared transitions

[29] For non-modal types, both procedures return empty arrays.

##### §15.6.6.3 Examples

**Example 16.6.6.1** (Modal state reflection):

```cursive
[[reflect]]
modal FileHandle {
    @Closed {
        path: string@Managed,
    }

    @Open {
        path: string@Managed,
        handle: i32,
    }

    procedure open(~!): FileHandle@Open
        [[ fs::open |- true => true ]]
    {
        // Implementation
    }

    procedure close(~!): FileHandle@Closed
        [[ fs::close |- true => true ]]
    {
        // Implementation
    }
}

comptime {
    let states <- states_of::<FileHandle>()

    comptime_assert(states.len() == 2, "2 states")
    comptime_assert(states[0].name == "Closed", "First state")
    comptime_assert(states[1].name == "Open", "Second state")

    // Check Open state has more fields than Closed
    comptime_assert(states[1].fields.len() > states[0].fields.len(), "Open has handle field")

    let transitions <- transitions_of::<FileHandle>()

    loop trans: TransitionInfo in transitions {
        comptime_note(string_concat(
            string_concat("Transition: ", trans.from_state),
            string_concat(" -> ", trans.to_state)
        ))
    }
}
```

#### §15.6.7 Advanced Reflection Patterns [comptime.reflect.queries.patterns]

##### §15.6.7.1 Layout Validation

**Example 16.6.7.1** (GPU vertex layout validation):

```cursive
[[repr(C, packed)]]
[[reflect]]
record GpuVertex {
    position: [f32; 3],
    normal: [f32; 3],
    uv: [f32; 2],
}

comptime {
    let info <- reflect_type::<GpuVertex>()

    comptime_assert(info.size == 32, "Vertex must be 32 bytes for GPU")
    comptime_assert(info.align == 1, "Packed alignment must be 1")

    let fields <- fields_of::<GpuVertex>()

    comptime_assert(fields[0].offset == 0, "position at offset 0")
    comptime_assert(fields[1].offset == 12, "normal at offset 12")
    comptime_assert(fields[2].offset == 24, "uv at offset 24")

    comptime_note("GPU vertex layout validated for shader compatibility")
}
```

##### §15.6.7.2 Component Registration

**Example 16.6.7.2** (ECS component registration with reflection):

```cursive
[[reflect]]
record Transform {
    position: [f32; 3],
    rotation: [f32; 4],
    scale: [f32; 3],
}

comptime procedure register_component<T>(): ()
    [[ comptime::codegen |- true => true ]]
{
    let type_id_val <- type_id<T>()
    let type_name_val <- type_name<T>()
    let size_val <- size_of<T>()

    codegen::declare_constant(
        name: string_concat("COMPONENT_ID_", type_name_val),
        ty: codegen::type_named("u64"),
        value: quote { $(type_id_val) }
    )

    codegen::declare_constant(
        name: string_concat("COMPONENT_SIZE_", type_name_val),
        ty: codegen::type_named("usize"),
        value: quote { $(size_val) }
    )

    comptime_note(string_concat("Registered component: ", type_name_val))
}

comptime { register_component::<Transform>() }

// Generated constants:
// let COMPONENT_ID_Transform: const u64 = <unique_id>
// let COMPONENT_SIZE_Transform: const usize = 44
```

##### §15.6.7.3 Automatic Getter Generation

**Example 16.6.7.3** (Reflection-driven getter generation):

```cursive
[[reflect]]
record Config {
    public database_url: string@View,
    public max_connections: usize,
    public timeout_seconds: u64,
}

comptime procedure generate_getters<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    let fields <- fields_of::<T>()

    loop field: FieldInfo in fields {
        if field.visibility == Visibility::Public {
            codegen::add_procedure(
                target: TypeRef::TypeId(type_id<T>()),
                spec: codegen::ProcedureSpec {
                    name: string_concat("get_", field.name),
                    visibility: codegen::Visibility::Public,
                    receiver: codegen::ReceiverSpec::Const,
                    params: [],
                    return_type: TypeRef::Named(field.ty_name),
                    sequent: codegen::sequent_pure(),
                    body: quote {
                        result self.$(field.name)
                    },
                }
            )
        }
    }
}

comptime { generate_getters::<Config>() }

// Generated procedures:
// procedure get_database_url(~): string@View { result self.database_url }
// procedure get_max_connections(~): usize { result self.max_connections }
// procedure get_timeout_seconds(~): u64 { result self.timeout_seconds }

let config = Config {
    database_url: "localhost:5432",
    max_connections: 100,
    timeout_seconds: 30,
}

let url = config::get_database_url()
```

#### §15.6.8 Reflection Constraints Summary [comptime.reflect.queries.constraints]

[30] All reflection query procedures share these constraints:

**Opt-in requirement:**

[31] Type `T` shall be marked with `[[reflect]]` attribute (diagnostic E15-101).

**Comptime context:**

[32] Reflection queries shall execute in comptime contexts only (diagnostic E15-110).

**Concrete types:**

[33] Generic types shall be instantiated with concrete arguments (diagnostic E15-112).

**Grant requirement:**

[34] Procedures returning structured metadata (`fields_of`, `procedures_of`, etc.) require `comptime::alloc` grant for constructing result arrays.

#### §15.6.9 Diagnostics [comptime.reflect.queries.diagnostics]

[35] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.15. — end note]

#### §15.6.10 Conformance Requirements [comptime.reflect.queries.requirements]

[36] A conforming implementation SHALL:

1. Provide complete reflection API: reflect_type, fields_of, has_field, field_info_of, field_offset, procedures_of, has_procedure, procedure_info_of, variants_of, has_variant, variant_info_of, states_of, transitions_of
2. Return accurate metadata matching actual type structure, layout, and declarations
3. Include field offsets computed per §9.6 [memory.layout]
4. Include procedure grant information from sequent grants clauses
5. Include parameter responsibility flags from `move` modifiers
6. Respect visibility modifiers: limit private field details cross-module
7. Support reflection on generic types when instantiated
8. Emit diagnostics E15-101, E15-110, E15-111, E15-112, E15-120, E15-121, E15-122
9. Execute reflection queries at compile time only
10. Provide deterministic results for identical type definitions

[37] A conforming implementation MAY:

1. Optimize reflection metadata storage format
2. Cache reflection query results
3. Provide additional reflection metadata as extensions

[38] A conforming implementation SHALL NOT:

1. Allow reflection on non-reflected types
2. Execute reflection queries at runtime (in base specification)
3. Return inaccurate metadata
4. Violate visibility constraints during reflection


### §15.7 Quote Expressions and Interpolation [comptime.quote]

#### §15.7.1 Overview [comptime.quote.overview]

[1] _Quote expressions_ capture Cursive code as data for later emission during code generation. They enable type-safe code templates with compile-time value interpolation, supporting metaprogramming patterns without textual macros.

[2] Quote expressions use the `quote` keyword to delimit code and the `$(...)` syntax to interpolate compile-time values into the quoted code.

[3] This subclause specifies quote expression syntax, interpolation semantics, the QuotedBlock and QuotedExpr types, and integration with the code generation API (§16.8).

#### §15.7.2 Syntax [comptime.quote.syntax]

[4] Quote expression syntax:

**Quote expressions** take one of the following forms:
```
"quote" <block_expr>
"quote" <expression>
```

**Interpolations** take one of the following forms:
```
"$" "(" <expression> ")"
"$" <identifier>
```

[ Note: See Annex A §A.4 [grammar.expression] for the normative `quote_expr` production.
— end note ]

[5] **Quote forms:**

- `quote { statements }` — Quote block for procedure bodies, statement sequences
- `quote expression` — Quote single expression for inline values

[6] **Interpolation syntax:**

- `$(expression)` — Evaluate `expression` at compile time and splice result as literal value
- `$(identifier)` — When `identifier` binds to a string value, splice as identifier in generated code

[ Note: Quote interpolation uses the `$` (dollar sign) character. This is the designated interpolation syntax in Cursive. The `$` glyph is specifically reserved for this purpose.
— end note ]

#### §15.7.3 Constraints [comptime.quote.constraints]

##### §15.7.3.1 Context Requirements

[7] _Comptime-only._ Quote expressions shall appear only in comptime contexts:

- Within `comptime { ... }` blocks
- Within comptime procedure bodies
- As arguments to codegen API procedures

[8] Using quote expressions in runtime contexts produces diagnostic E16-200.

##### §15.7.3.2 Interpolation Constraints

[9] _Compile-time evaluability._ Expressions within `$(...)` shall be compile-time evaluable. They may reference:

- Comptime bindings (variables in comptime scope)
- Comptime constants
- Results of comptime procedures
- Comptime intrinsics

[10] Runtime-only expressions within `$(...)` produce diagnostic E16-201.

[11] _Interpolated value types._ Interpolated expressions shall produce values that can be embedded as literals:

- Primitive values (integers, floats, booleans, characters)
- String values (for both literal strings and identifier interpolation)
- Arrays of embeddable values
- Tuples of embeddable values

[12] Attempting to interpolate non-embeddable values (procedures, types, witnesses) produces diagnostic E16-202.

##### §15.7.3.3 Quoted Code Constraints

[13] _Syntactic validity._ The code within `quote { ... }` shall be syntactically valid Cursive code, though it need not be type-correct at quotation time.

[14] _Post-interpolation correctness._ After interpolation resolution, the generated code shall be type-correct and well-formed. Type errors in generated code are detected during type checking phase (§2.2.4.3) and produce diagnostic E16-203.

#### §15.7.4 Semantics [comptime.quote.semantics]

##### §15.7.4.1 Quote Evaluation

[15] Quote expressions evaluate to opaque QuotedBlock or QuotedExpr values:

[ Given: Quote expression `quote c` where `c` is code ]

$$
\frac{\Gamma_{\text{ct}} \vdash c : \text{syntactically valid}}{\Gamma_{\text{ct}} \vdash \texttt{quote } c : \texttt{QuotedBlock}}
\tag{T-Quote}
$$

[16] The quoted code `c` is captured as data without execution. Interpolations are not evaluated at quotation time.

##### §15.7.4.2 Interpolation Resolution

[17] When a quote is used in code generation, interpolations are evaluated and their values spliced into the code:

[ Given: Quote `quote { ... $(e_1) ... $(e_n) ... }` ]

$$
\frac{\forall i.\, \langle e_i, \sigma_{\text{ct}} \rangle \Downarrow_{\text{ct}} \langle v_i, \sigma_{\text{ct}} \rangle}{\texttt{quote } \{ \ldots $(e_i) \ldots \} \text{ resolves to code with } v_i \text{ spliced}}
\tag{E-Quote-Interpolate}
$$

[18] Each interpolated expression evaluates to a compile-time value. The value is converted to source code syntax and inserted at the interpolation site.

##### §15.7.4.3 Value Interpolation

[19] **Literal value splicing.** Interpolating a primitive value embeds that value as a literal:

```cursive
let multiplier: const usize = 10

let body = quote {
    result x * $(multiplier)
}

// After interpolation: result x * 10
```

[20] The compile-time value `10` is spliced as the literal `10` in the generated code.

##### §15.7.4.4 Identifier Interpolation

[21] **Identifier splicing.** Interpolating a string value as an identifier uses that string as an actual identifier in generated code:

```cursive
let field_name: const string@View = "balance"

let getter_body = quote {
    result self.$(field_name)
}

// After interpolation: result self.balance
```

[22] The string `"balance"` is spliced as the identifier `balance` (not as a string literal).

[23] **Identifier context detection.** The compiler detects whether an interpolation appears in identifier position (field access, variable reference) or value position (literal) and interprets accordingly:

- **Identifier position**: `self.$(name)`, `$(function_name)(args)` — Splice as identifier
- **Value position**: `x + $(value)`, `$(array)[index]` — Splice as literal value

##### §15.7.4.5 Array and Tuple Interpolation

[24] Arrays and tuples of embeddable values may be interpolated:

```cursive
let values: const [i32; 3] = [1, 2, 3]

let body = quote {
    let data = $(values)
}

// After interpolation: let data = [1, 2, 3]
```

#### §15.7.5 Examples [comptime.quote.examples]

##### §15.7.5.1 Simple Value Interpolation

**Example 16.7.5.1** (Numeric constant):

```cursive
comptime {
    let buffer_size: const usize = 4096

    let init_body = quote {
        let buffer: [u8; $(buffer_size)] = [0; $(buffer_size)]
        result buffer
    }

    // Generates: let buffer: [u8; 4096] = [0; 4096]
}
```

##### §15.7.5.2 Identifier Interpolation

**Example 16.7.5.2** (Field access generation):

```cursive
comptime procedure generate_field_accessor(field_name: string@View, field_type: string@View): QuotedBlock
    [[ |- field_name.len() > 0 => true ]]
{
    result quote {
        result self.$(field_name)
    }
}

comptime {
    let accessor = generate_field_accessor("position", "Vector3")

    // Generated: result self.position
}
```

##### §15.7.5.3 Combined Interpolation

**Example 16.7.5.3** (Multiple interpolations):

```cursive
comptime procedure generate_setter(field_name: string@View, field_type: string@View): QuotedBlock
    [[ comptime::alloc |- field_name.len() > 0 => true ]]
{
    let temp_name <- gensym("old_value")

    result quote {
        let $(temp_name) = self.$(field_name)
        self.$(field_name) = new_value

        // Optional: log change
        if DEBUG_MODE {
            log_field_change($(field_name), $(temp_name), new_value)
        }
    }
}
```

##### §15.7.5.4 Quote in Procedure Spec

**Example 16.7.5.4** (Quote as procedure body):

```cursive
comptime {
    let max_value: const i32 = 100

    codegen::declare_procedure(codegen::ProcedureSpec {
        name: "clamp_to_max",
        visibility: codegen::Visibility::Public,
        receiver: codegen::ReceiverSpec::None,
        params: [
            codegen::ParamSpec {
                name: "value",
                ty: TypeRef::Named("i32"),
                permission: Permission::Const,
                responsible: false,
            },
        ],
        return_type: TypeRef::Named("i32"),
        sequent: codegen::sequent_pure(),
        body: quote {
            if value > $(max_value) {
                result $(max_value)
            } else {
                result value
            }
        },
    })
}

// Generated:
// procedure clamp_to_max(value: const i32): i32 {
//     if value > 100 {
//         result 100
//     } else {
//         result value
//     }
// }
```

#### §15.7.6 Interpolation Type Safety [comptime.quote.typesafety]

##### §15.7.6.1 Type Preservation

[25] Interpolation preserves type information where applicable. Interpolating typed values maintains their types in generated code:

```cursive
let count: const u32 = 50

let body = quote {
    let items: [Item; $(count)] = allocate()
}

// count is u32, interpolates as 50u32 (preserving type)
```

##### §15.7.6.2 Type Coercion

[26] When necessary, interpolated values may undergo compile-time type coercion to match context:

```cursive
let size: const u32 = 1024

let body = quote {
    let buffer: [u8; $(size as usize)] = [0; $(size as usize)]
}
```

[27] Explicit `as` casts within interpolations are evaluated at compile time.

#### §15.7.7 Diagnostics [comptime.quote.diagnostics]

[28] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.15. — end note]

#### §15.7.8 Conformance Requirements [comptime.quote.requirements]

[29] A conforming implementation SHALL:

1. Support `quote { ... }` and `quote expr` syntax
2. Implement `$(...)` interpolation syntax (dollar sign)
3. Evaluate interpolations at compile time during code generation
4. Splice interpolated values as literals or identifiers based on context
5. Restrict quote expressions to comptime contexts (E16-200)
6. Enforce compile-time evaluability of interpolated expressions (E16-201)
7. Type-check generated code after interpolation resolution
8. Support identifier, value, array, and tuple interpolation
9. Detect and report type errors in generated code (E16-203)
10. Preserve type information during value interpolation

[30] A conforming implementation MAY:

1. Optimize quote representation for memory efficiency
2. Cache quoted code structures

[31] A conforming implementation SHALL NOT:

1. Use syntax other than `$(...)` for interpolation
2. Allow quote expressions in runtime contexts
3. Evaluate interpolations non-deterministically
4. Generate syntactically invalid code from well-formed quotes


### §15.8 Code Generation API and Specifications [comptime.codegen.api]

#### §15.8.1 Overview [comptime.codegen.api.overview]

[1] The code generation API provides explicit procedures for programmatically creating declarations during compilation. All code generation uses type-safe specification structures rather than string templates, ensuring generated code is validated and type-checked.

[2] This subclause specifies the complete codegen API: TypeRef enumeration, specification structures (ProcedureSpec, TypeSpec, etc.), codegen namespace procedures, and the integration with the code generation phase (§2.2.4.4).

[3] Code generation requires the `comptime::codegen` grant and executes during the compile-time execution phase, with declarations emitted during the code generation phase for subsequent type checking.

#### §15.8.2 TypeRef Enumeration [comptime.codegen.api.typeref]

##### §15.8.2.1 TypeRef Structure

[4] The `TypeRef` enumeration represents type references in code generation specifications:

```cursive
enum TypeRef {
    Named(string@View),
    SelfType,
    Generic(string@View, [TypeRef]),
    Tuple([TypeRef]),
    Array(TypeRef, usize),
    Slice(TypeRef),
    Pointer(TypeRef, Permission),
    Function([TypeRef], TypeRef, [string@View]),
    TypeId(u64),
}
```

[5] **Variant semantics:**

- `Named(name)`: Reference type by fully-qualified name (e.g., "i32", "module::Point")
- `SelfType`: Reference to the implementing type (used in procedure receivers and return types)
- `Generic(name, args)`: Generic type instantiation (e.g., "Container" with args [TypeRef::Named("i32")])
- `Tuple(types)`: Tuple type with element type array
- `Array(elem, size)`: Array type `[elem; size]`
- `Slice(elem)`: Slice type `[elem]`
- `Pointer(pointee, perm)`: Pointer type with permission (const/unique/shared)
- `Function(params, ret, grants)`: Callable type with parameter types, return type, grant identifiers
- `TypeId(id)`: Reference type by its compile-time type ID from `type_id<T>()`

##### §15.8.2.2 TypeRef Construction

[6] TypeRef values are constructed in comptime contexts:

**Example 16.8.2.1** (TypeRef construction examples):

```cursive
comptime {
    // Primitive type
    let int_ref = TypeRef::Named("i32")

    // Array type
    let buffer_ref = TypeRef::Array(TypeRef::Named("u8"), 1024)

    // Generic type
    let container_ref = TypeRef::Generic(
        "Container",
        [TypeRef::Named("i32")]
    )

    // Tuple type
    let pair_ref = TypeRef::Tuple([
        TypeRef::Named("i32"),
        TypeRef::Named("string@View")
    ])

    // Pointer type with permission
    let ptr_ref = TypeRef::Pointer(
        TypeRef::Named("Buffer"),
        Permission::Unique
    )

    // Function type
    let callback_ref = TypeRef::Function(
        [TypeRef::Named("i32")],
        TypeRef::Named("bool"),
        []  // No grants
    )

    // Type by ID
    let by_id = TypeRef::TypeId(type_id<Point>())
}
```

#### §15.8.3 Specification Structures [comptime.codegen.api.specs]

##### §15.8.3.1 ProcedureSpec

[7] Complete procedure specification:

```cursive
record ProcedureSpec {
    name: string@View,
    visibility: Visibility,
    receiver: ReceiverSpec,
    params: [ParamSpec],
    return_type: TypeRef,
    sequent: SequentSpec,
    body: QuotedBlock,
}

enum ReceiverSpec {
    None,
    Const,
    Shared,
    Unique,
}

record ParamSpec {
    name: string@View,
    ty: TypeRef,
    permission: Permission,
    responsible: bool,
}

enum Permission {
    Const,
    Unique,
    Shared,
}

record SequentSpec {
    grants: [string@View],
    must: [string@View],
    will: [string@View],
}

enum Visibility {
    Public,
    Internal,
    Private,
    Protected,
}
```

[8] **ProcedureSpec field semantics:**

- `name`: Procedure identifier
- `visibility`: Visibility modifier (public/internal/private/protected)
- `receiver`: Receiver specification (None for static, Const/Shared/Unique for instance procedures)
- `params`: Parameter array in declaration order
- `return_type`: Return type reference
- `sequent`: Contractual sequent specification
- `body`: Quoted procedure body

[9] **ParamSpec field semantics:**

- `name`: Parameter identifier
- `ty`: Parameter type reference
- `permission`: Parameter permission (const/unique/shared)
- `responsible`: `true` if parameter should have `move` modifier (responsible), `false` for non-responsible

[10] **SequentSpec field semantics:**

- `grants`: Array of grant identifiers (e.g., ["alloc::heap", "io::write"])
- `must`: Array of precondition expressions as strings (empty for `true`)
- `will`: Array of postcondition expressions as strings (empty for `true`)

##### §15.8.3.2 TypeSpec

[11] Complete type specification:

```cursive
record TypeSpec {
    kind: TypeKind,
    name: string@View,
    visibility: Visibility,
    generics: [GenericParamSpec],
    fields: [FieldSpec],
    procedures: [ProcedureSpec],
    variants: [VariantSpec],
}

enum TypeKind {
    Record,
    Enum,
    Tuple,
}

record FieldSpec {
    name: string@View,
    ty: TypeRef,
    visibility: Visibility,
}

record VariantSpec {
    name: string@View,
    payload: [TypeRef],
}

record GenericParamSpec {
    name: string@View,
    kind: GenericKind,
    bounds: [string@View],
}

enum GenericKind {
    Type,
    Const(TypeRef),
    Grant,
}
```

[12] **TypeSpec field semantics:**

- `kind`: Type category (Record, Enum, or Tuple)
- `name`: Type identifier
- `visibility`: Visibility modifier
- `generics`: Array of generic parameter specifications
- `fields`: Array of field specifications (for records/tuples)
- `procedures`: Array of associated procedure specifications
- `variants`: Array of variant specifications (for enums)

##### §15.8.3.3 Helper Constructors

[13] Helper procedures for common specification patterns:

```cursive
comptime procedure sequent_pure(): SequentSpec
    [[ |- true => true ]]
{
    result SequentSpec {
        grants: [],
        must: [],
        will: [],
    }
}

comptime procedure sequent_with_grants(grants: [string@View]): SequentSpec
    [[ |- grants.len() > 0 => true ]]
{
    result SequentSpec {
        grants: grants,
        must: [],
        will: [],
    }
}

comptime procedure param_const(name: string@View, ty: TypeRef): ParamSpec
    [[ |- name.len() > 0 => true ]]
{
    result ParamSpec {
        name: name,
        ty: ty,
        permission: Permission::Const,
        responsible: false,
    }
}

comptime procedure param_unique(name: string@View, ty: TypeRef): ParamSpec
    [[ |- name.len() > 0 => true ]]
{
    result ParamSpec {
        name: name,
        ty: ty,
        permission: Permission::Unique,
        responsible: false,
    }
}
```

#### §15.8.4 Codegen API Procedures [comptime.codegen.api.procedures]

##### §15.8.4.1 Declaration Generation

[14] Core codegen procedures:

**declare_procedure**:

```cursive
comptime procedure codegen::declare_procedure(spec: ProcedureSpec): ()
    [[ comptime::codegen |- true => true ]]
```

[15] **Semantics.** Emits a procedure declaration based on the specification. The procedure name shall not conflict with existing declarations (diagnostic E16-210). Generated procedure is validated during type checking phase.

**declare_type**:

```cursive
comptime procedure codegen::declare_type(spec: TypeSpec): ()
    [[ comptime::codegen |- true => true ]]
```

[16] **Semantics.** Emits a type declaration (record or enum). Type name shall not conflict (diagnostic E16-211). Fields and procedures are validated for well-formedness.

**declare_constant**:

```cursive
comptime procedure codegen::declare_constant(
    name: string@View,
    ty: TypeRef,
    value: QuotedExpr
): ()
    [[ comptime::codegen |- name.len() > 0 => true ]]
```

[17] **Semantics.** Emits a module-level constant binding. The constant name shall not conflict (diagnostic E16-212). The quoted value shall be compile-time evaluable.

##### §15.8.4.2 Type Extension Procedures

[18] Procedures for extending existing types:

**add_procedure**:

```cursive
comptime procedure codegen::add_procedure(
    target: TypeRef,
    spec: ProcedureSpec
): ()
    [[ comptime::codegen |- true => true ]]
```

[19] **Semantics.** Adds a procedure to an existing type. Target type shall exist and be visible. Procedure name shall not conflict with existing procedures on the type (diagnostic E16-213).

**add_function**:

```cursive
comptime procedure codegen::add_function(
    target: TypeRef,
    spec: ProcedureSpec
): ()
    [[ comptime::codegen |- true => true ]]
```

[20] **Semantics.** Adds an associated function (static procedure) to an existing type. Similar constraints as `add_procedure`.

##### §15.8.4.3 Validation Rules

[21] **Name collision detection:**

$$
\frac{\text{Generated name } n \text{ already exists in scope}}{\text{ERROR E16-210/E16-211/E16-212: name collision}}
\tag{WF-Codegen-UniqueNames}
$$

[22] **Type well-formedness:**

$$
\frac{\text{TypeRef } r \text{ references non-existent type}}{\text{ERROR E16-220: type reference invalid}}
\tag{WF-Codegen-TypeRef}
$$

[23] **Target existence:**

$$
\frac{\texttt{add\_procedure}(\text{target}, \text{spec}) \quad target \text{ not found}}{\text{ERROR E16-221: target type not found}}
\tag{WF-Codegen-Target}
$$

#### §15.8.5 Complete Code Generation Examples [comptime.codegen.api.examples]

##### §15.8.5.1 Automatic Serialization

**Example 16.8.5.1** (Complete serialization generation):

```cursive
[[reflect]]
record Message {
    id: u64,
    content: string@Managed,
    timestamp: i64,
}

comptime procedure generate_serialization<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    let fields <- fields_of::<T>()

    // Generate serialize procedure
    codegen::add_procedure(
        target: TypeRef::TypeId(type_id<T>()),
        spec: codegen::ProcedureSpec {
            name: "serialize",
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::Const,
            params: [],
            return_type: TypeRef::Slice(TypeRef::Named("u8")),
            sequent: sequent_with_grants(["alloc::heap"]),
            body: build_serialize_body(fields),
        }
    )

    // Generate deserialize function
    codegen::add_function(
        target: TypeRef::TypeId(type_id<T>()),
        spec: codegen::ProcedureSpec {
            name: "deserialize",
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::None,
            params: [
                param_const("data", TypeRef::Slice(TypeRef::Named("u8"))),
            ],
            return_type: TypeRef::Generic("Result", [
                TypeRef::Named(type_name<T>()),
                TypeRef::Named("ParseError")
            ]),
            sequent: sequent_with_grants(["alloc::heap"]),
            body: build_deserialize_body(fields),
        }
    )
}

comptime procedure build_serialize_body(fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    let buffer_name <- gensym("buffer")

    result quote {
        let $(buffer_name): [u8] = []

        // Serialize each field (simplified - actual implementation would iterate properly)
        $(buffer_name) = append_field_bytes($(buffer_name), field_data)

        result $(buffer_name)
    }
}

comptime procedure build_deserialize_body(fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    result quote {
        // Parse fields from data (simplified)
        result parse_from_bytes(data)
    }
}

comptime { generate_serialization::<Message>() }

// Generated procedures available:
let msg = Message { id: 1, content: string::from("Hello"), timestamp: 1234567890 }
let serialized = msg::serialize()
```

##### §15.8.5.2 Builder Pattern

**Example 16.8.5.2** (Complete builder generation):

```cursive
[[reflect]]
record User {
    name: string@Managed,
    email: string@Managed,
    age: u32,
}

comptime procedure generate_builder<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    let type_name_val <- type_name<T>()
    let fields <- fields_of::<T>()

    var builder_fields: [codegen::FieldSpec] = []
    var setter_procedures: [codegen::ProcedureSpec] = []

    // Create optional field for each field
    loop field: FieldInfo in fields {
        builder_fields = array_push(builder_fields, codegen::FieldSpec {
            name: field.name,
            ty: TypeRef::Generic("Optional", [TypeRef::Named(field.ty_name)]),
            visibility: codegen::Visibility::Private,
        })

        // Create setter procedure
        setter_procedures = array_push(setter_procedures, codegen::ProcedureSpec {
            name: field.name,
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::Unique,
            params: [param_const("value", TypeRef::Named(field.ty_name))],
            return_type: TypeRef::SelfType,
            sequent: sequent_pure(),
            body: quote {
                self.$(field.name) = Optional::Some(value)
                result self
            },
        })
    }

    // Add build procedure
    let build_proc = codegen::ProcedureSpec {
        name: "build",
        visibility: codegen::Visibility::Public,
        receiver: codegen::ReceiverSpec::Unique,
        params: [],
        return_type: TypeRef::Generic("Result", [
            TypeRef::Named(type_name_val),
            TypeRef::Named("BuildError")
        ]),
        sequent: sequent_pure(),
        body: build_builder_build_procedure(fields),
    }

    setter_procedures = array_push(setter_procedures, build_proc)

    // Declare builder type
    codegen::declare_type(codegen::TypeSpec {
        kind: codegen::TypeKind::Record,
        name: string_concat(type_name_val, "Builder"),
        visibility: codegen::Visibility::Public,
        generics: [],
        fields: builder_fields,
        procedures: setter_procedures,
        variants: [],
    })
}

comptime procedure build_builder_build_procedure(fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    result quote {
        // Validate all fields are set (simplified)
        if !all_fields_set() {
            result Err(BuildError::MissingField)
        }

        result Ok(construct_from_optionals())
    }
}

comptime { generate_builder::<User>() }

// Usage:
let user = UserBuilder::new()
    ::name(string::from("Alice"))
    ::email(string::from("alice@example.com"))
    ::age(30)
    ::build()?
```

##### §15.8.5.3 Debug Formatting

**Example 16.8.5.3** (Debug formatting generation):

```cursive
[[reflect]]
record Point {
    x: f64,
    y: f64,
}

comptime procedure generate_debug<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    let type_name_val <- type_name<T>()
    let fields <- fields_of::<T>()

    codegen::add_procedure(
        target: TypeRef::TypeId(type_id<T>()),
        spec: codegen::ProcedureSpec {
            name: "debug_string",
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::Const,
            params: [],
            return_type: TypeRef::Named("string@Managed"),
            sequent: sequent_with_grants(["alloc::heap"]),
            body: build_debug_body(type_name_val, fields),
        }
    )
}

comptime procedure build_debug_body(type_name: string@View, fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    let result_name <- gensym("result")

    result quote {
        let $(result_name) = string::from($(type_name))
        $(result_name) = string_concat($(result_name), " { ")

        // Append field representations (simplified)
        $(result_name) = string_concat($(result_name), field_representations)

        $(result_name) = string_concat($(result_name), " }")
        result $(result_name)
    }
}

comptime { generate_debug::<Point>() }

let p = Point { x: 3.0, y: 4.0 }
println("{}", p::debug_string())
// Output: "Point { x: 3.0, y: 4.0 }"
```

#### §15.8.6 Struct-of-Arrays Transformation [comptime.codegen.api.soa]

**Example 16.8.6.1** (SoA for cache-friendly layout):

```cursive
[[reflect]]
record Entity {
    position: [f32; 3],
    velocity: [f32; 3],
    health: f32,
}

comptime procedure generate_soa<T, const N: usize>(): ()
    [[ comptime::alloc, comptime::codegen |- N > 0, N <= 10000 => true ]]
{
    let type_name_val <- type_name<T>()
    let fields <- fields_of::<T>()

    var soa_fields: [codegen::FieldSpec] = []

    // Transform F: T into Fs: [T; N]
    loop field: FieldInfo in fields {
        soa_fields = array_push(soa_fields, codegen::FieldSpec {
            name: string_concat(field.name, "s"),
            ty: TypeRef::Array(TypeRef::Named(field.ty_name), N),
            visibility: field.visibility,
        })
    }

    // Generate get(index) procedure
    let get_body = build_soa_get_body(fields)

    let get_proc = codegen::ProcedureSpec {
        name: "get",
        visibility: codegen::Visibility::Public,
        receiver: codegen::ReceiverSpec::Const,
        params: [param_const("index", TypeRef::Named("usize"))],
        return_type: TypeRef::Named(type_name_val),
        sequent: codegen::SequentSpec {
            grants: [],
            must: [string_concat("index < ", usize_to_string(N))],
            will: [],
        },
        body: get_body,
    }

    // Generate set(index, value) procedure
    let set_body = build_soa_set_body(fields)

    let set_proc = codegen::ProcedureSpec {
        name: "set",
        visibility: codegen::Visibility::Public,
        receiver: codegen::ReceiverSpec::Unique,
        params: [
            param_const("index", TypeRef::Named("usize")),
            param_const("value", TypeRef::Named(type_name_val)),
        ],
        return_type: TypeRef::Named("()"),
        sequent: codegen::SequentSpec {
            grants: [],
            must: [string_concat("index < ", usize_to_string(N))],
            will: [],
        },
        body: set_body,
    }

    // Declare SoA type
    codegen::declare_type(codegen::TypeSpec {
        kind: codegen::TypeKind::Record,
        name: string_concat(string_concat(type_name_val, "SoA"), usize_to_string(N)),
        visibility: codegen::Visibility::Public,
        generics: [],
        fields: soa_fields,
        procedures: [get_proc, set_proc],
        variants: [],
    })
}

comptime procedure build_soa_get_body(fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    result quote {
        // Construct T from SoA arrays
        result construct_from_arrays(index)
    }
}

comptime procedure build_soa_set_body(fields: [FieldInfo]): QuotedBlock
    [[ comptime::alloc |- fields.len() > 0 => true ]]
{
    result quote {
        // Store value fields into SoA arrays
        store_to_arrays(index, value)
    }
}

comptime { generate_soa::<Entity, 1024>() }

// Generated: EntitySoA1024 with array-of-structs layout transformed to struct-of-arrays
let entities = EntitySoA1024::default()
```

#### §15.8.7 Generated Code Validation [comptime.codegen.api.validation]

##### §15.8.7.1 Type Checking Phase

[24] Generated declarations are type-checked during the type checking phase (§2.2.4.3), after all code generation completes:

**Validation sequence:**

```
1. Comptime execution phase (§2.2.4.2)
   → Execute comptime blocks
   → Call codegen API procedures
   → Build declaration specifications

2. Code generation phase (§2.2.4.4)
   → Emit generated declarations to AST
   → Merge with original code

3. Type checking phase (§2.2.4.3)
   → Type check all code (original + generated)
   → Validate well-formedness
   → Emit diagnostics for errors
```

[25] **Type checking requirement:**

$$
\frac{\text{Generated declaration } d \text{ added to AST}}{\Gamma \vdash d : \text{well-formed} \quad \text{or ERROR E16-230}}
\tag{WF-Generated-Typechecked}
$$

[26] If generated code fails type checking, diagnostic E16-230 includes:

- Generated code location
- Originating comptime block/procedure
- Type-checking error details
- Suggested fixes

##### §15.8.7.2 Semantic Validation

[27] Beyond syntax and types, generated code is validated for:

- Sequent grant subsumption (called procedures' grants covered by caller's grants)
- Permission correctness (receivers match procedure permissions)
- Definite assignment (all paths initialize bindings)
- Move semantics (moved values not used after move)

[28] Violations produce standard diagnostics (E05-xxx, E07-xxx, E11-xxx) with additional context noting the code was generated.

#### §15.8.8 Diagnostics [comptime.codegen.api.diagnostics]

[29] [Note: Diagnostics defined in this subsection are cataloged in Annex E §E.5.1.15. — end note]

#### §15.8.9 Conformance Requirements [comptime.codegen.api.requirements]

[30] A conforming implementation SHALL:

1. Provide complete TypeRef enumeration with all specified variants
2. Provide all specification structures: ProcedureSpec, TypeSpec, FieldSpec, ParamSpec, VariantSpec, SequentSpec, GenericParamSpec
3. Implement codegen API: declare_procedure, declare_type, declare_constant, add_procedure, add_function
4. Validate TypeRef references resolve to existing types (E16-220)
5. Detect name collisions between generated and existing declarations (E16-210 through E16-213)
6. Validate target types exist for add_procedure/add_function (E16-221)
7. Type-check generated code during type checking phase (E16-230)
8. Support permission specifications in ParamSpec (const/unique/shared)
9. Support parameter responsibility in ParamSpec (responsible flag)
10. Support receiver specifications (None/Const/Shared/Unique)
11. Support full sequent specifications with grants, must, will clauses
12. Execute code generation during code generation phase (§2.2.4.4)
13. Emit diagnostics E16-210 through E16-233 for violations

[31] A conforming implementation MAY:

1. Provide additional specification structure fields as extensions
2. Provide additional codegen API procedures
3. Optimize code generation for performance
4. Provide enhanced diagnostics tracing generated code

[32] A conforming implementation SHALL NOT:

1. Generate code that violates type safety
2. Skip type checking of generated code
3. Allow name collisions without diagnostics
4. Generate code from malformed specifications without validation


### §15.9 Hygiene, Validation, and Conformance [comptime.conformance]

#### §15.9.1 Overview [comptime.conformance.overview]

[1] This subclause consolidates hygiene mechanisms, validation requirements, and conformance obligations for the complete compile-time evaluation and reflection system. It specifies name collision prevention, generated code validation, and the integration requirements that ensure compile-time features work correctly with the broader language.

[2] Hygiene ensures generated code does not accidentally capture user-defined names. Validation ensures generated code is type-safe and well-formed. Conformance requirements enumerate implementation obligations across all compile-time subsystems.

#### §15.9.2 Hygienic Code Generation [comptime.conformance.hygiene]

##### §15.9.2.1 Name Collision Problem

[3] Generated code may inadvertently use identifiers that collide with user-defined names, causing:

- Accidental shadowing of user bindings
- Type conflicts between generated and user types
- Compilation errors from duplicate declarations

[4] **Unsafe pattern (name collision risk):**

```cursive
comptime {
    codegen::insert_statement(quote {
        let buffer = allocate()  // May collide with user's 'buffer'
    })
}

let buffer = "user data"
// Generated code shadows user binding
```

##### §15.9.2.2 The gensym Intrinsic

[5] The `gensym` intrinsic generates globally unique identifiers:

```cursive
comptime procedure gensym(prefix: string@View): string@View
    [[ comptime::alloc |- prefix.len() > 0 => true ]]
```

[6] **Semantics.** Returns a unique identifier string of the form `{prefix}_gNNNNN` where `NNNNN` is a globally unique numeric suffix. Each call produces a distinct identifier.

[7] **Uniqueness guarantee:**

$$
\frac{\texttt{gensym}(p_1) = id_1 \quad \texttt{gensym}(p_2) = id_2}{id_1 \ne id_2}
\tag{P-Gensym-Unique}
$$

[8] The numeric suffix is globally unique across the entire compilation unit, ensuring no collisions with user code or other generated code.

##### §15.9.2.3 Hygienic Pattern

[9] **Best practice.** Use `gensym` for all local bindings in generated code:

```cursive
comptime {
    let buffer_name <- gensym("buffer")
    let temp_name <- gensym("temp")

    codegen::insert_statement(quote {
        let $(buffer_name) = allocate()
        let $(temp_name) = process($(buffer_name))
        output($(temp_name))
    })
}

// User code can safely use 'buffer' and 'temp'
let buffer = "safe"
let temp = "safe"

// Generated code uses buffer_g00001, temp_g00002
```

[10] **Collision-free guarantee.** Using `gensym` ensures generated identifiers never collide with:

- User-defined identifiers
- Other generated identifiers
- Reserved keywords (gensym avoids keywords automatically)
- Predeclared bindings

##### §15.9.2.4 Public Name Documentation

[11] When code generation creates public APIs, the generated names should be predictable and documented:

**Example 16.9.2.1** (Documented public names):

```cursive
// Documentation: This derive generates:
//   - procedure serialize(~): [u8]
//   - procedure deserialize(data: [u8]): T \/ ParseError
comptime procedure derive_serializable<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    // Generate with predictable names (documented)
    codegen::add_procedure(
        target: TypeRef::TypeId(type_id<T>()),
        spec: codegen::ProcedureSpec {
            name: "serialize",  // Documented public name
            visibility: codegen::Visibility::Public,
            // ...
        }
    )
}
```

[12] Public generated names are part of the API contract; internal generated names should use `gensym`.

#### §15.9.3 Generated Code Validation [comptime.conformance.validation]

##### §15.9.3.1 Validation Requirements

[13] All generated code shall undergo the same validation as hand-written code:

**Syntactic validation:**

[14] Generated code shall be syntactically valid. Malformed quote interpolation or invalid specifications produce diagnostic E16-240.

**Type checking:**

[15] Generated code shall type-check successfully during the type checking phase (§2.2.4.3). Type errors produce diagnostic E16-230 with context identifying the generating comptime block.

**Semantic validation:**

[16] Generated code shall satisfy all semantic constraints:

- Grant coverage (procedure grants cover all operations)
- Permission correctness (receivers and parameters have valid permissions)
- Definite assignment (all bindings initialized before use)
- Move semantics (moved values not used after move)
- Contract satisfaction (sequent preconditions/postconditions valid)

[17] Semantic violations produce standard diagnostics (E05-xxx, E07-xxx, E11-xxx, E12-xxx) annotated with generation context.

##### §15.9.3.2 Validation Failures

[18] **Diagnostic augmentation.** When generated code fails validation, diagnostics shall include:

- Original error diagnostic (e.g., E07-700 for type mismatch)
- Note identifying the comptime block or procedure that generated the code
- Source location of the generation site
- Generated code snippet showing the error
- Suggested fixes for the generation logic

**Example 16.9.3.1 - invalid** (Generated code with type error):

```cursive
comptime {
    codegen::declare_procedure(codegen::ProcedureSpec {
        name: "broken",
        visibility: codegen::Visibility::Public,
        receiver: codegen::ReceiverSpec::None,
        params: [],
        return_type: TypeRef::Named("i32"),
        sequent: sequent_pure(),
        body: quote {
            result "not an integer"  // Type error
        },
    })
}

// error[E16-230]: generated code failed type checking
//   in procedure 'broken' generated at line 1
//   type mismatch: expected i32, found string@View
// note: generated by comptime block at line 1, column 1
```

#### §15.9.4 Consolidated Conformance Requirements [comptime.conformance.requirements]

##### §15.9.4.1 Comptime Execution Requirements

[19] A conforming implementation SHALL (§§16.1–16.4):

1. Support `comptime procedure` declarations with syntax per §16.2
2. Execute comptime procedures and blocks during compile-time execution phase (§2.2.4.2)
3. Restrict comptime grants to: comptime::alloc, comptime::codegen, comptime::config, comptime::diag
4. Enforce minimum resource limits: 256 recursion, 1M steps, 64MiB memory, 1MiB strings, 10K collections
5. Provide intrinsics: comptime_assert, comptime_error, comptime_warning, comptime_note
6. Provide config queries: cfg, cfg_value, target_os, target_arch, target_endian, target_pointer_width
7. Provide type queries: type_name, type_id, size_of, align_of, is_copy, is_sized
8. Guarantee deterministic comptime evaluation
9. Evaluate comptime dependencies in topological order
10. Detect cyclic dependencies (E16-021)

##### §15.9.4.2 Reflection Requirements

[20] A conforming implementation SHALL (§§16.5–16.6):

1. Support `[[reflect]]` attribute on record, enum, modal type declarations
2. Enforce zero metadata overhead for types without `[[reflect]]`
3. Reject reflection queries on non-reflected types (E16-101)
4. Provide complete reflection API: reflect_type, fields_of, procedures_of, variants_of, states_of, transitions_of
5. Include accurate metadata: names, sizes, offsets, alignments, visibility
6. Include procedure sequent information in ProcedureInfo (grants, must, will)
7. Include parameter responsibility flags in ParamInfo
8. Restrict reflection queries to comptime contexts (E16-110)
9. Respect visibility modifiers during reflection
10. Support reflection on instantiated generic types

##### §15.9.4.3 Code Generation Requirements

[21] A conforming implementation SHALL (§§16.7–16.8):

1. Support quote expressions with `quote { ... }` and `quote expr` syntax
2. Implement quote interpolation using `$(...)` syntax (dollar sign)
3. Provide TypeRef enumeration with all variants
4. Provide specification structures: ProcedureSpec, TypeSpec, ParamSpec, SequentSpec, etc.
5. Implement codegen API: declare_procedure, declare_type, declare_constant, add_procedure, add_function
6. Provide gensym() for unique identifier generation
7. Type-check generated code during type checking phase
8. Detect name collisions (E16-210 through E16-213)
9. Validate TypeRef references (E16-220)
10. Validate codegen targets exist (E16-221)

##### §15.9.4.4 Hygiene Requirements

[22] A conforming implementation SHALL:

1. Implement gensym() producing globally unique identifiers
2. Guarantee gensym() never produces duplicate identifiers
3. Support identifier interpolation via `$(string_value)`
4. Allow quote expressions to use gensym() for collision-free names
5. Detect and report name collisions in generated code

#### §15.9.5 Complete Diagnostic Catalog [comptime.conformance.diagnostics]

[23] [Note: All diagnostic codes defined in Clause 15 are cataloged in Annex E §E.5.1.15. — end note]

#### §15.9.6 Integration Summary [comptime.conformance.integration]

[25] The compile-time system integrates with:

**Translation phases (Clause 2):**

- Comptime execution during §2.2.4.2
- Code generation during §2.2.4.4
- Type checking validates generated code in §2.2.4.3

**Declarations (Clause 5):**

- Comptime procedures follow §5.4 with `comptime` modifier
- Generated declarations follow §5.4 and §5.5

**Type system (Clause 7):**

- TypeRef references all type constructors
- Generated code type-checked per Clause 7 rules
- Reflection builds on §7.8

**Expressions (Clause 8):**

- Comptime blocks are expressions (§8.7)
- Quote extends expression grammar

**Generics (Clause 10):**

- Generic parameters in comptime procedures
- Reflection on generic types when instantiated

**Memory model (Clause 11):**

- Comptime::alloc provides compile-time allocation
- No region escape analysis for comptime allocations

**Contracts (Clause 12):**

- Comptime grant system extends general grants
- Generated procedures include full sequents

**Annex A (Grammar):**

- Quote expression productions
- Comptime block productions
- [[reflect]] attribute production

**Annex E (Diagnostics):**

- E16-001 through E16-299 diagnostic codes
- Structured payload specifications

#### §15.9.7 Best Practices [comptime.conformance.practices]

##### §15.9.7.1 Recommended Patterns

[26] **Use gensym for local names:**

```cursive
// GOOD: Hygienic
let temp <- gensym("temp")
codegen::insert_statement(quote {
    let $(temp) = compute()
})

// AVOID: May collide
codegen::insert_statement(quote {
    let temp = compute()  // Collision risk
})
```

[27] **Document public APIs:**

```cursive
// Generate public procedures with documented names
// GOOD: Predictable API
codegen::add_procedure(target, spec {
    name: "serialize",  // Documented public API
    visibility: Public,
    // ...
})
```

[28] **Validate generated code:**

```cursive
// Add assertions to detect generation errors early
comptime {
    let type_count = 0

    loop type_name in type_names {
        generate_for_type(type_name)
        type_count = type_count + 1
    }

    comptime_assert(type_count > 0, "Should have generated at least one type")
}
```

##### §15.9.7.2 Anti-Patterns

[29] **Avoid:**

- String-based code generation without quotes (type-unsafe)
- Hardcoded identifier names in quotes without gensym (collision-prone)
- Excessive comptime computation approaching resource limits (brittle)
- Reflection on types without `[[reflect]]` attribute (will fail)
- Generating code with runtime grants in comptime procedures (will fail)

#### §15.9.8 Complete Conformance Requirements [comptime.conformance.complete]

[30] A conforming implementation of Clause 16 SHALL:

**Execution and Evaluation:**

1. Support comptime procedures with `comptime` keyword modifier
2. Support comptime blocks with `comptime { ... }` syntax
3. Execute during compile-time execution phase (§2.2.4.2)
4. Restrict to comptime-safe grants: comptime::alloc, comptime::codegen, comptime::config, comptime::diag
5. Enforce purity (no runtime side effects except codegen)
6. Guarantee termination within resource limits
7. Provide deterministic evaluation for identical inputs
8. Evaluate dependencies in topological order

**Intrinsics and Configuration:**

9. Provide assertion intrinsics: comptime_assert, comptime_error, comptime_warning, comptime_note
10. Provide config queries: cfg, cfg_value
11. Provide platform queries: target_os, target_arch, target_endian, target_pointer_width
12. Provide type queries: type_name, type_id, size_of, align_of, is_copy, is_sized
13. Provide string utilities: string_concat, usize_to_string, parse_usize

**Reflection:**

14. Support `[[reflect]]` attribute on record, enum, modal types
15. Enforce zero metadata overhead for non-reflected types
16. Provide complete reflection API with accurate metadata
17. Restrict reflection to comptime contexts
18. Respect visibility during reflection queries
19. Include procedure sequent and parameter responsibility in metadata

**Code Generation:**

20. Support quote expressions with `$(...)` interpolation syntax
21. Provide TypeRef enumeration with all type constructor variants
22. Provide complete specification structures (ProcedureSpec, TypeSpec, etc.)
23. Implement codegen API (declare_procedure, declare_type, declare_constant, add_procedure, add_function)
24. Provide gensym() for unique identifier generation
25. Type-check generated code during type checking phase
26. Detect name collisions in generated code

**Diagnostics:**

27. Emit diagnostics E16-001 through E16-299 for all violations
28. Provide structured diagnostic payloads per Annex E §E.5
29. Trace generated code errors to generation sites

**Resource Limits (minimum):**

30. Recursion depth: 256 levels
31. Evaluation steps: 1,000,000 per comptime block
32. Memory allocation: 64 MiB per compilation unit
33. String size: 1 MiB per string value
34. Collection size: 10,000 elements

[31] A conforming implementation MAY:

1. Exceed minimum resource limits
2. Provide additional comptime intrinsics
3. Provide additional codegen API procedures
4. Optimize comptime evaluation and code generation
5. Cache comptime results across compilations
6. Provide runtime reflection (outside specification scope)

[32] A conforming implementation SHALL NOT:

1. Allow runtime grants in comptime contexts
2. Execute comptime code non-deterministically
3. Generate metadata for non-reflected types
4. Skip validation of generated code
5. Allow name collisions without diagnostics
6. Use interpolation syntax other than `$(...)`
7. Execute reflection queries at runtime (in base specification)
8. Violate zero-cost guarantee for unused features

#### §15.9.9 Quality of Implementation Recommendations [comptime.conformance.quality]

[33] Implementations SHOULD:

1. Provide clear diagnostic messages for comptime errors
2. Show comptime evaluation progress for long-running generation
3. Warn when approaching resource limits (50% thresholds)
4. Provide debugging tools for comptime code
5. Cache comptime results for incremental compilation
6. Optimize generated code alongside hand-written code
7. Provide IDE support for quote expressions and generated code
8. Generate readable code with proper formatting
9. Preserve comments in generated code when applicable
10. Provide tooling to inspect generated code

#### §15.9.10 Examples [comptime.conformance.examples]

**Example 16.9.10.1** (Complete derive pattern with hygiene):

```cursive
[[reflect]]
record Data {
    value: i32,
    label: string@View,
}

comptime procedure derive_debug<T>(): ()
    [[ comptime::alloc, comptime::codegen |- true => true ]]
{
    let type_name_val <- type_name<T>()
    let fields <- fields_of::<T>()

    let result_name <- gensym("result")
    let field_value_name <- gensym("field_value")

    codegen::add_procedure(
        target: TypeRef::TypeId(type_id<T>()),
        spec: codegen::ProcedureSpec {
            name: "debug",  // Public API name (documented)
            visibility: codegen::Visibility::Public,
            receiver: codegen::ReceiverSpec::Const,
            params: [],
            return_type: TypeRef::Named("string@Managed"),
            sequent: sequent_with_grants(["alloc::heap"]),
            body: quote {
                let $(result_name) = string::from($(type_name_val))
                $(result_name) = string_concat($(result_name), " { ")

                // Hygienic field iteration
                loop field_idx in 0..$(fields.len()) {
                    let $(field_value_name) = get_field_string(field_idx)
                    $(result_name) = string_concat($(result_name), $(field_value_name))
                }

                $(result_name) = string_concat($(result_name), " }")
                result $(result_name)
            },
        }
    )

    comptime_note(string_concat("Generated debug for ", type_name_val))
}

comptime { derive_debug::<Data>() }

// Usage:
let data = Data { value: 42, label: "test" }
println("{}", data::debug())
// Output: "Data { value: 42, label: test }"
```

[1] Demonstrates hygiene (gensym), reflection (fields_of), quote (interpolation), and code generation (add_procedure) working together.

#### §15.9.11 Conformance Summary [comptime.conformance.summary]

[34] Conforming implementations shall implement all features specified in §§16.1 through 16.9, emit all diagnostics E16-001 through E16-299, and satisfy all SHALL requirements. Deviations render an implementation non-conforming unless explicitly categorized as implementation-defined elsewhere in this specification.

[35] The compile-time evaluation and reflection system is a cohesive whole: comptime execution enables code generation, reflection provides the data for metaprogramming, quotes and interpolation enable type-safe code templates, and hygiene prevents name collisions. All components work together to provide powerful, safe, zero-cost compile-time capabilities.


This appendix is the single normative source for all Cursive grammar productions in ANTLR-style notation. Every other chapter references these productions instead of re-declaring them. For readability, individual clauses may use simplified notation, but this annex contains the complete, authoritative grammar suitable for parser generation.

[ Note: This grammar uses ANTLR-style EBNF notation. For simplified notation used in prose, see individual clause grammar sections. The grammar here is suitable for direct use with ANTLR parser generators and similar tools.
— end note ]

## A.1 Lexical Grammar

```antlr
identifier
    : ident_start ident_continue*
    ;

ident
    : identifier
    ;

ident_start
    : [a-zA-Z_]
    ;

ident_continue
    : [a-zA-Z0-9_]
    ;

NEWLINE
    : '\n' | '\r\n'
    ;

separator
    : NEWLINE | ';'
    ;

line_comment
    : '//' ~[\n\r]* (NEWLINE | EOF)
    ;

block_comment
    : '/*' (~'*/' | block_comment)* '*/'
    ;

doc_comment
    : '///' ~[\n\r]*
    ;

module_doc
    : '//!' ~[\n\r]*
    ;

attribute
    : '[[' attribute_body ']]'
    ;

attribute_body
    : ident ('(' attr_args? ')')?
    ;

attr_args
    : attr_arg (',' attr_arg)*
    ;

attr_arg
    : ident '(' attr_args? ')'
    | ident '=' literal
    | literal
    | ident
    ;

literal
    : integer_literal
    | float_literal
    | boolean_literal
    | char_literal
    | string_literal
    ;

nat
    : digit (digit | '_')*
    ;

integer_literal
    : dec_literal integer_suffix?
    | hex_literal integer_suffix?
    | oct_literal integer_suffix?
    | bin_literal integer_suffix?
    ;

dec_literal
    : digit (digit | '_')*
    ;

hex_literal
    : '0x' hex_digit (hex_digit | '_')*
    ;

oct_literal
    : '0o' oct_digit (oct_digit | '_')*
    ;

bin_literal
    : '0b' bin_digit (bin_digit | '_')*
    ;

integer_suffix
    : 'i8' | 'i16' | 'i32' | 'i64' | 'i128' | 'isize'
    | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'usize'
    ;

float_literal
    : dec_literal '.' dec_literal? exponent? float_suffix?
    | dec_literal exponent float_suffix?
    | '.' dec_literal exponent? float_suffix?
    ;

exponent
    : ('e' | 'E') ('+' | '-')? dec_literal
    ;

float_suffix
    : 'f32' | 'f64'
    ;

boolean_literal
    : 'true' | 'false'
    ;

char_literal
    : '\'' char_body '\''
    ;

char_body
    : char_escape
    | ~['\\\n\r]
    ;

char_escape
    : '\\' [nrt\\'\"0]
    | '\\x' hex_digit hex_digit
    | '\\u{' hex_digit+ '}'
    ;

string_literal
    : '"' string_char* '"'
    ;

string_char
    : string_escape
    | ~["\\]
    ;

string_escape
    : '\\' [nrt\\'\"0]
    | '\\x' hex_digit hex_digit
    | '\\u{' hex_digit+ '}'
    ;

digit
    : [0-9]
    ;

hex_digit
    : [0-9a-fA-F]
    ;

oct_digit
    : [0-7]
    ;

bin_digit
    : [0-1]
    ;
```

[ Note: Newline-sensitive statement termination rules are specified in Clause 2 §2.4.
— end note ]

## A.2 Type Grammar

```antlr
type
    : primitive_type
    | compound_type
    | permission_type
    | pointer_type
    | safe_ptr_type
    | modal_type
    | witness_type
    | function_type
    | transition_type
    | grant_poly_type
    | generic_type
    | union_type
    | self_type
    | permission_hole_type
    | type_hole
    ;

primitive_type
    : 'i8' | 'i16' | 'i32' | 'i64' | 'i128' | 'isize'
    | 'u8' | 'u16' | 'u32' | 'u64' | 'u128' | 'usize'
    | 'f32' | 'f64'
    | 'bool' | 'char' | 'string' | '!' | '()'
    ;

compound_type
    : array_type
    | slice_type
    | tuple_type
    ;

array_type
    : '[' type ';' integer_literal ']'
    ;

slice_type
    : '[' type ']'
    ;

tuple_type
    : '(' type (',' type)+ ')'
    ;

permission_type
    : 'const' type
    | 'unique' type
    | 'shared' type
    ;

// Context-sensitive permission defaults:
// - Bindings (let/var): bare T means const T (default immutable)
// - Parameters: bare T means const T (default immutable)
// - Returns: bare T means const T (default immutable)
// - Fields: bare T means const T (default immutable)

pointer_type
    : '*' type
    | '*mut' type
    ;

safe_ptr_type
    : 'Ptr' '<' type '>'
    | 'Ptr' '<' type '>' '@' ident
    ;
    // Standard modal states for Ptr<T>: @Null, @Valid, @Weak, @Expired

modal_type
    : ident '@' modal_state
    ;

modal_state
    : ident
    | '_?'
    ;

witness_type
    : 'witness' '<' witness_property '>' allocation_state?
    ;

witness_property
    : ident
    | ident '@' ident
    ;

allocation_state
    : '@' ('Stack' | 'Region' | 'Heap')
    ;

function_type
    : '(' type_list? ')' '->' type grant_annotation?
    ;

transition_type
    : '@' ident '->' '@' ident
    ;

grant_poly_type
    : 'forall' ident grant_bound? '.' function_type
    ;

grant_bound
    : 'where' ident '<:' '{' grant_set '}'
    ;

generic_type
    : ident '<' type_args '>'
    ;

type_args
    : type (',' type)*
    ;

type_list
    : type (',' type)*
    ;

union_type
    : type '\\/' type
    ;

self_type
    : 'Self'
    ;

grant_annotation
    : '!' grant_set
    ;

type_hole
    : '_?'
    ;

permission_hole_type
    : '_?' type
    ;
```

[ Note (normative; see Clause 8 §8.2 and §8.7):

- `permission_hole_type` appears only where a permission wrapper is expected; elaboration chooses `perm⋆ ∈ {readonly, unique, shared, owned}` and yields `perm⋆ Type`.
- When `_?` is immediately followed by a `type` token in a position that admits permission wrappers, the parser recognizes `permission_hole_type` rather than `type_hole`.
  — end note ]

[ Note: Range type constructors (`Range<T>`, `RangeInclusive<T>`, etc.) are defined in Clause 2 §2.4.
— end note ]

## A.3 Pattern Grammar

```antlr
pattern
    : wildcard_pattern
    | literal_pattern
    | ident_pattern
    | tuple_pattern
    | record_pattern
    | enum_pattern
    | modal_pattern
    | pattern 'as' ident
    ;

wildcard_pattern
    : '_'
    ;

literal_pattern
    : literal
    ;

ident_pattern
    : identifier
    ;

tuple_pattern
    : '(' pattern (',' pattern)+ ')'
    ;

record_pattern
    : ident '{' field_pattern_list? '}'
    ;

field_pattern_list
    : field_pattern (',' field_pattern)* ','?
    ;

field_pattern
    : ident (':' pattern)?
    ;

enum_pattern
    : ident ('::' ident)? pattern_payload?
    ;

pattern_payload
    : '(' pattern_list? ')'
    | '{' field_pattern_list '}'
    ;

pattern_list
    : pattern (',' pattern)* ','?
    ;

modal_pattern
    : ident '@' modal_pattern_state pattern_payload?
    ;

modal_pattern_state
    : ident
    | '_?'
    ;
```

## A.4 Expression Grammar

```antlr
expr
    : seq_expr
    ;

seq_expr
    : assignment_expr
    | assignment_expr separator expr
    ;

assignment_expr
    : pipeline_expr (assign_op pipeline_expr)*
    ;

pipeline_expr
    : range_expr ('=>' range_expr ':' type)*
    ;

range_expr
    : logical_or_expr range_suffix
    | range_prefix logical_or_expr
    | '..'
    | logical_or_expr
    ;

range_suffix
    : '..' logical_or_expr?
    | '..=' logical_or_expr
    ;

range_prefix
    : '..'
    | '..='
    ;

logical_or_expr
    : logical_and_expr ('||' logical_and_expr)*
    ;

logical_and_expr
    : bitwise_or_expr ('&&' bitwise_or_expr)*
    ;

bitwise_or_expr
    : bitwise_xor_expr ('|' bitwise_xor_expr)*
    ;

bitwise_xor_expr
    : bitwise_and_expr ('^' bitwise_and_expr)*
    ;

bitwise_and_expr
    : equality_expr ('&' equality_expr)*
    ;

equality_expr
    : relational_expr (eq_op relational_expr)?
    ;

relational_expr
    : shift_expr (rel_op shift_expr)?
    ;

shift_expr
    : additive_expr (shift_op additive_expr)*
    ;

additive_expr
    : multiplicative_expr (add_op multiplicative_expr)*
    ;

multiplicative_expr
    : power_expr (mul_op power_expr)*
    ;

power_expr
    : unary_expr ('**' unary_expr)*
    ;

unary_expr
    : caret_prefix unary_expr
    | unary_op unary_expr
    | postfix_expr
    ;

caret_prefix
    : '^'+
    ;

postfix_expr
    : primary_expr postfix_suffix*
    ;

postfix_suffix
    : '.' ident
    | '::' ident '(' argument_list? ')'
    | '.' integer_literal
    | '[' expr ']'
    | '[' range_suffix ']'
    | '(' argument_list? ')'
    | 'as' type
    | '?'
    ;

primary_expr
    : literal
    | identifier
    | expr_hole
    | tuple_expr
    | record_expr
    | enum_expr
    | array_expr
    | unit_expr
    | '(' expr ')'
    | block_expr
    | if_expr
    | match_expr
    | loop_expr
    | closure_expr
    | region_expr
    | comptime_expr
    | 'move' expr
    | 'contract' '(' expr ',' expr ',' expr ')'
    | 'transition' '(' expr ',' '@' ident ')'
    | 'return' expr?
    | 'defer' block_expr
    | 'continue' '(' expr ')'
    | 'abort' '(' expr ')'
    ;

unit_expr
    : '()'
    ;

tuple_expr
    : '(' expr ',' expr (',' expr)* ','? ')'
    ;

record_expr
    : ident '{' field_init_list? '}'
    ;

field_init_list
    : field_init (',' field_init)* ','?
    ;

field_init
    : ident ':' expr
    | ident
    ;

tuple_struct_expr
    : ident '(' expr (',' expr)* ','? ')'
    ;

enum_expr
    : ident '::' ident enum_payload?
    ;

enum_payload
    : '(' argument_list? ')'
    | '{' field_init_list '}'
    ;

array_expr
    : '[' expr (',' expr)* ','? ']'
    | '[' expr ';' expr ']'
    ;

slice_expr
    : expr '[' range ']'
    ;

range
    : expr '..' expr          // exclusive end
    | expr '..=' expr         // inclusive end
    | '..' expr               // from start
    | '..=' expr              // from start, inclusive end
    | expr '..'               // to end
    | '..'                    // full slice
    ;

argument_list
    : expr (',' expr)* ','?
    ;

if_expr
    : 'if' if_head block_expr ('else' (if_expr | block_expr))?
    ;

if_head
    : expr
    | 'let' pattern '=' expr
    ;

match_expr
    : 'match' expr '{' match_arm+ '}'
    ;

match_arm
    : pattern ('if' expr)? '=>' expr ','
    ;

loop_expr
    : 'loop' loop_head? loop_verif? loop_block
    ;

loop_head
    : pattern ':' type 'in' expr
    | expr
    ;

loop_verif
    : ('with' '{' assertion_list '}')? ('by' expr)?
    ;

loop_block
    : block_expr
    ;

block_expr
    : block_stmt
    ;

closure_expr
    : '|' param_list? '|' '->' expr
    | '|' param_list? '|' block_expr
    ;

region_expr
    : 'region' ident ('as' ident)? block_expr
    ;

comptime_expr
    : 'comptime' block_expr
    ;

assign_op
    : '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>='
    ;

unary_op
    : '-' | '!' | '*' | '&'
    ;
    // Note: ^, &, * are position-disambiguated:
    //  - Prefix position: unary (region alloc, address-of, deref)
    //  - Infix position: binary (XOR, AND, multiply)

add_op
    : '+' | '-'
    ;

mul_op
    : '*' | '/' | '%'
    ;

shift_op
    : '<<' | '>>'
    ;

eq_op
    : '==' | '!='
    ;

rel_op
    : '<' | '>' | '<=' | '>='
    ;

// Hole production for expressions (Clause 8 §8.5)
expr_hole
    : '_?' (':' type)?
    ;
```


## A.5 Statement Grammar

```antlr
statement
    : block_stmt
    | var_decl_stmt
    | assign_stmt
    | use_decl
    | expr_stmt
    | labeled_stmt
    | return_stmt
    | break_stmt
    | continue_stmt
    | defer_stmt
    | empty_stmt
    | grant_gated_branch
    | loop_with_region
    | with_block
    ;

block_stmt
    : '{' statement* '}'
    | '{' statement* 'result' expr '}'
    ;

var_decl_stmt
    : 'let' pattern (':' type)? binding_op expr
    | 'var' pattern (':' type)? binding_op expr
    | 'shadow' 'let' pattern (':' type)? binding_op expr
    | 'shadow' 'var' pattern (':' type)? binding_op expr
    ;

binding_op
    : '='
    | '<-'
    ;

assign_stmt
    : l_value assign_op expr
    ;

l_value
    : identifier
    | expr '.' ident
    | expr '.' integer_literal
    | expr '[' expr ']'
    | '*' expr
    ;

expr_stmt
    : expr
    ;

labeled_stmt
    : '\'' ident ':' statement
    ;

return_stmt
    : 'return' expr?
    ;

break_stmt
    : 'break' label_ref? expr?
    ;

continue_stmt
    : 'continue' label_ref?
    ;

label_ref
    : '\'' ident
    ;

defer_stmt
    : 'defer' block_stmt
    ;

empty_stmt
    : ';'
    ;

grant_gated_branch
    : 'comptime' 'if' grant_predicate block_stmt ('else' block_stmt)?
    ;

grant_predicate
    : 'grants_include' '(' grant_set ')'
    | 'grants_exclude' '(' grant_set ')'
    ;

loop_with_region
    : 'loop' pattern ':' type 'in' expr 'region' ident block_stmt
    ;

with_block
    : 'with' grant_list '{' implementation_list '}' block_stmt
    ;

grant_list
    : grant_path (',' grant_path)*
    ;

implementation_list
    : implementation (',' implementation)*
    ;

implementation
    : grant_path '.' ident '(' param_list? ')' '=>' expr
    ;
```

[ Note: `loop_with_region` is syntactic sugar for iterator loops with region allocation as described in Clause 11 §11.3 [memory.region].
— end note ]

[ Note: `with_block` provides custom implementations for grant operations within a specific scope. Complete grant semantics are specified in Clause 12 §12.3 [contract.grant].
— end note ]

## A.6 Declaration Grammar

```antlr
top_level
    : (decl | use_decl)*
    ;

use_decl
    : visibility_modifier? 'use' use_clause
    | 'import' module_path ('as' ident)?
    ;

decl
    : var_decl_stmt
    | type_decl
    | procedure_decl
    | contract_decl
    | behavior_decl
    | grant_decl
    ;

type_decl
    : 'type' ident generic_params? '=' type where_clause?
    | record_decl
    | tuple_struct_decl
    | enum_decl
    | union_decl
    | modal_decl
    ;

record_decl
    : attribute* visibility? 'record' ident generic_params?
      contract_clause_list?
      behavior_clause?
      where_clause?
      record_body
    ;

contract_clause_list
    : ':' contract_ref (',' contract_ref)*
    ;

behavior_clause
    : 'with' behavior_ref (',' behavior_ref)*
    ;

invariant
    : assertion
    ;

record_body
    : '{' record_item* '}'
    ;

record_item
    : partition_directive
    | record_member
    ;

record_member
    : record_field
    | procedure_decl
    ;

record_field
    : visibility? ident ':' type
    ;

partition_directive
    : '<<' (ident | '_') '>>'
    ;

tuple_struct_decl
    : attribute* visibility? 'record' ident '(' field_type (',' field_type)* ','? ')'
      ('{' procedure_decl* '}')?
    ;

field_type
    : visibility? type
    ;

enum_decl
    : attribute* visibility? 'enum' ident generic_params? where_clause? enum_body
    ;

enum_body
    : '{' enum_variant (',' enum_variant)* ','? '}'
    ;

enum_variant
    : ident pattern_payload?
    ;

union_decl
    : attribute* visibility? 'union' ident generic_params? where_clause? union_body
    ;

union_body
    : '{' union_field+ '}'
    ;

union_field
    : ident ':' type
    ;

modal_decl
    : attribute* visibility? 'modal' ident generic_params? where_clause? modal_body
    ;

modal_body
    : '{' modal_state+ state_coercion* procedure_decl* '}'
    ;

// Built-in Arena modal type (informative - actual declaration is internal)
// modal Arena {
//     @Active { ptr: Ptr<u8>, capacity: usize, allocated: usize }
//     @Active::alloc<T>(~!, value: T) -> @Active
//     @Active::alloc_array<T>(~!, count: usize) -> @Active
//     @Active::reset(~!) -> @Active
//     @Active::freeze(~) -> @Frozen
//     @Active::free(~!) -> @Freed
//
//     @Frozen { ptr: Ptr<u8>, allocated: usize }
//     @Frozen::thaw(~!) -> @Active
//     @Frozen::free(~!) -> @Freed
//
//     @Freed { }
// }

modal_state
    : '@' ident record_body where_clause?
    ;

state_coercion
    : 'coerce' '@' ident '<:' '@' ident coercion_constraint?
    ;

coercion_constraint
    : '{'
      ('cost' ':' cost ','?)?
      ('requires' ':' permission ','?)?
      ('grants' ':' grant_set ','?)?         // Canonical form
      '}'
    ;

cost
    : 'O(1)' | 'O(n)' | integer_literal
    ;

procedure_decl
    : attribute* visibility? procedure_kind transition_spec?
      ident generic_params?
      '(' param_list? ')' (':' type)?
      where_clause?
      contract_clause?
      callable_body
    ;

procedure_kind
    : 'procedure'
    | 'comptime' 'procedure'
    | 'extern' string_literal? 'procedure'
    ;

callable_body
    : block_stmt
    | '=' expression ';'
    | ';'
    ;

transition_spec
    : '@' ident '->' '@' ident
    ;

param_list
    : param (',' param)*
    ;

param
    : param_modifier? ident ':' type
    | self_param
    ;

param_modifier
    : 'move'
    ;

self_param
    : '~'            // Shorthand for self: const Self
    | '~%'           // Shorthand for self: shared Self
    | '~!'           // Shorthand for self: unique Self
    | 'self' ':' permission? self_type
    ;

contract_decl
    : attribute* visibility? 'contract' ident generic_params?
      contract_extends_clause? where_clause? contract_body
    ;

contract_extends_clause
    : ':' contract_ref (',' contract_ref)*
    ;

contract_ref
    : ident ('<' type_args '>')?
    ;

contract_body
    : '{' contract_item* '}'
    ;

contract_item
    : associated_type_decl
    | procedure_signature
    ;

associated_type_decl
    : 'type' ident type_bound?
    ;

type_bound
    : ':' behavior_bounds
    ;

procedure_signature
    : 'procedure' ident '(' param_list? ')' (':' type)?
      where_clause?
      contract_clause*
    ;

type_projection
    : ident '::' ident
    | 'Self' '::' ident
    ;

behavior_decl
    : attribute* visibility? 'behavior' ident generic_params?
      behavior_extension?
      where_clause?
      '{' behavior_item* '}'
    ;

grant_decl
    : visibility? 'grant' ident
    ;

behavior_extension
    : 'with' behavior_ref (',' behavior_ref)*
    ;

behavior_item
    : procedure_decl
    | type_decl
    ;

qualified_name
    : module_path '::' ident          // module_path::identifier
    | ident '::' ident                // alias::identifier (alias is an ident introduced by import)
    ;

module_path
    : ident ('::' ident)*
    ;

visibility_modifier
    : 'public'                    // Limited to 'public' for re-export intent in use declarations
    ;

qualified_path
    : module_path
    | module_path '::' ident
    ;

use_clause
    : qualified_path
    | qualified_path 'as' ident
    | qualified_path '::' '{' use_list '}'
    | qualified_path '::' '*'
    ;

use_list
    : use_specifier (',' use_specifier)*
    ;

use_specifier
    : ident
    | ident 'as' ident
    ;

ident_list
    : ident (',' ident)* ','?
    ;

visibility
    : 'public' | 'internal' | 'private' | 'protected'
    ;

generic_params
    : '<' generic_param (',' generic_param)* '>'
    ;

generic_param
    : type_param
    | const_param
    | grant_param
    ;

type_param
    : ident (':' behavior_bounds)?
    ;

const_param
    : 'const' ident ':' type
    ;

grant_param
    : ident                             // Grant parameter, e.g., G
    ;

behavior_bounds
    : behavior_ref ('+' behavior_ref)*
    ;

behavior_ref
    : ident ('<' type_args '>')?
    ;

where_clause
    : 'where' where_predicate (',' where_predicate)*
    ;

where_predicate
    : ident ':' behavior_bounds
    | type ':' behavior_bounds
    | ident '<:' '{' grant_set '}'        // Grant parameter bounds
    ;

permission
    : 'const' | 'unique' | 'shared'
    ;
```

## A.7 Contract Grammar

```antlr
contract_clause
    : sequent_clause
    ;

sequent_clause
    : '[[' sequent_spec ']]'
    ;

sequent_spec
    : grant_set '|-' antecedent '=>' consequent
    | grant_set '|-' antecedent
    | grant_set '|-' '=>' consequent
    | grant_set '|-'
    | '|-' antecedent '=>' consequent
    | '|-' antecedent '=>'
    | '|-' '=>' consequent
    | '|-' antecedent
    | antecedent '=>' consequent
    | grant_set
    ;

antecedent
    : predicate_block
    ;

consequent
    : predicate_block
    ;

predicate_block
    : assertion
    | assertion_list
    ;

assertion_list
    : assertion ('&&' assertion)*
    ;
```

[ Note: Explanation:

- `sequent_clause` — Contractual sequent in sequent calculus form, delimited by semantic brackets `⟦ ⟧` (Unicode U+27E6, U+27E7) or ASCII equivalent `[[ ]]`
- `sequent_spec` — The sequent proper: `grants ⊢ P ⇒ Q`
  - `grants` — Grant context (capability assumptions) as comma-separated list
  - `|-` — Turnstile (entailment), ASCII representation of `⊢`
  - `P` — Antecedent (preconditions)
  - `=>` — Implication, ASCII representation of `⇒`
  - `Q` — Consequent (postconditions)
- Sequent components may be omitted with smart defaulting:
  - Grant-only: `[[ io::write ]]` expands to `[[ io::write |- true => true ]]`
  - Precondition-only: `[[ x > 0 ]]` expands to `[[ x > 0 => true ]]` (canonical: `[[ |- x > 0 => true ]]`)
  - Postcondition-only: `[[ => result > 0 ]]` expands to `[[ true => result > 0 ]]` (canonical: `[[ |- true => result > 0 ]]`)
  - No grants: `[[ P => Q ]]` (preferred form, canonical: `[[ |- P => Q ]]`)
  - Pure function: entire sequent clause may be omitted, defaults to `[[ ∅ |- true => true ]]` (empty grant set, canonical form)

Conjunction within antecedents and consequents uses explicit `&&` operator, not comma separation.

The semantic brackets `⟦ ⟧` / `[[ ]]` are consistent with their use for type value sets (e.g., `⟦ bool ⟧ = {true, false}`) throughout this specification, creating a unified notation for formal semantic content.
— end note ]


## A.8 Assertion Grammar

```antlr
assertion
    : logic_expr
    ;

logic_expr
    : logic_expr '&&' logic_expr
    | logic_expr '||' logic_expr
    | '!' logic_expr
    | logic_term
    ;

logic_term
    : expr compare_op expr
    | 'forall' '(' ident 'in' expr ')' '{' assertion '}'
    | 'exists' '(' ident 'in' expr ')' '{' assertion '}'
    | '@old' '(' expr ')'
    | 'result'
    | expr
    ;

compare_op
    : '==' | '!=' | '<' | '>' | '<=' | '>='
    ;
```

## A.9 Grant Grammar

[ Note (normative): This section defines the grammar for grant specifications, which track compile-time capabilities and restrictions on procedure operations.
— end note ]

```antlr
grant_set
    : grant_ref (',' grant_ref)* ','?
    ;

grant_ref
    : grant_path
    | ident                       // Grant parameter reference (simple identifier)
    | '_?'                        // Grant inference hole
    ;

grant_path
    : ident ('::' ident)*       // e.g., alloc::heap, fs::write
    ;

// Built-in grant categories
alloc_grant
    : 'alloc' '::' ('heap' | 'region' | 'stack' | 'temp' | '*')
    ;

file_system_grant
    : 'fs' '::' ('read' | 'write' | 'delete' | 'metadata' | '*')
    ;

network_grant
    : 'net' '::' ('read' | 'write' | 'connect' | 'listen' | '*')
    ;

time_grant
    : 'time' '::' ('read' | 'sleep' | 'monotonic' | '*')
    ;

thread_grant
    : 'thread' '::' ('spawn' | 'join' | 'atomic' | '*')
    ;

ffi_grant
    : 'ffi' '::' ('call' | '*')
    ;

unsafe_grant
    : 'unsafe' '::' ('ptr' | 'transmute' | '*')
    ;

panic_grant
    : 'panic'
    ;
```

[ Note: Grant parameters are declared in generic parameter lists (§A.6) and referenced in grant sets using `grants<G>` syntax. — end note ]

**Example A.9.1 (Grant polymorphism):**

```cursive
procedure process<T, G>(data: T): Result<T>
    grants<G>, alloc::heap
    where G <: {fs::read, net::read}
{
    // Procedure body can use grants<G> and alloc::heap
}
```

[ Note: Grant Inference: The `_?` hole allows the compiler to infer required grants based on procedure body (see Clause 8 §8.x and Clause 9 §9.x).
— end note ]

[ Note: Forward Reference: Complete grant semantics, propagation rules, and verification are specified in Clause 12 [contract] (Contracts and Grants).
— end note ]

---

## A.10 Consolidated Grammar Reference

[1] This section provides a consolidated reference grouping all grammar productions by syntactic category for quick lookup. The authoritative definitions appear in §§A.1–A.9 above; this section provides navigation only.

### A.10.1 Lexical Productions

**Identifiers**: `identifier`, `ident_start`, `ident_continue`  
**Literals**: `literal`, `integer_literal`, `float_literal`, `boolean_literal`, `char_literal`, `string_literal`  
**Numeric**: `dec_literal`, `hex_literal`, `oct_literal`, `bin_literal`, `integer_suffix`, `float_suffix`  
**Comments**: `line_comment`, `block_comment`, `doc_comment`, `module_doc`  
**Separators**: `NEWLINE`, `separator`  
**Attributes**: `attribute`, `attribute_body`, `attr_args`, `attr_arg`

### A.10.2 Type Productions

**Primitive types**: `primitive_type` (integers, floats, bool, char, string, unit, never)  
**Compound types**: `array_type`, `slice_type`, `tuple_type`  
**Permission types**: `permission_type` (const, unique, shared)  
**Pointer types**: `pointer_type` (raw), `safe_ptr_type` (modal)  
**Modal types**: `modal_type`, `modal_state`  
**Witness types**: `witness_type`, `witness_property`, `allocation_state`  
**Function types**: `function_type`, `transition_type`  
**Generic types**: `generic_type`, `type_args`  
**Union types**: `union_type`  
**Special**: `self_type`, `type_hole`, `permission_hole_type`

### A.10.3 Pattern Productions

**Patterns**: `pattern`, `wildcard_pattern`, `literal_pattern`, `ident_pattern`, `tuple_pattern`, `record_pattern`, `enum_pattern`, `modal_pattern`  
**Pattern components**: `field_pattern_list`, `pattern_payload`, `pattern_list`

### A.10.4 Expression Productions

**Expression hierarchy**: `expr`, `seq_expr`, `assignment_expr`, `pipeline_expr`, `range_expr`  
**Logical operators**: `logical_or_expr`, `logical_and_expr`  
**Bitwise operators**: `bitwise_or_expr`, `bitwise_xor_expr`, `bitwise_and_expr`  
**Comparison**: `equality_expr`, `relational_expr`  
**Arithmetic**: `additive_expr`, `multiplicative_expr`, `power_expr`, `shift_expr`  
**Unary**: `unary_expr`, `unary_op`, `caret_prefix`  
**Postfix**: `postfix_expr`, `postfix_suffix` (includes `'as' type` cast operator)  
**Primary**: `primary_expr`, `literal`, `identifier`, `tuple_expr`, `record_expr`, `enum_expr`, `array_expr`, `unit_expr`  
**Control flow**: `if_expr`, `match_expr`, `loop_expr`, `block_expr`  
**Advanced**: `closure_expr`, `region_expr`, `comptime_expr`  
**Operators**: `assign_op`, `add_op`, `mul_op`, `shift_op`, `eq_op`, `rel_op`, `'as'` (type cast)

### A.10.5 Statement Productions

**Statements**: `statement`, `block_stmt`, `var_decl_stmt`, `assign_stmt`, `expr_stmt`, `labeled_stmt`, `return_stmt`, `break_stmt`, `continue_stmt`, `defer_stmt`, `empty_stmt`  
**L-values**: `l_value`  
**Labels**: `label_ref`  
**Special**: `grant_gated_branch`, `loop_with_region`, `with_block`

### A.10.6 Declaration Productions

**Top level**: `top_level`, `use_decl`, `decl`  
**Module syntax**: `visibility_modifier`, `qualified_path`, `use_clause`, `use_list`, `use_specifier`, `module_path`, `qualified_name`  
**Types**: `type_decl`, `record_decl`, `tuple_struct_decl`, `enum_decl`, `union_decl`, `modal_decl`  
**Procedures**: `procedure_decl`, `procedure_kind`, `callable_body`, `param_list`, `param`, `param_modifier`, `self_param`  
**Contracts**: `contract_decl`, `contract_extends_clause`, `contract_body`, `contract_item`, `procedure_signature`  
**Behaviors**: `behavior_decl`, `behavior_extension`, `behavior_item`  
**Grants**: `grant_decl`  
**Components**: `record_body`, `record_item`, `record_member`, `record_field`, `partition_directive`, `enum_body`, `enum_variant`, `modal_body`, `modal_state`  
**Generics**: `generic_params`, `generic_param`, `type_param`, `const_param`, `grant_param`, `behavior_bounds`, `where_clause`, `where_predicate`  
**Visibility**: `visibility`, `visibility_modifier`  
**Associated types**: `associated_type_decl`, `type_projection`  
**Qualifiers**: `permission`, `binding_op`

### A.10.7 Contract Grammar Productions

**Sequents**: `contract_clause`, `sequent_clause`, `sequent_spec`  
**Components**: `antecedent`, `consequent`, `predicate_block`, `assertion_list`  
**Reference**: Complete sequent syntax specified in §A.7

### A.10.8 Assertion Grammar Productions

**Assertions**: `assertion`, `logic_expr`, `logic_term`  
**Operators**: `compare_op`  
**Quantifiers**: `forall`, `exists` (in logic_term)  
**Special**: `@old` operator, `result` identifier

### A.10.9 Grant Grammar Productions

**Grants**: `grant_set`, `grant_ref`, `grant_path`  
**Built-in categories**: `alloc_grant`, `file_system_grant`, `network_grant`, `time_grant`, `thread_grant`, `ffi_grant`, `unsafe_grant`, `panic_grant`  
**Reference**: Complete grant semantics in Clause 12 §12.3

### A.10.10 Grammar Production Cross-Reference Table

[2] Table A.10 provides a complete index of all grammar productions defined in this annex:

| Production     | Section | Category    | Used In                   |
| -------------- | ------- | ----------- | ------------------------- |
| identifier     | A.1     | Lexical     | All constructs            |
| type           | A.2     | Type        | Declarations, annotations |
| pattern        | A.3     | Pattern     | Match, destructuring      |
| expr           | A.4     | Expression  | All executable contexts   |
| statement      | A.5     | Statement   | Procedure bodies          |
| decl           | A.6     | Declaration | Module scope              |
| grant_decl     | A.6     | Declaration | Grant declarations        |
| sequent_clause | A.7     | Contract    | Procedure signatures      |
| assertion      | A.8     | Assertion   | Contracts, invariants     |
| grant_set      | A.9     | Grant       | Sequent grants clause     |

[3] The grammar is complete and unambiguous. All productions are defined with clear precedence and associativity. Implementations should be able to generate parsers directly from these ANTLR-style productions.


### §B.1 Implementation-Defined Behavior Catalog [behavior.implementation]

[1] This annex enumerates all behaviors for which this specification permits multiple valid implementations. Each entry identifies the clause where the behavior is described, enumerates the permitted choices, and specifies the documentation obligations imposed on conforming implementations.

[2] Conforming implementations shall document their choices for each implementation-defined behavior listed below.

#### §B.1.1 Numeric Representation

**B.1.01 — Integer Type Widths Beyond Mandated Minima**

- **Description**: While this specification mandates minimum sizes for integer types (Table 7.2.1), implementations may provide larger representations on platforms where doing so improves performance or matches platform conventions.
- **Permitted Choices**: Implementations may use wider representations provided the value sets remain compatible.
- **References**: §7.2.2 [type.primitive.int], §11.6 [memory.layout]
- **Documentation Required**: Actual sizes for `i128`/`u128` and pointer-width types (`isize`/`usize`) on each target platform.

**B.1.02 — 128-bit Integer Alignment**

- **Description**: Alignment for `i128` and `u128` types.
- **Permitted Choices**: 8 bytes or 16 bytes alignment.
- **References**: §7.2.2, Table 7.2.1
- **Documentation Required**: Whether implementation uses 8 or 16-byte alignment for 128-bit integers.

**B.1.03 — Floating-Point Subnormal Handling**

- **Description**: Treatment of subnormal (denormalized) floating-point numbers.
- **Permitted Choices**: Full IEEE 754 subnormal support, or flush-to-zero.
- **References**: §7.2.3 [type.primitive.float]
- **Documentation Required**: Whether subnormals are supported or flushed to zero.

**B.1.04 — Endianness**

- **Description**: Byte order for multi-byte values.
- **Permitted Choices**: Little-endian, big-endian, or bi-endian (runtime selectable).
- **References**: §7.2.2 [type.primitive.int], §15.6.4
- **Documentation Required**: Endianness for each target platform.

#### §B.1.2 Memory and Layout

**B.1.05 — Pointer Size and Alignment**

- **Description**: Size and alignment of pointer types and `usize`/`isize`.
- **Permitted Choices**: 4 bytes (32-bit), 8 bytes (64-bit), or other platform-specific widths.
- **References**: §7.5 [type.pointer], Table 11.6
- **Documentation Required**: Pointer size for each target architecture.

**B.1.06 — Native Type Layout**

- **Description**: Memory layout for types without `[[repr(C)]]` or other repr attributes.
- **Permitted Choices**: Implementations may reorder fields, insert padding, or optimize layout.
- **References**: §11.6 [memory.layout]
- **Documentation Required**: Whether implementation optimizes layout or preserves declaration order for native types.

**B.1.07 — Maximum Source File Size**

- **Description**: Maximum size of source files accepted by the compiler.
- **Permitted Choices**: At least 1 MiB; implementations may support larger files.
- **References**: §2.1.3[5]
- **Documentation Required**: Actual maximum file size supported.

**B.1.08 — Maximum Stack Size**

- **Description**: Size of procedure call stack.
- **Permitted Choices**: Platform-dependent, typically 1-8 MiB.
- **References**: §10.2.3 [memory.object.storage]
- **Documentation Required**: Stack size limits and whether they are configurable.

#### §B.1.3 Translation Limits

**B.1.09 — Comptime Resource Limits**

- **Description**: Resource limits for compile-time evaluation beyond mandated minima.
- **Permitted Choices**: May exceed minimums specified in §2.2.3 (256 recursion depth, 1M steps, 64 MiB memory).
- **References**: §2.2.3, §16.2.3.3
- **Documentation Required**: Actual resource limits for comptime evaluation.

**B.1.10 — Monomorphization Limits**

- **Description**: Maximum number of generic instantiations.
- **Permitted Choices**: At least 1024 instantiations per generic entity.
- **References**: §10.6.9.3
- **Documentation Required**: Actual monomorphization limits.

**B.1.11 — Delimiter Nesting Depth**

- **Description**: Maximum nesting level for delimiters (parentheses, brackets, braces).
- **Permitted Choices**: At least 256 levels.
- **References**: §2.4.3[3.1]
- **Documentation Required**: Actual maximum nesting depth.

#### §B.1.4 Diagnostic Formatting

**B.1.12 — Diagnostic Display Format**

- **Description**: Presentation style for diagnostic messages.
- **Permitted Choices**: Implementations may use color, Unicode box-drawing, ASCII-only, or custom formats.
- **References**: §1.5.5 [intro.conformance.diagnostics], Annex E §E.5.6
- **Documentation Required**: Supported output formats and default style.

**B.1.13 — Diagnostic Payload Schema**

- **Description**: Machine-readable diagnostic output schema details.
- **Permitted Choices**: JSON Lines (required minimum), plus optionally XML, Protocol Buffers, or custom formats.
- **References**: Annex E §E.5.6
- **Documentation Required**: Supported schema formats.

#### §B.1.5 ABI and Interoperability

**B.1.14 — Name Mangling Scheme**

- **Description**: Symbol name mangling for external linkage entities.
- **Permitted Choices**: Implementation-defined mangling scheme or no mangling.
- **References**: §15.5.6 [interop.linkage]
- **Documentation Required**: Complete mangling algorithm or statement of no-mangling policy.

**B.1.15 — Calling Convention Details**

- **Description**: Exact register allocation and stack frame layout for each supported calling convention.
- **Permitted Choices**: Must follow platform ABI specifications (System V AMD64, Microsoft x64, ARM AAPCS).
- **References**: §15.6.2 [interop.abi], §15.6.5
- **Documentation Required**: Calling convention details for each supported platform.

**B.1.16 — Binary Compatibility Policy**

- **Description**: Whether implementation provides binary compatibility across versions.
- **Permitted Choices**: No guarantee (source-level only) or explicit ABI stability guarantees.
- **References**: §15.7.2 [interop.compatibility]
- **Documentation Required**: ABI stability policy and versioning scheme if applicable.

#### §B.1.6 Platform-Specific

**B.1.17 — Unicode Normalization Form**

- **Description**: Which Unicode normalization form is used for source text.
- **Permitted Choices**: NFC, NFD, NFKC, or NFKD.
- **References**: §2.1.4[2]
- **Documentation Required**: Normalization form used and whether conversions are performed.

**B.1.18 — Panic Unwinding Support**

- **Description**: Whether panic unwinding is supported or abort-only.
- **Permitted Choices**: Full unwinding, abort-on-panic, or mode-selectable.
- **References**: §11.2.5.5 [memory.object.destructor.panic]
- **Documentation Required**: Unwinding support and configuration options.

**B.1.19 — Weak Symbol Support**

- **Description**: Whether weak symbols are supported on the target platform.
- **Permitted Choices**: Full support, partial support, or unsupported.
- **References**: §15.5.7 [interop.linkage]
- **Documentation Required**: Which platforms support weak symbols and any limitations.

**B.1.20 — Default Verification Mode**

- **Description**: Default contract verification strategy when no `[[verify(...)]]` attribute is present.
- **Permitted Choices**: Implementation-defined mapping of build modes to verification strategies.
- **References**: §12.8.7, Table 12.3
- **Documentation Required**: How `--build=debug` and `--build=release` map to verification modes.

[3] Implementations shall publish a conformance document listing their choices for each implementation-defined behavior above. The document shall be publicly available and included with compiler distribution.

---

### §B.2 Undefined Behavior Catalog [behavior.undefined]

[2] This annex provides the authoritative catalog of undefined behaviors (UB-IDs) referenced throughout the specification. Each entry includes the UB identifier, a complete description, the operations that trigger it, detection feasibility, and references to clauses where it is mentioned.

[3] **Warning**: Programs exhibiting undefined behavior cease to be conforming. Implementations may produce any result once undefined behavior is triggered, including but not limited to: program crashes, data corruption, security vulnerabilities, or apparently correct behavior. Programmers must avoid all undefined behavior; tools may assist but cannot guarantee detection in all cases.

#### §B.2.1 Memory Safety Violations

**B.2.01 — Access to Object Outside Its Lifetime**

- **Description**: Accessing an object through any means (dereferencing a dangling pointer, using a moved-from binding, reading destroyed storage, accessing region-allocated memory after region exit) after the object's lifetime has ended or before the object's lifetime has begun.
- **Triggering Operations**:
  - Dereferencing a pointer after the pointed-to object has been destroyed
  - Using a binding after it has been moved
  - Accessing region-allocated values after the region has exited
  - Reading from uninitialized storage (also covered by B.2.02)
- **Detection**: Prevented by region escape analysis (§11.3.3), move checking (§11.5), and definite assignment (§5.7) in safe code. May occur in unsafe code or through FFI.
- **References**: §11.2, §11.5, §11.3, Clause 15
- **Consequences**: Memory corruption, crashes, security vulnerabilities

**B.2.02 — Read of Uninitialized Memory**

- **Description**: Reading the value of an object that has allocated storage but has not been initialized.
- **Triggering Operations**:
  - Reading a variable before assignment
  - Dereferencing a pointer to uninitialized memory
  - Accessing uninitialized array elements
- **Detection**: Prevented by definite assignment analysis (§5.7) in safe code. May occur in unsafe code when reading raw pointers.
- **References**: §5.7 [decl.initialization]
- **Consequences**: Reading indeterminate values, potential security issues if uninitialized memory contains sensitive data

**B.2.03 — Double Free**

- **Description**: Destroying an object multiple times or freeing memory that has already been freed.
- **Triggering Operations**:
  - Multiple responsible bindings to the same object (prevented in safe code)
  - Manual free of region-allocated memory
  - FFI interaction where both Cursive and foreign code free the same memory
- **Detection**: Prevented by cleanup responsibility tracking in safe code. May occur in unsafe code or FFI.
- **References**: §11.2.2, §11.5, Clause 15
- **Consequences**: Heap corruption, crashes, security vulnerabilities

**B.2.04 — Null Pointer Dereference**

- **Description**: Dereferencing a raw null pointer.
- **Triggering Operations**:
  - Dereferencing `*const T` or `*mut T` when the pointer is null
  - Calling foreign functions with null pointers when they expect non-null
- **Detection**: Prevented for safe pointers (`Ptr<T>@Valid` cannot be null). May occur with raw pointers in unsafe code or FFI.
- **References**: §7.5.5 [type.pointer.raw], §15.2.5
- **Consequences**: Segmentation fault, crash

#### §B.2.2 Alignment and Layout Violations

**B.2.10 — Misaligned Object Access**

- **Description**: Accessing an object at an address that does not satisfy the type's alignment requirement on platforms with strict alignment enforcement.
- **Triggering Operations**:
  - Casting pointer to type with stricter alignment requirement
  - Using `[[repr(packed)]]` and accessing fields without unaligned-load intrinsics
  - FFI passing misaligned pointers to functions expecting alignment
- **Detection**: Platform-dependent. Some platforms (ARM) fault on misalignment; others (x86-64) tolerate with performance penalty.
- **References**: §11.6 [memory.layout], §15.2.2.2
- **Consequences**: Hardware fault, performance degradation, or silent data corruption depending on platform

**B.2.11 — Invalid Type Representation**

- **Description**: Reading a value whose bit pattern is not valid for its type.
- **Triggering Operations**:
  - Transmuting to type with invalid bit pattern
  - Reading uninitialized bool (value other than 0 or 1)
  - Reading invalid enum discriminant
  - Foreign code providing invalid values via FFI
- **Detection**: Compiler cannot detect; programmer responsibility in unsafe code.
- **References**: §11.2.2 [memory.object.model], §11.8.3.3
- **Consequences**: Logic errors, potential exploits, type confusion

#### §B.2.3 Type System Violations

**B.2.15 — Type Confusion**

- **Description**: Treating a value of one type as if it were another incompatible type.
- **Triggering Operations**:
  - Invalid transmute between incompatible types
  - FFI providing value of different type than declared
  - Unsafe pointer cast followed by dereference
- **Detection**: Type system prevents in safe code. May occur in unsafe code or FFI.
- **References**: §7.5.5, §11.8, Clause 15
- **Consequences**: Memory corruption, security vulnerabilities, crashes

#### §B.2.4 Unsafe Operation Violations

**B.2.25 — Invalid Transmute**

- **Description**: Using transmute with incompatible sizes or interpreting bit patterns that are invalid for the target type.
- **Triggering Operations**:
  - `transmute::<From, To>(value)` where `sizeof(From) != sizeof(To)`
  - Transmuting to type where bit pattern is invalid
- **Detection**: Size mismatch detected at compile time. Bit pattern validity is programmer responsibility.
- **References**: §11.8.3.3[10-11]
- **Consequences**: Memory corruption if sizes differ; logic errors if bit pattern invalid

**B.2.26 — Raw Pointer Arithmetic Overflow**

- **Description**: Pointer arithmetic producing address outside valid memory or wrapping around address space.
- **Triggering Operations**:
  - `ptr.offset(n)` where `n` moves pointer outside valid allocation
  - Pointer arithmetic wrapping address space
- **Detection**: Not detected; programmer responsibility in unsafe code.
- **References**: §7.5.5 [type.pointer.raw], §11.8
- **Consequences**: Accessing invalid memory, crashes, security issues

#### §B.2.5 Concurrency Violations

**B.2.50 — Data Race**

- **Description**: Concurrent access to the same memory location where at least one access is a write and the accesses are not ordered by synchronization (happens-before relationship).
- **Triggering Operations**:
  - Multiple threads accessing shared data without synchronization
  - Missing mutex protection for shared mutable data
  - Incorrect atomic ordering allowing races
- **Detection**: Prevented by permission system in safe code (`const` for sharing, `unique` for exclusive access, `shared` requires synchronization). May occur in unsafe code or with incorrect synchronization.
- **References**: §14.2.2[3-5], §14.2.5, §14.1.2
- **Consequences**: Non-deterministic behavior, data corruption, crashes

**B.2.51 — Misaligned Atomic Operation**

- **Description**: Performing atomic operation on a location that does not satisfy natural alignment for the type.
- **Triggering Operations**:
  - Atomic load/store on misaligned address
  - Using atomic operations on packed structures without alignment guarantee
- **Detection**: Platform-dependent. Compiler cannot verify alignment of all atomic operation targets.
- **References**: §14.3.4[4], §14.3.7
- **Consequences**: Undefined behavior on most platforms; may cause incorrect results or crashes

**B.2.52 — Dropping Locked Mutex**

- **Description**: Destroying a Mutex value while in @Locked state (mutex dropped without unlocking).
- **Triggering Operations**:
  - Scope exit while Mutex is @Locked
  - Explicit drop call on locked mutex
- **Detection**: Type system prevents in safe code (RAII guard pattern). Possible with unsafe state manipulation.
- **References**: §14.4.5[4], §14.4.2
- **Consequences**: Deadlock (other threads waiting for unlock), resource leak

#### §B.2.6 FFI and Interoperability Violations

**B.2.53 — Calling Convention Mismatch**

- **Description**: Calling a foreign function with a calling convention different from what the function expects.
- **Triggering Operations**:
  - Declaring extern procedure with wrong calling convention
  - Passing Cursive callback with wrong convention to C
- **Detection**: Compiler generates code for declared convention but cannot verify foreign code matches.
- **References**: §15.2.6, §15.6.2
- **Consequences**: Stack corruption, incorrect argument values, crashes

**B.2.54 — One Definition Rule Violation**

- **Description**: Multiple conflicting definitions of the same entity with external linkage.
- **Triggering Operations**:
  - Same type defined differently in multiple compilation units
  - Same procedure defined with different implementations across units
- **Detection**: May be caught at link time; undetected violations cause UB.
- **References**: §15.5.5 [interop.linkage]
- **Consequences**: Linking errors or runtime instability with inconsistent definitions

#### §B.2.7 Additional Violations

**B.2.60 — Arithmetic Overflow in Unchecked Mode**

- **Description**: Integer arithmetic overflow in release/unchecked build mode.
- **Triggering Operations**:
  - Addition, subtraction, multiplication producing value outside type's range
  - Negating minimum signed integer
- **Detection**: In checked/debug mode, panics. In release mode with wrapping semantics, wraps (defined behavior). In unchecked optimization mode, undefined.
- **References**: §7.2.2 [type.primitive.int], §8.3.4
- **Consequences**: Incorrect results, potential security issues

**B.2.61 — Stack Overflow**

- **Description**: Exhausting the call stack through excessive recursion or large stack allocations.
- **Triggering Operations**:
  - Deep recursion exceeding stack size
  - Large automatic storage allocations
- **Detection**: May be caught by guard pages (stack overflow signal). Not prevented at compile time.
- **References**: §11.2.3 [memory.object.storage], §10.6 (recursive procedures)
- **Consequences**: Crash, stack corruption

**B.2.62 — Foreign Function Safety Violation**

- **Description**: Foreign function violating Cursive safety invariants (modifying const data, creating data races, corrupting memory).
- **Triggering Operations**:
  - Calling foreign function that violates documented contract
  - Foreign function modifying data through const pointer
  - Foreign function creating race conditions
- **Detection**: Cannot be detected; trust placed in foreign code via contracts.
- **References**: Clause 15 [interop], §15.1.10
- **Consequences**: Violates Cursive safety guarantees; any consequence possible

[4] **Normative Requirement**: Conforming programs shall not rely on undefined behavior. Implementations are not required to diagnose undefined behavior but may provide optional detection mechanisms (sanitizers, runtime checks) as quality-of-implementation features.

[5] **Informative Note**: The list above enumerates known sources of undefined behavior in Cursive. Implementations discovering additional undefined behaviors shall report them to the working group for inclusion in future specification revisions.

---

### §B.3 Unspecified Behavior Catalog [behavior.unspecified]

[6] This annex enumerates behaviors for which this specification permits multiple outcomes without requiring implementation documentation. Unlike implementation-defined behavior (§B.1), implementations need not document which choice they make for unspecified behaviors.

[7] **Normative Requirement**: Each outcome permitted for an unspecified behavior shall be well-defined (not undefined behavior). Programs may observe different outcomes across implementations or executions, but all outcomes shall be valid according to this specification.

#### §B.3.1 Padding Byte Values

**B.3.01 — Structure Padding Byte Values**

- **Description**: The values of padding bytes inserted between fields or at the end of structures to satisfy alignment requirements.
- **Permitted Outcomes**: Padding bytes may have any value (zero, garbage, deterministic pattern, or implementation-defined initialization).
- **References**: §11.6.3 [memory.layout.padding]
- **Constraint**: Reading padding bytes directly is undefined behavior; only accessing via structure fields is defined.

#### §B.3.2 Optimization Ordering

**B.3.02 — Dead Code Elimination Order**

- **Description**: The order in which unreachable code is eliminated during optimization.
- **Permitted Outcomes**: Implementations may eliminate dead code in any order or not at all.
- **References**: §9.4.4 [stmt.order.divergence]
- **Constraint**: Observable behavior must not change; only removal of unobservable code permitted.

**B.3.03 — Inline Expansion Decisions**

- **Description**: Which procedure calls are inlined by the optimizer.
- **Permitted Outcomes**: Implementations may inline any procedure call or leave it as a call, provided observable behavior is preserved.
- **References**: Clause 10 §10.6 [generic.resolution.monomorphization]
- **Constraint**: Optimization must not alter observable behavior.

#### §B.3.3 Module Initialization

**B.3.04 — Lazy vs Eager Initialization**

- **Description**: When module-level bindings without eager dependencies are initialized.
- **Permitted Outcomes**: Implementations may initialize lazily (on first use) or eagerly (before main), provided observable behavior matches the eager semantics specified in §4.6.
- **References**: §4.6.2[7], §5.7.2
- **Constraint**: Each initializer runs exactly once; dependencies must be respected.

#### §B.3.4 Memory Layout

**B.3.05 — Field Reordering in Native Layout**

- **Description**: The order of fields in memory for types without `[[repr(C)]]` or explicit layout attributes.
- **Permitted Outcomes**: Implementations may reorder fields for optimization (size reduction, alignment efficiency) or preserve declaration order.
- **References**: §11.6.2, B.1.06
- **Constraint**: Field offsets determined by chosen ordering; must remain stable for the compilation.

[8] Unspecified behaviors enable implementation flexibility while maintaining portability: programs shall not rely on specific outcomes but may observe different outcomes across implementations without violating conformance.


### §C.1 Type System Rules [formal.type]

[1] This annex shall provide a complete formalization of the type system using mathematical notation and inference rules. It will consolidate all typing judgments from Clause 7 and prove key meta-theoretic properties.

[ Note: This section is reserved for the complete formal type system specification.

Planned content includes:
- Typing judgments for all expression forms
- Type equivalence and subtyping relations  
- Well-formedness rules for all type constructors
- Kinding rules for higher-level types
- Proof of type system soundness
— end note ]

---

### §C.2 Operational Semantics [formal.operational]

[2] This annex shall provide small-step and big-step operational semantics for expression and statement evaluation, formalizing the execution model described informally in Clauses 8 and 9.

[ Note: This section is reserved for formal operational semantics.

Planned content includes:
- Small-step reduction rules ($\langle e, \sigma \rangle \to \langle e', \sigma' \rangle$)
- Big-step evaluation rules ($\langle e, \sigma \rangle \Downarrow \langle v, \sigma' \rangle$)
- Store and environment models
- Control outcome propagation
- Proof of deterministic evaluation
— end note ]

---

### §C.3 Denotational Semantics [formal.denotational]

[3] This annex shall provide denotational semantics mapping Cursive programs to mathematical domains, enabling equational reasoning about program behavior.

[ Note: This section is reserved for denotational semantics.
— end note ]

---

### §C.4 Permission and Move Semantics [formal.permission]

[4] This annex shall formalize the permission system, move semantics, and binding responsibility tracking described in Clause 11.

[ Note: This section is reserved for formal permission semantics.

Planned content includes:
- Permission lattice formalization
- Cleanup responsibility tracking
- Move semantics and invalidation rules
- Non-responsible binding validity conditions
- Proof of memory safety properties
— end note ]

---

### §C.5 Witness Semantics [formal.witness]

[5] This annex shall formalize the witness system's dynamic dispatch semantics, vtable construction, and type erasure properties described in Clause 13.

[ Note: This section is reserved for formal witness semantics.
— end note ]

---

### §C.6 Contract and Sequent Semantics [formal.contract]

[6] This annex shall formalize the sequent calculus model, grant propagation, and contract verification described in Clause 12.

[ Note: This section is reserved for formal contract semantics.

Planned content includes:
- Sequent calculus formalization
- Grant subsumption and composition rules
- Precondition and postcondition entailment
- Invariant desugaring formalization
- Verification soundness proofs
— end note ]

---

### §C.7 Meta-Theory [formal.metatheory]

[7] This annex shall prove key meta-theoretic properties of the Cursive language: progress (well-typed programs don't get stuck), preservation (evaluation preserves types), and soundness (well-typed programs don't exhibit undefined behavior).

[ Note: This section is reserved for meta-theoretic proofs.

Planned theorems:
- **Progress**: If $\Gamma \vdash e : \tau$, then either $e$ is a value or there exists $e'$ such that $\langle e, \sigma \rangle \to \langle e', \sigma' \rangle$
- **Preservation**: If $\Gamma \vdash e : \tau$ and $\langle e, \sigma \rangle \to \langle e', \sigma' \rangle$, then $\Gamma \vdash e' : \tau$
- **Soundness**: Well-typed programs that do not use unsafe code cannot produce undefined behaviors enumerated in Annex B §B.2
- **Memory Safety**: Well-typed programs cannot produce use-after-free, double-free, or null-pointer dereference errors
- **Data Race Freedom**: Well-typed concurrent programs without unsafe code are data-race-free
— end note ]


### §D.1 Recommended Minimum Limits [limits.minimum]

[1] This annex specifies recommended minimum limits that conforming implementations should support. These limits provide guidance for implementers and help programmers write portable code. Implementations may exceed these minimums and shall document their actual limits.

[2] **Normative requirement**: Implementations shall support at least the minimum limits specified below. Exceeding the limits may produce implementation-defined diagnostics or may be unsupported (IFNDR).

#### §D.1.1 Source Text Limits

**D.1.01 — Source File Size**

- **Minimum**: 1 MiB (1,048,576 bytes)
- **Reference**: §2.1.3[5]
- **Diagnostic**: E02-002 if exceeded
- **Rationale**: Supports large generated files and comprehensive modules

**D.1.02 — Identifier Length**

- **Minimum**: 1023 characters
- **Reference**: §2.3, §6.1
- **Diagnostic**: E02-201 if exceeded
- **Rationale**: Accommodates descriptive names and generated identifiers

**D.1.03 — String Literal Length**

- **Minimum**: 65,535 characters (64 KiB)
- **Reference**: §2.3.3[6]
- **Diagnostic**: E02-200 if exceeded
- **Rationale**: Supports embedded documentation and data

#### §D.1.2 Syntactic Nesting Limits

**D.1.04 — Block Nesting Depth**

- **Minimum**: 256 levels
- **Reference**: §6.2, §9.1
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports deeply nested control flow

**D.1.05 — Expression Nesting Depth**

- **Minimum**: 256 levels
- **Reference**: Clause 8
- **Diagnostic**: Implementation-defined
- **Rationale**: Accommodates complex expressions

**D.1.06 — Type Nesting Depth**

- **Minimum**: 128 levels
- **Reference**: Clause 7
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports nested generic types

**D.1.07 — Delimiter Nesting Depth**

- **Minimum**: 256 levels
- **Reference**: §2.4.3[3.1]
- **Diagnostic**: E02-300
- **Rationale**: Prevents stack overflow in pathological cases

#### §D.1.3 Declaration Limits

**D.1.08 — Procedure Parameters**

- **Minimum**: 255 parameters
- **Reference**: §5.4 [decl.function]
- **Diagnostic**: Implementation-defined
- **Rationale**: Accommodates complex APIs

**D.1.09 — Record Fields**

- **Minimum**: 1024 fields
- **Reference**: §5.5 [decl.type]
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports large data structures

**D.1.10 — Enum Variants**

- **Minimum**: 1024 variants
- **Reference**: §5.5 [decl.type], §7.3.5
- **Diagnostic**: Implementation-defined
- **Rationale**: Accommodates extensive state machines

**D.1.11 — Modal States**

- **Minimum**: 64 states per modal type
- **Reference**: §7.6 [type.modal]
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports complex state machines

**D.1.12 — Generic Parameters**

- **Minimum**: 256 generic parameters per entity
- **Reference**: §10.2 [generic.parameter]
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports highly generic code

#### §D.1.4 Compile-Time Evaluation Limits

**D.1.13 — Comptime Recursion Depth**

- **Minimum**: 256 stack frames
- **Reference**: §2.2.3[3], §16.2.3.3[13]
- **Diagnostic**: E02-101, E16-003
- **Rationale**: Supports recursive comptime algorithms

**D.1.14 — Comptime Evaluation Steps**

- **Minimum**: 1,000,000 evaluation steps per comptime block
- **Reference**: §2.2.3[3], §16.2.3.3[13]
- **Diagnostic**: E02-102, E16-004
- **Rationale**: Prevents infinite loops while allowing complex generation

**D.1.15 — Comptime Memory Allocation**

- **Minimum**: 64 MiB per compilation unit
- **Reference**: §2.2.3[3], §16.2.3.3[13]
- **Diagnostic**: E02-103, E16-005
- **Rationale**: Supports large generated data structures

**D.1.16 — Comptime String Size**

- **Minimum**: 1 MiB per string value
- **Reference**: §2.2.3[3], §16.2.3.3[13]
- **Diagnostic**: E02-104, E16-006
- **Rationale**: Accommodates code generation templates

**D.1.17 — Comptime Collection Cardinality**

- **Minimum**: 10,000 elements per array/collection
- **Reference**: §2.2.3[3], §16.2.3.3[13]
- **Diagnostic**: E02-105, E16-008
- **Rationale**: Supports bulk code generation

#### §D.1.5 Name Resolution Limits

**D.1.18 — Qualified Name Chain Length**

- **Minimum**: 32 components
- **Reference**: §6.4.4[12.2]
- **Diagnostic**: E06-406
- **Rationale**: Supports deep module hierarchies

**D.1.19 — Scope Depth**

- **Minimum**: 256 nested scopes
- **Reference**: §6.2 [name.scope]
- **Diagnostic**: Implementation-defined
- **Rationale**: Matches block nesting limit

#### §D.1.6 Generic and Contract Limits

**D.1.20 — Monomorphization Instantiations**

- **Minimum**: 1024 distinct instantiations per generic entity
- **Reference**: §10.6.9.3[58]
- **Diagnostic**: E10-612
- **Rationale**: Supports extensive generic usage

**D.1.21 — Generic Instantiation Nesting**

- **Minimum**: 32 levels of nested generic instantiation
- **Reference**: §10.6.9.3[58]
- **Diagnostic**: E10-612
- **Rationale**: Supports recursive generic types with indirection

**D.1.22 — Grant Set Size**

- **Minimum**: 256 grants per sequent clause
- **Reference**: §12.3.9[3]
- **Diagnostic**: E12-032
- **Rationale**: Accommodates complex capability requirements

**D.1.23 — Where Clause Predicates**

- **Minimum**: 64 predicates per where clause
- **Reference**: §10.3 [generic.bounds], §12.6 [contract.invariant]
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports complex constraints

#### §D.1.7 Runtime Limits (Implementation-Defined)

**D.1.24 — Stack Size**

- **Minimum**: Implementation-defined (typically 1-8 MiB)
- **Reference**: §11.2.3 [memory.object.storage], B.1.08
- **Documentation Required**: Implementations shall document stack size and whether configurable
- **Rationale**: Platform-dependent

**D.1.25 — Maximum Heap Allocation**

- **Minimum**: Platform-dependent (limited by available memory)
- **Reference**: §11.2.3 [memory.object.storage]
- **Documentation Required**: Implementations shall document maximum single allocation and total heap size
- **Rationale**: Platform and configuration dependent

**D.1.26 — Concurrent Threads**

- **Minimum**: Platform-dependent (typically at least number of CPU cores)
- **Reference**: §14.1 [concurrency.model]
- **Documentation Required**: Implementations shall document thread limits
- **Rationale**: Platform and runtime dependent

[3] **Conformance Note**: Implementations exceeding these limits provide better support for complex programs but are not required to do so. Programs relying on limits beyond those specified here are not portable.

---

### §D.2 Translation Limits [limits.translation]

[4] This section specifies limits applicable during specific compilation phases. These limits are distinct from the general limits in §D.1.

#### §D.2.1 Parsing Phase Limits

**D.2.01 — Parse Tree Depth**

- **Minimum**: Same as block nesting (256 levels)
- **Reference**: §2.2.4.1
- **Diagnostic**: Implementation-defined (may cause parser stack overflow)
- **Rationale**: Parser must handle deeply nested structures

**D.2.02 — Declaration Count per Module**

- **Minimum**: 65,535 top-level declarations
- **Reference**: §2.5, Clause 4
- **Diagnostic**: Implementation-defined
- **Rationale**: Supports generated code and large APIs

#### §D.2.2 Type Checking Phase Limits

**D.2.03 — Type Unification Complexity**

- **Minimum**: 1024 unification variables per type inference problem
- **Reference**: §7.1, §10.6.8 [generic.resolution.constraints]
- **Diagnostic**: E10-610 (no principal type)
- **Rationale**: Supports complex generic inference

**D.2.04 — Constraint Solving Iterations**

- **Minimum**: 10,000 constraint solving iterations for generic bounds
- **Reference**: §10.6.8
- **Diagnostic**: E10-610
- **Rationale**: Prevents infinite constraint solving loops

#### §D.2.3 Code Generation Phase Limits

**D.2.05 — Generated Declarations**

- **Minimum**: 100,000 declarations generated via comptime/codegen
- **Reference**: §16.8 [comptime.codegen.api]
- **Diagnostic**: E16-210/E16-211/E16-212
- **Rationale**: Supports extensive metaprogramming

**D.2.06 — Witness Table Entries**

- **Minimum**: 256 procedures per behavior/contract vtable
- **Reference**: §13.4 [witness.representation]
- **Diagnostic**: Implementation-defined
- **Rationale**: Accommodates large interfaces

[5] **Quality of Implementation**: Implementations should provide diagnostic warnings when approaching limits (e.g., at 50%, 75%, 90% of capacity) to help programmers avoid hitting hard limits during development.

[6] **Conformance Testing**: Conformance test suites should include tests exercising limits at or near the minimums specified here to verify implementations meet requirements.

---

### §D.3 Recommended Practices [limits.practices]

[7] Programmers writing portable code should:

1. **Stay well below limits**: Target 50% of minimum limits for maximum portability
2. **Test on multiple implementations**: Verify code works across different compilers
3. **Avoid extreme nesting**: Refactor deeply nested code for readability and portability
4. **Monitor comptime resource usage**: Use comptime_note to track generation progress
5. **Partition large modules**: Split very large files across multiple modules

[8] Implementations providing limit diagnostics should emit warnings when programs approach limits, enabling proactive refactoring before hard limits are reached.


### §E.2 Algorithm Specifications [implementation.algorithms]

[1] This section provides detailed algorithms for key compiler phases. These algorithms are informative: conforming implementations may use different approaches provided they satisfy the normative requirements in the main specification clauses.

#### §E.2.6 Region Escape Analysis Algorithm [implementation.algorithms.region]

##### §E.2.6.1 Overview

[2] This subsection specifies the complete escape analysis algorithm referenced by §9.3.3 [memory.region.escape]. The algorithm determines whether region-allocated values escape their regions through provenance tracking and escape checking.

##### §E.2.6.2 Provenance Tracking Algorithm

[3] **Input**: Expression $e$ in environment $\Gamma$  
**Output**: Provenance metadata $\pi \in \{\text{Stack}, \text{Region}(r), \text{Heap}\}$

**Algorithm:**

```
function compute_provenance(e, Γ):
    match e:
        // Region allocation
        case ^expr in region r:
            return Region(r)

        // Stack-allocated local variable
        case identifier x where x is local binding without ^:
            return Stack

        // Module-scope or static
        case identifier x where x is module-scope:
            return Heap  // Static treated as Heap

        // Heap conversion
        case expr.to_heap():
            return Heap

        // Address-of: inherits from target
        case &value:
            π_value = compute_provenance(value, Γ)
            return π_value

        // Field access: inherits from structure
        case struct.field:
            π_struct = compute_provenance(struct, Γ)
            return π_struct

        // Procedure call: conservative (Heap)
        case f(args):
            return Heap  // Conservative assumption

        // Literals: Stack
        case literal:
            return Stack

        // Default: Stack (conservative)
        default:
            return Stack
```

[4] **Provenance Propagation Table**: Complete propagation rules for all expression forms:

| Expression Form         | Provenance Rule                  |
| ----------------------- | -------------------------------- |
| `^expr` in region r     | Region(r)                        |
| Local variable (no `^`) | Stack                            |
| Module-scope variable   | Heap                             |
| `&value`                | Same as value                    |
| `struct.field`          | Same as struct                   |
| `array[index]`          | Same as array                    |
| `tuple.N`               | Same as tuple                    |
| `*pointer`              | Heap (conservative)              |
| `expr.to_heap()`        | Heap                             |
| `f(args)`               | Heap (conservative)              |
| Literals                | Stack                            |
| Binary operations       | Stack (if both Stack), else Heap |
| Conditional `if`        | Most restrictive of branches     |

##### §E.2.6.3 Escape Checking Algorithm

[5] **Input**: Expression $e$, target scope $s$, region environment $R$  
**Output**: Valid or Error(E09-101)

**Algorithm:**

```
function check_escape(e, target_scope s, region_env R):
    π = compute_provenance(e, Γ)

    match π:
        case Stack:
            return Valid  // Stack values can escape

        case Heap:
            return Valid  // Heap values can escape

        case Region(r):
            if r ∈ lexical_ancestors(s):
                // Region r is local to scope s
                return Error(E09-101, {
                    region: r,
                    allocation_site: find_allocation_site(e, r),
                    escape_site: current_location,
                    provenance_path: trace_provenance(e)
                })
            else:
                // Region r is not local (parent region allocation via ^^)
                return Valid
```

[6] **Escape Check Points**: The algorithm is invoked at:

1. **Return statements**: `check_escape(return_value, containing_procedure, R)`
2. **Region block boundaries**: Before exiting region, check all values that might escape
3. **Closure captures**: For each captured value, check against closure's lifetime
4. **Field assignments**: When assigning to field of longer-lived structure

##### §E.2.6.4 Interprocedural Analysis (Optional Refinement)

[7] Implementations may perform interprocedural analysis to refine provenance for procedure calls:

**Conservative approach** (required minimum):

- All procedure calls return Heap provenance

**Refined approach** (optional):

- Track provenance through procedure signatures (future extension)
- Analyze procedure bodies to determine return provenance
- Propagate provenance through call chain

[8] Refined analysis may accept more programs but shall never accept programs that would be rejected by conservative analysis (soundness preservation).

##### §E.2.6.5 Diagnostic Construction

[9] When escape violation is detected (E09-101), construct diagnostic with:

**Required fields:**

- Region identifier where value was allocated
- Allocation site (source location of `^` operator)
- Escape site (source location of escape attempt)

**Optional fields (recommended):**

- Provenance path showing how provenance propagated
- Suggested fix (use `.to_heap()` if applicable)
- Related notes (region definition location)

**Example diagnostic output:**

```
error[E09-101]: cannot escape region-allocated value
  --> src/server.cursive:125:12
    |
125 |         result data
    |                ^^^^ region-allocated value escapes here
    |
note: value allocated in region 'temp' at line 122
  --> src/server.cursive:122:21
    |
122 |         let data = ^Buffer::new()
    |                    ^ allocated in region 'temp'
    |
note: region 'temp' defined here
  --> src/server.cursive:121:5
    |
121 |     region temp {
    |     ^^^^^^^^^^^ region exits at line 126
    |
help: convert to heap before returning
    |
125 |         result data.to_heap()
    |                    ++++++++++
```

##### §E.2.6.6 Worked Examples

**Example E.2.6.1**: Direct region escape (invalid)

```cursive
procedure build(): Buffer [[alloc::region]] {
    region r {
        let data = ^Buffer::new()  // prov(data) = Region(r)
        result data                // check_escape(data, build, R)
                                   // → Region(r) ∈ lexical_ancestors(build)
                                   // → ERROR E09-101
    }
}
```

**Example E.2.6.2**: Pointer escape via address-of (invalid)

```cursive
procedure get_ptr(): Ptr<i32>@Valid [[alloc::region]] {
    region r {
        let value = ^42            // prov(value) = Region(r)
        let ptr = &value           // prov(ptr) = prov(value) = Region(r)
        result ptr                 // check_escape(ptr, get_ptr, R)
                                   // → ERROR E09-101
    }
}
```

**Example E.2.6.3**: Heap conversion (valid)

```cursive
procedure build(): Buffer [[alloc::region, alloc::heap]] {
    region r {
        let data = ^Buffer::new()      // prov(data) = Region(r)
        let heap_data = data.to_heap() // prov(heap_data) = Heap
        result heap_data               // check_escape(heap_data, build, R)
                                       // → Heap provenance
                                       // → Valid
    }
}
```

**Example E.2.6.4**: Parent region allocation (valid)

```cursive
procedure build(): Buffer [[alloc::region]] {
    region outer {
        region inner {
            let data = ^^Buffer::new()  // prov(data) = Region(outer)
            result data                 // check_escape(data, inner, R)
                                        // → Region(outer) ∉ lexical_ancestors(inner)
                                        // → Valid (escapes inner, stays in outer)
        }
        // data still valid in outer
        result data
    }
}
```

##### §E.2.6.7 Implementation Considerations

[10] **Performance**: Provenance tracking is compile-time only with zero runtime overhead. Implementations should:

- Track provenance as metadata on AST nodes
- Propagate during type checking phase
- Perform escape checking during region boundary analysis
- Cache provenance to avoid recomputation

[11] **Precision**: The conservative analysis (procedure calls return Heap) may reject safe programs. Implementations may refine with interprocedural analysis but shall maintain soundness.

[12] **Integration**: Escape analysis integrates with:

- Type checking (§2.2.4.3)
- Move checking (Clause 9)
- Definite assignment (§4.7)
- Control-flow analysis (Clause 8)

---

### §E.5 Implementation Diagnostics [implementation.diagnostics]

[1] This annex provides comprehensive guidance for implementing conforming diagnostic systems in Cursive compilers and toolchains. It includes the authoritative diagnostic code registry, payload schemas, quality guidelines, and machine-readable output specifications.

[2] All diagnostic codes follow the canonical format `E[CC]-[NNN]` where:

- `E` denotes an error diagnostic
- `[CC]` is a two-digit clause number with leading zero (02, 04, 05, 06, 07, etc.)
- `-` is a hyphen separator for visual clarity
- `[NNN]` is a three-digit sequential number with leading zeros

[3] The format specification is normatively defined in §1.6.6 [intro.document.diagnostics].

#### §E.5.1 Diagnostic Code Registry [implementation.diagnostics.registry]

[4] The following tables enumerate all diagnostic codes defined in the Cursive language specification. Each entry includes:

- **Code**: The canonical diagnostic identifier in format `E[CC]-[NNN]`;
- **Section**: The specific section reference (e.g., §2.1.3[1]);
- **Description**: A brief summary of the error condition;
- **Severity**: Error (E), Warning (W), or Note (N).

[5] All codes use severity "E" (Error) in the current version. Future versions may introduce warning and note diagnostics.

##### §E.5.1.1 Clause 02: Lexical Structure and Translation

**Subsection §2.1: Source Text Encoding**

| Code    | Section   | Description                                   | Severity |
| ------- | --------- | --------------------------------------------- | -------- |
| E02-001 | §2.1.3[1] | Invalid UTF-8 sequence in source file         | E        |
| E02-002 | §2.1.3[5] | File size exceeds implementation limit        | E        |
| E02-003 | §2.1.3[2] | Misplaced byte-order mark (BOM)               | E        |
| E02-004 | §2.1.3[4] | Prohibited code point (U+0000 null character) | E        |

**Subsection §2.2: Translation Phases**

| Code    | Section   | Description                                      | Severity |
| ------- | --------- | ------------------------------------------------ | -------- |
| E02-101 | §2.2.3[4] | Comptime evaluation exceeded maximum iterations  | E        |
| E02-102 | §2.2.3[4] | Comptime evaluation exceeded maximum memory      | E        |
| E02-103 | §2.2.3[4] | Comptime evaluation exceeded maximum stack depth | E        |
| E02-104 | §2.2.3[4] | Comptime evaluation exceeded time limit          | E        |
| E02-105 | §2.2.3[3] | Collection cardinality exceeded comptime limit   | E        |
| E02-106 | §2.2.3[4] | Runtime-only grant used in comptime execution    | E        |
| E02-107 | §2.2.3[5] | Generated symbol name collision                  | E        |

**Subsection §2.3: Lexical Elements**

| Code    | Section   | Description                                        | Severity |
| ------- | --------- | -------------------------------------------------- | -------- |
| E02-200 | §2.3.2[3] | Reserved keyword used as identifier                | E        |
| E02-201 | §2.3.3[5] | Invalid character in identifier                    | E        |
| E02-202 | §2.3.4[2] | Unterminated string literal                        | E        |
| E02-203 | §2.3.4[3] | Invalid escape sequence in string literal          | E        |
| E02-204 | §2.3.5[2] | Unterminated character literal                     | E        |
| E02-205 | §2.3.5[3] | Empty character literal                            | E        |
| E02-206 | §2.3.6[3] | Integer literal exceeds maximum value              | E        |
| E02-207 | §2.3.6[4] | Invalid digit in numeric literal                   | E        |
| E02-208 | §2.3.7[2] | Floating-point literal exceeds representable range | E        |

**Subsection §2.4: Tokenization and Statement Termination**

| Code    | Section   | Description                                   | Severity |
| ------- | --------- | --------------------------------------------- | -------- |
| E02-300 | §2.4.3[3] | Delimiter nesting exceeds maximum depth (256) | E        |
| E02-301 | §2.4.4[5] | Disallowed form at module scope               | E        |

**Subsection §2.5: Compilation Units and Top-Level Forms**

| Code    | Section   | Description                                        | Severity |
| ------- | --------- | -------------------------------------------------- | -------- |
| E02-400 | §2.5.3[4] | Redeclaration in same scope                        | E        |
| E02-401 | §2.5.4[6] | Cyclic module initializer dependency (eager edges) | E        |

##### §E.5.1.2 Clause 04: Modules

**Subsection §4.1: Module Overview**

| Code    | Section     | Description                                                | Severity |
| ------- | ----------- | ---------------------------------------------------------- | -------- |
| E04-001 | §4.1.3[1]   | Multiple source files merged without permitted constructs  | E        |
| E04-002 | §4.1.3[2]   | Source file located outside manifest-declared source roots | E        |
| E04-003 | §4.1.3[3]   | Module path component is not a valid identifier            | E        |
| E04-004 | §4.1.3[5]   | Case-insensitive filesystem collision between module paths | E        |
| E04-005 | §4.1.3[6]   | Module path component uses a reserved keyword              | E        |
| E04-006 | §4.1.3[2]   | Project manifest missing or missing required tables        | E        |
| E04-007 | §4.1.3[5.2] | Case-insensitive filesystem collision warning              | W        |

**Subsection §4.2: Module Syntax (Import/Use)**

| Code    | Section   | Description                                              | Severity |
| ------- | --------- | -------------------------------------------------------- | -------- |
| E04-100 | §4.2.3[4] | Duplicate entry in `use` list                            | E        |
| E04-101 | §4.2.3[5] | Wildcard `use` expansion introduces conflicting bindings | E        |
| E04-102 | §4.2.3[7] | Visibility modifier applied to an `import` declaration   | E        |

**Subsection §4.3: Module Scope (Use Bindings)**

| Code    | Section   | Description                                                        | Severity |
| ------- | --------- | ------------------------------------------------------------------ | -------- |
| E04-200 | §4.3.2[3] | `use` binding collides with existing identifier without `as` alias | E        |
| E04-201 | §4.3.2[4] | Wildcard `use` expansion conflicts with existing bindings          | E        |
| E04-202 | §4.3.2[7] | `use` references a module that has not been imported               | E        |
| E04-203 | §4.4.2[4] | Duplicate exported identifier resulting from `public use`          | E        |
| E04-204 | §4.4.2[2] | `public use` re-exports a non-public item                          | E        |
| E04-205 | §4.3.2[1] | `import` refers to module outside manifest-declared roots          | E        |

**Subsection §4.5: Qualified Name Resolution**

| Code    | Section   | Description                                                         | Severity |
| ------- | --------- | ------------------------------------------------------------------- | -------- |
| E04-400 | §4.5.3[1] | Qualified-name head is not a known module or alias                  | E        |
| E04-401 | §4.5.3[3] | Qualified-name head ambiguous across imports                        | E        |
| E04-402 | §4.5.3[4] | Partial module path does not resolve to a module                    | E        |
| E04-403 | §4.5.3[5] | Attempt to rebind an existing import alias                          | E        |
| E04-404 | §4.5.3[2] | Qualified name references an item not exported by the target module | E        |

**Subsection §4.6: Module Initialization and Cycles**

| Code    | Section     | Description                                               | Severity |
| ------- | ----------- | --------------------------------------------------------- | -------- |
| E04-500 | §4.6.2[4]   | Cycle detected in eager dependency graph                  | E        |
| E04-501 | §4.6.2[6]   | Module initialization blocked by failing predecessor      | E        |
| E04-502 | §4.6.2[8]   | Access to binding before prerequisite module initialises  | E        |
| E04-503 | §4.6.4.4[8] | Lazy dependency misclassified; eager interaction required | E        |

**Subsection §4.6.7: Type Visibility Integration**

| Code    | Section   | Description                                     | Severity |
| ------- | --------- | ----------------------------------------------- | -------- |
| E07-750 | §4.6.7[5] | Internal type referenced across module boundary | E        |

---

##### §E.5.1.3 Clause 05: Declarations

**Subsection §5.2: Variable Bindings**

| Code    | Section   | Description                                  | Severity |
| ------- | --------- | -------------------------------------------- | -------- |
| E05-201 | §5.2.3[1] | `shadow` used without matching outer binding | E        |
| E05-202 | §5.2.3[2] | Reassignment of `let` binding                | E        |
| E05-203 | §5.2.3[3] | Duplicate identifiers in pattern binding     | E        |
| E05-204 | §5.2.3[4] | Pattern initializer arity/shape mismatch     | E        |

**Subsection §5.3: Binding Patterns**

| Code    | Section   | Description                                          | Severity |
| ------- | --------- | ---------------------------------------------------- | -------- |
| E05-301 | §5.3.3[2] | Unknown field in record pattern                      | E        |
| E05-302 | §5.3.3[3] | Tuple pattern arity mismatch                         | E        |
| E05-303 | §5.3.3[4] | Duplicate identifiers in pattern                     | E        |
| E05-304 | §5.3.3[1] | Missing type annotation for multi-identifier pattern | E        |

**Subsection §5.4: Procedures**

| Code    | Section     | Description                                                | Severity |
| ------- | ----------- | ---------------------------------------------------------- | -------- |
| E05-401 | §5.4.3[2]   | Procedure receiver missing or malformed                    | E        |
| E05-402 | §5.4.3[6]   | Comptime callable body not compile-time evaluable          | E        |
| E05-403 | §5.4.3[6]   | Missing return type annotation where required              | E        |
| E05-406 | §5.4.3[5]   | Procedure with empty grant set attempts grant-requiring op | E        |
| E05-408 | §5.4.3[4]   | Expression-bodied procedure includes explicit sequent      | E        |
| E05-409 | §5.4.3[2.3] | Call site missing `move` for responsible parameter         | E        |
| E05-410 | §5.4.3[2.3] | Call site uses `move` for non-responsible parameter        | E        |

**Subsection §5.5: Type Declarations**

| Code    | Section    | Description                                       | Severity |
| ------- | ---------- | ------------------------------------------------- | -------- |
| E05-501 | §5.5.3[11] | Cyclic type alias                                 | E        |
| E05-502 | §5.5.3[10] | Unsupported representation attribute              | E        |
| E05-503 | §5.5.3[6]  | Duplicate contract reference on type declaration  | E        |
| E05-504 | §5.5.3[7]  | Duplicate predicate reference on type declaration | E        |
| E05-505 | §5.5.3[13] | Empty modal type declaration                      | E        |
| E05-506 | §5.5.3[14] | Multiple contracts with incompatible signatures   | E        |
| E05-507 | §5.5.3[15] | Infinite-size recursive type                      | E        |

**Subsection §5.6: Visibility Rules**

| Code    | Section   | Description                                  | Severity |
| ------- | --------- | -------------------------------------------- | -------- |
| E05-601 | §5.6.3[1] | `private`/`protected` used at module scope   | E        |
| E05-602 | §5.6.3[4] | Visibility modifier applied to local binding | E        |
| E05-603 | §5.6.5[1] | Attempt to widen visibility during re-export | E        |
| E05-604 | §5.6.5[2] | Non-`public` modifier used with `use`        | E        |
| E05-605 | §5.6.4[3] | Protected member access violation            | E        |

**Subsection §5.7: Initialization and Definite Assignment**

| Code    | Section   | Description                                      | Severity |
| ------- | --------- | ------------------------------------------------ | -------- |
| E05-701 | §5.7.2[2] | Module initializer cycle                         | E        |
| E05-702 | §5.7.2[3] | Module initializer blocked by failing dependency | E        |
| E05-703 | §5.7.3[2] | Use of potentially unassigned binding            | E        |
| E05-704 | §5.7.4[4] | Pattern omits required binding                   | E        |
| E05-705 | §5.7.5[1] | Reassignment of `let` binding                    | E        |

**Subsection §5.8: Program Entry Points**

| Code    | Section   | Description                                      | Severity |
| ------- | --------- | ------------------------------------------------ | -------- |
| E05-801 | §5.8.2[1] | Missing or multiple entry points                 | E        |
| E05-802 | §5.8.2[3] | Entry point not `public`                         | E        |
| E05-803 | §5.8.2[4] | Entry point declared as procedure/comptime/async | E        |
| E05-804 | §5.8.2[5] | Disallowed attribute on entry point              | E        |

**Subsection §5.9: Grant Declarations**

| Code    | Section   | Description                                  | Severity |
| ------- | --------- | -------------------------------------------- | -------- |
| E05-901 | §5.9.3[3] | Grant name conflicts with reserved namespace | E        |
| E05-902 | §5.9.3[4] | Grant declaration not at module scope        | E        |
| E05-903 | §5.9.3[2] | Duplicate grant name in same module          | E        |

##### §E.5.1.4 Clause 06: Names, Scopes, and Resolution

**Subsection §6.2: Scope Formation**

| Code    | Section    | Description                          | Severity |
| ------- | ---------- | ------------------------------------ | -------- |
| E06-201 | §6.2.3[5]  | Scope tree cycle or multiple parents | E        |
| E06-202 | §6.2.3[10] | Treating `use` as lexical scope      | E        |

**Subsection §6.3: Name Introduction and Shadowing**

| Code    | Section    | Description                                           | Severity |
| ------- | ---------- | ----------------------------------------------------- | -------- |
| E06-300 | §6.3.3[6]  | Redeclaration of identifier in same scope             | E        |
| E06-301 | §6.3.3[7]  | `shadow` used outside nested scope (including module) | E        |
| E06-302 | §6.3.3[8]  | Redeclaration/shadow/alias of predeclared identifier  | E        |
| E06-303 | §6.3.3[10] | Pattern shadow refers to non-existent outer binding   | E        |

**Subsection §6.4: Name Lookup**

| Code    | Section      | Description                                       | Severity |
| ------- | ------------ | ------------------------------------------------- | -------- |
| E06-400 | §6.4.4       | Ambiguous identifier (multiple imported bindings) | E        |
| E06-401 | §6.4.4       | Undefined identifier (not found in any scope)     | E        |
| E06-402 | §6.4.4[13]   | Qualified-name prefix is not module or type       | E        |
| E06-403 | §6.4.4[13]   | Qualified-name suffix is not exported             | E        |
| E06-404 | §6.4.4[13]   | Module-qualified name missing target item         | E        |
| E06-405 | §6.4.4[13]   | Type-qualified name missing associated item       | E        |
| E06-406 | §6.4.4[12.2] | Qualified name chain too long                     | E        |
| E06-407 | §6.4.4[13.1] | Empty qualified name component                    | E        |

##### §E.5.1.5 Clause 07: Type System

**Subsection §7.2: Primitive Types**

| Code    | Section   | Description                                                    | Severity |
| ------- | --------- | -------------------------------------------------------------- | -------- |
| E07-001 | §7.2.1[5] | Attempt to redeclare or shadow a reserved primitive identifier | E        |
| E07-100 | §7.2.2.6  | Integer constant overflow during folding                       | E        |
| E07-101 | §7.2.2.6  | Compile-time division or remainder by zero                     | E        |
| E07-102 | §7.2.3.6  | Invalid floating literal suffix                                | E        |
| E07-103 | §7.2.3.6  | Floating constant overflow or division by zero                 | E        |
| E07-104 | §7.2.4.4  | Non-boolean operand supplied to logical operator               | E        |
| E07-105 | §7.2.4.4  | Boolean used where numeric type required                       | E        |
| E07-106 | §7.2.5.2  | Character literal uses surrogate code point                    | E        |

**Subsection §7.4: Function Types**

| Code    | Section    | Description                                        | Severity |
| ------- | ---------- | -------------------------------------------------- | -------- |
| E07-200 | §7.4.4[15] | Grant set references undeclared grant              | E        |
| E07-201 | §7.4.4[15] | Contractual sequent references undefined predicate | E        |
| E07-202 | §7.4.4[15] | Call site lacks required grants                    | E        |
| E07-203 | §7.4.4[15] | Call site cannot prove `must` clause               | E        |
| E07-204 | §7.4.4[15] | Callable loses grant/contract info when exported   | E        |
| E07-205 | §7.4.4[15] | Function subtyping violates variance rules         | E        |
| E07-206 | §7.4.4[15] | Conversion of capturing closure to raw pointer     | E        |

**Subsection §7.5: Pointer Types**

| Code    | Section  | Description                                      | Severity |
| ------- | -------- | ------------------------------------------------ | -------- |
| E07-300 | §7.5.3.2 | Pointer escapes stack/region provenance          | E        |
| E07-301 | §7.5.2.4 | Dereference of `Ptr<T>@Null`                     | E        |
| E07-302 | §7.5.2.3 | Address-of applied to non-storage expression     | E        |
| E07-303 | §7.5.2.3 | Missing explicit pointer type annotation         | E        |
| E07-304 | §7.5.2.4 | Dereference of `Ptr<T>@Weak` without upgrade     | E        |
| E07-305 | §7.5.2.4 | Dereference of `Ptr<T>@Expired`                  | E        |
| E07-400 | §7.5.5.2 | Raw pointer dereference outside `unsafe` context | E        |
| E07-401 | §7.5.5.2 | Raw pointer assignment outside `unsafe` context  | E        |
| E07-402 | §7.5.5.3 | Cast between incompatible raw pointer types      | E        |

**Subsection §7.6: Modal Types**

| Code    | Section     | Description                                                    | Severity |
| ------- | ----------- | -------------------------------------------------------------- | -------- |
| E07-500 | §7.6.8[13]  | Duplicate modal state name                                     | E        |
| E07-501 | §7.6.8[13]  | Transition references undeclared state                         | E        |
| E07-502 | §7.6.8[13]  | Transition body fails to return the required target state      | E        |
| E07-503 | §7.6.8[13]  | Modal pattern match missing required state branch              | E        |
| E07-504 | §7.6.2[6.3] | State-specific field accessed outside its defining state       | E        |
| E07-505 | §7.6.2[6.1] | Transition signature lacks a matching procedure implementation | E        |

**Subsection §7.3: Composite Types (Union Types)**

| Code    | Section    | Description                                       | Severity |
| ------- | ---------- | ------------------------------------------------- | -------- |
| E07-710 | §7.3.6[60] | Union component type not well-formed              | E        |
| E07-711 | §7.3.6[60] | Type mismatch: cannot widen to union              | E        |
| E07-712 | §7.3.6[60] | Single-component union (should use type directly) | E        |

**Subsection §7.7: Type Relations**

| Code    | Section | Description                                  | Severity |
| ------- | ------- | -------------------------------------------- | -------- |
| E07-003 | §7.7.6  | Type mismatch in expression                  | E        |
| E07-700 | §7.7.6  | Subtyping check failure / variance violation | E        |
| E07-701 | §7.7.6  | Cyclic type alias                            | E        |
| E07-702 | §7.7.6  | Type compatibility failure for operation     | E        |
| E07-703 | §7.7.6  | Modal/union pattern lacks branch             | E        |
| E07-704 | §7.7.6  | Union pattern missing component type         | E        |

**Subsection §7.8: Type Introspection**

| Code    | Section | Description                                        | Severity |
| ------- | ------- | -------------------------------------------------- | -------- |
| E07-900 | §7.8.2  | `typeof` used in value position                    | E        |
| E07-901 | §7.8.5  | `type_info` result escapes compile-time context    | E        |
| E07-902 | §7.8.8  | Introspection invoked on ill-formed type           | E        |
| E07-903 | §7.8.5  | Attempt to inspect private field via introspection | E        |

##### §E.5.1.6 Clause 07: Expressions

**Subsection §7.1: Expression Fundamentals**

| Code    | Section   | Description                                                | Severity |
| ------- | --------- | ---------------------------------------------------------- | -------- |
| E07-001 | §7.1.3[8] | Runtime-only construct used in const/comptime context      | E        |
| E07-002 | §7.1.6    | Type cannot be inferred and no contextual type provided    | E        |
| E07-004 | §7.1.5    | Missing grant(s) from grants clause in contractual sequent | E        |
| E07-020 | §7.1.3[9] | Pipeline stage omitted type annotation while changing type | E        |
| E07-021 | §7.2.11   | Pipeline stage annotation disagrees with inferred type     | E        |

**Subsection §7.2: Primary and Postfix Expressions**

| Code    | Section   | Description                                     | Severity |
| ------- | --------- | ----------------------------------------------- | -------- |
| E07-201 | §7.2.2[3] | Integer literal cannot fit target type          | E        |
| E07-202 | §7.2.2[3] | Invalid character literal                       | E        |
| E07-210 | §7.2.3[7] | Identifier used before definite assignment      | E        |
| E07-211 | §7.2.3[5] | Identifier resolves to non-value entity         | E        |
| E07-220 | §7.2.5    | Block producing non-unit value without `result` | E        |
| E07-230 | §7.2.7    | Procedure call arity mismatch                   | E        |
| E07-231 | §7.2.7    | Procedure call has extra arguments              | E        |
| E07-232 | §7.2.7    | Method receiver lacks required permission       | E        |
| E07-233 | §7.2.7    | Method receiver has incompatible type           | E        |
| E07-240 | §7.2.8    | Field access violates visibility                | E        |
| E07-241 | §7.2.8    | Tuple projection index out of range             | E        |
| E07-250 | §7.2.9    | Array/slice index out of range                  | E        |
| E07-251 | §7.2.9    | Slice bounds invalid                            | E        |
| E07-260 | §7.2.10   | Address-of applied to non-place expression      | E        |

**Subsection §7.3: Unary and Binary Operators**

| Code    | Section | Description                                            | Severity |
| ------- | ------- | ------------------------------------------------------ | -------- |
| E07-301 | §7.3.4  | Operand types mismatch for arithmetic/bitwise operator | E        |
| E07-302 | §7.3.4  | Modulo operator applied to non-integer type            | E        |
| E07-303 | §7.3.4  | Shift amount ≥ bit width                               | E        |
| E07-304 | §7.3.4  | Division or modulo by zero                             | E        |
| E07-310 | §7.3.6  | Equality invoked on type without `Eq` implementation   | E        |
| E07-320 | §7.3.7  | Logical operator operands not `bool`                   | E        |
| E07-330 | §7.3.3  | Checked-mode arithmetic negation overflow              | E        |
| E07-331 | §7.3.9  | `move` applied to value without ownership              | E        |
| E07-340 | §7.3.8  | Assignment target is not a place                       | E        |
| E07-341 | §7.3.8  | Compound assignment invalid for operand type           | E        |
| E07-342 | §7.3.8  | Chained assignment is ill-formed                       | E        |

**Subsection §7.4: Structured Expressions**

| Code    | Section | Description                                                | Severity |
| ------- | ------- | ---------------------------------------------------------- | -------- |
| E07-400 | §7.4.2  | Record literal missing required field                      | E        |
| E07-401 | §7.4.2  | Record literal duplicates field                            | E        |
| E07-402 | §7.4.2  | Record literal references field not visible in scope       | E        |
| E07-403 | §7.4.2  | Single-element tuple literal disallowed                    | E        |
| E07-404 | §7.4.2  | Enum variant payload mismatch                              | E        |
| E07-430 | §7.4.3  | Array literal elements have mismatched types               | E        |
| E07-431 | §7.4.3  | Repeat array requires `Copy` element or comptime length    | E        |
| E07-440 | §7.4.4  | `if` expression requires `else` but none provided          | E        |
| E07-450 | §7.4.5  | Match result type inference failed (use typed hole)        | E        |
| E07-451 | §7.4.5  | Match is non-exhaustive                                    | E        |
| E07-452 | §7.4.5  | Match arm unreachable                                      | E        |
| E07-460 | §7.4.6  | Loop break values disagree                                 | E        |
| E07-461 | §7.4.6  | Iterator loop missing element type annotation              | E        |
| E07-462 | §7.4.6  | Iterator does not satisfy iteration protocol               | E        |
| E07-463 | §7.4.6  | `break`/`continue` used outside loop                       | E        |
| E07-470 | §7.4.7  | Closure captures moved-from value                          | E        |
| E07-471 | §7.4.7  | Closure outlives captured reference (escape violation)     | E        |
| E07-472 | §7.4.7  | Closure captures unique binding while uniqueness is active | E        |
| E07-473 | §7.4.7  | Closure permission incompatible with captured variable     | E        |

**Subsection §7.5: Patterns and Exhaustiveness**

| Code    | Section | Description                                                  | Severity |
| ------- | ------- | ------------------------------------------------------------ | -------- |
| E07-500 | §7.5.2  | Record pattern omits required field                          | E        |
| E07-510 | §7.5.2  | Or-pattern branches bind different identifiers               | E        |
| E07-511 | §7.5.2  | Or-pattern branches bind identifiers with incompatible types | E        |
| E07-512 | §7.5.4  | Match arm is unreachable                                     | E        |
| E07-520 | §7.5.5  | Destructuring statement used in disallowed context           | E        |
| E07-704 | §7.5.2  | Union pattern match missing component type(s)                | E        |

**Subsection §7.6: Conversions and Coercions**

| Code    | Section | Description                          | Severity |
| ------- | ------- | ------------------------------------ | -------- |
| E07-600 | §7.6.2  | Constant cast loses information      | E        |
| E07-601 | §7.6.2  | Cast not covered by a legal category | E        |

**Subsection §7.7: Constant and Comptime**

| Code    | Section | Description                                           | Severity |
| ------- | ------- | ----------------------------------------------------- | -------- |
| E07-700 | §7.7.2  | Runtime-only construct used in const/comptime context | E        |
| E07-701 | §7.7.3  | Comptime block requested non-comptime grant           | E        |

**Subsection §8.8: Expression Typing**

| Code    | Section | Description                                        | Severity |
| ------- | ------- | -------------------------------------------------- | -------- |
| E07-800 | §7.8.2  | Type compatibility failure (general typing errors) | E        |
| E09-403 | §9.4   | Place used without required permission             | E        |

##### §E.5.1.7 Clause 09: Statements and Control Flow

**Subsection §9.2: Simple Statements**

| Code    | Section    | Description                                                | Severity |
| ------- | ---------- | ---------------------------------------------------------- | -------- |
| E09-101 | §9.2.3[12] | Assignment to immutable (`let`) binding                    | E        |
| E09-102 | §9.2.3[13] | Type mismatch in assignment                                | E        |
| E09-103 | §9.2.3[15] | Assignment operator mismatch (= vs <-)                     | E        |
| E09-120 | §9.2.6[30] | Defer block produces non-unit value                        | E        |
| E09-121 | §9.2.6[31] | Defer block contains control transfer escaping defer scope | E        |

**Subsection §9.3: Control Flow Statements**

| Code    | Section    | Description                                   | Severity |
| ------- | ---------- | --------------------------------------------- | -------- |
| E09-201 | §9.3.3[20] | Return statement outside procedure body       | E        |
| E09-202 | §9.3.3[21] | Return value type mismatch                    | E        |
| E09-203 | §9.3.3[22] | Missing return value on control-flow path     | E        |
| E09-211 | §9.3.4[29] | Break statement outside loop or labeled block | E        |
| E09-212 | §9.3.4[30] | Break/continue references undefined label     | E        |
| E09-213 | §9.3.4[31] | Break values have incompatible types          | E        |
| E09-221 | §9.3.5[37] | Continue statement outside loop               | E        |
| E09-222 | §9.3.5[38] | Continue targets non-loop label               | E        |
| E09-231 | §9.3.6[44] | Duplicate label in procedure                  | E        |

##### §E.5.1.8 Clause 09: Generics and Behaviors

**Subsection §9.2: Type Parameters**

| Code    | Section | Description                                                        | Severity |
| ------- | ------- | ------------------------------------------------------------------ | -------- |
| E09-101 | §9.2.3 | Type parameter cannot be inferred; explicit type argument required | E        |
| E09-102 | §9.2.4 | Const argument not compile-time evaluable                          | E        |
| E09-103 | §9.2.4 | Const parameter used in runtime-only context                       | E        |
| E09-104 | §9.2.6 | Parameter with default appears before parameter without default    | E        |
| E09-105 | §9.2.6 | Default value references later parameter                           | E        |
| E09-106 | §9.2.7 | Partial explicit arguments skip early parameters                   | E        |
| E09-107 | §9.2.8 | Duplicate parameter name in generic parameter list                 | E        |
| E09-108 | §9.2.8 | Const parameter has invalid type (not integer or bool)             | E        |
| E09-109 | §9.2.8 | Grant parameter uses `:` instead of `⊆` for bound                  | E        |
| E09-110 | §9.2.8 | Const parameter used as runtime value                              | E        |

**Subsection §9.3: Bounds and Where-Constraints**

| Code    | Section | Description                                                     | Severity |
| ------- | ------- | --------------------------------------------------------------- | -------- |
| E09-201 | §9.3.9 | Bound references undefined or non-visible behavior/contract     | E        |
| E09-202 | §9.3.9 | Type argument does not satisfy bound                            | E        |
| E09-203 | §9.3.9 | Associated type equality constraint: types do not match         | E        |
| E09-204 | §9.3.9 | Grant bound references invalid grant identifier                 | E        |
| E09-205 | §9.3.9 | Cyclic bound dependencies through associated type projections   | E        |
| E09-206 | §9.3.9 | Conflicting associated type equality constraints                | E        |
| E09-301 | §9.3.7 | Grant parameter exceeds bound (grant set not subset of allowed) | E        |

**Subsection §9.4: Behavior Declarations**

| Code    | Section | Description                                                     | Severity |
| ------- | ------- | --------------------------------------------------------------- | -------- |
| E09-401 | §9.4.3 | Behavior procedure declared without body                        | E        |
| E09-402 | §9.4.3 | Cyclic behavior extension (behavior extends itself)             | E        |
| E09-403 | §9.4.4 | Associated type does not satisfy bound                          | E        |
| E09-404 | §9.4.8 | Behavior extends non-behavior (e.g., contract)                  | E        |
| E09-405 | §9.4.8 | Behavior name collision with existing binding                   | E        |
| E09-406 | §9.4.8 | Duplicate associated type name in behavior                      | E        |
| E09-407 | §9.4.8 | Behavior procedure has invalid receiver                         | E        |
| E09-411 | §9.4.5 | Type claims Copy but does not satisfy structural requirements   | E        |
| E09-412 | §9.4.5 | Type implements both Copy and Drop (mutual exclusion violation) | E        |
| E09-413 | §9.4.3 | Conflicting procedures from extended behaviors                  | E        |

**Subsection §9.5: Behavior Implementations and Coherence**

| Code    | Section  | Description                                             | Severity |
| ------- | -------- | ------------------------------------------------------- | -------- |
| E09-501 | §9.5.4  | Incomplete implementation (missing procedures or types) | E        |
| E09-502 | §9.5.4  | Procedure signature incompatible with behavior          | E        |
| E09-503 | §9.5.4  | Associated type specification missing                   | E        |
| E09-504 | §9.5.5  | Blanket implementation lacks where clause               | E        |
| E09-505 | §9.5.6  | Orphan rule violation                                   | E        |
| E09-506 | §9.5.7  | Duplicate implementation (coherence violation)          | E        |
| E09-507 | §9.5.7  | Overlapping blanket implementations                     | E        |
| E09-508 | §9.5.11 | Implementation for non-behavior (e.g., contract)        | E        |
| E09-509 | §9.5.11 | Implementation type does not exist or is not visible    | E        |
| E09-510 | §9.5.11 | Generic implementation parameter mismatch               | E        |

**Subsection §9.6: Resolution and Monomorphization**

| Code    | Section | Description                                              | Severity |
| ------- | ------- | -------------------------------------------------------- | -------- |
| E09-601 | §9.6.2 | Cannot infer type arguments; explicit turbofish required | E        |
| E09-602 | §9.6.3 | Type argument does not satisfy behavior bound            | E        |
| E09-603 | §9.6.3 | Type argument does not satisfy contract bound            | E        |
| E09-604 | §9.6.3 | Associated type constraint not satisfied                 | E        |
| E09-605 | §9.6.3 | Grant parameter exceeds bound                            | E        |
| E09-606 | §9.6.5 | Cyclic associated type projection                        | E        |
| E09-607 | §9.6.7 | Ambiguous blanket implementation (multiple match)        | E        |
| E09-608 | §9.6.7 | Behavior not satisfied for type                          | E        |
| E09-609 | §9.6.8 | Type unification failed                                  | E        |
| E09-610 | §9.6.8 | No principal type exists (ambiguous inference)           | E        |
| E09-611 | §9.6.4 | Infinite-size recursive type                             | E        |
| E09-612 | §9.6.4 | Monomorphization limit exceeded                          | E        |

**Subsection §9.7: Variance and Inference**

| Code    | Section  | Description                                        | Severity |
| ------- | -------- | -------------------------------------------------- | -------- |
| E09-701 | §9.7.10 | Variance violation in generic type substitution    | E        |
| E09-702 | §9.7.12 | Conflicting variance requirements (internal error) | E        |

##### §E.5.1.9 Clause 09: Memory Model, Regions, and Permissions

**Subsection §9.3: Regions**

| Code    | Section     | Description                                   | Severity |
| ------- | ----------- | --------------------------------------------- | -------- |
| E09-101 | §9.3.4[18] | Region-allocated value escapes region         | E        |
| E09-102 | §9.3.4[22] | Heap allocation requires alloc::heap grant    | E        |
| E09-103 | §9.3.8     | Region allocation outside region block        | E        |
| E09-104 | §9.3.5     | Invalid caret stacking (too many ^ for depth) | E        |
| E09-110 | §9.3.7[33] | Arena binding escapes region                  | E        |

**Subsection §9.4: Permissions**

| Code    | Section | Description                                        | Severity |
| ------- | ------- | -------------------------------------------------- | -------- |
| E09-301 | §9.4.6 | Mutation through `const` permission                | E        |
| E09-302 | §9.4.6 | Multiple `unique` bindings to same object          | E        |
| E09-303 | §9.4.6 | Permission upgrade attempt (const → unique)        | E        |
| E09-310 | §9.4.6 | Partition accessed multiple times through `shared` | E        |
| E09-311 | §9.4.6 | Invalid partition directive (unknown identifier)   | E        |
| E09-403 | §9.4   | Place used without required permission             | E        |

**Subsection §9.5: Move/Copy/Clone**

| Code    | Section | Description                                                                | Severity |
| ------- | ------- | -------------------------------------------------------------------------- | -------- |
| E09-501 | §9.5.6 | Attempt to move from `var` binding                                         | E        |
| E09-502 | §9.5.6 | Attempt to move from non-responsible binding                               | E        |
| E09-503 | §9.5.6 | Use of moved value                                                         | E        |
| E09-504 | §9.5.6 | Use of non-responsible binding after source moved to responsible parameter | E        |
| E09-510 | §9.5.6 | Attempt to copy non-Copy type                                              | E        |
| E09-511 | §9.5.6 | Attempt to clone non-Clone type                                            | E        |

**Subsection §9.6: Layout and Alignment**

| Code    | Section | Description                             | Severity |
| ------- | ------- | --------------------------------------- | -------- |
| E09-601 | §9.6.5 | Explicit alignment smaller than natural | E        |
| E09-602 | §9.6.5 | Invalid repr attribute combination      | E        |
| E09-603 | §9.6.5 | Transparent applied to multi-field type | E        |

**Subsection §9.7: Aliasing**

| Code    | Section | Description                               | Severity |
| ------- | ------- | ----------------------------------------- | -------- |
| E09-701 | §9.7.6 | Multiple `unique` bindings to same object | E        |
| E09-702 | §9.7.6 | `shared` binding while `unique` active    | E        |
| E09-703 | §9.7.6 | `unique` binding while `shared` active    | E        |

**Subsection §9.8: Unsafe Blocks**

| Code    | Section | Description                            | Severity |
| ------- | ------- | -------------------------------------- | -------- |
| E09-801 | §9.8.6 | Raw pointer dereference outside unsafe | E        |
| E09-802 | §9.8.6 | Raw pointer write outside unsafe       | E        |
| E09-803 | §9.8.6 | Transmute outside unsafe               | E        |
| E09-804 | §9.8.6 | Transmute size mismatch                | E        |
| E09-805 | §9.8.6 | Inline assembly outside unsafe         | E        |

##### §E.5.1.10 Clause 12: Contracts

**Subsection §12.2: Sequent Syntax and Structure**

| Code    | Section    | Description                               | Severity |
| ------- | ---------- | ----------------------------------------- | -------- |
| E12-001 | §12.2.3[1] | Invalid sequent brackets (not [[]])       | E        |
| E12-002 | §12.2.3[2] | Missing or duplicate turnstile            | E        |
| E12-003 | §12.2.3[3] | Missing or duplicate implication operator | E        |
| E12-004 | §12.2.3[4] | Sequent components in wrong order         | E        |
| E12-005 | §12.2.3[5] | Effectful expression in must/will clause  | E        |
| E12-006 | §12.2.3[6] | Undefined grant in grant clause           | E        |
| E12-007 | §12.2.3[7] | result identifier used in must clause     | E        |
| E12-008 | §12.2.3[8] | @old operator used in must clause         | E        |
| E12-009 | §12.2.3[8] | Nested @old operators                     | E        |
| E12-010 | §12.2.3[9] | Ambiguous abbreviated sequent             | E        |

**Subsection §12.3: Grants**

| Code    | Section      | Description                                   | Severity |
| ------- | ------------ | --------------------------------------------- | -------- |
| E12-020 | §12.3.3.9[9] | Comptime grant used in runtime procedure      | E        |
| E12-030 | §12.3.8[21]  | Call site missing required grants             | E        |
| E12-031 | §12.3.9[1]   | Grant visibility violation (non-public grant) | E        |
| E12-032 | §12.3.9[3]   | Grant set exceeds implementation limit        | E        |

**Subsection §12.4: Preconditions**

| Code    | Section     | Description                                        | Severity |
| ------- | ----------- | -------------------------------------------------- | -------- |
| E12-040 | §12.4.3[1]  | Precondition expression has non-bool type          | E        |
| E12-041 | §12.4.3[2]  | Precondition performs side effects (not pure)      | E        |
| E12-042 | §12.4.3[3]  | Precondition references local binding (not param)  | E        |
| E12-043 | §12.4.6[20] | Contract implementation has stronger precondition  | E        |
| E12-044 | §12.4.3[4]  | Precondition cannot be evaluated (ill-formed expr) | E        |

**Subsection §12.5: Postconditions**

| Code    | Section       | Description                                          | Severity |
| ------- | ------------- | ---------------------------------------------------- | -------- |
| E12-050 | §12.5.4.1[13] | Effectful expression in @old(...)                    | E        |
| E12-051 | §12.5.4.1[14] | @old references local binding (not parameter)        | E        |
| E12-052 | §12.5.6[26]   | Contract implementation has weaker postcondition     | E        |
| E12-053 | §12.5.7[1]    | Postcondition expression has non-bool type           | E        |
| E12-054 | §12.5.7[2]    | Postcondition performs side effects (not pure)       | E        |
| E12-055 | §12.5.7[3]    | Postcondition references local binding               | E        |
| E12-056 | §12.8.4[15]   | Postcondition unprovable in static verification mode | E        |

**Subsection §12.6: Invariants**

| Code    | Section       | Description                                       | Severity |
| ------- | ------------- | ------------------------------------------------- | -------- |
| E12-060 | §12.6.9[1]    | Invariant expression has non-bool type            | E        |
| E12-061 | §12.6.9[2]    | Invariant performs side effects (not pure)        | E        |
| E12-062 | §12.6.9[3]    | Invariant references inaccessible binding         | E        |
| E12-063 | §12.6.9[4]    | @old operator used in where clause                | E        |
| E12-064 | §12.6.9[5]    | result identifier used in type invariant          | E        |
| E12-065 | §12.6.9[6]    | Unsatisfiable type invariant (type uninhabitable) | E        |
| E12-066 | §12.6.2.4[10] | Invariant violated at construction                | E        |
| E12-067 | §12.6.2.4[10] | Invariant violated after mutation                 | E        |
| E12-068 | §12.6.3.3[15] | Loop invariant violated at entry                  | E        |
| E12-069 | §12.6.3.3[15] | Loop invariant not preserved by iteration         | E        |

**Subsection §12.7: Sequent Checking Flow**

| Code    | Section     | Description                                | Severity |
| ------- | ----------- | ------------------------------------------ | -------- |
| E12-070 | §12.7.7[20] | Grant accumulation exceeds declared grants | E        |

**Subsection §12.8: Verification Modes**

| Code    | Section     | Description                                            | Severity |
| ------- | ----------- | ------------------------------------------------------ | -------- |
| E12-080 | §12.8.10[1] | verify attribute misplaced (not before procedure)      | E        |
| E12-081 | §12.8.10[2] | Invalid verification mode (not static/dynamic/trusted) | E        |

**Subsection §12.9: Grammar and Contract Declarations**

| Code    | Section    | Description                                    | Severity |
| ------- | ---------- | ---------------------------------------------- | -------- |
| E12-090 | §12.9.4[7] | Quantifier (forall/exists) unsupported         | E        |
| E12-091 | §12.9.5[9] | Contract procedure has body (must be abstract) | E        |

##### §E.5.1.10 Clause 13: Concurrency and Memory Ordering

**Subsection §13.1: Concurrency Model**

| Code    | Description                                  | Section    |
| ------- | -------------------------------------------- | ---------- |
| E13-100 | Thread return type is not const              | §13.1.7[1] |
| E13-101 | Shared data captured without synchronization | §13.1.7[2] |
| E13-102 | Thread dropped without join or detach        | §13.1.7[4] |
| E13-103 | Thread spawning missing thread::spawn grant  | §13.1.7[3] |
| E13-104 | Thread join missing thread::join grant       | §13.1.7[3] |

**Subsection §13.3: Atomic Operations**

| Code    | Description                                      | Section    |
| ------- | ------------------------------------------------ | ---------- |
| E13-200 | Atomic operation on non-atomic type              | §13.3.4[1] |
| E13-201 | Atomic operation with incorrect permission       | §13.3.4[2] |
| E13-202 | Invalid memory ordering for operation            | §13.3.4[3] |
| E13-203 | Atomic operation on unsupported type (e.g. i128) | §13.3.4[5] |
| E13-204 | Misaligned atomic access                         | §13.3.4[4] |

**Subsection §13.4: Synchronization Primitives**

| Code    | Description                                  | Section    |
| ------- | -------------------------------------------- | ---------- |
| E13-300 | Type constraint violation for sync primitive | §13.4.5[1] |
| E13-301 | Missing grant for synchronization operation  | §13.4.5[3] |

##### §E.5.1.11 Clause 12: Witness System

**Subsection §12.3: Formation and Construction**

| Code    | Description                                                 | Section    |
| ------- | ----------------------------------------------------------- | ---------- |
| E12-001 | Type does not satisfy behavior/satisfy contract/have state  | §12.3.6[1] |
| E12-010 | Missing `move` for responsible witness (@Heap/@Region)      | §12.3.6[2] |
| E12-011 | Region witness escapes region                               | §12.3.6[5] |
| E12-012 | Grant missing for witness construction (alloc::heap/region) | §12.3.6[4] |

**Subsection §12.5: Dispatch Semantics**

| Code    | Description                                 | Section     |
| ------- | ------------------------------------------- | ----------- |
| E12-020 | Method not found in behavior/contract       | §12.5.8[7]  |
| E12-021 | Method not available in modal state         | §12.5.5[10] |
| E12-022 | Insufficient grants for witness method call | §12.5.7[14] |

**Subsection §12.6: Memory Integration**

| Code    | Description                                 | Section     |
| ------- | ------------------------------------------- | ----------- |
| E12-030 | Permission upgrade on witness               | §12.6.4[6]  |
| E12-031 | Witness transition requires grant           | §12.6.7[20] |
| E12-032 | Invalid witness transition (no such method) | §12.6.7[19] |

---

##### §E.5.1.12 Clause 13: Concurrency and Memory Ordering

[Note: This section was moved from Clause 14 to Clause 13. — end note]

##### §E.5.1.13 Clause 14: Interoperability and ABI

**Subsection §14.1: FFI Declarations**

|| Code | Description | Section |
|| ------- | ---------------------------------------------------------- | ----------- |
|| E14-001 | Invalid calling convention string | §14.1.3[1] |
|| E14-002 | Non-FFI-safe type in extern signature | §14.1.3[2] |
|| E14-003 | Missing required grants (ffi::call, unsafe::ptr) | §14.1.3[3] |
|| E14-004 | Extern procedure with body not declared public | §14.1.3[4] |
|| E14-005 | Variadic parameters in extern signature (not supported) | §14.1.3[5] |
|| E14-006 | Permission qualifier in extern signature | §14.1.3[7] |
|| E14-007 | Modal type in extern signature | §14.1.3[8] |
|| E14-008 | Extern procedure captures variables (closures forbidden) | §14.1.3[9] |
|| E14-009 | unwind attribute on non-extern procedure | §14.1.3[10] |
|| E14-010 | Extern procedure call outside unsafe block | §14.1.6[22] |

**Subsection §14.2: FFI Unsafe Usage**

|| Code | Description | Section |
|| ------- | --------------------------------------------- | -------- |
|| E14-020 | Dereference of potentially null FFI pointer | §14.2.5 |
|| E14-021 | FFI call with mismatched calling convention | §14.2.6 |
|| E14-022 | Region pointer passed to storing FFI function | §14.2.3 |

**Subsection §14.3: C Compatibility**

|| Code | Description | Section |
|| ------- | ----------------------------------------------- | ----------- |
|| E14-030 | Non-C-compatible field in repr(C) type | §14.3.2[12] |
|| E14-031 | repr(C) enum missing tag_type specification | §14.3.2[10] |
|| E14-040 | Non-extern function pointer in FFI context | §14.3.4[22] |

**Subsection §14.4: Platform Features**

|| Code | Description | Section |
|| ------- | ------------------------------------------------- | ------- |
|| E14-050 | Platform query used outside comptime context | §14.4.2 |
|| E14-051 | Inline assembly attempted (not supported in v1.0) | §14.4.3 |
|| E14-052 | SIMD intrinsic attempted (not supported in v1.0) | §14.4.4 |
|| E14-053 | Unsupported platform-specific attribute | §14.4.5 |

**Subsection §14.5: Linkage and Symbol Visibility**

|| Code | Description | Section |
|| ------- | ----------------------------------------------- | ---------- |
|| E14-060 | Multiple definitions of type (ODR violation) | §14.5.5 |
|| E14-061 | Multiple definitions of procedure (ODR) | §14.5.5 |
|| E14-062 | Linkage attribute on non-public entity | §14.5.8 |
|| E14-070 | Weak symbols not supported on target platform | §14.5.7 |

**Subsection §14.6: ABI Specification**

|| Code | Description | Section |
|| ------- | ----------------------------------- | ------- |
|| E14-080 | Unsupported calling convention | §14.6.2 |
|| E14-081 | ABI mismatch (incompatible types) | §14.6.3 |
|| E14-082 | Stack misalignment detected | §14.6.2 |

**Subsection §14.7: Binary Compatibility**

|| Code | Description | Section |
|| ------- | ---------------------------------------------------- | ------- |
|| E14-090 | Link-time symbol conflict (ODR violation detected) | §14.7.4 |
|| E14-091 | ABI version mismatch | §14.7.2 |
|| E14-092 | Incompatible object file format | §14.7.4 |

##### §E.5.1.14 Clause 15: Compile-Time Evaluation and Reflection

**Subsection §15.2: Comptime Procedures**

|| Code | Description | Section |
|| ------- | ---------------------------------------------------- | ------------ |
|| E15-001 | Runtime grant in comptime procedure sequent | §15.2.3.1[8] |
|| E15-002 | Non-pure operation in comptime procedure | §15.2.3.2 |
|| E15-003 | Recursion depth exceeded (>256) | §15.2.3.3 |
|| E15-004 | Evaluation steps exceeded (>1M) | §15.2.3.3 |
|| E15-005 | Memory allocation exceeded (>64MiB) | §15.2.3.3 |
|| E15-006 | String size exceeded (>1MiB) in comptime | §15.2.3.3 |
|| E15-007 | Runtime-only construct in comptime context | §15.2.3 |
|| E15-008 | Return type not compile-time representable | §15.2.3.4 |
|| E15-009 | Comptime procedure with receiver | §15.2.3.5 |
|| E15-010 | Comptime procedure called from runtime context | §15.2.5 |

**Subsection §15.3: Comptime Blocks**

|| Code | Description | Section |
|| ------- | ------------------------------------------------- | -------- |
|| E15-020 | Comptime binding referenced from runtime code | §15.3.3 |
|| E15-021 | Cyclic dependency in comptime blocks | §15.3.4 |
|| E15-022 | Comptime block result type not representable | §15.3.3 |

**Subsection §15.4: Comptime Intrinsics**

|| Code | Description | Section |
|| ------- | ------------------------------------------- | ------- |
|| E15-030 | Comptime assertion failed | §15.4.2 |
|| E15-031 | Comptime error (fatal) | §15.4.2 |
|| E15-032 | Comptime warning (non-fatal) | §15.4.2 |
|| E15-040 | Configuration key not found | §15.4.3 |
|| E15-041 | Platform query in runtime context | §15.4.3 |

**Subsection §15.5: Reflection Opt-In**

|| Code | Description | Section |
|| ------- | -------------------------------------------------- | ------- |
|| E15-100 | [[reflect]] on non-type declaration | §15.5.3 |
|| E15-101 | Reflection query on non-reflected type | §15.5.3 |
|| E15-110 | Reflection API in runtime context | §15.5.4 |
|| E15-111 | Private reflection details accessed cross-module | §15.5.3 |
|| E15-112 | Reflection on uninstantiated generic | §15.5.3 |

**Subsection §15.6: Type Reflection Queries**

|| Code | Description | Section |
|| ------- | --------------------------------------- | ------- |
|| E15-120 | Field not found during query | §15.6.3 |
|| E15-121 | Procedure not found during query | §15.6.4 |
|| E15-122 | Variant not found during query | §15.6.5 |

**Subsection §15.7: Quote Expressions**

|| Code | Description | Section |
|| ------- | ----------------------------------------------------- | ------- |
|| E15-200 | Quote expression in runtime context | §15.7.3 |
|| E15-201 | Interpolation expression not compile-time evaluable | §15.7.3 |
|| E15-202 | Interpolated value type not embeddable | §15.7.3 |
|| E15-203 | Generated code failed type checking | §15.7.3 |

**Subsection §15.8: Code Generation API**

|| Code | Description | Section |
|| ------- | -------------------------------------------------- | ------- |
|| E15-210 | Generated procedure name collision | §15.8.4 |
|| E15-211 | Generated type name collision | §15.8.4 |
|| E15-212 | Generated constant name collision | §15.8.4 |
|| E15-213 | Procedure name collision on type | §15.8.4 |
|| E15-220 | TypeRef references non-existent type | §15.8.4 |
|| E15-221 | add_procedure/add_function target not found | §15.8.4 |
|| E15-230 | Generated code failed validation | §15.8.7 |
|| E15-231 | ProcedureSpec malformed (missing required field) | §15.8.3 |
|| E15-232 | TypeSpec malformed (missing required field) | §15.8.3 |
|| E15-233 | SequentSpec malformed (invalid grant identifier) | §15.8.3 |
|| E15-240 | Quote interpolation malformed | §15.7.3 |

---

#### §E.5.2 Diagnostic Code Allocation Strategy [implementation.diagnostics.allocation]

[9] Diagnostic codes within each clause are allocated by subsection to facilitate maintenance and avoid conflicts:

**Allocation Pattern**:

- **E[CC]-001 to E[CC]-099**: First major subsection
- **E[CC]-100 to E[CC]-199**: Second major subsection
- **E[CC]-200 to E[CC]-299**: Third major subsection
- And so forth within the clause

[10] This pattern enables adding diagnostics to existing subsections without renumbering. Reserved gaps between subsections allow future expansion.

[11] **Cross-clause shared codes**: In rare cases, a diagnostic defined in one clause may be referenced by another clause when the error condition naturally belongs to the first clause but manifests during processing defined by the second clause. Examples:

- E09-403 (permission violation) used by both Clause 7 (expressions) and Clause 9 (memory model)
- E07-750 (internal type visibility) used by both Clause 4 (modules) and Clause 6 (types)

[12] Such sharing is explicitly documented in both locations with forward/backward references to avoid confusion.

---

#### §E.5.3 Diagnostic Payload Schemas [implementation.diagnostics.payloads]

[8] Diagnostic payloads shall be machine-readable and support structured output formats. This section defines JSON schemas for diagnostic messages.

##### §E.5.3.1 Basic Diagnostic Structure

[9] A conforming diagnostic message in JSON format shall have the following structure:

```json
{
  "code": "E02-001",
  "severity": "error",
  "message": "Invalid UTF-8 sequence in source file",
  "location": {
    "file": "src/main.cursive",
    "line": 42,
    "column": 15,
    "span": {
      "start": { "line": 42, "column": 15 },
      "end": { "line": 42, "column": 18 }
    }
  },
  "notes": [
    {
      "message": "UTF-8 validation failed at byte offset 0x2A",
      "location": null
    }
  ],
  "fix_hints": [
    {
      "message": "Replace invalid sequence with valid UTF-8",
      "span": {
        "start": { "line": 42, "column": 15 },
        "end": { "line": 42, "column": 18 }
      },
      "replacement": "\uFFFD"
    }
  ]
}
```

[10] **Fields**:

- `code` (string, required): The diagnostic code in canonical format `E[CC]-[NNN]`.
- `severity` (string, required): One of `"error"`, `"warning"`, or `"note"`.
- `message` (string, required): Human-readable description of the diagnostic.
- `location` (object, required): Source location where the diagnostic was triggered.
  - `file` (string, required): Absolute or relative path to source file.
  - `line` (integer, required): 1-indexed line number.
  - `column` (integer, required): 1-indexed column number (UTF-8 code units).
  - `span` (object, optional): Start and end positions for multi-character spans.
- `notes` (array, optional): Additional context or explanatory notes.
- `fix_hints` (array, optional): Suggested fixes (compiler may offer automated corrections).

##### §E.5.3.2 Multi-Location Diagnostics

[11] Some diagnostics reference multiple source locations (e.g., "type mismatch: expected X here, found Y there"). In such cases, use the `related_locations` field:

```json
{
  "code": "E07-003",
  "severity": "error",
  "message": "Type mismatch in expression",
  "location": {
    "file": "src/main.cursive",
    "line": 50,
    "column": 10
  },
  "related_locations": [
    {
      "message": "Expected type 'i32' from context",
      "location": {
        "file": "src/main.cursive",
        "line": 45,
        "column": 5
      }
    },
    {
      "message": "Expression has type 'f64'",
      "location": {
        "file": "src/main.cursive",
        "line": 50,
        "column": 10
      }
    }
  ]
}
```

---

#### §E.5.4 Quality Guidelines [implementation.diagnostics.quality]

[12] Implementations should strive to produce high-quality diagnostics that aid users in understanding and correcting errors. This section provides recommendations.

##### §E.5.4.1 Message Clarity

[13] Diagnostic messages should:

- **Be concise**: Avoid verbose explanations in the main message. Use notes for extended context.
- **Be specific**: Identify the exact problem (e.g., "expected ';' after statement" not "syntax error").
- **Be actionable**: Suggest what the user should do to fix the issue.
- **Avoid jargon**: Use terminology from the specification, but explain technical terms when necessary.

**Example (Good)**:

```
error[E05-202]: cannot assign to immutable binding 'x'
  --> src/main.cursive:10:5
   |
10 |     x = 42;
   |     ^^^^^^ assignment to immutable binding
   |
note: consider making the binding mutable with 'var'
  --> src/main.cursive:8:5
   |
8  |     let x = 10;
   |     --- help: change this to 'var x = 10;'
```

**Example (Poor)**:

```
error: illegal operation
```

##### §E.5.4.2 Source Context

[14] Diagnostics should include:

- **Line and column numbers**: 1-indexed for compatibility with editors.
- **Source snippet**: Show the offending line(s) with caret (^) or underline indicating the error span.
- **Surrounding context**: For complex errors, show 1-2 lines before/after for orientation.

##### §E.5.4.3 Suggested Fixes

[15] Where feasible, implementations should provide fix hints (automated or manual). Fix hints shall:

- Be syntactically correct;
- Preserve program semantics where possible;
- Be conservative (avoid guessing user intent when multiple fixes are plausible).

**Example**:

```
error[E02-200]: reserved keyword 'type' cannot be used as identifier
  --> src/main.cursive:5:9
   |
5  |     let type = 42;
   |         ^^^^ reserved keyword
   |
help: use a different identifier, or prefix with 'r#' for raw identifier
   |
5  |     let r#type = 42;
   |         ++++++
```

---

#### §E.5.5 Severity Levels [implementation.diagnostics.severity]

[16] The current specification defines three severity levels:

- **Error (E)**: Violates a normative requirement. Compilation cannot proceed past errors. All diagnostics in this version use severity "E".
- **Warning (W)**: Indicates potentially problematic code that does not violate normative requirements (e.g., unused variable, unreachable code). Reserved for future use.
- **Note (N)**: Provides additional context for errors or warnings. Not standalone diagnostics.

[17] Future versions may introduce warnings for common mistakes or deprecated features. Implementations may define implementation-specific warnings (e.g., performance hints) but shall clearly distinguish them from specification-defined diagnostics.

---

#### §E.5.6 Machine-Readable Output [implementation.diagnostics.output]

[18] Implementations should support at least two output formats:

- **Human-readable text**: Default for interactive terminal use. Supports color, styling, and Unicode.
- **JSON**: Machine-readable structured output for tooling (IDEs, CI/CD, linters).

##### §E.5.6.1 JSON Output Format

[19] When the `--diagnostic-format=json` flag is provided (or equivalent), compilers shall emit one JSON object per diagnostic, separated by newlines (JSON Lines format):

```json
{"code":"E02-001","severity":"error","message":"...","location":{...}}
{"code":"E07-003","severity":"error","message":"...","location":{...}}
```

[20] This format enables efficient streaming and parsing by external tools.

##### §E.5.6.2 Text Output Format

[21] Human-readable text output should follow this general template:

```
<severity>[<code>]: <message>
  --> <file>:<line>:<column>
   |
<line_num> | <source_line>
   | <indicator>
   |
<notes...>
<fix_hints...>
```

**Example**:

```
error[E07-003]: type mismatch in expression
  --> src/main.cursive:50:10
   |
50 |     let x: i32 = 3.14;
   |                  ^^^^ expected 'i32', found 'f64'
   |
note: the expression has type 'f64'
  --> src/main.cursive:50:10
   |
help: use an integer literal instead
   |
50 |     let x: i32 = 3;
   |                  ~
```

---

#### §E.5.7 Diagnostic Registry Maintenance [implementation.diagnostics.maintenance]

[22] The diagnostic code registry in this annex is authoritative. When adding new diagnostics:

1. Allocate the next available sequential code within the appropriate clause and subsection range.
2. Update this registry table with code, section reference, and description.
3. Document the diagnostic in the corresponding specification clause.
4. Add examples demonstrating the error condition.
5. Provide suggested diagnostic message templates.

[23] Deprecated diagnostics shall be marked in the registry but not removed, to preserve historical records and support legacy code analysis tools.


### G.1 Assembly, module table, and external imports [algorithms.modules]

This annex specifies normative algorithms for building the module table within a single assembly (project) and for resolving external assemblies referenced by `import`. Within an assembly, every module is always available via qualified access without an `import`. `import` is required only for external assemblies/libraries.

#### G.1.1 Definitions

- Assembly. The build unit defined by the workspace manifest (`Cursive.toml`). The manifest declares one or more source roots (§4.1) and, implementation‑defined, may declare external dependencies.
- Module table 𝕄. A finite map from fully qualified module paths to module metadata constructed from the assembly’s source roots.
- External assembly table 𝔼𝔸. A finite map from external assembly identifiers to their exported module tables. Construction of 𝔼𝔸 is implementation‑defined but must be deterministic and documented.

#### G.1.2 Module table construction (intra‑assembly)

Input: manifest roots R = {r₁,…, rₙ}; file system F.

Output: module table 𝕄.

Algorithm (deterministic):

```
function build_module_table(R, F):
    M := {}                     // empty map
    for each root r in R in lexicographic order:
        for each file f under r where extension ∈ {".cursive"} sorted lexicographically:
            s := relative_path_without_extension(f, r)
            comps := split_on_path_sep(s)
            if not all(is_identifier(c) for c in comps):
                error E04-003 (invalid module path component)
            mpath := join_with("::", comps)
            if mpath ∈ M:
                error E04-004 (case/alias collision) and continue
            M[mpath] := metadata_for(f)
    return M
```

Side conditions:

- `is_identifier` must conform to Annex A §A.1 ASCII identifier rules (Option B from §2 vs Annex A mismatch resolution).
- Implementations must diagnose case‑insensitive collisions before semantic analysis (E04‑004).

#### G.1.3 External assembly import resolution

`import A::p::q [as alias]` refers to a module path under external assembly `A`. Resolution proceeds as:

1) Resolve `A` in 𝔼𝔸 to obtain an external module table 𝕄_A.
2) Verify that `p::q` ∈ dom(𝕄_A). If not, emit E04‑205 (unresolved external module).
3) Record an alias (if any) into the alias map 𝔄 as `alias ↦ (A::p::q)`.

Notes:

- `import` must not be used for intra‑assembly modules; qualified access is sufficient within the assembly.
- Alias identifiers introduced by `import` do not become unqualified bindings; they serve only as qualified heads (§G.3).

---

### G.2 Export‑set construction (no re‑exports) [algorithms.exports]

In the absence of `use`/`public use`, a module’s export set ℰ(m) contains exactly the declarations in module m that are marked `public` by §5.6.

Judgment:

$$
\frac{\text{decl}(d) \land \text{module}(d)=m \land \text{visibility}(d)=\text{public}}{d \in \mathcal{E}(m)}\quad[\text{WF-Export}]
$$

Diagnostics:

- Duplicate exported identifiers within a single module are ill‑formed: emit E04‑203.

---

### G.3 Qualified name resolution (intra‑ and inter‑assembly) [algorithms.qualified]

This section gives a single pipeline for qualified references that covers intra‑assembly access (no imports required) and inter‑assembly access (via `import`).

#### G.3.1 Alias map

The alias map 𝔄 only records aliases introduced by `import` of external assemblies; intra‑assembly access does not use aliases.

#### G.3.2 Resolution rules

Given module tables 𝕄 (assembly) and {𝕄_A} for external assemblies, and alias map 𝔄:

Module‑path head:

$$
\frac{m \in \operatorname{dom}(\mathbb{M}) \quad x \in \mathcal{E}(m)}{m::x \Rightarrow \text{Binding}(m,x)}\quad[\text{QR-Resolve-Intra}]
$$

Alias head (external):

$$
\frac{a \in \operatorname{dom}(\mathbb{A}) \quad \mathbb{A}(a)=m' \quad m'::x \Rightarrow b}{a::x \Rightarrow b}\quad[\text{QR-Alias-External}]
$$

Failure conditions and diagnostics:

- Invalid head (neither module path in 𝕄/𝕄_A nor alias in 𝔄): E04‑400.
- Partial module path not found (left‑to‑right prefix failure): E04‑402.
- Item not exported from resolved module: E04‑404.
- Alias rebound attempt: E04‑403.

---

### G.4 Initialization order and eager/lazy classification [algorithms.init]

Let G = (V, E) be the directed dependency graph whose vertices are modules and edges record initialization‑relevant dependencies.

#### G.4.1 Edge classification

An edge m → n is eager if and only if any module‑scope initializer or comptime block in m may read a binding in ℰ(n) that requires initialization. Otherwise the edge is lazy.

Deterministic classifier:

```
function classify_edges(M):
    for each module m in M:
        for each reference (m → n) discovered in module-scope initializers or comptime blocks:
            mark eager(m, n)
        for each reference to n that mentions only procedures, types, behaviors, or contracts:
            if not eager(m, n): mark lazy(m, n)
    return E_eager, E_lazy
```

#### G.4.2 Ordering and safety

Cycle rejection (eager subgraph):

$$
\frac{\exists C \subseteq V.\, \text{Cycle}(C, E_{eager})}{\text{RejectCycle}(C)}\quad[\text{WF-Cycle}]
$$

Safe initialization:

$$
\frac{\forall p \in \operatorname{Pred}_{eager}(m).\, \text{Initialized}(p)}{\text{SafeInit}(m)}\quad[\text{WF-SafeInit}]
$$

Scheduler (topological): any topological order over (V, E_{eager}). On failure, emit E04‑501 for blocked successors and E04‑502 on attempted reads before initialization completes.

---

### G.5 Conformance hooks and tooling [algorithms.conformance]

Implementations must expose the following artifacts to tooling:

- The intra‑assembly module table 𝕄 and per‑module export sets ℰ(m).
- The external alias map 𝔄 and the set of resolved external assemblies {𝕄_A}.
- The eager subgraph (V, E_{eager}) and its topological order.

All emitted diagnostics must follow Annex E §E.5 payload schemas.

