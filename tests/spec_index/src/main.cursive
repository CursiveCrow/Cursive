procedure string_view_bytes(view: string@View) -> const [u8] {
  let bytes_view: bytes@View = bytes::view_string(view)
  let slice: const [u8] = bytes::as_slice(bytes_view)
  return slice
}

procedure bytes_view_from_slice(data: const [u8]) -> bytes@View {
  let view: bytes@View = bytes::view(data)
  return view
}

procedure slice_len(data: const [u8]) -> usize {
  let view: bytes@View = bytes::view(data)
  let len: usize = bytes::length(view)
  return len
}

procedure find_byte(data: const [u8], start: usize, b: u8) -> usize {
  let len: usize = slice_len(data)
  var i: usize = start
  loop i < len {
    if data[i] == b {
      return i
    }
    i = i + 1
  }
  return len
}

procedure trim_cr(line: const [u8]) -> const [u8] {
  let len: usize = slice_len(line)
  if len == 0 {
    return line
  }
  let last: u8 = line[len - 1usize]
  if last == 13u8 {
    let out: const [u8] = line[0usize..(len - 1usize)]
    return out
  }
  return line
}

procedure is_digit(b: u8) -> bool {
  if b >= 48u8 {
    if b <= 57u8 {
      return true
    }
  }
  return false
}

procedure is_upper(b: u8) -> bool {
  if b >= 65u8 {
    if b <= 90u8 {
      return true
    }
  }
  return false
}

procedure find_subslice(hay: const [u8], needle: const [u8], start: usize) -> usize {
  let hay_len: usize = slice_len(hay)
  let needle_len: usize = slice_len(needle)
  if needle_len == 0usize {
    return start
  }
  if needle_len > hay_len {
    return hay_len
  }
  var i: usize = start
  loop i + needle_len <= hay_len {
    var j: usize = 0usize
    var ok: bool = true
    loop j < needle_len {
      if hay[i + j] != needle[j] {
        ok = false
        break
      }
      j = j + 1
    }
    if ok {
      return i
    }
    i = i + 1
  }
  return hay_len
}

procedure find_diagnostic(line: const [u8]) -> usize {
  let len: usize = slice_len(line)
  if len < 10usize {
    return len
  }
  var i: usize = 0
  loop i + 9usize < len {
    let c0: u8 = line[i]
    if (c0 == 69u8 || c0 == 87u8 || c0 == 73u8 || c0 == 80u8) && line[i + 1usize] == 45u8 {
      let c1: u8 = line[i + 2usize]
      let c2: u8 = line[i + 3usize]
      let c3: u8 = line[i + 4usize]
      if is_upper(c1) && is_upper(c2) && is_upper(c3) && line[i + 5usize] == 45u8 {
        let d0: u8 = line[i + 6usize]
        let d1: u8 = line[i + 7usize]
        let d2: u8 = line[i + 8usize]
        let d3: u8 = line[i + 9usize]
        if is_digit(d0) && is_digit(d1) && is_digit(d2) && is_digit(d3) {
          return i
        }
      }
    }
    i = i + 1
  }
  return len
}

procedure append_view(buf: unique bytes@Managed, view: bytes@View, heap: $HeapAllocator) -> bool {
  let res = bytes::append(buf, view, heap)
  match res {
    _ok: () => { return true }
    _err: AllocationError => { return false }
  }
  return false
}

procedure append_lit(buf: unique bytes@Managed, lit: string@View, heap: $HeapAllocator) -> bool {
  let view: bytes@View = bytes::view_string(lit)
  let ok: bool = append_view(buf, view, heap)
  return ok
}

procedure append_slice(buf: unique bytes@Managed, slice: const [u8], heap: $HeapAllocator) -> bool {
  let view: bytes@View = bytes::view(slice)
  let ok: bool = append_view(buf, view, heap)
  return ok
}

procedure append_byte(buf: unique bytes@Managed, b: u8, heap: $HeapAllocator) -> bool {
  let tmp: [u8; 1] = [b]
  let slice: const [u8] = tmp[0usize..1usize]
  let view: bytes@View = bytes::view(slice)
  let ok: bool = append_view(buf, view, heap)
  return ok
}

procedure append_usize(buf: unique bytes@Managed, n: usize, heap: $HeapAllocator) -> bool {
  var digits: [u8; 20] = [0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]
  var count: usize = 0
  var x: usize = n
  loop {
    let d: usize = x % 10usize
    let digit: u8 = (d as u8)
    digits[count] = 48u8 + digit
    count = count + 1
    x = x / 10usize
    if x == 0usize {
      break
    }
  }
  var i: usize = count
  loop i > 0 {
    i = i - 1
    let ok: bool = append_byte(buf, digits[i], heap)
    if !ok {
      return false
    }
  }
  return true
}

procedure emit_obligation(
  buf: unique bytes@Managed,
  data: const [u8],
  has_section: bool,
  section_start: usize,
  section_end: usize,
  kind: string@View,
  name_start: usize,
  name_end: usize,
  line_no: usize,
  first: bool,
  heap: $HeapAllocator
) -> bool {
  if !first {
    if !append_lit(buf, ",", heap) {
      return false
    }
  }
  if !append_lit(buf, "{\"id\":\"", heap) {
    return false
  }
  if !append_lit(buf, "ยง", heap) {
    return false
  }
  if has_section {
    let sec_slice: const [u8] = data[section_start..section_end]
    if !append_slice(buf, sec_slice, heap) {
      return false
    }
  } else {
    if !append_lit(buf, "0", heap) {
      return false
    }
  }
  if !append_lit(buf, ":", heap) {
    return false
  }
  if !append_lit(buf, kind, heap) {
    return false
  }
  if !append_lit(buf, ":", heap) {
    return false
  }
  let name_slice: const [u8] = data[name_start..name_end]
  if !append_slice(buf, name_slice, heap) {
    return false
  }
  if !append_lit(buf, "\",\"section\":\"", heap) {
    return false
  }
  if has_section {
    let sec_slice2: const [u8] = data[section_start..section_end]
    if !append_slice(buf, sec_slice2, heap) {
      return false
    }
  } else {
    if !append_lit(buf, "0", heap) {
      return false
    }
  }
  if !append_lit(buf, "\",\"kind\":\"", heap) {
    return false
  }
  if !append_lit(buf, kind, heap) {
    return false
  }
  if !append_lit(buf, "\",\"name\":\"", heap) {
    return false
  }
  if !append_slice(buf, name_slice, heap) {
    return false
  }
  if !append_lit(buf, "\",\"line\":", heap) {
    return false
  }
  if !append_usize(buf, line_no, heap) {
    return false
  }
  if !append_lit(buf, "}", heap) {
    return false
  }
  return true
}

public procedure main(move ctx: Context) -> i32 {
  let fs: $FileSystem = move ctx.fs
  let heap: $HeapAllocator = move ctx.heap
  let input_path: string@View = "C0updated.md"
  let output_path: string@View = "tests/spec_index/spec_index.json"

  let read_res = fs ~> read_file(input_path)
  var contents: string@Managed = match read_res {
    s: string@Managed => { s }
    _e: IoError => { return 1 }
  }

  let view: string@View = string::as_view(contents)
  let data: const [u8] = string_view_bytes(view)
  let data_len: usize = slice_len(data)

  let buf_res = bytes::with_capacity(data_len + 1024, heap)
  var out_buf: unique bytes@Managed = match buf_res {
    b: bytes@Managed => { b }
    _e: AllocationError => { return 1 }
  }

  if !append_lit(out_buf, "{\"version\":1,\"obligations\":[", heap) {
    return 1
  }

  var line_start: usize = 0
  var line_no: usize = 1
  var has_section: bool = false
  var section_start: usize = 0
  var section_end: usize = 0
  var first: bool = true

  let op_pat: [u8; 3] = [226u8, 138u8, 162u8]
  let op_slice: const [u8] = op_pat[0usize..3usize]

  loop line_start < data_len {
    let line_end: usize = find_byte(data, line_start, 10u8)
    let end: usize = if line_end == data_len { data_len } else { line_end }
    let line: const [u8] = data[line_start..end]
    let line_trim: const [u8] = trim_cr(line)
    let line_len: usize = slice_len(line_trim)

    if line_len >= 2usize {
      var hash_count: usize = 0
      loop hash_count < line_len {
        if line_trim[hash_count] == 35u8 {
          hash_count = hash_count + 1
        } else {
          break
        }
      }
      if hash_count > 0usize && hash_count < line_len && line_trim[hash_count] == 32u8 {
        var pos: usize = hash_count + 1usize
        let num_start: usize = pos
        loop pos < line_len {
          let c: u8 = line_trim[pos]
          if is_digit(c) || c == 46u8 {
            pos = pos + 1
          } else {
            break
          }
        }
        if pos > num_start {
          section_start = line_start + num_start
          section_end = line_start + pos
          has_section = true
        }
      }
    }

    if line_len >= 4usize && line_trim[0usize] == 42u8 && line_trim[1usize] == 42u8 {
      if line_trim[2usize] == 40u8 {
        var i: usize = 3usize
        var found: bool = false
        loop i + 2usize < line_len {
          if line_trim[i] == 41u8 && line_trim[i + 1usize] == 42u8 && line_trim[i + 2usize] == 42u8 {
            found = true
            break
          }
          i = i + 1
        }
        if found {
          let name_start: usize = line_start + 3usize
          let name_end: usize = line_start + i
          let ok: bool = emit_obligation(out_buf, data, has_section, section_start, section_end, "rule", name_start, name_end, line_no, first, heap)
          if !ok {
            return 1
          }
          first = false
        }
      } else {
        var j: usize = 2usize
        var found_def: bool = false
        loop j + 1usize < line_len {
          if line_trim[j] == 42u8 && line_trim[j + 1usize] == 42u8 {
            found_def = true
            break
          }
          j = j + 1
        }
        if found_def {
          var name_end2: usize = line_start + j
          let name_start2: usize = line_start + 2usize
          if name_end2 > name_start2 && data[name_end2 - 1usize] == 46u8 {
            name_end2 = name_end2 - 1usize
          }
          let ok2: bool = emit_obligation(out_buf, data, has_section, section_start, section_end, "definition", name_start2, name_end2, line_no, first, heap)
          if !ok2 {
            return 1
          }
          first = false
        }
      }
    }

    let diag_idx: usize = find_diagnostic(line_trim)
    if diag_idx < line_len {
      let name_start3: usize = line_start + diag_idx
      let name_end3: usize = line_start + diag_idx + 10usize
      let ok3: bool = emit_obligation(out_buf, data, has_section, section_start, section_end, "diagnostic", name_start3, name_end3, line_no, first, heap)
      if !ok3 {
        return 1
      }
      first = false
    }

    let op_idx: usize = find_subslice(line_trim, op_slice, 0usize)
    if op_idx < line_len {
      var p: usize = op_idx + 3usize
      loop p < line_len {
        if line_trim[p] == 32u8 {
          p = p + 1
        } else {
          break
        }
      }
      let name_start4: usize = line_start + p
      var q: usize = p
      loop q < line_len {
        if line_trim[q] == 32u8 {
          break
        }
        q = q + 1
      }
      if q > p {
        let name_end4: usize = line_start + q
        let ok4: bool = emit_obligation(out_buf, data, has_section, section_start, section_end, "judgment", name_start4, name_end4, line_no, first, heap)
        if !ok4 {
          return 1
        }
        first = false
      }
    }

    if line_end == data_len {
      line_start = data_len
    } else {
      line_start = line_end + 1usize
    }
    line_no = line_no + 1
  }

  if !append_lit(out_buf, "]}", heap) {
    return 1
  }

  let out_view: bytes@View = bytes::as_view(out_buf)
  let write_res = fs ~> write_file(output_path, out_view)
  match write_res {
    _ok: () => { return 0 }
    _e: IoError => { return 1 }
  }
}
