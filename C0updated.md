# Cursive 0

- [Cursive 0](#cursive-0)
  - [0. Front Matter](#0-front-matter)
    - [0.1. Status and Scope (Bootstrap, Informative)](#01-status-and-scope-bootstrap-informative)
    - [0.2. Deviations from the Root Specification (Cursive0)](#02-deviations-from-the-root-specification-cursive0)
    - [0.3. Bootstrap Milestones and Equivalence](#03-bootstrap-milestones-and-equivalence)
    - [0.4. Document Conventions](#04-document-conventions)
  - [1. Foundations](#1-foundations)
    - [1.1. Conformance](#11-conformance)
    - [1.2. Behavior Types](#12-behavior-types)
    - [1.3. Authority Model](#13-authority-model)
    - [1.4. Unsupported Constructs Policy](#14-unsupported-constructs-policy)
    - [1.5. Target and ABI Assumptions](#15-target-and-abi-assumptions)
    - [1.6. Diagnostics Infrastructure](#16-diagnostics-infrastructure)
    - [1.7. Host Primitives](#17-host-primitives)
  - [2. Phase 0: Build/Project Model](#2-phase-0-buildproject-model)
    - [2.1. Project Root and Manifest](#21-project-root-and-manifest)
    - [2.2. Assemblies](#22-assemblies)
    - [2.3. Deterministic Ordering and Case Folding](#23-deterministic-ordering-and-case-folding)
    - [2.4. Module Discovery](#24-module-discovery)
    - [2.5. Output Artifacts and Linking](#25-output-artifacts-and-linking)
    - [2.6. Tool Resolution and IR Assembly Inputs](#26-tool-resolution-and-ir-assembly-inputs)
    - [2.7. Unwind and FFI Surface](#27-unwind-and-ffi-surface)
  - [3. Phase 1: Source Loading, Lexing, Parsing](#3-phase-1-source-loading-lexing-parsing)
    - [3.1. Source Loading and Normalization](#31-source-loading-and-normalization)
    - [3.2. Lexical Analysis](#32-lexical-analysis)
    - [3.3. Grammar, Parsing, and AST Construction](#33-grammar-parsing-and-ast-construction)
    - [3.4. Module Aggregation](#34-module-aggregation)
  - [4. Phase 2: Compile-Time Execution (Deferred in Cursive0)](#4-phase-2-compile-time-execution-deferred-in-cursive0)
  - [5. Phase 3: Name Resolution + Type Checking](#5-phase-3-name-resolution--type-checking)
    - [5.1. Name Resolution and Scopes (Cursive0)](#51-name-resolution-and-scopes-cursive0)
    - [5.2. Type System Core (Cursive0)](#52-type-system-core-cursive0)
    - [5.3. Classes and Record Methods (Cursive0)](#53-classes-and-record-methods-cursive0)
    - [5.4. Modal Types (Definitions)](#54-modal-types-definitions)
    - [5.5. State-Specific Fields](#55-state-specific-fields)
    - [5.6. Transitions and State-Specific Methods](#56-transitions-and-state-specific-methods)
    - [5.7. Modal Widening (`widen`)](#57-modal-widening-widen)
    - [5.8. String and Bytes Types and States](#58-string-and-bytes-types-and-states)
    - [5.9. Capabilities and Context (Cursive0)](#59-capabilities-and-context-cursive0)
    - [5.10. Enum Discriminant Defaults](#510-enum-discriminant-defaults)
    - [5.11. Foundational Predicates and Classes (Cursive0)](#511-foundational-predicates-and-classes-cursive0)
    - [5.12. Initialization Planning](#512-initialization-planning)
    - [5.13 Attributes and Metadata](#513-attributes-and-metadata)
  - [6. Phase 4: Code Generation](#6-phase-4-code-generation)
    - [6.0. Codegen Model and Judgments](#60-codegen-model-and-judgments)
    - [6.1. Layout and Representation](#61-layout-and-representation)
    - [6.2. ABI Lowering (Cursive0)](#62-abi-lowering-cursive0)
    - [6.3. Symbols, Mangling, and Linkage](#63-symbols-mangling-and-linkage)
    - [6.4. Expression Lowering and Evaluation Order](#64-expression-lowering-and-evaluation-order)
    - [6.5. Statement and Block Lowering](#65-statement-and-block-lowering)
    - [6.6. Pattern Matching Lowering](#66-pattern-matching-lowering)
    - [6.7. Globals and Initialization](#67-globals-and-initialization)
    - [6.8. Cleanup, Drop, and Unwinding](#68-cleanup-drop-and-unwinding)
    - [6.9. Built-ins Runtime Interface](#69-built-ins-runtime-interface)
    - [6.10. Dynamic Dispatch](#610-dynamic-dispatch)
    - [6.11. Checks and Panic](#611-checks-and-panic)
    - [6.12. LLVM 21 Backend Requirements](#612-llvm-21-backend-requirements)
  - [7. Dynamic Semantics](#7-dynamic-semantics)
    - [7.1. Initialization Order and Poisoning](#71-initialization-order-and-poisoning)
    - [7.2. Modal Layout (Dynamic Semantics)](#72-modal-layout-dynamic-semantics)
    - [7.3. Modal Pattern Matching](#73-modal-pattern-matching)
    - [7.4. Deterministic Destruction and Unwinding (Cursive0)](#74-deterministic-destruction-and-unwinding-cursive0)
    - [7.5. String Literal Semantics](#75-string-literal-semantics)
    - [7.6. Dynamic Class Objects](#76-dynamic-class-objects)
    - [7.7. FileSystem and File Operations](#77-filesystem-and-file-operations)
    - [7.8. Interpreter Entrypoint (Project-Level)](#78-interpreter-entrypoint-project-level)
  - [8. Appendix A - Diagnostic Codes](#8-appendix-a---diagnostic-codes)
    - [8.0. DiagIdÃ¢â‚¬â€œCode Map](#80-diagidÃ¢code-map)
    - [8.1. E-PRJ (Project)](#81-e-prj-project)
    - [8.2. E-MOD (Module)](#82-e-mod-module)
    - [8.3. E-OUT (Output and Linking)](#83-e-out-output-and-linking)
    - [8.4. E-SRC (Source)](#84-e-src-source)
    - [8.5. E-CNF (Conformance / Limits)](#85-e-cnf-conformance--limits)
    - [8.6. W-CNF (Conformance Warnings)](#86-w-cnf-conformance-warnings)
    - [8.7. E-UNS (Unsupported Constructs)](#87-e-uns-unsupported-constructs)
    - [8.8. E-MEM (Memory)](#88-e-mem-memory)
    - [8.9. E-CON (Concurrency and Contracts)](#89-e-con-concurrency-and-contracts)
    - [8.10. I-CON (Concurrency and Contracts Info)](#810-i-con-concurrency-and-contracts-info)
    - [8.11. W-CON (Concurrency and Contracts Warnings)](#811-w-con-concurrency-and-contracts-warnings)
    - [8.12. E-SYS (System)](#812-e-sys-system)
    - [8.13. W-MOD (Module Warnings)](#813-w-mod-module-warnings)
    - [8.14. W-SRC (Source Warnings)](#814-w-src-source-warnings)
    - [8.15. E-TYP (Types)](#815-e-typ-types)
    - [8.16. W-SYS (System Warnings)](#816-w-sys-system-warnings)
    - [8.17. E-SEM (Semantics)](#817-e-sem-semantics)
    - [8.18. W-SEM (Semantic Warnings)](#818-w-sem-semantic-warnings)
    - [8.19. P-TYP (Runtime Panics - Types)](#819-p-typ-runtime-panics---types)
    - [8.20. P-SEM (Runtime Panics - Semantics)](#820-p-sem-runtime-panics---semantics)
  - [9. Appendix B - Notation and Glossary](#9-appendix-b---notation-and-glossary)
    - [9.1. Notation Conventions](#91-notation-conventions)
    - [9.2. Helper Functions and Relations](#92-helper-functions-and-relations)

## 0. Front Matter

### 0.1. Status and Scope (Bootstrap, Informative)

**Phase.**
Phase = {Phase0, Phase1, Phase2, Phase3, Phase4}

**PhaseStatus.**
PhaseStatus = {Implemented, Deferred, InProgress}

**PhaseStatusMap.**
PhaseStatus(Phase0) = Implemented
PhaseStatus(Phase1) = Implemented
PhaseStatus(Phase2) = Deferred
PhaseStatus(Phase3) = InProgress
PhaseStatus(Phase4) = InProgress

**PhaseSection.**
PhaseSection(Phase0) = 2
PhaseSection(Phase1) = 3
PhaseSection(Phase2) = 4
PhaseSection(Phase3) = 5
PhaseSection(Phase4) = 6

### 0.2. Deviations from the Root Specification (Cursive0)

**DeviationId.**
DeviationId = {D_BootstrapEquivalence, D_SourceNormalization, D_ModuleOrdering, D_KeywordReservation, D_GenericTokenization, D_UnsafeSpanClassification, D_GroupingTrailingCommas, D_UnsupportedGrammarFamilies, D_OverloadingScope, D_Permissions, D_ParamPassing, D_PointerAddressOf, D_RegionOptionsSyntax, D_TypeInference, D_RecordUpdate, D_RangeExpressions, D_RangePatterns, D_FieldVisibilityDefault, D_EnumDiscriminantControls, D_UnionLayout, D_LayoutAttributes, D_CallingConventionToolchain, D_SymbolVisibilityMechanism, D_FileSystemSemantics, D_ResultStatementRemoved}

- `System` in Cursive0 omits `time()`;
- Cursive0 does not reserve `result` as a keyword and does not support the `result e;` statement-form. Block values are produced by tail expressions (and, where early exit is required, by `frame`/`break`-style control constructs). The contract intrinsic `@result` remains supported (Â§3.3.8.6) and is parsed as `@` followed by an identifier with lexeme `result`. this is a bootstrap restriction.

**DeviationRef.**
DeviationRef(D_BootstrapEquivalence) = {"0.3.2"}
DeviationRef(D_SourceNormalization) = {"3.1.1"}
DeviationRef(D_ModuleOrdering) = {"2.3.1", "2.3.2", "2.3.3"}
DeviationRef(D_KeywordReservation) = {"3.2.3"}
DeviationRef(D_GenericTokenization) = {"3.2.9"}
DeviationRef(D_UnsafeSpanClassification) = {"3.2.12"}
DeviationRef(D_GroupingTrailingCommas) = {"3.3.4"}
DeviationRef(D_UnsupportedGrammarFamilies) = {"3.3.2.7"}
DeviationRef(D_OverloadingScope) = {"5.1.5", "5.3"}
DeviationRef(D_Permissions) = {"1.1.1", "5.2.2"}
DeviationRef(D_ParamPassing) = {"5.2.4", "5.3.2", "5.2.15"}
DeviationRef(D_PointerAddressOf) = {"1.1.1", "5.2.12", "5.2.16"}
DeviationRef(D_RegionOptionsSyntax) = {"3.3.4", "5.2.17"}
DeviationRef(D_TypeInference) = {"5.2.9"}
DeviationRef(D_RecordUpdate) = {"3.3.4"}
DeviationRef(D_RangeExpressions) = {"5.2.12"}
DeviationRef(D_RangePatterns) = {"5.2.13"}
DeviationRef(D_FieldVisibilityDefault) = {"5.2.2", "5.3.2"}
DeviationRef(D_EnumDiscriminantControls) = {"5.10", "6.1.4"}
DeviationRef(D_UnionLayout) = {"6.1.4", "6.1.4.1"}
DeviationRef(D_LayoutAttributes) = {"6.1.3"}
DeviationRef(D_CallingConventionToolchain) = {"6.2.1", "6.2.3"}
DeviationRef(D_SymbolVisibilityMechanism) = {"6.3.4"}
DeviationRef(D_FileSystemSemantics) = {"7.7"}
DeviationRef(D_ResultStatementRemoved) = {"0.2.1", "3.2.3", "3.3.8.6"}

### 0.3. Bootstrap Milestones and Equivalence

#### 0.3.1. Bootstrap Milestones and Invariants

**BootstrapCompiler.**
BootstrapCompiler = {cursivec0, cursivec1, cursivec2}

**BootstrapName.**
BootstrapName(cursivec0) = "cursivec0"
BootstrapName(cursivec1) = "cursivec1"
BootstrapName(cursivec2) = "cursivec2"

**BootstrapImpl.**
BootstrapImpl(cursivec0) = {"C++", "LLVM"}
BootstrapImpl(cursivec1) = {"Cursive"}
BootstrapImpl(cursivec2) = {"Cursive"}

**CompilerSourceProject.**
CompilerSource âˆˆ Project

**ProducesCompiler.**
ProducesCompiler : BootstrapCompiler Ã— Project â‡€ BootstrapCompiler

**Milestone Invariants.**
M0 â‡” Status(cursivec0, CompilerSource) = ok âˆ§ Subset(CompilerSource, S0)
M1 â‡” Status(cursivec1, CompilerSource) = ok âˆ§ ProducesCompiler(cursivec1, CompilerSource) = cursivec2
M2 â‡” âˆ€ P âˆˆ Project. BootstrapEq(cursivec1, cursivec2, P)

#### 0.3.2. Observable Behavior Equivalence for Bootstrap

**Compiler Observable Behavior.**

Under(p, O) â‡” prefix(Normalize(p), Normalize(O))
IsFile(p) â‡” FSKind(p) = File

DiagObs(d) = âŸ¨d.code, d.severity, d.message, d.spanâŸ©
DiagStream(C, P) = [DiagObs(d_1), â€¦, DiagObs(d_k)]
Status(C, P) = ok â‡” âˆ€ d âˆˆ DiagStream(C, P). d.severity â‰  Error
Status(C, P) = fail â‡” âˆƒ d âˆˆ DiagStream(C, P). d.severity = Error
ExitCode(C, P) = 0 â‡” Status(C, P) = ok
ExitCode(C, P) = 1 â‡” Status(C, P) = fail
Executable(P) â‡” P.assembly.kind = `executable`
IRSet(P) = {IRPath(P, m, e) | m âˆˆ ModuleList(P)} if P.assembly.emit_ir = e âˆˆ {"ll", "bc"}
IRSet(P) = âˆ… if P.assembly.emit_ir âˆ‰ {"ll", "bc"}
ExeSet(P) =
 {ExePath(P)}  if Executable(P)
 âˆ…             otherwise
RequiredOutputs(P) = {ObjPath(P, m) | m âˆˆ ModuleList(P)} âˆª IRSet(P) âˆª ExeSet(P)
Artifacts(C, P) = RequiredOutputs(P) â‡” Status(C, P) = ok
Artifacts(C, P) = âˆ… â‡” Status(C, P) = fail

ObsComp(C, P) = âŸ¨Status(C, P), ExitCode(C, P), DiagStream(C, P), Artifacts(C, P)âŸ©

**Bootstrap Equivalence.**
BootstrapEq(C_a, C_b, P) â‡” ObsComp(C_a, P) = ObsComp(C_b, P) âˆ§ (Status(C_a, P) = ok â‡’ Artifacts(C_a, P) = RequiredOutputs(P))

### 0.4. Document Conventions

**NormativeKeywords.**
NormativeKeywords = {`MUST`, `MUST NOT`, `SHOULD`, `SHOULD NOT`, `MAY`}

**RFC 2119 Interpretation.**
The keywords in NormativeKeywords MUST be interpreted as described in RFC 2119.

**DocScope.**
DocScope = {ConformanceTarget, SupportedSubset, RequiredBehavior(`cursivec0`)}

**DiagnosticCodeFormat.**
DiagPrefix = {E, W, I}
DiagCategory = [A-Z]^3
DiagDigits = [0-9]^4
DiagCode = DiagPrefix ++ "-" ++ DiagCategory ++ "-" ++ DiagDigits
Bucket(Digits) = Digits[0..1]
Seq(Digits) = Digits[2..3]

## 1. Foundations

### 1.1. Conformance

**C0Conforming.**
C0Conforming(P) â‡” WF(P) âˆ§ Subset(P, S0)

**WF.**
WF(P) â‡” âˆƒ Î“. Project(Î“) = P âˆ§ âˆ€ j âˆˆ ReqJudgments(P). Î“ âŠ¢ j â‡“ ok

**ReqJudgments.**
ReqJudgments(P) = [Phase1Order(P), Phase3Order(P), Phase4Order(P)]

**Phase1Order.**
Î“ âŠ¢ Phase1Order(P) â‡“ ok â‡” âˆƒ Ms. Î“ âŠ¢ ParseModules(P) â‡“ Ms

**Phase4Order.**
Î“ âŠ¢ Phase4Order(P) â‡“ ok â‡” âˆƒ Objs, IRs, Exe. Î“ âŠ¢ OutputPipeline(P) â‡“ (Objs, IRs, Exe)

**Constructs.**
TypeNodes(P, m) = { t | t âˆˆ Type âˆ§ Subnode(ASTModule(P, m), t) }
StmtNodes(P, m) = { s | s âˆˆ Stmt âˆ§ Subnode(ASTModule(P, m), s) }

ItemKind(UsingDecl(_, _, _, _, _)) = `using_decl`
ItemKind(ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _)) = `procedure`
ItemKind(RecordDecl(_, _, _, _, _, _, _, _, _, _)) = `record`
ItemKind(EnumDecl(_, _, _, _, _, _, _, _, _, _)) = `enum`
ItemKind(ModalDecl(_, _, _, _, _, _, _, _, _, _)) = `modal`
ItemKind(ClassDecl(_, _, _, _, _, _, _, _, _, _)) = `class`
ItemKind(TypeAliasDecl(_, _, _, _, _, _, _, _)) = `type_alias`
ItemKind(StaticDecl(_, _, _, _, _, _)) = `static_decl`
ItemKind(_) = âŠ¥

TopDeclConstructs(P) = { ItemKind(it) | m âˆˆ P.modules âˆ§ it âˆˆ ASTModule(P, m).items âˆ§ ItemKind(it) â‰  âŠ¥ }

TypeCtor(TypePerm(_, base)) = TypeCtor(base)
TypeCtor(TypePrim(name)) = {name}
TypeCtor(TypeTuple(elems)) = {`tuple`} âˆª â‹ƒ_{t âˆˆ elems} TypeCtor(t)
TypeCtor(TypeArray(elem, _)) = {`array`} âˆª TypeCtor(elem)
TypeCtor(TypeSlice(elem)) = {`slice`} âˆª TypeCtor(elem)
TypeCtor(TypeUnion(members)) = {`union`} âˆª â‹ƒ_{t âˆˆ members} TypeCtor(t)
TypeCtor(TypeFunc(params, ret)) = {`function`} âˆª â‹ƒ_{âŸ¨_, tâŸ© âˆˆ params} TypeCtor(t) âˆª TypeCtor(ret)
TypeCtor(TypePtr(elem, _)) = {`ptr`} âˆª TypeCtor(elem)
TypeCtor(TypeRawPtr(_, elem)) = {`rawptr`} âˆª TypeCtor(elem)
TypeCtor(TypeString(_)) = {`string`}
TypeCtor(TypeBytes(_)) = {`bytes`}
TypeCtor(TypeDynamic(_)) = {`dyn_class`}
TypeCtor(TypeOpaque(_)) = {`opaque`}
TypeCtor(TypeRefine(base, _)) = {`refinement`} âˆª TypeCtor(base)
TypeCtor(TypeModalState(_, _)) = {`modal`}
TypeCtor(TypePath(["Region"])) = {`region`}
TypeCtor(TypePath(["RegionOptions"])) = {`region_options`}
TypeCtor(TypePath(p)) = {`record`} if RecordDecl(p) defined
TypeCtor(TypePath(p)) = {`enum`} if EnumDecl(p) defined
TypeCtor(_) = âˆ…

TypeConstructs(P) = â‹ƒ_{m âˆˆ P.modules} â‹ƒ_{t âˆˆ TypeNodes(P, m)} TypeCtor(t)

PermOfType(TypePerm(p, _)) = {p}
PermOfType(_) = âˆ…
RecvPerms(members) = { p | âˆƒ attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc. MethodDecl(attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ members âˆ§ recv = ReceiverShorthand(p) }
ClassRecvPerms(items) = { p | âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ items âˆ§ recv = ReceiverShorthand(p) }
StateRecvPerms(states) = { p | âˆƒ S, members, span, doc, attrs, vis, name, gen_params, recv, params, ret, contract, body. StateBlock(S, members, span, doc) âˆˆ states âˆ§ StateMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, _, _) âˆˆ members âˆ§ recv = ReceiverShorthand(p) }
PermConstructs(P) = â‹ƒ_{m âˆˆ P.modules} â‹ƒ_{t âˆˆ TypeNodes(P, m)} PermOfType(t) âˆª â‹ƒ_{m âˆˆ P.modules} â‹ƒ_{RecordDecl(_, _, _, _, _, _, members, _, _, _) âˆˆ ASTModule(P, m).items} RecvPerms(members) âˆª â‹ƒ_{m âˆˆ P.modules} â‹ƒ_{ModalDecl(_, _, _, _, _, _, states, _, _, _) âˆˆ ASTModule(P, m).items} StateRecvPerms(states) âˆª â‹ƒ_{m âˆˆ P.modules} â‹ƒ_{ClassDecl(_, _, _, _, _, _, _, items, _, _) âˆˆ ASTModule(P, m).items} ClassRecvPerms(items)

ExprKind(Literal(_)) = `literal`
ExprKind(Identifier(_)) = `identifier`
ExprKind(FieldAccess(_, _)) = `field_access`
ExprKind(TupleAccess(_, _)) = `tuple_index`
ExprKind(IndexAccess(_, _)) = `index`
ExprKind(IfExpr(_, _, _)) = `if`
ExprKind(MatchExpr(_, _)) = `match`
ExprKind(LoopInfinite(_)) = `loop`
ExprKind(LoopConditional(_, _)) = `loop`
ExprKind(LoopIter(_, _, _, _)) = `loop`
ExprKind(MoveExpr(_)) = `move`
ExprKind(Unary(`"widen"`, _)) = `widen`
ExprKind(TransmuteExpr(_, _, _)) = `transmute`
ExprKind(UnsafeBlockExpr(_)) = `unsafe`
ExprKind(AllocExpr(_, _)) = `region_alloc`
ExprKind(MethodCall(_, _, _)) = `method_call`
ExprKind(Propagate(_)) = `union_propagate`
ExprKind(ParallelExpr(_, _, _)) = `parallel`
ExprKind(SpawnExpr(_, _)) = `spawn`
ExprKind(DispatchExpr(_, _, _, _, _)) = `dispatch`
ExprKind(WaitExpr(_)) = `wait`
ExprKind(YieldExpr(_, _)) = `yield`
ExprKind(YieldFromExpr(_, _)) = `yield`
ExprKind(SyncExpr(_)) = `sync`
ExprKind(RaceExpr(_)) = `race`
ExprKind(AllExpr(_)) = `all`
ExprKind(_) = âŠ¥

StmtKind(LetStmt(_)) = `let`
StmtKind(VarStmt(_)) = `var`
StmtKind(ShadowLetStmt(_, _, _)) = `shadow`
StmtKind(ShadowVarStmt(_, _, _)) = `shadow`
StmtKind(AssignStmt(_, _)) = `assign`
StmtKind(CompoundAssignStmt(_, _, _)) = `compound_assign`
StmtKind(DeferStmt(_)) = `defer`
StmtKind(RegionStmt(_, _, _)) = `region`
StmtKind(FrameStmt(_, _)) = `frame`
StmtKind(KeyBlockStmt(_, _, _, _)) = `key_block`
StmtKind(ReturnStmt(_)) = `return`
StmtKind(BreakStmt(_)) = `break`
StmtKind(ContinueStmt) = `continue`
StmtKind(UnsafeBlockStmt(_)) = `unsafe`
StmtKind(_) = âŠ¥

ExprStmtConstructs(P) = { ExprKind(e) | m âˆˆ P.modules âˆ§ e âˆˆ ExprNodes(P, m) âˆ§ ExprKind(e) â‰  âŠ¥ } âˆª { StmtKind(s) | m âˆˆ P.modules âˆ§ s âˆˆ StmtNodes(P, m) âˆ§ StmtKind(s) â‰  âŠ¥ }

CapConstructs(P) = { c | c âˆˆ {`Context`, `FileSystem`, `HeapAllocator`, `ExecutionDomain`, `Reactor`} âˆ§ âˆƒ m, t. m âˆˆ P.modules âˆ§ t âˆˆ TypeNodes(P, m) âˆ§ t = TypePath([c]) }

Constructs(P) = TopDeclConstructs(P) âˆª TypeConstructs(P) âˆª PermConstructs(P) âˆª ExprStmtConstructs(P) âˆª CapConstructs(P)

**Subset.**
Subset(P, S0) â‡” Constructs(P) âŠ† S0

**(Reject-IllFormed)**
Â¬ C0Conforming(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Reject(P)

**TranslationPhases.**

TranslationPhases = [Phase1, Phase2, Phase3, Phase4]

#### 1.1.1. Cursive0 Subset (S0)

S0 = S_Lex âˆª S_Modules âˆª S_TopDecl âˆª S_Types âˆª S_Perms âˆª S_ExprStmt âˆª S_Caps

**S_Lex.**
S_Lex = RulesIn({"3.1", "3.2", "3.3"})

**S_Modules.**
S_Modules = RulesIn({"2", "3.3.6.3", "5.1"})

**S_TopDecl.**
S_TopDecl = {`import_decl`, `using_decl`, `extern_block`, `procedure`, `record`, `enum`, `modal`, `class`, `type_alias`, `static_decl`}

**S_Types.**
PrimTypes_C0 = IntTypes âˆª FloatTypes âˆª {`bool`, `char`, `()`, `!`}
TypeCtors_C0 = {`tuple`, `array`, `slice`, `record`, `enum`, `union`, `function`, `ptr`, `rawptr`, `string`, `bytes`, `region_options`, `region`, `dyn_class`, `opaque`, `refinement`}
S_Types = PrimTypes_C0 âˆª TypeCtors_C0

**S_Perms.**
S_Perms = PermSet_C0

**S_ExprStmt.**
S_ExprStmt = {`literal`, `identifier`, `field_access`, `tuple_index`, `index`, `if`, `loop`, `match`, `break`, `continue`, `return`, `defer`, `region`, `frame`, `key_block`, `union_propagate`, `let`, `var`, `shadow`, `assign`, `compound_assign`, `move`, `widen`, `transmute`, `unsafe`, `region_alloc`, `method_call`, `parallel`, `spawn`, `dispatch`, `wait`, `yield`, `sync`, `race`, `all`}

**S_Caps.**
S_Caps = {`Context`, `FileSystem`, `HeapAllocator`, `ExecutionDomain`, `Reactor`}
  
**PermSet (Cursive0).**
PermSet_C0 = {`const`, `unique`, `shared`}

**Subset Lexeme Basis.**
Let S be a source file and let K satisfy Î“ âŠ¢ Tokenize(S) â‡“ (K, _).
Any use of PermSyntax or UnsupportedForm MUST be based on token lexemes in K (and, where specified elsewhere, the AST produced by ParseFile(S)); implementations MUST NOT match substrings inside identifiers.
See Ã‚Â§3.2.2 and Ã‚Â§3.2.7.

S0Unsupported = {`closure`, `pipeline`, `metaprogramming`, `Network`, `GPUFactory`, `CPUFactory`}

### 1.2. Behavior Types

**IllFormed.**
StaticJudgSet = WFModulePathJudg âˆª LinkJudg âˆª ParseJudgment âˆª ResolvePathJudg âˆª ResolveExprListJudg âˆª ResolveEnumPayloadJudg âˆª ResolveCalleeJudg âˆª ResolveArmJudg âˆª ResolveStmtSeqJudg âˆª TypeEqJudg âˆª ConstLenJudg âˆª SubtypingJudg âˆª PermSubJudg âˆª ArgsOkTJudg âˆª TypeInfJudg âˆª StmtJudg âˆª PatJudg âˆª ExprJudg âˆª MatchJudg âˆª DeclJudg âˆª BJudgment âˆª ArgPassJudg âˆª ProvPlaceJudg âˆª ProvExprJudg âˆª ProvStmtJudg âˆª BlockProvJudg âˆª ArgsOkJudg âˆª TypeWFJudg âˆª StringBytesJudg âˆª BitcopyDropJudg âˆª BitcopyJudg âˆª CloneJudg âˆª DropJudg âˆª FfiSafeJudg âˆª TypeRefsJudg âˆª ValueRefsJudg âˆª CodegenJudg âˆª LayoutJudg âˆª EncodeConstJudg âˆª ValidValueJudg âˆª RecordLayoutJudg âˆª UnionLayoutJudg âˆª TupleLayoutJudg âˆª RangeLayoutJudg âˆª EnumLayoutJudg âˆª ModalLayoutJudg âˆª DynLayoutJudg âˆª ABITyJudg âˆª ABIParamJudg âˆª ABIRetJudg âˆª ABICallJudg âˆª LowerCallJudg âˆª MangleJudg âˆª LinkageJudg âˆª EvalOrderJudg âˆª LowerExprJudg âˆª LowerStmtJudg âˆª PatternLowerJudg âˆª LowerBindJudg âˆª GlobalsJudg âˆª ConstInitJudg âˆª CleanupJudg âˆª RuntimeIfcJudg âˆª DynDispatchJudg âˆª ChecksJudg âˆª LLVMAttrJudg âˆª RuntimeDeclJudg âˆª LLVMTyJudg âˆª LLVMEmitJudg âˆª LowerIRJudg âˆª BindStorageJudg âˆª LLVMCallJudg âˆª VTableJudg âˆª LiteralEmitJudg âˆª BuiltinSymJudg âˆª DropHookJudg âˆª EntryJudg âˆª PoisonJudg
StaticRuleSet = { r | Conclusion(r) âˆˆ StaticJudgSet }
Conclusion(r) = J    (r is written (Ï€_1 â€¦ Ï€_k) / J)
Premises(r) = [Ï€_1, â€¦, Ï€_k]    (r is written (Ï€_1 â€¦ Ï€_k) / _)
Subject(Î“ âŠ¢ j) = j_0 where j_0 is the leftmost term to the right of âŠ¢
EnvOf(Î“ âŠ¢ j) = Î“
Î¸ ranges over substitutions of metavariables in r
Applies(r, x) â‡” âˆƒ Î¸. Subject(Conclusion(r)[Î¸]) = x
PremisesHold(r, x) â‡” âˆƒ Î¸. Subject(Conclusion(r)[Î¸]) = x âˆ§ Î“_r = EnvOf(Conclusion(r)[Î¸]) âˆ§ âˆ€ Ï€ âˆˆ Premises(r)[Î¸]. Ï€ â‰  âŠ¥ âˆ§ (Ï€ is a judgment â‡’ Î“_r âŠ¢ Ï€)
IllFormed(x) â‡” âˆƒ r âˆˆ StaticRuleSet. Applies(r, x) âˆ§ Â¬ PremisesHold(r, x)

**Undefinedness Policy.**
StaticUndefined(J) â‡” âˆƒ r. Conclusion(r) = J âˆ§ âˆƒ Ï€ âˆˆ Premises(r). Ï€ = âŠ¥

RuleId(r) = id â‡” r is labeled (id)
DiagIdOf(J) = id â‡” âˆƒ r. Conclusion(r) = J âˆ§ RuleId(r) = id
DiagIdOf(J) = âŠ¥ â‡” Â¬ âˆƒ r. Conclusion(r) = J âˆ§ RuleId(r) defined

**(Static-Undefined)**
StaticUndefined(J)    Code(DiagIdOf(J)) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ J â‡‘ c

**(Static-Undefined-NoCode)**
StaticUndefined(J)    Code(DiagIdOf(J)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ J â‡‘

**OutsideConformance.**
If OutsideConformance holds, this specification imposes no requirements on observable behavior, diagnostics, or termination. Implementations MAY exhibit any behavior.

**Static vs. Runtime Checks.**

CheckKind = {PatternExhaustiveness, TypeCompatibility, PermissionViolations, ProvenanceEscape, ArrayBounds, SafePointerValidity, IntegerOverflow, SliceBounds, IntDivisionByZero}

StaticCheck = {PatternExhaustiveness, TypeCompatibility, PermissionViolations, ProvenanceEscape, ArrayBounds, SafePointerValidity}
RuntimeCheck = {IntegerOverflow, SliceBounds, IntDivisionByZero}

RuntimeBehavior(IntegerOverflow) = Panic
RuntimeBehavior(SliceBounds) = Panic
RuntimeBehavior(IntDivisionByZero) = Panic

ResourceExhaustion â‡’ OutsideConformance

**Error Recovery (Cursive0).**
LexRecovery = SkipToNextTokenStart
ParseRecovery = SyncSet({`;`, `}`, `EOF`})
TypeRecovery = ContinueDecls
MaxErrorCount âˆˆ â„• âˆª {âˆž}
SuggestedMaxErrorCount = 100
AbortOnErrorCount(n) â‡” n â‰¥ MaxErrorCount

### 1.3. Authority Model

Cursive0 adopts a **no ambient authority (NAA)** discipline: observable external effects are only possible through explicit possession and use of *capability values*.

This section is a Cursive0 specialization of the root Cursive design (see the root design's authority model). Where the root design references capability classes and factories not present in the Cursive0 subset (e.g., `Network`, `CpuDomainFactory`, `GpuDomainFactory`), those constructs are unsupported in Cursive0 and are rejected per Â§1.4 (via `S0Unsupported`).

#### 1.3.1. Capability universe in Cursive0

Let:

- `CapToken = {FileSystem, HeapAllocator, Reactor, ExecutionDomain, System}`

A *capability-bearing type* is any type that (possibly transitively) contains one or more elements of `CapToken`. In Cursive0, the capability roots are:

- `Context` (provides `fs`, `heap`, `sys`, `reactor`, and domain accessors), and
- the dynamic class object types `$FileSystem`, `$HeapAllocator`, `$Reactor`, `$ExecutionDomain`, and
- `System`.

Define a structural capability extraction function:

- `CapInType : Type â†’ ð’«(CapToken)`

such that (at minimum):

- `CapInType(TypePath(["Context"])) = {FileSystem, HeapAllocator, Reactor, ExecutionDomain, System}`
- `CapInType(TypePath(["System"])) = {System}`
- `CapInType(TypeDynamic(["FileSystem"])) = {FileSystem}`
- `CapInType(TypeDynamic(["HeapAllocator"])) = {HeapAllocator}`
- `CapInType(TypeDynamic(["Reactor"])) = {Reactor}`
- `CapInType(TypeDynamic(["ExecutionDomain"])) = {ExecutionDomain}`
- `CapInType(TypePerm(_, T)) = CapInType(T)`
- `CapInType(TypeTuple(Ts)) = â‹ƒ{CapInType(T) | T âˆˆ Ts}`
- `CapInType(TypeArray(T, _)) = CapInType(T)`
- `CapInType(TypeSlice(T)) = CapInType(T)`
- `CapInType(TypeStruct(_), TypeRecord(_), TypeUnion(_), TypeEnum(_), TypeModalState(_), TypeApply(_), â€¦)` distributes structurally over the immediate component types of the type constructor (after alias expansion).

(Implementations MAY compute `CapInType` by taking the least fixed-point over nominal expansions and alias expansions; cycles are handled by memoization and treating already-visited nominal nodes as contributing `âˆ…` for termination.)

#### 1.3.2. No ambient authority requirements

**(NAA-1) No implicit capability roots.** A conforming implementation MUST NOT provide any implicit/global bindings whose type is capability-bearing (per Â§1.3.1). In particular, there MUST NOT exist built-in top-level values that directly perform file system, allocation, reactor, or scheduling effects without an explicit capability receiver/value.

**(NAA-2) Context as the sole initial root.** The only capability roots introduced by the abstract machine at runtime are those contained in the `Context` value produced by `ContextInitSigma` (see Â§7.7.6) and explicitly passed to the program entry procedure.

**(NAA-3) Effect gating.** Any externally observable effect specified by this document (e.g., file system I/O, raw allocation, reactor scheduling, process exit) MUST occur only as a consequence of calling a capability-gated primitive:
- a built-in procedure that is classified as a runtime host primitive (Â§1.7), or
- a built-in method/procedure whose receiver is a capability value (e.g., `$FileSystem`, `$HeapAllocator`, `$Reactor`, `$ExecutionDomain`, or `System`).

**(NAA-4) Callgraph monotonicity (capability requirement subset property).** Because `closure` and `pipeline` constructs are unsupported in Cursive0 (`S0Unsupported`), call targets in Cursive0 are statically resolvable after name resolution.

Define a procedure-level capability requirement:

- `CapReq(d) = â‹ƒ{CapInType(T_i) | T_i is the type of a parameter (and receiver, if any) of declaration d}`

A program satisfies the capability subset property iff for every direct call from procedure `d_src` to procedure `d_tgt`:

- `CapReq(d_tgt) âŠ† CapReq(d_src)`.

A conforming implementation MUST reject programs that violate this property.

(Informal intuition: a procedure may not call into code that requires capabilities it did not itself explicitly receive, except via explicit capability values passed through its own parameters.)

#### 1.3.3. Attenuation requirements

Some capability-gated operations create *attenuated* (restricted) derived capabilities. In Cursive0, the following operations are attenuation operations:

- `$FileSystem::restrict(root)` produces a file system capability whose authority is limited to the specified rooted subtree (see Â§7.7.1â€“Â§7.7.2 for the rooted model).
- `$HeapAllocator::with_quota(bytes)` produces a heap allocator whose authority is limited by the specified quota (see Â§7.7.5).
- `CancelToken@Active::child()` produces a descendant cancellation token whose cancellation is dominated by the parent (see Â§18.6.1).
- `Context::cpu()`, `Context::gpu()`, and `Context::inline()` produce execution-domain capabilities derived from the context (see Â§5.9.5).

A conforming implementation MUST ensure attenuation is **monotone**: derived capability values MUST NOT grant authority beyond that of the source capability value from which they were derived.

#### 1.3.4. Unsafe and foreign interaction

The no-ambient-authority requirements constrain the *safe* Cursive0 execution model. `unsafe` operations and foreign-function interfaces may allow a program to escape these constraints by design, but capability isolation requirements (see Â§21.3) still apply: capability-bearing values MUST NOT cross the safe/foreign boundary except through the mechanisms explicitly permitted by this specification.

### 1.4. Unsupported Constructs Policy

**UnsupportedConstruct.**
UnsupportedConstruct = âˆ…

UnsupportedForm = UnsupportedConstruct âˆª S0Unsupported âˆª UnsupportedGrammarFamily âˆª ComptimeForm

**(Unsupported-Construct)**
f âˆˆ UnsupportedForm
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(Code(Unsupported-Construct))

### 1.5. Target and ABI Assumptions

TargetArch = Win64
Endianness = Little
PtrSizeBytes = PtrSize
LayoutSpec = RulesIn({"6.1.1", "6.1.2", "6.1.3", "6.1.4", "6.1.5", "6.1.6"})

Target = "x86_64-pc-windows-msvc"
Win64 = Target

### 1.6. Diagnostics Infrastructure

#### 1.6.1. Source Locations and Spans

**SourceLocation.**

SourceLocation = âŸ¨file, offset, line, columnâŸ©

**Span.**

Span = âŸ¨file, start_offset, end_offset, start_line, start_col, end_line, end_colâŸ©

SpanRange(sp) = [sp.start_offset, sp.end_offset)

**(WF-Location)**
0 â‰¤ o    Î“ âŠ¢ Locate(S, o) â‡“ â„“_loc
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ â„“_loc : LocationOk

**(WF-Span)**
0 â‰¤ s â‰¤ e â‰¤ S.byte_len    Î“ âŠ¢ Locate(S, s) â‡“ â„“_s    Î“ âŠ¢ Locate(S, e) â‡“ â„“_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ âŸ¨S.path, s, e, â„“_s.line, â„“_s.column, â„“_e.line, â„“_e.columnâŸ© : SpanOk

**Span Construction**

ClampSpan(S, s, e) = (s', e')
s' = min(s, S.byte_len)
e' = min(max(e, s'), S.byte_len)

**(Span-Of)**
Î“ âŠ¢ ClampSpan(S, s, e) â‡“ (s', e')    Î“ âŠ¢ âŸ¨S.path, s', e', line_s, col_s, line_e, col_eâŸ© : SpanOk
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SpanOf(S, s, e) â‡“ âŸ¨S.path, s', e', line_s, col_s, line_e, col_eâŸ©

#### 1.6.2. Token Spans

**TokenKind.**

TokenKind_C0 = TokenKind_(Â§ 3.2.4) âˆª {Unknown}

**(No-Unknown-Ok)**
âˆ€ t âˆˆ K. t.kind â‰  Unknown
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ K : TokenStreamOk

**RawToken.**

RawToken = âŸ¨kind, lexeme, s, eâŸ©

**Token.**

Token = âŸ¨kind, lexeme, spanâŸ©

**(Attach-Token-Ok)**
Î“ âŠ¢ SpanOf(S, s, e) â‡“ sp
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttachSpan(S, âŸ¨k, â„“, s, eâŸ©) â‡“ âŸ¨k, â„“, spâŸ©

**Token Stream Attachment (BigÃ¢â‚¬â€˜Step)**

**(Attach-Tokens-Ok)**
âˆ€ r âˆˆ rs, Î“ âŠ¢ AttachSpan(S, r) â‡“ t    ts = [t | r âˆˆ rs]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttachSpans(S, rs) â‡“ ts

#### 1.6.3. Diagnostics: Records and Emission

**Diagnostic.**

Severity = {Error, Warning}

**Diagnostic Stream.**
Î” = [d_1, â€¦, d_n]

**(Emit-Append)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(Î”, d) â‡“ (Î” ++ [d])

**Emit (Implicit).**
Emit(c) = Emit(Î”, âŸ¨c, Severity(c), Message(c), âŠ¥âŸ©)
Emit(c, sp) = Emit(Î”, âŸ¨c, Severity(c), Message(c), spâŸ©)

Severity(c) = SeverityColumn(c)
Message(c) = ConditionColumn(c)

CompileStatus(Î”) =
 fail  if HasError(Î”)
 ok    otherwise

#### 1.6.4. Diagnostic Code Selection

SpecCode : DiagId â‡€ DiagCode
SpecCode(id) = âŠ¥
C0Code : DiagId â‡€ DiagCode

**(Code-Spec)**
SpecCode(id) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Code(id) â‡“ c

**(Code-C0)**
SpecCode(id) = âŠ¥    C0Code(id) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Code(id) â‡“ c

**DiagIdÃ¢â‚¬â€œCode Mapping.**
id emits a diagnostic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(Code(id))
â‡‘ â‰¡ â‡‘ Code(id)

**Resolution Failure.**
NoDiag(â†‘)

#### 1.6.5. Diagnostic Ordering

**(Order)**
Î” = [d_1, d_2, â€¦, d_n]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Order(Î”) â‡“ [d_1, d_2, â€¦, d_n]

#### 1.6.6. Diagnostic Rendering

Render(d) =
 code ++ " (" ++ sev ++ ")" ++ msg ++ " @" ++ loc  if d.span â‰  âŠ¥
 code ++ " (" ++ sev ++ ")" ++ msg                if d.span = âŠ¥

code = d.code
sev =
 "error"   if d.severity = Error
 "warning" if d.severity = Warning
msg =
 "\""      if d.message = "\""
 ": " ++ d.message  otherwise
loc = d.span.file ++ ":" ++ d.span.start_line ++ ":" ++ d.span.start_col
PermLexeme(const) = "const"
PermLexeme(unique) = "unique"
PermLexeme(shared) = "shared"
QualLexeme(imm) = "imm"
QualLexeme(mut) = "mut"
PtrStateSuffix(âŠ¥) = ""
PtrStateSuffix(Valid) = "@Valid"
PtrStateSuffix(Null) = "@Null"
PtrStateSuffix(Expired) = "@Expired"
StringStateSuffix(âŠ¥) = ""
StringStateSuffix(View) = "@View"
StringStateSuffix(Managed) = "@Managed"
BytesStateSuffix(âŠ¥) = ""
BytesStateSuffix(View) = "@View"
BytesStateSuffix(Managed) = "@Managed"
ParamRender(âŸ¨âŠ¥, TâŸ©) = TypeRender(T)
ParamRender(âŸ¨move, TâŸ©) = "move " ++ TypeRender(T)
TypeRender(TypePrim(name)) = name
TypeRender(TypeRange) = "TypeRange"
TypeRender(TypePerm(p, T)) = PermLexeme(p) ++ " " ++ TypeRender(T)
TypeRender(TypeUnion([T_1, â€¦, T_n])) = Join(" | ", [TypeRender(T_1), â€¦, TypeRender(T_n)])
TypeRender(TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)) = "(" ++ Join(", ", [ParamRender(âŸ¨m_1, T_1âŸ©), â€¦, ParamRender(âŸ¨m_n, T_nâŸ©)]) ++ ") -> " ++ TypeRender(R)
TypeRender(TypeTuple([])) = "()"
TypeRender(TypeTuple([T])) = "(" ++ TypeRender(T) ++ ";)"
TypeRender(TypeTuple([T_1, â€¦, T_n])) = "(" ++ Join(", ", [TypeRender(T_1), â€¦, TypeRender(T_n)]) ++ ")"
TypeRender(TypeArray(T, e)) = "[" ++ TypeRender(T) ++ "; " ++ ArrayLen(e) ++ "]"
TypeRender(TypeSlice(T)) = "[" ++ TypeRender(T) ++ "]"
TypeRender(TypePtr(T, s)) = "Ptr<" ++ TypeRender(T) ++ ">" ++ PtrStateSuffix(s)
TypeRender(TypeRawPtr(q, T)) = "* " ++ QualLexeme(q) ++ " " ++ TypeRender(T)
TypeRender(TypeString(st)) = "string" ++ StringStateSuffix(st)
TypeRender(TypeBytes(st)) = "bytes" ++ BytesStateSuffix(st)
TypeRender(TypeDynamic(p)) = "$" ++ StringOfPath(p)
TypeRender(TypeApply(p, args)) = StringOfPath(p) ++ "<" ++ Join(", ", [TypeRender(a) | a âˆˆ args]) ++ ">"
TypeRender(TypeModalState(modal_ref, S)) = ModalRefRender(modal_ref) ++ "@" ++ S
TypeRender(TypePath(p)) = StringOfPath(p)
ModalRefRender(TypePath(p)) = StringOfPath(p)
ModalRefRender(TypeApply(p, args)) = StringOfPath(p) ++ "<" ++ Join(", ", [TypeRender(a) | a âˆˆ args]) ++ ">"

#### 1.6.7. Diagnostics without Source Spans

**(NoSpan-External)**
Origin(d) = External
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ d.span = âŠ¥

### 1.7. Host Primitives

FSPrim = {FSOpenRead, FSOpenWrite, FSOpenAppend, FSCreateWrite, FSReadFile, FSReadBytes, FSWriteFile, FSWriteStdout, FSWriteStderr, FSExists, FSRemove, FSOpenDir, FSCreateDir, FSEnsureDir, FSKind, FSRestrict}
FilePrim = {FileReadAll, FileReadAllBytes, FileWrite, FileFlush, FileClose}
DirPrim = {DirNext, DirClose}

SystemPrim = {SystemGetEnv, SystemExit}
HeapPrim = {HeapWithQuota, HeapAllocRaw, HeapDeallocRaw}
ReactorPrim = {ReactorRun, ReactorRegister}
CancelPrim = {CancelNew, CancelChild, CancelDoCancel, CancelIsCancelled, CancelWaitCancelled}

HostPrim = {ParseTOML, ReadBytes, WriteFile, ResolveTool, ResolveRuntimeLib, Invoke, AssembleIR, InvokeLinker} âˆª FSPrim âˆª FilePrim âˆª DirPrim âˆª SystemPrim âˆª HeapPrim âˆª ReactorPrim âˆª CancelPrim
HostPrimDiag = {ParseTOML, ReadBytes, WriteFile, ResolveTool, ResolveRuntimeLib, Invoke, AssembleIR, InvokeLinker}
HostPrimRuntime = FSPrim âˆª FilePrim âˆª DirPrim âˆª SystemPrim âˆª HeapPrim âˆª ReactorPrim âˆª CancelPrim
MapsToDiagOrRuntime(p) â‡” p âˆˆ HostPrimDiag âˆª HostPrimRuntime
HostPrimFail(p) â‡” p âˆˆ HostPrim âˆ§ âˆƒ args. Î“ âŠ¢ p(args) â‡‘

HostPrimFail(p) âˆ§ Â¬ MapsToDiagOrRuntime(p) â‡’ IllFormed(p)

## 2. Phase 0: Build/Project Model

**Assembly Kind.**
AssemblyKind = {`executable`, `library`}

**Assembly Record.**
Assembly = âŸ¨name, kind, root, out_dir, emit_ir, source_root, outputs, modulesâŸ©

**Project Record.**
Project = âŸ¨root, assemblies, assembly, source_root, outputs, modulesâŸ©
Assemblies(P) = P.assemblies
Assembly(P) = P.assembly
AsmNames(P) = [A.name | A âˆˆ Assemblies(P)]
AsmByName(P, n) = A â‡” A âˆˆ Assemblies(P) âˆ§ A.name = n âˆ§ (âˆ€ B âˆˆ Assemblies(P). B.name = n â‡’ B = A)

**Build/Project Validation Scope.**
Phase0Checks = RulesIn({"2"})
SourceChecks = RulesIn({"3", "4", "5", "6"})
Phase0Checks âˆ© SourceChecks = âˆ…

**Command-Line Output.**
DumpProject(P, dump) =
 ProjectSummary(P) ++ OutputSummary(P)  if dump = false
 ProjectSummary(P) ++ OutputSummary(P) ++ ["file:" ++ f | d âˆˆ Modules(P.source_root), f âˆˆ CompilationUnit(d)]  if dump = true

ProjectSummary(P) = [âŸ¨`project_root`, P.rootâŸ©, âŸ¨`assemblies`, AsmNames(P)âŸ©, âŸ¨`assembly_name`, P.assembly.nameâŸ©, âŸ¨`source_root`, P.source_rootâŸ©, âŸ¨`output_root`, OutputRoot(P)âŸ©, âŸ¨`module_list`, ModuleList(P)âŸ©]

OutputSummary(P) = [âŸ¨`module`, m, `obj`, ObjPath(P, m), `ir`, IROpt(P, m)âŸ© | m âˆˆ ModuleList(P)]

IROpt(P, m) =
 IRPath(P, m, P.assembly.emit_ir)  if P.assembly.emit_ir â‰  `none`
 âŠ¥                                if P.assembly.emit_ir = `none`

### 2.1. Project Root and Manifest

**Manifest Parsing (Big-Step)**

ParseTOML : Path â‡€ TOMLTable

**(Parse-Manifest-Ok)**
ParseTOML(R/`Cursive.toml`) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseManifest(R) â‡“ T

**(Parse-Manifest-Missing)**
Â¬ exists(R/`Cursive.toml`)    c = Code(Parse-Manifest-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseManifest(R) â‡‘ c

**(Parse-Manifest-Err)**
ParseTOML(R/`Cursive.toml`) â‡‘    c = Code(Parse-Manifest-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseManifest(R) â‡‘ c

**Manifest Required (No Single-File Fallback).**
If Î“ âŠ¢ ParseManifest(R) â‡‘ c, then Î“ âŠ¢ LoadProject(R, target) â‡‘ c and the implementation MUST NOT attempt any single-file or heuristic fallback project construction.

**Manifest Path Resolution.**
Manifest lookup MUST use host filesystem path resolution semantics for R/`Cursive.toml` and MUST NOT perform additional case verification.

**Manifest Schema (Cursive0)**

n = t.name
k = t.kind
r = t.root
o = t.out_dir
e = t.emit_ir

**(WF-Assembly-Name)**
Î“ âŠ¢ n : Identifier    Î“ âŠ¢ n : NotKeyword
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : Name

**(WF-Assembly-Name-Err)**
Â¬(Î“ âŠ¢ n : Identifier âˆ§ Î“ âŠ¢ n : NotKeyword)    c = Code(WF-Assembly-Name-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ n : Name â‡‘ c

**(WF-Assembly-Kind)**
k âˆˆ AssemblyKind
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ k : Kind

**(WF-Assembly-Kind-Err)**
k âˆ‰ AssemblyKind    c = Code(WF-Assembly-Kind-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ k : Kind â‡‘ c

**(WF-Assembly-Root-Path)**
Î“ âŠ¢ r : RelPath
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ r : RootPath

**(WF-Assembly-Root-Path-Err)**
Â¬(Î“ âŠ¢ r : RelPath)    c = Code(WF-Assembly-Root-Path-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ r : RootPath â‡‘ c

**(WF-Assembly-OutDir-Path)**
o = âŠ¥ âˆ¨ Î“ âŠ¢ o : RelPath
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ o : OutDirPath

**(WF-Assembly-OutDir-Path-Err)**
o â‰  âŠ¥    Â¬(Î“ âŠ¢ o : RelPath)    c = Code(WF-Assembly-OutDir-Path-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ o : OutDirPath â‡‘ c

**(WF-Assembly-EmitIR)**
e âˆˆ {âŠ¥, `none`, `ll`, `bc`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : EmitIR

**(WF-Assembly-EmitIR-Err)**
e âˆ‰ {âŠ¥, `none`, `ll`, `bc`}    c = Code(WF-Assembly-EmitIR-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : EmitIR â‡‘ c

**Manifest Validation (Big-Step)**

Keys(T) = Dom(T)
AsmField(T) = T[`assembly`]
AsmTables(T) =
 [AsmField(T)]  if IsTable(AsmField(T))
 AsmField(T)    if IsArrayTable(AsmField(T))
 âŠ¥              otherwise

**(WF-TopKeys)**
Keys(T) âŠ† {`assembly`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : TopKeys

**(WF-TopKeys-Err)**
Â¬(Keys(T) âŠ† {`assembly`})    c = Code(WF-TopKeys-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : TopKeys â‡‘ c

**(WF-Assembly-Table)**
AsmTables(T) â‰  âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyTable

**(WF-Assembly-Table-Err)**
AsmTables(T) = âŠ¥    c = Code(WF-Assembly-Table-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyTable â‡‘ c

**(WF-Assembly-Count)**
AsmTables(T) = Ts    |Ts| â‰¥ 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyCount

**(WF-Assembly-Count-Err)**
AsmTables(T) = Ts    |Ts| = 0    c = Code(WF-Assembly-Count-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyCount â‡‘ c

**(WF-Assembly-Name-Dup)**
AsmTables(T) = Ts    Distinct([t.name | t âˆˆ Ts])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyNames

**(WF-Assembly-Name-Dup-Err)**
AsmTables(T) = Ts    Â¬ Distinct([t.name | t âˆˆ Ts])    c = Code(WF-Assembly-Name-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : AssemblyNames â‡‘ c

Req = {`name`, `kind`, `root`}
Opt = {`out_dir`, `emit_ir`}

**(WF-Assembly-Keys)**
Keys(t) âŠ† (Req âˆª Opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : KnownKeys

**(WF-Assembly-Keys-Err)**
Â¬(Keys(t) âŠ† (Req âˆª Opt))    c = Code(WF-Assembly-Keys-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : KnownKeys â‡‘ c

**(WF-Assembly-Required-Types)**
âˆ€ k âˆˆ Req. IsString(t[k])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : ReqTypes

**(WF-Assembly-Required-Types-Err)**
âˆƒ k âˆˆ Req. t[k] = âŠ¥ âˆ¨ Â¬ IsString(t[k])    c = Code(WF-Assembly-Required-Types-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : ReqTypes â‡‘ c

**(WF-Assembly-Optional-Types)**
t[`out_dir`] âˆˆ {string, âŠ¥}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : OutDirType

**(WF-Assembly-OutDirType-Err)**
t[`out_dir`] âˆ‰ {string, âŠ¥}    c = Code(WF-Assembly-OutDirType-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : OutDirType â‡‘ c

t[`emit_ir`] âˆˆ {string, âŠ¥}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : EmitIRType

**(WF-Assembly-EmitIRType-Err)**
t[`emit_ir`] âˆ‰ {string, âŠ¥}    c = Code(WF-Assembly-EmitIRType-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ t : EmitIRType â‡‘ c

**Path Resolution**
WinSep = {"\\", "/"}
AsciiLetter(c) â‡” (c âˆˆ {"A", â€¦, "Z"} âˆ¨ c âˆˆ {"a", â€¦, "z"})
DriveRooted(p) â‡” |p| â‰¥ 3 âˆ§ AsciiLetter(At(p, 0)) âˆ§ At(p, 1) = ":" âˆ§ At(p, 2) âˆˆ WinSep
UNC(p) â‡” StartsWith(p, "//") âˆ¨ StartsWith(p, "\\\\")
RootRelative(p) â‡” (StartsWith(p, "/") âˆ¨ StartsWith(p, "\\")) âˆ§ Â¬ UNC(p) âˆ§ Â¬ DriveRooted(p)
RootTag(p) =
 p[0..2)  if DriveRooted(p)
 "//"     if UNC(p)
 "/"      if RootRelative(p)
 "\""     otherwise
Tail(p) =
 p[3..|p|)  if DriveRooted(p)
 p[2..|p|)  if UNC(p)
 p[1..|p|)  if RootRelative(p)
 p         otherwise
Segs(p) = [ p[i..j) | 0 â‰¤ i < j â‰¤ |p| âˆ§ (âˆ€ k âˆˆ [i, j). At(p, k) âˆ‰ WinSep) âˆ§ (i = 0 âˆ¨ At(p, i-1) âˆˆ WinSep) âˆ§ (j = |p| âˆ¨ At(p, j) âˆˆ WinSep) ]
PathComps(p) =
 Segs(p)  if RootTag(p) = "\""
 [RootTag(p)] ++ Segs(Tail(p))  otherwise
JoinComp([]) = "\""
JoinComp([c]) = c
JoinComp(c::cs) =
 c ++ JoinComp(cs)          if c âˆˆ {"/", "//"}
 c ++ "/" ++ JoinComp(cs)   if DriveRooted(c ++ "/")
 c ++ "/" ++ JoinComp(cs)   otherwise
Join(a, b) =
 b  if AbsPath(b)
 JoinComp(PathComps(a) ++ PathComps(b))  otherwise

AbsPath(p) â‡” DriveRooted(p) âˆ¨ UNC(p) âˆ¨ RootRelative(p)
is_relative(p) â‡” Â¬ AbsPath(p)
Join : Path Ã— Path â†’ Path
Normalize : Path â†’ Path
Canon : Path â‡€ Path
prefix(p, q) â‡” PathPrefix(PathComps(q), PathComps(p))
Normalize(p) = JoinComp([ c | c âˆˆ PathComps(p) âˆ§ c â‰  "." ])
Canon(p) = âŠ¥ â‡” âˆƒ c âˆˆ PathComps(Normalize(p)). c = ".."
Canon(p) = Normalize(p) â‡” Â¬ âˆƒ c âˆˆ PathComps(Normalize(p)). c = ".."
Drop(0, xs) = xs    Drop(n, []) = []    Drop(n, x::xs) = Drop(n-1, xs) (n > 0)
relative(p, base) = rel â‡” Canon(p) = p' âˆ§ Canon(base) = b' âˆ§ PathPrefix(PathComps(b'), PathComps(p')) âˆ§ rel = JoinComp(Drop(|PathComps(b')|, PathComps(p')))
Basename(p) =
 "\""  if |PathComps(p)| = 0
 last(PathComps(p))  otherwise
last([x]) = x    last(x::xs) = last(xs) (|xs| > 0)

b = Basename(p)
D = { j | 0 â‰¤ j < |b| âˆ§ b[j] = "." }
FileExt(p) =
 "\""  if D = âˆ…
 "\""  if D â‰  âˆ… âˆ§ max(D) = 0
 b[max(D)..|b|)  if D â‰  âˆ… âˆ§ max(D) > 0

**(Resolve-Canonical)**
p' = Normalize(Join(R, p))    Canon(R) = R'    Canon(p') = p''
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Resolve(R, p) â‡“ (R', p'')

**(Resolve-Canonical-Err)**
p' = Normalize(Join(R, p))    (Canon(R) = âŠ¥ âˆ¨ Canon(p') = âŠ¥)    c = Code(Resolve-Canonical-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Resolve(R, p) â‡‘ c

**(WF-RelPath)**
is_relative(p)    Î“ âŠ¢ Resolve(R, p) â‡“ (R', p'')    prefix(p'', R')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : RelPath

**(WF-RelPath-Err)**
Â¬ is_relative(p) âˆ¨ (Î“ âŠ¢ Resolve(R, p) â‡“ (R', p'') âˆ§ Â¬ prefix(p'', R'))    c = Code(WF-RelPath-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : RelPath â‡‘ c

Project(Î“) = P â‡” Î“.project = P

**Project Load (Small-Step)**

AssemblyTarget = Name âˆª {âŠ¥}
ProjLoadState = {Start(R, target), Parsed(R, target, T), Validated(R, target, T), ProjAsmScan(R, target, T, Ts, As), Discovered(P), Error(code)}

**(Step-Parse)**
Î“ âŠ¢ ParseManifest(R) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Start(R, target)âŸ© â†’ âŸ¨Parsed(R, target, T)âŸ©

**(Step-Parse-Err)**
Î“ âŠ¢ ParseManifest(R) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Start(R, target)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Step-Validate)**
Î“ âŠ¢ ValidateManifest(T) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Parsed(R, target, T)âŸ© â†’ âŸ¨Validated(R, target, T)âŸ©

**(Step-Validate-Err)**
Î“ âŠ¢ ValidateManifest(T) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Parsed(R, target, T)âŸ© â†’ âŸ¨Error(c)âŸ©

**Manifest Validation (Deterministic).**

ChecksAsm(t) = [Î“ âŠ¢ t : KnownKeys, Î“ âŠ¢ t : ReqTypes, Î“ âŠ¢ t : OutDirType, Î“ âŠ¢ t : EmitIRType, Î“ âŠ¢ t.name : Name, Î“ âŠ¢ t.kind : Kind, Î“ âŠ¢ t.emit_ir : EmitIR, Î“ âŠ¢ t.root : RootPath, Î“ âŠ¢ t.out_dir : OutDirPath]
BaseChecks(T) = [Î“ âŠ¢ T : TopKeys, Î“ âŠ¢ T : AssemblyTable, Î“ âŠ¢ T : AssemblyCount, Î“ âŠ¢ T : AssemblyNames]
AsmChecks(T) =
 []  if AsmTables(T) = âŠ¥
 ++_{t âˆˆ AsmTables(T)} ChecksAsm(t)  otherwise
Checks(T) = BaseChecks(T) ++ AsmChecks(T)

FirstFail([]) = âŠ¥
FirstFail(J::Js) = c â‡” Î“ âŠ¢ J â‡‘ c
FirstFail(J::Js) = FirstFail(Js) â‡” Î“ âŠ¢ J â‡“ ok

**(ValidateManifest-Ok)**
FirstFail(Checks(T)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateManifest(T) â‡“ ok

**(ValidateManifest-Err)**
FirstFail(Checks(T)) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateManifest(T) â‡‘ c

**(Step-Asm-Init)**
Ts = AsmTables(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Validated(R, target, T)âŸ© â†’ âŸ¨ProjAsmScan(R, target, T, Ts, [])âŸ©

**(Step-Asm-Cons)**
Î“ âŠ¢ BuildAssembly(R, t_0) â‡“ A
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ProjAsmScan(R, target, T, t_0::ts, As)âŸ© â†’ âŸ¨ProjAsmScan(R, target, T, ts, As ++ [A])âŸ©

**(Step-Asm-Err)**
Î“ âŠ¢ BuildAssembly(R, t_0) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ProjAsmScan(R, target, T, t_0::ts, As)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Step-Asm-Done)**
Î“ âŠ¢ SelectAssembly(As, target) â‡“ A_0    P = âŸ¨root = R, assemblies = As, assembly = A_0, source_root = A_0.source_root, outputs = A_0.outputs, modules = A_0.modulesâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ProjAsmScan(R, target, T, [], As)âŸ© â†’ âŸ¨Discovered(P)âŸ©

**(Step-Asm-Done-Err)**
Î“ âŠ¢ SelectAssembly(As, target) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ProjAsmScan(R, target, T, [], As)âŸ© â†’ âŸ¨Error(c)âŸ©

**Assembly Selection**

**(Select-Only)**
|As| = 1    target = âŠ¥    As = [A_0]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SelectAssembly(As, target) â‡“ A_0

**(Select-By-Name)**
target â‰  âŠ¥    A âˆˆ As    A.name = target
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SelectAssembly(As, target) â‡“ A

**(Select-Err)**
(target = âŠ¥ âˆ§ |As| â‰  1) âˆ¨ (target â‰  âŠ¥ âˆ§ Â¬ âˆƒ A âˆˆ As. A.name = target)    c = Code(Assembly-Select-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SelectAssembly(As, target) â‡‘ c

**Assembly Build (Big-Step)**

**(BuildAssembly-Ok)**
Î“ âŠ¢ Resolve(R, t.root) â‡“ (R', S)    Î“ âŠ¢ S : SourceRoot    Î“ âŠ¢ Modules(S, t.name) â‡“ M    L = sort_{â‰º_mod}(M)    A = âŸ¨name = t.name, kind = t.kind, root = t.root, out_dir = t.out_dir, emit_ir = t.emit_ir, source_root = S, outputs = OutputPaths(R, t), modules = LâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuildAssembly(R, t) â‡“ A

**(BuildAssembly-Err-Resolve)**
Î“ âŠ¢ Resolve(R, t.root) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuildAssembly(R, t) â‡‘ c

**(BuildAssembly-Err-Root)**
Î“ âŠ¢ Resolve(R, t.root) â‡“ (R', S)    Î“ âŠ¢ S : SourceRoot â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuildAssembly(R, t) â‡‘ c

**(BuildAssembly-Err-Modules)**
Î“ âŠ¢ Resolve(R, t.root) â‡“ (R', S)    Î“ âŠ¢ S : SourceRoot    Î“ âŠ¢ Modules(S, t.name) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuildAssembly(R, t) â‡‘ c

**Project Load (Big-Step)**

**(LoadProject-Ok)**
Î“ âŠ¢ ParseManifest(R) â‡“ T    Î“ âŠ¢ ValidateManifest(T) â‡“ ok    AsmTables(T) = [t_1, â€¦, t_n]    âˆ€ i, Î“ âŠ¢ BuildAssembly(R, t_i) â‡“ A_i    As = [A_1, â€¦, A_n]    Î“ âŠ¢ SelectAssembly(As, target) â‡“ A_0    P = âŸ¨root = R, assemblies = As, assembly = A_0, source_root = A_0.source_root, outputs = A_0.outputs, modules = A_0.modulesâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoadProject(R, target) â‡“ P

**(LoadProject-Err)**
Î“ âŠ¢ LoadProject(R, target) â†’* âŸ¨Error(c)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoadProject(R, target) â‡‘ c

**Well-Formed Project Root**

**(WF-Project-Root)**
exists(`Cursive.toml` at R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŠ¢ R : ProjectRoot

### 2.2. Assemblies

A_0.kind âˆˆ AssemblyKind
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ A_0 : Assembly


### 2.3. Deterministic Ordering and Case Folding

#### 2.3.1. Module File Processing Order
FoldPath(r) = JoinComp([CaseFold(NFC(c)) | c âˆˆ PathComps(r)])

FileKey(f, d) =
 âŸ¨FoldPath(rel), relâŸ©  if relative(f, d) â‡“ rel
 âŸ¨âŠ¥, Basename(f)âŸ©      if relative(f, d) â‡‘

f_1 â‰º_file f_2 â‡” Utf8LexLess(FileKey(f_1, d), FileKey(f_2, d))

**(FileOrder-Rel-Fail)**
relative(f, d) â‡‘    c = Code(FileOrder-Rel-Fail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

#### 2.3.2. Module Path Case-Folding Algorithm

**Fold.**
Fold(p) = [CaseFold(NFC(c)) | c âˆˆ p]

#### 2.3.3. Directory Enumeration Order

DirKey(d, S) =
 âŸ¨FoldPath(rel), relâŸ©  if relative(d, S) â‡“ rel
 âŸ¨âŠ¥, Basename(d)âŸ©      if relative(d, S) â‡‘

d_1 â‰º_dir d_2 â‡” Utf8LexLess(DirKey(d_1, S), DirKey(d_2, S))

DirSeq(S) = sort_{â‰º_dir}(Dirs(S))

**(DirSeq-Read-Err)**
Dirs(S) â‡‘    c = Code(DirSeq-Read-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

**(DirSeq-Rel-Fail)**
relative(d, S) â‡‘    c = Code(DirSeq-Rel-Fail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

### 2.4. Module Discovery

**Dirs.**
Dirs(S) = { d | is_dir(d) âˆ§ relative(d, S) â‡“ r }
S âˆˆ Dirs(S)

**(WF-Source-Root)**
is_dir(S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S : SourceRoot

**(WF-Source-Root-Err)**
Â¬ is_dir(S)    c = Code(WF-Source-Root-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S : SourceRoot â‡‘ c

**(Module-Dir)**
âˆƒ f âˆˆ Files(d) : FileExt(f) = ".cursive"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ d : ModuleDir

Modules(S) = { d âˆˆ Dirs(S) | Î“ âŠ¢ d : ModuleDir }

**Module Discovery (Big-Step)**

**(Modules-Ok)**
âŸ¨DiscStart(S, A)âŸ© â†’* âŸ¨DiscDone(M)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Modules(S, A) â‡“ M

**(Modules-Err)**
âŸ¨DiscStart(S, A)âŸ© â†’* âŸ¨Error(c)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Modules(S, A) â‡‘ c

Files(d) = { f | f âˆˆ d âˆ§ FileExt(f) = ".cursive" }

CompilationUnit(d) = sort_{â‰º_file}(Files(d))

**(CompilationUnit-Rel-Fail)**
âˆƒ f âˆˆ Files(d). relative(f, d) â‡‘    c = Code(FileOrder-Rel-Fail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CompilationUnit(d) â‡‘ c


**Module Path.**

**(Module-Path-Root)**
relative(d, S) = Îµ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModulePath(d, S, A) = A

**(Module-Path-Rel)**
relative(d, S) = c_1 / â€¦ / c_n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModulePath(d, S, A) = c_1 :: â€¦ :: c_n

**(Module-Path-Rel-Fail)**
relative(d, S) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModulePath(d, S, A) â‡‘

WFModulePathJudg = {WF-Module-Path}

**(WF-Module-Path-Ok)**
âˆ€ comp âˆˆ p, (Î“ âŠ¢ comp : Identifier) âˆ§ Â¬ Keyword(comp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WF-Module-Path(p) â‡“ ok

**(WF-Module-Path-Reserved)**
âˆƒ comp âˆˆ p. Keyword(comp)    c = Code(WF-Module-Path-Reserved)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WF-Module-Path(p) â‡‘ c

**(WF-Module-Path-Ident-Err)**
âˆƒ comp âˆˆ p. Â¬(Î“ âŠ¢ comp : Identifier)    c = Code(WF-Module-Path-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WF-Module-Path(p) â‡‘ c

**(WF-Module-Path-Collision)**
p_1 â‰  p_2    Fold(p_1) = Fold(p_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(Code(WF-Module-Path-Collision))    Î“ âŠ¢ Emit(W-MOD-1101, âŠ¥)

**Module Discovery (Small-Step)**
DiscState = {DiscStart(S, A), DiscScan(S, A, Pending, M, Seen), DiscDone(M), Error(code)}

**(Disc-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscStart(S, A)âŸ© â†’ âŸ¨DiscScan(S, A, DirSeq(S), [], âˆ…)âŸ©

**(Disc-Skip)**
Î“ âŠ¬ d : ModuleDir
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, d::ds, M, Seen)âŸ© â†’ âŸ¨DiscScan(S, A, ds, M, Seen)âŸ©

**(Disc-Add)**
Î“ âŠ¢ d : ModuleDir    Î“ âŠ¢ ModulePath(d, S, A) = p    Î“ âŠ¢ WF-Module-Path(p) â‡“ ok    Fold(p) âˆ‰ dom(Seen)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, d::ds, M, Seen)âŸ© â†’ âŸ¨DiscScan(S, A, ds, M ++ [p], Seen âˆª {Fold(p) â†¦ p})âŸ©

**(Disc-Collision)**
Î“ âŠ¢ d : ModuleDir    Î“ âŠ¢ ModulePath(d, S, A) = p    Î“ âŠ¢ WF-Module-Path(p) â‡“ ok    Fold(p) âˆˆ dom(Seen)    Seen[Fold(p)] â‰  p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, d::ds, M, Seen)âŸ© â†’ âŸ¨Error(Code(Disc-Collision))âŸ©

**(Disc-Invalid-Component)**
Î“ âŠ¢ d : ModuleDir    Î“ âŠ¢ ModulePath(d, S, A) = p    Î“ âŠ¢ WF-Module-Path(p) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, d::ds, M, Seen)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Disc-Rel-Fail)**
Î“ âŠ¢ d : ModuleDir    relative(d, S) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, d::ds, M, Seen)âŸ© â†’ âŸ¨Error(Code(Disc-Rel-Fail))âŸ©

**(Disc-Done)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨DiscScan(S, A, [], M, Seen)âŸ© â†’ âŸ¨DiscDone(M)âŸ©

### 2.5. Output Artifacts and Linking

**Output Root.**

O = OutputRoot(P) =
 P.root/P.assembly.out_dir  if provided
 P.root/`build`             otherwise

**Output Hygiene (Cursive0).**
OutputHygiene(P) â‡” âˆ€ p âˆˆ RequiredOutputs(P). Under(p, OutputRoot(P))

OutputPaths(R, A).root =
 R/A.out_dir  if provided
 R/`build`    otherwise
OutputPaths(R, A).obj_dir = OutputPaths(R, A).root/`obj`
OutputPaths(R, A).ir_dir = OutputPaths(R, A).root/`ir`
OutputPaths(R, A).bin_dir = OutputPaths(R, A).root/`bin`

P.outputs = P.assembly.outputs

**Object File Naming**

PathToPrefix(s) = Concat([BMap(b) | b âˆˆ Utf8(NFC(s))])
BMap(b) =
 chr(b)           if b âˆˆ [0-9A-Za-z]
 "_x" ++ Hex2(b)  otherwise

mangle(s) = PathToPrefix(s)
MangleModulePath(p) = mangle(PathString(PathKey(p)))

obj(m) = O / `obj` / (MangleModulePath(p) ++ ".obj")

**Executable Naming**

exe = O / `bin` / (assembly_name ++ ".exe")

**Output and Linking Semantics (Formal Rules)**

path(m) = m.path
S = P.source_root

**Module Emission Order.**

m_1 â‰º_mod m_2 â‡” Utf8LexLess(Fold(path(m_1)), Fold(path(m_2))) âˆ¨ (Fold(path(m_1)) = Fold(path(m_2)) âˆ§ Utf8LexLess(path(m_1), path(m_2)))

Utf8LexLess(a, b) â‡” LexBytes(Utf8(a), Utf8(b))

**(ModuleList-Ok)**
Î“ âŠ¢ Modules(S, P.assembly.name) â‡“ M    L = sort_{â‰º_mod}(M)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModuleList(P) â‡“ L

**(ModuleList-Err)**
Î“ âŠ¢ Modules(S, P.assembly.name) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModuleList(P) â‡‘ c

**Output Paths.**
O = OutputRoot(P)
assembly_name = P.assembly.name
ext(e) =
 ".ll"  if e = `ll`
 ".bc"  if e = `bc`

ObjPath(P, m) = O / `obj` / (MangleModulePath(path(m)) ++ ".obj")
IRPath(P, m, e) = O / `ir` / (MangleModulePath(path(m)) ++ ext(e))
ExePath(P) =
 O / `bin` / (assembly_name ++ ".exe")  if Executable(P)
 âŠ¥                                     otherwise

ObjPaths(P, ms) = [ObjPath(P, m) | m âˆˆ ms]
IRPaths(P, ms, e) = [IRPath(P, m, e) | m âˆˆ ms]

**Module Index and Symbol Name.**
ModuleList(P) = [m_1, â€¦, m_n]
Index(P, m_i) = i
pad4(i) = PadLeft(Decimal(i), '0', 4)
SymbolName(P, m) =
 "main"  if path(m) = P.assembly.name
 "mod" ++ pad4(Index(P, m))  otherwise

trunc8(s) = PadRight(Take(Utf8(s), 8), 8, 0x00)

**LLVM Target Constants.**
LLVMTriple = "x86_64-pc-windows-msvc"
LLVMDataLayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

IsRootModule(P, m) â‡” path(m) = P.assembly.name

WithEntry(P, m, IR) =
 IR ++ [EntryStub(P)]  if Executable(P) âˆ§ IsRootModule(P, m)
 IR                    otherwise

**(CodegenObj-LLVM)**
Project(Î“) = P    Î“ âŠ¢ CodegenModule(m) â‡“ IR    IR' = WithEntry(P, m, IR)    Î“ âŠ¢ LowerIR(IR') â‡“ L    Î“ âŠ¢ EmitObj(L) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenObj(m) â‡“ b

**(CodegenIR-LLVM)**
Project(Î“) = P    e âˆˆ {`ll`, `bc`}    Î“ âŠ¢ CodegenModule(m) â‡“ IR    IR' = WithEntry(P, m, IR)    Î“ âŠ¢ LowerIR(IR') â‡“ L    Î“ âŠ¢ EmitLLVM(L) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenIR(m, e) â‡“ b

**File Emission.**
WriteFileOk(p, b) â‡’ Overwrites(p, b)

**Directory Creation.**
EnsureDir(p) â‡“ ok â‡’ IsDir(p)

**Emit Objects**

**(Emit-Objects-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitObjects([], P) â‡“ []

**(Emit-Objects-Cons)**
Î“ âŠ¢ CodegenObj(m) â‡“ b    Î“ âŠ¢ WriteFile(ObjPath(P, m), b) â‡“ ok    Î“ âŠ¢ EmitObjects(ms, P) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitObjects(m::ms, P) â‡“ ObjPath(P, m)::L

**Emit IR**

**(Emit-IR-None)**
e = `none`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitIR(ms, P, e) â‡“ []

**(Emit-IR-Cons-LL)**
e = `ll`    Î“ âŠ¢ CodegenIR(m, e) â‡“ b    Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡“ ok    Î“ âŠ¢ EmitIR(ms, P, e) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitIR(m::ms, P, e) â‡“ IRPath(P, m, e)::L

**(Emit-IR-Cons-BC)**
e = `bc`    Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t    Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a    Î“ âŠ¢ AssembleIR(a, t) â‡“ b    Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡“ ok    Î“ âŠ¢ EmitIR(ms, P, e) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitIR(m::ms, P, e) â‡“ IRPath(P, m, e)::L

EmitIRFail(m, P, `ll`) â‡” Î“ âŠ¢ CodegenIR(m, `ll`) â‡‘ âˆ¨ (âˆƒ b. Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ b âˆ§ Î“ âŠ¢ WriteFile(IRPath(P, m, `ll`), b) â‡‘)
EmitIRFail(m, P, `bc`) â‡”
 Î“ âŠ¢ CodegenIR(m, `ll`) â‡‘ âˆ¨
 (âˆƒ t. Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡‘) âˆ¨
 (âˆƒ t, a. Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a âˆ§ Î“ âŠ¢ AssembleIR(a, t) â‡‘) âˆ¨
 (âˆƒ t, a, b. Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a âˆ§ Î“ âŠ¢ AssembleIR(a, t) â‡“ b âˆ§ Î“ âŠ¢ WriteFile(IRPath(P, m, `bc`), b) â‡‘)

**(Emit-IR-Err)**
EmitIRFail(m, P, e)    c = Code(Out-IR-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitIR(m::ms, P, e) â‡‘ c

LinkJudg = {ResolveRuntimeLib, Link}
RuntimeLibName = "cursive0_rt.lib"
RuntimeLibPath(P) = P.root / `runtime` / RuntimeLibName

**(ResolveRuntimeLib-Ok)**
Î“ âŠ¢ ReadBytes(RuntimeLibPath(P)) â‡“ _
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ RuntimeLibPath(P)

**(ResolveRuntimeLib-Err)**
Î“ âŠ¢ ReadBytes(RuntimeLibPath(P)) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRuntimeLib(P) â‡‘

LinkerSyms : Path Ã— List(Path) Ã— Path â‡€ â„˜(Symbol)
RuntimeRequiredSyms = RuntimeSyms
MissingRuntimeSym(t, L, exe) â‡” RuntimeRequiredSyms âŠˆ LinkerSyms(t, L, exe)

LinkObjs(P) = ObjPaths(P, ModuleList(P))
LinkInputs(P) = LinkObjs(P) ++ [RuntimeLibPath(P)]
LinkFlags(P) = ["/OUT:" ++ ExePath(P), "/ENTRY:main", "/SUBSYSTEM:CONSOLE", "/NODEFAULTLIB"]
LinkArgsOk(P, L, exe) â‡” L = LinkInputs(P) âˆ§ exe = ExePath(P) âˆ§ LinkFlags(P) = ["/OUT:" ++ ExePath(P), "/ENTRY:main", "/SUBSYSTEM:CONSOLE", "/NODEFAULTLIB"]

**(Link-Ok)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    Î“ âŠ¢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Link(Objs, P) â‡“ ok

**(Link-NotFound)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡‘    c = Code(Out-Link-NotFound)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Link(Objs, P) â‡‘ c

**(Link-Runtime-Missing)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡‘    c = Code(Out-Link-Runtime-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Link(Objs, P) â‡‘ c

**(Link-Runtime-Incompatible)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    c = Code(Out-Link-Runtime-Incompatible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Link(Objs, P) â‡‘ c

**(Link-Fail)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    LinkArgsOk(P, Objs ++ [lib], ExePath(P))    Â¬ MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    Î“ âŠ¢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) â‡‘    c = Code(Out-Link-Fail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Link(Objs, P) â‡‘ c

**Output Pipeline (Big-Step)**
O = OutputRoot(P)
ms = ModuleList(P)
e = P.assembly.emit_ir

**(Output-Pipeline)**
Executable(P)    Î“ âŠ¢ EnsureDir(O) â‡“ ok    Î“ âŠ¢ EnsureDir(O / `obj`) â‡“ ok    Î“ âŠ¢ EnsureDir(O / `bin`) â‡“ ok    (e = `none` âˆ¨ Î“ âŠ¢ EnsureDir(O / `ir`) â‡“ ok)    Î“ âŠ¢ EmitObjects(ms, P) â‡“ Objs    Î“ âŠ¢ EmitIR(ms, P, e) â‡“ IRs    Î“ âŠ¢ Link(Objs, P) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ OutputPipeline(P) â‡“ (Objs, IRs, ExePath(P))

**(Output-Pipeline-Lib)**
Â¬ Executable(P)    Î“ âŠ¢ EnsureDir(O) â‡“ ok    Î“ âŠ¢ EnsureDir(O / `obj`) â‡“ ok    (e = `none` âˆ¨ Î“ âŠ¢ EnsureDir(O / `ir`) â‡“ ok)    Î“ âŠ¢ EmitObjects(ms, P) â‡“ Objs    Î“ âŠ¢ EmitIR(ms, P, e) â‡“ IRs
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ OutputPipeline(P) â‡“ (Objs, IRs, âŠ¥)

**(Output-Pipeline-Err)**
âŸ¨OutStart(P)âŸ© â†’* âŸ¨Error(c)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ OutputPipeline(P) â‡‘ c

**Output Pipeline (Small-Step)**
OutState = {OutStart(P), OutDirs(P), OutObjs(P, ms, Objs), OutIR(P, ms, Objs, IRs, e), OutLink(P, Objs, IRs), OutDone(Objs, IRs, Exe), Error(code)}
O = OutputRoot(P)
ms = ModuleList(P)
e = P.assembly.emit_ir

**(Out-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutStart(P)âŸ© â†’ âŸ¨OutDirs(P)âŸ©

**(Out-Dirs-Ok)**
Î“ âŠ¢ EnsureDir(O) â‡“ ok    Î“ âŠ¢ EnsureDir(O / `obj`) â‡“ ok    (Â¬ Executable(P) âˆ¨ Î“ âŠ¢ EnsureDir(O / `bin`) â‡“ ok)    (e = `none` âˆ¨ Î“ âŠ¢ EnsureDir(O / `ir`) â‡“ ok)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutDirs(P)âŸ© â†’ âŸ¨OutObjs(P, ms, [])âŸ©

**(Out-Dirs-Err)**
Î“ âŠ¢ EnsureDir(O) â‡‘ âˆ¨ Î“ âŠ¢ EnsureDir(O / `obj`) â‡‘ âˆ¨ (Executable(P) âˆ§ Î“ âŠ¢ EnsureDir(O / `bin`) â‡‘) âˆ¨ (e âˆˆ {`ll`, `bc`} âˆ§ Î“ âŠ¢ EnsureDir(O / `ir`) â‡‘)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutDirs(P)âŸ© â†’ âŸ¨Error(Code(Out-Dirs-Err))âŸ©

**(Out-Obj-Collision)**
Â¬ Distinct(L ++ ObjPaths(P, ms))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutObjs(P, ms, L)âŸ© â†’ âŸ¨Error(Code(Out-Obj-Collision))âŸ©

**(Out-Obj-Cons)**
Î“ âŠ¢ CodegenObj(m) â‡“ b    Î“ âŠ¢ WriteFile(ObjPath(P, m), b) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutObjs(P, m::ms, L)âŸ© â†’ âŸ¨OutObjs(P, ms, L ++ [ObjPath(P, m)])âŸ©

**(Out-Obj-Err)**
Î“ âŠ¢ CodegenObj(m) â‡‘ âˆ¨ (Î“ âŠ¢ CodegenObj(m) â‡“ b âˆ§ Î“ âŠ¢ WriteFile(ObjPath(P, m), b) â‡‘)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutObjs(P, m::ms, L)âŸ© â†’ âŸ¨Error(Code(Out-Obj-Err))âŸ©

**(Out-Obj-Done)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutObjs(P, [], L)âŸ© â†’ âŸ¨OutIR(P, ModuleList(P), L, [], e)âŸ©

**(Out-IR-None)**
e = `none`    Executable(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutLink(P, Objs, IRs)âŸ©

**(Out-IR-None-NoLink)**
e = `none`    Â¬ Executable(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutDone(Objs, IRs, âŠ¥)âŸ©

**(Out-IR-Collision)**
e âˆˆ {`ll`, `bc`}    Â¬ Distinct(IRs ++ IRPaths(P, ms, e))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, ms, Objs, IRs, e)âŸ© â†’ âŸ¨Error(Code(Out-IR-Collision))âŸ©

**(Out-IR-Cons-LL)**
e = `ll`    Î“ âŠ¢ CodegenIR(m, e) â‡“ b    Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, m::ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutIR(P, ms, Objs, IRs ++ [IRPath(P, m, e)], e)âŸ©

**(Out-IR-Cons-BC)**
e = `bc`    Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t    Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a    Î“ âŠ¢ AssembleIR(a, t) â‡“ b    Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, m::ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutIR(P, ms, Objs, IRs ++ [IRPath(P, m, e)], e)âŸ©

**(Out-IR-Err)**
(e = `ll` âˆ§ (Î“ âŠ¢ CodegenIR(m, e) â‡‘ âˆ¨ (Î“ âŠ¢ CodegenIR(m, e) â‡“ b âˆ§ Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡‘))) âˆ¨
(e = `bc` âˆ§ (Î“ âŠ¢ CodegenIR(m, `ll`) â‡‘ âˆ¨ (Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡‘) âˆ¨ (Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a âˆ§ Î“ âŠ¢ AssembleIR(a, t) â‡‘) âˆ¨ (Î“ âŠ¢ CodegenIR(m, `ll`) â‡“ t âˆ§ Î“ âŠ¢ ResolveTool(`llvm-as`) â‡“ a âˆ§ Î“ âŠ¢ AssembleIR(a, t) â‡“ b âˆ§ Î“ âŠ¢ WriteFile(IRPath(P, m, e), b) â‡‘)))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, m::ms, Objs, IRs, e)âŸ© â†’ âŸ¨Error(Code(Out-IR-Err))âŸ©

**(Out-IR-Done)**
e âˆˆ {`ll`, `bc`}    ms = []    Executable(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutLink(P, Objs, IRs)âŸ©

**(Out-IR-Done-NoLink)**
e âˆˆ {`ll`, `bc`}    ms = []    Â¬ Executable(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutIR(P, ms, Objs, IRs, e)âŸ© â†’ âŸ¨OutDone(Objs, IRs, âŠ¥)âŸ©

**(Out-Link-Ok)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    Î“ âŠ¢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutLink(P, Objs, IRs)âŸ© â†’ âŸ¨OutDone(Objs, IRs, ExePath(P))âŸ©

**(Out-Link-NotFound)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutLink(P, Objs, IRs)âŸ© â†’ âŸ¨Error(Code(Out-Link-NotFound))âŸ©

**(Out-Link-Runtime-Missing)**
Executable(P)    Î“ âŠ¢ ResolveRuntimeLib(P) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutLink(P, Objs, IRs)âŸ© â†’ âŸ¨Error(Code(Out-Link-Runtime-Missing))âŸ©

**(Out-Link-Runtime-Incompatible)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutLink(P, Objs, IRs)âŸ© â†’ âŸ¨Error(Code(Out-Link-Runtime-Incompatible))âŸ©

**(Out-Link-Fail)**
Executable(P)    Î“ âŠ¢ ResolveTool(`lld-link`) â‡“ t    Î“ âŠ¢ ResolveRuntimeLib(P) â‡“ lib    Â¬ MissingRuntimeSym(t, Objs ++ [lib], ExePath(P))    Î“ âŠ¢ InvokeLinker(t, Objs ++ [lib], ExePath(P)) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨OutLink(P, Objs, IRs)âŸ© â†’ âŸ¨Error(Code(Out-Link-Fail))âŸ©

### 2.6. Tool Resolution and IR Assembly Inputs

SearchDirs(P) =
 [Env(`C0_LLVM_BIN`)]  if Env(`C0_LLVM_BIN`) â‰  âŠ¥ âˆ§ Env(`C0_LLVM_BIN`) â‰  ""
 [P.root/`llvm/llvm-21.1.8-x86_64/bin`]  if RepoLLVM(P)
 PATHDirs  otherwise

**(ResolveTool-Ok)**
Project(Î“) = P    SearchDirs(P) contains x at t
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTool(x) â‡“ t

**(ResolveTool-Err-Linker)**
Project(Î“) = P    x = `lld-link`    SearchDirs(P) does not contain x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTool(x) â‡‘

**(ResolveTool-Err-IR)**
Project(Î“) = P    x = `llvm-as`    SearchDirs(P) does not contain x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTool(x) â‡‘

**(AssembleIR-Ok)**
Invoke(a, t) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AssembleIR(a, t) â‡“ b

**(AssembleIR-Err)**
Invoke(a, t) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AssembleIR(a, t) â‡‘

### 2.7. Unwind and FFI Surface

**FFI Boundary.** A call to an `extern` procedure or an invocation of a `[[export]]` procedure from foreign code crosses the FFI boundary.

FFIBoundary(proc) â‡” proc = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ¨ (proc = ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ§ ExportAttr(proc) defined)

**Unwind Modes.**
UnwindMode(proc) = m â‡” UnwindAttr(proc) = m
UnwindMode(proc) = "abort" â‡” UnwindAttr(proc) undefined

UnwindAttr(proc) = m â‡” âˆƒ a âˆˆ AttrByName(proc, "unwind"). a.args = [StringLiteral(m)]

**Boundary Effects.**
1. If a Cursive panic or foreign unwind attempts to cross an FFI boundary with UnwindMode(proc) = "abort", the program MUST abort.
2. If UnwindMode(proc) = "catch", boundary behavior is defined in Â§5.13.6.4 and Â§21.2:
   - Imported procedures: foreign unwinds are converted to Cursive panics.
   - Exported procedures: Cursive panics are caught and converted to the error indicator value defined in Â§21.2.2.

**Safety.** Calls to `extern` procedures MUST occur within an `unsafe` block (Â§21.2.1). A call outside `unsafe` is ill-formed (`Call-Extern-Unsafe-Err`).

## 3. Phase 1: Source Loading, Lexing, Parsing

### 3.1. Source Loading and Normalization

**Source File Record.**

SourceFile = âŸ¨path, bytes, scalars, text, byte_len, line_starts, line_countâŸ©

S.text = EncodeUTF8(S.scalars)
S.byte_len = ByteLen(S.text)
S.line_count = |S.line_starts|

**Unicode Scalars and UTF-8.**
Byte = { n âˆˆ â„• | 0 â‰¤ n â‰¤ 255 }
Bytes = [Byte]
UnicodeScalar = { u âˆˆ â„• | 0 â‰¤ u â‰¤ 0x10FFFF âˆ§ u âˆ‰ [0xD800, 0xDFFF] }
Scalars = [UnicodeScalar]
String = Scalars
Utf8Len(u) =
 1  if 0 â‰¤ u â‰¤ 0x7F
 2  if 0x80 â‰¤ u â‰¤ 0x7FF
 3  if 0x800 â‰¤ u â‰¤ 0xFFFF
 4  if 0x10000 â‰¤ u â‰¤ 0x10FFFF
EncodeUTF8(u) =
 [u]  if 0 â‰¤ u â‰¤ 0x7F
 [0xC0 âˆ¨ (u >> 6), 0x80 âˆ¨ (u & 0x3F)]  if 0x80 â‰¤ u â‰¤ 0x7FF
 [0xE0 âˆ¨ (u >> 12), 0x80 âˆ¨ ((u >> 6) & 0x3F), 0x80 âˆ¨ (u & 0x3F)]  if 0x800 â‰¤ u â‰¤ 0xFFFF
 [0xF0 âˆ¨ (u >> 18), 0x80 âˆ¨ ((u >> 12) & 0x3F), 0x80 âˆ¨ ((u >> 6) & 0x3F), 0x80 âˆ¨ (u & 0x3F)]  if 0x10000 â‰¤ u â‰¤ 0x10FFFF
EncodeUTF8([]) = []
EncodeUTF8(u::U) = EncodeUTF8(u) ++ EncodeUTF8(U)
DecodeUTF8(B) = U â‡” EncodeUTF8(U) = B
Utf8Valid(B) â‡” âˆƒ U. DecodeUTF8(B) = U
Utf8(s) = EncodeUTF8(s)


#### 3.1.1. Unicode Normalization Outside Identifiers

NormalizeOutsideIdentifiers : Scalars â†’ Scalars
NormalizeOutsideIdentifiers(T) = T

#### 3.1.2. Lexically Sensitive Unicode Enforcement
T = S.scalars
LexSensitivePos(S) = [ p | 0 â‰¤ p < |T| âˆ§ Sensitive(T[p]) âˆ§ Â¬ InsideLiteralOrComment(p) ]
Î“ âŠ¢ LexSecure(S, K, LexSensitivePos(S)) â‡“ ok
#### 3.1.3. UTF-8 Decoding and BOM Handling


**(Decode-Ok)**
DecodeUTF8(B) â‡“ U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Decode(B) â‡“ U

**(Decode-Err)**
DecodeUTF8(B) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Decode(B) â‡‘

StripLeadBOM([]) = []
StripLeadBOM(U+FEFF::U) = U
StripLeadBOM(u::U) = u::U  if u â‰  U+FEFF

**(StripBOM-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StripBOM([]) â‡“ ([], false, âŠ¥)

**(StripBOM-None)**
U = u_0::u_1::â€¦    u_0 â‰  U+FEFF    âˆ€ i > 0, u_i â‰  U+FEFF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StripBOM(U) â‡“ (U, false, âŠ¥)

**(StripBOM-Start)**
U = U+FEFF::U_1    âˆ€ i, U_1[i] â‰  U+FEFF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StripBOM(U) â‡“ (U_1, true, âŠ¥)

**(StripBOM-Embedded)**
U' = StripLeadBOM(U)    b = (U â‰  [] âˆ§ U[0] = U+FEFF)    i = min{ p | 0 â‰¤ p < |U'| âˆ§ U'[p] = U+FEFF }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StripBOM(U) â‡“ (U', b, i)

#### 3.1.4. Line Ending Normalization and Logical Lines

CR = U+000D
LF = U+000A

**(Norm-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NormalizeLF([]) â‡“ []

**(Norm-CRLF)**
Î“ âŠ¢ NormalizeLF(U) â‡“ V
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NormalizeLF([CR, LF] ++ U) â‡“ [LF] ++ V

**(Norm-CR)**
U = [] âˆ¨ U[0] â‰  LF    Î“ âŠ¢ NormalizeLF(U) â‡“ V
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NormalizeLF([CR] ++ U) â‡“ [LF] ++ V

**(Norm-LF)**
Î“ âŠ¢ NormalizeLF(U) â‡“ V
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NormalizeLF([LF] ++ U) â‡“ [LF] ++ V

**(Norm-Other)**
c â‰  CR    c â‰  LF    Î“ âŠ¢ NormalizeLF(U) â‡“ V
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NormalizeLF([c] ++ U) â‡“ [c] ++ V

**Logical Line Map.**

Utf8Offsets([]) = [0]
Utf8Offsets(c::cs) = [0] ++ [o + Utf8Len(c) | o âˆˆ Utf8Offsets(cs)]

LineStarts(T) = [0] ++ [Utf8Offsets(T)[i] + 1 | 0 â‰¤ i < |T| âˆ§ T[i] = LF]
LineCount(T) = |LineStarts(T)|

**Locate (Line/Column).**
L = S.line_starts
o' = min(o, S.byte_len)
k = max{ j | L[j] â‰¤ o' }

Î“ âŠ¢ Locate(S, o) â‡“ âŸ¨file = S.path, offset = o', line = k + 1, col = o' - L[k] + 1âŸ©

#### 3.1.5. Prohibited Code Points

Prohibited(c) â‡” General_Category(c) = Cc âˆ§ c âˆ‰ {U+0009, U+000A, U+000C, U+000D}

LiteralSpan(T) = â‹ƒ { [ByteOf(T, i), ByteOf(T, j)) | StringRange(T, i, j) âˆ¨ CharRange(T, i, j) }

**(WF-Prohibited)**
âˆ€ i, Prohibited(T[i]) â‡’ ByteOf(T, i) âˆˆ LiteralSpan(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : NoProhibited

#### 3.1.6. NFC Normalization for Identifiers and Module Paths

NFC(s) = UnicodeNFC_{15.0.0}(s)

CaseFold(s) = UnicodeCaseFold_{15.0.0}(s)

**Totality.**
The functions NFC and CaseFold are total on sequences of Unicode scalar values. All inputs to IdKey and PathKey MUST be Unicode scalar sequences; inputs are produced by LoadSource, which rejects invalid UTF-8.

IdKey(s) = NFC(s)
IdEq(s_1, s_2) â‡” IdKey(s_1) = IdKey(s_2)

PathKey(p) = [NFC(c_1), â€¦, NFC(c_n)]
PathEq(p, q) â‡” PathKey(p) = PathKey(q)

#### 3.1.7. Newline Tokens and Statement Termination

Tokenize : SourceFile â‡€ (Token* Ã— DocComment*)
Tokenize(S) = (K, D) â‡’ LexNewline(K, S) âˆ§ LexNoComments(K, S)

Depth(K, 0) = 0
Depth(K, i+1) = Depth(K, i) + Î´(K[i])
Î´(t) =
 1   if t âˆˆ {Punctuator("("), Punctuator("["), Punctuator("{")}
 -1  if t âˆˆ {Punctuator(")"), Punctuator("]"), Punctuator("}")}
 0   otherwise

Prev(K, i) = âŠ¥ â‡” { j | j < i âˆ§ K[j].kind â‰  newline âˆ§ âˆ€ k. j < k < i â‡’ K[k].kind â‰  newline } = âˆ…
Prev(K, i) = K[j] â‡” j = max{ j | j < i âˆ§ K[j].kind â‰  newline âˆ§ âˆ€ k. j < k < i â‡’ K[k].kind â‰  newline }
Next(K, i) = âŠ¥ â‡” { j | j > i âˆ§ K[j].kind â‰  newline } = âˆ…
Next(K, i) = K[j] â‡” j = min{ j | j > i âˆ§ K[j].kind â‰  newline }

Ambig = {"+", "-", "*", "&", "|"}
BeginsOperand(t) â‡” t.kind âˆˆ {Identifier, IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral} âˆ¨ (t.kind = Punctuator âˆ§ t.lexeme âˆˆ {"(", "[", "{"}) âˆ¨ (t.kind = Operator âˆ§ t.lexeme âˆˆ {"!", "-", "&", "*", "^"}) âˆ¨ (t.kind = Keyword âˆ§ t.lexeme âˆˆ {"if", "match", "loop", "unsafe", "move", "transmute", "widen", "parallel", "spawn", "dispatch", "yield", "sync", "race", "all"})
UnaryOnly = {"!", "~", "?"}

Continue(K, i) â‡” Depth(K, i) > 0 âˆ¨ (âˆƒ t. Prev(K, i) = t âˆ§ (t.lexeme = "," âˆ¨ (t.kind = Operator âˆ§ ((t.lexeme âˆˆ Ambig âˆ§ âˆƒ u. Next(K, i) = u âˆ§ BeginsOperand(u)) âˆ¨ t.lexeme âˆ‰ UnaryOnly)))) âˆ¨ (âˆƒ u. Next(K, i) = u âˆ§ u.lexeme âˆˆ {".", "::", "~>"})

Filter(K) = [ K[i] | K[i].kind â‰  newline âˆ¨ Â¬ Continue(K, i) ]

IsTerminator(t) â‡” t = Punctuator(";") âˆ¨ t.kind = newline
BoundaryTokens(K, i) = { t | t = K[i] âˆ¨ t = Prev(K, i) âˆ¨ t = Next(K, i) } \ {âŠ¥}
HasTerminator(F, i) â‡” âˆƒ t âˆˆ BoundaryTokens(F, i). IsTerminator(t)
Commas are separators within a single statement and are never statement terminators. A comma MUST appear only between list elements. Trailing commas are permitted only when TrailingCommaAllowed (Â§3.3.5); otherwise they are ill-formed. A permitted trailing comma does not introduce an empty list element.
RequiredTerminator : Token* Ã— â„• â†’ Bool
ContinuesLine : Token* Ã— â„• â†’ Bool
ContinuesLine(K, i) â‡” K[i].kind = newline âˆ§ Continue(K, i)
RequiredTerminator(K, i) â‡” K[i].kind = newline âˆ§ Â¬ ContinuesLine(K, i)

**(Missing-Terminator-Err)**
RequiredTerminator(K, i)    Â¬ HasTerminator(Filter(K), i)    c = Code(Missing-Terminator-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)


#### 3.1.8. Source Loading Pipeline (Small-Step and Big-Step)

SourceLoadState = {Start(f, B), Sized(f, B), Decoded(f, B, U), BomStripped(f, B, U, b, j), Normalized(f, B, T, j), LineMapped(f, B, T, L), Validated(S), Error(code)}
B âˆˆ Bytes
U âˆˆ Scalars
T âˆˆ Scalars
L = LineStarts(T)
j âˆˆ â„• âˆª {âŠ¥}

**(Step-Size)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Start(f, B)âŸ© â†’ âŸ¨Sized(f, B)âŸ©

**(Step-Decode)**
Î“ âŠ¢ Decode(B) â‡“ U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Sized(f, B)âŸ© â†’ âŸ¨Decoded(f, B, U)âŸ©

**(Step-Decode-Err)**
Î“ âŠ¢ Decode(B) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Sized(f, B)âŸ© â†’ âŸ¨Error(Code(Step-Decode-Err))âŸ©

**(Step-BOM)**
Î“ âŠ¢ StripBOM(U) â‡“ (U', b, j)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Decoded(f, B, U)âŸ© â†’ âŸ¨BomStripped(f, B, U', b, j)âŸ©

**(Step-Norm)**
T = NormalizeOutsideIdentifiers(U)    Î“ âŠ¢ NormalizeLF(T) â‡“ V
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BomStripped(f, B, U, b, j)âŸ© â†’ âŸ¨Normalized(f, B, V, j)âŸ©

**(Step-EmbeddedBOM-Err)**
j â‰  âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Normalized(f, B, T, j)âŸ© â†’ âŸ¨Error(Code(Step-EmbeddedBOM-Err))âŸ©

**(Step-LineMap)**
j = âŠ¥    L = LineStarts(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Normalized(f, B, T, j)âŸ© â†’ âŸ¨LineMapped(f, B, T, L)âŸ©

**(Step-Prohibited)**
Î“ âŠ¢ T : NoProhibited    S = âŸ¨path = f, bytes = B, scalars = T, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = L, line_count = |L|âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LineMapped(f, B, T, L)âŸ© â†’ âŸ¨Validated(S)âŸ©

**(Step-Prohibited-Err)**
Î“ âŠ¬ T : NoProhibited
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LineMapped(f, B, T, L)âŸ© â†’ âŸ¨Error(Code(Step-Prohibited-Err))âŸ©

**Source Load (Big-Step)**

**(LoadSource-Ok)**
Î“ âŠ¢ Decode(B) â‡“ U    Î“ âŠ¢ StripBOM(U) â‡“ (U', b, âŠ¥)    Î“ âŠ¢ NormalizeLF(NormalizeOutsideIdentifiers(U')) â‡“ T    L = LineStarts(T)    Î“ âŠ¢ T : NoProhibited    S = âŸ¨path = f, bytes = B, scalars = T, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = L, line_count = |L|âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoadSource(f, B) â‡“ S

**(LoadSource-Err)**
Î“ âŠ¢ LoadSource(f, B) â†’* âŸ¨Error(c)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoadSource(f, B) â‡‘ c

#### 3.1.9. Diagnostic Spans for Source Loading

S_tmp = âŸ¨path = f, bytes = B, text = EncodeUTF8(T), byte_len = ByteLen(T), line_starts = LineStarts(T), line_count = |LineStarts(T)|âŸ©

O = Utf8Offsets(T)
O[|T|] = ByteLen(T)

SpanAtIndex(T, i) = SpanOf(S_tmp, O[i], O[i+1])

SpanAtLineStart(T, k) = SpanOf(S_tmp, s, e)
s =
 LineStarts(T)[k]  if k < |LineStarts(T)|
 ByteLen(T)        otherwise
e = min(s + 1, ByteLen(T))

If b = true, the warning W-SRC-0101 MUST be emitted even if LoadSource ultimately fails.


**(Span-BOM-Warn)**
b = true    e = min(1, ByteLen(T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(W-SRC-0101, SpanOf(S_tmp, 0, e))

**(Span-BOM-Embedded)**
j â‰  âŠ¥    i = min{ p | 0 â‰¤ p < |T| âˆ§ T[p] = U+FEFF }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(E-SRC-0103, SpanAtIndex(T, i))

**(Span-Prohibited)**
i = min{ p | 0 â‰¤ p < |T| âˆ§ Prohibited(T[p]) âˆ§ O[p] âˆ‰ LiteralSpan(T) }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(E-SRC-0104, SpanAtIndex(T, i))

**(NoSpan-Decode)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(E-SRC-0101, âŠ¥)

### 3.2. Lexical Analysis

#### 3.2.1. Inputs, Outputs, and Records

**LexerInput.**
T = S.scalars
B = S.text
n = S.byte_len
LexerInput(S) = âŸ¨T, B, nâŸ©

**LexerOutput.**
LexerOutput(S) = âŸ¨K, DâŸ©
K âˆˆ Token*    D âˆˆ DocComment*

**EOF Token.**
EOFSpan(S) = SpanOfText(S, |T|, |T|)
TokenEOF(S) = âŸ¨EOF, Îµ, EOFSpan(S)âŸ©

**LexemeBinding.**
TokenRange(S, t) = (i, j) â‡” t.span = SpanOfText(S, i, j)
LexemeBinding(S, T, K) â‡” âˆ€ t âˆˆ K. âˆƒ i, j. TokenRange(S, t) = (i, j) âˆ§ t.lexeme = Lexeme(T, i, j)

**DocComment.**

DocComment = âŸ¨kind, text, spanâŸ©

DocKind = {LineDoc, ModuleDoc}
StripLeadingSpace(s) =
 s[1..|s|)  if |s| > 0 âˆ§ At(s, 0) = U+0020
 s          otherwise
DocBody(T, i, j) = StripLeadingSpace(T[i+3..j))
DocMarker(T, i) =
 LineDoc    if T[i..i+3] = "///"
 ModuleDoc  if T[i..i+3] = "//!"
 âŠ¥          otherwise

**Newline Tokens.**
NewlineTokenAt(S, T, i) â‡” T[i] = LF âˆ§ Â¬ InsideLiteralOrComment(i)
LexNewline(K, S) â‡” âˆ€ i. NewlineTokenAt(S, T, i) â‡’ âˆƒ t âˆˆ K. t.kind = Newline âˆ§ TokenRange(S, t) = (i, i+1)
TokenInComment(S, t) â‡” âˆƒ i, j, a, b. TokenRange(S, t) = (i, j) âˆ§ (LineCommentRange(T, a, b) âˆ¨ BlockCommentRange(T, a, b)) âˆ§ a â‰¤ i âˆ§ j â‰¤ b
LexNoComments(K, S) â‡” âˆ€ t âˆˆ K. Â¬ TokenInComment(S, t)

**Indices and Lexemes.**
T = S.scalars
O = Utf8Offsets(T)
ScalarIndex(T) = { i | 0 â‰¤ i â‰¤ |T| }

ByteOf(T, i) = O[i]

SpanOfText(S, i, j) = SpanOf(S, ByteOf(T, i), ByteOf(T, j))

Lexeme(T, i, j) = T[i..j)

#### 3.2.2. Character Classes

c âˆˆ UnicodeScalar

**Whitespace.**

Whitespace(c) â‡” c âˆˆ {U+0020, U+0009, U+000C}

**Line Feed.**

LineFeed(c) â‡” c = U+000A

**Identifier Characters.**
XID_Start : UnicodeScalar â†’ Bool
XID_Continue : UnicodeScalar â†’ Bool

IdentStart(c) â‡” c = '_' âˆ¨ XID_Start(c)
IdentContinue(c) â‡” c = '_' âˆ¨ XID_Continue(c)

XIDVersion = "15.0.0"
XID_Start(c) â‡” c âˆˆ UAX31_XID_Start_{15.0.0}
XID_Continue(c) â‡” c âˆˆ UAX31_XID_Continue_{15.0.0}

**Non-Characters.**

NonCharacter(c) â‡” c âˆˆ [U+FDD0, U+FDEF] âˆ¨ (c & 0xFFFF) âˆˆ {0xFFFE, 0xFFFF}

**Digits.**

DecDigit(c) â‡” c âˆˆ {'0' â€¦ '9'}
HexDigit(c) â‡” DecDigit(c) âˆ¨ c âˆˆ {'a' â€¦ 'f', 'A' â€¦ 'F'}
OctDigit(c) â‡” c âˆˆ {'0' â€¦ '7'}
BinDigit(c) â‡” c âˆˆ {'0', '1'}

**Lexically Sensitive Characters.**

Sensitive(c) â‡” c âˆˆ {U+202A â€¦ U+202E, U+2066 â€¦ U+2069, U+200C, U+200D}

#### 3.2.3. Reserved Lexemes

**Reserved.**
Reserved = {`all`, `as`, `break`, `class`, `continue`, `dispatch`, `else`, `enum`, `false`, `defer`, `frame`, `from`, `if`, `imm`, `import`, `internal`, `let`, `loop`, `match`, `modal`, `move`, `mut`, `null`, `parallel`, `private`, `procedure`, `protected`, `public`, `race`, `record`, `region`, `return`, `shadow`, `shared`, `spawn`, `sync`, `transition`, `transmute`, `true`, `type`, `unique`, `unsafe`, `var`, `widen`, `where`, `using`, `yield`, `const`, `override`}

FutureReserved = âˆ…

**Keyword Predicate.**
Keyword(s) â‡” s âˆˆ Reserved

**Reserved Namespaces.**
ReservedNamespacePrefix = {`cursive.`}
ReservedIdentPrefix = {`gen_`}
ReservedNamespacePhase = Phase3

**Universe-Protected Bindings.**
UniverseProtected = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `f16`, `f32`, `f64`, `bool`, `char`, `usize`, `isize`, `Self`, `Drop`, `Bitcopy`, `Clone`, `Eq`, `Hash`, `Hasher`, `Iterator`, `Step`, `FfiSafe`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, `CancelToken`, `Context`, `System`, `ExecutionDomain`, `Reactor`, `CpuSet`, `Priority`, `Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`, `Tracked`, `Spawned`}
UniverseProtectedPhase = Phase3

`Drop`, `Bitcopy`, `Clone`, and `FfiSafe` are reserved predicate names. They MUST NOT be declared as classes or used as user-defined type/value bindings.

#### 3.2.4. Token Kinds

TokenKind âˆˆ {Identifier, Keyword(k), IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral, Operator(o), Punctuator(p), Newline, Unknown}

**Operator Set.**
OperatorSet = {"+", "-", "*", "/", "%", "**", "==", "!=", "<", "<=", ">", ">=", "&&", "||", "!", "&", "|", "^", "<<", ">>", "=", "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "<<=", ">>=", ":=", "<:", "..", "..=", "=>", "->", "::", "~", "~>", "~!", "~%", "?", "#", "@", "$"}

**Punctuator Set.**
PunctuatorSet = {"(", ")", "[", "]", "[[", "]]", "{", "}", ",", ":", ";", "."}

OperatorSet âˆ© PunctuatorSet = âˆ…

#### 3.2.5. Comment and Whitespace Scanning

T = S.scalars

**Line Comment Scan.**

**(Scan-Line-Comment)**
T[i] = '/'    T[i+1] = '/'    j = min{ p | i â‰¤ p âˆ§ (p = |T| âˆ¨ T[p] = LF) }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ScanLineComment(T, i) â‡“ j

**Doc Comment Classification.**
kind = DocMarker(T, i)
body = DocBody(T, i, j)

**(Doc-Comment)**
Î“ âŠ¢ ScanLineComment(T, i) â‡“ j    kind â‰  âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DocComment(T, i) â‡“ âŸ¨kind, body, SpanOfText(S, i, j)âŸ©

LineCommentTokens(T, i) = []
LineCommentNext(T, i) = j where Î“ âŠ¢ ScanLineComment(T, i) â‡“ j

**Block Comment Scan (Nested).**
BlockState = { BlockScan(T, i, d, i_0) | 0 â‰¤ i_0 â‰¤ i â‰¤ |T| âˆ§ d âˆˆ â„• } âˆª { BlockDone(j) | 0 â‰¤ j â‰¤ |T| }

**(Block-Start)**
T[i] = '/'    T[i+1] = '*'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BlockScan(T, i, d, i_0)âŸ© â†’ âŸ¨BlockScan(T, i+2, d+1, i_0)âŸ©

**(Block-End)**
T[i] = '*'    T[i+1] = '/'    d > 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BlockScan(T, i, d, i_0)âŸ© â†’ âŸ¨BlockScan(T, i+2, d-1, i_0)âŸ©

**(Block-Done)**
T[i] = '*'    T[i+1] = '/'    d = 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BlockScan(T, i, d, i_0)âŸ© â†’ âŸ¨BlockDone(i+2)âŸ©

**(Block-Step)**
T[i..i+2] â‰  "/*"    T[i..i+2] â‰  "*/"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BlockScan(T, i, d, i_0)âŸ© â†’ âŸ¨BlockScan(T, i+1, d, i_0)âŸ©

**(Block-Comment-Unterminated)**
âŸ¨BlockScan(T, i, d, i_0)âŸ© â†’* âŸ¨BlockScan(T, |T|, d, i_0)âŸ©    d > 0    c = Code(Block-Comment-Unterminated)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, i_0, i_0+2))

#### 3.2.6. Literal Lexing

T = S.scalars

**Syntax.**

```ebnf
integer_literal  ::= (decimal_integer | hex_integer | octal_integer | binary_integer) int_suffix?
decimal_integer  ::= dec_digit ("_"* dec_digit)*
hex_integer      ::= "0x" hex_digit ("_"* hex_digit)*
octal_integer    ::= "0o" oct_digit ("_"* oct_digit)*
binary_integer   ::= "0b" bin_digit ("_"* bin_digit)*
int_suffix       ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"

float_literal ::= decimal_integer "." decimal_integer? exponent? float_suffix
exponent      ::= ("e" | "E") ("+" | "-")? decimal_integer
float_suffix  ::= "f" | "f16" | "f32" | "f64"
```

**Float Suffix Requirement.**
Float literals MUST have a suffix. The suffix `f` indicates a float literal with width inferred from context; explicit suffixes `f16`, `f32`, `f64` specify the width directly. When `f` is used without a contextual type expectation, the literal defaults to `f32`. Using an explicit width suffix with a conflicting expected type is an error (e.g., `let x: f32 = 1.0f64` is ill-formed). This requirement avoids lexical ambiguity with tuple element access (e.g., `t.0.0` is unambiguously parsed as tuple access, not `t` followed by float `0.0`).

```ebnf
string_literal   ::= '"' (string_char | escape_sequence)* '"'
string_char      ::= string_char_unit
escape_sequence  ::= "\n" | "\r" | "\t" | "\\" | "\"" | "\'" | "\0" | "\x" hex_digit hex_digit | "\u{" hex_digit+ "}"

char_literal ::= "'" (char_content | escape_sequence) "'"
char_content ::= char_content_unit

bool_literal ::= "true" | "false"
null_literal ::= "null"
```

**Escape Validity.**
SimpleEscape = {`\\`, `\"`, `\'`, `\n`, `\r`, `\t`, `\0`}
EscapeOk(`\\`) âˆ§ EscapeOk(`\"`) âˆ§ EscapeOk(`\'`) âˆ§ EscapeOk(`\n`) âˆ§ EscapeOk(`\r`) âˆ§ EscapeOk(`\t`) âˆ§ EscapeOk(`\0`)
EscapeOk("\\x" h_1 h_2) â‡” HexDigit(h_1) âˆ§ HexDigit(h_2)
EscapeOk("\\u{" h_1 â€¦ h_n "}") â‡” 1 â‰¤ n â‰¤ 6 âˆ§ UnicodeScalar(HexValue(h_1 â€¦ h_n))

StringChar(c) â‡” UnicodeScalar(c) âˆ§ c â‰  "\"" âˆ§ c â‰  "\\" âˆ§ c â‰  U+000A
CharContent(c) â‡” UnicodeScalar(c) âˆ§ c â‰  "'" âˆ§ c â‰  "\\" âˆ§ c â‰  U+000A
string_char_unit = { c | StringChar(c) }
char_content_unit = { c | CharContent(c) }

**Underscore Constraints.**
BasePrefix = {"0x", "0o", "0b"}
IntSuffixSet = {"i8", "i16", "i32", "i64", "i128", "u8", "u16", "u32", "u64", "u128", "isize", "usize"}
FloatSuffixSet = {"f", "f16", "f32", "f64"}
NumSuffix = IntSuffixSet âˆª FloatSuffixSet
StartsWithUnderscore(s) â‡” At(s, 0) = "_"
EndsWithUnderscore(s) â‡” At(s, |s|-1) = "_"
AfterBasePrefixUnderscore(s) â‡” âˆƒ p âˆˆ BasePrefix. StartsWith(s, Concat(p, "_"))
AdjacentExponentUnderscore(s) â‡” âˆƒ i. At(s, i) = "_" âˆ§ ((i > 0 âˆ§ At(s, i-1) âˆˆ {"e", "E"}) âˆ¨ (i+1 < |s| âˆ§ At(s, i+1) âˆˆ {"e", "E"}))
BeforeSuffixUnderscore(s) â‡” âˆƒ suf âˆˆ NumSuffix. EndsWith(s, Concat("_", suf))
NumericUnderscoreOk(s) â‡” Â¬ StartsWithUnderscore(s) âˆ§ Â¬ EndsWithUnderscore(s) âˆ§ Â¬ AfterBasePrefixUnderscore(s) âˆ§ Â¬ AdjacentExponentUnderscore(s) âˆ§ Â¬ BeforeSuffixUnderscore(s)

**Numeric Scan (Maximal Prefix).**

DecRun(T, i) = max({i} âˆª { j | i < j â‰¤ |T| âˆ§ âˆ€ k âˆˆ [i, j). (DecDigit(T[k]) âˆ¨ T[k] = "_") })
HexRun(T, i) = max({i} âˆª { j | i < j â‰¤ |T| âˆ§ âˆ€ k âˆˆ [i, j). (HexDigit(T[k]) âˆ¨ T[k] = "_") })
OctRun(T, i) = max({i} âˆª { j | i < j â‰¤ |T| âˆ§ âˆ€ k âˆˆ [i, j). (OctDigit(T[k]) âˆ¨ T[k] = "_") })
BinRun(T, i) = max({i} âˆª { j | i < j â‰¤ |T| âˆ§ âˆ€ k âˆˆ [i, j). (BinDigit(T[k]) âˆ¨ T[k] = "_") })

SuffixMatch(T, i, U) = max({i} âˆª { j | i < j â‰¤ |T| âˆ§ Lexeme(T, i, j) âˆˆ U })

ExpSignEnd(T, i) =
 i+1  if i < |T| âˆ§ T[i] âˆˆ {"+", "-"}
 i    otherwise

ExpEnd(T, i) =
 DecRun(T, ExpSignEnd(T, i+1))  if i < |T| âˆ§ T[i] âˆˆ {"e", "E"}
 i                              otherwise

DecCoreEnd(T, i) =
 ExpEnd(T, q)  if p = DecRun(T, i) âˆ§ p < |T| âˆ§ T[p] = "." âˆ§ q = DecRun(T, p+1)
 ExpEnd(T, p)  if p = DecRun(T, i) âˆ§ (p â‰¥ |T| âˆ¨ T[p] â‰  ".")

NumericCoreEnd(T, i) =
 HexRun(T, i+2)  if T[i..i+2] = "0x"
 OctRun(T, i+2)  if T[i..i+2] = "0o"
 BinRun(T, i+2)  if T[i..i+2] = "0b"
 DecCoreEnd(T, i)  otherwise

NumericScanEnd(T, i) = SuffixMatch(T, NumericCoreEnd(T, i), NumSuffix)

HasDot(T, i, j) â‡” âˆƒ p. i â‰¤ p < j âˆ§ T[p] = "."
HasExp(T, i, j) â‡” âˆƒ p. i â‰¤ p < j âˆ§ T[p] âˆˆ {"e", "E"}

NumericKind(T, i) =
 FloatLiteral  if SuffixMatch(T, NumericCoreEnd(T, i), FloatSuffixSet) > NumericCoreEnd(T, i)
 IntLiteral    otherwise

**(Lex-Int)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericKind(T, i) = IntLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IntLiteral(T, i) â‡“ j

**(Lex-Float)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericKind(T, i) = FloatLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FloatLiteral(T, i) â‡“ j

NumericLexemeOk(T, i, j) â‡” (Lexeme(T, i, j) matches integer_literal âˆ¨ Lexeme(T, i, j) matches float_literal) âˆ§ NumericUnderscoreOk(Lexeme(T, i, j))
NumericLexemeBad(T, i, j) â‡” Â¬ NumericLexemeOk(T, i, j)

**(Lex-Numeric-Err)**
DecDigit(T[i])    j = NumericScanEnd(T, i)    NumericLexemeBad(T, i, j)    c = Code(Lex-Numeric-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, i, j))

**Leading Zeros.**
Digits(s) = Remove(s, "_")
DecimalLeadingZero(T, i, j) â‡” Lexeme(T, i, j) matches decimal_integer âˆ§ |Digits(Lexeme(T, i, j))| > 1 âˆ§ At(Digits(Lexeme(T, i, j)), 0) = '0'

DecimalLeadingZero(T, i, j)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(W-SRC-0301, SpanOfText(S, i, j))

**EscapeSequences.**
EscapeValue(`\\`) = 0x5C
EscapeValue(`\"`) = 0x22
EscapeValue(`\'`) = 0x27
EscapeValue(`\n`) = 0x0A
EscapeValue(`\r`) = 0x0D
EscapeValue(`\t`) = 0x09
EscapeValue(`\0`) = 0x00
EscapeValue("\\x" h_1 h_2) = HexValue(h_1 h_2)
EscapeValue("\\u{" h_1 â€¦ h_n "}") = EncodeUTF8(HexValue(h_1 â€¦ h_n))

**(Lex-String)**
Lexeme(T, i, j) matches string_literal
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringLiteral(T, i) â‡“ j

BackslashCount(T, p) = max{ k | 0 â‰¤ k â‰¤ p âˆ§ âˆ€ r âˆˆ [p-k, p). T[r] = "\\" }
UnescapedQuote(T, p) â‡” T[p] = "\"" âˆ§ BackslashCount(T, p) mod 2 = 0
StringTerminator(T, i) = min{ q | q > i âˆ§ (UnescapedQuote(T, q) âˆ¨ T[q] = LF âˆ¨ q = |T|) }
LineFeedOrEOFBeforeClose(T, i) â‡” StringTerminator(T, i) = |T| âˆ¨ T[StringTerminator(T, i)] = LF
EscapeMatch(T, p, q) â‡” Lexeme(T, p, q) matches escape_sequence âˆ§ EscapeOk(Lexeme(T, p, q))
BadEscapeAt(T, p) â‡” T[p] = "\\" âˆ§ Â¬ âˆƒ q. EscapeMatch(T, p, q)
FirstBadEscape(T, i) = min{ p | i < p < StringTerminator(T, i) âˆ§ BadEscapeAt(T, p) }

**(Lex-String-Unterminated)**
LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-String-Unterminated)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, i, i+1))

**(Lex-String-BadEscape)**
FirstBadEscape(T, i) = p    c = Code(Lex-String-BadEscape)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, p, p+1))

**(Lex-Char)**
Lexeme(T, i, j) matches char_literal
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CharLiteral(T, i) â‡“ j

**Character Literal Encoding.**
CharValueRange = { x | 0 â‰¤ x â‰¤ 0x10FFFF âˆ§ x âˆ‰ [0xD800, 0xDFFF] }
CharRepr = `u32`
SizeOf(`char`) = 4
AlignOf(`char`) = 4

UnescapedApostrophe(T, p) â‡” T[p] = "'" âˆ§ BackslashCount(T, p) mod 2 = 0
CharTerminator(T, i) = min{ q | q > i âˆ§ (UnescapedApostrophe(T, q) âˆ¨ T[q] = LF âˆ¨ q = |T|) }
CharLiteralInvalid(T, i) â‡” CharScalarCount(T, i) â‰  1
CharScalarCountFrom(T, p, q) = 0 â‡” p â‰¥ q
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, p+1, q) â‡” p < q âˆ§ T[p] â‰  "\\"
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, r, q) â‡” p < q âˆ§ T[p] = "\\" âˆ§ EscapeMatch(T, p, r)
CharScalarCountFrom(T, p, q) = 1 + CharScalarCountFrom(T, p+1, q) â‡” p < q âˆ§ T[p] = "\\" âˆ§ Â¬ âˆƒ r. EscapeMatch(T, p, r)
CharScalarCount(T, i) = CharScalarCountFrom(T, i+1, CharTerminator(T, i))

**(Lex-Char-Unterminated)**
LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-Char-Unterminated)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, i, i+1))

**(Lex-Char-BadEscape)**
FirstBadEscape(T, i) = p    c = Code(Lex-Char-BadEscape)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, p, p+1))

**(Lex-Char-Invalid)**
CharLiteralInvalid(T, i)    c = Code(Lex-Char-Invalid)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, i, i+1))

**Literal Tokenization Helpers.**

StringTok(T, i) = { (StringLiteral, j) | StringLiteral(T, i) â‡“ j }
CharTok(T, i) = { (CharLiteral, j) | CharLiteral(T, i) â‡“ j }
IntTok(T, i) = { (IntLiteral, j) | IntLiteral(T, i) â‡“ j }
FloatTok(T, i) = { (FloatLiteral, j) | FloatLiteral(T, i) â‡“ j }

#### 3.2.7. Identifier and Keyword Lexing

T = S.scalars

**Identifier Scan.**
IdentScanEnd(T, i) = min{ j | j > i âˆ§ (Â¬ IdentContinue(T[j]) âˆ¨ j = |T|) âˆ§ âˆ€ k âˆˆ (i, j). IdentContinue(T[k]) }

**(Lex-Identifier)**
IdentStart(T[i])    j = IdentScanEnd(T, i)    s = Lexeme(T, i, j)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Ident(T, i) â‡“ (s, j)

**(Lex-Ident-InvalidUnicode)**
k = min{ p | i â‰¤ p < j âˆ§ NonCharacter(T[p]) }    c = Code(Lex-Ident-InvalidUnicode)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, SpanOfText(S, k, k+1))

**(Lex-Ident-Token)**
Î“ âŠ¢ Ident(T, i) â‡“ (s, j)    Î“ âŠ¢ ClassifyIdent(s) â‡“ k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IdentToken(T, i) â‡“ (k, j)

**Keyword Classification.**
ClassifyIdent(s) =
 BoolLiteral  if s âˆˆ {"true", "false"}
 NullLiteral  if s = "null"
 Keyword(s)   if Keyword(s)
 Identifier   otherwise

#### 3.2.8. Operator and Punctuator Lexing

OpSet = OperatorSet
PuncSet = PunctuatorSet

OpMatch(T, i) = { (o, j) | o âˆˆ OpSet âˆ§ Lexeme(T, i, j) = o }
PuncMatch(T, i) = { (p, j) | p âˆˆ PuncSet âˆ§ Lexeme(T, i, j) = p }

OpTok(T, i) = { (Operator(o), j) | (o, j) âˆˆ OpMatch(T, i) }
PuncTok(T, i) = { (Punctuator(p), j) | (p, j) âˆˆ PuncMatch(T, i) }

#### 3.2.9. Maximal-Munch Rule

T = S.scalars

IsQuote(c) â‡” c âˆˆ {"\"", "'"}
Candidates(T, i) =
 StringTok(T, i) âˆª CharTok(T, i)  if IsQuote(T[i])
 FloatTok(T, i) âˆª IntTok(T, i)    if DecDigit(T[i])
 IdentToken(T, i)                 if IdentStart(T[i])
 OpTok(T, i) âˆª PuncTok(T, i)       if OpTok(T, i) â‰  âˆ… âˆ¨ PuncTok(T, i) â‰  âˆ…
 âˆ…                                otherwise

Longest(C) = { (k, j) âˆˆ C | âˆ€ (k', j') âˆˆ C, j â‰¥ j' }

KindPriority(IntLiteral) = 3
KindPriority(FloatLiteral) = 3
KindPriority(StringLiteral) = 3
KindPriority(CharLiteral) = 3
KindPriority(BoolLiteral) = 3
KindPriority(NullLiteral) = 3
KindPriority(Identifier) = 2
KindPriority(Keyword(_)) = 2
KindPriority(Operator(_)) = 1
KindPriority(Punctuator(_)) = 0

PickLongest(C) = argmax_{(k, j) âˆˆ C} âŸ¨j, KindPriority(k)âŸ©

**(Max-Munch)**
PickLongest(C) = (k, j)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NextToken(T, i) â‡“ (k, j)

**(Max-Munch-Err)**
Candidates(T, i) = âˆ…    c = Code(Max-Munch-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NextToken(T, i) â‡‘ c

SpanOfErr(Max-Munch-Err, S, i) = SpanOfText(S, i, i+1)

GenericCloseException = false

#### 3.2.10. Lexical Security

T = S.scalars
O = Utf8Offsets(T)

**Literal/Comment Ranges.**
LineCommentRange(T, i, j) â‡” Î“ âŠ¢ ScanLineComment(T, i) â‡“ j
BlockCommentRange(T, i, j) â‡” T[i..i+2] = "/*" âˆ§ âŸ¨BlockScan(T, i, 0, i)âŸ© â†’* âŸ¨BlockDone(j)âŸ©
StringRange(T, i, j) â‡” Î“ âŠ¢ StringLiteral(T, i) â‡“ j
CharRange(T, i, j) â‡” Î“ âŠ¢ CharLiteral(T, i) â‡“ j
InsideLiteralOrComment(i) â‡” âˆƒ a, b. a â‰¤ i < b âˆ§ (LineCommentRange(T, a, b) âˆ¨ BlockCommentRange(T, a, b) âˆ¨ StringRange(T, a, b) âˆ¨ CharRange(T, a, b))

**Sensitive Positions in a Span.**

SensitiveInSpan(T, i, j) = [ p | i â‰¤ p < j âˆ§ Sensitive(T[p]) ]

**Unsafe Spans (Token-Only).**

IsLBrace(t) â‡” t.kind = Punctuator("{")
IsRBrace(t) â‡” t.kind = Punctuator("}")

NextNonNewline(K, i) = âŠ¥ â‡” { j | j â‰¥ i âˆ§ K[j].kind â‰  Newline } = âˆ…
NextNonNewline(K, i) = j â‡” j = min{ j | j â‰¥ i âˆ§ K[j].kind â‰  Newline }

MatchBrace(K, j) = min{ k | k > j âˆ§ Balance(j, k) = 0 âˆ§ âˆ€ m âˆˆ (j, k), Balance(j, m) > 0 }

Balance(K, j, m) = |{ x | j â‰¤ x â‰¤ m âˆ§ IsLBrace(K[x]) }| - |{ x | j â‰¤ x â‰¤ m âˆ§ IsRBrace(K[x]) }|
MatchBrace(K, j) = âŠ¥ â‡” { k | k > j âˆ§ Balance(K, j, k) = 0 âˆ§ âˆ€ m âˆˆ (j, k). Balance(K, j, m) > 0 } = âˆ…

SpanFrom(t_a, t_b) = âŸ¨t_a.span.file, t_a.span.start_offset, t_b.span.end_offset, t_a.span.start_line, t_a.span.start_col, t_b.span.end_line, t_b.span.end_colâŸ©

UnsafeSpans(K) = { SpanFrom(K[j], K[k]) | K[i].kind = Keyword("unsafe"), j = NextNonNewline(K, i+1), K[j].kind = Punctuator("{"), k = MatchBrace(K, j), k â‰  âŠ¥ }

UnsafeAtByte(b) â‡” âˆƒ sp âˆˆ UnsafeSpans(K). b âˆˆ SpanRange(sp)

UnsafeSpanMode = TokenOnly

**Lexical Security Check.**
Sens = [ p | Sensitive(T[p]) âˆ§ Â¬ InsideLiteralOrComment(p) ]

**(LexSecure-Err)**
i = min{ p | p âˆˆ Sens âˆ§ Â¬ UnsafeAtByte(ByteOf(T, p)) }    c = Code(LexSecure-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LexSecure(S, K, Sens) â‡‘ c

**(LexSecure-Warn)**
âˆ€ p âˆˆ Sens, UnsafeAtByte(ByteOf(T, p))    Î“ âŠ¢ EmitList(LexSecureWarns(S, Sens))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LexSecure(S, K, Sens) â‡“ ok

LexSecureWarns(S, Sens) = [ âŸ¨W-SRC-0308, SpanOfText(S, p, p+1)âŸ© | p âˆˆ Sens ]
LexSecureErrSpan(S, i) = SpanOfText(S, i, i+1)

#### 3.2.11. Tokenization (Small-Step)

LexState = {LexStart(S), LexScan(S, i, K, D, Sens), LexDone(K, D, Sens), LexError(code)}
T = S.scalars
|T| = len(T)

**(Lex-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexStart(S)âŸ© â†’ âŸ¨LexScan(S, 0, [], [], [])âŸ©

**(Lex-End)**
i â‰¥ |T|
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexDone(K, D, Sens)âŸ©

**(Lex-Whitespace)**
Whitespace(T[i])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, i+1, K, D, Sens)âŸ©

**(Lex-Newline)**
T[i] = LF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, i+1, K ++ [âŸ¨newline, Lexeme(T, i, i+1), SpanOfText(S, i, i+1)âŸ©], D, Sens)âŸ©

**(Lex-Line-Comment)**
T[i..i+2] = "//"    T[i..i+3] âˆ‰ {"///", "//!"}    Î“ âŠ¢ ScanLineComment(T, i) â‡“ j
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K, D, Sens)âŸ©

**(Lex-Doc-Comment)**
T[i..i+3] âˆˆ {"///", "//!"}    Î“ âŠ¢ ScanLineComment(T, i) â‡“ j    Î“ âŠ¢ DocComment(T, i) â‡“ d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K, D ++ [d], Sens)âŸ©

**(Lex-Block-Comment)**
T[i..i+2] = "/*"    âŸ¨BlockScan(T, i, 0, i)âŸ© â†’* âŸ¨BlockDone(j)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K, D, Sens)âŸ©

**(Lex-String-Unterminated-Recover)**
T[i] = "\""    LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-String-Unterminated)    Î“ âŠ¢ Emit(c, SpanOfText(S, i, i+1))    j = StringTerminator(T, i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K, D, Sens)âŸ©

**(Lex-Char-Unterminated-Recover)**
T[i] = "'"    LineFeedOrEOFBeforeClose(T, i)    c = Code(Lex-Char-Unterminated)    Î“ âŠ¢ Emit(c, SpanOfText(S, i, i+1))    j = CharTerminator(T, i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K, D, Sens)âŸ©

**(Lex-Sensitive)**
Sensitive(T[i])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, i+1, K, D, Sens ++ [i])âŸ©

SensitiveTok(T, i, j, k) =
 []                    if k âˆˆ {StringLiteral, CharLiteral}
 SensitiveInSpan(T, i, j)  otherwise

**(Lex-Token)**
Â¬ Whitespace(T[i])    T[i] â‰  LF    T[i..i+2] âˆ‰ {"//", "/*"}    Â¬ Sensitive(T[i])    Î“ âŠ¢ NextToken(T, i) â‡“ (k, j)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexScan(S, j, K ++ [âŸ¨k, Lexeme(T, i, j), SpanOfText(S, i, j)âŸ©], D, Sens ++ SensitiveTok(T, i, j, k))âŸ©

**(Lex-Token-Err)**
Â¬ Whitespace(T[i])    T[i] â‰  LF    T[i..i+2] âˆ‰ {"//", "/*"}    Â¬ (T[i] = "\"" âˆ§ LineFeedOrEOFBeforeClose(T, i))    Â¬ (T[i] = "'" âˆ§ LineFeedOrEOFBeforeClose(T, i))    Â¬ Sensitive(T[i])    Î“ âŠ¢ NextToken(T, i) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨LexScan(S, i, K, D, Sens)âŸ© â†’ âŸ¨LexError(c)âŸ©

#### 3.2.12. Tokenize (Big-Step)

**(Tokenize-Ok)**
âŸ¨LexStart(S)âŸ© â†’* âŸ¨LexDone(K, D, Sens)âŸ©    Î“ âŠ¢ LexSecure(S, K, Sens) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Tokenize(S) â‡“ (K, D)

**(Tokenize-Secure-Err)**
âŸ¨LexStart(S)âŸ© â†’* âŸ¨LexDone(K, D, Sens)âŸ©    Î“ âŠ¢ LexSecure(S, K, Sens) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Tokenize(S) â‡‘ c

**(Tokenize-Err)**
âŸ¨LexStart(S)âŸ© â†’* âŸ¨LexError(c)âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Tokenize(S) â‡‘ c

Phase1LexDiagRefs = {"8.4", "8.5", "8.8"}

### 3.3. Grammar, Parsing, and AST Construction

#### 3.3.1. Inputs, Outputs, and Invariants

**Inputs.**
ParseInputs(U, K, D, K') â‡” U = [S_1, â€¦, S_n] âˆ§ K = [K_1, â€¦, K_n] âˆ§ D = [D_1, â€¦, D_n] âˆ§ (âˆ€ i. Î“ âŠ¢ Tokenize(S_i) â‡“ (K_i, D_i)) âˆ§ K' = [Filter(K_i) | 1 â‰¤ i â‰¤ n]
ParseUnitSources(U) â‡” âˆƒ d, f_1, â€¦, f_n, B_1, â€¦, B_n. CompilationUnit(d) = [f_1, â€¦, f_n] âˆ§ U = [S_1, â€¦, S_n] âˆ§ âˆ§_{i=1}^n (Î“ âŠ¢ ReadBytes(f_i) â‡“ B_i âˆ§ Î“ âŠ¢ LoadSource(f_i, B_i) â‡“ S_i)

**Outputs.**
ParseOutputs(U, F) â‡” Î“ âŠ¢ ParseUnit(U) â‡“ F
F = [F_1, â€¦, F_n]

ModuleAggregationRef = {"3.4.1", "3.4.2"}

**Parsing Phase Invariants.**

**(Phase1-Complete)**
âˆ€ i, Î“ âŠ¢ ParseFile(S_i) â‡“ F_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnit(U) â‡“ [F_1, â€¦, F_n]

PhaseExec(Phase1, U) â‡” Î“ âŠ¢ ParseUnit(U) â‡“ F
âˆ€ p âˆˆ {Phase2, Phase3, Phase4}. PhaseExec(p, U) â‡’ PhaseExec(Phase1, U)

**(Phase1-Declarations)**
Î“ âŠ¢ ParseUnit(U) â‡“ [F_1, â€¦, F_n]    âˆ€ i, F_i.items = I_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AllDecls(U) = I_1 ++ â€¦ ++ I_n

**(Phase1-Forward-Refs)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePhase(U) â‡“ NoResolutionConstraints

#### 3.3.2. AST Node Catalog (Cursive0 Subset)

ASTNode = ASTItem âˆª ASTExpr âˆª ASTPattern âˆª ASTType âˆª ASTStmt
SpanOfNode : ASTNode â†’ Span
DocOf : ASTNode â†’ (DocList âˆª {âŠ¥})

SpanDefault(P, P') = SpanBetween(P, P')
DocDefault = []
DocOptDefault = âŠ¥
FillSpan(n, P, P') =
 n[span := SpanDefault(P, P')]  if SpanMissing(n)
 n                             otherwise
FillDoc(n) =
 n[doc := DocDefault]  if DocMissing(n)
 n                     otherwise
FillDocOpt(n) =
 n[doc_opt := DocOptDefault]  if DocOptMissing(n)
 n                            otherwise
ParseCtor(n, P, P') = FillDocOpt(FillDoc(FillSpan(n, P, P')))
DocAssociationRef = {"3.3.11"}

**Doc Lists.**

DocList = [DocComment]
DocCommentRef = {"3.2.1"}

**Paths.**

Path = [identifier]
ModulePath = Path
TypePath = Path
ClassPath = Path
PathString(p) = StringOfPath(p)
StringOfPathRef = {"3.4.1"}

##### 3.3.2.1. Module and Files

**ASTModule.**

ASTModule = âŸ¨path, items, module_docâŸ©
ASTModule.path âˆˆ Path
ASTModule.items âˆˆ [ASTItem]
ASTModule.module_doc âˆˆ DocList

**ASTFile.**

ASTFile = âŸ¨path, items, module_docâŸ©
ASTFile.path âˆˆ Path
ASTFile.items âˆˆ [ASTItem]
ASTFile.module_doc âˆˆ DocList

**Attributes.**

AttrName ::= identifier | âŸ¨vendor_prefix, identifierâŸ©
vendor_prefix ::= identifier ("." identifier)*
AttrArg ::= literal | identifier | âŸ¨name, literalâŸ© | âŸ¨name, argsâŸ©
AttributeSpec ::= Attr(name: AttrName, args: [AttrArg])
AttributeList ::= [AttributeSpec]
AttrOpt ::= {âŠ¥} âˆª AttributeList

##### 3.3.2.2. Items

ASTItem âˆˆ {ImportDecl, UsingDecl, ExternBlock, StaticDecl, ProcedureDecl, RecordDecl, EnumDecl, ModalDecl, ClassDecl, TypeAliasDecl, ErrorItem}

**ImportDecl.**

ImportDecl = âŸ¨attrs_opt, vis, path, alias_opt, span, docâŸ©

**UsingDecl.**

UsingDecl = âŸ¨attrs_opt, vis, clause, span, docâŸ©

**UsingClause.**

UsingClause âˆˆ {UsingPath = âŸ¨path, alias_optâŸ©, UsingList = âŸ¨module_path, specsâŸ©, UsingWildcard = âŸ¨module_pathâŸ©}

UsingSpec = âŸ¨name, alias_optâŸ©    name âˆˆ {identifier, `self`}

**ExternBlock.**

ExternBlock = âŸ¨attrs_opt, vis, abi_opt, items, span, docâŸ©
ExternItem âˆˆ {ExternProcDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, return_type_opt, contract_opt, foreign_contracts_opt, span, docâŸ©}
abi_opt âˆˆ {âŠ¥} âˆª ExternAbi
ExternAbi âˆˆ {StringAbi, IdentAbi}

**StaticDecl.**

StaticDecl = âŸ¨attrs_opt, vis, mut, binding, span, docâŸ©

mut âˆˆ {`let`, `var`}

**ProcedureDecl.**

ProcedureDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, return_type_opt, contract_opt, body, span, docâŸ©

**RecordDecl.**

RecordDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, implements, members, invariant_opt, span, docâŸ©

RecordDecl.implements âˆˆ [ClassPath]

RecordMember âˆˆ {FieldDecl = âŸ¨attrs_opt, vis, boundary, name, type, init_opt, span, doc_optâŸ©, MethodDecl = âŸ¨attrs_opt, vis, override, name, gen_params_opt, receiver, params, return_type_opt, contract_opt, body, span, doc_optâŸ©}
Receiver âˆˆ {ReceiverShorthand(perm), ReceiverExplicit(mode_opt, type)}
perm âˆˆ {`const`, `unique`, `shared`}
mode_opt âˆˆ {`move`, âŠ¥}
boundary âˆˆ {true, false}

**EnumDecl.**

EnumDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, implements, variants, invariant_opt, span, docâŸ©

EnumDecl.implements âˆˆ [ClassPath]

VariantDecl = âŸ¨name, payload_opt, discriminant_opt, span, doc_optâŸ©

VariantPayload âˆˆ {TuplePayload = [Type], RecordPayload = [FieldDecl]}
âˆ€ f âˆˆ RecordPayload. f.init_opt = âŠ¥

**ModalDecl.**

ModalDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, implements, states, invariant_opt, span, docâŸ©

ModalDecl.implements âˆˆ [ClassPath]

StateBlock = âŸ¨name, members, span, doc_optâŸ©

StateMember âˆˆ {StateFieldDecl = âŸ¨attrs_opt, vis, boundary, name, type, span, doc_optâŸ©, StateMethodDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, receiver, params, return_type_opt, contract_opt, body, span, doc_optâŸ©, TransitionDecl = âŸ¨attrs_opt, vis, name, params, target_state, body, span, doc_optâŸ©}

**ClassDecl.**

ClassDecl = âŸ¨attrs_opt, vis, modal_opt, name, gen_params_opt, where_clause_opt, supers, items, span, docâŸ©

ClassDecl.supers âˆˆ [ClassPath]

ClassItem âˆˆ {ClassFieldDecl = âŸ¨attrs_opt, vis, boundary, name, type, span, doc_optâŸ©, ClassMethodDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, receiver, params, return_type_opt, contract_opt, body_opt, span, doc_optâŸ©, AssociatedTypeDecl = âŸ¨attrs_opt, vis, name, type_opt, span, doc_optâŸ©, AbstractStateDecl = âŸ¨attrs_opt, vis, name, fields, span, doc_optâŸ©}
AbstractClassMethod(m) â‡” âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, span, doc. m = ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, âŠ¥, span, doc)
ConcreteClassMethod(m) â‡” âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. m = ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) âˆ§ body â‰  âŠ¥
AbstractStateDecl.fields âˆˆ [ClassFieldDecl]

**TypeAliasDecl.**

TypeAliasDecl = âŸ¨attrs_opt, vis, name, gen_params_opt, where_clause_opt, type, span, docâŸ©

**Generic Parameters and Where Clauses.**

Variance = {Covariant, Contravariant, Invariant, Bivariant}
TypeParam = âŸ¨name, bounds, default_opt, varianceâŸ©
GenericParams = [TypeParam]
GenericArgs = [Type]
PredicateName = {`Bitcopy`, `Clone`, `Drop`, `FfiSafe`}
PredWherePred = âŸ¨pred, typeâŸ©
WherePred = PredWherePred
WhereClause = [WherePred]
gen_params_opt âˆˆ {âŠ¥} âˆª GenericParams
where_clause_opt âˆˆ {âŠ¥} âˆª WhereClause

**Contracts and Invariants.**

ContractClause = âŸ¨pre, postâŸ©
Invariant = Expr
contract_opt âˆˆ {âŠ¥} âˆª ContractClause
invariant_opt âˆˆ {âŠ¥} âˆª Invariant
modal_opt âˆˆ {true, false}
ForeignContractKind = {ForeignAssumes, ForeignEnsures}
EnsuresPredicate = {Ensures(pred), EnsuresError(pred), EnsuresNullResult(pred)}    pred âˆˆ Expr
ForeignContractClause = âŸ¨kind, predsâŸ©
  kind âˆˆ ForeignContractKind
  preds âˆˆ [Expr]              if kind = ForeignAssumes
  preds âˆˆ [EnsuresPredicate]  if kind = ForeignEnsures
foreign_contracts_opt âˆˆ {âŠ¥} âˆª [ForeignContractClause]

**Key System (AST).**

KeyMode = {Read, Write}
KeyModeOpt âˆˆ {âŠ¥} âˆª KeyMode
KeyBlockMod = {Dynamic, Speculative, Release}
KeyBlockMods = [KeyBlockMod]
KeySeg = {Field(marked, name), Index(marked, expr)}    marked âˆˆ {true, false}
KeyPathExpr = âŸ¨root, segsâŸ©
KeyPathList = [KeyPathExpr]
KeyBlockStmt = âŸ¨paths, mods, mode_opt, bodyâŸ©

**Concurrency (AST).**

ParallelOpt = {Cancel(expr), Name(str)}
ParallelOpts = [ParallelOpt]
SpawnOpt = {Name(str), Affinity(expr), Priority(expr)}
SpawnOpts = [SpawnOpt]
ReduceOp = {`+`, `*`} âˆª Identifier
DispatchOpt = {Reduce(op), Ordered, Chunk(expr)}    op âˆˆ ReduceOp
DispatchOpts = [DispatchOpt]
YieldReleaseOpt âˆˆ {âŠ¥} âˆª {Release}
RaceHandler = {RaceReturn(expr), RaceYield(expr)}
RaceArm = âŸ¨expr, pat, handlerâŸ©    handler âˆˆ RaceHandler
RaceArms = [RaceArm]
AliasBodyRef = {"6.1.4"}
AliasStep(TypePath(p)) = AliasBody(p) if defined; otherwise TypePath(p)
AliasStep(T) = T if T âˆ‰ {TypePath(p)}
AliasNorm(T) =
 TypePerm(perm, AliasNorm(base))  if T = TypePerm(perm, base)
 TypeTuple([AliasNorm(t) | t âˆˆ elems])  if T = TypeTuple(elems)
 TypeArray(AliasNorm(elem), size_expr)  if T = TypeArray(elem, size_expr)
 TypeSlice(AliasNorm(elem))  if T = TypeSlice(elem)
 TypeUnion([AliasNorm(t) | t âˆˆ members])  if T = TypeUnion(members)
 TypeFunc([âŸ¨m, AliasNorm(t)âŸ© | âŸ¨m, tâŸ© âˆˆ params], AliasNorm(ret))  if T = TypeFunc(params, ret)
 TypeApply(AliasPath(path), [AliasNorm(t) | t âˆˆ args])  if T = TypeApply(path, args)
 TypeDynamic(AliasPath(path))  if T = TypeDynamic(path)
 TypeOpaque(AliasPath(path))  if T = TypeOpaque(path)
 TypeModalState(AliasModalRef(modal_ref), state)  if T = TypeModalState(modal_ref, state)
 TypePtr(AliasNorm(elem), ptr_state_opt)  if T = TypePtr(elem, ptr_state_opt)
 TypeRawPtr(qual, AliasNorm(elem))  if T = TypeRawPtr(qual, elem)
 TypeRefine(AliasNorm(base), pred)  if T = TypeRefine(base, pred)
 AliasNorm(AliasStep(T))  if T = TypePath(p)
 T  otherwise
AliasPath(p) = p if AliasBody(p) undefined
AliasPath(p) = AliasPath(p') if AliasBody(p) = TypePath(p')
AliasModalRef(TypePath(p)) = TypePath(AliasPath(p))
AliasModalRef(TypeApply(p, args)) = TypeApply(AliasPath(p), [AliasNorm(t) | t âˆˆ args])
AliasTransparent(T, U) â‡” AliasNorm(T) = AliasNorm(U)
AliasGraph = { âŸ¨p, qâŸ© | AliasBody(p) = T âˆ§ q âˆˆ TypePaths(T) }
TypePaths(TypePrim(_)) = âˆ…
TypePaths(TypeRange) = âˆ…
TypePaths(TypePerm(_, T)) = TypePaths(T)
TypePaths(TypeTuple([T_1, â€¦, T_n])) = â‹ƒ_{i=1}^n TypePaths(T_i)
TypePaths(TypeArray(T, _)) = TypePaths(T)
TypePaths(TypeSlice(T)) = TypePaths(T)
TypePaths(TypeUnion([T_1, â€¦, T_n])) = â‹ƒ_{i=1}^n TypePaths(T_i)
TypePaths(TypeFunc([âŸ¨_, T_1âŸ©, â€¦, âŸ¨_, T_nâŸ©], R)) = (â‹ƒ_{i=1}^n TypePaths(T_i)) âˆª TypePaths(R)
TypePaths(TypeApply(p, args)) = {p} âˆª (â‹ƒ_{t âˆˆ args} TypePaths(t))
TypePaths(TypePtr(T, _)) = TypePaths(T)
TypePaths(TypeRawPtr(_, T)) = TypePaths(T)
TypePaths(TypeString(_)) = âˆ…
TypePaths(TypeBytes(_)) = âˆ…
TypePaths(TypeDynamic(p)) = {p}
TypePaths(TypeOpaque(p)) = {p}
TypePaths(TypeModalState(modal_ref, _)) = TypePathsOfModalRef(modal_ref)
TypePaths(TypePath(p)) = {p}
TypePaths(TypeRefine(base, _)) = TypePaths(base)
TypePathsOfModalRef(TypePath(p)) = {p}
TypePathsOfModalRef(TypeApply(p, args)) = {p} âˆª (â‹ƒ_{t âˆˆ args} TypePaths(t))
AliasCycle(p) â‡” p âˆˆ Reach^+(AliasGraph, p)
**(TypeAlias-Recursive-Err)**
AliasCycle(p)    c = Code(TypeAlias-Recursive-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : TypeAliasOk â‡‘ c
**(TypeAlias-Ok)**
Î£.Types[p] = TypeAliasDecl(_, _, _, gen_params_opt, where_clause_opt, ty, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    Î“_g âŠ¢ ty wf    Â¬ AliasCycle(p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : TypeAliasOk

**ErrorItem.**

ErrorItem = âŸ¨spanâŸ©
IsDecl(ErrorItem(_)) = false

##### 3.3.2.3. Types

**Type.**
Type = {TypePerm(perm, base), TypePrim(name), TypeTuple(elems), TypeArray(elem, size_expr), TypeSlice(elem), TypeUnion(members), TypeFunc(params, ret), TypePath(path), TypeApply(path, args), TypeDynamic(path), TypeOpaque(path), TypeRefine(base, pred), TypeString(string_state_opt), TypeBytes(bytes_state_opt), TypeModalState(modal_ref, state), TypePtr(elem, ptr_state_opt), TypeRawPtr(qual, elem), TypeRange}
TypeApply = âŸ¨path, argsâŸ©
TypeOpaque = âŸ¨pathâŸ©
TypeRefine = âŸ¨base, predâŸ©

Perm = {`const`, `unique`, `shared`}
Qual = {`imm`, `mut`}
PtrStateOpt = {âŠ¥, `Valid`, `Null`, `Expired`}
StringStateOpt = {âŠ¥, `@Managed`, `@View`}
BytesStateOpt = {âŠ¥, `@Managed`, `@View`}
Name âˆˆ PrimTypes_C0

ParamMode = {`move`, âŠ¥}
ParamType = âŸ¨mode, typeâŸ© where mode âˆˆ ParamMode âˆ§ type âˆˆ Type

TypeRangeSyntax = âŠ¥

**Range Record.**
RangeFieldType(`kind`) = `u8`
RangeFieldType(`lo`) = `usize`
RangeFieldType(`hi`) = `usize`

##### 3.3.2.4. Expressions

**Literal Tokens.**
LiteralKind = {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
LiteralToken = { t âˆˆ Token | t.kind âˆˆ LiteralKind }

**Expr.**
RangeKind = {`To`, `ToInclusive`, `Full`, `From`, `Exclusive`, `Inclusive`}
Expr = {Literal(lit), PtrNullExpr, Identifier(name), QualifiedName(path, name), QualifiedApply(path, name, form), Path(path, name), ErrorExpr(span), TupleExpr(elems), ArrayExpr(elems), RecordExpr(type_ref, fields), EnumLiteral(path, payload_opt), FieldAccess(base, name), TupleAccess(base, index), IndexAccess(base, index_expr), Call(callee, args), CallTypeArgs(callee, type_args, args), MethodCall(base, name, args), Unary(op, expr), Binary(op, left, right), Cast(expr, type), Range(kind, lo_opt, hi_opt), IfExpr(cond, then_block, else_opt), MatchExpr(scrutinee, arms), LoopInfinite(inv_opt, body), LoopConditional(cond, inv_opt, body), LoopIter(pattern, type_opt, iter, inv_opt, body), BlockExpr(stmts, tail_opt), UnsafeBlockExpr(body), MoveExpr(place), TransmuteExpr(src_type, dst_type, expr), AllocExpr(region_opt, expr), Propagate(expr), AddressOf(place), Deref(expr), ContractResult, ContractEntry(expr), ParallelExpr(domain, opts, body), SpawnExpr(opts, body), DispatchExpr(pat, range, key_clause_opt, opts, body), WaitExpr(handle), YieldExpr(release_opt, expr), YieldFromExpr(release_opt, expr), SyncExpr(expr), RaceExpr(arms), AllExpr(exprs)}
ExprSpan : Expr â†’ Span
ExprAttrs(e) âˆˆ AttrOpt
AttachExprAttrs(e, attrs) = e' where ExprAttrs(e') = (attrs ++ ExprAttrs(e) if ExprAttrs(e) â‰  âŠ¥ else attrs) and all other fields of e' equal those of e
LoopInvariantOpt âˆˆ {âŠ¥} âˆª Expr
KeyClause = âŸ¨path, modeâŸ©
KeyClauseOpt âˆˆ {âŠ¥} âˆª KeyClause

ModalRef = {TypePath(path), TypeApply(path, args)}
TypeRef = {TypePath(path), TypeApply(path, args), ModalStateRef(modal_ref, state)}    modal_ref âˆˆ ModalRef

**Qualified Expressions.**
ParenForm = {Paren(args) | args âˆˆ Arg*}
BraceForm = {Brace(fields) | fields âˆˆ FieldInit*}
QualForm = ParenForm âˆª BraceForm
âˆ€ P, P', e. (Î“ âŠ¢ ParseExpr(P) â‡“ (P', e)) â‡’ e âˆ‰ {Path(_, _), EnumLiteral(_, _)}

**Argument.**
Arg = âŸ¨moved, expr, spanâŸ© where moved âˆˆ {true, false}

MovedArg(moved, e) =
 MoveExpr(e)  if moved = true âˆ§ IsPlace(e)
 e            otherwise

**Field Initializer.**
FieldInit = âŸ¨name, exprâŸ©

##### 3.3.2.5. Patterns

Pattern = {LiteralPattern(lit), WildcardPattern, IdentifierPattern(name), TypedPattern(name, type), TuplePattern(elems), RecordPattern(type_path, fields), EnumPattern(type_path, name, payload_opt), ModalPattern(state_name, fields_opt), RangePattern(kind, lo, hi)}
PatternSpan : Pattern â†’ Span

FieldPattern = âŸ¨name, pattern_opt, spanâŸ©

EnumPayloadPattern = {TuplePayloadPattern([Pattern]), RecordPayloadPattern([FieldPattern])}

ModalPayloadPattern = {ModalRecordPayload([FieldPattern])}

##### 3.3.2.6. Statements

Stmt = {LetStmt(binding), VarStmt(binding), ErrorStmt(span), ShadowLetStmt(name, type_opt, init), ShadowVarStmt(name, type_opt, init), AssignStmt(place, expr), CompoundAssignStmt(place, op, expr), ExprStmt(expr), DeferStmt(block), RegionStmt(opts_opt, alias_opt, block), FrameStmt(target_opt, block), KeyBlockStmt(paths, mods, mode_opt, block), ReturnStmt(expr_opt), BreakStmt(expr_opt), ContinueStmt, UnsafeBlockStmt(block)}

binding = âŸ¨pattern, type_opt, op, init, spanâŸ©
opts_opt âˆˆ {âŠ¥} âˆª Expr    alias_opt âˆˆ {âŠ¥} âˆª Identifier
target_opt âˆˆ {âŠ¥} âˆª Identifier

##### 3.3.2.7. Unsupported Grammar Families (Cursive0 Decision)

UnsupportedGrammarFamily = {`metaprogramming`}
UnsupportedGrammarFamily âŠ† UnsupportedForm

#### 3.3.3. Parser State and Judgments

**Parser State.**

PState = âŸ¨K, i, D, j, d, Î”âŸ©

TokStream(P) = K
TokIndex(P) = i
DocStream(P) = D
DocIndex(P) = j
Depth(P) = d
DiagStream(P) = Î”

**Helper Functions.**

Tok(P) =
 K[i]                        if i < |K|
 âŸ¨EOF, Îµ, EOFSpan(K)âŸ©         if i = |K|

SourceOf(K) = S â‡” Î“ âŠ¢ Tokenize(S) â‡“ (K_raw, D) âˆ§ K = Filter(K_raw)
EOFSpan(K) = EOFSpan(SourceOf(K))

Advance(P) = âŸ¨K, i+1, D, j, d, Î”âŸ©
Clone(P) = âŸ¨K, i, D, j, d, []âŸ©
MergeDiag(P_b, P_d, P_s) = âŸ¨TokStream(P_s), TokIndex(P_s), DocStream(P_s), DocIndex(P_s), Depth(P_s), DiagStream(P_b) ++ DiagStream(P_d)âŸ©

**Parser Index Invariant.**
PStateOk(P) â‡” 0 â‰¤ i â‰¤ |K|

AdvanceOrEOF(P) =
 Advance(P)  if i < |K|
 P           if i = |K|

LastConsumed(P, P') =
 K[i'-1]  if i' > i
 Tok(P)   if i' = i
SpanBetween(P, P') = SpanFrom(Tok(P), LastConsumed(P, P'))

SplitSpan2(sp) = (sp_L, sp_R) where
 sp_L.file = sp.file âˆ§ sp_R.file = sp.file
 sp_L.start_offset = sp.start_offset âˆ§ sp_L.end_offset = sp.start_offset + 1
 sp_R.start_offset = sp.start_offset + 1 âˆ§ sp_R.end_offset = sp.start_offset + 2
 sp_L.start_line = sp.start_line âˆ§ sp_L.end_line = sp.start_line
 sp_R.start_line = sp.start_line âˆ§ sp_R.end_line = sp.start_line
 sp_L.start_col = sp.start_col âˆ§ sp_L.end_col = sp.start_col + 1
 sp_R.start_col = sp.start_col + 1 âˆ§ sp_R.end_col = sp.start_col + 2

SplitShiftR(P) = âŸ¨K', i, D, j, d, Î”âŸ©
where Tok(P) = âŸ¨Operator(">>"), ">>", spâŸ© âˆ§ (sp_L, sp_R) = SplitSpan2(sp)
K' = K[0..i) ++ [âŸ¨Operator(">"), ">", sp_LâŸ©, âŸ¨Operator(">"), ">", sp_RâŸ©] ++ K[i+1..]

**Judgments (Big-Step).**
ParseJudgment = {ParseFile, ParseModule, ParseItem, ParseStmt, ParseExpr, ParsePattern, ParseType}

#### 3.3.4. Grammar Subset and Cursive0 Lexeme Policy

**Lexeme Predicates.**
IsIdent(t) â‡” t.kind = Identifier
IsKw(t, s) â‡” t.kind = Keyword(s)
IsOp(t, s) â‡” t.kind = Operator(s)
IsPunc(t, s) â‡” t.kind = Punctuator(s)
Lexeme(t) = t.lexeme

**Contextual Keywords.**
CtxKeyword = {"in", "key", "wait"}
Ctx(t, s) â‡” IsIdent(t) âˆ§ Lexeme(t) = s âˆ§ s âˆˆ CtxKeyword
Â¬ Ctx(t, "as") âˆ§ Â¬ Ctx(t, "move")

**Fixed Identifier Lexemes.**
FixedIdent_Key = {"read", "write", "dynamic", "speculative", "release"}
FixedIdent_Parallel = {"cancel", "name"}
FixedIdent_Spawn = {"name", "affinity", "priority"}
FixedIdent_Dispatch = {"reduce", "ordered", "chunk", "min", "max", "and", "or"}
FixedIdent = FixedIdent_Key âˆª FixedIdent_Parallel âˆª FixedIdent_Spawn âˆª FixedIdent_Dispatch
FixedIdentTok(t, s) â‡” IsIdent(t) âˆ§ Lexeme(t) = s âˆ§ s âˆˆ FixedIdent
Fixed identifiers MUST be tokenized as identifiers and are disambiguated by syntactic position.

Trailing comma rules are defined in Â§3.3.5.

**Cursive0 Declaration Keywords.**
UsingKeyword = "using"
Keyword("use") = false

**Union Propagation.**
UnionPropTok(t) â‡” IsOp(t, "?")
UnionPropForm(e) â‡” âˆƒ e_0. e = Propagate(e_0)

**Type Tokens.**
TypeWhereTok(t) â‡” IsIdent(t) âˆ§ Lexeme(t) = "where"
OpaqueTypeTok(t) â‡” IsIdent(t) âˆ§ Lexeme(t) = "opaque"
TypeArgsStartTok(t) â‡” IsOp(t, "<")
C0TypeRestricted(P) â‡” false

**Syntax (Cursive0 Subset).**

```ebnf
module            ::= item*
item              ::= import_decl | using_decl | extern_block | static_decl | procedure_decl | record_decl | enum_decl | modal_decl | class_decl | type_alias_decl

attribute_list    ::= attribute+
attribute          ::= "[[" attribute_spec ("," attribute_spec)* "]]"
attribute_spec     ::= attribute_name ("(" attribute_args ")")?
attribute_name     ::= identifier | vendor_prefix "::" identifier
vendor_prefix      ::= identifier ("." identifier)*
attribute_args     ::= attribute_arg ("," attribute_arg)*
attribute_arg      ::= literal
                    | identifier
                    | identifier ":" literal
                    | identifier "(" attribute_args ")"

import_decl        ::= attribute_list? visibility? "import" module_path ("as" identifier)?
using_decl         ::= attribute_list? visibility? "using" using_clause
using_clause       ::= using_path ("as" identifier)?
                     | using_path "::" using_list
                     | using_path "::" "*"
path               ::= identifier ("::" identifier)*
module_path        ::= path
using_path         ::= module_path ("::" identifier)?
type_path          ::= path generic_args?
using_list         ::= "{" using_specifier ("," using_specifier)* "}"
using_specifier    ::= identifier ("as" identifier)?
                     | "self" ("as" identifier)?

extern_block       ::= attribute_list? visibility? "extern" extern_abi? "{" extern_item* "}"
extern_abi         ::= string_literal | identifier
extern_item        ::= attribute_list? visibility? "procedure" identifier generic_params? signature where_clause? contract_clause? foreign_contract_clause_list? terminator

static_decl        ::= attribute_list? visibility? ("let" | "var") binding_decl
binding_decl       ::= pattern (":" type)? binding_op expression
procedure_decl     ::= attribute_list? visibility? "procedure" identifier generic_params? signature where_clause? contract_clause? block_expr
signature          ::= "(" param_list? ")" ("->" type)?
param_list         ::= param ("," param)*
param              ::= param_mode? identifier ":" type param_refine_opt?
param_refine_opt   ::= refinement_clause
param_mode         ::= "move"
record_decl        ::= attribute_list? visibility? "record" identifier generic_params? implements_clause? where_clause? "{" record_body? "}" type_invariant?
enum_decl          ::= attribute_list? visibility? "enum" identifier generic_params? implements_clause? where_clause? "{" variant_list? "}" type_invariant?
modal_decl         ::= attribute_list? visibility? "modal" identifier generic_params? implements_clause? where_clause? "{" state_block+ "}" type_invariant?
class_decl         ::= attribute_list? visibility? "modal"? "class" identifier generic_params? ("<:" superclass_bounds)? where_clause? "{" class_body? "}"
type_alias_decl    ::= attribute_list? visibility? "type" identifier generic_params? where_clause? "=" type

record_body        ::= record_member ("," record_member)*
record_member      ::= attribute_list? (record_field_decl | method_def)
method_def         ::= visibility? "override"? "procedure" identifier generic_params? "(" receiver ("," param_list)? ")" ("->" type)? contract_clause? block_expr
receiver           ::= receiver_shorthand | explicit_receiver
receiver_shorthand ::= "~" | "~!" | "~%"
explicit_receiver  ::= param_mode? "self" ":" type

implements_clause  ::= "<:" class_list
class_list         ::= class_path ("," class_path)*
class_path         ::= type_path

state_block        ::= "@" state_name "{" state_member* "}"
state_name         ::= identifier
state_member       ::= attribute_list? (state_field_decl | state_method_def | transition_def)
state_field_decl   ::= visibility? key_boundary? identifier ":" type
state_method_def   ::= visibility? "procedure" identifier generic_params? "(" state_method_params ")" ("->" type)? contract_clause? block_expr
state_method_params ::= receiver_shorthand ("," param_list)?
                     | param_list?
transition_def     ::= visibility? "transition" identifier "(" param_list ")" "->" "@" target_state block_expr
target_state       ::= identifier

superclass_bounds  ::= class_path ("+" class_path)*
class_body         ::= class_item*
class_item         ::= class_method_decl | associated_type_decl | abstract_field_decl | abstract_state_decl
class_method_decl  ::= attribute_list? visibility? "procedure" identifier generic_params? "(" receiver ("," param_list)? ")" ("->" type)? contract_clause? class_method_body
class_method_body  ::= block_expr | terminator
associated_type_decl ::= attribute_list? visibility? "type" identifier ("=" type)? terminator
abstract_field_decl ::= attribute_list? visibility? key_boundary? identifier ":" type terminator
abstract_state_decl ::= attribute_list? visibility? "@" identifier "{" abstract_field_decl* "}" terminator?

visibility         ::= "public" | "internal" | "private" | "protected"

key_boundary       ::= "#"

record_field_decl_list ::= record_field_decl ("," record_field_decl)*
record_field_decl  ::= visibility? key_boundary? identifier ":" type record_field_init_opt?
record_field_init_opt ::= "=" expression
field_decl_list    ::= field_decl ("," field_decl)*
field_decl         ::= visibility? key_boundary? identifier ":" type
variant_list       ::= variant ("," variant)*
variant            ::= identifier variant_payload? ("=" integer_literal)?
variant_payload    ::= "(" type_list? ")" | "{" field_decl_list? "}"
type_list          ::= type ("," type)*

statement          ::= key_block_stmt | binding_stmt | shadow_binding | assignment_stmt | expr_stmt | defer_stmt | region_stmt | frame_stmt | return_stmt | break_stmt | continue_stmt | unsafe_block
binding_stmt       ::= ("let" | "var") pattern (":" type)? binding_op expression terminator
shadow_binding     ::= "shadow" ("let" | "var") identifier (":" type)? "=" expression terminator
assignment_stmt    ::= place_expr "=" expression terminator
compound_assign    ::= place_expr compound_op expression terminator
expr_stmt          ::= expression terminator
defer_stmt         ::= "defer" block_expr
region_stmt        ::= "region" region_opts? region_alias? block_expr
region_opts        ::= "(" expression ")"
region_alias       ::= "as" identifier
frame_stmt         ::= "frame" block_expr | identifier "." "frame" block_expr
return_stmt        ::= "return" expression? terminator?
break_stmt         ::= "break" expression? terminator?
continue_stmt      ::= "continue" terminator?
unsafe_block       ::= "unsafe" block_expr

key_block_stmt     ::= "#" key_path_list key_block_mod* key_mode? block_expr
key_path_list      ::= key_path_expr ("," key_path_expr)*
key_block_mod      ::= "dynamic" | "speculative" | "release"
key_mode           ::= "read" | "write"
key_path_expr      ::= key_root key_seg*
key_root           ::= identifier
key_seg            ::= ("." key_field) | ("[" key_index "]")
key_field          ::= key_marker? identifier
key_index          ::= key_marker? expression
key_marker         ::= "#"

binding_op         ::= "=" | ":="
compound_op        ::= "+=" | "-=" | "*=" | "/=" | "%="
terminator         ::= ";" | newline
newline            ::= "\n"

expression         ::= attribute_list? unattributed_expr
unattributed_expr  ::= range_expression | logical_or_expr

range_expression   ::= exclusive_range | inclusive_range | from_range | to_range | to_inclusive_range | full_range
exclusive_range    ::= logical_or_expr ".." logical_or_expr
inclusive_range    ::= logical_or_expr "..=" logical_or_expr
from_range         ::= logical_or_expr ".."
to_range           ::= ".." logical_or_expr
to_inclusive_range ::= "..=" logical_or_expr
full_range         ::= ".."
logical_or_expr    ::= logical_and_expr ("||" logical_and_expr)*
logical_and_expr   ::= comparison_expr ("&&" comparison_expr)*
comparison_expr    ::= bitwise_or_expr (("==" | "!=" | "<" | "<=" | ">" | ">=") bitwise_or_expr)*
bitwise_or_expr    ::= bitwise_xor_expr ("|" bitwise_xor_expr)*
bitwise_xor_expr   ::= bitwise_and_expr ("^" bitwise_and_expr)*
bitwise_and_expr   ::= shift_expr ("&" shift_expr)*
shift_expr         ::= additive_expr (("<<" | ">>") additive_expr)*
additive_expr      ::= multiplicative_expr (("+" | "-") multiplicative_expr)*
multiplicative_expr ::= power_expr (("*" | "/" | "%") power_expr)*
power_expr         ::= cast_expr ("**" power_expr)?
cast_expr          ::= unary_expr ("as" type)?

unary_expr          ::= unary_operator unary_expr | address_of_expr | move_expr | postfix_expr
unary_operator      ::= "!" | "-" | "*" | "widen"
address_of_expr     ::= "&" place_expr
move_expr           ::= "move" place_expr

postfix_expr        ::= primary_expr postfix_suffix*
postfix_suffix      ::= "." identifier | "." decimal_literal | "[" expression "]" | "~>" identifier "(" argument_list? ")" | "(" argument_list? ")" | "?"

primary_expr        ::= literal | null_ptr_expr | identifier_expr | contract_intrinsic | qualified_expr | tuple_literal | array_literal | record_literal | if_expr | match_expr | loop_expr | block_expr | unsafe_expr | transmute_expr | alloc_expr | parallel_expr | spawn_expr | wait_expr | dispatch_expr | yield_expr | yield_from_expr | sync_expr | race_expr | all_expr
unsafe_expr         ::= "unsafe" block_expr
transmute_expr      ::= "transmute" "<" type "," type ">" "(" expression ")"
identifier_expr     ::= identifier
qualified_expr      ::= qualified_type_expr ("::" identifier)? qualified_suffix?
qualified_type_expr ::= path
qualified_suffix    ::= "(" argument_list? ")" | "{" field_init_list "}"
null_ptr_expr       ::= "Ptr" "::" "null" "(" ")"
alloc_expr          ::= "^" expression

parallel_expr      ::= "parallel" domain_expr block_options? block_expr
domain_expr        ::= expression
block_options      ::= "[" block_option ("," block_option)* "]"
block_option       ::= "cancel" ":" expression | "name" ":" string_literal
spawn_expr         ::= "spawn" spawn_option_list? block_expr
spawn_option_list  ::= "[" spawn_option ("," spawn_option)* "]"
spawn_option       ::= "name" ":" string_literal | "affinity" ":" expression | "priority" ":" expression
wait_expr          ::= "wait" expression
yield_expr         ::= "yield" "release"? expression
yield_from_expr    ::= "yield" "release"? "from" expression
sync_expr          ::= "sync" expression
race_expr          ::= "race" "{" race_arm ("," race_arm)* "}"
race_arm           ::= expression "->" "|" pattern "|" race_handler
race_handler       ::= expression | "yield" expression
all_expr           ::= "all" "{" expression ("," expression)* "}"
dispatch_expr      ::= "dispatch" pattern "in" range_expression key_clause? dispatch_option_list? block_expr
key_clause         ::= "key" key_path_expr key_mode
dispatch_option_list ::= "[" dispatch_option ("," dispatch_option)* "]"
dispatch_option    ::= "reduce" ":" reduce_op | "ordered" | "chunk" ":" expression
reduce_op          ::= "+" | "*" | "min" | "max" | "and" | "or" | identifier

parenthesized_expr  ::= "(" expression ")"

tuple_literal       ::= "(" tuple_expr_elements? ")"
tuple_expr_elements ::= expression ";" | expression ("," expression)+
array_literal       ::= "[" expression_list "]"
expression_list     ::= expression ("," expression)*
record_literal      ::= (type_path | state_specific_type) "{" field_init_list "}"
field_init_list     ::= field_init ("," field_init)*
field_init          ::= identifier ":" expression | identifier

argument_list       ::= argument ("," argument)*
argument            ::= "move"? expression

if_expr             ::= "if" expression block_expr ("else" (block_expr | if_expr))?
match_expr          ::= "match" expression "{" match_arm ("," match_arm)* "}"
match_arm           ::= pattern ("if" expression)? "=>" arm_body
arm_body            ::= expression | block_expr

loop_expr           ::= "loop" loop_condition? loop_invariant? block_expr
loop_condition      ::= expression | pattern (":" type)? "in" expression
loop_invariant      ::= "where" "{" predicate_expr "}"

block_expr          ::= "{" statement* expression? "}"

place_expr          ::= "*" place_expr | postfix_expr

pattern             ::= literal_pattern | wildcard_pattern | identifier_pattern | typed_pattern | tuple_pattern | record_pattern | enum_pattern | modal_pattern | range_pattern
literal_pattern     ::= literal
wildcard_pattern    ::= "_"
identifier_pattern  ::= identifier
typed_pattern       ::= identifier ":" type

tuple_pattern       ::= "(" tuple_pattern_elements? ")"
tuple_pattern_elements ::= pattern ";" | pattern ("," pattern)+
record_pattern      ::= type_path "{" field_pattern_list? "}"
field_pattern_list  ::= field_pattern ("," field_pattern)*
field_pattern       ::= identifier (":" pattern)?

enum_pattern        ::= type_path "::" identifier enum_payload_pattern?
enum_payload_pattern ::= "(" tuple_pattern_elements? ")" | "{" field_pattern_list? "}"

modal_pattern       ::= "@" identifier ("{" field_pattern_list? "}")?

range_pattern       ::= pattern (".." | "..=") pattern

type                ::= permission? base_type refinement_clause?
refinement_clause   ::= "where" "{" predicate_expr "}"
base_type           ::= union_type | non_union_type
union_type          ::= non_union_type ("|" non_union_type)+
non_union_type      ::= primitive_type | tuple_type | function_type | array_type | slice_type | safe_pointer_type | raw_pointer_type | string_type | bytes_type | dynamic_type | state_specific_type | type_path | opaque_type

primitive_type      ::= integer_type | float_type | bool_type | char_type | unit_type | never_type
integer_type        ::= "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128" | "isize" | "usize"
float_type          ::= "f16" | "f32" | "f64"
bool_type           ::= "bool"
char_type           ::= "char"
unit_type           ::= "(" ")"
never_type          ::= "!"

tuple_type          ::= "(" tuple_type_elements? ")"
tuple_type_elements ::= type ";" | type ("," type)+
function_type       ::= "(" param_type_list? ")" "->" type
param_type_list     ::= param_type ("," param_type)*
param_type          ::= "move"? type
array_type          ::= "[" type ";" const_expression "]"
slice_type          ::= "[" type "]"

string_type         ::= "string" ("@" ("Managed" | "View"))?
bytes_type          ::= "bytes" ("@" ("Managed" | "View"))?

modal_type_name     ::= type_path generic_args?
state_specific_type ::= modal_type_name "@" state_name

safe_pointer_type   ::= "Ptr" "<" type ">" ("@" pointer_state)?
pointer_state       ::= "Valid" | "Null" | "Expired"
raw_pointer_type    ::= "*" ("imm" | "mut") type

dynamic_type        ::= "$" type_path
opaque_type         ::= "opaque" type_path

const_expression    ::= expression

permission         ::= "const" | "unique" | "shared"

generic_params     ::= "<" type_param (";" type_param)* ">"
type_param         ::= identifier type_bounds? type_default?
type_bounds        ::= "<:" bound_list
bound_list         ::= class_bound ("," class_bound)*
class_bound        ::= type_path generic_args?
type_default       ::= "=" type
where_clause       ::= "where" where_predicate_list
where_predicate_list ::= where_predicate (predicate_separator where_predicate)* predicate_separator?
predicate_separator ::= terminator
where_predicate    ::= predicate_name "(" type ")"
predicate_name     ::= "Bitcopy" | "Clone" | "Drop" | "FfiSafe"
generic_args       ::= "<" type_arg_list ">"
type_arg_list      ::= type ("," type)*

contract_clause    ::= "|=" contract_body
contract_body      ::= precondition_expr | precondition_expr "=>" postcondition_expr | "=>" postcondition_expr
precondition_expr  ::= predicate_expr
postcondition_expr ::= predicate_expr
predicate_expr     ::= logical_or_expr
contract_intrinsic ::= "@result" | "@entry" "(" expression ")"
foreign_contract_clause_list ::= foreign_contract_clause+
foreign_contract_clause ::= "|=" foreign_contract_body
foreign_contract_body ::= foreign_assumes | foreign_ensures
foreign_assumes    ::= "@foreign_assumes" "(" predicate_list ")"
foreign_ensures    ::= "@foreign_ensures" "(" ensures_predicate_list ")"
predicate_list     ::= predicate_expr ("," predicate_expr)*
ensures_predicate_list ::= ensures_predicate ("," ensures_predicate)*
ensures_predicate  ::= predicate_expr | "@error" ":" predicate_expr | "@null_result" ":" predicate_expr

type_invariant     ::= "where" "{" predicate_expr "}"
```

Commas are list separators only and are never statement terminators; statement termination is governed solely by `terminator`.

**Method Context (Cursive0).**

RecordMembers(M) = { m | m occurs as RecordMember in M }
ClassItems(M) = { m | m occurs as ClassItem in M }
MethodDecls(M) = { m | m = MethodDecl(â€¦) âˆ§ m occurs in M }
ClassMethodDecls(M) = { m | m = ClassMethodDecl(â€¦) âˆ§ m occurs in M }
MethodContextOk(M) â‡” MethodDecls(M) âŠ† RecordMembers(M) âˆ§ ClassMethodDecls(M) âŠ† ClassItems(M)

**(Method-Context-Err)**
Â¬ MethodContextOk(M)    c = Code(Method-Context-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

#### 3.3.5. Token Consumption (Small-Step, Success-Only)

ConsumeState = {Consume(P, k), ConsumeDone(P)}
ParseRejectRules = âˆ…

**(Tok-Consume-Kind)**
Tok(P).kind = k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Consume(P, k)âŸ© â†’ âŸ¨ConsumeDone(Advance(P))âŸ©

**(Tok-Consume-Keyword)**
IsKw(Tok(P), s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Consume(P, Keyword(s))âŸ© â†’ âŸ¨ConsumeDone(Advance(P))âŸ©

**(Tok-Consume-Operator)**
IsOp(Tok(P), s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Consume(P, Operator(s))âŸ© â†’ âŸ¨ConsumeDone(Advance(P))âŸ©

**(Tok-Consume-Punct)**
IsPunc(Tok(P), s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Consume(P, Punctuator(s))âŸ© â†’ âŸ¨ConsumeDone(Advance(P))âŸ©

**List Parsing (Small-Step)**

ListState = {ListStart(P), ListScan(P, xs), ListDone(P, xs)}

**(List-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ListStart(P)âŸ© â†’ âŸ¨ListScan(P, [])âŸ©

**(List-Cons)**
Î“ âŠ¢ ParseElem(P) â‡“ (P', x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ListScan(P, xs)âŸ© â†’ âŸ¨ListScan(P', xs ++ [x])âŸ©

**(List-Done)**
Tok(P) âˆˆ EndSet
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ListScan(P, xs)âŸ© â†’ âŸ¨ListDone(P, xs)âŸ©

EndSet âŠ† TokenKind
In list parsing rules, P_0 denotes the parser state immediately after consuming the list opening delimiter for the list being parsed.
TrailingComma(P, EndSet) â‡” IsPunc(Tok(P), ",") âˆ§ Tok(Advance(P)) âˆˆ EndSet
TokensBetween(P_0, P) = âŸ¨TokIndex(P_0), TokIndex(P)âŸ©
TokLine(t) = t.span.line_s
TrailingCommaAllowed(P_0, P, EndSet) â‡” TrailingComma(P, EndSet) âˆ§ TokLine(Tok(P)) < TokLine(Tok(Advance(P)))

**(Trailing-Comma-Err)**
TrailingComma(P, EndSet)    Â¬ TrailingCommaAllowed(P_0, P, EndSet)    c = Code(Trailing-Comma-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c, Tok(P).span)

#### 3.3.6. Module and Item Parsing

**ParseFile (Big-Step).**
Î“ âŠ¢ Tokenize(S) â‡“ (K_raw, D)
K = Filter(K_raw)
P_0 = âŸ¨K, 0, D, 0, 0, []âŸ©

**(ParseFile-Ok)**
Î“ âŠ¢ ParseItems(P_0) â‡“ (P_1, I, MDoc)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFile(S) â‡“ âŸ¨S.path, I, MDocâŸ©

ParseModule âˆˆ RulesIn({"3.4.1", "3.4.2"})

**Item Sequence (Big-Step).**

**(ParseItems-Empty)**
Tok(P) = EOF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItems(P) â‡“ (P, [], [])

**(ParseItems-Cons)**
Tok(P) â‰  EOF    Î“ âŠ¢ ParseItem(P) â‡“ (P_1, it)    Î“ âŠ¢ ParseItems(P_1) â‡“ (P_2, I, M)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItems(P) â‡“ (P_2, [it] ++ I, M)

TopLevelItem âŠ† item

##### 3.3.6.1. Identifiers and Paths

**(Parse-Ident)**
IsIdent(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseIdent(P) â‡“ (Advance(P), Lexeme(Tok(P)))

**(Parse-Ident-Err)**
Â¬ IsIdent(Tok(P))    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseIdent(P) â‡“ (P, "_")

**(Parse-ModulePath)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, id)    Î“ âŠ¢ ParseModulePathTail(P_1, [id]) â‡“ (P_2, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModulePath(P) â‡“ (P_2, path)

**(Parse-ModulePathTail-End)**
Â¬ IsOp(Tok(P), "::")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModulePathTail(P, xs) â‡“ (P, xs)

**(Parse-ModulePathTail-Cons)**
IsOp(Tok(P), "::")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, id)    Î“ âŠ¢ ParseModulePathTail(P_1, xs ++ [id]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModulePathTail(P, xs) â‡“ (P_2, ys)

##### 3.3.6.2. Visibility Parsing

**(Parse-Vis-Opt)**
IsKw(Tok(P), v)    v âˆˆ {`public`, `internal`, `private`, `protected`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVis(P) â‡“ (Advance(P), v)

**(Parse-Vis-Default)**
Â¬ IsKw(Tok(P), v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVis(P) â‡“ (P, `internal`)

**(Parse-ModalOpt-Yes)**
IsKw(Tok(P), `modal`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModalOpt(P) â‡“ (Advance(P), true)

**(Parse-ModalOpt-No)**
Â¬ IsKw(Tok(P), `modal`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModalOpt(P) â‡“ (P, false)

##### 3.3.6.3. Using Declarations

**Import Declarations.**

**(Parse-Import)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `import`)    Î“ âŠ¢ ParseModulePath(Advance(P_1)) â‡“ (P_2, path)    Î“ âŠ¢ ParseAliasOpt(P_2) â‡“ (P_3, alias_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_3, âŸ¨ImportDecl, attrs_opt, vis, path, alias_opt, SpanBetween(P, P_3), []âŸ©)

**Using Declarations.**

**(Parse-Using-Wildcard)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `using`)    Î“ âŠ¢ ParseModulePath(Advance(P_1)) â‡“ (P_2, mp)    IsOp(Tok(P_2), "::")    IsOp(Tok(Advance(P_2)), "*")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (Advance(Advance(P_2)), âŸ¨UsingDecl, attrs_opt, vis, âŸ¨UsingWildcard, mpâŸ©, SpanBetween(P, Advance(Advance(P_2))), []âŸ©)

**(Parse-Using-List)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `using`)    Î“ âŠ¢ ParseModulePath(Advance(P_1)) â‡“ (P_2, mp)    IsOp(Tok(P_2), "::")    IsPunc(Tok(Advance(P_2)), "{")    Î“ âŠ¢ ParseUsingList(Advance(Advance(P_2))) â‡“ (P_3, specs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_3, âŸ¨UsingDecl, attrs_opt, vis, âŸ¨UsingList, mp, specsâŸ©, SpanBetween(P, P_3), []âŸ©)

**(Parse-Using-Path-Qualified)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `using`)    Î“ âŠ¢ ParseModulePath(Advance(P_1)) â‡“ (P_2, mp)    IsOp(Tok(P_2), "::")    IsIdent(Tok(Advance(P_2)))    Î“ âŠ¢ ParseIdent(Advance(P_2)) â‡“ (P_3, id)    Î“ âŠ¢ ParseAliasOpt(P_3) â‡“ (P_4, alias_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_4, âŸ¨UsingDecl, attrs_opt, vis, âŸ¨UsingPath, mp ++ [id], alias_optâŸ©, SpanBetween(P, P_4), []âŸ©)

**(Parse-Using-Path)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `using`)    Î“ âŠ¢ ParseModulePath(Advance(P_1)) â‡“ (P_2, path)    Â¬ IsOp(Tok(P_2), "::")    Î“ âŠ¢ ParseAliasOpt(P_2) â‡“ (P_3, alias_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_3, âŸ¨UsingDecl, attrs_opt, vis, âŸ¨UsingPath, path, alias_optâŸ©, SpanBetween(P, P_3), []âŸ©)

**Extern Blocks.**

**(Parse-ExternBlock)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `extern`)    Î“ âŠ¢ ParseExternAbiOpt(Advance(P_1)) â‡“ (P_2, abi_opt)    IsPunc(Tok(P_2), "{")    Î“ âŠ¢ ParseExternItemList(Advance(P_2)) â‡“ (P_3, items)    IsPunc(Tok(P_3), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (Advance(P_3), âŸ¨ExternBlock, attrs_opt, vis, abi_opt, items, SpanBetween(P, Advance(P_3)), []âŸ©)

**(Parse-ExternAbiOpt-None)**
Tok(P).kind âˆ‰ {StringLiteral, Identifier}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternAbiOpt(P) â‡“ (P, âŠ¥)

**(Parse-ExternAbiOpt-String)**
Tok(P).kind = StringLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternAbiOpt(P) â‡“ (Advance(P), StringAbi(Tok(P)))

**(Parse-ExternAbiOpt-Ident)**
IsIdent(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternAbiOpt(P) â‡“ (Advance(P), IdentAbi(Lexeme(Tok(P))))

**(Parse-ExternItemList-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternItemList(P) â‡“ (P, [])

**(Parse-ExternItemList-Cons)**
Â¬ IsPunc(Tok(P), "}")    Î“ âŠ¢ ParseExternItem(P) â‡“ (P_1, it)    Î“ âŠ¢ ParseExternItemList(P_1) â‡“ (P_2, rest)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternItemList(P) â‡“ (P_2, [it] ++ rest)

**(Parse-ExternItem)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseSignature(P_3) â‡“ (P_4, params, ret_opt)    Î“ âŠ¢ ParseWhereClauseOpt(P_4) â‡“ (P_5, where_clause_opt)    Î“ âŠ¢ ParseContractClauseOpt(P_5) â‡“ (P_6, contract_opt)    Î“ âŠ¢ ParseForeignContractClauseListOpt(P_6) â‡“ (P_7, foreign_contracts_opt)    Î“ âŠ¢ ConsumeTerminatorReq(P_7) â‡“ P_8
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExternItem(P) â‡“ (P_8, âŸ¨ExternProcDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, foreign_contracts_opt, SpanBetween(P, P_8), []âŸ©)

##### 3.3.6.4. Static Declarations

**(Parse-Static-Decl)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Tok(P_1) = Keyword(kw)    kw âˆˆ {`let`, `var`}    mut = kw    Î“ âŠ¢ ParseBindingAfterLetVar(P_1) â‡“ (P_2, bind)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_2, âŸ¨StaticDecl, attrs_opt, vis, mut, bind, SpanBetween(P, P_2), []âŸ©)

##### 3.3.6.5. Procedure Declarations

**(Parse-Procedure)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseSignature(P_3) â‡“ (P_4, params, ret_opt)    Î“ âŠ¢ ParseWhereClauseOpt(P_4) â‡“ (P_5, where_clause_opt)    Î“ âŠ¢ ParseContractClauseOpt(P_5) â‡“ (P_6, contract_opt)    Î“ âŠ¢ ParseBlock(P_6) â‡“ (P_7, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_7, âŸ¨ProcedureDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, SpanBetween(P, P_7), []âŸ©)

##### 3.3.6.6. Record Declarations

**(Parse-Record)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `record`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseImplementsOpt(P_3) â‡“ (P_4, impls)    Î“ âŠ¢ ParseWhereClauseOpt(P_4) â‡“ (P_5, where_clause_opt)    Î“ âŠ¢ ParseRecordBody(P_5) â‡“ (P_6, members)    Î“ âŠ¢ ParseInvariantOpt(P_6) â‡“ (P_7, invariant_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_7, âŸ¨RecordDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, members, invariant_opt, SpanBetween(P, P_7), []âŸ©)

##### 3.3.6.7. Enum Declarations

**(Parse-Enum)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `enum`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseImplementsOpt(P_3) â‡“ (P_4, impls)    Î“ âŠ¢ ParseWhereClauseOpt(P_4) â‡“ (P_5, where_clause_opt)    Î“ âŠ¢ ParseEnumBody(P_5) â‡“ (P_6, variants)    Î“ âŠ¢ ParseInvariantOpt(P_6) â‡“ (P_7, invariant_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_7, âŸ¨EnumDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, variants, invariant_opt, SpanBetween(P, P_7), []âŸ©)

##### 3.3.6.8. Modal Declarations

**(Parse-Modal)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `modal`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseImplementsOpt(P_3) â‡“ (P_4, impls)    Î“ âŠ¢ ParseWhereClauseOpt(P_4) â‡“ (P_5, where_clause_opt)    Î“ âŠ¢ ParseModalBody(P_5) â‡“ (P_6, states)    Î“ âŠ¢ ParseInvariantOpt(P_6) â‡“ (P_7, invariant_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_7, âŸ¨ModalDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, states, invariant_opt, SpanBetween(P, P_7), []âŸ©)

**(Parse-Class)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Î“ âŠ¢ ParseModalOpt(P_1) â‡“ (P_2, modal_opt)    IsKw(Tok(P_2), `class`)    Î“ âŠ¢ ParseIdent(Advance(P_2)) â‡“ (P_3, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_3) â‡“ (P_4, gen_params_opt)    Î“ âŠ¢ ParseSuperclassOpt(P_4) â‡“ (P_5, supers)    Î“ âŠ¢ ParseWhereClauseOpt(P_5) â‡“ (P_6, where_clause_opt)    Î“ âŠ¢ ParseClassBody(P_6) â‡“ (P_7, items)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_7, âŸ¨ClassDecl, attrs_opt, vis, modal_opt, name, gen_params_opt, where_clause_opt, supers, items, SpanBetween(P, P_7), []âŸ©)

**(Parse-ModalBody)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseStateBlockList(Advance(P)) â‡“ (P_1, states)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModalBody(P) â‡“ (Advance(P_1), states)

**(Parse-StateBlock)**
IsOp(Tok(P), "@")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, name)    IsPunc(Tok(P_1), "{")    Î“ âŠ¢ ParseStateMemberList(Advance(P_1)) â‡“ (P_2, members)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateBlock(P) â‡“ (Advance(P_2), âŸ¨name, members, SpanBetween(P, P_2), []âŸ©)

**(Parse-StateMember-Field)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Î“ âŠ¢ ParseKeyBoundaryOpt(P_1) â‡“ (P_2, boundary)    Î“ âŠ¢ ParseIdent(P_2) â‡“ (P_3, name)    IsPunc(Tok(P_3), ":")    Î“ âŠ¢ ParseType(Advance(P_3)) â‡“ (P_4, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMember(P) â‡“ (P_4, âŸ¨StateFieldDecl, attrs_opt, vis, boundary, name, ty, SpanBetween(P, P_4), []âŸ©)

**(Parse-StateMember-Method)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseStateMethodSignature(P_3) â‡“ (P_4, recv, params, ret_opt)    Î“ âŠ¢ ParseContractClauseOpt(P_4) â‡“ (P_5, contract_opt)    Î“ âŠ¢ ParseBlock(P_5) â‡“ (P_6, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMember(P) â‡“ (P_6, âŸ¨StateMethodDecl, attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, SpanBetween(P, P_6), []âŸ©)

**(Parse-StateMember-Transition)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `transition`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    IsPunc(Tok(P_2), "(")    Î“ âŠ¢ ParseParamList(Advance(P_2)) â‡“ (P_3, params)    IsPunc(Tok(P_3), ")")    P_3' = Advance(P_3)    IsOp(Tok(P_3'), "->")    IsOp(Tok(Advance(P_3')), "@")    Î“ âŠ¢ ParseIdent(Advance(Advance(P_3'))) â‡“ (P_4, target)    Î“ âŠ¢ ParseBlock(P_4) â‡“ (P_5, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMember(P) â‡“ (P_5, âŸ¨TransitionDecl, attrs_opt, vis, name, params, target, body, SpanBetween(P, P_5), []âŸ©)

##### 3.3.6.9. Implements Clauses

**(Parse-Implements-None)**
Â¬ IsOp(Tok(P), "<:")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseImplementsOpt(P) â‡“ (P, [])

**(Parse-Implements-Yes)**
IsOp(Tok(P), "<:")    Î“ âŠ¢ ParseClassList(Advance(P)) â‡“ (P_1, cls)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseImplementsOpt(P) â‡“ (P_1, cls)

**(Parse-ClassList-Cons)**
Î“ âŠ¢ ParseClassPath(P) â‡“ (P_1, c_0)    Î“ âŠ¢ ParseClassListTail(P_1, [c_0]) â‡“ (P_2, cs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassList(P) â‡“ (P_2, cs)

**(Parse-ClassListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassListTail(P, cs) â‡“ (P, cs)

**(Parse-ClassListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseClassPath(Advance(P)) â‡“ (P_1, c)    Î“ âŠ¢ ParseClassListTail(P_1, cs ++ [c]) â‡“ (P_2, cs')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassListTail(P, cs) â‡“ (P_2, cs')


##### 3.3.6.10. Class Declarations

**(Parse-Superclass-None)**
Â¬ IsOp(Tok(P), "<:")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSuperclassOpt(P) â‡“ (P, [])

**(Parse-Superclass-Yes)**
IsOp(Tok(P), "<:")    Î“ âŠ¢ ParseSuperclassBounds(Advance(P)) â‡“ (P_1, supers)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSuperclassOpt(P) â‡“ (P_1, supers)

**(Parse-SuperclassBounds-Cons)**
Î“ âŠ¢ ParseClassPath(P) â‡“ (P_1, c_0)    Î“ âŠ¢ ParseSuperclassBoundsTail(P_1, [c_0]) â‡“ (P_2, cs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSuperclassBounds(P) â‡“ (P_2, cs)

**(Parse-SuperclassBoundsTail-End)**
Â¬ IsOp(Tok(P), "+")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSuperclassBoundsTail(P, cs) â‡“ (P, cs)

**(Parse-SuperclassBoundsTail-Plus)**
IsOp(Tok(P), "+")    Î“ âŠ¢ ParseClassPath(Advance(P)) â‡“ (P_1, c)    Î“ âŠ¢ ParseSuperclassBoundsTail(P_1, cs ++ [c]) â‡“ (P_2, cs')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSuperclassBoundsTail(P, cs) â‡“ (P_2, cs')

**(Parse-ClassBody)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseClassItemList(Advance(P)) â‡“ (P_1, items)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassBody(P) â‡“ (Advance(P_1), items)

**(Parse-ClassItemList-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItemList(P) â‡“ (P, [])

**(Parse-ClassItemList-Cons)**
Â¬ IsPunc(Tok(P), "}")    Î“ âŠ¢ ParseClassItem(P) â‡“ (P_1, it)    Î“ âŠ¢ ParseClassItemList(P_1) â‡“ (P_2, rest)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItemList(P) â‡“ (P_2, [it] ++ rest)

**(Parse-ClassItem-Method)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseMethodSignature(P_3) â‡“ (P_4, receiver, params, ret_opt)    Î“ âŠ¢ ParseContractClauseOpt(P_4) â‡“ (P_5, contract_opt)    Î“ âŠ¢ ParseClassMethodBody(P_5) â‡“ (P_6, body_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItem(P) â‡“ (P_6, âŸ¨ClassMethodDecl, attrs_opt, vis, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body_opt, SpanBetween(P, P_6), []âŸ©)

**(Parse-ClassItem-AssociatedType)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `type`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseAssocTypeOpt(P_2) â‡“ (P_3, type_opt)    Î“ âŠ¢ ConsumeTerminatorReq(P_3) â‡“ P_4
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItem(P) â‡“ (P_4, âŸ¨AssociatedTypeDecl, attrs_opt, vis, name, type_opt, SpanBetween(P, P_4), []âŸ©)

**(Parse-ClassItem-AbstractState)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsOp(Tok(P_1), "@")    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    IsPunc(Tok(P_2), "{")    Î“ âŠ¢ ParseAbstractFieldList(Advance(P_2)) â‡“ (P_3, fields)    IsPunc(Tok(P_3), "}")    Î“ âŠ¢ ConsumeTerminatorOpt(Advance(P_3), âŠ¥) â‡“ P_4
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItem(P) â‡“ (P_4, âŸ¨AbstractStateDecl, attrs_opt, vis, name, fields, SpanBetween(P, P_4), []âŸ©)

**(Parse-ClassItem-Field)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Î“ âŠ¢ ParseKeyBoundaryOpt(P_1) â‡“ (P_2, boundary)    Î“ âŠ¢ ParseIdent(P_2) â‡“ (P_3, name)    IsPunc(Tok(P_3), ":")    Î“ âŠ¢ ParseType(Advance(P_3)) â‡“ (P_4, ty)    Î“ âŠ¢ ConsumeTerminatorReq(P_4) â‡“ P_5
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassItem(P) â‡“ (P_5, âŸ¨ClassFieldDecl, attrs_opt, vis, boundary, name, ty, SpanBetween(P, P_5), []âŸ©)

**(Parse-AssocTypeOpt-None)**
Â¬ IsOp(Tok(P), "=")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAssocTypeOpt(P) â‡“ (P, âŠ¥)

**(Parse-AssocTypeOpt-Yes)**
IsOp(Tok(P), "=")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAssocTypeOpt(P) â‡“ (P_1, ty)

**(Parse-AbstractFieldList-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAbstractFieldList(P) â‡“ (P, [])

**(Parse-AbstractFieldList-Cons)**
Î“ âŠ¢ ParseAbstractFieldDecl(P) â‡“ (P_1, f)    Î“ âŠ¢ ParseAbstractFieldList(P_1) â‡“ (P_2, rest)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAbstractFieldList(P) â‡“ (P_2, [f] ++ rest)

**(Parse-AbstractFieldDecl)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Î“ âŠ¢ ParseKeyBoundaryOpt(P_1) â‡“ (P_2, boundary)    Î“ âŠ¢ ParseIdent(P_2) â‡“ (P_3, name)    IsPunc(Tok(P_3), ":")    Î“ âŠ¢ ParseType(Advance(P_3)) â‡“ (P_4, ty)    Î“ âŠ¢ ConsumeTerminatorReq(P_4) â‡“ P_5
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAbstractFieldDecl(P) â‡“ (P_5, âŸ¨ClassFieldDecl, attrs_opt, vis, boundary, name, ty, SpanBetween(P, P_5), []âŸ©)

**(Parse-ClassMethodBody-Concrete)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseBlock(P) â‡“ (P_1, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassMethodBody(P) â‡“ (P_1, body)

**(Parse-ClassMethodBody-Abstract)**
Â¬ IsPunc(Tok(P), "{")    Î“ âŠ¢ ConsumeTerminatorReq(P) â‡“ P_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassMethodBody(P) â‡“ (P_1, âŠ¥)

##### 3.3.6.11. Type Alias Declarations

**(Parse-Type-Alias)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `type`)    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_2) â‡“ (P_3, gen_params_opt)    Î“ âŠ¢ ParseWhereClauseOpt(P_3) â‡“ (P_4, where_clause_opt)    IsOp(Tok(P_4), "=")    Î“ âŠ¢ ParseType(Advance(P_4)) â‡“ (P_5, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_5, âŸ¨TypeAliasDecl, attrs_opt, vis, name, gen_params_opt, where_clause_opt, ty, SpanBetween(P, P_5), []âŸ©)

##### 3.3.6.13. Item Helper Parsing Rules

**Type Paths.**

**(Parse-TypePath)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, id)    Î“ âŠ¢ ParseTypePathTail(P_1, [id]) â‡“ (P_2, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_2, path)


**(Parse-ClassPath)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassPath(P) â‡“ (P_1, path)

**(Parse-TypePathTail-End)**
Â¬ IsOp(Tok(P), "::")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypePathTail(P, xs) â‡“ (P, xs)

**(Parse-TypePathTail-Cons)**
IsOp(Tok(P), "::")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, id)    Î“ âŠ¢ ParseTypePathTail(P_1, xs ++ [id]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypePathTail(P, xs) â‡“ (P_2, ys)

**Attribute Lists.**

**(Parse-AttrListOpt-None)**
Â¬ IsPunc(Tok(P), "[[")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P, âŠ¥)

**(Parse-AttrListOpt-Yes)**
IsPunc(Tok(P), "[[")    Î“ âŠ¢ ParseAttrList(P) â‡“ (P_1, attrs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_1, attrs)

**(Parse-AttrList-Cons)**
Î“ âŠ¢ ParseAttrBlock(P) â‡“ (P_1, attrs_0)    Î“ âŠ¢ ParseAttrListTail(P_1, attrs_0) â‡“ (P_2, attrs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrList(P) â‡“ (P_2, attrs)

**(Parse-AttrListTail-End)**
Â¬ IsPunc(Tok(P), "[[")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrListTail(P, attrs) â‡“ (P, attrs)

**(Parse-AttrListTail-Cons)**
IsPunc(Tok(P), "[[")    Î“ âŠ¢ ParseAttrBlock(P) â‡“ (P_1, attrs_0)    Î“ âŠ¢ ParseAttrListTail(P_1, attrs ++ attrs_0) â‡“ (P_2, attrs_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrListTail(P, attrs) â‡“ (P_2, attrs_1)

**(Parse-AttrBlock)**
IsPunc(Tok(P), "[[")    P_0 = Advance(P)    Î“ âŠ¢ ParseAttrSpecList(P_0) â‡“ (P_1, specs)    IsPunc(Tok(P_1), "]]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrBlock(P) â‡“ (Advance(P_1), specs)

**(Parse-AttrSpecList-Cons)**
Î“ âŠ¢ ParseAttrSpec(P) â‡“ (P_1, s)    Î“ âŠ¢ ParseAttrSpecListTail(P_1, [s]) â‡“ (P_2, specs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrSpecList(P) â‡“ (P_2, specs)

**(Parse-AttrSpecListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrSpecListTail(P, xs) â‡“ (P, xs)

**(Parse-AttrSpecListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "]]")    TrailingCommaAllowed(P_0, P, {Punctuator("]]")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrSpecListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-AttrSpecListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseAttrSpec(Advance(P)) â‡“ (P_1, s)    Î“ âŠ¢ ParseAttrSpecListTail(P_1, xs ++ [s]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrSpecListTail(P, xs) â‡“ (P_2, ys)

**(Parse-AttrSpec)**
Î“ âŠ¢ ParseAttrName(P) â‡“ (P_1, name)    Î“ âŠ¢ ParseAttrArgsOpt(P_1) â‡“ (P_2, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrSpec(P) â‡“ (P_2, Attr(name, args))

**(Parse-AttrName-Plain)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, id)    Â¬ IsPunc(Tok(P_1), ".")    Â¬ IsOp(Tok(P_1), "::")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrName(P) â‡“ (P_1, id)

**(Parse-AttrName-Vendor)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, id_0)    Î“ âŠ¢ ParseVendorPrefixTail(P_1, [id_0]) â‡“ (P_2, pref)    IsOp(Tok(P_2), "::")    Î“ âŠ¢ ParseIdent(Advance(P_2)) â‡“ (P_3, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrName(P) â‡“ (P_3, âŸ¨pref, nameâŸ©)

**(Parse-VendorPrefixTail-End)**
Â¬ IsPunc(Tok(P), ".")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVendorPrefixTail(P, xs) â‡“ (P, xs)

**(Parse-VendorPrefixTail-Cons)**
IsPunc(Tok(P), ".")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, id)    Î“ âŠ¢ ParseVendorPrefixTail(P_1, xs ++ [id]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVendorPrefixTail(P, xs) â‡“ (P_2, ys)

**(Parse-AttrArgsOpt-None)**
Â¬ IsPunc(Tok(P), "(")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgsOpt(P) â‡“ (P, [])

**(Parse-AttrArgsOpt-Yes)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseAttrArgList(Advance(P)) â‡“ (P_1, args)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgsOpt(P) â‡“ (Advance(P_1), args)

**(Parse-AttrArgList-Cons)**
Î“ âŠ¢ ParseAttrArg(P) â‡“ (P_1, a)    Î“ âŠ¢ ParseAttrArgListTail(P_1, [a]) â‡“ (P_2, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgList(P) â‡“ (P_2, args)

**(Parse-AttrArgListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgListTail(P, xs) â‡“ (P, xs)

**(Parse-AttrArgListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    TrailingCommaAllowed(P_0, P, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-AttrArgListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseAttrArg(Advance(P)) â‡“ (P_1, a)    Î“ âŠ¢ ParseAttrArgListTail(P_1, xs ++ [a]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArgListTail(P, xs) â‡“ (P_2, ys)

**(Parse-AttrArg-Named-Literal)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    IsPunc(Tok(P_1), ":")    Tok(Advance(P_1)).kind âˆˆ LiteralKind
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArg(P) â‡“ (Advance(Advance(P_1)), âŸ¨name, Tok(Advance(P_1))âŸ©)

**(Parse-AttrArg-Named-Call)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    IsPunc(Tok(P_1), "(")    Î“ âŠ¢ ParseAttrArgList(Advance(P_1)) â‡“ (P_2, args)    IsPunc(Tok(P_2), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArg(P) â‡“ (Advance(P_2), âŸ¨name, argsâŸ©)

**(Parse-AttrArg-Literal)**
Tok(P).kind âˆˆ LiteralKind
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArg(P) â‡“ (Advance(P), Tok(P))

**(Parse-AttrArg-Ident)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAttrArg(P) â‡“ (P_1, name)

**Generic Arguments and Parameters.**

**(Parse-GenericArgs)**
IsOp(Tok(P), "<")    Î“ âŠ¢ ParseTypeList(Advance(P)) â‡“ (P_1, args)    IsOp(Tok(P_1), ">")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericArgs(P) â‡“ (Advance(P_1), args)

**(Parse-GenericArgsOpt-None)**
Â¬ IsOp(Tok(P), "<")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericArgsOpt(P) â‡“ (P, âŠ¥)

**(Parse-GenericArgsOpt-Yes)**
Î“ âŠ¢ ParseGenericArgs(P) â‡“ (P_1, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericArgsOpt(P) â‡“ (P_1, args)

**(Parse-GenericParamsOpt-None)**
Â¬ IsOp(Tok(P), "<")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericParamsOpt(P) â‡“ (P, âŠ¥)

**(Parse-GenericParamsOpt-Yes)**
Î“ âŠ¢ ParseGenericParams(P) â‡“ (P_1, params)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericParamsOpt(P) â‡“ (P_1, params)

**(Parse-GenericParams)** 
IsOp(Tok(P), "<")    Î“ âŠ¢ ParseTypeParam(Advance(P)) â‡“ (P_1, p_1)    Î“ âŠ¢ ParseTypeParamTail(P_1, [p_1]) â‡“ (P_2, ps)    IsOp(Tok(P_2), ">")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGenericParams(P) â‡“ (Advance(P_2), ps)

**(Parse-TypeParamTail-End)** 
Â¬ IsPunc(Tok(P), ";")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeParamTail(P, ps) â‡“ (P, ps)

**(Parse-TypeParamTail-Cons)** 
IsPunc(Tok(P), ";")    Î“ âŠ¢ ParseTypeParam(Advance(P)) â‡“ (P_1, p)    Î“ âŠ¢ ParseTypeParamTail(P_1, ps ++ [p]) â‡“ (P_2, ps')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeParamTail(P, ps) â‡“ (P_2, ps')

**(Parse-TypeParam)** 
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Î“ âŠ¢ ParseTypeBoundsOpt(P_1) â‡“ (P_2, bounds)    Î“ âŠ¢ ParseTypeDefaultOpt(P_2) â‡“ (P_3, default_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeParam(P) â‡“ (P_3, âŸ¨name, bounds, default_opt, âŠ¥âŸ©)

**(Parse-TypeBoundsOpt-None)**
Â¬ IsOp(Tok(P), "<:")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeBoundsOpt(P) â‡“ (P, [])

**(Parse-TypeBoundsOpt-Yes)**
IsOp(Tok(P), "<:")    Î“ âŠ¢ ParseClassBoundList(Advance(P)) â‡“ (P_1, bounds)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeBoundsOpt(P) â‡“ (P_1, bounds)

**(Parse-ClassBoundList-Cons)**
Î“ âŠ¢ ParseClassBound(P) â‡“ (P_1, b_1)    Î“ âŠ¢ ParseClassBoundListTail(P_1, [b_1]) â‡“ (P_2, bs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassBoundList(P) â‡“ (P_2, bs)

**(Parse-ClassBoundListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassBoundListTail(P, bs) â‡“ (P, bs)

**(Parse-ClassBoundListTail-Cons)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseClassBound(Advance(P)) â‡“ (P_1, b)    Î“ âŠ¢ ParseClassBoundListTail(P_1, bs ++ [b]) â‡“ (P_2, bs')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassBoundListTail(P, bs) â‡“ (P_2, bs')

**(Parse-ClassBound)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    Î“ âŠ¢ ParseGenericArgsOpt(P_1) â‡“ (P_2, args_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseClassBound(P) â‡“ (P_2, âŸ¨path, args_optâŸ©)

**(Parse-TypeDefaultOpt-None)**
Â¬ IsOp(Tok(P), "=")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeDefaultOpt(P) â‡“ (P, âŠ¥)

**(Parse-TypeDefaultOpt-Yes)**
IsOp(Tok(P), "=")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeDefaultOpt(P) â‡“ (P_1, ty)

**(Parse-WhereClauseOpt-None)**
Â¬ IsKw(Tok(P), `where`) âˆ¨ IsPunc(Tok(Advance(P)), "{")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWhereClauseOpt(P) â‡“ (P, âŠ¥)

**(Parse-WhereClauseOpt-Yes)**
IsKw(Tok(P), `where`)    Â¬ IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ ParseWherePredList(Advance(P)) â‡“ (P_1, preds)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWhereClauseOpt(P) â‡“ (P_1, preds)

**(Parse-WherePredList-Cons)**
Î“ âŠ¢ ParseWherePred(P) â‡“ (P_1, p)    Î“ âŠ¢ ParseWherePredListTail(P_1, [p]) â‡“ (P_2, ps)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePredList(P) â‡“ (P_2, ps)

**(Parse-WherePredListTail-End)**
Â¬ IsTerminator(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePredListTail(P, ps) â‡“ (P, ps)

**(Parse-WherePredListTail-TrailingTerminator)**
IsTerminator(Tok(P))    Â¬ IsIdent(Tok(Advance(P)))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePredListTail(P, ps) â‡“ (Advance(P), ps)

**(Parse-WherePredListTail-Cons)**
IsTerminator(Tok(P))    Î“ âŠ¢ ParseWherePred(Advance(P)) â‡“ (P_1, p)    Î“ âŠ¢ ParseWherePredListTail(P_1, ps ++ [p]) â‡“ (P_2, ps')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePredListTail(P, ps) â‡“ (P_2, ps')

IsPredName(name) â‡” name âˆˆ {`Bitcopy`, `Clone`, `Drop`, `FfiSafe`}

**(Parse-WherePred-Predicate)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    IsPredName(name)    IsPunc(Tok(P_1), "(")    Î“ âŠ¢ ParseType(Advance(P_1)) â‡“ (P_2, ty)    IsPunc(Tok(P_2), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePred(P) â‡“ (Advance(P_2), PredWherePred(name, ty))

**(Parse-WherePred-Err)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Â¬ (IsPredName(name) âˆ§ IsPunc(Tok(P_1), "("))    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P_1).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseWherePred(P) â‡“ (P_1, PredWherePred(name, TypePrim("!")))

**(Parse-InvariantOpt-None)**
Â¬ (IsKw(Tok(P), `where`) âˆ§ IsPunc(Tok(Advance(P)), "{"))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseInvariantOpt(P) â‡“ (P, âŠ¥)

**(Parse-InvariantOpt-Yes)**
IsKw(Tok(P), `where`)    IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ ParsePredicateExpr(Advance(Advance(P))) â‡“ (P_1, pred)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseInvariantOpt(P) â‡“ (Advance(P_1), pred)

ParseLoopInvariantOpt(P) â‡“ (P_1, inv_opt) â‡” Î“ âŠ¢ ParseInvariantOpt(P) â‡“ (P_1, inv_opt)

**Qualified Head.**


**(Parse-QualifiedHead)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, id_0)    IsOp(Tok(P_1), "::")    Î“ âŠ¢ ParseModulePathTail(P_1, [id_0]) â‡“ (P_2, xs)    xs = ys ++ [name]    |xs| â‰¥ 2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseQualifiedHead(P) â‡“ (P_2, ys, name)

**Using Lists.**


**(Parse-UsingSpec)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Î“ âŠ¢ ParseAliasOpt(P_1) â‡“ (P_2, alias_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingSpec(P) â‡“ (P_2, âŸ¨name, alias_optâŸ©)

**Bindings.**

**(Parse-BindingAfterLetVar)**
Tok(P) = kw âˆˆ {Keyword(`let`), Keyword(`var`)}    Î“ âŠ¢ ParsePattern(Advance(P)) â‡“ (P_1, pat)    Î“ âŠ¢ ParseTypeAnnotOpt(P_1) â‡“ (P_2, ty_opt)    Tok(P_2) âˆˆ {Operator("="), Operator(":=")}    op = Tok(P_2)    Î“ âŠ¢ ParseExpr(Advance(P_2)) â‡“ (P_3, init)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseBindingAfterLetVar(P) â‡“ (P_3, âŸ¨pat, ty_opt, op, init, SpanBetween(P, P_3)âŸ©)

**(Parse-ShadowBinding)**
Tok(P) = kw âˆˆ {Keyword(`let`), Keyword(`var`)}    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, name)    Î“ âŠ¢ ParseTypeAnnotOpt(P_1) â‡“ (P_2, ty_opt)    IsOp(Tok(P_2), "=")    Î“ âŠ¢ ParseExpr(Advance(P_2)) â‡“ (P_3, init)    s = (ShadowLetStmt(name, ty_opt, init) if kw = Keyword(`let`) else ShadowVarStmt(name, ty_opt, init))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseShadowBinding(P) â‡“ (P_3, s)

**Record Bodies.**

**(Parse-RecordBody)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseRecordMemberList(Advance(P)) â‡“ (P_1, members)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordBody(P) â‡“ (Advance(P_1), members)

**Record Member Lists.**

**(Parse-RecordMemberList-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMemberList(P) â‡“ (P, [])

**(Parse-RecordMemberList-Cons)**
Î“ âŠ¢ ParseRecordMember(P) â‡“ (P_1, m)    Î“ âŠ¢ ParseRecordMemberTail(P_1, [m]) â‡“ (P_2, ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMemberList(P) â‡“ (P_2, ms)

**(Parse-RecordMemberTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMemberTail(P, xs) â‡“ (P, xs)

**(Parse-RecordMemberTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMemberTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-RecordMemberTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseRecordMember(Advance(P)) â‡“ (P_1, m)    Î“ âŠ¢ ParseRecordMemberTail(P_1, xs ++ [m]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMemberTail(P, xs) â‡“ (P_2, ys)

**Record Members.**

**(Parse-RecordMember-Method)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseMethodDefAfterVis(P_1, vis, attrs_opt) â‡“ (P_2, m)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMember(P) â‡“ (P_2, m)

**(Parse-RecordMember-Field)**
Î“ âŠ¢ ParseAttrListOpt(P) â‡“ (P_0, attrs_opt)    Î“ âŠ¢ ParseVis(P_0) â‡“ (P_1, vis)    Â¬ IsKw(Tok(P_1), `procedure`)    Î“ âŠ¢ ParseRecordFieldDeclAfterVis(P_1, vis, attrs_opt) â‡“ (P_2, f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordMember(P) â‡“ (P_2, f)

**Record Method Definitions.**

**(Parse-MethodDefAfterVis)**
Î“ âŠ¢ ParseOverrideOpt(P) â‡“ (P_0, ov)    IsKw(Tok(P_0), `procedure`)    Î“ âŠ¢ ParseIdent(Advance(P_0)) â‡“ (P_1, name)    Î“ âŠ¢ ParseGenericParamsOpt(P_1) â‡“ (P_2, gen_params_opt)    Î“ âŠ¢ ParseMethodSignature(P_2) â‡“ (P_3, receiver, params, ret_opt)    Î“ âŠ¢ ParseContractClauseOpt(P_3) â‡“ (P_4, contract_opt)    Î“ âŠ¢ ParseBlock(P_4) â‡“ (P_5, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMethodDefAfterVis(P, vis, attrs_opt) â‡“ (P_5, âŸ¨MethodDecl, attrs_opt, vis, ov, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body, SpanBetween(P, P_5), []âŸ©)

**(Parse-Override-Yes)**
IsKw(Tok(P), `override`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseOverrideOpt(P) â‡“ (Advance(P), true)

**(Parse-Override-No)**
Â¬ IsKw(Tok(P), `override`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseOverrideOpt(P) â‡“ (P, false)


**(Parse-MethodSignature)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseReceiver(Advance(P)) â‡“ (P_1, r)    Î“ âŠ¢ ParseMethodParams(P_1) â‡“ (P_2, params)    IsPunc(Tok(P_2), ")")    Î“ âŠ¢ ParseReturnOpt(Advance(P_2)) â‡“ (P_3, ret_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMethodSignature(P) â‡“ (P_3, r, params, ret_opt)

**(Parse-StateMethodSignature-Receiver)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseReceiver(Advance(P)) â‡“ (P_1, r)    r = ReceiverShorthand(_)    Î“ âŠ¢ ParseMethodParams(P_1) â‡“ (P_2, params)    IsPunc(Tok(P_2), ")")    Î“ âŠ¢ ParseReturnOpt(Advance(P_2)) â‡“ (P_3, ret_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMethodSignature(P) â‡“ (P_3, r, params, ret_opt)

**(Parse-StateMethodSignature-Default)**
IsPunc(Tok(P), "(")    Â¬ IsOp(Tok(Advance(P)), "~")    Â¬ IsOp(Tok(Advance(P)), "~!")    Â¬ IsOp(Tok(Advance(P)), "~%")    Î“ âŠ¢ ParseSignature(P) â‡“ (P_1, params, ret_opt)    r = ReceiverShorthand(`const`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMethodSignature(P) â‡“ (P_1, r, params, ret_opt)

**(Parse-MethodParams-None)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMethodParams(P) â‡“ (P, [])

**(Parse-MethodParams-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseParamList(Advance(P)) â‡“ (P_1, params)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMethodParams(P) â‡“ (P_1, params)

**Receiver Parsing.**

**(Parse-Receiver-Short-Const)**
IsOp(Tok(P), "~")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReceiver(P) â‡“ (Advance(P), ReceiverShorthand(`const`))

**(Parse-Receiver-Short-Unique)**
IsOp(Tok(P), "~!")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReceiver(P) â‡“ (Advance(P), ReceiverShorthand(`unique`))

**(Parse-Receiver-Short-Shared)**
IsOp(Tok(P), "~%")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReceiver(P) â‡“ (Advance(P), ReceiverShorthand(`shared`))

**(Parse-Receiver-Explicit)**
Î“ âŠ¢ ParseParamModeOpt(P) â‡“ (P_1, mode)    IsIdent(Tok(P_1))    Lexeme(Tok(P_1)) = `self`    IsPunc(Tok(Advance(P_1)), ":")    Î“ âŠ¢ ParseType(Advance(Advance(P_1))) â‡“ (P_2, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReceiver(P) â‡“ (P_2, ReceiverExplicit(mode, ty))

**State Block Lists.**

**(Parse-StateBlockList-Empty)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateBlockList(P) â‡“ (P, [])

**(Parse-StateBlockList-Cons)**
Î“ âŠ¢ ParseStateBlock(P) â‡“ (P_1, st)    Î“ âŠ¢ ParseStateBlockList(P_1) â‡“ (P_2, sts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateBlockList(P) â‡“ (P_2, [st] ++ sts)

**State Member Lists.**

**(Parse-StateMemberList-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMemberList(P) â‡“ (P, [])

**(Parse-StateMemberList-Cons)**
Î“ âŠ¢ ParseStateMember(P) â‡“ (P_1, m)    Î“ âŠ¢ ParseStateMemberList(P_1) â‡“ (P_2, ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStateMemberList(P) â‡“ (P_2, [m] ++ ms)


**Enum Bodies.**

**(Parse-EnumBody)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseVariantList(Advance(P)) â‡“ (P_1, vars)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnumBody(P) â‡“ (Advance(P_1), vars)

**Parameters and Returns.**

**(Parse-ParamList-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamList(P) â‡“ (P, [])

**(Parse-ParamList-Cons)**
Î“ âŠ¢ ParseParam(P) â‡“ (P_1, param)    Î“ âŠ¢ ParseParamTail(P_1, [param]) â‡“ (P_2, params)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamList(P) â‡“ (P_2, params)

**(Parse-ReturnOpt-None)**
Â¬ IsOp(Tok(P), "->")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReturnOpt(P) â‡“ (P, âŠ¥)

**(Parse-ReturnOpt-Arrow)**
IsOp(Tok(P), "->")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReturnOpt(P) â‡“ (P_1, ty)

**(Parse-ContractClauseOpt-None)**
Â¬ IsOp(Tok(P), "|=") âˆ¨ ForeignContractStart(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseContractClauseOpt(P) â‡“ (P, âŠ¥)

**(Parse-ContractClauseOpt-Yes)**
IsOp(Tok(P), "|=")    Î“ âŠ¢ ParseContractBody(Advance(P)) â‡“ (P_1, clause)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseContractClauseOpt(P) â‡“ (P_1, clause)

**(Parse-ContractBody-PostOnly)**
IsOp(Tok(P), "=>")    Î“ âŠ¢ ParsePredicateExpr(Advance(P)) â‡“ (P_1, post)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseContractBody(P) â‡“ (P_1, âŸ¨âŠ¥, postâŸ©)

**(Parse-ContractBody-PrePost)**
Î“ âŠ¢ ParsePredicateExpr(P) â‡“ (P_1, pre)    IsOp(Tok(P_1), "=>")    Î“ âŠ¢ ParsePredicateExpr(Advance(P_1)) â‡“ (P_2, post)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseContractBody(P) â‡“ (P_2, âŸ¨pre, postâŸ©)

**(Parse-ContractBody-PreOnly)**
Î“ âŠ¢ ParsePredicateExpr(P) â‡“ (P_1, pre)    Â¬ IsOp(Tok(P_1), "=>")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseContractBody(P) â‡“ (P_1, âŸ¨pre, âŠ¥âŸ©)

ForeignContractStart(P) â‡” IsOp(Tok(P), "|=") âˆ§ IsOp(Tok(Advance(P)), "@") âˆ§ IsIdent(Tok(Advance(Advance(P)))) âˆ§ Lexeme(Tok(Advance(Advance(P)))) âˆˆ {`foreign_assumes`, `foreign_ensures`}

**(Parse-ForeignContractClauseListOpt-None)**
Â¬ ForeignContractStart(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClauseListOpt(P) â‡“ (P, âŠ¥)

**(Parse-ForeignContractClauseListOpt-Yes)**
ForeignContractStart(P)    Î“ âŠ¢ ParseForeignContractClauseList(P) â‡“ (P_1, clauses)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClauseListOpt(P) â‡“ (P_1, clauses)

**(Parse-ForeignContractClauseList-Cons)**
Î“ âŠ¢ ParseForeignContractClause(P) â‡“ (P_1, clause)    Î“ âŠ¢ ParseForeignContractClauseListTail(P_1, [clause]) â‡“ (P_2, clauses)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClauseList(P) â‡“ (P_2, clauses)

**(Parse-ForeignContractClauseListTail-End)**
Â¬ ForeignContractStart(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClauseListTail(P, xs) â‡“ (P, xs)

**(Parse-ForeignContractClauseListTail-Cons)**
ForeignContractStart(P)    Î“ âŠ¢ ParseForeignContractClause(P) â‡“ (P_1, clause)    Î“ âŠ¢ ParseForeignContractClauseListTail(P_1, xs ++ [clause]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClauseListTail(P, xs) â‡“ (P_2, ys)

**(Parse-ForeignContractClause-Assumes)**
IsOp(Tok(P), "|=")    IsOp(Tok(Advance(P)), "@")    IsIdent(Tok(Advance(Advance(P))))    Lexeme(Tok(Advance(Advance(P)))) = `foreign_assumes`    IsPunc(Tok(Advance(Advance(Advance(P)))), "(")    Î“ âŠ¢ ParsePredicateList(Advance(Advance(Advance(Advance(P))))) â‡“ (P_1, preds)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClause(P) â‡“ (Advance(P_1), ForeignContractClause(ForeignAssumes, preds))

**(Parse-ForeignContractClause-Ensures)**
IsOp(Tok(P), "|=")    IsOp(Tok(Advance(P)), "@")    IsIdent(Tok(Advance(Advance(P))))    Lexeme(Tok(Advance(Advance(P)))) = `foreign_ensures`    IsPunc(Tok(Advance(Advance(Advance(P)))), "(")    Î“ âŠ¢ ParseEnsuresPredicateList(Advance(Advance(Advance(Advance(P))))) â‡“ (P_1, preds)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseForeignContractClause(P) â‡“ (Advance(P_1), ForeignContractClause(ForeignEnsures, preds))

**(Parse-PredicateList)** 
Î“ âŠ¢ ParseExprList(P) â‡“ (P_1, preds)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePredicateList(P) â‡“ (P_1, preds)

**(Parse-EnsuresPredicateList-Cons)** 
Î“ âŠ¢ ParseEnsuresPredicate(P) â‡“ (P_1, pred)    Î“ âŠ¢ ParseEnsuresPredicateListTail(P_1, [pred]) â‡“ (P_2, preds)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicateList(P) â‡“ (P_2, preds)

**(Parse-EnsuresPredicateListTail-End)** 
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicateListTail(P, xs) â‡“ (P, xs)

**(Parse-EnsuresPredicateListTail-TrailingComma)** 
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    TrailingCommaAllowed(P_0, P, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicateListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-EnsuresPredicateListTail-Comma)** 
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseEnsuresPredicate(Advance(P)) â‡“ (P_1, pred)    Î“ âŠ¢ ParseEnsuresPredicateListTail(P_1, xs ++ [pred]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicateListTail(P, xs) â‡“ (P_2, ys)

**(Parse-EnsuresPredicate-Error)** 
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `error`    IsPunc(Tok(Advance(Advance(P))), ":")    Î“ âŠ¢ ParsePredicateExpr(Advance(Advance(Advance(P)))) â‡“ (P_1, pred)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicate(P) â‡“ (P_1, EnsuresError(pred))

**(Parse-EnsuresPredicate-NullResult)** 
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `null_result`    IsPunc(Tok(Advance(Advance(P))), ":")    Î“ âŠ¢ ParsePredicateExpr(Advance(Advance(Advance(P)))) â‡“ (P_1, pred)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicate(P) â‡“ (P_1, EnsuresNullResult(pred))

**(Parse-EnsuresPredicate-Plain)** 
Î“ âŠ¢ ParsePredicateExpr(P) â‡“ (P_1, pred)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnsuresPredicate(P) â‡“ (P_1, Ensures(pred))

**(Parse-AliasOpt-None)**
Â¬ IsKw(Tok(P), `as`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAliasOpt(P) â‡“ (P, âŠ¥)

**(Parse-AliasOpt-Yes)**
IsKw(Tok(P), `as`)    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, id)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAliasOpt(P) â‡“ (P_1, id)

**(Parse-TypeAnnotOpt-None)**
Â¬ IsPunc(Tok(P), ":")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeAnnotOpt(P) â‡“ (P, âŠ¥)

**(Parse-TypeAnnotOpt-Yes)**
IsPunc(Tok(P), ":")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeAnnotOpt(P) â‡“ (P_1, ty)

**(Parse-KeyBoundaryOpt-Yes)**
IsOp(Tok(P), "#")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBoundaryOpt(P) â‡“ (Advance(P), true)

**(Parse-KeyBoundaryOpt-No)**
Â¬ IsOp(Tok(P), "#")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBoundaryOpt(P) â‡“ (P, false)

**(Parse-UsingList-Empty)**
IsPunc(Tok(P), "}")    Î“ âŠ¢ Emit(Code(Unsupported-Construct))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingList(P) â‡“ (Advance(P), [])

**(Parse-UsingList-Cons)**
Î“ âŠ¢ ParseUsingSpec(P) â‡“ (P_1, s)    Î“ âŠ¢ ParseUsingListTail(P_1, [s]) â‡“ (P_2, specs)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingList(P) â‡“ (Advance(P_2), specs)

**(Parse-UsingListTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingListTail(P, xs) â‡“ (P, xs)

**(Parse-UsingListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-UsingListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseUsingSpec(Advance(P)) â‡“ (P_1, s)    Î“ âŠ¢ ParseUsingListTail(P_1, xs ++ [s]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUsingListTail(P, xs) â‡“ (P_2, ys)

**(Parse-RecordFieldDeclList-Empty)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclList(P) â‡“ (P, [])

**(Parse-RecordFieldDeclList-Cons)**
Î“ âŠ¢ ParseRecordFieldDecl(P) â‡“ (P_1, f)    Î“ âŠ¢ ParseRecordFieldDeclTail(P_1, [f]) â‡“ (P_2, fields)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclList(P) â‡“ (P_2, fields)

**(Parse-RecordFieldDecl)**
Î“ âŠ¢ ParseVis(P) â‡“ (P_1, vis)    Î“ âŠ¢ ParseRecordFieldDeclAfterVis(P_1, vis, âŠ¥) â‡“ (P_2, f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDecl(P) â‡“ (P_2, f)

**(Parse-RecordFieldDeclAfterVis)**
Î“ âŠ¢ ParseKeyBoundaryOpt(P) â‡“ (P_0, boundary)    Î“ âŠ¢ ParseIdent(P_0) â‡“ (P_1, name)    IsPunc(Tok(P_1), ":")    Î“ âŠ¢ ParseType(Advance(P_1)) â‡“ (P_2, ty)    Î“ âŠ¢ ParseRecordFieldInitOpt(P_2) â‡“ (P_3, init_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclAfterVis(P, vis, attrs_opt) â‡“ (P_3, âŸ¨FieldDecl, attrs_opt, vis, boundary, name, ty, init_opt, SpanBetween(P, P_3), âŠ¥âŸ©)

**(Parse-RecordFieldInitOpt-None)**
Â¬ IsOp(Tok(P), "=")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldInitOpt(P) â‡“ (P, âŠ¥)

**(Parse-RecordFieldInitOpt-Yes)**
IsOp(Tok(P), "=")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldInitOpt(P) â‡“ (P_1, e)

**(Parse-RecordFieldDeclTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclTail(P, xs) â‡“ (P, xs)

**(Parse-RecordFieldDeclTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-RecordFieldDeclTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseRecordFieldDecl(Advance(P)) â‡“ (P_1, f)    Î“ âŠ¢ ParseRecordFieldDeclTail(P_1, xs ++ [f]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRecordFieldDeclTail(P, xs) â‡“ (P_2, ys)

**(Parse-FieldDeclList-Empty)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDeclList(P) â‡“ (P, [])

**(Parse-FieldDeclList-Cons)**
Î“ âŠ¢ ParseFieldDecl(P) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldDeclTail(P_1, [f]) â‡“ (P_2, fields)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDeclList(P) â‡“ (P_2, fields)

**(Parse-FieldDecl)**
Î“ âŠ¢ ParseVis(P) â‡“ (P_1, vis)    Î“ âŠ¢ ParseKeyBoundaryOpt(P_1) â‡“ (P_2, boundary)    Î“ âŠ¢ ParseIdent(P_2) â‡“ (P_3, name)    IsPunc(Tok(P_3), ":")    Î“ âŠ¢ ParseType(Advance(P_3)) â‡“ (P_4, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDecl(P) â‡“ (P_4, âŸ¨FieldDecl, âŠ¥, vis, boundary, name, ty, âŠ¥, SpanBetween(P, P_4), âŠ¥âŸ©)

**(Parse-FieldDeclTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDeclTail(P, xs) â‡“ (P, xs)

**(Parse-FieldDeclTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDeclTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-FieldDeclTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseFieldDecl(Advance(P)) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldDeclTail(P_1, xs ++ [f]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldDeclTail(P, xs) â‡“ (P_2, ys)

**(Parse-VariantList-Empty)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantList(P) â‡“ (P, [])

**(Parse-VariantList-Cons)**
Î“ âŠ¢ ParseVariant(P) â‡“ (P_1, v)    Î“ âŠ¢ ParseVariantTail(P_1, [v]) â‡“ (P_2, vs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantList(P) â‡“ (P_2, vs)

**(Parse-Variant)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Î“ âŠ¢ ParseVariantPayloadOpt(P_1) â‡“ (P_2, payload_opt)    Î“ âŠ¢ ParseVariantDiscriminantOpt(P_2) â‡“ (P_3, disc_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariant(P) â‡“ (P_3, âŸ¨name, payload_opt, disc_optâŸ©)

**(Parse-VariantPayloadOpt-None)**
Tok(P) âˆ‰ {Punctuator("("), Punctuator("{")}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantPayloadOpt(P) â‡“ (P, âŠ¥)

**(Parse-VariantPayloadOpt-Tuple)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseTypeList(Advance(P)) â‡“ (P_1, ts)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantPayloadOpt(P) â‡“ (Advance(P_1), TuplePayload(ts))

**(Parse-VariantPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseFieldDeclList(Advance(P)) â‡“ (P_1, fs)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantPayloadOpt(P) â‡“ (Advance(P_1), RecordPayload(fs))

**(Parse-VariantDiscriminantOpt-None)**
Â¬ IsOp(Tok(P), "=")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantDiscriminantOpt(P) â‡“ (P, âŠ¥)

**(Parse-VariantDiscriminantOpt-Yes)**
IsOp(Tok(P), "=")    t = Tok(Advance(P))    t.kind = IntLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantDiscriminantOpt(P) â‡“ (Advance(Advance(P)), t)
**(Parse-VariantTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantTail(P, xs) â‡“ (P, xs)

**(Parse-VariantTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-VariantTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseVariant(Advance(P)) â‡“ (P_1, v)    Î“ âŠ¢ ParseVariantTail(P_1, xs ++ [v]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseVariantTail(P, xs) â‡“ (P_2, ys)

**(Parse-Param)**
Î“ âŠ¢ ParseParamModeOpt(P) â‡“ (P_1, mode)    Î“ âŠ¢ ParseIdent(P_1) â‡“ (P_2, name)    IsPunc(Tok(P_2), ":")    Î“ âŠ¢ ParseType(Advance(P_2)) â‡“ (P_3, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParam(P) â‡“ (P_3, âŸ¨mode, name, tyâŸ©)

**(Parse-ParamMode-None)**
Â¬ IsKw(Tok(P), `move`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamModeOpt(P) â‡“ (P, âŠ¥)

**(Parse-ParamMode-Move)**
IsKw(Tok(P), `move`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamModeOpt(P) â‡“ (Advance(P), `move`)

**(Parse-ParamTail-End)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTail(P, xs) â‡“ (P, xs)

**(Parse-ParamTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    TrailingCommaAllowed(P_0, P, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-ParamTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseParam(Advance(P)) â‡“ (P_1, p)    Î“ âŠ¢ ParseParamTail(P_1, xs ++ [p]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTail(P, xs) â‡“ (P_2, ys)
**(Parse-Signature)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseParamList(Advance(P)) â‡“ (P_1, params)    IsPunc(Tok(P_1), ")")    Î“ âŠ¢ ParseReturnOpt(Advance(P_1)) â‡“ (P_2, ret_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSignature(P) â‡“ (P_2, params, ret_opt)



##### 3.3.6.14. Parser Recovery for Unsupported Constructs

**(Parse-Use-Unsupported)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `use`    Î“ âŠ¢ Emit(Code(Unsupported-Construct))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**(Return-At-Module-Err)**
IsKw(Tok(P), `return`)    Î“ âŠ¢ Emit(Code(Return-At-Module-Err))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (SyncItem(Advance(P)), ErrorItem(SpanBetween(P, Advance(P))))

**Generic Syntax Recovery.**
AngleDelta(Operator("<")) = 1
AngleDelta(Operator(">")) = -1
AngleDelta(Operator(">>")) = -2
AngleDelta(t) = 0 if t.kind âˆ‰ {Operator("<"), Operator(">"), Operator(">>")}

AngleStep(P, d) = âŸ¨Advance(P), d + AngleDelta(Tok(P))âŸ©
AngleScan(P_0, P, d) â‡“ P'
Tok(P) = EOF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AngleScan(P_0, P, d) â‡“ P_0
Tok(P) â‰  EOF    AngleStep(P, d) = âŸ¨P_1, d_1âŸ©    d_1 â‰  0    AngleScan(P_0, P_1, d_1) â‡“ P'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AngleScan(P_0, P, d) â‡“ P'
Tok(P) â‰  EOF    AngleStep(P, d) = âŸ¨P_1, d_1âŸ©    d_1 = 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AngleScan(P_0, P, d) â‡“ P_1

SkipAngles(P_0) â‡“ P' â‡” AngleScan(P_0, P_0, 0) â‡“ P'


**(Parse-Item-Err)**
c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Î“ âŠ¢ SyncItem(P_1) â‡“ P_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseItem(P) â‡“ (P_2, ErrorItem(SpanBetween(P, P_2)))

#### 3.3.7. Type Parsing (C0 Subset)

**Type Start Predicate.**
TypeStart(t) â‡” IsKw(t, `const`) âˆ¨ IsKw(t, `unique`) âˆ¨ IsKw(t, `shared`) âˆ¨ Lexeme(t) âˆˆ PrimTypes_C0 âˆ¨ IsPunc(t, "(") âˆ¨ IsPunc(t, "[") âˆ¨ IsOp(t, "*") âˆ¨ IsOp(t, "$") âˆ¨ Lexeme(t) âˆˆ {`string`, `Ptr`} âˆ¨ IsIdent(t)

**(Parse-Type)**
Î“ âŠ¢ ParsePermOpt(P) â‡“ (P_1, perm_opt)    Î“ âŠ¢ ParseNonPermType(P_1) â‡“ (P_2, base)    Î“ âŠ¢ ParseUnionTail(P_2) â‡“ (P_3, ts)    base' = (base if ts = [] else TypeUnion([base] ++ ts))    ty_0 = (base' if perm_opt = âŠ¥ else TypePerm(perm_opt, base'))    Î“ âŠ¢ ParseRefinementOpt(P_3) â‡“ (P_4, pred_opt)    ty = (ty_0 if pred_opt = âŠ¥ else TypeRefine(ty_0, pred_opt))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseType(P) â‡“ (P_4, ty)

**(Parse-Type-Err)**
Î“ âŠ¢ ParsePermOpt(P) â‡“ (P_1, perm_opt)    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P_1).span)    base = TypePrim("!")    ty = (base if perm_opt = âŠ¥ else TypePerm(perm_opt, base))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseType(P) â‡“ (P_1, ty)


**(Parse-Perm-Const)**
IsKw(Tok(P), `const`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePermOpt(P) â‡“ (Advance(P), `const`)

**(Parse-Perm-Unique)**
IsKw(Tok(P), `unique`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePermOpt(P) â‡“ (Advance(P), `unique`)

**(Parse-Perm-Shared)**
IsKw(Tok(P), `shared`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePermOpt(P) â‡“ (Advance(P), `shared`)

**(Parse-Perm-None)**
Â¬ (IsKw(Tok(P), `const`) âˆ¨ IsKw(Tok(P), `unique`) âˆ¨ IsKw(Tok(P), `shared`))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePermOpt(P) â‡“ (P, âŠ¥)

**(Parse-UnionTail-None)**
Â¬ IsOp(Tok(P), "|")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnionTail(P) â‡“ (P, [])

**(Parse-UnionTail-Cons)**
IsOp(Tok(P), "|")    Î“ âŠ¢ ParseNonPermType(Advance(P)) â‡“ (P_1, t_1)    Î“ âŠ¢ ParseUnionTail(P_1) â‡“ (P_2, ts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnionTail(P) â‡“ (P_2, [t_1] ++ ts)

**Refinement Clauses.**

**(Parse-RefinementOpt-None)**
Â¬ IsKw(Tok(P), `where`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRefinementOpt(P) â‡“ (P, âŠ¥)

**(Parse-RefinementOpt-Yes)**
IsKw(Tok(P), `where`)    IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ ParsePredicateExpr(Advance(Advance(P))) â‡“ (P_1, pred)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRefinementOpt(P) â‡“ (Advance(P_1), pred)

ParsePredicateExpr(P) â‡“ (P_1, e) â‡” Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)

**Modal Type References.**

ParseModalTypeRef(P) â‡“ (P_2, tr) â‡” Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path) âˆ§ Î“ âŠ¢ ParseGenericArgsOpt(P_1) â‡“ (P_2, args_opt) âˆ§ tr = (TypePath(path) if args_opt = âŠ¥ else TypeApply(path, args_opt))


**Non-Permission Types.**

PrimLexemeSet = PrimTypes_C0 \ {"()", "!"}
BuiltinTypePath(path) â‡” (|path| = 1 âˆ§ path[0] âˆˆ PrimLexemeSet) âˆ¨ path = ["string"] âˆ¨ path = ["bytes"]

**(Parse-Prim-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) âˆˆ PrimLexemeSet
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(P), TypePrim(Lexeme(Tok(P))))

**(Parse-Unit-Type)**
IsPunc(Tok(P), "(")    IsPunc(Tok(Advance(P)), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(Advance(P)), TypePrim("()"))

**(Parse-Never-Type)**
IsOp(Tok(P), "!")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(P), TypePrim("!"))

**(Parse-Func-Type)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseParamTypeList(Advance(P)) â‡“ (P_1, params)    IsPunc(Tok(P_1), ")")    IsOp(Tok(Advance(P_1)), "->")    Î“ âŠ¢ ParseType(Advance(Advance(P_1))) â‡“ (P_2, ret)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_2, TypeFunc(params, ret))

**(Parse-Tuple-Type)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseTupleTypeElems(Advance(P)) â‡“ (P_1, elems)    elems â‰  []    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(P_1), TypeTuple(elems))

**(Parse-Array-Type)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, t)    IsPunc(Tok(P_1), ";")    Î“ âŠ¢ ParseExpr(Advance(P_1)) â‡“ (P_2, e)    IsPunc(Tok(P_2), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(P_2), TypeArray(t, e))

**(Parse-Slice-Type)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, t)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (Advance(P_1), TypeSlice(t))

**(Parse-Safe-Pointer-Type-ShiftSplit)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "<")    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, t)    IsOp(Tok(P_1), ">>")    P_1' = SplitShiftR(P_1)    Î“ âŠ¢ ParsePtrState(Advance(P_1')) â‡“ (P_2, st_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_2, TypePtr(t, st_opt))

**(Parse-Safe-Pointer-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "<")    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, t)    IsOp(Tok(P_1), ">")    Î“ âŠ¢ ParsePtrState(Advance(P_1)) â‡“ (P_2, st_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_2, TypePtr(t, st_opt))

**(Parse-Raw-Pointer-Type)**
IsOp(Tok(P), "*")    IsKw(Tok(Advance(P)), q)    q âˆˆ {`imm`, `mut`}    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypeRawPtr(q, t))

**(Parse-String-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `string`    Î“ âŠ¢ ParseStringState(Advance(P)) â‡“ (P_1, st_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypeString(st_opt))

**(Parse-Bytes-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `bytes`    Î“ âŠ¢ ParseBytesState(Advance(P)) â‡“ (P_1, st_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypeBytes(st_opt))

**(Parse-Dynamic-Type)**
IsOp(Tok(P), "$")    Î“ âŠ¢ ParseTypePath(Advance(P)) â‡“ (P_1, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypeDynamic(path))

**(Parse-Modal-State-Type)**
Î“ âŠ¢ ParseModalTypeRef(P) â‡“ (P_1, modal_ref)    IsOp(Tok(P_1), "@")    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, state)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_2, TypeModalState(modal_ref, state))

**(Parse-Opaque-Type)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `opaque`    Î“ âŠ¢ ParseTypePath(Advance(P)) â‡“ (P_1, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypeOpaque(path))

**(Parse-Type-Apply)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    IsOp(Tok(P_1), "<")    Î“ âŠ¢ ParseGenericArgs(P_1) â‡“ (P_2, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_2, TypeApply(path, args))

**(Parse-Type-Path)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    Â¬ IsOp(Tok(P_1), "@")    Â¬ IsOp(Tok(P_1), "<")    Â¬ BuiltinTypePath(path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseNonPermType(P) â‡“ (P_1, TypePath(path))

##### 3.3.7.1. Type Helper Parsing Rules

**Tuple Type Elements.**

**(Parse-TupleTypeElems-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleTypeElems(P) â‡“ (P, [])

**(Parse-TupleTypeElems-One)**
Î“ âŠ¢ ParseType(P) â‡“ (P_1, t)    IsPunc(Tok(P_1), ";")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleTypeElems(P) â‡“ (Advance(P_1), [t])

**(Parse-TupleTypeElems-TrailingComma)**
Î“ âŠ¢ ParseType(P) â‡“ (P_1, t)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    TrailingCommaAllowed(P_0, P_1, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleTypeElems(P) â‡“ (Advance(P_1), [t])

**(Parse-TupleTypeElems-Many)**
Î“ âŠ¢ ParseType(P) â‡“ (P_1, t_1)    IsPunc(Tok(P_1), ",")    Î“ âŠ¢ ParseType(Advance(P_1)) â‡“ (P_2, t_2)    Î“ âŠ¢ ParseTypeListTail(P_2, [t_2]) â‡“ (P_3, ts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleTypeElems(P) â‡“ (P_3, [t_1] ++ ts)

**Param Type Lists.**

**(Parse-ParamTypeList-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTypeList(P) â‡“ (P, [])

**(Parse-ParamTypeList-Cons)**
Î“ âŠ¢ ParseParamType(P) â‡“ (P_1, pt)    Î“ âŠ¢ ParseParamTypeListTail(P_1, [pt]) â‡“ (P_2, pts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTypeList(P) â‡“ (P_2, pts)

**(Parse-ParamTypeListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTypeListTail(P, ps) â‡“ (P, ps)

**(Parse-ParamTypeListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseParamType(Advance(P)) â‡“ (P_1, pt)    Î“ âŠ¢ ParseParamTypeListTail(P_1, ps ++ [pt]) â‡“ (P_2, ps')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamTypeListTail(P, ps) â‡“ (P_2, ps')

**Param Types.**

**(Parse-ParamType-Move)**
IsKw(Tok(P), `move`)    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamType(P) â‡“ (P_1, âŸ¨`move`, tyâŸ©)

**(Parse-ParamType-Plain)**
Â¬ IsKw(Tok(P), `move`)    Î“ âŠ¢ ParseType(P) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParamType(P) â‡“ (P_1, âŸ¨âŠ¥, tyâŸ©)

**String State.**

**(Parse-StringState-None)**
Â¬ IsOp(Tok(P), "@")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStringState(P) â‡“ (P, âŠ¥)

**(Parse-StringState-Managed)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Managed`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStringState(P) â‡“ (Advance(Advance(P)), `Managed`)

**(Parse-StringState-View)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `View`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStringState(P) â‡“ (Advance(Advance(P)), `View`)

**Bytes State.**

**(Parse-BytesState-None)**
Â¬ IsOp(Tok(P), "@")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseBytesState(P) â‡“ (P, âŠ¥)

**(Parse-BytesState-Managed)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Managed`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseBytesState(P) â‡“ (Advance(Advance(P)), `Managed`)

**(Parse-BytesState-View)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `View`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseBytesState(P) â‡“ (Advance(Advance(P)), `View`)

**Pointer State.**

**(Parse-PtrState-None)**
Â¬ IsOp(Tok(P), "@")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePtrState(P) â‡“ (P, âŠ¥)

**(Parse-PtrState-Valid)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePtrState(P) â‡“ (Advance(Advance(P)), `Valid`)

**(Parse-PtrState-Null)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Null`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePtrState(P) â‡“ (Advance(Advance(P)), `Null`)

**(Parse-PtrState-Expired)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `Expired`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePtrState(P) â‡“ (Advance(Advance(P)), `Expired`)

**Type Lists.**

**(Parse-TypeList-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeList(P) â‡“ (P, [])

**(Parse-TypeList-Cons)**
Î“ âŠ¢ ParseType(P) â‡“ (P_1, t)    Î“ âŠ¢ ParseTypeListTail(P_1, [t]) â‡“ (P_2, ts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeList(P) â‡“ (P_2, ts)

**(Parse-TypeListTail-End)**
Tok(P) âˆˆ {Punctuator(")"), Punctuator("}"), Operator(">")}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeListTail(P, xs) â‡“ (P, xs)

**(Parse-TypeListTail-TrailingComma)**
IsPunc(Tok(P), ",")    Tok(Advance(P)) âˆˆ {Punctuator(")"), Punctuator("}"), Operator(">")}    TrailingCommaAllowed(P_0, P, {Punctuator(")"), Punctuator("}"), Operator(">")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-TypeListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, t)    Î“ âŠ¢ ParseTypeListTail(P_1, xs ++ [t]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTypeListTail(P, xs) â‡“ (P_2, ys)

#### 3.3.8. Expression Parsing and Precedence

**Operator Sets.**
LogicalOrOps = {"||"}
LogicalAndOps = {"&&"}
ComparisonOps = {"==", "!=", "<", "<=", ">", ">="}
BitOrOps = {"|"}
BitXorOps = {"^"}
BitAndOps = {"&"}
AddOps = {"+", "-"}
MulOps = {"*", "/", "%"}

**(Parse-Expr-Attr)**
IsPunc(Tok(P), "[[")    Î“ âŠ¢ ParseAttrList(P) â‡“ (P_1, attrs)    Î“ âŠ¢ ParseRange(P_1) â‡“ (P_2, e)    AttachExprAttrs(e, attrs) = e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExpr(P) â‡“ (P_2, e')

**(Parse-Expr-NoAttr)**
Â¬ IsPunc(Tok(P), "[[")    Î“ âŠ¢ ParseRange(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)

##### 3.3.8.1. Range Expressions

ExprStart(t) â‡” IsIdent(t) âˆ¨ (t âˆˆ LiteralToken) âˆ¨ IsPunc(t, "(") âˆ¨ IsPunc(t, "[") âˆ¨ IsPunc(t, "{")
              âˆ¨ IsOp(t, "!") âˆ¨ IsOp(t, "-") âˆ¨ IsOp(t, "&") âˆ¨ IsOp(t, "*") âˆ¨ IsOp(t, "^")
              âˆ¨ IsKw(t, `if`) âˆ¨ IsKw(t, `match`) âˆ¨ IsKw(t, `loop`) âˆ¨ IsKw(t, `unsafe`) âˆ¨ IsKw(t, `move`) âˆ¨ IsKw(t, `transmute`) âˆ¨ IsKw(t, `widen`) âˆ¨ IsKw(t, `parallel`) âˆ¨ IsKw(t, `spawn`) âˆ¨ IsKw(t, `dispatch`) âˆ¨ IsKw(t, `yield`) âˆ¨ IsKw(t, `sync`) âˆ¨ IsKw(t, `race`) âˆ¨ IsKw(t, `all`)

**(Parse-Range-To)**
IsOp(Tok(P), "..")    Î“ âŠ¢ ParseLogicalOr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRange(P) â‡“ (P_1, Range(To, âŠ¥, e))

**(Parse-Range-ToInc)**
IsOp(Tok(P), "..=")    Î“ âŠ¢ ParseLogicalOr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRange(P) â‡“ (P_1, Range(ToInclusive, âŠ¥, e))

**(Parse-Range-Full)**
IsOp(Tok(P), "..")    Tok(Advance(P)) âˆ‰ ExprStart
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRange(P) â‡“ (Advance(P), Range(Full, âŠ¥, âŠ¥))

**(Parse-Range-Lhs)**
Î“ âŠ¢ ParseLogicalOr(P) â‡“ (P_1, e_0)    Î“ âŠ¢ ParseRangeTail(P_1, e_0) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRange(P) â‡“ (P_2, e)

**(Parse-RangeTail-None)**
Â¬ (IsOp(Tok(P), "..") âˆ¨ IsOp(Tok(P), "..="))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRangeTail(P, e) â‡“ (P, e)

**(Parse-RangeTail-From)**
IsOp(Tok(P), "..")    Tok(Advance(P)) âˆ‰ ExprStart
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRangeTail(P, e_0) â‡“ (Advance(P), Range(From, e_0, âŠ¥))

**(Parse-RangeTail-Excl)**
IsOp(Tok(P), "..")    Tok(Advance(P)) âˆˆ ExprStart    Î“ âŠ¢ ParseLogicalOr(Advance(P)) â‡“ (P_1, e_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRangeTail(P, e_0) â‡“ (P_1, Range(Exclusive, e_0, e_1))

**(Parse-RangeTail-Incl)**
IsOp(Tok(P), "..=")    Î“ âŠ¢ ParseLogicalOr(Advance(P)) â‡“ (P_1, e_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRangeTail(P, e_0) â‡“ (P_1, Range(Inclusive, e_0, e_1))

##### 3.3.8.2. Binary Operator Chains

Î“ âŠ¢ ParseLogicalOr(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, LogicalOrOps, ParseLogicalAnd) â‡“ (P', e)
Î“ âŠ¢ ParseLogicalAnd(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, LogicalAndOps, ParseComparison) â‡“ (P', e)
Î“ âŠ¢ ParseComparison(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, ComparisonOps, ParseBitOr) â‡“ (P', e)
Î“ âŠ¢ ParseBitOr(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, BitOrOps, ParseBitXor) â‡“ (P', e)
Î“ âŠ¢ ParseBitXor(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, BitXorOps, ParseBitAnd) â‡“ (P', e)
Î“ âŠ¢ ParseBitAnd(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, BitAndOps, ParseShift) â‡“ (P', e)
Î“ âŠ¢ ParseShift(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, ShiftOps, ParseAdd) â‡“ (P', e)
Î“ âŠ¢ ParseAdd(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, AddOps, ParseMul) â‡“ (P', e)
Î“ âŠ¢ ParseMul(P) â‡“ (P', e) â‡” Î“ âŠ¢ ParseLeftChain(P, MulOps, ParsePower) â‡“ (P', e)

**(Parse-LeftChain)**
Î“ âŠ¢ ParseHigher(P) â‡“ (P_1, e_0)    Î“ âŠ¢ ParseLeftChainTail(P_1, e_0, OpSet, ParseHigher) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLeftChain(P, OpSet, ParseHigher) â‡“ (P_2, e)

**(Parse-LeftChain-Stop)**
Tok(P) âˆ‰ OpSet
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLeftChainTail(P, e, OpSet, ParseHigher) â‡“ (P, e)

**(Parse-LeftChain-Cons)**
Tok(P) = op âˆˆ OpSet    Î“ âŠ¢ ParseHigher(Advance(P)) â‡“ (P_1, e_1)    e' = Binary(op, e, e_1)    Î“ âŠ¢ ParseLeftChainTail(P_1, e', OpSet, ParseHigher) â‡“ (P_2, e'')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLeftChainTail(P, e, OpSet, ParseHigher) â‡“ (P_2, e'')


##### 3.3.8.3. Power (Right-Associative)

**(Parse-Power)**
Î“ âŠ¢ ParseCast(P) â‡“ (P_1, e_0)    Î“ âŠ¢ ParsePowerTail(P_1, e_0) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePower(P) â‡“ (P_2, e)

**(Parse-PowerTail-None)**
Â¬ IsOp(Tok(P), "**")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePowerTail(P, e) â‡“ (P, e)

**(Parse-PowerTail-Cons)**
IsOp(Tok(P), "**")    Î“ âŠ¢ ParsePower(Advance(P)) â‡“ (P_1, e_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePowerTail(P, e_0) â‡“ (P_1, Binary("**", e_0, e_1))

##### 3.3.8.4. Cast Expressions

**(Parse-Cast)**
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, e)    Î“ âŠ¢ ParseCastTail(P_1, e) â‡“ (P_2, e')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseCast(P) â‡“ (P_2, e')

**(Parse-CastTail-None)**
Â¬ IsKw(Tok(P), `as`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseCastTail(P, e) â‡“ (P, e)

**(Parse-CastTail-As)**
IsKw(Tok(P), `as`)    Î“ âŠ¢ ParseType(Advance(P)) â‡“ (P_1, t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseCastTail(P, e) â‡“ (P_1, Cast(e, t))

##### 3.3.8.5. Unary and Postfix

**(Parse-Unary-Prefix)**
Tok(P) = op âˆˆ {"!", "-"}    Î“ âŠ¢ ParseUnary(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, Unary(op, e))

**(Parse-Unary-Deref)**
IsOp(Tok(P), "*")    Î“ âŠ¢ ParseUnary(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, Deref(e))

**(Parse-Unary-AddressOf)**
IsOp(Tok(P), "&")    Î“ âŠ¢ ParsePlace(Advance(P)) â‡“ (P_1, p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, AddressOf(p))

**(Parse-Unary-Move)**
IsKw(Tok(P), `move`)    Î“ âŠ¢ ParsePlace(Advance(P)) â‡“ (P_1, p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, MoveExpr(p))

**(Parse-Unary-Widen)**
IsKw(Tok(P), `widen`)    Î“ âŠ¢ ParseUnary(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, Unary(`widen`, e))

**(Parse-Unary-Postfix)**
Î“ âŠ¢ ParsePostfix(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseUnary(P) â‡“ (P_1, e)

**(Parse-Postfix)**
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, e_0)    Î“ âŠ¢ ParsePostfixTail(P_1, e_0) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePostfix(P) â‡“ (P_2, e)

##### 3.3.8.6. Primary Expressions

**(Parse-Comptime-Unsupported)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `comptime`    IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ Emit(Code(Unsupported-Construct))    Î“ âŠ¢ SyncStmt(P) â‡“ P_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, ErrorExpr(SpanBetween(P, P_1)))

**(Parse-Literal-Expr)**
Tok(P).kind âˆˆ {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P), Literal(Tok(P)))

**(Parse-Null-Ptr)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `Ptr`    IsOp(Tok(Advance(P)), "::")    Tok(Advance(Advance(P))).kind = NullLiteral    IsPunc(Tok(Advance(Advance(Advance(P)))), "(")    IsPunc(Tok(Advance(Advance(Advance(Advance(P))))), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(Advance(Advance(Advance(Advance(P))))), PtrNullExpr)

**(Parse-Contract-Result)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `result`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(Advance(P)), ContractResult)

**(Parse-Contract-Entry)**
IsOp(Tok(P), "@")    IsIdent(Tok(Advance(P)))    Lexeme(Tok(Advance(P))) = `entry`    IsPunc(Tok(Advance(Advance(P))), "(")    Î“ âŠ¢ ParseExpr(Advance(Advance(Advance(P)))) â‡“ (P_1, e)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), ContractEntry(e))

**(Parse-Alloc-Implicit)**
IsOp(Tok(P), "^")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, AllocExpr(âŠ¥, e))


**(Parse-Identifier-Expr)**
IsIdent(Tok(P))    Â¬ IsOp(Tok(Advance(P)), "::")    Â¬ IsOp(Tok(Advance(P)), "@")    Â¬ IsPunc(Tok(Advance(P)), "{")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P), Identifier(Lexeme(Tok(P))))

**(Parse-Qualified-Name)**
Î“ âŠ¢ ParseQualifiedHead(P) â‡“ (P_1, path, name)    Tok(P_1) âˆ‰ {Punctuator("("), Punctuator("{")}    Â¬ IsOp(Tok(P_1), "@")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, QualifiedName(path, name))

**(Parse-Qualified-Apply-Paren)**
Î“ âŠ¢ ParseQualifiedHead(P) â‡“ (P_1, path, name)    IsPunc(Tok(P_1), "(")    Î“ âŠ¢ ParseArgList(Advance(P_1)) â‡“ (P_2, args)    IsPunc(Tok(P_2), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_2), QualifiedApply(path, name, Paren(args)))

**(Parse-Qualified-Apply-Brace)**
Î“ âŠ¢ ParseQualifiedHead(P) â‡“ (P_1, path, name)    IsPunc(Tok(P_1), "{")    Î“ âŠ¢ ParseFieldInitList(Advance(P_1)) â‡“ (P_2, fields)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_2), QualifiedApply(path, name, Brace(fields)))

**(Parse-Parenthesized-Expr)**
IsPunc(Tok(P), "(")    Â¬ TupleParen(P)    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), e)

**(Parse-Tuple-Literal)**
IsPunc(Tok(P), "(")    TupleParen(P)    Î“ âŠ¢ ParseTupleExprElems(Advance(P)) â‡“ (P_1, elems)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), TupleExpr(elems))

**(Parse-Array-Literal)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseExprList(Advance(P)) â‡“ (P_1, elems)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), ArrayExpr(elems))

**(Parse-Record-Literal-ModalState)**
Î“ âŠ¢ ParseModalTypeRef(P) â‡“ (P_1, modal_ref)    IsOp(Tok(P_1), "@")    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, state)    IsPunc(Tok(P_2), "{")    Î“ âŠ¢ ParseFieldInitList(Advance(P_2)) â‡“ (P_3, fields)    IsPunc(Tok(P_3), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_3), RecordExpr(ModalStateRef(modal_ref, state), fields))

**(Parse-Record-Literal)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    |path| = 1    IsPunc(Tok(P_1), "{")    Î“ âŠ¢ ParseFieldInitList(Advance(P_1)) â‡“ (P_2, fields)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_2), RecordExpr(TypePath(path), fields))


RuleSet(ParsePrimary_NoBrace) = RuleSet(ParsePrimary) \ {Parse-Record-Literal, Parse-Record-Literal-ModalState, Parse-Qualified-Apply-Brace}
RuleSet(ParsePostfix_NoBrace) = RuleSet(ParsePostfix) with ParsePrimary replaced by ParsePrimary_NoBrace
RuleSet(ParseUnary_NoBrace) = RuleSet(ParseUnary) with ParsePostfix replaced by ParsePostfix_NoBrace
RuleSet(ParseLogicalOr_NoBrace) = RuleSet(ParseLogicalOr) with ParseLogicalAnd replaced by ParseLogicalAnd_NoBrace
RuleSet(ParseLogicalAnd_NoBrace) = RuleSet(ParseLogicalAnd) with ParseComparison replaced by ParseComparison_NoBrace
RuleSet(ParseComparison_NoBrace) = RuleSet(ParseComparison) with ParseBitOr replaced by ParseBitOr_NoBrace
RuleSet(ParseBitOr_NoBrace) = RuleSet(ParseBitOr) with ParseBitXor replaced by ParseBitXor_NoBrace
RuleSet(ParseBitXor_NoBrace) = RuleSet(ParseBitXor) with ParseBitAnd replaced by ParseBitAnd_NoBrace
RuleSet(ParseBitAnd_NoBrace) = RuleSet(ParseBitAnd) with ParseShift replaced by ParseShift_NoBrace
RuleSet(ParseShift_NoBrace) = RuleSet(ParseShift) with ParseAdd replaced by ParseAdd_NoBrace
RuleSet(ParseAdd_NoBrace) = RuleSet(ParseAdd) with ParseMul replaced by ParseMul_NoBrace
RuleSet(ParseMul_NoBrace) = RuleSet(ParseMul) with ParsePower replaced by ParsePower_NoBrace
RuleSet(ParseRange_NoBrace) = RuleSet(ParseRange) with ParseLogicalOr replaced by ParseLogicalOr_NoBrace
RuleSet(ParseExpr_NoBrace) = RuleSet(ParseExpr) with ParseRange replaced by ParseRange_NoBrace

Î“ âŠ¢ ParseRange_NoBrace(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExpr_NoBrace(P) â‡“ (P_1, e)

**(Parse-If-Expr)**
IsKw(Tok(P), `if`)    Î“ âŠ¢ ParseExpr_NoBrace(Advance(P)) â‡“ (P_1, c)    Î“ âŠ¢ ParseBlock(P_1) â‡“ (P_2, b1)    Î“ âŠ¢ ParseElseOpt(P_2) â‡“ (P_3, b2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_3, IfExpr(c, b1, b2))

**(Parse-Match-Expr)**
IsKw(Tok(P), `match`)    Î“ âŠ¢ ParseExpr_NoBrace(Advance(P)) â‡“ (P_1, e)    IsPunc(Tok(P_1), "{")    Î“ âŠ¢ ParseMatchArms(Advance(P_1)) â‡“ (P_2, arms)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_2), MatchExpr(e, arms))

**(Parse-Loop-Expr)**
IsKw(Tok(P), `loop`)    Î“ âŠ¢ ParseLoopTail(Advance(P)) â‡“ (P_1, loop)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, loop)

**(Parse-Parallel-Expr)**
IsKw(Tok(P), `parallel`)    Î“ âŠ¢ ParseExpr_NoBrace(Advance(P)) â‡“ (P_1, domain)    Î“ âŠ¢ ParseParallelOptsOpt(P_1) â‡“ (P_2, opts)    Î“ âŠ¢ ParseBlock(P_2) â‡“ (P_3, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_3, ParallelExpr(domain, opts, body))

**(Parse-Spawn-Expr)**
IsKw(Tok(P), `spawn`)    Î“ âŠ¢ ParseSpawnOptsOpt(Advance(P)) â‡“ (P_1, opts)    Î“ âŠ¢ ParseBlock(P_1) â‡“ (P_2, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_2, SpawnExpr(opts, body))

**(Parse-Wait-Expr)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `wait`    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, handle)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, WaitExpr(handle))

**(Parse-Dispatch-Expr)**
IsKw(Tok(P), `dispatch`)    Î“ âŠ¢ ParsePattern(Advance(P)) â‡“ (P_1, pat)    IsIdent(Tok(P_1))    Lexeme(Tok(P_1)) = `in`    Î“ âŠ¢ ParseRange(Advance(P_1)) â‡“ (P_2, range)    Î“ âŠ¢ ParseKeyClauseOpt(P_2) â‡“ (P_3, key_clause_opt)    Î“ âŠ¢ ParseDispatchOptsOpt(P_3) â‡“ (P_4, opts)    Î“ âŠ¢ ParseBlock(P_4) â‡“ (P_5, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_5, DispatchExpr(pat, range, key_clause_opt, opts, body))

**(Parse-Yield-From-Expr)**
IsKw(Tok(P), `yield`)    P_1 = Advance(P)    (IsIdent(Tok(P_1)) âˆ§ Lexeme(Tok(P_1)) = `release` â‡’ release_opt = Release âˆ§ P_2 = Advance(P_1))    (Â¬(IsIdent(Tok(P_1)) âˆ§ Lexeme(Tok(P_1)) = `release`) â‡’ release_opt = âŠ¥ âˆ§ P_2 = P_1)    IsKw(Tok(P_2), `from`)    Î“ âŠ¢ ParseExpr(Advance(P_2)) â‡“ (P_3, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_3, YieldFromExpr(release_opt, e))

**(Parse-Yield-Expr)**
IsKw(Tok(P), `yield`)    P_1 = Advance(P)    (IsIdent(Tok(P_1)) âˆ§ Lexeme(Tok(P_1)) = `release` â‡’ release_opt = Release âˆ§ P_2 = Advance(P_1))    (Â¬(IsIdent(Tok(P_1)) âˆ§ Lexeme(Tok(P_1)) = `release`) â‡’ release_opt = âŠ¥ âˆ§ P_2 = P_1)    Â¬ IsKw(Tok(P_2), `from`)    Î“ âŠ¢ ParseExpr(P_2) â‡“ (P_3, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_3, YieldExpr(release_opt, e))

**(Parse-Sync-Expr)**
IsKw(Tok(P), `sync`)    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, SyncExpr(e))

**(Parse-Race-Expr)**
IsKw(Tok(P), `race`)    IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ ParseRaceArms(Advance(Advance(P))) â‡“ (P_1, arms)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), RaceExpr(arms))

**(Parse-All-Expr)**
IsKw(Tok(P), `all`)    IsPunc(Tok(Advance(P)), "{")    Î“ âŠ¢ ParseAllExprList(Advance(Advance(P))) â‡“ (P_1, es)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_1), AllExpr(es))

**(Parse-Block-Expr)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseBlock(P) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, b)

**(Parse-Unsafe-Expr)**
IsKw(Tok(P), `unsafe`)    Î“ âŠ¢ ParseBlock(Advance(P)) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_1, UnsafeBlockExpr(b))

**(Parse-Transmute-Expr-ShiftSplit)**
IsKw(Tok(P), `transmute`)    IsOp(Tok(Advance(P)), "<")    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, t1)    IsPunc(Tok(P_1), ",")    Î“ âŠ¢ ParseType(Advance(P_1)) â‡“ (P_2, t2)    IsOp(Tok(P_2), ">>")    P_2' = SplitShiftR(P_2)    IsOp(Tok(P_2'), ">")    IsPunc(Tok(Advance(P_2')), "(")    Î“ âŠ¢ ParseExpr(Advance(Advance(P_2'))) â‡“ (P_3, e)    IsPunc(Tok(P_3), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_3), TransmuteExpr(t1, t2, e))

**(Parse-Transmute-Expr)**
IsKw(Tok(P), `transmute`)    IsOp(Tok(Advance(P)), "<")    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, t1)    IsPunc(Tok(P_1), ",")    Î“ âŠ¢ ParseType(Advance(P_1)) â‡“ (P_2, t2)    IsOp(Tok(P_2), ">")    IsPunc(Tok(Advance(P_2)), "(")    Î“ âŠ¢ ParseExpr(Advance(Advance(P_2))) â‡“ (P_3, e)    IsPunc(Tok(P_3), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (Advance(P_3), TransmuteExpr(t1, t2, e))


**(Parse-Primary-Err)**
c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Î“ âŠ¢ SyncStmt(P_1) â‡“ P_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePrimary(P) â‡“ (P_2, ErrorExpr(SpanBetween(P, P_2)))

##### 3.3.8.7. Expression Helper Parsing Rules

**Postfix Tail.**

**(Parse-PostfixTail-Stop)**
Â¬ PostfixStart(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePostfixTail(P, e) â‡“ (P, e)

**(Parse-PostfixTail-Cons)**
PostfixStart(P)    Î“ âŠ¢ PostfixStep(P, e) â‡“ (P_1, e_1)    Î“ âŠ¢ ParsePostfixTail(P_1, e_1) â‡“ (P_2, e_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePostfixTail(P, e) â‡“ (P_2, e_2)

PostfixStartTok = {Punctuator("."), Punctuator("["), Punctuator("("), Operator("~>"), Operator("?")}
CallTypeArgsStart(P) â‡” TypeArgsStartTok(Tok(P)) âˆ§ (Î“ âŠ¢ ParseGenericArgs(P) â‡“ (P_1, args)) âˆ§ IsPunc(Tok(P_1), "(")
PostfixStart(P) â‡” Tok(P) âˆˆ PostfixStartTok âˆ¨ CallTypeArgsStart(P)

**(Postfix-Field)**
IsPunc(Tok(P), ".")    IsIdent(Tok(Advance(P)))    name = Lexeme(Tok(Advance(P)))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(Advance(P)), FieldAccess(e, name))

**(Postfix-TupleIndex)**
IsPunc(Tok(P), ".")    t = Tok(Advance(P))    t.kind = IntLiteral    idx = IntValue(t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(Advance(P)), TupleAccess(e, idx))

**(Postfix-Index)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, idx)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(P_1), IndexAccess(e, idx))

**(Postfix-Call)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseArgList(Advance(P)) â‡“ (P_1, args)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(P_1), Call(e, args))

**(Postfix-Call-TypeArgs)**
CallTypeArgsStart(P)    Î“ âŠ¢ ParseGenericArgs(P) â‡“ (P_1, targs)    IsPunc(Tok(P_1), "(")    Î“ âŠ¢ ParseArgList(Advance(P_1)) â‡“ (P_2, args)    IsPunc(Tok(P_2), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(P_2), CallTypeArgs(e, targs, args))

**(Postfix-MethodCall)**
IsOp(Tok(P), "~>")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, name)    IsPunc(Tok(P_1), "(")    Î“ âŠ¢ ParseArgList(Advance(P_1)) â‡“ (P_2, args)    IsPunc(Tok(P_2), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(P_2), MethodCall(e, name, args))

**(Postfix-Propagate)**
IsOp(Tok(P), "?")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PostfixStep(P, e) â‡“ (Advance(P), Propagate(e))

**Argument Lists.**

**(Parse-ArgList-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgList(P) â‡“ (P, [])

**(Parse-ArgList-Cons)**
Î“ âŠ¢ ParseArg(P) â‡“ (P_1, a)    Î“ âŠ¢ ParseArgTail(P_1, [a]) â‡“ (P_2, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgList(P) â‡“ (P_2, args)

**(Parse-Arg)**
Î“ âŠ¢ ParseArgMoveOpt(P) â‡“ (P_1, moved)    Î“ âŠ¢ ParseExpr(P_1) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArg(P) â‡“ (P_2, âŸ¨moved, e, SpanBetween(P, P_2)âŸ©)

**(Parse-ArgMoveOpt-None)**
Â¬ IsKw(Tok(P), `move`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgMoveOpt(P) â‡“ (P, false)

**(Parse-ArgMoveOpt-Yes)**
IsKw(Tok(P), `move`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgMoveOpt(P) â‡“ (Advance(P), true)

**Key Paths.**

**(Parse-KeyMarkerOpt-Yes)**
IsOp(Tok(P), "#")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyMarkerOpt(P) â‡“ (Advance(P), true)

**(Parse-KeyMarkerOpt-No)**
Â¬ IsOp(Tok(P), "#")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyMarkerOpt(P) â‡“ (P, false)

**(Parse-KeyField)**
Î“ âŠ¢ ParseKeyMarkerOpt(P) â‡“ (P_1, marked)    Î“ âŠ¢ ParseIdent(P_1) â‡“ (P_2, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyField(P) â‡“ (P_2, Field(marked, name))

**(Parse-KeyIndex)**
Î“ âŠ¢ ParseKeyMarkerOpt(P) â‡“ (P_1, marked)    Î“ âŠ¢ ParseExpr(P_1) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyIndex(P) â‡“ (P_2, Index(marked, e))

**(Parse-KeySegs-End)**
Tok(P) âˆ‰ {Punctuator("."), Punctuator("[")}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeySegs(P, xs) â‡“ (P, xs)

**(Parse-KeySegs-Field)**
IsPunc(Tok(P), ".")    Î“ âŠ¢ ParseKeyField(Advance(P)) â‡“ (P_1, seg)    Î“ âŠ¢ ParseKeySegs(P_1, xs ++ [seg]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeySegs(P, xs) â‡“ (P_2, ys)

**(Parse-KeySegs-Index)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseKeyIndex(Advance(P)) â‡“ (P_1, seg)    IsPunc(Tok(P_1), "]")    Î“ âŠ¢ ParseKeySegs(Advance(P_1), xs ++ [seg]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeySegs(P, xs) â‡“ (P_2, ys)

**(Parse-KeyPathExpr)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, root)    Î“ âŠ¢ ParseKeySegs(P_1, []) â‡“ (P_2, segs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyPathExpr(P) â‡“ (P_2, âŸ¨root, segsâŸ©)

**(Parse-KeyPathList-Cons)**
Î“ âŠ¢ ParseKeyPathExpr(P) â‡“ (P_1, kp)    Î“ âŠ¢ ParseKeyPathListTail(P_1, [kp]) â‡“ (P_2, ks)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyPathList(P) â‡“ (P_2, ks)

**(Parse-KeyPathListTail-End)**
Â¬ IsPunc(Tok(P), ",")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyPathListTail(P, xs) â‡“ (P, xs)

**(Parse-KeyPathListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseKeyPathExpr(Advance(P)) â‡“ (P_1, kp)    Î“ âŠ¢ ParseKeyPathListTail(P_1, xs ++ [kp]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyPathListTail(P, xs) â‡“ (P_2, ys)

**Key Modes and Modifiers.**

**(Parse-KeyBlockMod-Dynamic)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `dynamic`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBlockMod(P) â‡“ (Advance(P), Dynamic)

**(Parse-KeyBlockMod-Speculative)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `speculative`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBlockMod(P) â‡“ (Advance(P), Speculative)

**(Parse-KeyBlockMod-Release)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `release`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBlockMod(P) â‡“ (Advance(P), Release)

**(Parse-KeyBlockModsOpt-None)**
Â¬ (IsIdent(Tok(P)) âˆ§ Lexeme(Tok(P)) âˆˆ {`dynamic`, `speculative`, `release`})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBlockModsOpt(P) â‡“ (P, [])

**(Parse-KeyBlockModsOpt-Cons)**
Î“ âŠ¢ ParseKeyBlockMod(P) â‡“ (P_1, m)    Î“ âŠ¢ ParseKeyBlockModsOpt(P_1) â‡“ (P_2, ms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyBlockModsOpt(P) â‡“ (P_2, [m] ++ ms)

**(Parse-KeyMode-Read)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `read`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyMode(P) â‡“ (Advance(P), Read)

**(Parse-KeyMode-Write)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `write`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyMode(P) â‡“ (Advance(P), Write)

**(Parse-KeyMode-Err)**
Â¬ (IsIdent(Tok(P)) âˆ§ Lexeme(Tok(P)) âˆˆ {`read`, `write`})    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyMode(P) â‡“ (P, Read)

**(Parse-KeyModeOpt-None)**
Â¬ (IsIdent(Tok(P)) âˆ§ Lexeme(Tok(P)) âˆˆ {`read`, `write`})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyModeOpt(P) â‡“ (P, âŠ¥)

**(Parse-KeyModeOpt-Some)**
Î“ âŠ¢ ParseKeyMode(P) â‡“ (P_1, mode)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyModeOpt(P) â‡“ (P_1, mode)

**(Parse-KeyClauseOpt-None)**
Â¬ Ctx(Tok(P), `key`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyClauseOpt(P) â‡“ (P, âŠ¥)

**(Parse-KeyClauseOpt-Yes)**
Ctx(Tok(P), `key`)    Î“ âŠ¢ ParseKeyPathExpr(Advance(P)) â‡“ (P_1, path)    Î“ âŠ¢ ParseKeyMode(P_1) â‡“ (P_2, mode)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseKeyClauseOpt(P) â‡“ (P_2, âŸ¨path, modeâŸ©)

**Parallel Options.**

**(Parse-ParallelOptsOpt-None)**
Â¬ IsPunc(Tok(P), "[")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptsOpt(P) â‡“ (P, [])

**(Parse-ParallelOptsOpt-Yes)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseParallelOptList(Advance(P)) â‡“ (P_1, opts)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptsOpt(P) â‡“ (Advance(P_1), opts)

**(Parse-ParallelOptList-Empty)**
IsPunc(Tok(P), "]")    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptList(P) â‡“ (P, [])

**(Parse-ParallelOptList-Cons)**
Î“ âŠ¢ ParseParallelOpt(P) â‡“ (P_1, opt)    Î“ âŠ¢ ParseParallelOptListTail(P_1, [opt]) â‡“ (P_2, opts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptList(P) â‡“ (P_2, opts)

**(Parse-ParallelOptListTail-End)**
IsPunc(Tok(P), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptListTail(P, xs) â‡“ (P, xs)

**(Parse-ParallelOptListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "]")    TrailingCommaAllowed(P_0, P, {Punctuator("]")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-ParallelOptListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseParallelOpt(Advance(P)) â‡“ (P_1, opt)    Î“ âŠ¢ ParseParallelOptListTail(P_1, xs ++ [opt]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOptListTail(P, xs) â‡“ (P_2, ys)

**(Parse-ParallelOpt-Cancel)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `cancel`    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseExpr(Advance(Advance(P))) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOpt(P) â‡“ (P_1, Cancel(e))

**(Parse-ParallelOpt-Name)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `name`    IsPunc(Tok(Advance(P)), ":")    Tok(Advance(Advance(P))).kind = StringLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseParallelOpt(P) â‡“ (Advance(Advance(Advance(P))), Name(Tok(Advance(Advance(P)))))

**Spawn Options.**

**(Parse-SpawnOptsOpt-None)**
Â¬ IsPunc(Tok(P), "[")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptsOpt(P) â‡“ (P, [])

**(Parse-SpawnOptsOpt-Yes)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseSpawnOptList(Advance(P)) â‡“ (P_1, opts)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptsOpt(P) â‡“ (Advance(P_1), opts)

**(Parse-SpawnOptList-Empty)**
IsPunc(Tok(P), "]")    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptList(P) â‡“ (P, [])

**(Parse-SpawnOptList-Cons)**
Î“ âŠ¢ ParseSpawnOpt(P) â‡“ (P_1, opt)    Î“ âŠ¢ ParseSpawnOptListTail(P_1, [opt]) â‡“ (P_2, opts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptList(P) â‡“ (P_2, opts)

**(Parse-SpawnOptListTail-End)**
IsPunc(Tok(P), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptListTail(P, xs) â‡“ (P, xs)

**(Parse-SpawnOptListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "]")    TrailingCommaAllowed(P_0, P, {Punctuator("]")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-SpawnOptListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseSpawnOpt(Advance(P)) â‡“ (P_1, opt)    Î“ âŠ¢ ParseSpawnOptListTail(P_1, xs ++ [opt]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOptListTail(P, xs) â‡“ (P_2, ys)

**(Parse-SpawnOpt-Name)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `name`    IsPunc(Tok(Advance(P)), ":")    Tok(Advance(Advance(P))).kind = StringLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOpt(P) â‡“ (Advance(Advance(Advance(P))), Name(Tok(Advance(Advance(P)))))

**(Parse-SpawnOpt-Affinity)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `affinity`    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseExpr(Advance(Advance(P))) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOpt(P) â‡“ (P_1, Affinity(e))

**(Parse-SpawnOpt-Priority)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `priority`    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseExpr(Advance(Advance(P))) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseSpawnOpt(P) â‡“ (P_1, Priority(e))

**Dispatch Options.**

**(Parse-DispatchOptsOpt-None)**
Â¬ IsPunc(Tok(P), "[")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptsOpt(P) â‡“ (P, [])

**(Parse-DispatchOptsOpt-Yes)**
IsPunc(Tok(P), "[")    Î“ âŠ¢ ParseDispatchOptList(Advance(P)) â‡“ (P_1, opts)    IsPunc(Tok(P_1), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptsOpt(P) â‡“ (Advance(P_1), opts)

**(Parse-DispatchOptList-Empty)**
IsPunc(Tok(P), "]")    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptList(P) â‡“ (P, [])

**(Parse-DispatchOptList-Cons)**
Î“ âŠ¢ ParseDispatchOpt(P) â‡“ (P_1, opt)    Î“ âŠ¢ ParseDispatchOptListTail(P_1, [opt]) â‡“ (P_2, opts)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptList(P) â‡“ (P_2, opts)

**(Parse-DispatchOptListTail-End)**
IsPunc(Tok(P), "]")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptListTail(P, xs) â‡“ (P, xs)

**(Parse-DispatchOptListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "]")    TrailingCommaAllowed(P_0, P, {Punctuator("]")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-DispatchOptListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseDispatchOpt(Advance(P)) â‡“ (P_1, opt)    Î“ âŠ¢ ParseDispatchOptListTail(P_1, xs ++ [opt]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOptListTail(P, xs) â‡“ (P_2, ys)

**(Parse-ReduceOp-Op)**
IsOp(Tok(P), op)    op âˆˆ {"+", "*"}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReduceOp(P) â‡“ (Advance(P), op)

**(Parse-ReduceOp-Ident)**
IsIdent(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseReduceOp(P) â‡“ (Advance(P), Lexeme(Tok(P)))

**(Parse-DispatchOpt-Reduce)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `reduce`    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseReduceOp(Advance(Advance(P))) â‡“ (P_1, op)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOpt(P) â‡“ (P_1, Reduce(op))

**(Parse-DispatchOpt-Ordered)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `ordered`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOpt(P) â‡“ (Advance(P), Ordered)

**(Parse-DispatchOpt-Chunk)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = `chunk`    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseExpr(Advance(Advance(P))) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseDispatchOpt(P) â‡“ (P_1, Chunk(e))

**Race Arms.**

**(Parse-RaceArms-Cons)**
Î“ âŠ¢ ParseRaceArm(P) â‡“ (P_1, a)    Î“ âŠ¢ ParseRaceArmsTail(P_1, [a]) â‡“ (P_2, arms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArms(P) â‡“ (P_2, arms)

**(Parse-RaceArms-Empty)**
Tok(P) = Punctuator("}")    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArms(P) â‡“ (P, [])

**(Parse-RaceArm)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    IsOp(Tok(P_1), "->")    IsPunc(Tok(Advance(P_1)), "|")    Î“ âŠ¢ ParsePattern(Advance(Advance(P_1))) â‡“ (P_2, pat)    IsPunc(Tok(P_2), "|")    Î“ âŠ¢ ParseRaceHandler(Advance(P_2)) â‡“ (P_3, handler)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArm(P) â‡“ (P_3, âŸ¨e, pat, handlerâŸ©)

**(Parse-RaceArmsTail-End)**
Tok(P) = Punctuator("}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArmsTail(P, xs) â‡“ (P, xs)

**(Parse-RaceArmsTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArmsTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-RaceArmsTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseRaceArm(Advance(P)) â‡“ (P_1, a)    Î“ âŠ¢ ParseRaceArmsTail(P_1, xs ++ [a]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceArmsTail(P, xs) â‡“ (P_2, ys)

**(Parse-RaceHandler-Yield)**
IsKw(Tok(P), `yield`)    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceHandler(P) â‡“ (P_1, RaceYield(e))

**(Parse-RaceHandler-Return)**
Â¬ IsKw(Tok(P), `yield`)    Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRaceHandler(P) â‡“ (P_1, RaceReturn(e))

**All Expression Lists.**

**(Parse-AllExprList-Cons)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    Î“ âŠ¢ ParseAllExprListTail(P_1, [e]) â‡“ (P_2, es)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAllExprList(P) â‡“ (P_2, es)

**(Parse-AllExprList-Empty)**
Tok(P) = Punctuator("}")    c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAllExprList(P) â‡“ (P, [])

**(Parse-AllExprListTail-End)**
Tok(P) = Punctuator("}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAllExprListTail(P, xs) â‡“ (P, xs)

**(Parse-AllExprListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAllExprListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-AllExprListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)    Î“ âŠ¢ ParseAllExprListTail(P_1, xs ++ [e]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseAllExprListTail(P, xs) â‡“ (P_2, ys)

**Expression Lists.**

**(Parse-ExprList-Cons)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    Î“ âŠ¢ ParseExprListTail(P_1, [e]) â‡“ (P_2, es)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprList(P) â‡“ (P_2, es)

**(Parse-ExprList-Empty)**
Tok(P) âˆˆ {Punctuator(")"), Punctuator("]")}    Î“ âŠ¢ Emit(Code(Unsupported-Construct))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprList(P) â‡“ (P, [])

**Tuple Expression Elements.**

**(Parse-TupleExprElems-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleExprElems(P) â‡“ (P, [])

**(Parse-TupleExprElems-Single)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    IsPunc(Tok(P_1), ";")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleExprElems(P) â‡“ (Advance(P_1), [e])

**(Parse-TupleExprElems-TrailingComma)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    TrailingCommaAllowed(P_0, P_1, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleExprElems(P) â‡“ (Advance(P_1), [e])

**(Parse-TupleExprElems-Many)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e_1)    IsPunc(Tok(P_1), ",")    Î“ âŠ¢ ParseExpr(Advance(P_1)) â‡“ (P_2, e_2)    Î“ âŠ¢ ParseExprListTail(P_2, [e_2]) â‡“ (P_3, es)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTupleExprElems(P) â‡“ (P_3, [e_1] ++ es)

**Tuple vs Parenthesized Disambiguation.**
ParenDelta(Punctuator("(")) = 1
ParenDelta(Punctuator(")")) = -1
ParenDelta(t) = 0 if t.kind âˆ‰ {Punctuator("("), Punctuator(")")}

TupleScan(P, d) â‡“ b
Tok(P) = EOF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TupleScan(P, d) â‡“ false
Tok(P) = Punctuator(")") âˆ§ d = 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TupleScan(P, d) â‡“ false
Tok(P) âˆˆ {Punctuator(","), Punctuator(";")} âˆ§ d = 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TupleScan(P, d) â‡“ true
Tok(P) âˆ‰ {Punctuator(")"), Punctuator(","), Punctuator(";")}    TupleScan(Advance(P), d + ParenDelta(Tok(P))) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TupleScan(P, d) â‡“ b

TupleParen(P) â‡” IsPunc(Tok(P), "(") âˆ§ (IsPunc(Tok(Advance(P)), ")") âˆ¨ TupleScan(Advance(P), 1) â‡“ true)
**Field Initializers.**

**(Parse-FieldInitList-Empty)**
IsPunc(Tok(P), "}")    Î“ âŠ¢ Emit(Code(Unsupported-Construct))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInitList(P) â‡“ (P, [])

**(Parse-FieldInitList-Cons)**
Î“ âŠ¢ ParseFieldInit(P) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldInitTail(P_1, [f]) â‡“ (P_2, fs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInitList(P) â‡“ (P_2, fs)


**(Parse-FieldInit-Explicit)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    IsPunc(Tok(P_1), ":")    Î“ âŠ¢ ParseExpr(Advance(P_1)) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInit(P) â‡“ (P_2, âŸ¨name, eâŸ©)

**(Parse-FieldInit-Shorthand)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Â¬ IsPunc(Tok(P_1), ":")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInit(P) â‡“ (P_1, âŸ¨name, Identifier(name)âŸ©)

**Match Arms.**

**(Parse-MatchArms-Cons)**
Î“ âŠ¢ ParseMatchArm(P) â‡“ (P_1, a)    Î“ âŠ¢ ParseMatchArmsTail(P_1, [a]) â‡“ (P_2, arms)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMatchArms(P) â‡“ (P_2, arms)

**(Parse-MatchArm)**
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, pat)    Î“ âŠ¢ ParseGuardOpt(P_1) â‡“ (P_2, guard_opt)    IsOp(Tok(P_2), "=>")    Î“ âŠ¢ ParseArmBody(Advance(P_2)) â‡“ (P_3, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMatchArm(P) â‡“ (P_3, âŸ¨pat, guard_opt, bodyâŸ©)

**(Parse-MatchArmsTail-End)**
Tok(P) = Punctuator("}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMatchArmsTail(P, xs) â‡“ (P, xs)

**(Parse-MatchArmsTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseMatchArm(Advance(P)) â‡“ (P_1, a)    Î“ âŠ¢ ParseMatchArmsTail(P_1, xs ++ [a]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseMatchArmsTail(P, xs) â‡“ (P_2, ys)

**(Parse-GuardOpt-None)**
Â¬ IsKw(Tok(P), `if`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGuardOpt(P) â‡“ (P, âŠ¥)

**(Parse-GuardOpt-Yes)**
IsKw(Tok(P), `if`)    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseGuardOpt(P) â‡“ (P_1, e)

**(Parse-ArmBody-Block)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseBlock(P) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArmBody(P) â‡“ (P_1, b)

**(Parse-ArmBody-Expr)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArmBody(P) â‡“ (P_1, e)

**Argument and Expression Tail Lists.**

**(Parse-ArgTail-End)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgTail(P, xs) â‡“ (P, xs)

**(Parse-ArgTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    TrailingCommaAllowed(P_0, P, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-ArgTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseArg(Advance(P)) â‡“ (P_1, a)    Î“ âŠ¢ ParseArgTail(P_1, xs ++ [a]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseArgTail(P, xs) â‡“ (P_2, ys)

**(Parse-ExprListTail-End)**
Tok(P) âˆˆ {Punctuator(")"), Punctuator("]"), Punctuator("}")}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprListTail(P, xs) â‡“ (P, xs)

**(Parse-ExprListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "]")    TrailingCommaAllowed(P_0, P, {Punctuator("]")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-ExprListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)    Î“ âŠ¢ ParseExprListTail(P_1, xs ++ [e]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprListTail(P, xs) â‡“ (P_2, ys)

**(Parse-FieldInitTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInitTail(P, xs) â‡“ (P, xs)

**(Parse-FieldInitTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInitTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-FieldInitTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseFieldInit(Advance(P)) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldInitTail(P_1, xs ++ [f]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldInitTail(P, xs) â‡“ (P_2, ys)
**Loop Tail.**

**(Parse-LoopTail-Infinite)**
Î“ âŠ¢ ParseLoopInvariantOpt(P) â‡“ (P_0, inv_opt)    IsPunc(Tok(P_0), "{")    Î“ âŠ¢ ParseBlock(P_0) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLoopTail(P) â‡“ (P_1, LoopInfinite(inv_opt, b))

**(Parse-LoopTail-Iter)**
Î“ âŠ¢ TryParsePatternIn(P) â‡“ (P_1, pat)    Î“ âŠ¢ ParseTypeAnnotOpt(P_1) â‡“ (P_2, ty_opt)    IsIdent(Tok(P_2))    Lexeme(Tok(P_2)) = `in`    Î“ âŠ¢ ParseExpr_NoBrace(Advance(P_2)) â‡“ (P_3, iter)    Î“ âŠ¢ ParseLoopInvariantOpt(P_3) â‡“ (P_4, inv_opt)    Î“ âŠ¢ ParseBlock(P_4) â‡“ (P_5, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLoopTail(P) â‡“ (P_5, LoopIter(pat, ty_opt, iter, inv_opt, body))

**(Parse-LoopTail-Cond)**
Î“ âŠ¢ ParseExpr_NoBrace(P) â‡“ (P_1, cond)    Î“ âŠ¢ ParseLoopInvariantOpt(P_1) â‡“ (P_2, inv_opt)    Î“ âŠ¢ ParseBlock(P_2) â‡“ (P_3, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseLoopTail(P) â‡“ (P_3, LoopConditional(cond, inv_opt, body))

**(TryParsePatternIn-Ok)**
P_c = Clone(P)    Î“ âŠ¢ ParsePattern(P_c) â‡“ (P_1, pat)    Î“ âŠ¢ ParseTypeAnnotOpt(P_1) â‡“ (P_2, ty_opt)    IsIdent(Tok(P_2))    Lexeme(Tok(P_2)) = `in`    P' = MergeDiag(P, P_2, P_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TryParsePatternIn(P) â‡“ (P', pat)

**(TryParsePatternIn-Fail)**
P_c = Clone(P)    Â¬ (Î“ âŠ¢ ParsePattern(P_c) â‡“ (P_1, pat) âˆ§ Î“ âŠ¢ ParseTypeAnnotOpt(P_1) â‡“ (P_2, ty_opt) âˆ§ IsIdent(Tok(P_2)) âˆ§ Lexeme(Tok(P_2)) = `in`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TryParsePatternIn(P) â†‘

**Else Clause.**

**(Parse-ElseOpt-None)**
Â¬ IsKw(Tok(P), `else`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseElseOpt(P) â‡“ (P, âŠ¥)

**(Parse-ElseOpt-If)**
IsKw(Tok(P), `else`)    IsKw(Tok(Advance(P)), `if`)    Î“ âŠ¢ ParsePrimary(Advance(P)) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseElseOpt(P) â‡“ (P_1, e)

**(Parse-ElseOpt-Block)**
IsKw(Tok(P), `else`)    Î“ âŠ¢ ParseBlock(Advance(P)) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseElseOpt(P) â‡“ (P_1, b)

**Optional Expression.**

**(Parse-ExprOpt-None)**
Tok(P) âˆˆ {Punctuator(";"), Punctuator("}"), Newline, EOF}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprOpt(P) â‡“ (P, âŠ¥)

**(Parse-ExprOpt-Yes)**
Tok(P) âˆ‰ {Punctuator(";"), Punctuator("}"), Newline, EOF}    Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseExprOpt(P) â‡“ (P_1, e)

**Place Expressions.**

IsPlace(e) â‡” e âˆˆ {Identifier(_), FieldAccess(_, _), TupleAccess(_, _), IndexAccess(_, _)} âˆ¨ (âˆƒ p. e = Deref(p) âˆ§ IsPlace(p))
PlaceExprParseErr = Parse-Syntax-Err

**(Parse-Place-Deref)**
IsOp(Tok(P), "*")    Î“ âŠ¢ ParsePlace(Advance(P)) â‡“ (P_1, p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePlace(P) â‡“ (P_1, Deref(p))

**(Parse-Place-Postfix)**
Î“ âŠ¢ ParsePostfix(P) â‡“ (P_1, e)    IsPlace(e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePlace(P) â‡“ (P_1, e)

**(Parse-Place-Err)**
Î“ âŠ¢ ParsePostfix(P) â‡“ (P_1, e)    Â¬ IsPlace(e)    c = Code(PlaceExprParseErr)    Î“ âŠ¢ Emit(c, Tok(P).span)    Î“ âŠ¢ SyncStmt(P_1) â‡“ P_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePlace(P) â‡“ (P_2, ErrorExpr(SpanBetween(P, P_2)))

#### 3.3.9. Pattern Parsing

**(Parse-Pattern)**
Î“ âŠ¢ ParsePatternRange(P) â‡“ (P_1, pat)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, pat)

**(Parse-Pattern-Err)**
c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePattern(P) â‡“ (P, WildcardPattern)

**(Parse-Pattern-Range-None)**
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (P_1, p)    Â¬ (IsOp(Tok(P_1), "..") âˆ¨ IsOp(Tok(P_1), "..="))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternRange(P) â‡“ (P_1, p)

**(Parse-Pattern-Range)**
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (P_1, p_0)    Tok(P_1) = op âˆˆ {"..", "..="}    Î“ âŠ¢ ParsePatternAtom(Advance(P_1)) â‡“ (P_2, p_1)    kind = (`Exclusive` if op = ".." else `Inclusive`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternRange(P) â‡“ (P_2, RangePattern(kind, p_0, p_1))

**(Parse-Pattern-Literal)**
Tok(P).kind âˆˆ {IntLiteral, FloatLiteral, StringLiteral, CharLiteral, BoolLiteral, NullLiteral}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (Advance(P), LiteralPattern(Tok(P)))

**(Parse-Pattern-Wildcard)**
IsIdent(Tok(P))    Lexeme(Tok(P)) = "_"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (Advance(P), WildcardPattern)

**(Parse-Pattern-Typed)**
IsIdent(Tok(P))    IsPunc(Tok(Advance(P)), ":")    Î“ âŠ¢ ParseType(Advance(Advance(P))) â‡“ (P_1, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (P_1, TypedPattern(Lexeme(Tok(P)), ty))

**(Parse-Pattern-Identifier)**
IsIdent(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (Advance(P), IdentifierPattern(Lexeme(Tok(P))))

**(Parse-Pattern-Tuple)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseTuplePatternElems(Advance(P)) â‡“ (P_1, elems)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (Advance(P_1), TuplePattern(elems))

**(Parse-Pattern-Record)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    IsPunc(Tok(P_1), "{")    Î“ âŠ¢ ParseFieldPatternList(Advance(P_1)) â‡“ (P_2, fields)    IsPunc(Tok(P_2), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (Advance(P_2), RecordPattern(path, fields))

**(Parse-Pattern-Enum)**
Î“ âŠ¢ ParseTypePath(P) â‡“ (P_1, path)    IsOp(Tok(P_1), "::")    Î“ âŠ¢ ParseIdent(Advance(P_1)) â‡“ (P_2, name)    Î“ âŠ¢ ParseEnumPatternPayloadOpt(P_2) â‡“ (P_3, payload_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (P_3, EnumPattern(path, name, payload_opt))

**(Parse-Pattern-Modal)**
IsOp(Tok(P), "@")    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, name)    Î“ âŠ¢ ParseModalPatternPayloadOpt(P_1) â‡“ (P_2, fields_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternAtom(P) â‡“ (P_2, ModalPattern(name, fields_opt))

##### 3.3.9.1. Pattern Helper Parsing Rules

**Pattern Lists.**

**(Parse-PatternList-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternList(P) â‡“ (P, [])

**(Parse-PatternList-Cons)**
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, p)    Î“ âŠ¢ ParsePatternListTail(P_1, [p]) â‡“ (P_2, ps)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternList(P) â‡“ (P_2, ps)

**(Parse-PatternListTail-End)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternListTail(P, xs) â‡“ (P, xs)

**(Parse-PatternListTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), ")")    TrailingCommaAllowed(P_0, P, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternListTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-PatternListTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParsePattern(Advance(P)) â‡“ (P_1, p)    Î“ âŠ¢ ParsePatternListTail(P_1, xs ++ [p]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParsePatternListTail(P, xs) â‡“ (P_2, ys)

**Tuple Pattern Elements.**

**(Parse-TuplePatternElems-Empty)**
IsPunc(Tok(P), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTuplePatternElems(P) â‡“ (P, [])

**(Parse-TuplePatternElems-Single)**
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, p)    IsPunc(Tok(P_1), ";")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTuplePatternElems(P) â‡“ (Advance(P_1), [p])

**(Parse-TuplePatternElems-TrailingComma)**
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, p)    IsPunc(Tok(P_1), ",")    IsPunc(Tok(Advance(P_1)), ")")    TrailingCommaAllowed(P_0, P_1, {Punctuator(")")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTuplePatternElems(P) â‡“ (Advance(P_1), [p])

**(Parse-TuplePatternElems-Many)**
Î“ âŠ¢ ParsePattern(P) â‡“ (P_1, p_1)    IsPunc(Tok(P_1), ",")    Î“ âŠ¢ ParsePattern(Advance(P_1)) â‡“ (P_2, p_2)    Î“ âŠ¢ ParsePatternListTail(P_2, [p_2]) â‡“ (P_3, ps)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseTuplePatternElems(P) â‡“ (P_3, [p_1] ++ ps)

**Field Pattern Lists.**

**(Parse-FieldPatternList-Empty)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternList(P) â‡“ (P, [])

**(Parse-FieldPatternList-Cons)**
Î“ âŠ¢ ParseFieldPattern(P) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldPatternTail(P_1, [f]) â‡“ (P_2, fs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternList(P) â‡“ (P_2, fs)

**(Parse-FieldPattern)**
Î“ âŠ¢ ParseIdent(P) â‡“ (P_1, name)    Î“ âŠ¢ ParseFieldPatternTailOpt(P_1, name) â‡“ (P_2, pat_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPattern(P) â‡“ (P_2, âŸ¨name, pat_opt, SpanBetween(P, P_2)âŸ©)

**(Parse-FieldPatternTailOpt-None)**
Â¬ IsPunc(Tok(P), ":")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternTailOpt(P, name) â‡“ (P, âŠ¥)

**(Parse-FieldPatternTailOpt-Yes)**
IsPunc(Tok(P), ":")    Î“ âŠ¢ ParsePattern(Advance(P)) â‡“ (P_1, pat)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternTailOpt(P, name) â‡“ (P_1, pat)

**(Parse-FieldPatternTail-End)**
IsPunc(Tok(P), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternTail(P, xs) â‡“ (P, xs)

**(Parse-FieldPatternTail-TrailingComma)**
IsPunc(Tok(P), ",")    IsPunc(Tok(Advance(P)), "}")    TrailingCommaAllowed(P_0, P, {Punctuator("}")})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternTail(P, xs) â‡“ (Advance(P), xs)

**(Parse-FieldPatternTail-Comma)**
IsPunc(Tok(P), ",")    Î“ âŠ¢ ParseFieldPattern(Advance(P)) â‡“ (P_1, f)    Î“ âŠ¢ ParseFieldPatternTail(P_1, xs ++ [f]) â‡“ (P_2, ys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseFieldPatternTail(P, xs) â‡“ (P_2, ys)
**Enum Pattern Payload.**

**(Parse-EnumPatternPayloadOpt-None)**
Tok(P) âˆ‰ {Punctuator("("), Punctuator("{")}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnumPatternPayloadOpt(P) â‡“ (P, âŠ¥)

**(Parse-EnumPatternPayloadOpt-Tuple)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseTuplePatternElems(Advance(P)) â‡“ (P_1, ps)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnumPatternPayloadOpt(P) â‡“ (Advance(P_1), TuplePayloadPattern(ps))

**(Parse-EnumPatternPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseFieldPatternList(Advance(P)) â‡“ (P_1, fs)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseEnumPatternPayloadOpt(P) â‡“ (Advance(P_1), RecordPayloadPattern(fs))

**Modal Pattern Payload.**

**(Parse-ModalPatternPayloadOpt-None)**
Â¬ IsPunc(Tok(P), "{")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModalPatternPayloadOpt(P) â‡“ (P, âŠ¥)

**(Parse-ModalPatternPayloadOpt-Record)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseFieldPatternList(Advance(P)) â‡“ (P_1, fs)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModalPatternPayloadOpt(P) â‡“ (Advance(P_1), ModalRecordPayload(fs))

#### 3.3.10. Statement and Block Parsing

**Statement Terminators.**
StmtTerm = {Punctuator(";"), Newline}
Terminates(t) â‡” t âˆˆ StmtTerm

**(Parse-Statement)**
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, s)    Î“ âŠ¢ ConsumeTerminatorOpt(P_1, s) â‡“ P_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmt(P) â‡“ (P_2, s)

**(Parse-Statement-Err)**
c = Code(Parse-Syntax-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)    P_1 = AdvanceOrEOF(P)    Î“ âŠ¢ SyncStmt(P_1) â‡“ P_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmt(P) â‡“ (P_2, ErrorStmt(SpanBetween(P, P_2)))


**(Parse-Binding-Stmt)**
Tok(P) âˆˆ {Keyword(`let`), Keyword(`var`)}    Î“ âŠ¢ ParseBindingAfterLetVar(P) â‡“ (P_1, bind)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, LetOrVarStmt(P, bind))

**(Parse-Shadow-Stmt)**
IsKw(Tok(P), `shadow`)    Tok(Advance(P)) âˆˆ {Keyword(`let`), Keyword(`var`)}    Î“ âŠ¢ ParseShadowBinding(Advance(P)) â‡“ (P_1, s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, s)

**(Parse-Assign-Stmt)**
Î“ âŠ¢ ParsePlace(P) â‡“ (P_1, p)    Tok(P_1) âˆˆ {Operator("="), Operator("+="), Operator("-="), Operator("*="), Operator("/="), Operator("%=")}    Î“ âŠ¢ ParseExpr(Advance(P_1)) â‡“ (P_2, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_2, AssignOrCompound(P_1, p, e))

**(Parse-Return-Stmt)**
IsKw(Tok(P), `return`)    Î“ âŠ¢ ParseExprOpt(Advance(P)) â‡“ (P_1, e_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, ReturnStmt(e_opt))

**(Parse-Break-Stmt)**
IsKw(Tok(P), `break`)    Î“ âŠ¢ ParseExprOpt(Advance(P)) â‡“ (P_1, e_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, BreakStmt(e_opt))

**(Parse-Continue-Stmt)**
IsKw(Tok(P), `continue`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (Advance(P), ContinueStmt)

**(Parse-Unsafe-Block)**
IsKw(Tok(P), `unsafe`)    Î“ âŠ¢ ParseBlock(Advance(P)) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, UnsafeBlockStmt(b))

**(Parse-Defer-Stmt)**
IsKw(Tok(P), `defer`)    Î“ âŠ¢ ParseBlock(Advance(P)) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, DeferStmt(b))

**(Parse-Region-Opts-None)**
Â¬ IsPunc(Tok(P), "(")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRegionOptsOpt(P) â‡“ (P, âŠ¥)

**(Parse-Region-Opts-Some)**
IsPunc(Tok(P), "(")    Î“ âŠ¢ ParseExpr(Advance(P)) â‡“ (P_1, e)    IsPunc(Tok(P_1), ")")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRegionOptsOpt(P) â‡“ (Advance(P_1), e)

**(Parse-Region-Alias-None)**
Â¬ IsKw(Tok(P), `as`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRegionAliasOpt(P) â‡“ (P, âŠ¥)

**(Parse-Region-Alias-Some)**
IsKw(Tok(P), `as`)    Î“ âŠ¢ ParseIdent(Advance(P)) â‡“ (P_1, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseRegionAliasOpt(P) â‡“ (P_1, name)

**(Parse-Region-Stmt)**
IsKw(Tok(P), `region`)    Î“ âŠ¢ ParseRegionOptsOpt(Advance(P)) â‡“ (P_1, opts_opt)    Î“ âŠ¢ ParseRegionAliasOpt(P_1) â‡“ (P_2, alias_opt)    Î“ âŠ¢ ParseBlock(P_2) â‡“ (P_3, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_3, RegionStmt(opts_opt, alias_opt, b))

**(Parse-Frame-Stmt)**
IsKw(Tok(P), `frame`)    Î“ âŠ¢ ParseBlock(Advance(P)) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, FrameStmt(âŠ¥, b))

**(Parse-Frame-Explicit)**
IsIdent(Tok(P))    IsPunc(Tok(Advance(P)), ".")    IsKw(Tok(Advance(Advance(P))), `frame`)    name = Lexeme(Tok(P))    Î“ âŠ¢ ParseBlock(Advance(Advance(Advance(P)))) â‡“ (P_1, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, FrameStmt(name, b))

**(Parse-KeyBlock-Stmt)**
IsOp(Tok(P), "#")    Î“ âŠ¢ ParseKeyPathList(Advance(P)) â‡“ (P_1, paths)    Î“ âŠ¢ ParseKeyBlockModsOpt(P_1) â‡“ (P_2, mods)    Î“ âŠ¢ ParseKeyModeOpt(P_2) â‡“ (P_3, mode_opt)    Î“ âŠ¢ ParseBlock(P_3) â‡“ (P_4, body)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_4, KeyBlockStmt(paths, mods, mode_opt, body))

**(Parse-Expr-Stmt)**
Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtCore(P) â‡“ (P_1, ExprStmt(e))

**Block Parsing.**

**(Parse-Block)**
IsPunc(Tok(P), "{")    Î“ âŠ¢ ParseStmtSeq(Advance(P)) â‡“ (P_1, stmts, tail)    IsPunc(Tok(P_1), "}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseBlock(P) â‡“ (Advance(P_1), BlockExpr(stmts, tail))

##### 3.3.10.1. Statement Helper Parsing Rules
**Terminator Consumption.**

ReqTerm(s) â‡” s âˆˆ {LetStmt(_), VarStmt(_), ShadowLetStmt(_), ShadowVarStmt(_), AssignStmt(_, _), CompoundAssignStmt(_, _, _), ExprStmt(_)}

**(ConsumeTerminatorOpt-Req-Yes)**
ReqTerm(s)    IsTerm(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorOpt(P, s) â‡“ Advance(P)

**(ConsumeTerminatorOpt-Req-No)**
ReqTerm(s)    Â¬ IsTerm(Tok(P))    Emit(Code(Missing-Terminator-Err), Span = Tok(P).span)    Î“ âŠ¢ SyncStmt(P) â‡“ P_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorOpt(P, s) â‡“ P_1

**(ConsumeTerminatorOpt-Opt-Yes)**
Â¬ ReqTerm(s)    IsTerm(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorOpt(P, s) â‡“ Advance(P)

**(ConsumeTerminatorOpt-Opt-No)**
Â¬ ReqTerm(s)    Â¬ IsTerm(Tok(P))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorOpt(P, s) â‡“ P

**(ConsumeTerminatorReq-Yes)**
Tok(P) âˆˆ {Punctuator(";"), Newline}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorReq(P) â‡“ Advance(P)

**(ConsumeTerminatorReq-No)**
Tok(P) âˆ‰ {Punctuator(";"), Newline}    c = Code(Missing-Terminator-Err)    Î“ âŠ¢ Emit(c, Tok(P).span)    Î“ âŠ¢ SyncStmt(P) â‡“ P_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConsumeTerminatorReq(P) â‡“ P_1

**Let/Var Statements.**

**(LetOrVarStmt-Let)**
Tok(P) = Keyword(`let`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LetOrVarStmt(P, bind) â‡“ LetStmt(bind)

**(LetOrVarStmt-Var)**
Tok(P) = Keyword(`var`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LetOrVarStmt(P, bind) â‡“ VarStmt(bind)

**Assignments.**

**(AssignOrCompound-Assign)**
Tok(P_1) = Operator("=")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AssignOrCompound(P_1, p, e) â‡“ AssignStmt(p, e)

**(AssignOrCompound-Compound)**
Tok(P_1) = Operator(op)    op âˆˆ {"+=", "-=", "*=", "/=", "%="}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AssignOrCompound(P_1, p, e) â‡“ CompoundAssignStmt(p, op, e)

**Statement Sequences.**

**(ParseStmtSeq-End)**
Tok(P) = Punctuator("}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtSeq(P) â‡“ (P, [], âŠ¥)

**(ParseStmtSeq-TailExpr)**
Tok(P) âˆ‰ {Punctuator("}")}    Î“ âŠ¢ ParseExpr(P) â‡“ (P_1, e)    Tok(P_1) = Punctuator("}")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtSeq(P) â‡“ (P_1, [], e)

**(ParseStmtSeq-Cons)**
Î“ âŠ¢ ParseStmt(P) â‡“ (P_1, s)    Î“ âŠ¢ ParseStmtSeq(P_1) â‡“ (P_2, ss, tail)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseStmtSeq(P) â‡“ (P_2, [s] ++ ss, tail)

#### 3.3.11. Doc Comment Association (Phase 1)

DocSeq(D) = D
ItemSeq(Items) = Items

**(Attach-Doc-Line)**
d.kind = LineDoc    Items = [i_1, â€¦, i_k]    j = min{ t | d.span.end_offset â‰¤ i_t.span.start_offset }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttachDoc(d, i_j)
LineDocTarget(d, Items) = i_j â‡” Î“ âŠ¢ AttachDoc(d, i_j)
LineDocsFor(i, D, Items) = [d âˆˆ D | d.kind = LineDoc âˆ§ LineDocTarget(d, Items) = i]

**(Attach-Doc-Module)**
d.kind = ModuleDoc
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttachModuleDoc(d)

ModuleDocs(D) = [d âˆˆ D | d.kind = ModuleDoc]

#### 3.3.12. Error Recovery and Synchronization

**Statement Synchronization Set.**

SyncStmt = {Punctuator(";"), Newline, Punctuator("}"), EOF}

**Item Synchronization Set.**

SyncItem = {Keyword(`procedure`), Keyword(`record`), Keyword(`enum`), Keyword(`modal`), Keyword(`class`), Keyword(`type`), Keyword(`using`), Keyword(`let`), Keyword(`var`), Punctuator("}"), EOF}

**Type Synchronization Set.**

SyncType = {Punctuator(","), Punctuator(";"), Newline, Punctuator(")"), Punctuator("]"), Punctuator("}"), EOF}

**(Sync-Stmt-Stop)**
Tok(P) âˆˆ {Punctuator("}"), EOF}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncStmt(P) â‡“ P

**(Sync-Stmt-Consume)**
Tok(P) âˆˆ {Punctuator(";"), Newline}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncStmt(P) â‡“ Advance(P)

**(Sync-Stmt-Advance)**
Tok(P) âˆ‰ SyncStmt
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncStmt(P) â‡“ SyncStmt(Advance(P))

**(Sync-Item-Stop)**
Tok(P) âˆˆ SyncItem
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncItem(P) â‡“ P

**(Sync-Item-Advance)**
Tok(P) âˆ‰ SyncItem
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncItem(P) â‡“ SyncItem(Advance(P))

**(Sync-Type-Stop)**
Tok(P) âˆˆ {Punctuator(")"), Punctuator("]"), Punctuator("}"), EOF}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncType(P) â‡“ P

**(Sync-Type-Consume)**
Tok(P) âˆˆ {Punctuator(","), Punctuator(";"), Newline}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncType(P) â‡“ Advance(P)

**(Sync-Type-Advance)**
Tok(P) âˆ‰ SyncType
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SyncType(P) â‡“ SyncType(Advance(P))

StmtParseErrRule = Parse-Statement-Err
ItemParseErrRule = Parse-Item-Err

#### 3.3.13. Diagnostics (Phase 1)

Phase1DiagRules = {Unsupported-Construct, Missing-Terminator-Err, Trailing-Comma-Err, Parse-Syntax-Err}

**(Parse-Syntax-Err)**
GenericParseRules = {Parse-Ident-Err, Parse-Type-Err, Parse-Pattern-Err, Parse-Primary-Err, Parse-Statement-Err, Parse-Item-Err}

r âˆˆ GenericParseRules    PremisesHold(r, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(Code(Parse-Syntax-Err))

### 3.4. Module Aggregation

#### 3.4.1. Inputs, Outputs, and Invariants

ModuleAggInputs(P) = âŸ¨P.modules, P.source_root, { CompilationUnit(DirOf(p, P.source_root)) | p âˆˆ P.modules }âŸ©
ModuleAggOutputs(P) = âŸ¨{ ParseModule(p, P.source_root) | p âˆˆ P.modules }, { NameMap(P, p) | p âˆˆ P.modules }, G, InitOrder, InitPlanâŸ©
ModuleMap(P, p) = M â‡” Î“ âŠ¢ ParseModules(P) â‡“ Ms âˆ§ M âˆˆ Ms âˆ§ M.path = p
PathOfModule(p) = [c_1, â€¦, c_n] â‡” p = c_1 :: Â·Â·Â· :: c_n
StringOfPath([c_1, â€¦, c_n]) = Join("::", [c_1, â€¦, c_n])
NameCollectAfterParse(P) â‡” Î“ âŠ¢ ParseModules(P) â‡“ Ms âˆ§ âˆ€ M âˆˆ Ms. âˆƒ N. Î“ âŠ¢ CollectNames(M) â‡“ N
NameCollectOrderIndepRef = {"5.1.5"}
ForwardRefOrderRef = {"5.12"}

#### 3.4.2. Module Aggregation (`ParseModule`)

**Module Directory of a Module Path.**

**(DirOf-Root)**
p = A
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DirOf(p, S) = S

**(DirOf-Rel)**
p = c_1 :: Â·Â·Â· :: c_n    n â‰¥ 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DirOf(p, S) = S / c_1 / Â·Â·Â· / c_n

A = P.assembly.name

**ParseModule (Big-Step).**
U = CompilationUnit(DirOf(p, S))
U = [f_1, â€¦, f_n]
ReadBytes : Path â‡€ Bytes

**(ReadBytes-Ok)**
read_ok(f) = B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadBytes(f) â‡“ B

**(ReadBytes-Err)**
read_ok(f) â‡‘    c = Code(ReadBytes-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadBytes(f) â‡‘ c

Bytes(f) = B â‡” Î“ âŠ¢ ReadBytes(f) â‡“ B

**(ParseModule-Ok)**
âˆ€ i, Î“ âŠ¢ ReadBytes(f_i) â‡“ B_i    Î“ âŠ¢ LoadSource(f_i, B_i) â‡“ S_i    Î“ âŠ¢ ParseFile(S_i) â‡“ F_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModule(p, S) â‡“ âŸ¨p, F_1.items ++ Â·Â·Â· ++ F_n.items, F_1.module_doc ++ Â·Â·Â· ++ F_n.module_docâŸ©

**(ParseModule-Err-Read)**
âˆƒ i, Î“ âŠ¢ ReadBytes(f_i) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModule(p, S) â‡‘ c

**(ParseModule-Err-Load)**
âˆƒ i, Î“ âŠ¢ ReadBytes(f_i) â‡“ B_i    Î“ âŠ¢ LoadSource(f_i, B_i) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModule(p, S) â‡‘ c

**LoadSource Short-Circuit.**
If Î“ âŠ¢ LoadSource(f, B) â‡‘ c for any file in a compilation unit, ParseModule MUST NOT invoke Tokenize, ParseFile, or subset checks for that file.

**(ParseModule-Err-Unit)**
Î“ âŠ¢ CompilationUnit(DirOf(p, S)) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModule(p, S) â‡‘ c

**(ParseModule-Err-Parse)**
âˆƒ i, Î“ âŠ¢ ReadBytes(f_i) â‡“ B_i    Î“ âŠ¢ LoadSource(f_i, B_i) â‡“ S_i    Î“ âŠ¢ ParseFile(S_i) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModule(p, S) â‡‘ c

ParseFileBestEffort(S) â‡” âˆƒ F. Î“ âŠ¢ ParseFile(S) â‡“ F
ParseFileOk(S) â‡” ParseFileBestEffort(S) âˆ§ Â¬ HasError(ParseFileDiag(S))
ParseFileDiag(S) = Î” â‡” Î“ âŠ¢ Tokenize(S) â‡“ (K_raw, D) âˆ§ K = Filter(K_raw) âˆ§ P_0 = âŸ¨K, 0, D, 0, 0, []âŸ© âˆ§ Î“ âŠ¢ ParseItems(P_0) â‡“ (P_1, I, MDoc) âˆ§ DiagStream(P_1) = Î”
HasError(Î”) â‡” âˆƒ d âˆˆ Î”. d.severity = Error

**ParseModule (Small-Step).**
ModState = {ModStart(p, S), ModScan(p, S, U, items, docs), ModDone(M), Error(code)}

**(Mod-Start)**
U = CompilationUnit(DirOf(p, S))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModStart(p, S)âŸ© â†’ âŸ¨ModScan(p, S, U, [], [])âŸ©

**(Mod-Start-Err-Unit)**
Î“ âŠ¢ CompilationUnit(DirOf(p, S)) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModStart(p, S)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Mod-Scan)**
U = f :: fs    Î“ âŠ¢ ReadBytes(f) â‡“ B    Î“ âŠ¢ LoadSource(f, B) â‡“ S_f    Î“ âŠ¢ ParseFile(S_f) â‡“ F
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModScan(p, S, f :: fs, items, docs)âŸ© â†’ âŸ¨ModScan(p, S, fs, items ++ F.items, docs ++ F.module_doc)âŸ©

**(Mod-Scan-Err-Read)**
U = f :: fs    Î“ âŠ¢ ReadBytes(f) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModScan(p, S, f :: fs, items, docs)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Mod-Scan-Err-Load)**
U = f :: fs    Î“ âŠ¢ ReadBytes(f) â‡“ B    Î“ âŠ¢ LoadSource(f, B) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModScan(p, S, f :: fs, items, docs)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Mod-Scan-Err-Parse)**
U = f :: fs    Î“ âŠ¢ ReadBytes(f) â‡“ B    Î“ âŠ¢ LoadSource(f, B) â‡“ S_f    Î“ âŠ¢ ParseFile(S_f) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModScan(p, S, f :: fs, items, docs)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Mod-Done)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ModScan(p, S, [], items, docs)âŸ© â†’ âŸ¨ModDone(âŸ¨p, items, docsâŸ©)âŸ©

**ParseModules (Big-Step).**

P.modules = [p_1, â€¦, p_k]

**(ParseModules-Ok)**
âˆ€ i, Î“ âŠ¢ ParseModule(p_i, P.source_root) â‡“ M_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModules(P) â‡“ [M_1, â€¦, M_k]

**(ParseModules-Err)**
âˆƒ i, Î“ âŠ¢ ParseModule(p_i, P.source_root) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ParseModules(P) â‡‘ c

## 4. Phase 2: Compile-Time Execution (Deferred in Cursive0)

ComptimeForm = {`comptime`}
ComptimeForm âŠ† UnsupportedForm

## 5. Phase 3: Name Resolution + Type Checking

### 5.1. Name Resolution and Scopes (Cursive0)

#### 5.1.1. Scope Context and Identifiers

IdKeyRef = {"3.1.6"}
ScopeKey(S) â‡” dom(S) âŠ† {IdKey(x) | x âˆˆ Identifier}

Î£ = âŸ¨Î£.Mods, Î£.Types, Î£.ClassesâŸ©
Î£.Mods âˆˆ [ASTModule]
Î£.Types : Path â‡€ TypeDecl
Î£.Classes : Path â‡€ ClassDecl

Î“ = âŸ¨P, Î£, m, SâŸ©
Project(Î“) = P
ResCtx(Î“) = âŸ¨Î£, mâŸ©
CurrentModule(Î“) = m
Scopes(Î“) = S

EntityKind = {Value, Type, Class, ModuleAlias}
EntitySource = {Decl, Using, RegionAlias}
Entity = âŸ¨kind, origin_opt, target_opt, sourceâŸ©
origin_opt âˆˆ ModulePath âˆª {âŠ¥}    target_opt âˆˆ Identifier âˆª {âŠ¥}

**Unified Namespace.**

S : IdKey â‡€ Entity

Scopes(Î“) = [S_1, â€¦, S_k, S_proc, S_module, S_universe]    (k â‰¥ 0)

LocalScopes(Î“) = [S_1, â€¦, S_k]
ProcScope(Î“) = S_proc
ModuleScope(Î“) = S_module
UniverseScope(Î“) = S_universe

UniverseProtectedRef = {"3.2.3"}

UniverseBindings = { IdKey(x) â†¦ âŸ¨Type, âŠ¥, âŠ¥, DeclâŸ© | x âˆˆ UniverseProtected } âˆª { IdKey(`cursive`) â†¦ âŸ¨ModuleAlias, `cursive`, âŠ¥, DeclâŸ© }
S_universe = UniverseBindings

BytePrefix(p, s) â‡” âˆƒ r. s = p ++ r
Prefix(s, p) â‡” BytePrefix(p, s)

ReservedGen(x) â‡” Prefix(IdKey(x), IdKey(`gen_`))
ReservedCursive(x) â‡” IdEq(x, `cursive`)
ReservedId(x) â‡” ReservedGen(x) âˆ¨ ReservedCursive(x)
ReservedModulePath(path) â‡” (|path| â‰¥ 1 âˆ§ IdEq(path[0], `cursive`)) âˆ¨ (âˆƒ i. ReservedGen(path[i]))

<!-- Source: "The `cursive.*` namespace prefix is reserved for specification-defined features. User programs and vendor extensions MUST NOT use this namespace." -->

PrimTypeNames = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `f16`, `f32`, `f64`, `bool`, `char`, `usize`, `isize`}
SpecialTypeNames = {`Self`, `Drop`, `Bitcopy`, `Clone`, `Eq`, `Hash`, `Hasher`, `Iterator`, `Step`, `FfiSafe`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, `CancelToken`, `Context`, `System`, `ExecutionDomain`, `CpuSet`, `Priority`, `Reactor`}
AsyncTypeNames = {`Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`, `Tracked`}

`Drop`, `Bitcopy`, `Clone`, and `FfiSafe` are reserved predicate names and are included in SpecialTypeNames to prevent shadowing.

PrimTypeKeys = {IdKey(x) | x âˆˆ PrimTypeNames}
SpecialTypeKeys = {IdKey(x) | x âˆˆ SpecialTypeNames}
AsyncTypeKeys = {IdKey(x) | x âˆˆ AsyncTypeNames}

KeywordKey(n) â‡” âˆƒ s. n = IdKey(s) âˆ§ Keyword(s)

#### 5.1.2. Name Introduction and Shadowing

dom(S) = keys(S)
Scopes(Î“) = [S_cur] ++ Î“_out
InScope(S, x) â‡” IdKey(x) âˆˆ dom(S)
InOuter(Î“, x) â‡” âˆƒ S âˆˆ Î“_out. InScope(S, x)

**(Intro-Ok)**
Â¬ InScope(S_cur, x)    Â¬ InOuter(Î“, x)    Â¬ ReservedId(x)    (S_cur â‰  S_module âˆ¨ x âˆ‰ UniverseProtected)    Scopes(Î“') = [S_cur[IdKey(x) â†¦ ent]] ++ Î“_out    Project(Î“') = Project(Î“)    ResCtx(Î“') = ResCtx(Î“)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Intro(x, ent) â‡“ Î“'

**(Intro-Dup)**
InScope(S_cur, x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Intro(x, ent) â‡‘

**(Intro-Shadow-Required)**
Â¬ InScope(S_cur, x)    InOuter(Î“, x)    c = Code(Intro-Shadow-Required)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Intro(x, ent) â‡‘ c

**(Shadow-Ok)**
Â¬ InScope(S_cur, x)    InOuter(Î“, x)    Â¬ ReservedId(x)    (S_cur â‰  S_module âˆ¨ x âˆ‰ UniverseProtected)    Scopes(Î“') = [S_cur[IdKey(x) â†¦ ent]] ++ Î“_out    Project(Î“') = Project(Î“)    ResCtx(Î“') = ResCtx(Î“)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ShadowIntro(x, ent) â‡“ Î“'

**(Shadow-Unnecessary)**
Â¬ InScope(S_cur, x)    Â¬ InOuter(Î“, x)    c = Code(Shadow-Unnecessary)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ShadowIntro(x, ent) â‡‘ c

**(Intro-Reserved-Gen-Err)**
ReservedGen(x)    c = Code(Intro-Reserved-Gen-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Intro(x, ent) â‡‘ c

**(Intro-Reserved-Cursive-Err)**
ReservedCursive(x)    c = Code(Intro-Reserved-Cursive-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Intro(x, ent) â‡‘ c

**(Shadow-Reserved-Gen-Err)**
ReservedGen(x)    c = Code(Shadow-Reserved-Gen-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ShadowIntro(x, ent) â‡‘ c

**(Shadow-Reserved-Cursive-Err)**
ReservedCursive(x)    c = Code(Shadow-Reserved-Cursive-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ShadowIntro(x, ent) â‡‘ c

**Deterministic Rule Priority (Intro / ShadowIntro).**

When multiple Intro/ShadowIntro rules are simultaneously applicable, an implementation MUST apply the first matching clause in the following ordered checks.

**Intro Priority.**
1. If ReservedGen(x) then apply **(Intro-Reserved-Gen-Err)**.
2. Else if ReservedCursive(x) then apply **(Intro-Reserved-Cursive-Err)**.
3. Else if InScope(S_cur, x) then apply **(Intro-Dup)**.
4. Else if InOuter(Î“, x) then apply **(Intro-Shadow-Required)**.
5. Else if the premises of **(Intro-Ok)** hold then apply **(Intro-Ok)**.
6. Otherwise, Î“ âŠ¢ Intro(x, ent) â‡‘ with no diagnostic code.

**ShadowIntro Priority.**
1. If ReservedGen(x) then apply **(Shadow-Reserved-Gen-Err)**.
2. Else if ReservedCursive(x) then apply **(Shadow-Reserved-Cursive-Err)**.
3. Else if InScope(S_cur, x) then Î“ âŠ¢ ShadowIntro(x, ent) â‡‘ with no diagnostic code.
4. Else if Â¬ InOuter(Î“, x) then apply **(Shadow-Unnecessary)**.
5. Else if the premises of **(Shadow-Ok)** hold then apply **(Shadow-Ok)**.
6. Otherwise, Î“ âŠ¢ ShadowIntro(x, ent) â‡‘ with no diagnostic code.

**Binding Introduction Selection.**
If a binding is introduced by a syntactic form without the `shadow` keyword, the implementation MUST invoke Intro for that binding. If a binding is introduced by a `shadow` form (e.g., `ShadowLetStmt`/`ShadowVarStmt`), the implementation MUST invoke ShadowIntro for that binding. The implementation MUST NOT substitute the other judgment.

**Module-Scope Name Validation.**

Names(N) = dom(N)

**(Validate-Module-Ok)**
âˆ€ n âˆˆ Names(N). Â¬ KeywordKey(n) âˆ§ n âˆ‰ PrimTypeKeys âˆ§ n âˆ‰ SpecialTypeKeys âˆ§ n âˆ‰ AsyncTypeKeys
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModuleNames(N) â‡“ ok

**(Validate-Module-Keyword-Err)**
âˆƒ n âˆˆ Names(N). KeywordKey(n)    c = Code(Validate-Module-Keyword-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModuleNames(N) â‡‘ c

**(Validate-Module-Prim-Shadow-Err)**
âˆƒ n âˆˆ Names(N). n âˆˆ PrimTypeKeys    c = Code(Validate-Module-Prim-Shadow-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModuleNames(N) â‡‘ c

**(Validate-Module-Special-Shadow-Err)**
âˆƒ n âˆˆ Names(N). n âˆˆ SpecialTypeKeys    c = Code(Validate-Module-Special-Shadow-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModuleNames(N) â‡‘ c

**(Validate-Module-Async-Shadow-Err)**
âˆƒ n âˆˆ Names(N). n âˆˆ AsyncTypeKeys    c = Code(Validate-Module-Async-Shadow-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModuleNames(N) â‡‘ c

#### 5.1.3. Lookup

**Unqualified Lookup.**

Scopes(Î“) = [S_1, â€¦, S_n]
i = min{j | IdKey(x) âˆˆ dom(S_j)}

**(Lookup-Unqualified)**
i defined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lookup(x) â‡“ S_i[IdKey(x)]

**(Lookup-Unqualified-None)**
i undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lookup(x) â†‘

**Kind Filtering.**
ValueKind(ent) â‡” ent.kind = Value
TypeKind(ent) â‡” ent.kind = Type
ClassKind(ent) â‡” ent.kind = Class
ModuleKind(ent) â‡” ent.kind = ModuleAlias
RegionAlias(ent) â‡” ent.source = RegionAlias

RegionAliasName(Î“, x) â‡” Î“ âŠ¢ ResolveValueName(x) â‡“ ent âˆ§ RegionAlias(ent)

**(Resolve-Value-Name)**
Î“ âŠ¢ Lookup(x) â‡“ ent    ValueKind(ent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveValueName(x) â‡“ ent

**(Resolve-Type-Name)**
Î“ âŠ¢ Lookup(x) â‡“ ent    TypeKind(ent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeName(x) â‡“ ent

**(Resolve-Class-Name)**
Î“ âŠ¢ Lookup(x) â‡“ ent    ClassKind(ent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassName(x) â‡“ ent

**(Resolve-Module-Name)**
Î“ âŠ¢ Lookup(x) â‡“ ent    ModuleKind(ent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModuleName(x) â‡“ ent

**Qualified Lookup.**
P = Project(Î“)
m = CurrentModule(Î“)
AllModulePaths(P) = â‹ƒ_{A âˆˆ P.assemblies} A.modules
AsmOfPath(p) = p[0]    if |p| â‰¥ 1
AsmOfModule(m) = AsmOfPath(m)
ImportDecls(m) = [d | d âˆˆ ASTModule(P, m).items âˆ§ d = ImportDecl(_, _, _, _, _, _)]
ImportPaths(m) = [p | ImportDecl(_, _, p, _, _, _) âˆˆ ImportDecls(m)]
VisibleAssemblies(m) = {AsmOfModule(m)} âˆª {AsmOfPath(p) | p âˆˆ ImportPaths(m)}
PublicAPI(m) â‡” âˆƒ it âˆˆ ASTModule(P, m).items. Vis(it) = `public`
VisibleModulePaths(m) = { p | p âˆˆ AllModulePaths(P) âˆ§ AsmOfPath(p) âˆˆ VisibleAssemblies(m) }
ModulePaths = VisibleModulePaths(m)
ModuleNames = VisibleModuleNames(m)
Alias = AliasMap(m)

**(Resolve-ModulePath)**
Î“ âŠ¢ AliasExpand(path, Alias) â‡“ path'    StringOfPath(path') âˆˆ ModuleNames
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModulePath(path, Alias, ModuleNames) â‡“ path'

**(ResolveModulePath-Err)**
Î“ âŠ¢ AliasExpand(path, Alias) â‡“ path'    StringOfPath(path') âˆ‰ ModuleNames    c = Code(ResolveModulePath-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModulePath(path, Alias, ModuleNames) â‡‘ c

**(Resolve-Qualified)**
Î“ âŠ¢ ResolveModulePath(path, Alias, ModuleNames) â‡“ mp    NameMap(P, mp)[IdKey(name)] = ent    Î“ âŠ¢ CanAccess(m, DeclOf(mp, name)) â‡“ ok    K(ent)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualified(path, name, K) â‡“ ent

K âˆˆ {ValueKind, TypeKind, ClassKind, ModuleKind}

#### 5.1.4. Visibility and Accessibility

DeclOf(mp, name) = it â‡” ModuleOf(it) = mp âˆ§ it â‰  ExternBlock(_, _, _, _, _, _) âˆ§ IdKey(name) âˆˆ dom(ItemBindings(it, mp))
DeclOf(mp, name) = proc â‡” ExternBlockOf(proc) = blk âˆ§ ModuleOf(blk) = mp âˆ§ ProcName(proc) = name
ModuleOf(it) = p â‡” it âˆˆ ASTModule(P, p).items
ModuleOf(proc) = ModuleOf(ExternBlockOf(proc))
ExternBlockOf(proc) = blk â‡” âˆƒ p. blk âˆˆ ASTModule(P, p).items âˆ§ proc âˆˆ blk.items
ProcName(proc) = name â‡” proc = ExternProcDecl(_, _, name, _, _, _, _, _, _, _, _)
ModuleOfPath(path) = mp â‡” SplitLast(path) = (mp, name)
Vis(it) = it.vis
SameAssembly(m_1, m_2) â‡” AsmOfModule(m_1) = AsmOfModule(m_2)

**(Access-Public)**
Vis(it) = `public`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡“ ok

**(Access-Internal)**
Vis(it) = `internal`    SameAssembly(ModuleOf(it), m)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡“ ok

**(Access-Private)**
Vis(it) = `private`    ModuleOf(it) = m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡“ ok

**(Access-Protected)**
Vis(it) = `protected`    ModuleOf(it) = m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡“ ok

**(Access-Internal-Err)**
Vis(it) = `internal`    Â¬ SameAssembly(ModuleOf(it), m)    c = Code(Access-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡‘ c

**(Access-Err)**
Vis(it) âˆˆ {`private`, `protected`}    ModuleOf(it) â‰  m    c = Code(Access-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CanAccess(m, it) â‡‘ c

**Top-Level `protected`.**

TopLevelDecl(it) â‡” it âˆˆ ASTModule(P, ModuleOf(it)).items

**(Protected-TopLevel-Ok)**
Vis(it) â‰  `protected`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TopLevelVis(it) â‡“ ok

**(Protected-TopLevel-Err)**
Vis(it) = `protected`    TopLevelDecl(it)    c = Code(Protected-TopLevel-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TopLevelVis(it) â‡‘ c

#### 5.1.5. Top-Level Name Collection (Order Independence)

**Order Independence.**
âˆ€ items'. Permutation(items', items) âˆ§ Î“ âŠ¢ CollectNames(items, p, âˆ…) â‡“ N â‡’ Î“ âŠ¢ CollectNames(items', p, âˆ…) â‡“ N

**Binding Kinds.**

BindKind = {Value, Type, Class, ModuleAlias}
BindSource = {Decl, Using, Import}
NameInfo = âŸ¨kind, origin, target_opt, sourceâŸ©
P = Project(Î“)
NameMap(P, mp) = N â‡” ModuleMap(P, mp) = M âˆ§ Î“ âŠ¢ CollectNames(M) â‡“ N
AliasMap(m) = { n â†¦ origin | NameMap(P, m)[n].kind = ModuleAlias }
UsingMap(m) = { n â†¦ âŸ¨k, origin, target_optâŸ© | NameMap(P, m)[n].source = Using âˆ§ NameMap(P, m)[n].kind = k âˆ§ k âˆˆ {Value, Type, Class} }
UsingValueMap(m) = { n â†¦ origin | NameMap(P, m)[n].source = Using âˆ§ NameMap(P, m)[n].kind = Value }
UsingTypeMap(m) = { n â†¦ origin | NameMap(P, m)[n].source = Using âˆ§ NameMap(P, m)[n].kind âˆˆ {Type, Class} }
TypeMap(m) = { n â†¦ origin | NameMap(P, m)[n].kind = Type }
ClassMap(m) = { n â†¦ origin | NameMap(P, m)[n].kind = Class }

**Pattern Name Extraction.**

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(IdentifierPattern(x)) â‡“ [x]

**(Pat-Typed)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(TypedPattern(x, _)) â‡“ [x]

**(Pat-Wild)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(WildcardPattern) â‡“ []

**(Pat-Lit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(LiteralPattern(lit)) â‡“ []

âˆ€ i, Î“ âŠ¢ PatNames(p_i) â‡“ N_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(TuplePattern([p_1, â€¦, p_n])) â‡“ N_1 ++ Â·Â·Â· ++ N_n

**(Pat-Record-Field-Explicit)**
Î“ âŠ¢ PatNames(p) â‡“ N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(âŸ¨name, pattern_opt = p, spanâŸ©) â‡“ N

**(Pat-Record-Field-Implicit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(âŸ¨name, pattern_opt = âŠ¥, spanâŸ©) â‡“ [name]

âˆ€ i, Î“ âŠ¢ PatNames(f_i) â‡“ N_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(RecordPattern(_, [f_1, â€¦, f_n])) â‡“ N_1 ++ Â·Â·Â· ++ N_n

**(Pat-Enum-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(EnumPattern(_, _, âŠ¥)) â‡“ []

**(Pat-Enum-Tuple)**
âˆ€ i, Î“ âŠ¢ PatNames(p_i) â‡“ N_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(EnumPattern(_, _, TuplePayloadPattern([p_1, â€¦, p_n]))) â‡“ N_1 ++ Â·Â·Â· ++ N_n

**(Pat-Enum-Record)**
âˆ€ i, Î“ âŠ¢ PatNames(f_i) â‡“ N_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(EnumPattern(_, _, RecordPayloadPattern([f_1, â€¦, f_n]))) â‡“ N_1 ++ Â·Â·Â· ++ N_n

**(Pat-Range)**
Î“ âŠ¢ PatNames(p_l) â‡“ N_l    Î“ âŠ¢ PatNames(p_h) â‡“ N_h
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PatNames(RangePattern(_, p_l, p_h)) â‡“ N_l ++ N_h

**Using Bindings.**
AllModuleNames = { StringOfPath(p) | p âˆˆ AllModulePaths(P) }
VisibleModuleNames(m) = { StringOfPath(p) | p âˆˆ VisibleModulePaths(m) }
Last([c_1, â€¦, c_n]) = c_n if n â‰¥ 1
IsModulePath(path) â‡” StringOfPath(path) âˆˆ AllModuleNames
SplitLast(path) = (mp, name) â‡” path = mp ++ [name] âˆ§ |path| â‰¥ 2
ModuleByPath(P, p) = m â‡” ASTModule(P, p) = m

**Item Names.**
ItemNames(mp) = { n | NameMap(P, mp)[n].kind âˆˆ {Value, Type, Class} }

**Using Spec Names.**
UsingSpecName(mp, âŸ¨name, alias_optâŸ©) =
 alias_opt    if alias_opt â‰  âŠ¥
 Last(mp)     if name = `self` âˆ§ alias_opt = âŠ¥
 name         otherwise
UsingSpecNames(mp, [s_1, â€¦, s_n]) = [UsingSpecName(mp, s_1), â€¦, UsingSpecName(mp, s_n)]

**Declared Names (Non-Using).**

**(DeclNames-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DeclNames([], p) â‡“ âˆ…

**(DeclNames-Using)**
Î“ âŠ¢ DeclNames(rest, p) â‡“ D
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DeclNames(âŸ¨UsingDecl, _, _, _, _âŸ© :: rest, p) â‡“ D

**(DeclNames-Item)**
it â‰  âŸ¨UsingDecl, _, _, _, _âŸ©    Î“ âŠ¢ ItemBindings(it, p) â‡“ B    Î“ âŠ¢ DeclNames(rest, p) â‡“ D
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DeclNames(it :: rest, p) â‡“ Names(B) âˆª D

DeclNames(m) = DeclNames(m.items, m.path)

**Item-Path Resolution.**

**(ItemOfPath)**
|path| â‰¥ 2    SplitLast(path) = (mp, name)    IsModulePath(mp)    m = ModuleByPath(P, mp)    IdKey(name) âˆˆ ItemNames(mp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemOfPath(path) â‡“ (mp, name)

**(ItemOfPath-None)**
Â¬ (|path| â‰¥ 2 âˆ§ SplitLast(path) = (mp, name) âˆ§ IsModulePath(mp) âˆ§ m = ModuleByPath(P, mp) âˆ§ IdKey(name) âˆˆ ItemNames(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemOfPath(path) â†‘

**Import Path Resolution.**

ImportRequired(m, path) â‡” AsmOfPath(path) â‰  AsmOfModule(m)
ImportCovers(m, path) â‡” âˆƒ p âˆˆ ImportPaths(m). PathPrefix(p, path)
ImportOkJudg = {ImportOk}

**(Import-Ok-Local)**
Â¬ ImportRequired(m, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ImportOk(m, path) â‡“ ok

**(Import-Ok-Covered)**
ImportRequired(m, path)    ImportCovers(m, path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ImportOk(m, path) â‡“ ok

**(Import-Ok-Err)**
ImportRequired(m, path)    Â¬ ImportCovers(m, path)    c = Code(Import-Using-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ImportOk(m, path) â‡‘ c

**(Resolve-Import-Ok)**
StringOfPath(path) âˆˆ AllModuleNames
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveImportPath(path) â‡“ path

**(Resolve-Import-Err)**
StringOfPath(path) âˆ‰ AllModuleNames    c = Code(Resolve-Import-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveImportPath(path) â‡‘ c

**Using Path Resolution.**

**(Resolve-Using-Item)**
Î“ âŠ¢ ItemOfPath(path) â‡“ (mp, name)    Â¬ IsModulePath(path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveUsingPath(path) â‡“ âŸ¨Item, mp, nameâŸ©

**(Resolve-Using-Module)**
IsModulePath(path)    Î“ âŠ¢ ItemOfPath(path) â†‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveUsingPath(path) â‡“ âŸ¨Module, pathâŸ©

**(Resolve-Using-Ambig)**
IsModulePath(path)    Î“ âŠ¢ ItemOfPath(path) â‡“ (mp, name)    c = Code(Resolve-Using-Ambig)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveUsingPath(path) â‡‘ c

**(Resolve-Using-None)**
Â¬ IsModulePath(path)    Î“ âŠ¢ ItemOfPath(path) â†‘    c = Code(Resolve-Using-None)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveUsingPath(path) â‡‘ c

**Import Bindings.**

**(Import-Path)**
u = âŸ¨ImportDecl, vis, path, alias_opt, _, _âŸ©    Î“ âŠ¢ ResolveImportPath(path) â‡“ mp    name = alias_opt if present, else Last(path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ImportNames(u) â‡“ [(name, âŸ¨ModuleAlias, mp, âŠ¥, ImportâŸ©)]

**(Import-Path-Err)**
u = âŸ¨ImportDecl, _, path, _, _, _âŸ©    Î“ âŠ¢ ResolveImportPath(path) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ImportNames(u) â‡‘ c

**(Using-Path-Item)**
u = âŸ¨UsingDecl, vis, âŸ¨UsingPath, path, alias_optâŸ©, _, _âŸ©    Î“ âŠ¢ ResolveUsingPath(path) â‡“ âŸ¨Item, mp, itemâŸ©    Î“ âŠ¢ ImportOk(m, mp) â‡“ ok    Î“ âŠ¢ CanAccess(m, DeclOf(mp, item)) â‡“ ok    (vis = `public` â‡’ Vis(DeclOf(mp, item)) = `public`)    NameMap(P, mp)[IdKey(item)] = âŸ¨k, _, _, _âŸ©    k âˆˆ {Value, Type, Class}    name = alias_opt if present, else item
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [(name, âŸ¨k, mp, item, UsingâŸ©)]

**(Using-Path-Item-Public-Err)**
u = âŸ¨UsingDecl, `public`, âŸ¨UsingPath, path, _âŸ©, _, _âŸ©    Î“ âŠ¢ ResolveUsingPath(path) â‡“ âŸ¨Item, mp, itemâŸ©    Vis(DeclOf(mp, item)) â‰  `public`    c = Code(Using-Path-Item-Public-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡‘ c

**(Using-Path-Module)**
u = âŸ¨UsingDecl, _, âŸ¨UsingPath, path, alias_optâŸ©, _, _âŸ©    Î“ âŠ¢ ResolveUsingPath(path) â‡“ âŸ¨Module, pathâŸ©    Î“ âŠ¢ ImportOk(m, path) â‡“ ok    name = alias_opt if present, else Last(path)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [(name, âŸ¨ModuleAlias, path, âŠ¥, UsingâŸ©)]

**(Using-List-NoSelf)**
u = âŸ¨UsingDecl, vis, âŸ¨UsingList, mp, specsâŸ©, _, _âŸ©    âˆ€ s âˆˆ specs. s = âŸ¨name_s, _âŸ© âˆ§ name_s â‰  `self`    Distinct(UsingSpecNames(mp, specs))    Î“ âŠ¢ ImportOk(m, mp) â‡“ ok    âˆ€ i, s_i = âŸ¨name_i, alias_iâŸ©    NameMap(P, mp)[IdKey(name_i)] = âŸ¨k_i, _, _, _âŸ©    k_i âˆˆ {Value, Type, Class}    Î“ âŠ¢ CanAccess(m, DeclOf(mp, name_i)) â‡“ ok    (vis = `public` â‡’ Vis(DeclOf(mp, name_i)) = `public`)    bind_i = âŸ¨UsingSpecName(mp, s_i), âŸ¨k_i, mp, name_i, UsingâŸ©âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [bind_1, â€¦, bind_n]

**(Using-List-Self)**
u = âŸ¨UsingDecl, vis, âŸ¨UsingList, mp, specsâŸ©, _, _âŸ©    s_self âˆˆ specs    s_self = âŸ¨`self`, alias_selfâŸ©    âˆ€ s âˆˆ specs. s.name = `self` â‡’ s = s_self    ItemSpecs = [s_i | s_i âˆˆ specs âˆ§ s_i.name â‰  `self`]    Distinct(UsingSpecNames(mp, specs))    Î“ âŠ¢ ImportOk(m, mp) â‡“ ok    âˆ€ i, s_i âˆˆ ItemSpecs, s_i = âŸ¨name_i, alias_iâŸ©    NameMap(P, mp)[IdKey(name_i)] = âŸ¨k_i, _, _, _âŸ©    k_i âˆˆ {Value, Type, Class}    Î“ âŠ¢ CanAccess(m, DeclOf(mp, name_i)) â‡“ ok    (vis = `public` â‡’ Vis(DeclOf(mp, name_i)) = `public`)    bind_i = âŸ¨UsingSpecName(mp, s_i), âŸ¨k_i, mp, name_i, UsingâŸ©âŸ©    self_name = UsingSpecName(mp, s_self)    bind_self = âŸ¨self_name, âŸ¨ModuleAlias, mp, âŠ¥, UsingâŸ©âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [bind_self, bind_1, â€¦, bind_n]

**(Using-Wildcard-Warn)**
u = âŸ¨UsingDecl, vis, âŸ¨UsingWildcard, mpâŸ©, _, _âŸ©    Î“ âŠ¢ ImportOk(m, mp) â‡“ ok    PublicAPI(m)    Items = { name | name âˆˆ ItemNames(mp) âˆ§ Î“ âŠ¢ CanAccess(m, DeclOf(mp, name)) â‡“ ok }    (vis = `public` â‡’ âˆ€ name âˆˆ Items. Vis(DeclOf(mp, name)) = `public`)    âˆ€ name âˆˆ Items, NameMap(P, mp)[IdKey(name)] = âŸ¨k, _, _, _âŸ©    k âˆˆ {Value, Type, Class}    bind_name = âŸ¨name, âŸ¨k, mp, name, UsingâŸ©âŸ©    Î“ âŠ¢ Emit(W-MOD-1201, âŠ¥)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [bind_name | name âˆˆ Items]

**(Using-Wildcard)**
u = âŸ¨UsingDecl, vis, âŸ¨UsingWildcard, mpâŸ©, _, _âŸ©    Î“ âŠ¢ ImportOk(m, mp) â‡“ ok    Â¬ PublicAPI(m)    Items = { name | name âˆˆ ItemNames(mp) âˆ§ Î“ âŠ¢ CanAccess(m, DeclOf(mp, name)) â‡“ ok }    (vis = `public` â‡’ âˆ€ name âˆˆ Items. Vis(DeclOf(mp, name)) = `public`)    âˆ€ name âˆˆ Items, NameMap(P, mp)[IdKey(name)] = âŸ¨k, _, _, _âŸ©    k âˆˆ {Value, Type, Class}    bind_name = âŸ¨name, âŸ¨k, mp, name, UsingâŸ©âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡“ [bind_name | name âˆˆ Items]

**(Using-List-Dup)**
u = âŸ¨UsingDecl, _, âŸ¨UsingList, mp, specsâŸ©, _, _âŸ©    Â¬ Distinct(UsingSpecNames(mp, specs))    c = Code(Using-List-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡‘ c

**(Using-List-Public-Err)**
u = âŸ¨UsingDecl, `public`, âŸ¨UsingList, mp, specsâŸ©, _, _âŸ©    âˆƒ s_i âˆˆ specs. s_i = âŸ¨name_i, _âŸ© âˆ§ name_i â‰  `self` âˆ§ Vis(DeclOf(mp, name_i)) â‰  `public`    c = Code(Using-List-Public-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UsingNames(u) â‡‘ c

**Item Bindings.**

**(Bind-Procedure)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨ProcedureDecl, _, name, _, _, _, _, _âŸ©, p) â‡“ [(name, âŸ¨Value, p, âŠ¥, DeclâŸ©)]

**(Bind-ExternBlock)**
B = [(name_i, âŸ¨Value, p, âŠ¥, DeclâŸ©) | ExternProcDecl(_, _, name_i, _, _, _, _, _, _, _, _) âˆˆ items]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨ExternBlock, _, _, _, items, _, _âŸ©, p) â‡“ B

**(Bind-Record)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨RecordDecl, _, name, _, _, _, _âŸ©, p) â‡“ [(name, âŸ¨Type, p, âŠ¥, DeclâŸ©)]

**(Bind-Enum)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨EnumDecl, _, name, _, _, _, _âŸ©, p) â‡“ [(name, âŸ¨Type, p, âŠ¥, DeclâŸ©)]

**(Bind-Class)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨ClassDecl, _, name, _, _, _, _âŸ©, p) â‡“ [(name, âŸ¨Class, p, âŠ¥, DeclâŸ©)]

**(Bind-TypeAlias)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨TypeAliasDecl, _, name, _, _, _âŸ©, p) â‡“ [(name, âŸ¨Type, p, âŠ¥, DeclâŸ©)]

**(Bind-Static)**
Î“ âŠ¢ PatNames(pat) â‡“ N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(âŸ¨StaticDecl, _, _, âŸ¨pat, _, _, _, _âŸ©, _, _âŸ©, p) â‡“ [(n, âŸ¨Value, p, âŠ¥, DeclâŸ©) | n âˆˆ N]

**(Bind-Import)**
Î“ âŠ¢ ImportNames(u) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(u, p) â‡“ B

**(Bind-Import-Err)**
Î“ âŠ¢ ImportNames(u) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(u, p) â‡‘ c

**(Bind-Using)**
Î“ âŠ¢ UsingNames(u) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(u, p) â‡“ B

**(Bind-Using-Err)**
Î“ âŠ¢ UsingNames(u) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(u, p) â‡‘ c

**(Bind-ErrorItem)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ItemBindings(ErrorItem(_), p) â‡“ []

**CollectNames (Big-Step).**

**(Collect-Ok)**
Î“ âŠ¢ CollectNames(items, p, âˆ…) â‡“ N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CollectNames(M) â‡“ N

**(Collect-Scan)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    DisjointNames(B, N)    NoDup(B)    Î“ âŠ¢ CollectNames(rest, p, N âˆª B) â‡“ N'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CollectNames(it :: rest, p, N) â‡“ N'

**(Collect-Using-Import-Dup)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    (Â¬ DisjointNames(B, N) âˆ¨ Â¬ NoDup(B))    UsingImportConflict(B, N)    c = Code(Import-Using-Name-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CollectNames(it :: rest, p, N) â‡‘ c

**(Collect-Dup)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    (Â¬ DisjointNames(B, N) âˆ¨ Â¬ NoDup(B))    Â¬ UsingImportConflict(B, N)    c = Code(Collect-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CollectNames(it :: rest, p, N) â‡‘ c

**(Collect-Err)**
Î“ âŠ¢ ItemBindings(it, p) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CollectNames(it :: rest, p, N) â‡‘ c

Names(B) = { n | (n, _) âˆˆ B }
NoDup(B) â‡” Distinct(Names(B))
DisjointNames(B, N) â‡” Names(B) âˆ© dom(N) = âˆ…
N âˆª B = { (n, v) | (n, v) âˆˆ N âˆ¨ (n, v) âˆˆ B }
NameInfoOf(B, n) = info â‡” (n, info) âˆˆ B
NameSource(B, n) = src â‡” NameInfoOf(B, n) = info âˆ§ info.source = src
NameSource(N, n) = src â‡” n âˆˆ dom(N) âˆ§ N[n].source = src
UsingImportConflict(B, N) â‡” âˆƒ n. n âˆˆ Names(B) âˆ© dom(N) âˆ§ (NameSource(B, n) âˆˆ {Using, Import} âˆ¨ NameSource(N, n) âˆˆ {Using, Import})

**CollectNames (Small-Step).**
NamesState = {NamesStart(M), NamesScan(items, p, N), NamesDone(N), Error(code)}

**(Names-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesStart(M)âŸ© â†’ âŸ¨NamesScan(M.items, M.path, âˆ…)âŸ©

**(Names-Step)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    DisjointNames(B, N)    NoDup(B)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesScan(it :: rest, p, N)âŸ© â†’ âŸ¨NamesScan(rest, p, N âˆª B)âŸ©

**(Names-Step-Using-Import-Dup)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    (Â¬ DisjointNames(B, N) âˆ¨ Â¬ NoDup(B))    UsingImportConflict(B, N)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesScan(it :: rest, p, N)âŸ© â†’ âŸ¨Error(Code(Import-Using-Name-Conflict))âŸ©

**(Names-Step-Dup)**
Î“ âŠ¢ ItemBindings(it, p) â‡“ B    (Â¬ DisjointNames(B, N) âˆ¨ Â¬ NoDup(B))    Â¬ UsingImportConflict(B, N)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesScan(it :: rest, p, N)âŸ© â†’ âŸ¨Error(Code(Names-Step-Dup))âŸ©

**(Names-Step-Err)**
Î“ âŠ¢ ItemBindings(it, p) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesScan(it :: rest, p, N)âŸ© â†’ âŸ¨Error(c)âŸ©

**(Names-Done)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨NamesScan([], p, N)âŸ© â†’ âŸ¨NamesDone(N)âŸ©


#### 5.1.6. Qualified Disambiguation (Resolution-Time)

ResolveQualifiedForm : Expr â‡€ Expr

ResolveArgs : [Arg] â‡€ [Arg]
ResolveFieldInits : [FieldInit] â‡€ [FieldInit]
ResolveRecordPath : Path Ã— Identifier â‡€ Path
ResolveEnumUnit : Path Ã— Identifier â‡€ Path
ResolveEnumTuple : Path Ã— Identifier â‡€ Path
ResolveEnumRecord : Path Ã— Identifier â‡€ Path

**(ResolveArgs-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveArgs([]) â‡“ []

**(ResolveArgs-Cons)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'    Î“ âŠ¢ ResolveArgs(rest) â‡“ rest'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveArgs([âŸ¨moved, e, spanâŸ©] ++ rest) â‡“ [âŸ¨moved, e', spanâŸ©] ++ rest'

**(ResolveFieldInits-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldInits([]) â‡“ []

**(ResolveFieldInits-Cons)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'    Î“ âŠ¢ ResolveFieldInits(rest) â‡“ rest'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldInits([âŸ¨f, eâŸ©] ++ rest) â‡“ [âŸ¨f, e'âŸ©] ++ rest'

ResolvePathJudg = {ResolveRecordPath, ResolveEnumUnit, ResolveEnumTuple, ResolveEnumRecord}

**(Resolve-RecordPath)**
Î“ âŠ¢ ResolveTypePath(path ++ [name]) â‡“ p    RecordDecl(p) = R
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p

**(Resolve-EnumUnit)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ p    EnumDecl(p) = E    VariantPayload(E, name) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumUnit(path, name) â‡“ p

**(Resolve-EnumTuple)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ p    EnumDecl(p) = E    VariantPayload(E, name) = TuplePayload(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumTuple(path, name) â‡“ p

**(Resolve-EnumRecord)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ p    EnumDecl(p) = E    VariantPayload(E, name) = RecordPayload(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumRecord(path, name) â‡“ p

BuiltinValuePath(path, name) â‡” BuiltinValueSig(path, name) defined

**(ResolveQual-Name-Builtin)**
BuiltinValuePath(path, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedName(path, name)) â‡“ Path(path, name)

**(ResolveQual-Name-Value)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)    PathOfModule(mp) = path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedName(path, name)) â‡“ Path(path', name')

**(ResolveQual-Name-Record)**
Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p    SplitLast(p) = (mp, name')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedName(path, name)) â‡“ Path(mp, name')

**(ResolveQual-Name-Enum)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â†‘    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumUnit(path, name) â‡“ p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedName(path, name)) â‡“ EnumLiteral(FullPath(p, name), âŠ¥)

**(ResolveQual-Name-Err)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â†‘    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumUnit(path, name) â†‘    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedName(path, name)) â‡‘ c

**(ResolveQual-Apply-Value)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)    PathOfModule(mp) = path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) â‡“ Call(Path(path', name'), args')

**(ResolveQual-Apply-Builtin)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    BuiltinValuePath(path, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) â‡“ Call(Path(path, name), args')

**(ResolveQual-Apply-Record)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p    SplitLast(p) = (mp, name')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) â‡“ Call(Path(mp, name'), args')

**(ResolveQual-Apply-Enum-Tuple)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â†‘    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumTuple(path, name) â‡“ p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) â‡“ EnumLiteral(FullPath(p, name), Paren(ArgsExprs(args')))

**(ResolveQual-Apply-Err)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â†‘    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumTuple(path, name) â†‘    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Paren(args))) â‡‘ c

**Qualified Apply (Brace).**

**(ResolveQual-Apply-RecordLit)**
Î“ âŠ¢ ResolveFieldInits(fields) â‡“ fields'    Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) â‡“ RecordExpr(TypePath(p), fields')

**(ResolveQual-Apply-Enum-Record)**
Î“ âŠ¢ ResolveFieldInits(fields) â‡“ fields'    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumRecord(path, name) â‡“ p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) â‡“ EnumLiteral(FullPath(p, name), Brace(fields'))

**(ResolveQual-Apply-Brace-Err)**
Î“ âŠ¢ ResolveFieldInits(fields) â‡“ fields'    Î“ âŠ¢ ResolveRecordPath(path, name) â†‘    Î“ âŠ¢ ResolveEnumRecord(path, name) â†‘    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveQualifiedForm(QualifiedApply(path, name, Brace(fields))) â‡‘ c

#### 5.1.7. Resolution Pass (Big-Step and Small-Step)

P = Project(Î“)
m = CurrentModule(Î“)
M = ASTModule(P, m)
ResolveInputs = âŸ¨M, ModulePaths, { NameMap(P, p) | p âˆˆ ModulePaths }âŸ©
ResolveOutputs = âŸ¨M'âŸ©
PathOfModuleRef = {"3.4.1"}

**(Validate-ModulePath-Ok)**
Â¬ ReservedModulePath(PathOfModule(p))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModulePath(p) â‡“ ok

**(Validate-ModulePath-Reserved-Err)**
ReservedModulePath(PathOfModule(p))    c = Code(Validate-ModulePath-Reserved-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValidateModulePath(p) â‡‘ c

**(ResolveModule-Ok)**
Î“ âŠ¢ CollectNames(M) â‡“ N    Î“ âŠ¢ ValidateModulePath(M.path) â‡“ ok    Î“ âŠ¢ ValidateModuleNames(N) â‡“ ok    S_module = N    Î“_N = [S_module, S_universe]    Î“_N âŠ¢ ResolveItems(M.items) â‡“ items'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModule(M) â‡“ âŸ¨M.path, items', M.module_docâŸ©

**(ResolveItems-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItems([]) â‡“ []

**(ResolveItems-Cons)**
Î“ âŠ¢ TopLevelVis(it) â‡“ ok    Î“ âŠ¢ ResolveItem(it) â‡“ it'    Î“ âŠ¢ ResolveItems(rest) â‡“ rest'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItems(it :: rest) â‡“ it' :: rest'

**Type Parameter Scopes (Resolution).**

TypeParamBindings(params) = { IdKey(p.name) â†¦ âŸ¨Type, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }
TypeParamBindings(âŠ¥) = {}

**(ResolveGenericParamsOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveGenericParamsOpt(âŠ¥) â‡“ âŠ¥

**(ResolveGenericParamsOpt-Yes)**
Î“ âŠ¢ ResolveTypeParamList(params) â‡“ params'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveGenericParamsOpt(params) â‡“ params'

**(ResolveTypeParam)**
Î“ âŠ¢ ResolveClassPathList(bounds) â‡“ bounds'    Î“ âŠ¢ ResolveTypeOpt(default_opt) â‡“ default_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeParam(âŸ¨name, bounds, default_opt, varianceâŸ©) â‡“ âŸ¨name, bounds', default_opt', varianceâŸ©

**(ResolveTypeParamList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeParamList([]) â‡“ []

**(ResolveTypeParamList-Cons)**
Î“ âŠ¢ ResolveTypeParam(p) â‡“ p'    Î“ âŠ¢ ResolveTypeParamList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeParamList(p :: ps) â‡“ p' :: ps'

**(ResolveWhereClauseOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveWhereClauseOpt(âŠ¥) â‡“ âŠ¥

**(ResolveWhereClauseOpt-Yes)**
Î“ âŠ¢ ResolveWherePredList(preds) â‡“ preds'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveWhereClauseOpt(preds) â‡“ preds'

**(ResolveWherePred-Predicate)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveWherePred(PredWherePred(pred, ty)) â‡“ PredWherePred(pred, ty')

**(ResolveWherePredList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveWherePredList([]) â‡“ []

**(ResolveWherePredList-Cons)**
Î“ âŠ¢ ResolveWherePred(p) â‡“ p'    Î“ âŠ¢ ResolveWherePredList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveWherePredList(p :: ps) â‡“ p' :: ps'

**(ResolveContractClauseOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveContractClauseOpt(âŠ¥) â‡“ âŠ¥

**(ResolveContractClauseOpt-Yes)**
Î“ âŠ¢ ResolveExprOpt(pre) â‡“ pre'    Î“ âŠ¢ ResolveExprOpt(post) â‡“ post'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveContractClauseOpt(ContractClause(pre, post)) â‡“ ContractClause(pre', post')

**(ResolveInvariantOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveInvariantOpt(âŠ¥) â‡“ âŠ¥

**(ResolveInvariantOpt-Yes)**
Î“ âŠ¢ ResolveExpr(inv) â‡“ inv'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveInvariantOpt(inv) â‡“ inv'

**(ResolveForeignContractClauseListOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClauseListOpt(âŠ¥) â‡“ âŠ¥

**(ResolveForeignContractClauseListOpt-Yes)**
Î“ âŠ¢ ResolveForeignContractClauseList(cs) â‡“ cs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClauseListOpt(cs) â‡“ cs'

**(ResolveForeignContractClauseList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClauseList([]) â‡“ []

**(ResolveForeignContractClauseList-Cons)**
Î“ âŠ¢ ResolveForeignContractClause(c) â‡“ c'    Î“ âŠ¢ ResolveForeignContractClauseList(cs) â‡“ cs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClauseList(c :: cs) â‡“ c' :: cs'

**(ResolveForeignContractClause-Assumes)**
Î“ âŠ¢ ResolveExprList(preds) â‡“ preds'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClause(ForeignContractClause(ForeignAssumes, preds)) â‡“ ForeignContractClause(ForeignAssumes, preds')

**(ResolveForeignContractClause-Ensures)**
Î“ âŠ¢ ResolveEnsuresPredicateList(preds) â‡“ preds'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveForeignContractClause(ForeignContractClause(ForeignEnsures, preds)) â‡“ ForeignContractClause(ForeignEnsures, preds')

**(ResolveEnsuresPredicateList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnsuresPredicateList([]) â‡“ []

**(ResolveEnsuresPredicateList-Cons)**
Î“ âŠ¢ ResolveEnsuresPredicate(p) â‡“ p'    Î“ âŠ¢ ResolveEnsuresPredicateList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnsuresPredicateList(p :: ps) â‡“ p' :: ps'

**(ResolveEnsuresPredicate-Plain)**
Î“ âŠ¢ ResolveExpr(pred) â‡“ pred'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnsuresPredicate(Ensures(pred)) â‡“ Ensures(pred')

**(ResolveEnsuresPredicate-Error)**
Î“ âŠ¢ ResolveExpr(pred) â‡“ pred'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnsuresPredicate(EnsuresError(pred)) â‡“ EnsuresError(pred')

**(ResolveEnsuresPredicate-NullResult)**
Î“ âŠ¢ ResolveExpr(pred) â‡“ pred'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnsuresPredicate(EnsuresNullResult(pred)) â‡“ EnsuresNullResult(pred')

**(ResolveExternItemList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExternItemList([]) â‡“ []

**(ResolveExternItemList-Cons)**
Î“ âŠ¢ ResolveExternItem(it) â‡“ it'    Î“ âŠ¢ ResolveExternItemList(rest) â‡“ rest'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExternItemList(it :: rest) â‡“ it' :: rest'

**(ResolveExternItem-Procedure)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“_p = [S_proc, S_gen, S_module, S_universe]    Î“_p âŠ¢ ResolveParams(params) â‡“ params'    Î“_p âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_p âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'    Î“_p âŠ¢ ResolveForeignContractClauseListOpt(foreign_contracts_opt) â‡“ foreign_contracts_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExternItem(ExternProcDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, foreign_contracts_opt, span, doc)) â‡“ ExternProcDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', params', ret_opt', contract_opt', foreign_contracts_opt', span, doc)

**(ResolveItem-ExternBlock)**
Î“ âŠ¢ ResolveExternItemList(items) â‡“ items'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(ExternBlock(attrs_opt, vis, abi_opt, items, span, doc)) â‡“ ExternBlock(attrs_opt, vis, abi_opt, items', span, doc)

**(ResolveItem-Static)**
Î“ âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“ âŠ¢ ResolveExpr(init) â‡“ init'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(StaticDecl(attrs_opt, vis, mut, âŸ¨pat, ty_opt, op, init, spanâŸ©, span', doc)) â‡“ StaticDecl(attrs_opt, vis, mut, âŸ¨pat', ty_opt', op, init', spanâŸ©, span', doc)

**(ResolveItem-Procedure)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“_p = [S_proc, S_gen, S_module, S_universe]    Î“_p âŠ¢ ResolveParams(params) â‡“ params'    Î“_p âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_p âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'    Î“_p âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(ProcedureDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, span, doc)) â‡“ ProcedureDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', params', ret_opt', contract_opt', body', span, doc)

**(ResolveItem-Import)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(ImportDecl(attrs_opt, vis, path, alias_opt, span, doc)) â‡“ ImportDecl(attrs_opt, vis, path, alias_opt, span, doc)

**(ResolveItem-Using)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(UsingDecl(attrs_opt, vis, clause, span, doc)) â‡“ UsingDecl(attrs_opt, vis, clause, span, doc)

**(ResolveItem-TypeAlias)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    Î“_g âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(TypeAliasDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, ty, span, doc)) â‡“ TypeAliasDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', ty', span, doc)

**(ResolveItem-Record)**
R = RecordDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, members, invariant_opt, span, doc)    S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    Î“_g âŠ¢ ResolveClassPathList(impls) â‡“ impls'    Î“_g âŠ¢ ResolveRecordMemberList(R, members) â‡“ members'    Î“_g âŠ¢ ResolveInvariantOpt(invariant_opt) â‡“ invariant_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(R) â‡“ RecordDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', impls', members', invariant_opt', span, doc)

**(ResolveItem-Enum)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    Î“_g âŠ¢ ResolveClassPathList(impls) â‡“ impls'    Î“_g âŠ¢ ResolveVariantList(vars) â‡“ vars'    Î“_g âŠ¢ ResolveInvariantOpt(invariant_opt) â‡“ invariant_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(EnumDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, vars, invariant_opt, span, doc)) â‡“ EnumDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', impls', vars', invariant_opt', span, doc)

**(ResolveItem-Modal)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    Î“_g âŠ¢ ResolveClassPathList(impls) â‡“ impls'    Î“_g âŠ¢ ResolveStateBlockList(states) â‡“ states'    Î“_g âŠ¢ ResolveInvariantOpt(invariant_opt) â‡“ invariant_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(ModalDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, impls, states, invariant_opt, span, doc)) â‡“ ModalDecl(attrs_opt, vis, name, gen_params_opt', where_clause_opt', impls', states', invariant_opt', span, doc)

**(ResolveItem-Class)**
S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    Î“_g âŠ¢ ResolveWhereClauseOpt(where_clause_opt) â‡“ where_clause_opt'    Î“_g âŠ¢ ResolveClassPathList(supers) â‡“ supers'    Î“_g âŠ¢ ResolveClassItemList(items) â‡“ items'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveItem(ClassDecl(attrs_opt, vis, modal_opt, name, gen_params_opt, where_clause_opt, supers, items, span, doc)) â‡“ ClassDecl(attrs_opt, vis, modal_opt, name, gen_params_opt', where_clause_opt', supers', items', span, doc)

**Self Binding for Methods.**

**(BindSelf-Record)**
RecordPath(R) = p    SplitLast(p) = (mp, name)    S_proc' = S_proc[IdKey(`Self`) â†¦ âŸ¨Type, mp, name, DeclâŸ©]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSelfRecord(R, S_proc) â‡“ S_proc'

**(BindSelf-Class)**
S_proc' = S_proc[IdKey(`Self`) â†¦ âŸ¨Type, âŠ¥, âŠ¥, DeclâŸ©]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSelfClass(S_proc) â‡“ S_proc'

**(ResolveReceiver-Shorthand)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveReceiver(ReceiverShorthand(perm)) â‡“ ReceiverShorthand(perm)

**(ResolveReceiver-Explicit)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveReceiver(ReceiverExplicit(mode_opt, ty)) â‡“ ReceiverExplicit(mode_opt, ty')

**(ResolveClassPathList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassPathList([]) â‡“ []

**(ResolveClassPathList-Cons)**
Î“ âŠ¢ ResolveClassPath(p) â‡“ p'    Î“ âŠ¢ ResolveClassPathList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassPathList(p :: ps) â‡“ p' :: ps'

**(ResolveTypeList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeList([]) â‡“ []

**(ResolveTypeList-Cons)**
Î“ âŠ¢ ResolveType(t) â‡“ t'    Î“ âŠ¢ ResolveTypeList(ts) â‡“ ts'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeList(t :: ts) â‡“ t' :: ts'

**(ResolveFieldDecl)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'    Î“ âŠ¢ ResolveExprOpt(init_opt) â‡“ init_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldDecl(FieldDecl(attrs_opt, vis, boundary, name, ty, init_opt, span, doc_opt)) â‡“ FieldDecl(attrs_opt, vis, boundary, name, ty', init_opt', span, doc_opt)

**(ResolveFieldDeclList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldDeclList([]) â‡“ []

**(ResolveFieldDeclList-Cons)**
Î“ âŠ¢ ResolveFieldDecl(f) â‡“ f'    Î“ âŠ¢ ResolveFieldDeclList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldDeclList(f :: fs) â‡“ f' :: fs'

**(ResolveRecordMember-Field)**
Î“ âŠ¢ ResolveFieldDecl(f) â‡“ f'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRecordMember(R, f) â‡“ f'

**(ResolveRecordMember-Method)**
R = RecordDecl(_, _, _, gen_params_opt_r, _, _, _, _, _, _)    S_rec = TypeParamBindings(gen_params_opt_r)    S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_rec, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“ âŠ¢ BindSelfRecord(R, S_proc) â‡“ S_proc'    Î“_m = [S_proc', S_gen, S_rec, S_module, S_universe]    Î“_m âŠ¢ ResolveReceiver(recv) â‡“ recv'    Î“_m âŠ¢ ResolveParams(params) â‡“ params'    Î“_m âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_m âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'    Î“_m âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRecordMember(R, MethodDecl(attrs_opt, vis, override, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)) â‡“ MethodDecl(attrs_opt, vis, override, name, gen_params_opt', recv', params', ret_opt', contract_opt', body', span, doc_opt)

**(ResolveRecordMemberList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRecordMemberList(R, []) â‡“ []

**(ResolveRecordMemberList-Cons)**
Î“ âŠ¢ ResolveRecordMember(R, m) â‡“ m'    Î“ âŠ¢ ResolveRecordMemberList(R, ms) â‡“ ms'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRecordMemberList(R, m :: ms) â‡“ m' :: ms'

**(ResolveClassFieldDecl)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassFieldDecl(ClassFieldDecl(attrs_opt, vis, boundary, name, ty, span, doc_opt)) â‡“ ClassFieldDecl(attrs_opt, vis, boundary, name, ty', span, doc_opt)

**(ResolveClassFieldDeclList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassFieldDeclList([]) â‡“ []

**(ResolveClassFieldDeclList-Cons)**
Î“ âŠ¢ ResolveClassFieldDecl(f) â‡“ f'    Î“ âŠ¢ ResolveClassFieldDeclList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassFieldDeclList(f :: fs) â‡“ f' :: fs'

**(ResolveClassItem-AssociatedType)**
Î“ âŠ¢ ResolveTypeOpt(type_opt) â‡“ type_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItem(AssociatedTypeDecl(attrs_opt, vis, name, type_opt, span, doc_opt)) â‡“ AssociatedTypeDecl(attrs_opt, vis, name, type_opt', span, doc_opt)

**(ResolveClassItem-AbstractState)**
Î“ âŠ¢ ResolveClassFieldDeclList(fields) â‡“ fields'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItem(AbstractStateDecl(attrs_opt, vis, name, fields, span, doc_opt)) â‡“ AbstractStateDecl(attrs_opt, vis, name, fields', span, doc_opt)

**(ResolveClassItem-Field)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItem(ClassFieldDecl(attrs_opt, vis, boundary, name, ty, span, doc_opt)) â‡“ ClassFieldDecl(attrs_opt, vis, boundary, name, ty', span, doc_opt)

**(ResolveClassItem-Method-Abstract)**
Scopes(Î“) = [S_class, S_module, S_universe]    S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_class, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“ âŠ¢ BindSelfClass(S_proc) â‡“ S_proc'    Î“_m = [S_proc', S_gen, S_class, S_module, S_universe]    Î“_m âŠ¢ ResolveReceiver(recv) â‡“ recv'    Î“_m âŠ¢ ResolveParams(params) â‡“ params'    Î“_m âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_m âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItem(ClassMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, âŠ¥, span, doc_opt)) â‡“ ClassMethodDecl(attrs_opt, vis, name, gen_params_opt', recv', params', ret_opt', contract_opt', âŠ¥, span, doc_opt)

**(ResolveClassItem-Method-Concrete)**
Scopes(Î“) = [S_class, S_module, S_universe]    S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_class, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“ âŠ¢ BindSelfClass(S_proc) â‡“ S_proc'    Î“_m = [S_proc', S_gen, S_class, S_module, S_universe]    Î“_m âŠ¢ ResolveReceiver(recv) â‡“ recv'    Î“_m âŠ¢ ResolveParams(params) â‡“ params'    Î“_m âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_m âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'    Î“_m âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItem(ClassMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)) â‡“ ClassMethodDecl(attrs_opt, vis, name, gen_params_opt', recv', params', ret_opt', contract_opt', body', span, doc_opt)

**(ResolveClassItemList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItemList([]) â‡“ []

**(ResolveClassItemList-Cons)**
Î“ âŠ¢ ResolveClassItem(it) â‡“ it'    Î“ âŠ¢ ResolveClassItemList(its) â‡“ its'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassItemList(it :: its) â‡“ it' :: its'

**(ResolveVariantPayloadOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariantPayloadOpt(âŠ¥) â‡“ âŠ¥

**(ResolveVariantPayloadOpt-Tuple)**
Î“ âŠ¢ ResolveTypeList(ts) â‡“ ts'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariantPayloadOpt(TuplePayload(ts)) â‡“ TuplePayload(ts')

**(ResolveVariantPayloadOpt-Record)**
Î“ âŠ¢ ResolveFieldDeclList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariantPayloadOpt(RecordPayload(fs)) â‡“ RecordPayload(fs')

**(ResolveVariant)**
Î“ âŠ¢ ResolveVariantPayloadOpt(payload_opt) â‡“ payload_opt'    Î“ âŠ¢ ResolveExprOpt(disc_opt) â‡“ disc_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariant(VariantDecl(name, payload_opt, disc_opt, span, doc_opt)) â‡“ VariantDecl(name, payload_opt', disc_opt', span, doc_opt)

**(ResolveVariantList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariantList([]) â‡“ []

**(ResolveVariantList-Cons)**
Î“ âŠ¢ ResolveVariant(v) â‡“ v'    Î“ âŠ¢ ResolveVariantList(vs) â‡“ vs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveVariantList(v :: vs) â‡“ v' :: vs'

**(ResolveStateMember-Field)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateMember(StateFieldDecl(attrs_opt, vis, boundary, name, ty, span, doc_opt)) â‡“ StateFieldDecl(attrs_opt, vis, boundary, name, ty', span, doc_opt)

**(ResolveStateMember-Method)**
Scopes(Î“) = [S_modal, S_module, S_universe]    S_gen = TypeParamBindings(gen_params_opt)    Î“_g = [S_gen, S_modal, S_module, S_universe]    Î“_g âŠ¢ ResolveGenericParamsOpt(gen_params_opt) â‡“ gen_params_opt'    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“_m = [S_proc, S_gen, S_modal, S_module, S_universe]    Î“_m âŠ¢ ResolveReceiver(recv) â‡“ recv'    Î“_m âŠ¢ ResolveParams(params) â‡“ params'    Î“_m âŠ¢ ResolveTypeOpt(ret_opt) â‡“ ret_opt'    Î“_m âŠ¢ ResolveContractClauseOpt(contract_opt) â‡“ contract_opt'    Î“_m âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateMember(StateMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)) â‡“ StateMethodDecl(attrs_opt, vis, name, gen_params_opt', recv', params', ret_opt', contract_opt', body', span, doc_opt)

**(ResolveStateMember-Transition)**
Scopes(Î“) = [S_modal, S_module, S_universe]    S_proc = { IdKey(p.name) â†¦ âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ© | p âˆˆ params }    Î“_m = [S_proc, S_modal, S_module, S_universe]    Î“_m âŠ¢ ResolveParams(params) â‡“ params'    Î“_m âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateMember(TransitionDecl(attrs_opt, vis, name, params, target_state, body, span, doc_opt)) â‡“ TransitionDecl(attrs_opt, vis, name, params', target_state, body', span, doc_opt)

**(ResolveStateMemberList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateMemberList([]) â‡“ []

**(ResolveStateMemberList-Cons)**
Î“ âŠ¢ ResolveStateMember(m) â‡“ m'    Î“ âŠ¢ ResolveStateMemberList(ms) â‡“ ms'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateMemberList(m :: ms) â‡“ m' :: ms'

**(ResolveStateBlock)**
Î“ âŠ¢ ResolveStateMemberList(members) â‡“ members'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateBlock(StateBlock(name, members, span, doc_opt)) â‡“ StateBlock(name, members', span, doc_opt)

**(ResolveStateBlockList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateBlockList([]) â‡“ []

**(ResolveStateBlockList-Cons)**
Î“ âŠ¢ ResolveStateBlock(b) â‡“ b'    Î“ âŠ¢ ResolveStateBlockList(bs) â‡“ bs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStateBlockList(b :: bs) â‡“ b' :: bs'

**(ResolveTypeOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeOpt(âŠ¥) â‡“ âŠ¥

**(ResolveTypeOpt-Some)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeOpt(ty) â‡“ ty'

**(ResolveExprOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExprOpt(âŠ¥) â‡“ âŠ¥

**(ResolveExprOpt-Some)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExprOpt(e) â‡“ e'

**(ResolveTypePath-Ident)**
|path| = 1    Î“ âŠ¢ ResolveTypeName(path[0]) â‡“ ent    ent.origin_opt = p    name = (ent.target_opt if present, else path[0])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypePath(path) â‡“ FullPath(PathOfModule(p), name)

**(ResolveTypePath-Ident-Local)**
|path| = 1    Î“ âŠ¢ ResolveTypeName(path[0]) â‡“ ent    ent.origin_opt = âŠ¥    name = (ent.target_opt if present, else path[0])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypePath(path) â‡“ [name]

**(ResolveTypePath-Qual)**
|path| â‰¥ 2    path = p ++ [name]    Î“ âŠ¢ ResolveQualified(p, name, TypeKind) â‡“ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypePath(path) â‡“ FullPath(PathOfModule(mp), name')

LocalTypePath(path) â‡” |path| = 1 âˆ§ Î“ âŠ¢ ResolveTypeName(path[0]) â‡“ ent âˆ§ ent.origin_opt = âŠ¥

**(ResolveClassPath-Ident)**
|path| = 1    Î“ âŠ¢ ResolveClassName(path[0]) â‡“ ent    ent.origin_opt = p    name = (ent.target_opt if present, else path[0])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassPath(path) â‡“ FullPath(PathOfModule(p), name)

**(ResolveClassPath-Qual)**
|path| â‰¥ 2    path = p ++ [name]    Î“ âŠ¢ ResolveQualified(p, name, ClassKind) â‡“ ent    ent.origin_opt = mp    name' = (ent.target_opt if present, else name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveClassPath(path) â‡“ FullPath(PathOfModule(mp), name')

**(ResolveType-Path)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveType(TypePath(path)) â‡“ TypePath(path')

**(ResolveType-Dynamic)**
Î“ âŠ¢ ResolveClassPath(path) â‡“ path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveType(TypeDynamic(path)) â‡“ TypeDynamic(path')

**(ResolveType-Apply)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ path'    Î“ âŠ¢ ResolveTypeList(args) â‡“ args'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveType(TypeApply(path, args)) â‡“ TypeApply(path', args')

**(ResolveType-ModalState)**
Î“ âŠ¢ ResolveModalRef(modal_ref) â‡“ modal_ref'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveType(TypeModalState(modal_ref, state)) â‡“ TypeModalState(modal_ref', state)

ResolveModalRef(modal_ref) â‡“ modal_ref' â‡”
 (modal_ref = TypePath(path) âˆ§ Î“ âŠ¢ ResolveTypePath(path) â‡“ path' âˆ§ modal_ref' = TypePath(path')) âˆ¨
 (modal_ref = TypeApply(path, args) âˆ§ Î“ âŠ¢ ResolveTypePath(path) â‡“ path' âˆ§ Î“ âŠ¢ ResolveTypeList(args) â‡“ args' âˆ§ modal_ref' = TypeApply(path', args'))

**(ResolveTypeRef-Path)**
Î“ âŠ¢ ResolveTypePath(path) â‡“ path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeRef(TypePath(path)) â‡“ TypePath(path')

**(ResolveTypeRef-Apply)**
Î“ âŠ¢ ResolveType(TypeApply(path, args)) â‡“ TypeApply(path', args')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeRef(TypeApply(path, args)) â‡“ TypeApply(path', args')

**(ResolveTypeRef-ModalState)**
Î“ âŠ¢ ResolveModalRef(modal_ref) â‡“ modal_ref'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveTypeRef(ModalStateRef(modal_ref, state)) â‡“ ModalStateRef(modal_ref', state)

**(ResolveType-Hom)**
âˆ€ i, Î“ âŠ¢ ResolveType(t_i) â‡“ t_i'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveType(C(t_1, â€¦, t_n)) â‡“ C(t_1', â€¦, t_n')

**(ResolveParam)**
Î“ âŠ¢ ResolveType(p.type) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParam(p) â‡“ p[type = ty']

**(ResolveParams-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParams([]) â‡“ []

**(ResolveParams-Cons)**
Î“ âŠ¢ ResolveParam(p) â‡“ p'    Î“ âŠ¢ ResolveParams(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParams(p :: ps) â‡“ p' :: ps'

ResolvePattern : Pattern â‡€ Pattern

**(ResolvePat-Wild)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(WildcardPattern) â‡“ WildcardPattern

**(ResolvePat-Ident)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(IdentifierPattern(x)) â‡“ IdentifierPattern(x)

**(ResolvePat-Literal)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(LiteralPattern(lit)) â‡“ LiteralPattern(lit)

**(ResolvePat-Typed)**
Î“ âŠ¢ ResolveType(ty) â‡“ ty'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(TypedPattern(x, ty)) â‡“ TypedPattern(x, ty')

**(ResolvePat-Tuple)**
Î“ âŠ¢ ResolvePatternList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(TuplePattern(ps)) â‡“ TuplePattern(ps')

**(ResolvePat-Record)**
Î“ âŠ¢ ResolveTypePath(tp) â‡“ tp'    Î“ âŠ¢ ResolveFieldPatternList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(RecordPattern(tp, fs)) â‡“ RecordPattern(tp', fs')

**(ResolvePat-Enum-Record-Fallback)**
Î“ âŠ¢ ResolveTypePath(tp) â‡“ tp_e    EnumDecl(tp_e) â†‘    Î“ âŠ¢ ResolveTypePath(tp ++ [name]) â‡“ tp_r    Î“ âŠ¢ ResolveFieldPatternList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(EnumPattern(tp, name, RecordPayloadPattern(fs))) â‡“ RecordPattern(tp_r, fs')

**(ResolvePat-Enum)**
Î“ âŠ¢ ResolveTypePath(tp) â‡“ tp'    Î“ âŠ¢ ResolveEnumPayloadPattern(payload_opt) â‡“ payload_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(EnumPattern(tp, name, payload_opt)) â‡“ EnumPattern(tp', name, payload_opt')

**(ResolvePat-Modal)**
Î“ âŠ¢ ResolveFieldPatternListOpt(fields_opt) â‡“ fields_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(ModalPattern(state, fields_opt)) â‡“ ModalPattern(state, fields_opt')

**(ResolvePat-Range)**
Î“ âŠ¢ ResolvePattern(p_l) â‡“ p_l'    Î“ âŠ¢ ResolvePattern(p_h) â‡“ p_h'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePattern(RangePattern(kind, p_l, p_h)) â‡“ RangePattern(kind, p_l', p_h')

**(ResolvePatternList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePatternList([]) â‡“ []

**(ResolvePatternList-Cons)**
Î“ âŠ¢ ResolvePattern(p) â‡“ p'    Î“ âŠ¢ ResolvePatternList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolvePatternList(p :: ps) â‡“ p' :: ps'

**(ResolveFieldPattern-Implicit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPattern(âŸ¨name, âŠ¥, spanâŸ©) â‡“ âŸ¨name, âŠ¥, spanâŸ©

**(ResolveFieldPattern-Explicit)**
Î“ âŠ¢ ResolvePattern(p) â‡“ p'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPattern(âŸ¨name, p, spanâŸ©) â‡“ âŸ¨name, p', spanâŸ©

**(ResolveFieldPatternList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPatternList([]) â‡“ []

**(ResolveFieldPatternList-Cons)**
Î“ âŠ¢ ResolveFieldPattern(f) â‡“ f'    Î“ âŠ¢ ResolveFieldPatternList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPatternList(f :: fs) â‡“ f' :: fs'

**(ResolveEnumPayloadPattern-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayloadPattern(âŠ¥) â‡“ âŠ¥

**(ResolveEnumPayloadPattern-Tuple)**
Î“ âŠ¢ ResolvePatternList(ps) â‡“ ps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayloadPattern(TuplePayloadPattern(ps)) â‡“ TuplePayloadPattern(ps')

**(ResolveEnumPayloadPattern-Record)**
Î“ âŠ¢ ResolveFieldPatternList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayloadPattern(RecordPayloadPattern(fs)) â‡“ RecordPayloadPattern(fs')

**(ResolveFieldPatternListOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPatternListOpt(âŠ¥) â‡“ âŠ¥

**(ResolveFieldPatternListOpt-Some)**
Î“ âŠ¢ ResolveFieldPatternList(fs) â‡“ fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveFieldPatternListOpt(fs) â‡“ fs'

**(ResolveExpr-Ident)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(Identifier(x)) â‡“ Identifier(x)

**(ResolveExpr-Ident-Err)**
Î“ âŠ¢ ResolveValueName(x) â‡‘    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(Identifier(x)) â‡‘ c

**(ResolveExpr-Qualified)**
Î“ âŠ¢ ResolveQualifiedForm(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(e) â‡“ e'

ResolveArgsRef = {"5.1.6"}
ResolveFieldInitsRef = {"5.1.6"}

ResolveExprListJudg = {ResolveExprList}

**(ResolveExprList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExprList([]) â‡“ []

**(ResolveExprList-Cons)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'    Î“ âŠ¢ ResolveExprList(es) â‡“ es'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExprList(e :: es) â‡“ e' :: es'

ResolveEnumPayloadJudg = {ResolveEnumPayload}

**(ResolveEnumPayload-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayload(âŠ¥) â‡“ âŠ¥

**(ResolveEnumPayload-Tuple)**
Î“ âŠ¢ ResolveExprList(es) â‡“ es'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayload(Paren(es)) â‡“ Paren(es')

**(ResolveEnumPayload-Record)**
Î“ âŠ¢ ResolveFieldInits(fields) â‡“ fields'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveEnumPayload(Brace(fields)) â‡“ Brace(fields')

ResolveKeyPathJudg = {ResolveKeyPathExpr, ResolveKeyPathList, ResolveKeySeg, ResolveKeySegs}

**(ResolveKeySeg-Field)**
seg = Field(marked, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeySeg(seg) â‡“ seg

**(ResolveKeySeg-Index)**
seg = Index(marked, e)    Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeySeg(seg) â‡“ Index(marked, e')

**(ResolveKeySegs-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeySegs([]) â‡“ []

**(ResolveKeySegs-Cons)**
Î“ âŠ¢ ResolveKeySeg(s) â‡“ s'    Î“ âŠ¢ ResolveKeySegs(ss) â‡“ ss'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeySegs(s :: ss) â‡“ s' :: ss'

**(ResolveKeyPathExpr)**
Î“ âŠ¢ ResolveValueName(root) â‡“ ent    Î“ âŠ¢ ResolveKeySegs(segs) â‡“ segs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyPathExpr(âŸ¨root, segsâŸ©) â‡“ âŸ¨root, segs'âŸ©

**(ResolveKeyPathExpr-Err)**
Î“ âŠ¢ ResolveValueName(root) â‡‘    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyPathExpr(âŸ¨root, segsâŸ©) â‡‘ c

**(ResolveKeyPathList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyPathList([]) â‡“ []

**(ResolveKeyPathList-Cons)**
Î“ âŠ¢ ResolveKeyPathExpr(kp) â‡“ kp'    Î“ âŠ¢ ResolveKeyPathList(kps) â‡“ kps'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyPathList(kp :: kps) â‡“ kp' :: kps'

ResolveParallelOptJudg = {ResolveParallelOpt, ResolveParallelOpts}

**(ResolveParallelOpt-Cancel)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParallelOpt(Cancel(e)) â‡“ Cancel(e')

**(ResolveParallelOpt-Name)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParallelOpt(Name(s)) â‡“ Name(s)

**(ResolveParallelOpts-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParallelOpts([]) â‡“ []

**(ResolveParallelOpts-Cons)**
Î“ âŠ¢ ResolveParallelOpt(o) â‡“ o'    Î“ âŠ¢ ResolveParallelOpts(os) â‡“ os'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveParallelOpts(o :: os) â‡“ o' :: os'

ResolveSpawnOptJudg = {ResolveSpawnOpt, ResolveSpawnOpts}

**(ResolveSpawnOpt-Name)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveSpawnOpt(Name(s)) â‡“ Name(s)

**(ResolveSpawnOpt-Affinity)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveSpawnOpt(Affinity(e)) â‡“ Affinity(e')

**(ResolveSpawnOpt-Priority)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveSpawnOpt(Priority(e)) â‡“ Priority(e')

**(ResolveSpawnOpts-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveSpawnOpts([]) â‡“ []

**(ResolveSpawnOpts-Cons)**
Î“ âŠ¢ ResolveSpawnOpt(o) â‡“ o'    Î“ âŠ¢ ResolveSpawnOpts(os) â‡“ os'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveSpawnOpts(o :: os) â‡“ o' :: os'

ResolveDispatchOptJudg = {ResolveDispatchOpt, ResolveDispatchOpts}

**(ResolveDispatchOpt-Reduce)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveDispatchOpt(Reduce(op)) â‡“ Reduce(op)

**(ResolveDispatchOpt-Ordered)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveDispatchOpt(Ordered) â‡“ Ordered

**(ResolveDispatchOpt-Chunk)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveDispatchOpt(Chunk(e)) â‡“ Chunk(e')

**(ResolveDispatchOpts-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveDispatchOpts([]) â‡“ []

**(ResolveDispatchOpts-Cons)**
Î“ âŠ¢ ResolveDispatchOpt(o) â‡“ o'    Î“ âŠ¢ ResolveDispatchOpts(os) â‡“ os'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveDispatchOpts(o :: os) â‡“ o' :: os'

ResolveRaceJudg = {ResolveRaceArm, ResolveRaceArms, ResolveRaceHandler}

**(ResolveRaceHandler-Return)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRaceHandler(RaceReturn(e)) â‡“ RaceReturn(e')

**(ResolveRaceHandler-Yield)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRaceHandler(RaceYield(e)) â‡“ RaceYield(e')

**(ResolveRaceArm)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'    Î“_0 = PushScope(Î“)    Î“_0 âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“_0 âŠ¢ BindPattern(pat') â‡“ Î“_1    Î“_1 âŠ¢ ResolveRaceHandler(handler) â‡“ handler'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRaceArm(âŸ¨e, pat, handlerâŸ©) â‡“ âŸ¨e', pat', handler'âŸ©

**(ResolveRaceArms-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRaceArms([]) â‡“ []

**(ResolveRaceArms-Cons)**
Î“ âŠ¢ ResolveRaceArm(a) â‡“ a'    Î“ âŠ¢ ResolveRaceArms(as) â‡“ as'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveRaceArms(a :: as) â‡“ a' :: as'

ResolveAllExprListJudg = {ResolveAllExprList}

**(ResolveAllExprList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveAllExprList([]) â‡“ []

**(ResolveAllExprList-Cons)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'    Î“ âŠ¢ ResolveAllExprList(es) â‡“ es'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveAllExprList(e :: es) â‡“ e' :: es'

ResolveCalleeJudg = {ResolveCallee}

**(ResolveCallee-Ident-Value)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(Identifier(x), args) â‡“ Identifier(x)

**(ResolveCallee-Ident-Record)**
Î“ âŠ¢ ResolveValueName(x) â‡‘    args = []    Î“ âŠ¢ ResolveTypeName(x) â‡“ ent    ent.origin_opt = p    name = (ent.target_opt if present, else x)    RecordDecl(FullPath(PathOfModule(p), name)) = R
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(Identifier(x), args) â‡“ Identifier(x)

**(ResolveCallee-Path-Value)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(Path(path, name), args) â‡“ Path(path, name)

**(ResolveCallee-Path-Builtin)**
BuiltinValuePath(path, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(Path(path, name), args) â‡“ Path(path, name)

**(ResolveCallee-Path-Record)**
Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p    args = []
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(Path(path, name), args) â‡“ Path(path, name)

**(ResolveCallee-Other)**
Î“ âŠ¢ ResolveExpr(callee) â‡“ callee'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveCallee(callee, args) â‡“ callee'

**(ResolveExpr-Call)**
Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveCallee(callee, args') â‡“ callee'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(Call(callee, args)) â‡“ Call(callee', args')

**(ResolveExpr-Call-TypeArgs)**
Î“ âŠ¢ ResolveTypeList(type_args) â‡“ type_args'    Î“ âŠ¢ ResolveArgs(args) â‡“ args'    Î“ âŠ¢ ResolveCallee(callee, args') â‡“ callee'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(CallTypeArgs(callee, type_args, args)) â‡“ CallTypeArgs(callee', type_args', args')

**(ResolveExpr-RecordExpr)**
Î“ âŠ¢ ResolveTypeRef(tr) â‡“ tr'    Î“ âŠ¢ ResolveFieldInits(fields) â‡“ fields'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(RecordExpr(tr, fields)) â‡“ RecordExpr(tr', fields')

**(ResolveExpr-EnumLiteral)**
Î“ âŠ¢ ResolveEnumPayload(payload_opt) â‡“ payload_opt'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(EnumLiteral(path, payload_opt)) â‡“ EnumLiteral(path, payload_opt')

ResolveArmJudg = {ResolveArm, ResolveArms}

**(ResolveArm)**
Î“_0 = PushScope(Î“)    Î“_0 âŠ¢ ResolvePattern(p) â‡“ p'    Î“_0 âŠ¢ BindPattern(p') â‡“ Î“_1    Î“_1 âŠ¢ ResolveExprOpt(g) â‡“ g'    Î“_1 âŠ¢ ResolveExpr(b) â‡“ b'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveArm(âŸ¨p, g, bâŸ©) â‡“ âŸ¨p', g', b'âŸ©

**(ResolveArms-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveArms([]) â‡“ []

**(ResolveArms-Cons)**
Î“ âŠ¢ ResolveArm(a) â‡“ a'    Î“ âŠ¢ ResolveArms(as) â‡“ as'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveArms(a :: as) â‡“ a' :: as'

**(ResolveExpr-Match)**
Î“ âŠ¢ ResolveExpr(scrutinee) â‡“ scrutinee'    Î“ âŠ¢ ResolveArms(arms) â‡“ arms'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(MatchExpr(scrutinee, arms)) â‡“ MatchExpr(scrutinee', arms')

**(ResolveExpr-LoopIter)**
Î“ âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'    Î“ âŠ¢ ResolveExpr(iter) â‡“ iter'    Î“_0 = PushScope(Î“)    Î“_0 âŠ¢ BindPattern(pat') â‡“ Î“_1    Î“_1 âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(LoopIter(pat, ty_opt, iter, body)) â‡“ LoopIter(pat', ty_opt', iter', body')

**(ResolveExpr-Parallel)**
Î“ âŠ¢ ResolveExpr(domain) â‡“ domain'    Î“ âŠ¢ ResolveParallelOpts(opts) â‡“ opts'    Î“ âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(ParallelExpr(domain, opts, body)) â‡“ ParallelExpr(domain', opts', body')

**(ResolveExpr-Spawn)**
Î“ âŠ¢ ResolveSpawnOpts(opts) â‡“ opts'    Î“ âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(SpawnExpr(opts, body)) â‡“ SpawnExpr(opts', body')

**(ResolveExpr-Wait)**
Î“ âŠ¢ ResolveExpr(handle) â‡“ handle'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(WaitExpr(handle)) â‡“ WaitExpr(handle')

ResolveKeyClauseJudg = {ResolveKeyClauseOpt}

**(ResolveKeyClauseOpt-None)**
key_clause_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyClauseOpt(key_clause_opt) â‡“ âŠ¥

**(ResolveKeyClauseOpt-Yes)**
key_clause_opt = âŸ¨path, modeâŸ©    Î“ âŠ¢ ResolveKeyPathExpr(path) â‡“ path'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveKeyClauseOpt(key_clause_opt) â‡“ âŸ¨path', modeâŸ©

**(ResolveExpr-Dispatch)**
Î“ âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“ âŠ¢ ResolveExpr(range) â‡“ range'    Î“ âŠ¢ ResolveKeyClauseOpt(key_clause_opt) â‡“ key_clause_opt'    Î“ âŠ¢ ResolveDispatchOpts(opts) â‡“ opts'    Î“_0 = PushScope(Î“)    Î“_0 âŠ¢ BindPattern(pat') â‡“ Î“_1    Î“_1 âŠ¢ ResolveExpr(body) â‡“ body'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(DispatchExpr(pat, range, key_clause_opt, opts, body)) â‡“ DispatchExpr(pat', range', key_clause_opt', opts', body')

**(ResolveExpr-Yield)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(YieldExpr(release_opt, e)) â‡“ YieldExpr(release_opt, e')

**(ResolveExpr-YieldFrom)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(YieldFromExpr(release_opt, e)) â‡“ YieldFromExpr(release_opt, e')

**(ResolveExpr-Sync)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(SyncExpr(e)) â‡“ SyncExpr(e')

**(ResolveExpr-Race)**
Î“ âŠ¢ ResolveRaceArms(arms) â‡“ arms'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(RaceExpr(arms)) â‡“ RaceExpr(arms')

**(ResolveExpr-All)**
Î“ âŠ¢ ResolveAllExprList(es) â‡“ es'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(AllExpr(es)) â‡“ AllExpr(es')

**(ResolveExpr-Alloc-Explicit-ByAlias)**
Î“ âŠ¢ ResolveValueName(r) â‡“ ent    RegionAlias(ent)    Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(Binary("^", Identifier(r), e)) â‡“ AllocExpr(r, e')

ResolveExprRules = {ResolveExpr-Ident, ResolveExpr-Qualified, ResolveExpr-Call, ResolveExpr-Call-TypeArgs, ResolveExpr-RecordExpr, ResolveExpr-EnumLiteral, ResolveExpr-Match, ResolveExpr-LoopIter, ResolveExpr-Parallel, ResolveExpr-Spawn, ResolveExpr-Wait, ResolveExpr-Dispatch, ResolveExpr-Yield, ResolveExpr-YieldFrom, ResolveExpr-Sync, ResolveExpr-Race, ResolveExpr-All, ResolveExpr-Alloc-Explicit-ByAlias, ResolveExpr-Hom, ResolveExpr-Alloc-Implicit, ResolveExpr-Alloc-Explicit, ResolveExpr-Block}

NoSpecificResolveExpr(e) â‡” Â¬ âˆƒ r âˆˆ ResolveExprRules \ {ResolveExpr-Hom}. PremisesHold(r, e)

**(ResolveExpr-Hom)**
NoSpecificResolveExpr(C(e_1, â€¦, e_n))    âˆ€ i, Î“ âŠ¢ ResolveExpr(e_i) â‡“ e_i'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(C(e_1, â€¦, e_n)) â‡“ C(e_1', â€¦, e_n')

**(ResolveExpr-Alloc-Implicit)**
Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(AllocExpr(âŠ¥, e)) â‡“ AllocExpr(âŠ¥, e')

**(ResolveExpr-Alloc-Explicit)**
Î“ âŠ¢ ResolveValueName(r) â‡“ ent    Î“ âŠ¢ ResolveExpr(e) â‡“ e'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(AllocExpr(r, e)) â‡“ AllocExpr(r, e')

ResolveStmtSeqJudg = {ResolveStmtSeq}

**(ResolveStmtSeq-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmtSeq([]) â‡“ (Î“, [])

**(ResolveStmtSeq-Cons)**
Î“ âŠ¢ ResolveStmt(s) â‡“ (Î“_1, s')    Î“_1 âŠ¢ ResolveStmtSeq(ss) â‡“ (Î“_2, ss')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmtSeq(s :: ss) â‡“ (Î“_2, s' :: ss')

**(ResolveExpr-Block)**
Î“_0 = PushScope(Î“)    Î“_0 âŠ¢ ResolveStmtSeq(stmts) â‡“ (Î“_1, stmts')    (tail_opt = âŠ¥ â‡’ tail_opt' = âŠ¥)    (tail_opt = e â‡’ Î“_1 âŠ¢ ResolveExpr(e) â‡“ e' âˆ§ tail_opt' = e')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveExpr(BlockExpr(stmts, tail_opt)) â‡“ BlockExpr(stmts', tail_opt')

**(BindNames-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindNames([]) â‡“ Î“

**(BindNames-Cons)**
Î“ âŠ¢ Intro(x, âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ©) â‡“ Î“_1    Î“_1 âŠ¢ BindNames(xs) â‡“ Î“_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindNames(x :: xs) â‡“ Î“_2

**(BindPattern)**
Î“ âŠ¢ PatNames(p) â‡“ ns    Î“ âŠ¢ BindNames(ns) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindPattern(p) â‡“ Î“'

**(ResolveStmt-Let)**
Î“ âŠ¢ ResolveExpr(init) â‡“ init'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'    Î“ âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“ âŠ¢ BindPattern(pat') â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(LetStmt(âŸ¨pat, ty_opt, op, init, spanâŸ©)) â‡“ (Î“', LetStmt(âŸ¨pat', ty_opt', op, init', spanâŸ©))

**(ResolveStmt-Var)**
Î“ âŠ¢ ResolveExpr(init) â‡“ init'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'    Î“ âŠ¢ ResolvePattern(pat) â‡“ pat'    Î“ âŠ¢ BindPattern(pat') â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(VarStmt(âŸ¨pat, ty_opt, op, init, spanâŸ©)) â‡“ (Î“', VarStmt(âŸ¨pat', ty_opt', op, init', spanâŸ©))

**(ResolveStmt-ShadowLet)**
Î“ âŠ¢ ResolveExpr(init) â‡“ init'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'    Î“ âŠ¢ ShadowIntro(x, âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ©) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(ShadowLetStmt(x, ty_opt, init)) â‡“ (Î“', ShadowLetStmt(x, ty_opt', init'))

**(ResolveStmt-ShadowVar)**
Î“ âŠ¢ ResolveExpr(init) â‡“ init'    Î“ âŠ¢ ResolveTypeOpt(ty_opt) â‡“ ty_opt'    Î“ âŠ¢ ShadowIntro(x, âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ©) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(ShadowVarStmt(x, ty_opt, init)) â‡“ (Î“', ShadowVarStmt(x, ty_opt', init'))

**(ResolveStmt-Defer)**
Î“ âŠ¢ ResolveExpr(b) â‡“ b'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(DeferStmt(b)) â‡“ (Î“, DeferStmt(b'))

**(ResolveStmt-Frame-Implicit)**
Î“ âŠ¢ ResolveExpr(b) â‡“ b'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(FrameStmt(âŠ¥, b)) â‡“ (Î“, FrameStmt(âŠ¥, b'))

**(ResolveStmt-Frame-Explicit)**
Î“ âŠ¢ ResolveValueName(r) â‡“ ent    Î“ âŠ¢ ResolveExpr(b) â‡“ b'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(FrameStmt(r, b)) â‡“ (Î“, FrameStmt(r, b'))

**(ResolveStmt-Region)**
Î“ âŠ¢ ResolveExprOpt(opts_opt) â‡“ opts_opt'    (alias_opt = âŠ¥ â‡’ Î“_r = Î“)    (alias_opt = r â‡’ Î“ âŠ¢ Intro(r, âŸ¨Value, âŠ¥, âŠ¥, RegionAliasâŸ©) â‡“ Î“_r)    Î“_r âŠ¢ ResolveExpr(b) â‡“ b'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveStmt(RegionStmt(opts_opt, alias_opt, b)) â‡“ (Î“, RegionStmt(opts_opt', alias_opt, b'))

ResolveExprOpt(âŠ¥) = âŠ¥
ResolveExprOpt(e) = e' â‡” Î“ âŠ¢ ResolveExpr(e) â‡“ e'

ResState = {ResStart(M), ResNames(M, N), ResItems(M, N), ResDone(M'), Error(code)}

**(Res-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ResStart(M)âŸ© â†’ âŸ¨ResNames(M, _)âŸ©

**(Res-Names)**
Î“ âŠ¢ CollectNames(M) â‡“ N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ResNames(M, _)âŸ© â†’ âŸ¨ResItems(M, N)âŸ©

**(Res-Items)**
Î“ âŠ¢ ResolveModule(M) â‡“ M'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ResItems(M, N)âŸ© â†’ âŸ¨ResDone(M')âŸ©

**ResolveModules (Big-Step).**

**(ResolveModules-Ok)**
Î“ âŠ¢ ParseModules(P) â‡“ [M_1, â€¦, M_k]    âˆ€ i, Î“ âŠ¢ ResolveModule(M_i) â‡“ M_i'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModules(P) â‡“ [M_1', â€¦, M_k']

**(ResolveModules-Err-Parse)**
Î“ âŠ¢ ParseModules(P) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModules(P) â‡‘ c

**(ResolveModules-Err-Resolve)**
Î“ âŠ¢ ParseModules(P) â‡“ [M_1, â€¦, M_k]    âˆƒ i. Î“ âŠ¢ ResolveModule(M_i) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ResolveModules(P) â‡‘ c

### 5.2. Type System Core (Cursive0)

#### 5.2.1. Type Equivalence

TypeEqJudg = {â‰¡}
ConstLenJudg = {ConstLen}

**(ConstLen-Lit)**
e = Literal(lit)    lit.kind = IntLiteral    InRange(IntValue(lit), "usize")    n = IntValue(lit)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConstLen(e) â‡“ n

**(ConstLen-Path)**
e = Path(path, name)    ValuePathType(path, name) = T    StaticDecl(_, _, _, âŸ¨IdentPattern(name), _, "=", init, _âŸ©, _, _) âˆˆ Î“    Î“ âŠ¢ ConstLen(init) â‡“ n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConstLen(e) â‡“ n

**(ConstLen-Err)**
Â¬ âˆƒ n. Î“ âŠ¢ ConstLen(e) â‡“ n    c = Code(ConstLen-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ConstLen(e) â‡‘ c

MembersEq([T_1, â€¦, T_n], [U_1, â€¦, U_n]) â‡” âˆƒ U'. Permutation(U', [U_1, â€¦, U_n]) âˆ§ âˆ€ i. 0 â‰¤ i < n â‡’ Î“ âŠ¢ T_i â‰¡ U'[i]

**(T-Equiv-Prim)**
T = TypePrim(n)    U = TypePrim(n)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Perm)**
T = TypePerm(p, T_0)    U = TypePerm(p, U_0)    Î“ âŠ¢ T_0 â‰¡ U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Tuple)**
T = TypeTuple([T_1, â€¦, T_n])    U = TypeTuple([U_1, â€¦, U_n])    âˆ€ i, Î“ âŠ¢ T_i â‰¡ U_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Array)**
T = TypeArray(T_0, e_0)    U = TypeArray(U_0, e_1)    Î“ âŠ¢ ConstLen(e_0) â‡“ n    Î“ âŠ¢ ConstLen(e_1) â‡“ n    Î“ âŠ¢ T_0 â‰¡ U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Slice)**
T = TypeSlice(T_0)    U = TypeSlice(U_0)    Î“ âŠ¢ T_0 â‰¡ U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Func)**
T = TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)    U = TypeFunc([âŸ¨m_1, U_1âŸ©, â€¦, âŸ¨m_n, U_nâŸ©], S)    âˆ€ i, Î“ âŠ¢ T_i â‰¡ U_i    Î“ âŠ¢ R â‰¡ S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Union)**
T = TypeUnion([T_1, â€¦, T_n])    U = TypeUnion([U_1, â€¦, U_n])    MembersEq([T_1, â€¦, T_n], [U_1, â€¦, U_n])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Path)**
T = TypePath(p)    U = TypePath(p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-ModalState)**
T = TypeModalState(modal_ref, S)    U = TypeModalState(modal_ref, S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-String)**
T = TypeString(st)    U = TypeString(st)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Bytes)**
T = TypeBytes(st)    U = TypeBytes(st)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Range)**
T = TypeRange    U = TypeRange
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Ptr)**
T = TypePtr(T_0, s)    U = TypePtr(U_0, s)    Î“ âŠ¢ T_0 â‰¡ U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-RawPtr)**
T = TypeRawPtr(q, T_0)    U = TypeRawPtr(q, U_0)    Î“ âŠ¢ T_0 â‰¡ U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

**(T-Equiv-Dynamic)**
T = TypeDynamic(p)    U = TypeDynamic(p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T â‰¡ U

#### 5.2.2. Subtyping

SubtypingJudg = {<:}

âˆ€ T, U âˆˆ IntTypes. T â‰  U â‡’ Â¬(Î“ âŠ¢ T <: U)

âˆ€ T, U âˆˆ FloatTypes. T â‰  U â‡’ Â¬(Î“ âŠ¢ T <: U)

PermSubJudg = {PermSub}

**(Perm-Const)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`const` PermSub `const`

**(Perm-Shared)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`shared` PermSub `shared`

**(Perm-Unique)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`unique` PermSub `unique`

**(Perm-Unique-Shared)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`unique` PermSub `shared`

**(Perm-Shared-Const)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`shared` PermSub `const`

**(Perm-Unique-Const)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
`unique` PermSub `const`

**(Sub-Perm)**
T = TypePerm(p, T_0)    U = TypePerm(q, U_0)    PermSub(p, q)    Î“ âŠ¢ T_0 <: U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Never)**
T âˆˆ ð’¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypePrim("!") <: T

**(Sub-Tuple)**
T = TypeTuple([T_1, â€¦, T_n])    U = TypeTuple([U_1, â€¦, U_n])    âˆ€ i, Î“ âŠ¢ T_i <: U_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Array)**
T = TypeArray(T_0, e_0)    U = TypeArray(U_0, e_1)    Î“ âŠ¢ ConstLen(e_0) â‡“ n    Î“ âŠ¢ ConstLen(e_1) â‡“ n    Î“ âŠ¢ T_0 <: U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Slice)**
T = TypeSlice(T_0)    U = TypeSlice(U_0)    Î“ âŠ¢ T_0 <: U_0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Range)**
T = TypeRange    U = TypeRange
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Ptr-State)**
s âˆˆ {`Valid`, `Null`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypePtr(T, s) <: TypePtr(T, âŠ¥)

**(Sub-Modal-Niche)**
ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    NicheCompatible(modal_ref, S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeModalState(modal_ref, S) <: ModalRefType(modal_ref)

**(Sub-Func)**
T = TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)    U = TypeFunc([âŸ¨m_1, U_1âŸ©, â€¦, âŸ¨m_n, U_nâŸ©], S)    âˆ€ i, Î“ âŠ¢ U_i <: T_i    Î“ âŠ¢ R <: S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Async)**
AsyncSig(T) = âŸ¨Out_1, In_1, Result_1, E_1âŸ©    AsyncSig(U) = âŸ¨Out_2, In_2, Result_2, E_2âŸ©
Î“ âŠ¢ Out_1 <: Out_2    Î“ âŠ¢ In_2 <: In_1    Î“ âŠ¢ Result_1 <: Result_2    Î“ âŠ¢ E_1 <: E_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

Member(T, U) â‡” U = TypeUnion([U_1, â€¦, U_n]) âˆ§ âˆƒ i. Î“ âŠ¢ T â‰¡ U_i

**(Sub-Member-Union)**
Member(T, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: U

**(Sub-Union-Width)**
U_1 = TypeUnion([T_1, â€¦, T_n])    U_2 = TypeUnion([U_1', â€¦, U_m'])    âˆ€ i, Member(T_i, U_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ U_1 <: U_2

SubtypingRules = RulesIn({"5.2.2", "5.3.1", "5.7", "5.8"})

#### 5.2.3. Function Types

**(T-Proc-As-Value)**
procedure f(m_1 x_1 : T_1, â€¦, m_n x_n : T_n) -> R declared
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f : TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)

FuncTypeRules = RulesIn({"5.2.1", "5.2.2"})

#### 5.2.4. Procedure Calls

ArgsOkTJudg = {ArgsOk_T}
ParamMode(âŸ¨mode, TâŸ©) = mode
ParamType(âŸ¨mode, TâŸ©) = T
ArgMoved(âŸ¨moved, e, spanâŸ©) = moved
ArgExpr(âŸ¨moved, e, spanâŸ©) = e
PlaceType(p) = T â‡” Î“; R; L âŠ¢ p :place T
ArgType(a) =
  { ExprType(MovedArg(ArgMoved(a), ArgExpr(a)))  if ArgMoved(a) = true
    PlaceType(ArgExpr(a))                        if ArgMoved(a) = false }

**(ArgsT-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk_T([], [])

**(ArgsT-Cons)**
Î“; R; L âŠ¢ MovedArg(moved, e) â‡ T_p âŠ£ âˆ…    moved = true    Î“; R; L âŠ¢ ArgsOk_T(ps, as)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk_T([âŸ¨`move`, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as)

**(ArgsT-Cons-Ref)**
Î“; R; L âŠ¢ e â‡_place T_p    AddrOfOk(e)    moved = false    Î“; R; L âŠ¢ ArgsOk_T(ps, as)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk_T([âŸ¨âŠ¥, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as)

**(T-Call)**
Î“; R; L âŠ¢ callee : TypeFunc(params, R_c)    Î“; R; L âŠ¢ ArgsOk_T(params, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) : R_c

**(Call-Extern-Unsafe-Err)**
CalleeProc(callee) = proc    proc = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _)    Â¬ UnsafeSpan(span(Call(callee, args)))    c = Code(Call-Extern-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-Callee-NotFunc)**
Î“; R; L âŠ¢ callee : T    T â‰  TypeFunc(_, _)    Â¬(RecordCallee(callee) âˆ§ args = [])    c = Code(Call-Callee-NotFunc)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-ArgCount-Err)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    |params| â‰  |args|    c = Code(Call-ArgCount-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-ArgType-Err)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    âˆƒ i. Â¬(Î“; R; L âŠ¢ ArgType(args[i]) <: ParamType(params[i]))    c = Code(Call-ArgType-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-Move-Missing)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    âˆƒ i. ParamMode(params[i]) = `move` âˆ§ ArgMoved(args[i]) = false    c = Code(Call-Move-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-Move-Unexpected)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    âˆƒ i. ParamMode(params[i]) = âŠ¥ âˆ§ ArgMoved(args[i]) = true    c = Code(Call-Move-Unexpected)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-Arg-Packed-Unsafe-Err)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    âˆƒ i. ParamMode(params[i]) = âŠ¥ âˆ§ PackedField(ArgExpr(args[i])) âˆ§ Â¬ UnsafeSpan(span(ArgExpr(args[i])))    c = Code(Packed-Field-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

**(Call-Arg-NotPlace)**
Î“; R; L âŠ¢ callee : TypeFunc(params, _)    âˆƒ i. ParamMode(params[i]) = âŠ¥ âˆ§ Â¬ IsPlace(ArgExpr(args[i]))    c = Code(Call-Arg-NotPlace)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c

#### 5.2.5. Tuples

**(T-Unit-Literal)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleExpr([]) : TypePrim("()")

**(T-Tuple-Literal)**
n â‰¥ 1    âˆ€ i, Î“ âŠ¢ e_i : T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleExpr([e_1, â€¦, e_n]) : TypeTuple([T_1, â€¦, T_n])

**(T-Tuple-Index)**
Î“ âŠ¢ e : TypeTuple([T_0, â€¦, T_{n-1}])    0 â‰¤ i < n    BitcopyType(T_i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) : T_i

**(T-Tuple-Index-Perm)**
Î“ âŠ¢ e : TypePerm(p, TypeTuple([T_0, â€¦, T_{n-1}]))    0 â‰¤ i < n    BitcopyType(TypePerm(p, T_i))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) : TypePerm(p, T_i)

**(P-Tuple-Index)**
Î“ âŠ¢ e :place TypeTuple([T_0, â€¦, T_{n-1}])    0 â‰¤ i < n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) :place T_i

**(P-Tuple-Index-Perm)**
Î“ âŠ¢ e :place TypePerm(p, TypeTuple([T_0, â€¦, T_{n-1}]))    0 â‰¤ i < n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) :place TypePerm(p, T_i)

ConstTupleIndex(i) â‡” âˆƒ n âˆˆ â„¤. i = n

**(TupleIndex-NonConst)**
Â¬ ConstTupleIndex(i)    c = Code(TupleIndex-NonConst)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) â‡‘ c

**(TupleIndex-OOB)**
Î“ âŠ¢ e : TypeTuple([T_0, â€¦, T_{n-1}])    (i < 0 âˆ¨ i â‰¥ n)    c = Code(TupleIndex-OOB)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) â‡‘ c

**(TupleAccess-NotTuple)**
Î“ âŠ¢ e : T    StripPerm(T) â‰  TypeTuple(_)    c = Code(TupleAccess-NotTuple)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleAccess(e, i) â‡‘ c

#### 5.2.6. Arrays and Slices

ConstIndex(e) â‡” âˆƒ n. Î“ âŠ¢ ConstLen(e) â‡“ n

**(T-Array-Literal-List)**
âˆ€ i, Î“ âŠ¢ e_i : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ArrayExpr([e_1, â€¦, e_n]) : TypeArray(T, Literal(IntLiteral(n)))

**(T-Index-Array)**
Î“ âŠ¢ e_1 : TypeArray(T, len)    Î“ âŠ¢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Î“ âŠ¢ ConstLen(e_2) â‡“ i    Î“ âŠ¢ ConstLen(len) â‡“ n    i < n    BitcopyType(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : T

**(T-Index-Array-Perm)**
Î“ âŠ¢ e_1 : TypePerm(p, TypeArray(T, len))    Î“ âŠ¢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Î“ âŠ¢ ConstLen(e_2) â‡“ i    Î“ âŠ¢ ConstLen(len) â‡“ n    i < n    BitcopyType(TypePerm(p, T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : TypePerm(p, T)

**(Index-Array-NonConst-Err)**
Î“ âŠ¢ e_1 : TypeArray(T, _)    Î“ âŠ¢ e_2 : TypePrim("usize")    Â¬ ConstIndex(e_2)    c = Code(Index-Array-NonConst-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

**(Index-Array-OOB-Err)**
Î“ âŠ¢ e_1 : TypeArray(T, len)    ConstIndex(e_2)    Î“ âŠ¢ ConstLen(e_2) â‡“ i    Î“ âŠ¢ ConstLen(len) â‡“ n    i â‰¥ n    c = Code(Index-Array-OOB-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

**(Index-Slice-Direct-Err)**
Î“ âŠ¢ e_1 : TypeSlice(T)    Î“ âŠ¢ e_2 : TypePrim("usize")    c = Code(Index-Slice-Direct-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

**(Index-Slice-Perm-Direct-Err)**
Î“ âŠ¢ e_1 : TypePerm(p, TypeSlice(T))    Î“ âŠ¢ e_2 : TypePrim("usize")    c = Code(Index-Slice-Direct-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

**(T-Slice-From-Array)**
Î“ âŠ¢ e_1 : TypeArray(T, n)    Î“; R; L âŠ¢ e_2 : Range    BitcopyType(TypeSlice(T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : TypeSlice(T)

**(T-Slice-From-Array-Perm)**
Î“ âŠ¢ e_1 : TypePerm(p, TypeArray(T, n))    Î“; R; L âŠ¢ e_2 : Range    BitcopyType(TypePerm(p, TypeSlice(T)))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : TypePerm(p, TypeSlice(T))

**(T-Slice-From-Slice)**
Î“ âŠ¢ e_1 : TypeSlice(T)    Î“; R; L âŠ¢ e_2 : Range    BitcopyType(TypeSlice(T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : TypeSlice(T)

**(T-Slice-From-Slice-Perm)**
Î“ âŠ¢ e_1 : TypePerm(p, TypeSlice(T))    Î“; R; L âŠ¢ e_2 : Range    BitcopyType(TypePerm(p, TypeSlice(T)))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) : TypePerm(p, TypeSlice(T))

**(P-Index-Array)**
Î“ âŠ¢ e_1 :place TypeArray(T, len)    Î“ âŠ¢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Î“ âŠ¢ ConstLen(e_2) â‡“ i    Î“ âŠ¢ ConstLen(len) â‡“ n    i < n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place T

**(P-Index-Array-Perm)**
Î“ âŠ¢ e_1 :place TypePerm(p, TypeArray(T, len))    Î“ âŠ¢ e_2 : TypePrim("usize")    ConstIndex(e_2)    Î“ âŠ¢ ConstLen(e_2) â‡“ i    Î“ âŠ¢ ConstLen(len) â‡“ n    i < n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place TypePerm(p, T)

**(P-Slice-From-Array)**
Î“ âŠ¢ e_1 :place TypeArray(T, n)    Î“; R; L âŠ¢ e_2 : Range
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place TypeSlice(T)

**(P-Slice-From-Array-Perm)**
Î“ âŠ¢ e_1 :place TypePerm(p, TypeArray(T, n))    Î“; R; L âŠ¢ e_2 : Range
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place TypePerm(p, TypeSlice(T))

**(P-Slice-From-Slice)**
Î“ âŠ¢ e_1 :place TypeSlice(T)    Î“; R; L âŠ¢ e_2 : Range
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place TypeSlice(T)

**(P-Slice-From-Slice-Perm)**
Î“ âŠ¢ e_1 :place TypePerm(p, TypeSlice(T))    Î“; R; L âŠ¢ e_2 : Range
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) :place TypePerm(p, TypeSlice(T))

**(Coerce-Array-Slice)**
Î“ âŠ¢ e : TypePerm(p, TypeArray(T, n))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : TypePerm(p, TypeSlice(T))

**(Index-Array-NonUsize)**
Î“ âŠ¢ e_1 : TypeArray(T, _)    Î“ âŠ¢ e_2 : T_i    T_i â‰  TypePrim("usize")    c = Code(Index-Array-NonUsize)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

**(Index-NonIndexable)**
Î“ âŠ¢ e_1 : T    StripPerm(T) âˆ‰ {TypeArray(_, _), TypeSlice(_)}    c = Code(Index-NonIndexable)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ IndexAccess(e_1, e_2) â‡‘ c

#### 5.2.7. Union Types

Members(TypeUnion([T_1, â€¦, T_n])) = [T_1, â€¦, T_n]
DistinctMembers(U) = [T_i âˆˆ Members(U) | âˆ€ j < i. Â¬(Î“ âŠ¢ T_i â‰¡ T_j)]
SetMembers(U) = { T | T âˆˆ DistinctMembers(U) }

**(T-Union-Intro)**
Î“ âŠ¢ e : T    Member(T, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : U

**(Union-DirectAccess-Err)**
Î“; R; L âŠ¢ e : U    StripPerm(U) = TypeUnion(_)    c = Code(Union-DirectAccess-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) â‡‘ c

#### 5.2.8. Default Record Construction

Fields(R) = Fields_{Â§ 5.3.2}(R)

InitOk(f) â‡” f = FieldDecl(attrs_opt, vis, boundary, name, T_f, init_opt, span, doc) âˆ§ (init_opt = âŠ¥) âˆ¨ (init_opt = e âˆ§ Î“; âŠ¥; âŠ¥ âŠ¢ e : T âˆ§ Î“ âŠ¢ T <: T_f)

**(WF-Record)**
âˆ€ f âˆˆ Fields(R), InitOk(f)    âˆ€ f_i â‰  f_j, f_i.name â‰  f_j.name
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ R record wf

**(WF-Record-DupField)**
âˆƒ f_i â‰  f_j. f_i.name = f_j.name    c = Code(WF-Record-DupField)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ R record wf â‡‘ c

DefaultConstructible(R) â‡” âˆ€ f âˆˆ Fields(R). f.init_opt â‰  âŠ¥
BuiltinRecord = {`RegionOptions`, `DirEntry`, `Context`, `System`}
BuiltinEnum = {`FileKind`, `IoError`, `AllocationError`}
BuiltinModal = {`Region`, `File`, `DirIter`, `CancelToken`, `Spawned`, `Tracked`, `Async`}

RecordPath(R) = [R.name]    if R.name âˆˆ BuiltinRecord
RecordPath(R) = FullPath(ModuleOf(R), R.name)    otherwise
RecordCallee(callee) = R â‡” (callee = Identifier(name) âˆ¨ callee = Path(path, name)) âˆ§ Î“ âŠ¢ ResolveTypeName(name) â‡“ ent âˆ§ ent.origin_opt = mp âˆ§ name' = (ent.target_opt if present, else name) âˆ§ RecordDecl(FullPath(PathOfModule(mp), name')) = R

**(T-Record-Default)**
RecordCallee(callee) = R    Î“ âŠ¢ R record wf    DefaultConstructible(R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Call(callee, []) : TypePath(RecordPath(R))

**(Record-Default-Init-Err)**
RecordCallee(callee) = R    Â¬ DefaultConstructible(R)    c = Code(Record-Default-Init-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Call(callee, []) â‡‘ c

#### 5.2.9. Type Inference (Cursive0)

TypeInfJudg = {â‡’, â‡, Solve}

Constraint = Type Ã— Type
ConstraintSet = â„˜(Constraint)
Solve(C) â‡“ id â‡” C = âˆ…
Solve(C) â‡‘ â‡” C â‰  âˆ…
âˆ€ Î“, R, L, e, T, C. Î“; R; L âŠ¢ e â‡’ T âŠ£ C â‡’ C = âˆ…
âˆ€ Î“, R, L, e, T, C. Î“; R; L âŠ¢ e â‡ T âŠ£ C â‡’ C = âˆ…

**(Syn-Expr)**
Î“; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡’ T âŠ£ âˆ…

**(Syn-Ident)**
(x : T) âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Identifier(x) â‡’ T âŠ£ âˆ…

**(Syn-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ TupleExpr([]) â‡’ TypePrim("()") âŠ£ âˆ…

**(Syn-Tuple)**
n â‰¥ 1    âˆ€ i, Î“; R; L âŠ¢ e_i â‡’ T_i âŠ£ C_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ TupleExpr([e_1, â€¦, e_n]) â‡’ TypeTuple([T_1, â€¦, T_n]) âŠ£ â‹ƒ_i C_i

**(Syn-Call)**
Î“; R; L âŠ¢ callee â‡’ TypeFunc(params, R_c) âŠ£ C_0    Î“; R; L âŠ¢ ArgsOk_T(params, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡’ R_c âŠ£ C_0

**(Syn-Call-Err)**
Î“; R; L âŠ¢ Call(callee, args) â‡‘ c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Call(callee, args) â‡’ T âŠ£ C â‡‘ c

**(Chk-Subsumption-Modal-NonNiche)**
Î“; R; L âŠ¢ e â‡’ S âŠ£ C    StripPerm(S) = TypeModalState(modal_ref, S_s)    StripPerm(T) = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    Â¬ NicheCompatible(modal_ref, S_s)    c = Code(Chk-Subsumption-Modal-NonNiche)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡ T â‡‘ c

**(Chk-Subsumption)**
Î“; R; L âŠ¢ e â‡’ S âŠ£ C    Î“ âŠ¢ S <: T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡ T âŠ£ C

**(Chk-Null-Ptr)**
T = TypePtr(U, s)    s âˆˆ {`Null`, âŠ¥}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ PtrNullExpr â‡ T âŠ£ âˆ…

PtrNullExpected(T) â‡” T = TypePtr(U, s) âˆ§ s âˆˆ {`Null`, âŠ¥}

**(Syn-PtrNull-Err)**
c = Code(PtrNull-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ PtrNullExpr â‡’ T âŠ£ C â‡‘ c

**(Chk-PtrNull-Err)**
Â¬ PtrNullExpected(T)    c = Code(PtrNull-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ PtrNullExpr â‡ T âŠ£ C â‡‘ c

#### 5.2.10. Literal Expressions (Cursive0)

IntTypes = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `isize`, `usize`}
FloatTypes = {`f16`, `f32`, `f64`}
FloatFormat("f16") = `binary16`    FloatFormat("f32") = `binary32`    FloatFormat("f64") = `binary64`
FloatBitWidth("f16") = 16    FloatBitWidth("f32") = 32    FloatBitWidth("f64") = 64
FloatValueSet(t) = { v | v is a value representable by IEEE 754-2019 format FloatFormat(t) }
IEEE754Encode(t, v) = bits â‡” v âˆˆ FloatValueSet(t) âˆ§ bits âˆˆ [0, 2^{FloatBitWidth(t)} - 1] âˆ§ ((v is NaN in IEEE 754-2019 format FloatFormat(t) âˆ§ bits = CanonicalNaNBits(t)) âˆ¨ (v is not NaN in IEEE 754-2019 format FloatFormat(t) âˆ§ bits is the IEEE 754-2019 encoding of v in format FloatFormat(t)))
CanonicalNaNBits("f16") = 0x7E00    CanonicalNaNBits("f32") = 0x7FC00000    CanonicalNaNBits("f64") = 0x7FF8000000000000
CanonicalNaN(t) = v â‡” IEEE754Encode(t, v) = CanonicalNaNBits(t)
NonNaNValueSet(t) = { v âˆˆ FloatValueSet(t) | IEEE754Encode(t, v) â‰  CanonicalNaNBits(t) }
LSB(n) = n mod 2
EvenSignificandLSB(t, v) â‡” LSB(IEEE754Encode(t, v)) = 0
DefaultInt = `i32`
DefaultFloat = `f32`
IntValue : Token â‡€ â„¤    FloatValue : Token â‡€ â„
IntSuffix : Token â‡€ IntTypes    FloatSuffix : Token â‡€ FloatTypes
IntCore(s) â‡” s matches (`decimal_integer` | `hex_integer` | `octal_integer` | `binary_integer`)
FloatCore(s) â‡” s matches `float_literal`
StripIntSuffix(s) = âŸ¨core, tâŸ© â‡” s = core ++ t âˆ§ t âˆˆ IntSuffixSet âˆ§ IntCore(core)
StripIntSuffix(s) = âŸ¨s, âŠ¥âŸ© â‡” Â¬ âˆƒ t. s = core ++ t âˆ§ t âˆˆ IntSuffixSet âˆ§ IntCore(core)
StripFloatSuffix(s) = âŸ¨core, tâŸ© â‡” s = core ++ t âˆ§ t âˆˆ FloatSuffixSet âˆ§ FloatCore(core)
StripFloatSuffix(s) = âŸ¨s, âŠ¥âŸ© â‡” Â¬ âˆƒ t. s = core ++ t âˆ§ t âˆˆ FloatSuffixSet âˆ§ FloatCore(core)
IntSuffix(lit) = t â‡” lit.kind = IntLiteral âˆ§ StripIntSuffix(Lexeme(lit)) = âŸ¨_, tâŸ©
FloatSuffix(lit) = t â‡” lit.kind = FloatLiteral âˆ§ StripFloatSuffix(Lexeme(lit)) = âŸ¨_, tâŸ©
IntValueCore(s) = v â‡” (s = "0x" ++ h âˆ§ v = HexValue(Digits(h))) âˆ¨ (s = "0o" ++ o âˆ§ v = OctValue(Digits(o))) âˆ¨ (s = "0b" ++ b âˆ§ v = BinValue(Digits(b))) âˆ¨ (s matches `decimal_integer` âˆ§ v = DecValue(Digits(s)))
IntValue(lit) = v â‡” lit.kind = IntLiteral âˆ§ StripIntSuffix(Lexeme(lit)) = âŸ¨core, _âŸ© âˆ§ IntValueCore(core) = v
FloatParts(s) = âŸ¨a, b, eâŸ© â‡” s = a ++ "." ++ b ++ exp âˆ§ (exp = "" â‡’ e = 0) âˆ§ (exp â‰  "" â‡’ exp = "e" ++ sign ++ d âˆ¨ exp = "E" ++ sign ++ d) âˆ§ (sign = "" â‡’ e = DecValue(Digits(d))) âˆ§ (sign = "+" â‡’ e = DecValue(Digits(d))) âˆ§ (sign = "-" â‡’ e = -DecValue(Digits(d)))
FloatValueCore(s) = v â‡” FloatParts(s) = âŸ¨a, b, eâŸ© âˆ§ v = (DecValue(Digits(a)) Â· 10^{|Digits(b)|} + DecValue(Digits(b))) Â· 10^{e - |Digits(b)|}
FloatValue(lit) = v â‡” lit.kind = FloatLiteral âˆ§ StripFloatSuffix(Lexeme(lit)) = âŸ¨core, _âŸ© âˆ§ FloatValueCore(core) = v
InRange(v, T) â‡” v âˆˆ RangeOf(T)
RangeOf : TypePrimName â†’ â„˜(â„)
RangeOf(t) = [-2^{w-1}, 2^{w-1} - 1] if t âˆˆ SignedIntTypes âˆ§ w = IntWidth(t)
RangeOf(t) = [0, 2^{w} - 1] if t âˆˆ UnsignedIntTypes âˆ§ w = IntWidth(t)
RangeOf(t) undefined otherwise

**(T-Int-Literal-Suffix)**
lit.kind = IntLiteral    IntSuffix(lit) = t    InRange(IntValue(lit), t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim(t)

**(T-Int-Literal-Default)**
lit.kind = IntLiteral    IntSuffix(lit) = âŠ¥    InRange(IntValue(lit), `i32`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim("i32")

**(T-Float-Literal-Explicit)**
lit.kind = FloatLiteral    FloatSuffix(lit) = t    t âˆˆ {"f16", "f32", "f64"}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim(t)

**(T-Float-Literal-Infer)**
lit.kind = FloatLiteral    FloatSuffix(lit) = "f"
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim("f32")

**(T-Bool-Literal)**
lit.kind = BoolLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim("bool")

**(T-Char-Literal)**
lit.kind = CharLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypePrim("char")

**(T-String-Literal)**
lit.kind = StringLiteral
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Literal(lit) : TypeString(`@View`)

**(Syn-Literal)**
Î“ âŠ¢ Literal(lit) : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡’ T âŠ£ âˆ…

NullLiteralExpected(T) â‡” T = TypeRawPtr(q, U)

**(Chk-Int-Literal)**
lit.kind = IntLiteral    T = TypePrim(t)    t âˆˆ IntTypes    InRange(IntValue(lit), t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ âˆ…

**(Chk-Float-Literal-Explicit)**
lit.kind = FloatLiteral    FloatSuffix(lit) = s    s âˆˆ {"f16", "f32", "f64"}    T = TypePrim(s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ âˆ…

**(Chk-Float-Literal-Infer)**
lit.kind = FloatLiteral    FloatSuffix(lit) = "f"    T = TypePrim(t)    t âˆˆ FloatTypes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ âˆ…

**(Chk-Float-Literal-Mismatch-Err)**
lit.kind = FloatLiteral    FloatSuffix(lit) = s    s âˆˆ {"f16", "f32", "f64"}    T = TypePrim(t)    t âˆˆ FloatTypes    s â‰  t
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ âˆ… â‡‘ E-TYP-1531

**(Chk-Null-Literal)**
lit.kind = NullLiteral    T = TypeRawPtr(q, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ âˆ…

**(Syn-Null-Literal-Err)**
lit.kind = NullLiteral    c = Code(NullLiteral-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡’ T âŠ£ C â‡‘ c

**(Chk-Null-Literal-Err)**
lit.kind = NullLiteral    Â¬ NullLiteralExpected(T)    c = Code(NullLiteral-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Literal(lit) â‡ T âŠ£ C â‡‘ c

#### 5.2.11. Statement Typing (Cursive0)

MutKind = {`let`, `var`}
Bind = {âŸ¨mut, TâŸ© | mut âˆˆ MutKind âˆ§ T âˆˆ Type}
BindOf(Î“, x) = âŸ¨mut, TâŸ© â‡” âŸ¨mut, TâŸ© is the binding for x in the nearest scope of Scopes(Î“)
(x : T) âˆˆ Î“ â‡” âˆƒ mut. BindOf(Î“, x) = âŸ¨mut, TâŸ©
MutOf(Î“, x) = mut â‡” BindOf(Î“, x) = âŸ¨mut, TâŸ©

StmtJudg = {Î“; R; L âŠ¢ s â‡’ Î“' â–· âŸ¨Res, Brk, BrkVoidâŸ©, Î“; R; L âŠ¢ ss â‡’ Î“' â–· âŸ¨Res, Brk, BrkVoidâŸ©, Î“; R; L âŠ¢ e : T, Î“; R; L âŠ¢ b : T, Î“; R; L âŠ¢ BlockInfo(b) â‡“ âŸ¨T, Brk, BrkVoidâŸ©, Î“ âŠ¢ pat â‡ T âŠ£ B}

LoopFlag = {âŠ¥, `loop`}

PushScope(Î“) = Î“' â‡” Scopes(Î“') = [âˆ…] ++ Scopes(Î“) âˆ§ Project(Î“') = Project(Î“) âˆ§ ResCtx(Î“') = ResCtx(Î“)
PopScope(Î“') = Î“ â‡” Scopes(Î“') = [_] ++ Scopes(Î“) âˆ§ Project(Î“') = Project(Î“) âˆ§ ResCtx(Î“') = ResCtx(Î“)

IntroEnt = âŸ¨Value, âŠ¥, âŠ¥, DeclâŸ©

**(IntroAll-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IntroAll(Î“, []) â‡“ Î“

**(IntroAll-Cons)**
Î“ âŠ¢ Intro(x, IntroEnt) â‡“ Î“_1    IntroAll(Î“_1 âˆª {x â†¦ âŸ¨`let`, TâŸ©}, rest) â‡“ Î“_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IntroAll(Î“, [(x, T)] ++ rest) â‡“ Î“_2

**(IntroAllVar-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IntroAllVar(Î“, []) â‡“ Î“

**(IntroAllVar-Cons)**
Î“ âŠ¢ Intro(x, IntroEnt) â‡“ Î“_1    IntroAllVar(Î“_1 âˆª {x â†¦ âŸ¨`var`, TâŸ©}, rest) â‡“ Î“_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IntroAllVar(Î“, [(x, T)] ++ rest) â‡“ Î“_2

**(ShadowAll-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ShadowAll(Î“, []) â‡“ Î“

**(ShadowAll-Cons)**
Î“ âŠ¢ ShadowIntro(x, IntroEnt) â‡“ Î“_1    ShadowAll(Î“_1 âˆª {x â†¦ âŸ¨`let`, TâŸ©}, rest) â‡“ Î“_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ShadowAll(Î“, [(x, T)] ++ rest) â‡“ Î“_2

**(ShadowAllVar-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ShadowAllVar(Î“, []) â‡“ Î“

**(ShadowAllVar-Cons)**
Î“ âŠ¢ ShadowIntro(x, IntroEnt) â‡“ Î“_1    ShadowAllVar(Î“_1 âˆª {x â†¦ âŸ¨`var`, TâŸ©}, rest) â‡“ Î“_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ShadowAllVar(Î“, [(x, T)] ++ rest) â‡“ Î“_2

ResType([T_1, â€¦, T_n]) = T â‡” n â‰¥ 1 âˆ§ âˆ€ i. Î“ âŠ¢ T_i â‰¡ T
ResType([]) = âŠ¥

LoopTypeInf(Brk, BrkVoid) =
  { TypePrim("!")    if Brk = [] âˆ§ BrkVoid = false
    TypePrim("()")   if Brk = [] âˆ§ BrkVoid = true
    T                if BrkVoid = false âˆ§ ResType(Brk) = T
    âŠ¥                otherwise }

LoopTypeFin(Brk, BrkVoid) =
  { TypePrim("()")   if Brk = []
    T                if BrkVoid = false âˆ§ ResType(Brk) = T
    âŠ¥                otherwise }

**Statement Sequences**

**(StmtSeq-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ [] â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(StmtSeq-Cons)**
Î“; R; L âŠ¢ s â‡’ Î“_1 â–· âŸ¨Res_1, Brk_1, B_1âŸ©    Î“_1; R; L âŠ¢ ss â‡’ Î“_2 â–· âŸ¨Res_2, Brk_2, B_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ s :: ss â‡’ Î“_2 â–· âŸ¨Res_1 ++ Res_2, Brk_1 ++ Brk_2, B_1 âˆ¨ B_2âŸ©

**Bindings**

binding = âŸ¨pat, ty_opt, op, init, _âŸ©

**(T-LetStmt-Ann)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡ T_a âŠ£ âˆ…    Î“ âŠ¢ pat â‡ T_a âŠ£ B    Distinct(PatNames(pat))    IntroAll(Î“, B) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ LetStmt(binding) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-LetStmt-Ann-Mismatch)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Â¬(Î“ âŠ¢ T_i <: T_a)    c = Code(T-LetStmt-Ann-Mismatch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ LetStmt(binding) â‡‘ c

**(T-LetStmt-Infer)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡“ Î¸    T_b = Î¸(T_i)    Î“ âŠ¢ pat â‡ T_b âŠ£ B    Distinct(PatNames(pat))    IntroAll(Î“, B) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ LetStmt(binding) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-LetStmt-Infer-Err)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡‘    c = Code(T-LetStmt-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ LetStmt(binding) â‡‘ c

**(T-VarStmt-Ann)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡ T_a âŠ£ âˆ…    Î“ âŠ¢ pat â‡ T_a âŠ£ B    Distinct(PatNames(pat))    IntroAllVar(Î“, B) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ VarStmt(binding) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-VarStmt-Ann-Mismatch)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Â¬(Î“ âŠ¢ T_i <: T_a)    c = Code(T-VarStmt-Ann-Mismatch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ VarStmt(binding) â‡‘ c

**(T-VarStmt-Infer)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡“ Î¸    T_b = Î¸(T_i)    Î“ âŠ¢ pat â‡ T_b âŠ£ B    Distinct(PatNames(pat))    IntroAllVar(Î“, B) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ VarStmt(binding) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-VarStmt-Infer-Err)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡‘    c = Code(T-VarStmt-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ VarStmt(binding) â‡‘ c

**(T-ShadowLetStmt-Ann)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡ T_a âŠ£ âˆ…    ShadowAll(Î“, [âŸ¨name, T_aâŸ©]) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowLetStmt(name, ty_opt, init) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-ShadowLetStmt-Ann-Mismatch)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Â¬(Î“ âŠ¢ T_i <: T_a)    c = Code(T-ShadowLetStmt-Ann-Mismatch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowLetStmt(name, ty_opt, init) â‡‘ c

**(T-ShadowLetStmt-Infer)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡“ Î¸    T_b = Î¸(T_i)    ShadowAll(Î“, [âŸ¨name, T_bâŸ©]) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowLetStmt(name, ty_opt, init) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-ShadowLetStmt-Infer-Err)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡‘    c = Code(T-ShadowLetStmt-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowLetStmt(name, ty_opt, init) â‡‘ c

**(T-ShadowVarStmt-Ann)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡ T_a âŠ£ âˆ…    ShadowAllVar(Î“, [âŸ¨name, T_aâŸ©]) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowVarStmt(name, ty_opt, init) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-ShadowVarStmt-Ann-Mismatch)**
ty_opt = T_a    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Â¬(Î“ âŠ¢ T_i <: T_a)    c = Code(T-ShadowVarStmt-Ann-Mismatch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowVarStmt(name, ty_opt, init) â‡‘ c

**(T-ShadowVarStmt-Infer)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡“ Î¸    T_b = Î¸(T_i)    ShadowAllVar(Î“, [âŸ¨name, T_bâŸ©]) â‡“ Î“'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowVarStmt(name, ty_opt, init) â‡’ Î“' â–· âŸ¨[], [], falseâŸ©

**(T-ShadowVarStmt-Infer-Err)**
ty_opt = âŠ¥    Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡‘    c = Code(T-ShadowVarStmt-Infer-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ShadowVarStmt(name, ty_opt, init) â‡‘ c

**Assignments**

PlaceRoot(Identifier(x)) = x
PlaceRoot(FieldAccess(p, _)) = PlaceRoot(p)
PlaceRoot(TupleAccess(p, _)) = PlaceRoot(p)
PlaceRoot(IndexAccess(p, _)) = PlaceRoot(p)
PlaceRoot(Deref(p)) = PlaceRoot(p)

**(T-Assign)**
IsPlace(p)    PlaceRoot(p) = x    MutOf(Î“, x) = `var`    Î“; R; L âŠ¢ p :place T_p    Î“; R; L âŠ¢ e â‡ T_p âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AssignStmt(p, e) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-CompoundAssign)**
IsPlace(p)    PlaceRoot(p) = x    MutOf(Î“, x) = `var`    Î“; R; L âŠ¢ p :place T_p    StripPerm(T_p) = TypePrim(t)    t âˆˆ NumericTypes    Î“; R; L âŠ¢ e : T_e    Î“ âŠ¢ T_e <: TypePrim(t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ CompoundAssignStmt(p, op, e) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(Assign-NotPlace)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    Â¬ IsPlace(p)    c = Code(Assign-NotPlace)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ stmt â‡‘ c

**(Assign-Immutable-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    PlaceRoot(p) = x    MutOf(Î“, x) = `let`    c = Code(Assign-Immutable-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ stmt â‡‘ c

**(Assign-Type-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    Î“; R; L âŠ¢ p :place T_p    Î“; R; L âŠ¢ e â‡’ T_e âŠ£ C    ((stmt = AssignStmt(p, e) âˆ§ Â¬(Î“ âŠ¢ T_e <: T_p)) âˆ¨ (stmt = CompoundAssignStmt(p, op, e) âˆ§ (Â¬(Î“ âŠ¢ T_e <: StripPerm(T_p)) âˆ¨ Â¬ âˆƒ t. StripPerm(T_p) = TypePrim(t) âˆ§ t âˆˆ NumericTypes)))    c = Code(Assign-Type-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ stmt â‡‘ c

**Const-Qualified Places.**

**(Assign-Const-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    Î“; R; L âŠ¢ p : TypePerm(`const`, T)    c = Code(Assign-Const-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ stmt â‡‘ c

**Expression and Unsafe Statements**

**(T-ExprStmt)**
Î“; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ExprStmt(e) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-UnsafeStmt)**
Î“; R; L âŠ¢ b : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ UnsafeBlockStmt(b) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-DeferStmt)**
Î“; R; L âŠ¢ b â‡ TypePrim("()") âŠ£ âˆ…    DeferSafe(b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ DeferStmt(b) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(Defer-NonUnit-Err)**
Î“; R; L âŠ¢ b : T_b    T_b â‰  TypePrim("()")    c = Code(Defer-NonUnit-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ DeferStmt(b) â‡‘ c

**(Defer-NonLocal-Err)**
Â¬ DeferSafe(b)    c = Code(Defer-NonLocal-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ DeferStmt(b) â‡‘ c

**(HasNonLocalCtrl-Return)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(ReturnStmt(_), in_loop)

**(HasNonLocalCtrl-Break)**
in_loop = false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(BreakStmt(_), in_loop)

**(HasNonLocalCtrl-Continue)**
in_loop = false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(ContinueStmt, in_loop)

**(HasNonLocalCtrl-LoopInfinite)**
HasNonLocalCtrl(body, true)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(LoopInfinite(body), in_loop)

**(HasNonLocalCtrl-LoopConditional)**
HasNonLocalCtrl(body, true)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(LoopConditional(_, body), in_loop)

**(HasNonLocalCtrl-LoopIter)**
HasNonLocalCtrl(body, true)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(LoopIter(_, _, _, body), in_loop)

**(HasNonLocalCtrl-Child)**
C âˆ‰ {LoopInfinite, LoopConditional, LoopIter}    âˆƒ i. HasNonLocalCtrl(x_i, in_loop)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HasNonLocalCtrl(C(x_1, â€¦, x_n), in_loop)

DeferSafe(b) â‡” Â¬ HasNonLocalCtrl(b, false)

**(T-RegionStmt)**
RegionOptsExpr(opts_opt) = opts    Î“; R; L âŠ¢ opts â‡ TypePath([`RegionOptions`]) âŠ£ âˆ…    RegionBind(Î“, alias_opt) = Î“_r    Î“_r; R; L âŠ¢ b : T_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RegionStmt(opts_opt, alias_opt, b) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-FrameStmt-Implicit)**
FrameBind(Î“, âŠ¥) = Î“_f    Î“_f; R; L âŠ¢ b : T_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FrameStmt(âŠ¥, b) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-FrameStmt-Explicit)**
FrameBind(Î“, r) = Î“_f    Î“_f; R; L âŠ¢ b : T_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FrameStmt(r, b) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(Frame-NoActiveRegion-Err)**
InnermostActiveRegion(Î“) undefined    c = Code(Frame-NoActiveRegion-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FrameStmt(âŠ¥, b) â‡‘ c

**(Frame-Target-NotActive-Err)**
Î“; R; L âŠ¢ Identifier(r) : T_r    Â¬ RegionActiveType(T_r)    c = Code(Frame-Target-NotActive-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FrameStmt(r, b) â‡‘ c

**Control Flow Statements**

**(T-Return-Value)**
R_b = BodyReturnType(R)    Î“; R; L âŠ¢ e â‡ R_b âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(e) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(T-Return-Unit)**
R_b = BodyReturnType(R)    R_b = TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(âŠ¥) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(Return-Async-Type-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    Î“; R; L âŠ¢ e : T    Â¬(Î“ âŠ¢ T <: Result)    c = Code(E-CON-0203)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(e) â‡‘ c

**(Return-Async-Unit-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    Result â‰  TypePrim("()")    c = Code(E-CON-0203)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(âŠ¥) â‡‘ c

**(Return-Type-Err)**
AsyncSig(R) = âŠ¥    Î“; R; L âŠ¢ e : T    R_b = BodyReturnType(R)    Â¬(Î“ âŠ¢ T <: R_b)    c = Code(Return-Type-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(e) â‡‘ c

**(Return-Unit-Err)**
AsyncSig(R) = âŠ¥    R_b = BodyReturnType(R)    R_b â‰  TypePrim("()")    c = Code(Return-Type-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ReturnStmt(âŠ¥) â‡‘ c

**(T-Break-Value)**
L = `loop`    Î“; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BreakStmt(e) â‡’ Î“ â–· âŸ¨[], [T], falseâŸ©

**(T-Break-Unit)**
L = `loop`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BreakStmt(âŠ¥) â‡’ Î“ â–· âŸ¨[], [], trueâŸ©

**(Break-Outside-Loop)**
L â‰  `loop`    c = Code(Break-Outside-Loop)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BreakStmt(_) â‡‘ c

**(T-Continue)**
L = `loop`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ContinueStmt â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**(Continue-Outside-Loop)**
L â‰  `loop`    c = Code(Continue-Outside-Loop)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ContinueStmt â‡‘ c

**(T-ErrorStmt)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ErrorStmt(_) â‡’ Î“ â–· âŸ¨[], [], falseâŸ©

**Block Expressions**

LastStmt([]) = âŠ¥
LastStmt([s_1, â€¦, s_n]) = s_n    (n â‰¥ 1)

**(BlockInfo-Res)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = T    (tail_opt = e â‡’ Î“_1; R; L âŠ¢ e : T_e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockInfo(BlockExpr(stmts, tail_opt)) â‡“ âŸ¨T, Brk, BrkVoidâŸ©

**(BlockInfo-Res-Err)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Res â‰  []    Â¬ âˆƒ T. ResType(Res) = T    c = Code(BlockInfo-Res-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockInfo(BlockExpr(stmts, tail_opt)) â‡‘ c

**(BlockInfo-Tail)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = e    Î“_1; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockInfo(BlockExpr(stmts, tail_opt)) â‡“ âŸ¨T, Brk, BrkVoidâŸ©

**(BlockInfo-ReturnTail)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = âŠ¥    LastStmt(stmts) = ReturnStmt(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockInfo(BlockExpr(stmts, âŠ¥)) â‡“ âŸ¨TypePrim("!"), Brk, BrkVoidâŸ©

**(BlockInfo-Unit)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = âŠ¥    LastStmt(stmts) â‰  ReturnStmt(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockInfo(BlockExpr(stmts, âŠ¥)) â‡“ âŸ¨TypePrim("()"), Brk, BrkVoidâŸ©

**(T-Block)**
Î“; R; L âŠ¢ BlockInfo(b) â‡“ âŸ¨T, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ b : T

**(Chk-Block-Tail)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = e    Î“_1; R; L âŠ¢ e â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockExpr(stmts, tail_opt) â‡ T âŠ£ âˆ…

**(Chk-Block-Return)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = âŠ¥    LastStmt(stmts) = ReturnStmt(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockExpr(stmts, âŠ¥) â‡ T âŠ£ âˆ…

**(Chk-Block-Unit)**
Î“_0 = PushScope(Î“)    Î“_0; R; L âŠ¢ stmts â‡’ Î“_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Î“ âŠ¢ WarnResultUnreachable(stmts) â‡“ ok    ResType(Res) = âŠ¥    tail_opt = âŠ¥    LastStmt(stmts) â‰  ReturnStmt(_)    T = TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ BlockExpr(stmts, âŠ¥) â‡ T âŠ£ âˆ…

**(T-Unsafe-Expr)**
Î“; R; L âŠ¢ b : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ UnsafeBlockExpr(b) : T

**(Chk-Unsafe-Expr)**
Î“; R; L âŠ¢ b â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ UnsafeBlockExpr(b) â‡ T âŠ£ âˆ…

**Loop Expressions**

**(T-Loop-Infinite)**
Î“; R; `loop` âŠ¢ BlockInfo(body) â‡“ âŸ¨T_b, Brk, BrkVoidâŸ©    LoopTypeInf(Brk, BrkVoid) = T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopInfinite(body) : T

**(T-Loop-Conditional)**
Î“; R; L âŠ¢ cond : TypePrim("bool")    Î“; R; `loop` âŠ¢ BlockInfo(body) â‡“ âŸ¨T_b, Brk, BrkVoidâŸ©    LoopTypeFin(Brk, BrkVoid) = T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopConditional(cond, body) : T

**(T-Loop-Iter)**
(Î“; R; L âŠ¢ iter : TypePerm(p, TypeSlice(T)) âˆ¨ Î“; R; L âŠ¢ iter : TypeSlice(T) âˆ¨ Î“; R; L âŠ¢ iter : TypePerm(p, TypeArray(T, n)) âˆ¨ Î“; R; L âŠ¢ iter : TypeArray(T, n))    (ty_opt = âŠ¥ â‡’ T_p = T)    (ty_opt = T_a â‡’ Î“ âŠ¢ T <: T_a âˆ§ T_p = T_a)    Î“ âŠ¢ pat â‡ T_p âŠ£ B    Distinct(PatNames(pat))    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, B) â‡“ Î“_1    Î“_1; R; `loop` âŠ¢ BlockInfo(body) â‡“ âŸ¨T_b, Brk, BrkVoidâŸ©    LoopTypeFin(Brk, BrkVoid) = T_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIter(pat, ty_opt, iter, body) : T_r

**(T-Loop-Iter-Async)**
AsyncSig(R) = âŸ¨Out_r, In_r, Result_r, E_râŸ©    Î“; R; L âŠ¢ iter : T_iter    AsyncSig(T_iter) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    In_i = TypePrim("()")    Î“ âŠ¢ E_i <: E_r    (ty_opt = âŠ¥ â‡’ T_p = Out_i)    (ty_opt = T_a â‡’ Î“ âŠ¢ Out_i <: T_a âˆ§ T_p = T_a)    Î“ âŠ¢ pat â‡ T_p âŠ£ B    Distinct(PatNames(pat))    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, B) â‡“ Î“_1    Î“_1; R; `loop` âŠ¢ BlockInfo(body) â‡“ âŸ¨T_b, Brk, BrkVoidâŸ©    LoopTypeFin(Brk, BrkVoid) = T_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIter(pat, ty_opt, iter, body) : T_r

**(Loop-Async-Err)**
Î“; R; L âŠ¢ iter : T_iter    AsyncSig(T_iter) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    (AsyncSig(R) = âŠ¥ âˆ¨ In_i â‰  TypePrim("()"))    c = Code(E-CON-0240)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIter(pat, ty_opt, iter, body) â‡‘ c

**Irrefutable Binding Patterns**

PatJudg = {Î“ âŠ¢ pat â‡ T âŠ£ B}

**(Pat-Dup-Err)**
Â¬ Distinct(PatNames(pat))    c = Code(Pat-Dup-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ pat â‡ T â‡‘ c

**(Pat-Wildcard)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ _ â‡ T âŠ£ âˆ…

**(Pat-Ident)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x â‡ T âŠ£ {x â†¦ T}

**(Pat-Unit)**
T = TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ () â‡ T âŠ£ âˆ…

**(Pat-Tuple-Arity-Err)**
T = TypeTuple([T_1, â€¦, T_n])    ps = [p_1, â€¦, p_m]    m â‰  n    c = Code(Pat-Tuple-Arity-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (p_1, â€¦, p_m) â‡ T â‡‘ c

**(Pat-Tuple)**
T = TypeTuple([T_1, â€¦, T_n])    âˆ€ i, Î“ âŠ¢ p_i â‡ T_i âŠ£ B_i    B = âŠŽ_i B_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (p_1, â€¦, p_n) â‡ T âŠ£ B

**(Pat-Record)**
RecordDecl(p) = R â‡” RecordPath(R) = p
FieldType(R, f) = T_f â‡” âŸ¨_, f, T_f, _, _, _âŸ© âˆˆ Fields(R)
FieldName(âŸ¨f, _, _âŸ©) = f
PatOf(âŸ¨f, âŠ¥, _âŸ©) = IdentifierPattern(f)
PatOf(âŸ¨f, p, _âŸ©) = p    if p â‰  âŠ¥

T = TypePath(p)    RecordDecl(p) = R    âˆ€ fp âˆˆ fs, FieldType(R, FieldName(fp)) = T_f âˆ§ FieldVisible(m, R, FieldName(fp)) âˆ§ Î“ âŠ¢ PatOf(fp) â‡ T_f âŠ£ B_f    B = âŠŽ_{fp âˆˆ fs} B_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p{fs} â‡ T âŠ£ B

**(RecordPattern-UnknownField-Bind)**
T = TypePath(p)    RecordDecl(p) = R    âˆƒ fp âˆˆ fs. FieldName(fp) âˆ‰ FieldNameSet(R)    c = Code(RecordPattern-UnknownField)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p{fs} â‡ T â‡‘ c

**(Let-Refutable-Pattern-Err)**
pat âˆˆ {TypedPattern(_, _), LiteralPattern(_), EnumPattern(_, _, _), ModalPattern(_, _), RangePattern(_, _, _)}    c = Code(Let-Refutable-Pattern-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ pat â‡ T â‡‘ c

#### 5.2.12. Expression Typing (Cursive0)

UnresolvedExpr = {QualifiedName(_, _), QualifiedApply(_, _, _)}

**(Expr-Unresolved-Err)**
e âˆˆ UnresolvedExpr    c = Code(ResolveExpr-Ident-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡‘ c

ExprJudg = {Î“; R; L âŠ¢ e : T, Î“; R; L âŠ¢ e â‡ T âŠ£ C, Î“; R; L âŠ¢ p :place T, Î“; R; L âŠ¢ p â‡_place T, Î“; R; L âŠ¢ r : Range}

**(Lift-Expr)**
Î“ âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e : T

**(Place-Check)**
Î“; R; L âŠ¢ p :place S    Î“ âŠ¢ S <: T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ p â‡_place T

StripPerm(T) =
  { T_0   if T = TypePerm(p, T_0)
    T     otherwise }
BitcopyType(T) â‡” BitcopyTypeCore(T)
SignedIntTypes = {i8, i16, i32, i64, i128, isize}
NumericTypes = IntTypes âˆª FloatTypes
EqType(T) â‡” (StripPerm(T) = TypePrim(t) âˆ§ t âˆˆ NumericTypes âˆª {`bool`, `char`}) âˆ¨ StripPerm(T) = TypePtr(U, s) âˆ¨ StripPerm(T) = TypeRawPtr(q, U) âˆ¨ StripPerm(T) = TypeString(st) âˆ¨ StripPerm(T) = TypeBytes(st)
OrdType(T) â‡” StripPerm(T) = TypePrim(t) âˆ§ t âˆˆ IntTypes âˆª FloatTypes âˆª {`char`}
ValuePathType : Path Ã— Ident â‡€ Type
BuiltinValueSig(path, name) = âŸ¨params, retâŸ© â‡”
 (path = ["Region"] âˆ§ RegionProcSig(`Region::`name) = âŸ¨params, retâŸ©) âˆ¨
 (path = ["CancelToken"] âˆ§ CancelTokenProcSig(`CancelToken::`name) = âŸ¨params, retâŸ©)
ValuePathType(path, name) = StaticType(path, name) if StaticType(path, name) defined
ValuePathType(path, name) = TypeFunc([âŸ¨mode, TâŸ© | âŸ¨mode, x, TâŸ© âˆˆ params], ret) if BuiltinValueSig(path, name) = âŸ¨params, retâŸ©
ValuePathType(path, name) = TypeFunc([âŸ¨mode, TâŸ© | âŸ¨mode, x, TâŸ© âˆˆ params], ProcReturn(ret_opt)) if DeclOf(path, name) = ProcedureDecl(_, _, _, _, _, params, ret_opt, _, _, _, _)
ValuePathType(path, name) = TypeFunc([âŸ¨mode, TâŸ© | âŸ¨mode, x, TâŸ© âˆˆ params], ProcReturn(ret_opt)) if DeclOf(path, name) = ExternProcDecl(_, _, _, _, _, params, ret_opt, _, _, _, _)
ValuePathType(path, name) undefined otherwise
UnsafeSpan(span) â‡” âˆƒ U, K, D, K', i. ParseInputs(U, K, D, K') âˆ§ SourceOf(K'_i).path = span.file âˆ§ âˆƒ sp âˆˆ UnsafeSpans(K'_i). span âŠ† sp


**Identifiers and Paths**

**(T-Ident)**
(x : T) âˆˆ Î“    BitcopyType(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Identifier(x) : T

**(T-Path-Value)**
ValuePathType(path, name) = T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Path(path, name) : T

**Place Typing**

**(P-Ident)**
(x : T) âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Identifier(x) :place T

**Record Field Access**

FieldVis(R, f) = vis â‡” âŸ¨vis, f, T_f, _âŸ© âˆˆ Fields(R)
FieldVisible(m, R, f) â‡” FieldVis(R, f) âˆˆ {`public`, `internal`} âˆ¨ (FieldVis(R, f) âˆˆ {`private`, `protected`} âˆ§ ModuleOfPath(RecordPath(R)) = m)

**(T-Field-Record)**
Î“; R; L âŠ¢ e : TypePath(p)    RecordDecl(p) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)    BitcopyType(T_f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) : T_f

**(T-Field-Record-Perm)**
Î“; R; L âŠ¢ e : TypePerm(p, TypePath(q))    RecordDecl(q) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)    BitcopyType(TypePerm(p, T_f))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) : TypePerm(p, T_f)

**(P-Field-Record)**
Î“; R; L âŠ¢ e :place TypePath(p)    RecordDecl(p) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) :place T_f

**(P-Field-Record-Perm)**
Î“; R; L âŠ¢ e :place TypePerm(p, TypePath(q))    RecordDecl(q) = R    FieldType(R, f) = T_f    FieldVisible(m, R, f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) :place TypePerm(p, T_f)

**(FieldAccess-Unknown)**
Î“; R; L âŠ¢ e : TypePath(p)    RecordDecl(p) = R    f âˆ‰ FieldNameSet(R)    c = Code(FieldAccess-Unknown)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) â‡‘ c

**(FieldAccess-NotVisible)**
Î“; R; L âŠ¢ e : TypePath(p)    RecordDecl(p) = R    f âˆˆ FieldNameSet(R)    Â¬ FieldVisible(m, R, f)    c = Code(FieldAccess-NotVisible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) â‡‘ c

**(FieldAccess-Enum)**
Î“; R; L âŠ¢ e : TypePath(p)    EnumDecl(p) = E    c = Code(FieldAccess-Unknown)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ FieldAccess(e, f) â‡‘ c

**(ValueUse-NonBitcopyPlace)**
IsPlace(e)    Â¬ BitcopyType(ExprType(e))    c = Code(ValueUse-NonBitcopyPlace)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡‘ c

**Error Expression**

**(T-ErrorExpr)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ErrorExpr(_) : TypePrim("!")

**Range Expressions**

Î“; R; L âŠ¢ r : Range â‡’ ExprType(r) = TypeRange

**(Range-Full)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`Full`, âŠ¥, âŠ¥) : Range

**(Range-To)**
Î“; R; L âŠ¢ e : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`To`, âŠ¥, e) : Range

**(Range-ToInclusive)**
Î“; R; L âŠ¢ e : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`ToInclusive`, âŠ¥, e) : Range

**(Range-From)**
Î“; R; L âŠ¢ e : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`From`, e, âŠ¥) : Range

**(Range-Exclusive)**
Î“; R; L âŠ¢ e_1 : TypePrim("usize")    Î“; R; L âŠ¢ e_2 : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`Exclusive`, e_1, e_2) : Range

**(Range-Inclusive)**
Î“; R; L âŠ¢ e_1 : TypePrim("usize")    Î“; R; L âŠ¢ e_2 : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Range(`Inclusive`, e_1, e_2) : Range

**(Range-NonIndex-Err)**
e = Range(kind, lo_opt, hi_opt)    c = Code(Range-NonIndex-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡‘ c

**If Expressions**

**(T-If)**
Î“; R; L âŠ¢ c : TypePrim("bool")    Î“; R; L âŠ¢ b_t : T    Î“; R; L âŠ¢ b_f : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ IfExpr(c, b_t, b_f) : T

**(T-If-No-Else)**
Î“; R; L âŠ¢ c : TypePrim("bool")    Î“; R; L âŠ¢ b_t : TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ IfExpr(c, b_t, âŠ¥) : TypePrim("()")

**(Chk-If)**
Î“; R; L âŠ¢ c : TypePrim("bool")    Î“; R; L âŠ¢ b_t â‡ T âŠ£ âˆ…    Î“; R; L âŠ¢ b_f â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ IfExpr(c, b_t, b_f) â‡ T âŠ£ âˆ…

**(Chk-If-No-Else)**
Î“; R; L âŠ¢ c : TypePrim("bool")    T = TypePrim("()")    Î“; R; L âŠ¢ b_t â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ IfExpr(c, b_t, âŠ¥) â‡ T âŠ£ âˆ…

**Unary Operators**

**(T-Not-Bool)**
Î“; R; L âŠ¢ e : TypePrim("bool")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Unary("!", e) : TypePrim("bool")

**(T-Not-Int)**
Î“; R; L âŠ¢ e : TypePrim(t)    t âˆˆ IntTypes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Unary("!", e) : TypePrim(t)

**(T-Neg)**
Î“; R; L âŠ¢ e : TypePrim(t)    t âˆˆ SignedIntTypes âˆª FloatTypes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Unary("-", e) : TypePrim(t)

**Binary Operators**

ArithOps = {"+", "-", "*", "/", "%", "**"}
BitOps = {"&", "|", "^"}
ShiftOps = {"<<", ">>"}
CmpOps = {"==", "!=", "<", "<=", ">", ">="}
LogicOps = {"&&", "||"}

**(T-Arith)**
Î“; R; L âŠ¢ e_1 : T    Î“; R; L âŠ¢ e_2 : T    StripPerm(T) = TypePrim(t)    t âˆˆ NumericTypes    op âˆˆ ArithOps
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Bitwise)**
Î“; R; L âŠ¢ e_1 : T    Î“; R; L âŠ¢ e_2 : T    StripPerm(T) = TypePrim(t)    t âˆˆ IntTypes    op âˆˆ BitOps
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Shift)**
Î“; R; L âŠ¢ e_1 : T_1    Î“; R; L âŠ¢ e_2 : TypePrim("u32")    StripPerm(T_1) = TypePrim(t)    t âˆˆ IntTypes    op âˆˆ ShiftOps
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim(t)

**(T-Compare-Eq)**
Î“; R; L âŠ¢ e_1 : T    Î“; R; L âŠ¢ e_2 : T    EqType(T)    op âˆˆ {"==", "!="}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim("bool")

**(T-Compare-Ord)**
Î“; R; L âŠ¢ e_1 : T    Î“; R; L âŠ¢ e_2 : T    OrdType(T)    op âˆˆ {"<", "<=", ">", ">="}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim("bool")

**(T-Logical)**
Î“; R; L âŠ¢ e_1 : TypePrim("bool")    Î“; R; L âŠ¢ e_2 : TypePrim("bool")    op âˆˆ LogicOps
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Binary(op, e_1, e_2) : TypePrim("bool")

**Casts**

S' = StripPerm(S)
T' = StripPerm(T)
CastValid(S, T) â‡” (S' = TypePrim(s) âˆ§ T' = TypePrim(t) âˆ§ s, t âˆˆ NumericTypes) âˆ¨ (S' = TypePrim("bool") âˆ§ T' = TypePrim(t) âˆ§ t âˆˆ IntTypes) âˆ¨ (S' = TypePrim(t) âˆ§ t âˆˆ IntTypes âˆ§ T' = TypePrim("bool")) âˆ¨ (S' = TypePrim("char") âˆ§ T' = TypePrim("u32")) âˆ¨ (S' = TypePrim("u32") âˆ§ T' = TypePrim("char"))

**(T-Cast)**
Î“; R; L âŠ¢ e : S    CastValid(S, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Cast(e, T) : T

**Address-Of, Dereference, Move**

HasLayoutPacked(D) â‡” `layout(packed)` appears in D.attrs_opt
PackedField(p) â‡” p = FieldAccess(base, f) âˆ§ StripPerm(ExprType(base)) = TypePath(path) âˆ§ RecordDecl(path) = R âˆ§ HasLayoutPacked(R)
AddrOfOk(p) â‡” IsPlace(p) âˆ§ (p = IndexAccess(_, idx) â‡’ Î“; R; L âŠ¢ idx : T_i âˆ§ StripPerm(T_i) = TypePrim("usize")) âˆ§ (PackedField(p) â‡’ UnsafeSpan(span(p)))

**(T-AddrOf)**
Î“; R; L âŠ¢ p :place T    AddrOfOk(p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AddressOf(p) : TypePtr(T, `Valid`)

**(T-Alloc-Explicit)**
Î“; R; L âŠ¢ e : T    Î“; R; L âŠ¢ Identifier(r) : T_r    RegionActiveType(T_r)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AllocExpr(r, e) : T

**(T-Alloc-Implicit)**
InnermostActiveRegion(Î“) = r    Î“; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AllocExpr(âŠ¥, e) : T

**(Alloc-Region-NotFound-Err)**
e = AllocExpr(r, _)    r â‰  âŠ¥    Î“; R; L âŠ¢ Identifier(r) : T_r    Â¬ RegionActiveType(T_r)    c = Code(Alloc-Region-NotFound-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡‘ c

**(Alloc-Implicit-NoRegion-Err)**
e = AllocExpr(âŠ¥, _)    InnermostActiveRegion(Î“) undefined    c = Code(Alloc-Implicit-NoRegion-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e â‡‘ c

**(T-Deref-Ptr)**
Î“; R; L âŠ¢ e : TypePtr(T, `Valid`)    BitcopyType(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) : T

**(T-Deref-Raw)**
UnsafeSpan(span(Deref(e)))    Î“; R; L âŠ¢ e : TypeRawPtr(q, T)    BitcopyType(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) : T

**(P-Deref-Ptr)**
Î“; R; L âŠ¢ e : TypePtr(T, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) :place T

**(P-Deref-Raw-Imm)**
UnsafeSpan(span(Deref(e)))    Î“; R; L âŠ¢ e : TypeRawPtr(`imm`, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) :place TypePerm(`const`, T)

**(P-Deref-Raw-Mut)**
UnsafeSpan(span(Deref(e)))    Î“; R; L âŠ¢ e : TypeRawPtr(`mut`, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) :place TypePerm(`unique`, T)

**(T-Move)**
Î“; R; L âŠ¢ p :place T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MoveExpr(p) : T

**(AddrOf-Packed-Unsafe-Err)**
PackedField(p)    Â¬ UnsafeSpan(span(p))    c = Code(Packed-Field-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AddressOf(p) â‡‘ c

**(AddrOf-NonPlace)**
Â¬ IsPlace(e)    c = Code(AddrOf-NonPlace)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AddressOf(e) â‡‘ c

**(AddrOf-Index-Array-NonUsize)**
p = IndexAccess(base, idx)    Î“; R; L âŠ¢ base : TypeArray(T, n)    Î“; R; L âŠ¢ idx : T_i    StripPerm(T_i) â‰  TypePrim("usize")    c = Code(Index-Array-NonUsize)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AddressOf(p) â‡‘ c

**(AddrOf-Index-Slice-NonUsize)**
p = IndexAccess(base, idx)    Î“; R; L âŠ¢ base : TypeSlice(T, n)    Î“; R; L âŠ¢ idx : T_i    StripPerm(T_i) â‰  TypePrim("usize")    c = Code(Index-Slice-NonUsize)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AddressOf(p) â‡‘ c

**(Deref-Null)**
Î“; R; L âŠ¢ e : TypePtr(T, `Null`)    c = Code(Deref-Null)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) â‡‘ c

**(Deref-Expired)**
Î“; R; L âŠ¢ e : TypePtr(T, `Expired`)    c = Code(Deref-Expired)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) â‡‘ c

**(Deref-Raw-Unsafe)**
Î“; R; L âŠ¢ e : TypeRawPtr(q, T)    Â¬ UnsafeSpan(span(Deref(e)))    c = Code(Deref-Raw-Unsafe)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Deref(e) â‡‘ c

**Transmute**

**(T-Transmute-SizeEq)**
Î“ âŠ¢ sizeof(t_1) = sizeof(t_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TransmuteSizeOk(t_1, t_2)

**(T-Transmute-AlignEq)**
Î“ âŠ¢ alignof(t_1) = alignof(t_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TransmuteAlignOk(t_1, t_2)

**(T-Transmute)**
UnsafeSpan(span(TransmuteExpr(t_1, t_2, e)))    Î“ âŠ¢ t_1 wf    Î“ âŠ¢ t_2 wf    Î“ âŠ¢ TransmuteSizeOk(t_1, t_2)    Î“ âŠ¢ TransmuteAlignOk(t_1, t_2)    Î“; R; L âŠ¢ e : t_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ TransmuteExpr(t_1, t_2, e) : t_2

**(Transmute-Unsafe-Err)**
Â¬ UnsafeSpan(span(TransmuteExpr(t_1, t_2, e)))    c = Code(Transmute-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ TransmuteExpr(t_1, t_2, e) â‡‘ c

**Propagation (`?`)**

SuccessMember(R, U) = T_s â‡” U = TypeUnion([T_1, â€¦, T_n]) âˆ§ Â¬(Î“ âŠ¢ T_s <: R) âˆ§ âˆ€ i â‰  s. Î“ âŠ¢ T_i <: R

**(T-Propagate)**
AsyncSig(R) = âŠ¥    Î“; R; L âŠ¢ e : U    SuccessMember(R, U) = T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Propagate(e) : T_s

SuccessMemberAsync(E, U) = T_s â‡” U = TypeUnion([T_1, â€¦, T_n]) âˆ§ Â¬(Î“ âŠ¢ T_s <: E) âˆ§ âˆ€ i â‰  s. Î“ âŠ¢ T_i <: E

**(T-Async-Try)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    E â‰  TypePrim("!")    Î“; R; L âŠ¢ e : U    SuccessMemberAsync(E, U) = T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Propagate(e) : T_s

**(Async-Try-Infallible-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    E = TypePrim("!")    Î“; R; L âŠ¢ e : U    c = Code(E-CON-0230)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ Propagate(e) â‡‘ c

**Record Literals**

FieldNames(R) = [ f.name | f âˆˆ Fields(R) ]
FieldInitNames(fields) = [ f | âŸ¨f, _âŸ© âˆˆ fields ]
Set(xs) = { x | x âˆˆ xs }
FieldNameSet(R) = Set(FieldNames(R))
FieldInitSet(fields) = Set(FieldInitNames(fields))

**(T-Record-Literal)**
RecordDecl(p) = R    Distinct(FieldInitNames(fields))    FieldInitSet(fields) = FieldNameSet(R)    âˆ€ âŸ¨f, eâŸ© âˆˆ fields, FieldType(R, f) = T_f âˆ§ FieldVisible(m, R, f) âˆ§ Î“; R; L âŠ¢ e â‡ T_f âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) : TypePath(p)

**(Record-FieldInit-Dup)**
RecordDecl(p) = R    Â¬ Distinct(FieldInitNames(fields))    c = Code(Record-FieldInit-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) â‡‘ c

**(Record-FieldInit-Missing)**
RecordDecl(p) = R    FieldInitSet(fields) â‰  FieldNameSet(R)    c = Code(Record-FieldInit-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) â‡‘ c

**(Record-Field-Unknown)**
RecordDecl(p) = R    âˆƒ âŸ¨f, eâŸ© âˆˆ fields. f âˆ‰ FieldNameSet(R)    c = Code(Record-Field-Unknown)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) â‡‘ c

**(Record-Field-NotVisible)**
RecordDecl(p) = R    âˆƒ âŸ¨f, eâŸ© âˆˆ fields. Â¬ FieldVisible(m, R, f)    c = Code(Record-Field-NotVisible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) â‡‘ c

**(Record-Field-NonBitcopy-Move)**
RecordDecl(p) = R    âˆƒ âŸ¨f, eâŸ© âˆˆ fields. FieldType(R, f) = T_f âˆ§ Â¬ BitcopyType(T_f) âˆ§ IsPlace(e) âˆ§ e â‰  MoveExpr(_)    c = Code(Record-Field-NonBitcopy-Move)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(TypePath(p), fields) â‡‘ c

**Enum Literals**

EnumDecl(p) = E â‡” EnumPathOf(E) = p
VariantPayload(E, v) = payload_opt â‡” âˆƒ disc, span, doc. VariantDecl(v, payload_opt, disc, span, doc) âˆˆ E.variants
VariantFieldNames(fs) = [ f | FieldDecl(_, _, _, f, _, _, _, _) âˆˆ fs ]
VariantFieldNameSet(fs) = Set(VariantFieldNames(fs))

EnumFieldType(E, v, f) = T_f â‡” VariantPayload(E, v) = RecordPayload(fs) âˆ§ âŸ¨_, f, T_f, _, _, _âŸ© âˆˆ fs

**(T-Enum-Lit-Unit)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ EnumLiteral(path, âŠ¥) : TypePath(EnumPath(path))

**(T-Enum-Lit-Tuple)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = TuplePayload([T_1, â€¦, T_n])    âˆ€ i, Î“; R; L âŠ¢ e_i â‡ T_i âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ EnumLiteral(path, Paren([e_1, â€¦, e_n])) : TypePath(EnumPath(path))

**(T-Enum-Lit-Record)**
EnumDecl(EnumPath(path)) = E    v = VariantName(path)    VariantPayload(E, v) = RecordPayload(fs)    Distinct(FieldInitNames(fields))    FieldInitSet(fields) = VariantFieldNameSet(fs)    âˆ€ âŸ¨f, eâŸ© âˆˆ fields, Î“; R; L âŠ¢ e â‡ EnumFieldType(E, v, f) âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ EnumLiteral(path, Brace(fields)) : TypePath(EnumPath(path))

#### 5.2.13. Pattern Matching (Cursive0)

MatchJudg = {Î“ âŠ¢ pat â— T âŠ£ B, Î“; R; L âŠ¢ ArmBody(body) : T, Î“; R; L âŠ¢ ArmBody(body) â‡ T}

PermWrap(T, B) =
  { { x â†¦ TypePerm(p, T_x) | x â†¦ T_x âˆˆ B }    if T = TypePerm(p, U)
    B                                      otherwise }

**(Pat-StripPerm)**
Î“ âŠ¢ pat â— StripPerm(T) âŠ£ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ pat â— T âŠ£ PermWrap(T, B)

PatternEffectRules = RulesIn({"5.2.15"})

ConstPatInt(p) = n â‡” p = LiteralPattern(IntLiteral(n))

**(ArmBody-Expr)**
Î“; R; L âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArmBody(e) : T

**(ArmBody-Block)**
Î“; R; L âŠ¢ b : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArmBody(b) : T

**(ArmBody-Expr-Chk)**
Î“; R; L âŠ¢ e â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArmBody(e) â‡ T

**(ArmBody-Block-Chk)**
Î“; R; L âŠ¢ b â‡ T âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArmBody(b) â‡ T

**(Pat-Dup-R-Err)**
Â¬ Distinct(PatNames(pat))    c = Code(Pat-Dup-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ pat â— T â‡‘ c

**(Pat-Wildcard-R)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ _ â— T âŠ£ âˆ…

**(Pat-Ident-R)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ x â— T âŠ£ {x â†¦ T}

**(Pat-Literal-R)**
Î“ âŠ¢ Literal(lit) : T_l    Î“ âŠ¢ T_l <: T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LiteralPattern(lit) â— T âŠ£ âˆ…

**(Pat-Tuple-R-Arity-Err)**
StripPerm(T) = TypeTuple([T_1, â€¦, T_n])    ps = [p_1, â€¦, p_m]    m â‰  n    c = Code(Pat-Tuple-Arity-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TuplePattern(ps) â— T â‡‘ c

**(Pat-Tuple-R)**
StripPerm(T) = TypeTuple([T_1, â€¦, T_n])    âˆ€ i, Î“ âŠ¢ p_i â— T_i âŠ£ B_i    B = âŠŽ_i B_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TuplePattern([p_1, â€¦, p_n]) â— T âŠ£ B

**(Pat-Record-R)**
StripPerm(T) = TypePath(p)    RecordDecl(p) = R    âˆ€ fp âˆˆ fs, FieldType(R, FieldName(fp)) = T_f âˆ§ FieldVisible(m, R, FieldName(fp)) âˆ§ Î“ âŠ¢ PatOf(fp) â— T_f âŠ£ B_f    B = âŠŽ_{fp âˆˆ fs} B_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RecordPattern(p, fs) â— T âŠ£ B

**(RecordPattern-UnknownField)**
StripPerm(T) = TypePath(p)    RecordDecl(p) = R    âˆƒ fp âˆˆ fs. FieldName(fp) âˆ‰ FieldNameSet(R)    c = Code(RecordPattern-UnknownField)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RecordPattern(p, fs) â— T â‡‘ c

**(Pat-Enum-Unit-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumPattern(p, v, âŠ¥) â— T âŠ£ âˆ…

**(Pat-Enum-Tuple-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = TuplePayload([T_1, â€¦, T_n])    âˆ€ i, Î“ âŠ¢ p_i â— T_i âŠ£ B_i    B = âŠŽ_i B_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumPattern(p, v, TuplePayloadPattern([p_1, â€¦, p_n])) â— T âŠ£ B

**(Pat-Enum-Record-R)**
StripPerm(T) = TypePath(p)    EnumDecl(p) = E    VariantPayload(E, v) = RecordPayload(fs')    âˆ€ fp âˆˆ fs, EnumFieldType(E, v, FieldName(fp)) = T_f âˆ§ Î“ âŠ¢ PatOf(fp) â— T_f âŠ£ B_f    B = âŠŽ_{fp âˆˆ fs} B_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumPattern(p, v, RecordPayloadPattern(fs)) â— T âŠ£ B

**(Pat-Modal-R)**
StripPerm(T) = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    âˆ€ fp âˆˆ fs, ModalPayloadMap(modal_ref, S)(FieldName(fp)) = T_f âˆ§ Î“ âŠ¢ PatOf(fp) â— T_f âŠ£ B_f    B = âŠŽ_{fp âˆˆ fs} B_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModalPattern(S, fs) â— T âŠ£ B

**(Pat-Modal-State-R)**
StripPerm(T) = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    âˆ€ fp âˆˆ fs, ModalPayloadMap(modal_ref, S)(FieldName(fp)) = T_f âˆ§ Î“ âŠ¢ PatOf(fp) â— T_f âŠ£ B_f    B = âŠŽ_{fp âˆˆ fs} B_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModalPattern(S, fs) â— T âŠ£ B

**(Pat-Range-R)**
StripPerm(T) = TypePrim(t)    t âˆˆ IntTypes    ConstPatInt(p_l) = n_l    ConstPatInt(p_h) = n_h    (kind = ".." â‡’ n_l < n_h)    (kind = "..=" â‡’ n_l â‰¤ n_h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RangePattern(kind, p_l, p_h) â— T âŠ£ âˆ…

**(RangePattern-NonConst)**
(ConstPatInt(p_l) undefined âˆ¨ ConstPatInt(p_h) undefined)    c = Code(RangePattern-NonConst)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RangePattern(kind, p_l, p_h) â— T â‡‘ c

**(RangePattern-Empty)**
ConstPatInt(p_l) = n_l    ConstPatInt(p_h) = n_h    ((kind = "..") â‡’ n_l â‰¥ n_h)    ((kind = "..=") â‡’ n_l > n_h)    c = Code(RangePattern-Empty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RangePattern(kind, p_l, p_h) â— T â‡‘ c

AllEq_Î“([T_1, â€¦, T_n]) â‡” âˆ€ i. Î“ âŠ¢ T_i â‰¡ T_1
Irrefutable(pat, T) â‡” pat = WildcardPattern âˆ¨ pat = IdentifierPattern(_) âˆ¨ (pat = TuplePattern([p_1, â€¦, p_n]) âˆ§ StripPerm(T) = TypeTuple([T_1, â€¦, T_n]) âˆ§ âˆ€ i. Irrefutable(p_i, T_i)) âˆ¨ (pat = RecordPattern(p, fs) âˆ§ StripPerm(T) = TypePath(p) âˆ§ RecordDecl(p) = R âˆ§ âˆ€ fp âˆˆ fs. Irrefutable(PatOf(fp), FieldType(R, FieldName(fp))))
HasIrrefutableArm(arms, T) â‡” âˆƒ arm âˆˆ arms. âˆƒ p, g, b. arm = âŸ¨p, g, bâŸ© âˆ§ Irrefutable(p, T)

**Enum Match**

VariantNames(E) = [ v.name | v âˆˆ E.variants ]
ArmVariants(arms) = { v | âˆƒ p, g, b. âŸ¨p, g, bâŸ© âˆˆ arms âˆ§ p = EnumPattern(_, v, _) }

**(T-Match-Enum)**
Î“; R; L âŠ¢ e : TypePath(p)    EnumDecl(p) = E    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— TypePath(p) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) : T_i    AllEq_Î“([T_1, â€¦, T_k])    (HasIrrefutableArm(arms, TypePath(p)) âˆ¨ ArmVariants(arms) = VariantNames(E))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) : T_1

**Modal Match**

ArmStates(arms) = { s | âˆƒ p, g, b. âŸ¨p, g, bâŸ© âˆˆ arms âˆ§ p = ModalPattern(_, s) }

**(T-Match-Modal)**
Î“; R; L âŠ¢ e : ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— ModalRefType(modal_ref) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) : T_i    AllEq_Î“([T_1, â€¦, T_k])    (HasIrrefutableArm(arms, ModalRefType(modal_ref)) âˆ¨ ArmStates(arms) = States(M))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) : T_1

**(Match-Modal-NonExhaustive)**
Î“; R; L âŠ¢ e : ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    Â¬(HasIrrefutableArm(arms, ModalRefType(modal_ref)) âˆ¨ ArmStates(arms) = States(M))    c = Code(Match-Modal-NonExhaustive)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡‘ c

**Union Match**

UnionTypes(U) = [T_1, â€¦, T_n] â‡” U = TypeUnion([T_1, â€¦, T_n])
ArmUnionTypes(arms) = { T | âˆƒ p, g, b. âŸ¨p, g, bâŸ© âˆˆ arms âˆ§ p = Pat-Union(T, _) }
UnionTypesExhaustive(arms, types) â‡” âˆ€ T âˆˆ types. âˆƒ arm âˆˆ arms. âˆƒ p, g, b. arm = âŸ¨p, g, bâŸ© âˆ§ p = Pat-Union(T, _)

**(T-Match-Union)**
Î“; R; L âŠ¢ e : TypeUnion([T_1, â€¦, T_n])    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— TypeUnion([T_1, â€¦, T_n]) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) : T_i'    AllEq_Î“([T_1', â€¦, T_k'])    (HasIrrefutableArm(arms, TypeUnion([T_1, â€¦, T_n])) âˆ¨ UnionTypesExhaustive(arms, [T_1, â€¦, T_n]))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) : T_1'

**(Match-Union-NonExhaustive)**
Î“; R; L âŠ¢ e : TypeUnion([T_1, â€¦, T_n])    Â¬(HasIrrefutableArm(arms, TypeUnion([T_1, â€¦, T_n])) âˆ¨ UnionTypesExhaustive(arms, [T_1, â€¦, T_n]))    c = Code(Match-Union-NonExhaustive)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡‘ c

**(Chk-Match-Union)**
Î“; R; L âŠ¢ e : TypeUnion([T_1, â€¦, T_n])    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— TypeUnion([T_1, â€¦, T_n]) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) â‡ T    (HasIrrefutableArm(arms, TypeUnion([T_1, â€¦, T_n])) âˆ¨ UnionTypesExhaustive(arms, [T_1, â€¦, T_n]))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡ T âŠ£ âˆ…

**Other Matches**

**(T-Match-Other)**
Î“; R; L âŠ¢ e : T    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— T âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) : T_i    AllEq_Î“([T_1, â€¦, T_k])    HasIrrefutableArm(arms, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) : T_1

**(Chk-Match-Enum)**
Î“; R; L âŠ¢ e : TypePath(p)    EnumDecl(p) = E    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— TypePath(p) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) â‡ T    (HasIrrefutableArm(arms, TypePath(p)) âˆ¨ ArmVariants(arms) = VariantNames(E))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡ T âŠ£ âˆ…

**(Chk-Match-Modal)**
Î“; R; L âŠ¢ e : ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— ModalRefType(modal_ref) âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) â‡ T    (HasIrrefutableArm(arms, ModalRefType(modal_ref)) âˆ¨ ArmStates(arms) = StateNames(M))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡ T âŠ£ âˆ…

**(Chk-Match-Other)**
Î“; R; L âŠ¢ e : T_s    âˆ€ i, arm_i = âŸ¨p_i, g_i, b_iâŸ©    Î“ âŠ¢ p_i â— T_s âŠ£ B_i    Distinct(PatNames(p_i))    Î“_i = IntroAll(Î“, B_i)    (g_i â‰  âŠ¥ â‡’ Î“_i; R; L âŠ¢ g_i : TypePrim("bool"))    Î“_i; R; L âŠ¢ ArmBody(b_i) â‡ T    HasIrrefutableArm(arms, T_s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MatchExpr(e, arms) â‡ T âŠ£ âˆ…

#### 5.2.14. Declaration Typing (Cursive0)

DeclJudg = {Î“ âŠ¢ ProcedureDecl : ok, Î“ âŠ¢ ExternProcDecl : ok, Î“ âŠ¢ ExternBlock : ok, Î“ âŠ¢ StaticDecl : ok, Î“ âŠ¢ RecordDecl : ok, Î“ âŠ¢ EnumDecl : ok, Î“ âŠ¢ ModalDecl : ok, Î“ âŠ¢ ClassDecl : ok}

**DeclTyping.**
DeclTyping(Ms) â‡“ ok â‡” âˆ€ M âˆˆ Ms. Î“ âŠ¢ DeclTypingMod(M) â‡“ ok
DeclTypingMod(M) â‡“ ok â‡” âˆ€ it âˆˆ M.items. Î“ âŠ¢ DeclTypingItem(M.path, it) â‡“ ok

ProvBindCheck(params, body) â‡“ ok â‡” body = BlockExpr(stmts, tail_opt) âˆ§ âˆƒ vec{Ï€}. |vec{Ï€}| = |params| âˆ§ Î“; InitProvEnv(params, vec{Ï€}, []) âŠ¢ BlockProv(stmts, tail_opt) â‡“ Ï€

DeclTypingItem(m, ImportDecl(_)) â‡“ ok
DeclTypingItem(m, UsingDecl(_)) â‡“ ok
DeclTypingItem(m, ExternBlock(_, _, _, items, _, _)) â‡“ ok â‡” Î“ âŠ¢ ExternBlock : ok âˆ§ âˆ€ it âˆˆ items. Î“ âŠ¢ it : ok
DeclTypingItem(m, StaticDecl(_, _, _, _, _, _)) â‡“ ok â‡” Î“ âŠ¢ StaticDecl : ok
DeclTypingItem(m, TypeAliasDecl(_, name, _, _, _, _, _, _)) â‡“ ok â‡” Î“ âŠ¢ FullPath(m, name) : TypeAliasOk
DeclTypingItem(m, ProcedureDecl(_, _, _, _, _, params, _, _, body, _, _) = item) â‡“ ok â‡” Î“ âŠ¢ ProcedureDecl : ok âˆ§ ProcBindCheck(m, item) â‡“ ok âˆ§ ProvBindCheck(params, body) â‡“ ok
DeclTypingItem(m, R) â‡“ ok â‡” R = RecordDecl(_, _, _, _, _, _, _, _, _, _) âˆ§ Î“ âŠ¢ R record : ok âˆ§ âˆ€ md âˆˆ Methods(R). MethodBindCheck(m, TypePath(RecordPath(R)), md) â‡“ ok âˆ§ ProvBindCheck(MethodParamsDecl(TypePath(RecordPath(R)), md), md.body) â‡“ ok
DeclTypingItem(m, E) â‡“ ok â‡” E = EnumDecl(_, _, _, _, _, _, _, _, _, _) âˆ§ Î“ âŠ¢ E enum : ok
DeclTypingItem(m, M) â‡“ ok â‡” M = ModalDecl(_, _, _, _, _, _, _, _, _, _) âˆ§ Î“ âŠ¢ M modal : ok âˆ§ âˆ€ S âˆˆ States(M), âˆ€ md âˆˆ Methods(M, S). StateMethodBindCheck(m, M, S, md) â‡“ ok âˆ§ ProvBindCheck(StateMethodParams(M, S, md), md.body) â‡“ ok âˆ§ âˆ€ tr âˆˆ Transitions(M, S). TransitionBindCheck(m, M, S, tr) â‡“ ok âˆ§ ProvBindCheck(TransitionParams(M, S, tr), tr.body) â‡“ ok
DeclTypingItem(m, Cl) â‡“ ok â‡” Cl = ClassDecl(_, _, _, _, _, _, _, _, _, _) âˆ§ Î“ âŠ¢ Cl : ok âˆ§ âˆ€ md âˆˆ ClassMethods(Cl). (md.body_opt = âŠ¥ âˆ¨ (ClassMethodBindCheck(m, Cl, md) â‡“ ok âˆ§ ProvBindCheck(ClassMethodParams(Cl, md), md.body_opt) â‡“ ok))

ParamBinds(params) = [âŸ¨x, TâŸ© | âŸ¨_, x, TâŸ© âˆˆ params]
ProcReturn(ret_opt) =
  { TypePrim("()")   if ret_opt = âŠ¥
    ret_opt          otherwise }
ReturnAnnOk(ret_opt) â‡” ret_opt â‰  âŠ¥

ExplicitReturn(BlockExpr(stmts, tail_opt)) â‡” tail_opt = âŠ¥ âˆ§ stmts â‰  [] âˆ§ LastStmt(stmts) = ReturnStmt(_)

VisRank(`public`) = 3    VisRank(`internal`) = 2    VisRank(`private`) = 1    VisRank(`protected`) = 1
FieldVisOk(R) â‡” âˆ€ f âˆˆ Fields(R). VisRank(f.vis) â‰¤ VisRank(R.vis)
StateMemberVisOk(M) â‡” âˆ€ S âˆˆ States(M), âˆ€ m âˆˆ Payload(M, S) âˆª Methods(M, S) âˆª Transitions(M, S). VisRank(m.vis) â‰¤ VisRank(M.vis)

**(WF-ProcedureDecl)**
item = ProcedureDecl(_, vis, _, gen_params_opt, where_clause_opt, params, ret_opt, _, body, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    Distinct(ParamNames(params))    ReturnAnnOk(ret_opt)    R = ProcReturn(ret_opt)    R_b = BodyReturnType(R)    âˆ€ âŸ¨_, x_i, T_iâŸ© âˆˆ params, Î“_g âŠ¢ T_i wf    Î“_0 = PushScope(Î“_g)    IntroAll(Î“_0, ParamBinds(params)) â‡“ Î“_1    Î“_1; R; âŠ¥ âŠ¢ body : T_b    Î“_g âŠ¢ T_b <: R_b    (ExportAttr(item) undefined âˆ¨ Î“ âŠ¢ ExportSigOk(item) â‡“ ok)    (R_b â‰  TypePrim("()") â‡’ ExplicitReturn(body))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ProcedureDecl : ok

**(WF-ProcedureDecl-MissingReturnType)**
item = ProcedureDecl(_, _, _, _, _, _, ret_opt, _, _, _, _)    Â¬ ReturnAnnOk(ret_opt)    c = Code(WF-ProcedureDecl-MissingReturnType)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(WF-ProcBody-ExplicitReturn-Err)**
item = ProcedureDecl(_, _, _, _, _, _, ret_opt, _, body, _, _)    R = ProcReturn(ret_opt)    R_b = BodyReturnType(R)    R_b â‰  TypePrim("()")    Â¬ ExplicitReturn(body)    c = Code(WF-ProcBody-ExplicitReturn-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(WF-ExternProcDecl)**
item = ExternProcDecl(_, _, _, gen_params_opt, where_clause_opt, params, ret_opt, _, _, _, _)    gen_params_opt = âŠ¥    params_gen = []    Î“_g = Î“    Î“_g; params_gen âŠ¢ where_clause_opt wf    Distinct(ParamNames(params))    ReturnAnnOk(ret_opt)    R = ProcReturn(ret_opt)    âˆ€ âŸ¨_, x_i, T_iâŸ© âˆˆ params, Î“_g âŠ¢ T_i wf    Î“_g âŠ¢ R wf    ExternSigOk(params, ret_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExternProcDecl : ok

**(WF-ExternProcDecl-MissingReturnType)**
item = ExternProcDecl(_, _, _, _, _, _, ret_opt, _, _, _, _)    Â¬ ReturnAnnOk(ret_opt)    c = Code(WF-ExternProcDecl-MissingReturnType)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(ExternProc-Generic-Err)**
item = ExternProcDecl(_, _, _, gen_params_opt, _, _, _, _, _, _, _)    gen_params_opt â‰  âŠ¥    c = Code(ExternProc-Generic-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(ExternProc-ByValue-Err)**
item = ExternProcDecl(_, _, _, _, _, params, ret_opt, _, _, _, _)    R = ProcReturn(ret_opt)    (âˆƒ T âˆˆ ExternParamTypes(params). Â¬ FfiByValueOk(T) âˆ¨ Â¬ FfiByValueOk(R))    c = Code(FfiByValue-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(WF-ExternBlock)**
item = ExternBlock(_, _, abi_opt, _, _, _)    ExternAbiOk(abi_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExternBlock : ok

**(ExternAbi-Unknown-Err)**
item = ExternBlock(_, _, abi_opt, _, _, _)    Â¬ ExternAbiOk(abi_opt)    c = Code(ExternAbi-Unknown-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(Export-Vis-Err)**
item = ProcedureDecl(_, vis, _, _, _, _, _, _, _, _, _)    ExportAttr(item) defined    vis â‰  `public`    c = Code(Export-Vis-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(ExportAbi-Unknown-Err)**
item = ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _)    ExportAttr(item) = âŸ¨abi, _âŸ©    abi âˆ‰ ExternAbiSet    c = Code(ExternAbi-Unknown-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(Export-Return-NotZeroable-Err)**
item = ProcedureDecl(_, _, _, _, _, _, ret_opt, _, _, _, _)    ExportAttr(item) defined    UnwindMode(item) = "catch"    R = ProcReturn(ret_opt)    Â¬ ZeroableType(R)    c = Code(Export-Return-NotZeroable-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(Export-ByValue-Err)**
item = ProcedureDecl(_, _, _, _, _, params, ret_opt, _, _, _, _)    ExportAttr(item) defined    R = ProcReturn(ret_opt)    (âˆƒ T âˆˆ ExportParamTypes(params). Â¬ FfiByValueOk(T) âˆ¨ Â¬ FfiByValueOk(R))    c = Code(FfiByValue-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

StaticVisOk(vis, mut) â‡” Â¬ (vis = `public` âˆ§ mut = `var`)

**(WF-StaticDecl)**
binding = âŸ¨pat, ty_opt, op, init, _âŸ©    StaticVisOk(vis, mut)    ty_opt = T_a    Î“; âŠ¥; âŠ¥ âŠ¢ init â‡ T_a âŠ£ âˆ…    Î“ âŠ¢ pat â‡ T_a âŠ£ B    Distinct(PatNames(pat))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StaticDecl : ok

**(WF-StaticDecl-Ann-Mismatch)**
item = StaticDecl(_, vis, mut, âŸ¨pat, ty_opt, op, init, _âŸ©, _, _)    ty_opt = T_a    Î“; âŠ¥; âŠ¥ âŠ¢ init â‡’ T_i âŠ£ C    Solve(C) â‡“ Î¸    Â¬(Î“ âŠ¢ Î¸(T_i) <: T_a)    c = Code(WF-StaticDecl-Ann-Mismatch)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(WF-StaticDecl-MissingType)**
item = StaticDecl(_, _, _, âŸ¨pat, ty_opt, op, init, _âŸ©, _, _)    ty_opt = âŠ¥    c = Code(WF-StaticDecl-MissingType)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(StaticVisOk-Err)**
item = StaticDecl(_, vis, mut, _, _, _)    Â¬ StaticVisOk(vis, mut)    c = Code(StaticVisOk-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ item â‡‘ c

**(WF-RecordDecl)**
R = RecordDecl(_, _, _, gen_params_opt, where_clause_opt, _, _, _, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    âˆ€ f âˆˆ Fields(R), Î“_g âŠ¢ f.type wf    FieldVisOk(R)    Î“_g âŠ¢ R record wf    Î“_g âŠ¢ Methods(R) : ok    Î“_g âŠ¢ TypePath(RecordPath(R)) : ImplementsOk
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ R record : ok

**(FieldVisOk-Err)**
R = RecordDecl(_, _, _, _, _, _, _, _, _, _)    Â¬ FieldVisOk(R)    c = Code(FieldVisOk-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ R â‡‘ c

EnumPathOf(E) = [E.name]    if E.name âˆˆ BuiltinEnum
EnumPathOf(E) = FullPath(ModuleOf(E), E.name)    otherwise

**Enum Variant Visibility.**

VariantVis(E, v) = Vis(E)
VariantVisible(m, E, v) â‡” Î“ âŠ¢ CanAccess(m, E) â‡“ ok

**(WF-EnumDecl)**
E = EnumDecl(_, _, _, gen_params_opt, where_clause_opt, _, variants, _, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    variants â‰  []    Distinct([v.name | v âˆˆ variants])    âˆ€ v âˆˆ variants, Î“_g âŠ¢ v.payload_opt wf    EnumDiscriminants(E) â‡“ _    Î“_g âŠ¢ TypePath(EnumPathOf(E)) : ImplementsOk
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ E enum : ok

PayloadOptWF(âŠ¥)
PayloadOptWF(TuplePayload([T_1, â€¦, T_n])) â‡” âˆ€ i. Î“ âŠ¢ T_i wf
PayloadOptWF(RecordPayload([âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_k, T_kâŸ©])) â‡” Distinct([f_1, â€¦, f_k]) âˆ§ âˆ€ i. Î“ âŠ¢ T_i wf

Î“ âŠ¢ payload_opt wf â‡” PayloadOptWF(payload_opt)

ModalPath(M) = [M.name]    if M.name âˆˆ BuiltinModal
ModalPath(M) = FullPath(ModuleOf(M), M.name)    otherwise

**(WF-ModalDecl)**
M = ModalDecl(_, _, _, gen_params_opt, where_clause_opt, _, _, _, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    p = ModalPath(M)    Î“_g âŠ¢ `modal` M wf    StateMemberVisOk(M)    Î“_g âŠ¢ TypePath(p) : ImplementsOk    âˆ€ S âˆˆ States(M), âˆ€ md âˆˆ Methods(M, S), Î“_g âŠ¢ md : StateMethodOK(M, S)    Î“_g âŠ¢ md : StateMethodBodyOK(p, S)    âˆ€ tr âˆˆ Transitions(M, S), Î“_g âŠ¢ tr : TransitionOK(M, S)    Î“_g âŠ¢ tr : TransitionBodyOK(p, S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ M modal : ok

**(StateMemberVisOk-Err)**
M = ModalDecl(_, _, _, _, _, _, _, _, _, _)    Â¬ StateMemberVisOk(M)    c = Code(StateMemberVisOk-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ M â‡‘ c

**(WF-ClassDecl)**
Cl = ClassDecl(_, _, _, _, gen_params_opt, where_clause_opt, _, _, _, _)    params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_g = BindTypeParams(Î“, params_gen)    Î“_g; params_gen âŠ¢ where_clause_opt wf    Î“_g âŠ¢ Cl : ClassOk
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl : ok

**Program Entry Point (Cursive0).**

MainDecls(P) = [ d | m âˆˆ P.modules, d âˆˆ ASTModule(P, m).items, d = ProcedureDecl(_, vis, name, _, _, params, ret_opt, _, body, span, doc), name = `main` ]

TypeParams(ProcedureDecl(_, _, _, gen_params_opt, _, _, _, _, _, _, _)) = (gen_params_opt if gen_params_opt â‰  âŠ¥ else [])
MainGeneric(d) â‡” TypeParams(d) â‰  []

MainSigOk(d) â‡” d = ProcedureDecl(_, vis, `main`, _, _, params, ret_opt, _, _, _, _) âˆ§ vis = `public` âˆ§ params = [âŸ¨mode, name, tyâŸ©] âˆ§ mode âˆˆ {âŠ¥, `move`} âˆ§ ty = TypePath([`Context`]) âˆ§ BuiltInContext(TypePath([`Context`])) âˆ§ ret_opt = TypePrim("i32")
MainConsumesContext(d) â‡” MainSigOk(d) âˆ§ âˆƒ mode. d.params = [âŸ¨mode, _, _âŸ©] âˆ§ mode = `move`
MainRetainsContext(d) â‡” MainSigOk(d) âˆ§ âˆƒ mode. d.params = [âŸ¨mode, _, _âŸ©] âˆ§ mode = âŠ¥

MainCheck : Project â‡€ ok

**(Main-Ok)**
Executable(P)    MainDecls(P) = [d]    Â¬ MainGeneric(d)    MainSigOk(d)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡“ ok

**(Main-Bypass-Lib)**
Â¬ Executable(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡“ ok

**(Main-Multiple)**
Executable(P)    |MainDecls(P)| > 1    c = Code(Main-Multiple)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡‘ c

**(Main-Generic-Err)**
Executable(P)    MainDecls(P) = [d]    MainGeneric(d)    c = Code(Main-Generic-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡‘ c

**(Main-Signature-Err)**
Executable(P)    MainDecls(P) = [d]    Â¬ MainSigOk(d)    c = Code(Main-Signature-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡‘ c

**(Main-Missing)**
Executable(P)    MainDecls(P) = []    c = Code(Main-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MainCheck(P) â‡‘ c

MainDiagRefs = {"8.2"}

Phase3Checks(P, Ms) = [Î“ âŠ¢ ResolveModules(P) â‡“ Ms, Î“ âŠ¢ DeclTyping(Ms) â‡“ ok, Î“ âŠ¢ MainCheck(P) â‡“ ok]
Phase3Order(P) â‡” âˆƒ Ms. FirstFail(Phase3Checks(P, Ms)) = âŠ¥

#### 5.2.15. Binding and Permission State (Cursive0)

**Binding State.**

BindingState ::= Valid | Moved | PartiallyMoved(F)    (F âŠ† Name)

**Binding Metadata.**

Movability ::= mov | immov
Responsibility ::= resp | alias
Mutability = {`let`, `var`}
BindInfo ::= âŸ¨state, mov, mut, respâŸ©    (mut âˆˆ Mutability)

**Binding Environment.**

BindScope = Map(Identifier, BindInfo)
ð”… = [BindScope]

PushScope_B(ð”…) = [âˆ…] ++ ð”…
PopScope_B([_] ++ ð”…) = ð”…

Lookup_B([Ïƒ] ++ ð”…', x) =
  { Ïƒ[x]                if x âˆˆ dom(Ïƒ)
    Lookup_B(ð”…', x)     otherwise }
Lookup_B([], x) = âŠ¥

Update_B([Ïƒ] ++ ð”…', x, info) =
  { [Ïƒ[x â†¦ info]] ++ ð”…'            if x âˆˆ dom(Ïƒ)
    [Ïƒ] ++ Update_B(ð”…', x, info)   otherwise }
Update_B([], x, info) = âŠ¥

Intro_B([Ïƒ] ++ ð”…', x, info) = [Ïƒ[x â†¦ info]] ++ ð”…'
ShadowIntro_B(ð”…, x, info) = Update_B(ð”…, x, info)

**Permission of a Type.**

PermOf(TypePerm(p, T)) = p
PermOf(T) = `const`    if T â‰  TypePerm(_, _)

**Permission State.**

ActiveState ::= Active | Inactive

PermKey = Identifier Ã— FieldPath
PermScope = Map(PermKey, ActiveState)
Î  = [PermScope]

PushScope_Î (Î ) = [âˆ…] ++ Î 
PopScope_Î ([_] ++ Î ) = Î 

Lookup_Î ([Ïƒ] ++ Î ', k) =
  { Inactive             if k âˆˆ dom(Ïƒ) âˆ§ Ïƒ[k] = Inactive
    Lookup_Î (Î ', k)      otherwise }
Lookup_Î ([], k) = Active

Update_Î ([Ïƒ] ++ Î ', k, s) = [Ïƒ[k â†¦ s]] ++ Î '

**Join at Control-Flow Merge.**

JoinState(Moved, s) = Moved
JoinState(s, Moved) = Moved
JoinState(PartiallyMoved(F_1), PartiallyMoved(F_2)) = PartiallyMoved(F_1 âˆª F_2)
JoinState(Valid, PartiallyMoved(F)) = PartiallyMoved(F)
JoinState(PartiallyMoved(F), Valid) = PartiallyMoved(F)
JoinState(Valid, Valid) = Valid

JoinBindInfo(âŸ¨s_1, mv_1, mut_1, resp_1âŸ©, âŸ¨s_2, mv_2, mut_2, resp_2âŸ©) =
  { âŸ¨JoinState(s_1, s_2), mv_1, mut_1, resp_1âŸ©   if mv_1 = mv_2 âˆ§ mut_1 = mut_2 âˆ§ resp_1 = resp_2
    âŠ¥                                            otherwise }

JoinScope_B(B_1, B_2) =
  { { x â†¦ JoinBindInfo(B_1[x], B_2[x]) | x âˆˆ dom(B_1) }    if dom(B_1) = dom(B_2) âˆ§ âˆ€ x âˆˆ dom(B_1). JoinBindInfo(B_1[x], B_2[x]) â‰  âŠ¥
    âŠ¥                                                      otherwise }

Join_B([], []) = []
Join_B(B_1 :: ð”…_1, B_2 :: ð”…_2) =
  { JoinScope_B(B_1, B_2) :: Join_B(ð”…_1, ð”…_2)    if JoinScope_B(B_1, B_2) â‰  âŠ¥ âˆ§ Join_B(ð”…_1, ð”…_2) â‰  âŠ¥
    âŠ¥                                           otherwise }
Join_B(ð”…_1, ð”…_2) = âŠ¥    if |ð”…_1| â‰  |ð”…_2|

JoinPermState(Active, Active) = Active
JoinPermState(_, _) = Inactive    otherwise

PermAt(B, x) =
  { B[x]     if x âˆˆ dom(B)
    Active   otherwise }

JoinScope_Î (B_1, B_2) = { x â†¦ JoinPermState(PermAt(B_1, x), PermAt(B_2, x)) | x âˆˆ dom(B_1) âˆª dom(B_2) }

JoinPerm([], []) = []
JoinPerm(B_1 :: Î _1, B_2 :: Î _2) =
  { JoinScope_Î (B_1, B_2) :: JoinPerm(Î _1, Î _2)    if JoinScope_Î (B_1, B_2) â‰  âŠ¥ âˆ§ JoinPerm(Î _1, Î _2) â‰  âŠ¥
    âŠ¥                                             otherwise }
JoinPerm(Î _1, Î _2) = âŠ¥    if |Î _1| â‰  |Î _2|

**Place Roots and Field Heads.**

FieldHead(Identifier(x)) = âŠ¥
FieldHead(FieldAccess(p, f)) =
  { f                if FieldHead(p) = âŠ¥
    FieldHead(p)     otherwise }
FieldHead(TupleAccess(p, _)) = FieldHead(p)
FieldHead(IndexAccess(p, _)) = FieldHead(p)
FieldHead(Deref(p)) = âŠ¥

**Access Legality.**

AccessStateOk(Valid, p) = true
AccessStateOk(PartiallyMoved(F), p) = (FieldHead(p) = f âˆ§ f âˆ‰ F)
AccessStateOk(Moved, p) = false

AccessOk_B(ð”…, p) â‡” x = PlaceRoot(p) âˆ§ Lookup_B(ð”…, x) = âŸ¨s, _, _, _âŸ© âˆ§ AccessStateOk(s, p)

AccessOk_Î (Î , p) â‡” (PermOf(ExprType(p)) â‰  `unique`) âˆ¨ AccessPathOk(Î , p)

AccessOk(ð”…, Î , p) â‡” AccessOk_B(ð”…, p) âˆ§ AccessOk_Î (Î , p)

**Binding Introduction.**

MovOf("=") = mov
MovOf(":=") = immov

IsMoveExpr(MoveExpr(_)) = true
IsMoveExpr(_) = false    otherwise

RespOfInit(init) =
  { resp    if Â¬ IsPlace(init)
    resp    if IsMoveExpr(init)
    alias   otherwise }

**Temporary Lifetime.**

InitExpr(âŸ¨_, _, _, init, _âŸ©) = init

BindInitScope(e) = BindScope(s) â‡”
  (s = LetStmt(binding) âˆ§ InitExpr(binding) = e) âˆ¨
  (s = VarStmt(binding) âˆ§ InitExpr(binding) = e) âˆ¨
  (s = ShadowLetStmt(_, _, e)) âˆ¨
  (s = ShadowVarStmt(_, _, e))

TempScope(e) =
  { BindInitScope(e)                  if BindInitScope(e) â‰  âŠ¥
    StmtScope(EnclosingStmt(e))       otherwise }

TempValue(e) â‡” Â¬ IsPlace(e)

TempOrderList([]) = []
TempOrderList([e] ++ es) = TempOrder(e) ++ TempOrderList(es)

TempOrder(e) =
  { TempOrderList(Children_LTR(e)) ++ [e]    if TempValue(e)
    TempOrderList(Children_LTR(e))          otherwise }

TempOrderStmt(s) = TempOrderList(StmtExprs(s))

ControlExpr(ReturnStmt(e)) = e    ControlExpr(BreakStmt(e)) = e
ControlExpr(s) = âŠ¥    if s âˆ‰ {ReturnStmt(_), BreakStmt(_)}

TempStmtList(s) = [ e âˆˆ TempOrderStmt(s) | TempScope(e) = StmtScope(s) âˆ§ e â‰  ControlExpr(s) ]
TempDropOrder(s) = Rev(TempStmtList(s))

**Judgments.**

BJudgment = {Î“; ð”…; Î  âŠ¢ e â‡’ ð”…' â–· Î ', Î“; ð”…; Î  âŠ¢ s â‡’ ð”…' â–· Î '}

ExprType(e) = T â‡” Î“; R; L âŠ¢ e : T
ExprType(p) = T â‡” IsPlace(p) âˆ§ Î“; R; L âŠ¢ p :place T

BindType(âŸ¨pat, ty_opt, op, init, _âŸ©) = T â‡” ty_opt = T
BindType(âŸ¨pat, âŠ¥, op, init, _âŸ©) = Î¸(T_i) â‡” Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C âˆ§ Solve(C) â‡“ Î¸
BindType(ShadowLetStmt(_, ty_opt, init)) = T â‡” ty_opt = T
BindType(ShadowLetStmt(_, âŠ¥, init)) = Î¸(T_i) â‡” Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C âˆ§ Solve(C) â‡“ Î¸
BindType(ShadowVarStmt(_, ty_opt, init)) = T â‡” ty_opt = T
BindType(ShadowVarStmt(_, âŠ¥, init)) = Î¸(T_i) â‡” Î“; R; L âŠ¢ init â‡’ T_i âŠ£ C âˆ§ Solve(C) â‡“ Î¸

MapUnion(M_1, M_2) = { x â†¦ (M_2[x] if x âˆˆ dom(M_2) else M_1[x]) | x âˆˆ dom(M_1) âˆª dom(M_2) }

IntroAll_B([Ïƒ] ++ ð”…', B) = [MapUnion(Ïƒ, B)] ++ ð”…'

ShadowAll_B(ð”…, B) = ShadowAll_B(ð”…, Entries(B))
ShadowAll_B(ð”…, []) = ð”…
ShadowAll_B(ð”…, [âŸ¨x, infoâŸ©] ++ xs) = ShadowAll_B(ShadowIntro_B(ð”…, x, info), xs)

BindInfoMap(f, B, mv, mut) = { x â†¦ âŸ¨Valid, MovEff(mv, f(B[x])), mut, f(B[x])âŸ© | x âˆˆ dom(B) }

MovEff(mv, resp) = mv    MovEff(mv, alias) = immov

T_Region = TypeModalState([`Region`], `Active`)
RegionBindName(Î“, alias_opt) =
  { alias_opt         if alias_opt â‰  âŠ¥
    FreshRegion(Î“)    otherwise }
RegionBindMap(Î“, alias_opt) = { r â†¦ T_Region | r = RegionBindName(Î“, alias_opt) }
RegionBindInfo(Î“, alias_opt) = BindInfoMap(Î» U. resp, RegionBindMap(Î“, alias_opt), mov, `let`)
FrameBindInfo(Î“) = RegionBindInfo(Î“, âŠ¥)

Names(B) = dom(B)

JoinAll_B([]) = âŠ¥
JoinAll_B([ð”…]) = ð”…
JoinAll_B(ð”…_1 :: ð”…_2 :: rest) = JoinAll_B([Join_B(ð”…_1, ð”…_2)] ++ rest)

JoinAllPerm([]) = âŠ¥
JoinAllPerm([Î ]) = Î 
JoinAllPerm(Î _1 :: Î _2 :: rest) = JoinAllPerm([JoinPerm(Î _1, Î _2)] ++ rest)

Top([Ïƒ] ++ Î ') = Ïƒ

SetTop([Ïƒ] ++ Î ', Ïƒ') = [Ïƒ'] ++ Î '

InactivateScope(Ïƒ, K) = { x â†¦ (Inactive if x âˆˆ K else Ïƒ[x]) | x âˆˆ dom(Ïƒ) âˆª K }

Roots(Î _2, Î _1) = { k | Top(Î _2)[k] = Inactive âˆ§ Lookup_Î (Î _1, k) = Active }

ConsumeOnMove(ð”…, e) =
  { Update_B(ð”…, x, âŸ¨Moved, mv, mut, respâŸ©)    if IsMoveExpr(e) âˆ§ x = PlaceRoot(MoveInner(e)) âˆ§ Lookup_B(ð”…, x) = âŸ¨s, mv, mut, respâŸ©
    ð”…                                         otherwise }

MoveInner(MoveExpr(p)) = p

OptList(âŠ¥) = []
OptList(e) = [e]    if e â‰  âŠ¥

StmtExprs(LetStmt(âŸ¨_, _, _, init, _âŸ©)) = [init]
StmtExprs(VarStmt(âŸ¨_, _, _, init, _âŸ©)) = [init]
StmtExprs(ShadowLetStmt(_, _, init)) = [init]
StmtExprs(ShadowVarStmt(_, _, init)) = [init]
StmtExprs(AssignStmt(p, e)) = [e, p]
StmtExprs(CompoundAssignStmt(p, _, e)) = [p, e]
StmtExprs(ExprStmt(e)) = [e]
StmtExprs(ReturnStmt(e_opt)) = OptList(e_opt)
StmtExprs(BreakStmt(e_opt)) = OptList(e_opt)
StmtExprs(ContinueStmt) = []
StmtExprs(DeferStmt(_)) = []
StmtExprs(UnsafeBlockStmt(b)) = [b]
StmtExprs(RegionStmt(opts_opt, _, b)) = [RegionOptsExpr(opts_opt), b]
StmtExprs(FrameStmt(_, b)) = [b]
StmtExprs(ErrorStmt(_)) = []

StmtScope(s) = s
BindScope(s) = BlockOfStmt(s)
EnclosingStmt(e) = s â‡” e âˆˆ SubExprs(s) âˆ§ âˆ€ s' âˆˆ SubStmts(s). e âˆ‰ SubExprs(s')
BlockOfStmt(s) = b â‡” s âˆˆ BlockStmts(b) âˆ§ âˆ€ b' âˆˆ SubBlocks(b). s âˆ‰ BlockStmts(b')

BlockStmts(BlockExpr(stmts, _)) = stmts

StmtBlocks(UnsafeBlockStmt(b)) = [b]
StmtBlocks(DeferStmt(b)) = [b]
StmtBlocks(RegionStmt(_, _, b)) = [b]
StmtBlocks(FrameStmt(_, b)) = [b]
StmtBlocks(s) = []    if s âˆ‰ {UnsafeBlockStmt(_), DeferStmt(_), RegionStmt(_, _, _), FrameStmt(_, _)}

SubExprs(s) = SubExprsList(StmtExprs(s))
SubExprsList([]) = âˆ…
SubExprsList([e] ++ es) = {e} âˆª SubExprsList(Children_LTR(e)) âˆª SubExprsList(es)

SubStmts(s) = SubStmtsList(StmtBlocks(s))
SubStmtsList([]) = âˆ…
SubStmtsList([b] ++ bs) = BlockStmts(b) âˆª SubStmtsSeq(BlockStmts(b)) âˆª SubStmtsList(bs)
SubStmtsSeq([]) = âˆ…
SubStmtsSeq([s] ++ ss) = SubStmts(s) âˆª SubStmtsSeq(ss)

SubBlocks(b) = SubBlocksSeq(BlockStmts(b))
SubBlocksSeq([]) = âˆ…
SubBlocksSeq([s] ++ ss) = StmtBlocks(s) âˆª (â‹ƒ_{b' âˆˆ StmtBlocks(s)} SubBlocks(b')) âˆª SubBlocksSeq(ss)

Entries(B) = [âŸ¨x_1, B[x_1]âŸ©, â€¦, âŸ¨x_n, B[x_n]âŸ©] â‡” [x_1, â€¦, x_n] enumerates dom(B) without repetition

SynthParams([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©]) = [âŸ¨m_1, âŠ¥, T_1âŸ©, â€¦, âŸ¨m_n, âŠ¥, T_nâŸ©]

CalleeProc(Identifier(x)) = proc â‡” Î“ âŠ¢ ResolveValueName(x) â‡“ ent âˆ§ ent.origin_opt = mp âˆ§ name = (ent.target_opt if present, else x) âˆ§ DeclOf(mp, name) = proc âˆ§ (proc = ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ¨ proc = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _))
CalleeProc(Path(path, name)) = proc â‡” Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent âˆ§ ent.origin_opt = mp âˆ§ name' = (ent.target_opt if present, else name) âˆ§ DeclOf(mp, name') = proc âˆ§ (proc = ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ¨ proc = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _))

Params(Call(callee, args)) =
  { proc.params            if CalleeProc(callee) = proc
    SynthParams(params)    if ExprType(callee) = TypeFunc(params, _)
    âŠ¥                      otherwise }

MethodOf(base, name) = md â‡” StripPerm(ExprType(base)) = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ LookupStateMethod(M, S, name) = md
MethodOf(base, name) = tr â‡” StripPerm(ExprType(base)) = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ LookupTransition(M, S, name) = tr
MethodOf(base, name) = m â‡” LookupMethod(StripPerm(ExprType(base)), name) = m
RecvBase(base, name) = T â‡” MethodOf(base, name) = m âˆ§ T = StripPerm(ExprType(base))

RecvParams(base, name) = StateMethodParams(M, S, md) â‡” StripPerm(ExprType(base)) = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ LookupStateMethod(M, S, name) = md
RecvParams(base, name) = TransitionParams(M, S, tr) â‡” StripPerm(ExprType(base)) = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ LookupTransition(M, S, name) = tr
RecvParams(base, name) = [âŸ¨RecvMode(m.receiver), `self`, RecvType(T, m.receiver)âŸ©] ++ m.params â‡” MethodOf(base, name) = m âˆ§ RecvBase(base, name) = T âˆ§ (m = MethodDecl(_, _, _, _, _, _, _, _, _, _, _, _) âˆ¨ m = ClassMethodDecl(_, _, _, _, _, _, _, _, _, _, _))

**Static Binding Maps (Module Scope).**

StaticBindTypesMod(P, m) = ++_{item âˆˆ ASTModule(P, m).items, item = StaticDecl(_, _, _, binding, _, _)} StaticBindTypes(binding)

StaticBindInfo(item) = BindInfoMap(Î» U. RespOfInit(init), StaticBindTypes(binding), MovOf(op), mut) â‡” item = StaticDecl(_, _, mut, binding, _, _) âˆ§ binding = âŸ¨_, _, op, init, _âŸ©

StaticBindMap(P, m) = ++_{item âˆˆ ASTModule(P, m).items, item = StaticDecl(_, _, _, _, _, _)} StaticBindInfo(item)

**Procedure Entry.**

ð”…_global = IntroAll_B(PushScope_B(ð”…), StaticBindMap(Project(Î“), m))
ð”…_proc = IntroAll_B(PushScope_B(ð”…_global), ParamBindMap(params))

ParamBindMap([]) = âˆ…
ParamBindMap([âŸ¨mode, x, TâŸ©] ++ ps) = MapUnion(ParamBindMap(ps), { x â†¦ âŸ¨Valid, ParamMov(mode), `let`, ParamResp(mode)âŸ© })
MethodParamBindMap(base, name) = ParamBindMap(RecvParams(base, name))

ParamTypeMap([]) = âˆ…
ParamTypeMap([âŸ¨mode, x, TâŸ©] ++ ps) = MapUnion(ParamTypeMap(ps), { x â†¦ T })

ParamMov(`move`) = mov    ParamMov(âŠ¥) = immov
ParamResp(`move`) = resp    ParamResp(âŠ¥) = alias

B_params = ParamTypeMap(params)
B_static = StaticBindTypesMod(Project(Î“), m)
Î _global = [{ x â†¦ Active | (x:T) âˆˆ B_static âˆ§ PermOf(T) = `unique` }]
Î _proc = [{ x â†¦ Active | (x:T) âˆˆ B_params âˆ§ PermOf(T) = `unique` }] ++ Î _global

**Expression Rules (Selected).**

**(B-Place)**
IsPlace(p)    AccessOk(ð”…, Î , p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ p â‡’ ð”… â–· Î 

**(B-Place-Unique-Err)**
IsPlace(p)    Î“; R; L âŠ¢ p : T_p    PermOf(T_p) = `unique`    Â¬ AccessPathOk(Î , p)    c = Code(B-Place-Unique-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ p â‡‘ c

**(B-Place-Moved-Err)**
IsPlace(p)    Î“; R; L âŠ¢ p : T_p    x = PlaceRoot(p)    Lookup_B(ð”…, x) = âŸ¨s, _, _, _âŸ©    (s = Moved âˆ¨ (s = PartiallyMoved(F) âˆ§ (FieldHead(p) = âŠ¥ âˆ¨ FieldHead(p) âˆˆ F)))    (PermOf(T_p) â‰  `unique` âˆ¨ AccessPathOk(Î , p))    c = Code(B-Place-Moved-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ p â‡‘ c

**(B-Move-Whole)**
IsPlace(p)    x = PlaceRoot(p)    FieldHead(p) = âŠ¥    Lookup_B(ð”…, x) = âŸ¨Valid, mv, m, râŸ©    mv = mov
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡’ Update_B(ð”…, x, âŸ¨Moved, mov, m, râŸ©) â–· Î 

**(B-Move-Field)**
IsPlace(p)    x = PlaceRoot(p)    FieldHead(p) = f    Î“; R; L âŠ¢ p : T_p    PermOf(T_p) = `unique`    Lookup_B(ð”…, x) = âŸ¨s, mv, m, râŸ©    mv = mov
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡’ Update_B(ð”…, x, âŸ¨PM(s, f), mov, m, râŸ©) â–· Î 

PM(Valid, f) = PartiallyMoved({f})
PM(PartiallyMoved(F), f) = PartiallyMoved(F âˆª {f})
PM(Moved, f) = âŠ¥

**(B-Move-Whole-Moved-Err)**
IsPlace(p)    FieldHead(p) = âŠ¥    x = PlaceRoot(p)    Lookup_B(ð”…, x) = âŸ¨s, mv, _, _âŸ©    s â‰  Valid    mv = mov    c = Code(B-Move-Whole-Moved-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

**(B-Move-Field-Moved-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Î“; R; L âŠ¢ p : T_p    PermOf(T_p) = `unique`    Lookup_B(ð”…, x) = âŸ¨s, mv, _, _âŸ©    (s = Moved âˆ¨ (s = PartiallyMoved(F) âˆ§ f âˆˆ F))    mv = mov    c = Code(B-Move-Field-Moved-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

**(B-Move-Field-NonUnique-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Î“; R; L âŠ¢ p : T_p    PermOf(T_p) â‰  `unique`    Lookup_B(ð”…, x) = âŸ¨_, mv, _, _âŸ©    mv = mov    c = Code(B-Move-Field-NonUnique-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

**(B-Move-Whole-Immovable-Err)**
IsPlace(p)    FieldHead(p) = âŠ¥    x = PlaceRoot(p)    Lookup_B(ð”…, x) = âŸ¨_, mv, _, _âŸ©    mv = immov    c = Code(B-Move-Whole-Immovable-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

**(B-Move-Field-Immovable-Err)**
IsPlace(p)    FieldHead(p) = f    x = PlaceRoot(p)    Lookup_B(ð”…, x) = âŸ¨_, mv, _, _âŸ©    mv = immov    c = Code(B-Move-Field-Immovable-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

BExprRules = {B-Place, B-Move-Whole, B-Move-Field, B-Call, B-MethodCall, B-Transition, B-Expr-Sub}

NoSpecificBExpr(e) â‡” Â¬ âˆƒ r âˆˆ BExprRules \ {B-Expr-Sub}. PremisesHold(r, e)

**(B-Expr-Sub)**
NoSpecificBExpr(e)    Children_LTR(e) = [e_1, â€¦, e_n]    Î“; ð”…_0; Î _0 âŠ¢ e_1 â‡’ ð”…_1 â–· Î _1  â€¦  Î“; ð”…_{n-1}; Î _{n-1} âŠ¢ e_n â‡’ ð”…_n â–· Î _n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…_0; Î _0 âŠ¢ e â‡’ ð”…_n â–· Î _n

**Call and Method Argument Passing.**

**Field-Path Permission Tracking.**

FieldPath = [Name]

FieldPathOf(Identifier(x)) = []
FieldPathOf(FieldAccess(p, f)) = FieldPathOf(p) ++ [f]
FieldPathOf(TupleAccess(p, _)) = FieldPathOf(p)
FieldPathOf(IndexAccess(p, _)) = FieldPathOf(p)
FieldPathOf(Deref(p)) = []

PlacePath(p) =
  { (PlaceRoot(p), [])            if p = Identifier(x)
    (PlaceRoot(p), FieldPathOf(p))    otherwise }

Prefixes([]) = [[]]
Prefixes([f] ++ fs) = [[]] âˆª { [f] ++ p | p âˆˆ Prefixes(fs) }
AncPaths(p) = { (PlaceRoot(p), fp) | fp âˆˆ Prefixes(FieldPathOf(p)) }

AccessPathOk(Î , p) â‡” âˆ€ k âˆˆ AncPaths(p). Lookup_Î (Î , k) = Active

DowngradeUniquePath(Î , mode, p) =
  { SetTop(Î , InactivateScope(Top(Î ), AncPaths(p)))    if mode = âŠ¥ âˆ§ IsPlace(p) âˆ§ PermOf(ExprType(p)) = `unique`
    Î                                                  otherwise }

DowngradeUnique(Î , mode, e) =
  { DowngradeUniquePath(Î , mode, e)    if IsPlace(e)
    Î                                  otherwise }

DowngradeUniqueBind(Î , init, T_b) =
  { DowngradeUniquePath(Î , âŠ¥, init)    if IsPlace(init) âˆ§ PermOf(ExprType(init)) = `unique` âˆ§ PermOf(T_b) = `const`
    Î                                   otherwise }

RemoveKeys(Ïƒ, D) = { k â†¦ Ïƒ[k] | k âˆˆ dom(Ïƒ) âˆ§ k âˆ‰ D }
Reactivate([Ïƒ] ++ Î ', D) = [RemoveKeys(Ïƒ, D)] ++ Î '

ArgPassExpr(mode, moved, e) =
  { MovedArg(moved, e)    if mode = `move` âˆ§ moved = true
    e                     otherwise }

ArgPassJudg = {Î“; ð”…; Î  âŠ¢ ArgPass(params, args) â‡’ ð”…' â–· Î ', D}

**(B-ArgPass-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ArgPass([], []) â‡’ ð”… â–· Î , âˆ…

**(B-ArgPass-Move-Missing)**
params = [âŸ¨`move`, _, T_pâŸ©] ++ ps    args = [âŸ¨moved, e, _âŸ©] ++ as    moved = false    c = Code(B-ArgPass-Move-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ArgPass(params, args) â‡‘ c

**(B-ArgPass-Cons)**
Î“; ð”…; Î  âŠ¢ ArgPassExpr(mode, moved, e) â‡’ ð”…_1 â–· Î _1    (mode = âŠ¥ â‡’ IsPlace(e))    Î _2 = DowngradeUnique(Î _1, mode, e)    Î“; ð”…_1; Î _2 âŠ¢ ArgPass(ps, as) â‡’ ð”…_2 â–· Î _3, D
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ArgPass([âŸ¨mode, _, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as) â‡’ ð”…_2 â–· Î _3, D âˆª Roots(Î _2, Î _1)

**(B-Call)**
Î“; ð”…; Î  âŠ¢ f â‡’ ð”…_1 â–· Î _1    Î“; ð”…_1; Î _1 âŠ¢ ArgPass(Params(Call(f, args)), args) â‡’ ð”…_2 â–· Î _2, D    Î _3 = Reactivate(Î _2, D)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ Call(f, args) â‡’ ð”…_2 â–· Î _3

**(B-MethodCall)**
Î“; ð”…; Î  âŠ¢ base â‡’ ð”…_1 â–· Î _1    Î“; ð”…_1; Î _1 âŠ¢ ArgPass(RecvParams(base, name), args) â‡’ ð”…_2 â–· Î _2, D    Î _3 = Reactivate(Î _2, D)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MethodCall(base, name, args) â‡’ ð”…_2 â–· Î _3

**(B-Transition)**
Î“; ð”…; Î  âŠ¢ e_self â‡’ ð”…_0 â–· Î _0    x = PlaceRoot(e_self)    Lookup_B(ð”…_0, x) = âŸ¨Valid, mov, m, râŸ©    mov = mov    ð”…_1 = Update_B(ð”…_0, x, âŸ¨Moved, mov, m, râŸ©)    Î“; ð”…_1; Î _0 âŠ¢ ArgPass(tr.params, args) â‡’ ð”…_2 â–· Î _1, D
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ e_self â†  t(args) â‡’ ð”…_2 â–· Reactivate(Î _1, D)

**Statement Rules (Selected).**

**(B-Seq-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ [] â‡’ ð”… â–· Î 

**(B-Seq-Cons)**
Î“; ð”…; Î  âŠ¢ s â‡’ ð”…_1 â–· Î _1    Î“; ð”…_1; Î _1 âŠ¢ ss â‡’ ð”…_2 â–· Î _2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ s :: ss â‡’ ð”…_2 â–· Î _2

**(B-LetVar-UniqueNonMove-Err)**
T_b = BindType(âŸ¨pat, ty_opt, op, init, _âŸ©)    PermOf(T_b) = `unique`    IsPlace(init)    Â¬ IsMoveExpr(init)    c = Code(B-LetVar-UniqueNonMove-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ LetOrVarStmt(âŸ¨pat, ty_opt, op, init, _âŸ©) â‡‘ c

**(B-LetVar)**
Î“; ð”…; Î  âŠ¢ init â‡’ ð”…_1 â–· Î _1    T_b = BindType(âŸ¨pat, ty_opt, op, init, _âŸ©)    Î _2 = DowngradeUniqueBind(Î _1, init, T_b)    ð”…_2 = ConsumeOnMove(ð”…_1, init)    Î“ âŠ¢ pat â‡ T_b âŠ£ B    ð”…_3 = IntroAll_B(ð”…_2, BindInfoMap(Î» U. RespOfInit(init), B, MovOf(op), mut))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ LetOrVarStmt(âŸ¨pat, ty_opt, op, init, _âŸ©) â‡’ ð”…_3 â–· Î _2

**(B-ShadowLet-UniqueNonMove-Err)**
T_b = BindType(ShadowLetStmt(x, ty_opt, init))    PermOf(T_b) = `unique`    IsPlace(init)    Â¬ IsMoveExpr(init)    c = Code(B-ShadowLet-UniqueNonMove-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ShadowLetStmt(x, ty_opt, init) â‡‘ c

**(B-ShadowLet)**
Î“; ð”…; Î  âŠ¢ init â‡’ ð”…_1 â–· Î _1    T_b = BindType(ShadowLetStmt(x, ty_opt, init))    Î _2 = DowngradeUniqueBind(Î _1, init, T_b)    ð”…_2 = ConsumeOnMove(ð”…_1, init)    B = { x â†¦ T_b }    ð”…_3 = ShadowAll_B(ð”…_2, BindInfoMap(Î» U. RespOfInit(init), B, MovOf("="), `let`))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ShadowLetStmt(x, ty_opt, init) â‡’ ð”…_3 â–· Î _2

**(B-ShadowVar-UniqueNonMove-Err)**
T_b = BindType(ShadowVarStmt(x, ty_opt, init))    PermOf(T_b) = `unique`    IsPlace(init)    Â¬ IsMoveExpr(init)    c = Code(B-ShadowVar-UniqueNonMove-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ShadowVarStmt(x, ty_opt, init) â‡‘ c

**(B-ShadowVar)**
Î“; ð”…; Î  âŠ¢ init â‡’ ð”…_1 â–· Î _1    T_b = BindType(ShadowVarStmt(x, ty_opt, init))    Î _2 = DowngradeUniqueBind(Î _1, init, T_b)    ð”…_2 = ConsumeOnMove(ð”…_1, init)    B = { x â†¦ T_b }    ð”…_3 = ShadowAll_B(ð”…_2, BindInfoMap(Î» U. RespOfInit(init), B, MovOf("="), `var`))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ShadowVarStmt(x, ty_opt, init) â‡’ ð”…_3 â–· Î _2

**(B-ExprStmt)**
Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ExprStmt(e) â‡’ ð”…_1 â–· Î _1

**(B-UnsafeStmt)**
Î“; ð”…; Î  âŠ¢ b â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ UnsafeBlockStmt(b) â‡’ ð”…_1 â–· Î _1

**(B-Defer)**
Î“; ð”…; Î  âŠ¢ b â‡’ ð”…_1 â–· Î _1    ð”…_1 = ð”…    Î _1 = Î 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ DeferStmt(b) â‡’ ð”… â–· Î 

**(B-RegionStmt)**
(opts_opt = âŠ¥ â‡’ ð”…_0 = ð”… âˆ§ Î _0 = Î ) âˆ§ (opts_opt = e â‡’ Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_0 â–· Î _0)    ð”…_1 = PushScope_B(ð”…_0)    Î _1 = PushScope_Î (Î _0)    ð”…_2 = IntroAll_B(ð”…_1, RegionBindInfo(Î“, alias_opt))    Î“; ð”…_2; Î _1 âŠ¢ b â‡’ ð”…_3 â–· Î _2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ RegionStmt(opts_opt, alias_opt, b) â‡’ PopScope_B(ð”…_3) â–· PopScope_Î (Î _2)

**(B-FrameStmt)**
ð”…_1 = PushScope_B(ð”…)    Î _1 = PushScope_Î (Î )    ð”…_2 = IntroAll_B(ð”…_1, FrameBindInfo(Î“))    Î“; ð”…_2; Î _1 âŠ¢ b â‡’ ð”…_3 â–· Î _2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ FrameStmt(r_opt, b) â‡’ PopScope_B(ð”…_3) â–· PopScope_Î (Î _2)

**(B-Assign-Immutable-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    IsPlace(p)    PlaceRoot(p) = x    Lookup_B(ð”…, x) = âŸ¨_, _, `let`, _âŸ©    c = Code(B-Assign-Immutable-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ stmt â‡‘ c

**(B-Assign)**
IsPlace(p)    PlaceRoot(p) = x    Lookup_B(ð”…, x) = âŸ¨s, mov, `var`, râŸ©    Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ AssignStmt(p, e) â‡’ Update_B(ð”…_1, x, âŸ¨Valid, mov, `var`, râŸ©) â–· Î _1

**(B-Assign-Const-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, op, e)}    Î“; R; L âŠ¢ p : TypePerm(`const`, T)    c = Code(B-Assign-Const-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ stmt â‡‘ c

**(B-If)**
Î“; ð”…; Î  âŠ¢ c â‡’ ð”…_c â–· Î _c    Î“; ð”…_c; Î _c âŠ¢ b_t â‡’ ð”…_t â–· Î _t    Î“; ð”…_c; Î _c âŠ¢ b_f â‡’ ð”…_f â–· Î _f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ IfExpr(c, b_t, b_f) â‡’ Join_B(ð”…_t, ð”…_f) â–· JoinPerm(Î _t, Î _f)

**(B-Match)**
Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_0 â–· Î _0    Î“; R; L âŠ¢ e : T    moved = IsMoveExpr(e)    ð”…_1 = ConsumeOnMove(ð”…_0, e)    âˆ€ i, Î“; PushScope_B(ð”…_1); PushScope_Î (Î _0) âŠ¢ Arm(moved, p_i, g_i, b_i) â‡’ ð”…_i â–· Î _i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MatchExpr(e, arms) â‡’ JoinAll_B([ð”…_i]) â–· JoinAllPerm([Î _i])

RespOfScrutinee(true) = resp
RespOfScrutinee(false) = alias

**(B-Arm)**
Î“ âŠ¢ p â‡‘ T âŠ£ B    ð”…_0 = IntroAll_B(ð”…, BindInfoMap(Î» U. RespOfScrutinee(moved), B, mov, `let`))    (g â‰  âŠ¥ â‡’ Î“; ð”…_0; Î  âŠ¢ g â‡’ ð”…_1 â–· Î _1)    (g = âŠ¥ â‡’ ð”…_1 = ð”…_0 âˆ§ Î _1 = Î )    Î“; ð”…_1; Î _1 âŠ¢ b â‡’ ð”…_2 â–· Î _2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ Arm(moved, p, g, b) â‡’ ð”…_2 â–· Î _2


**(B-Block)**
Î“; PushScope_B(ð”…); PushScope_Î (Î ) âŠ¢ stmts â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ BlockExpr(stmts, tail_opt) â‡’ PopScope_B(ð”…_1) â–· PopScope_Î (Î _1)

**Loop Fixpoint.**

Moved <_B PartiallyMoved(F) <_B Valid
PartiallyMoved(F_1) <_B PartiallyMoved(F_2) â‡” F_1 âŠ‡ F_2
x â‰¤_B y â‡” x <_B y âˆ¨ x = y
Active <_Î  Inactive
x â‰¤_Î  y â‡” x <_Î  y âˆ¨ x = y
ð”…_1 â‰¤ ð”…_2 â‡” âˆ€ i. ð”…_1[i] â‰¤_B ð”…_2[i]
Î _1 â‰¤_Î  Î _2 â‡” âˆ€ i. Î _1[i] â‰¤_Î  Î _2[i]

LoopStep : (ð”…, Î ) â†’ (ð”…, Î )
F(ð”…, Î ) = (Join_B(ð”…_0, ð”…'), JoinPerm(Î _0, Î ')) where (ð”…', Î ') = LoopStep(ð”…, Î )
(ð”…_0, Î _0) = (ð”…_init, Î _init)
(ð”…_{k+1}, Î _{k+1}) = F(ð”…_k, Î _k)
n = min{ k | (ð”…_k, Î _k) = (ð”…_{k+1}, Î _{k+1}) }
LoopFix(ð”…_init, Î _init, LoopStep) = (ð”…_n, Î _n)

**(B-Loop-Infinite)**
LoopStep(ð”…, Î ) = (ð”…_b, Î _b) where Î“; ð”…; Î  âŠ¢ body â‡’ ð”…_b â–· Î _b    (ð”…', Î ') = LoopFix(ð”…, Î , LoopStep)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ LoopInfinite(body) â‡’ ð”…' â–· Î '

**(B-Loop-Conditional)**
LoopStep(ð”…, Î ) = (ð”…_b, Î _b) where Î“; ð”…; Î  âŠ¢ cond â‡’ ð”…_c â–· Î _c âˆ§ Î“; ð”…_c; Î _c âŠ¢ body â‡’ ð”…_b â–· Î _b    (ð”…', Î ') = LoopFix(ð”…, Î , LoopStep)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ LoopConditional(cond, body) â‡’ ð”…' â–· Î '

**(B-Loop-Iter)**
Î“; ð”…; Î  âŠ¢ iter â‡’ ð”…_0 â–· Î _0    Î“ âŠ¢ pat â‡ T_p âŠ£ B    LoopStep(ð”…, Î ) = (ð”…_b, Î _b) where ð”…_1 = PushScope_B(ð”…) âˆ§ ð”…_2 = IntroAll_B(ð”…_1, BindInfoMap(Î» U. resp, B, mov, `let`)) âˆ§ Î _1 = PushScope_Î (Î ) âˆ§ Î“; ð”…_2; Î _1 âŠ¢ body â‡’ ð”…_3 â–· Î _2 âˆ§ ð”…_b = PopScope_B(ð”…_3) âˆ§ Î _b = PopScope_Î (Î _2)    (ð”…', Î ') = LoopFix(ð”…_0, Î _0, LoopStep)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ LoopIter(pat, ty_opt, iter, body) â‡’ ð”…' â–· Î '

**(B-Return)**
Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ReturnStmt(e) â‡’ ð”…_1 â–· Î _1

**(B-Return-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ReturnStmt(âŠ¥) â‡’ ð”… â–· Î 

**(B-Break)**
Î“; ð”…; Î  âŠ¢ e â‡’ ð”…_1 â–· Î _1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ BreakStmt(e) â‡’ ð”…_1 â–· Î _1

**(B-Break-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ BreakStmt(âŠ¥) â‡’ ð”… â–· Î 

**(B-Continue)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ ContinueStmt â‡’ ð”… â–· Î 

**(B-Move-Unique-Err)**
IsPlace(p)    Î“; R; L âŠ¢ p : T_p    PermOf(T_p) = `unique`    Â¬ AccessPathOk(Î , p)    c = Code(B-Place-Unique-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; ð”…; Î  âŠ¢ MoveExpr(p) â‡‘ c

**Procedure/Method Binding-Check.**

Init_B(m, params) = IntroAll_B(PushScope_B(IntroAll_B(PushScope_B([]), StaticBindMap(Project(Î“), m))), ParamBindMap(params))
Init_Î (m, params) = [{ x â†¦ Active | (x:T) âˆˆ ParamTypeMap(params) âˆ§ PermOf(T) = `unique` }] ++ [{ x â†¦ Active | (x:T) âˆˆ StaticBindTypesMod(Project(Î“), m) âˆ§ PermOf(T) = `unique` }]

BindCheck(m, params, body) â‡“ ok â‡” Î“; Init_B(m, params); Init_Î (m, params) âŠ¢ body â‡’ ð”…' â–· Î '

ProcBindCheck(m, ProcedureDecl(_, _, _, _, _, params, _, _, body, _, _)) â‡“ ok â‡” BindCheck(m, params, body) â‡“ ok

MethodParamsDecl(T, m) = [âŸ¨RecvMode(m.receiver), `self`, RecvType(T, m.receiver)âŸ©] ++ m.params
MethodBindCheck(m, T, md) â‡“ ok â‡” md.body = body âˆ§ BindCheck(m, MethodParamsDecl(T, md), body) â‡“ ok
ClassMethodBindCheck(m, Cl, md) â‡“ ok â‡” md.body_opt = body âˆ§ BindCheck(m, ClassMethodParams(Cl, md), body) â‡“ ok
StateMethodBindCheck(m, M, S, md) â‡“ ok â‡” md.body = body âˆ§ BindCheck(m, StateMethodParams(M, S, md), body) â‡“ ok
TransitionBindCheck(m, M, S, tr) â‡“ ok â‡” tr.body = body âˆ§ BindCheck(m, TransitionParams(M, S, tr), body) â‡“ ok

BindDiagRefs = {"8.2", "8.7", "8.10"}

#### 5.2.16. Safe Pointer Types (Cursive0)

PtrState = {`Valid`, `Null`, `Expired`}

Ptr<T> = TypePtr(T, âŠ¥)
Ptr<T>@s = TypePtr(T, s)    (s â‰  âŠ¥)

**Static Semantics**

BitcopyType(TypePtr(T, s))
CloneType(TypePtr(T, s))
Â¬ DropType(TypePtr(T, s))

sizeof(`Ptr<T>`) = sizeof(`usize`)    alignof(`Ptr<T>`) = alignof(`usize`)
PtrDiagRefs = {"8.10"}

#### 5.2.17. Regions, Frames, and Provenance (Cursive0)

**Built-in Record Type `RegionOptions`.**

RegionOptionsFields = [
  âŸ¨âŠ¥, `public`, false, `stack_size`, TypePrim("usize"), Literal(IntLiteral(0)), âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `name`, TypeString(âŠ¥), Literal(StringLiteral("\"")), âŠ¥, âŠ¥âŸ©
]

RegionOptionsDecl = RecordDecl(âŠ¥, `public`, `RegionOptions`, âŠ¥, âŠ¥, [], RegionOptionsFields, âŠ¥, âŠ¥, âŠ¥)

Î£.Types[`RegionOptions`] = RegionOptionsDecl

RegionPrealloc(opts) = opts.stack_size
NoPrealloc(opts) â‡” RegionPrealloc(opts) = 0

**Region/Frame Helpers.**

RegionActiveType(T) â‡” StripPerm(T) = TypeModalState([`Region`], `Active`)

FreshRegion(Î“) âˆˆ Name \ dom(Î“)

RegionOptsExpr(âŠ¥) = Call(Identifier(`RegionOptions`), [])
RegionOptsExpr(e) = e    if e â‰  âŠ¥

RegionBind(Î“, alias_opt) = Î“_r â‡” r =
  { alias_opt           if alias_opt â‰  âŠ¥
    FreshRegion(Î“)      otherwise } âˆ§ IntroAll(Î“, [âŸ¨r, TypeModalState([`Region`], `Active`)âŸ©]) â‡“ Î“_r

InnermostActiveRegion([]) = âŠ¥
InnermostActiveRegion([Ïƒ] ++ Î“') =
  { r                         if âˆƒ r. r âˆˆ dom(Ïƒ) âˆ§ RegionActiveType(Ïƒ[r])
    InnermostActiveRegion(Î“')  otherwise }

FrameBind(Î“, target_opt) = Î“_f â‡” r =
  { InnermostActiveRegion(Î“)    if target_opt = âŠ¥
    target_opt                  if target_opt â‰  âŠ¥ âˆ§ Î“; R; L âŠ¢ Identifier(target_opt) : T_r âˆ§ RegionActiveType(T_r) } âˆ§ F = FreshRegion(Î“) âˆ§ IntroAll(Î“, [âŸ¨F, TypeModalState([`Region`], `Active`)âŸ©]) â‡“ Î“_f

**Region Binding Constraints.**
If alias_opt = âŠ¥, the identifier r produced by RegionBindName(Î“, alias_opt) MUST be treated as synthetic. It MUST NOT be introduced by name resolution and MUST NOT be referenced by user code.

FrameBind introduces a fresh synthetic region identifier F with the same restriction. F is used only for provenance assignment.

**Provenance Tags.**

Ï€ ::= Ï€_Global | Ï€_Stack(S) | Ï€_Heap | Ï€_Region(r) | âŠ¥

RegionNesting(r_inner, r_outer) â‡” âˆƒ Î“_1, Ïƒ_inner, Î“_2, Ïƒ_outer, Î“_3. Î“ = Î“_1 ++ [Ïƒ_inner] ++ Î“_2 ++ [Ïƒ_outer] ++ Î“_3 âˆ§ r_inner âˆˆ dom(Ïƒ_inner) âˆ§ r_outer âˆˆ dom(Ïƒ_outer)

**Lifetime Order.**

Ï€_1 < Ï€_2 â‡” (Ï€_1 = Ï€_Region(r_inner) âˆ§ Ï€_2 = Ï€_Region(r_outer) âˆ§ RegionNesting(r_inner, r_outer)) âˆ¨ (Ï€_1 = Ï€_Region(r) âˆ§ Ï€_2 = Ï€_Stack(S)) âˆ¨ (Ï€_1 = Ï€_Stack(S) âˆ§ Ï€_2 = Ï€_Heap) âˆ¨ (Ï€_1 = Ï€_Heap âˆ§ Ï€_2 = Ï€_Global) âˆ¨ (Ï€_1 = Ï€_Global âˆ§ Ï€_2 = âŠ¥)

Ï€_1 â‰¤ Ï€_2 â‡” Ï€_1 = Ï€_2 âˆ¨ (Ï€_1 < Ï€_2) âˆ¨ âˆƒ Ï€. (Ï€_1 < Ï€ âˆ§ Ï€ â‰¤ Ï€_2)

FrameTargetRel(F, r) â‡” FrameTarget(Î“, F) = r
FrameTargetRel(F, r) â‡’ Ï€_Region(F) < Ï€_Region(r)

JoinProv(Ï€_1, Ï€_2) =
  { Ï€_1    if Ï€_1 â‰¤ Ï€_2
    Ï€_2    if Ï€_2 â‰¤ Ï€_1
    âŠ¥      otherwise }

JoinAllProv([]) = âŠ¥
JoinAllProv([Ï€]) = Ï€
JoinAllProv([Ï€_1, Ï€_2] ++ ps) = JoinAllProv([JoinProv(Ï€_1, Ï€_2)] ++ ps)

**Provenance Environment.**

Î© = âŸ¨Î£_Ï€, RSâŸ©
Scope_Ï€ = âŸ¨S, MâŸ© where M : Ident â‡€ Ï€
Î£_Ï€ âˆˆ [Scope_Ï€]
RegionEntry_Ï€ = âŸ¨tag, targetâŸ©
RS âˆˆ [RegionEntry_Ï€]

ScopeId(âŸ¨S, MâŸ©) = S
ScopeMap(âŸ¨S, MâŸ©) = M
TopScopeId([âŸ¨S, MâŸ©] ++ Î£_Ï€) = S
StackProv(Î£_Ï€) = Ï€_Stack(TopScopeId(Î£_Ï€))

PushScope_Ï€(Î£_Ï€) = [âŸ¨S, âˆ…âŸ©] ++ Î£_Ï€    (S fresh)
PopScope_Ï€([_] ++ Î£_Ï€) = Î£_Ï€

Lookup_Ï€([âŸ¨S, MâŸ©] ++ Î£_Ï€, x) =
  { M[x]                if x âˆˆ dom(M)
    Lookup_Ï€(Î£_Ï€, x)     otherwise }

Intro_Ï€([âŸ¨S, MâŸ©] ++ Î£_Ï€, x, Ï€) = [âŸ¨S, M[x â†¦ Ï€]âŸ©] ++ Î£_Ï€

ShadowIntro_Ï€(Î£_Ï€, x, Ï€) =
  { [âŸ¨S, M[x â†¦ Ï€]âŸ©] ++ Î£_Ï€'                    if Î£_Ï€ = [âŸ¨S, MâŸ©] ++ Î£_Ï€' âˆ§ x âˆˆ dom(M)
    [âŸ¨S, MâŸ©] ++ ShadowIntro_Ï€(Î£_Ï€', x, Ï€)     if Î£_Ï€ = [âŸ¨S, MâŸ©] ++ Î£_Ï€' âˆ§ x âˆ‰ dom(M)
    âŠ¥                                         if Î£_Ï€ = [] }

IntroAll_Ï€(Î£_Ï€, [], Ï€) = Î£_Ï€
IntroAll_Ï€(Î£_Ï€, [x] ++ xs, Ï€) = IntroAll_Ï€(Intro_Ï€(Î£_Ï€, x, Ï€), xs, Ï€)

ShadowAll_Ï€(Î£_Ï€, [], Ï€) = Î£_Ï€
ShadowAll_Ï€(Î£_Ï€, [x] ++ xs, Ï€) = ShadowAll_Ï€(ShadowIntro_Ï€(Î£_Ï€, x, Ï€), xs, Ï€)

ParamProvMap(params, vecÏ€) = { x_i â†¦ Ï€_i | params = [âŸ¨_, x_i, _âŸ©], vecÏ€ = [Ï€_i] }
InitProvEnv(params, vecÏ€, RS) = âŸ¨[âŸ¨S, ParamProvMap(params, vecÏ€)âŸ©], RSâŸ©    (S fresh)

AllocTag([], r) = âŠ¥
AllocTag([âŸ¨tag, targetâŸ©] ++ RS, âŠ¥) = tag
AllocTag([âŸ¨tag, targetâŸ©] ++ RS, r) =
  { tag              if target = r
    AllocTag(RS, r)  otherwise }

**Provenance of Places.**

ProvPlaceJudg = {Î“; Î© âŠ¢ p â‡“ Ï€}

Lookup_Ï€(Î£_Ï€, x) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ Identifier(x) â‡“ Ï€

**(P-Field)**
Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ FieldAccess(p, f) â‡“ Ï€

**(P-Tuple)**
Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ TupleAccess(p, i) â‡“ Ï€

**(P-Index)**
Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ IndexAccess(p, i) â‡“ Ï€

**(P-Deref)**
Î“; Î© âŠ¢ e â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ Deref(e) â‡“ Ï€

**Provenance of Expressions.**

ProvExprJudg = {Î“; Î© âŠ¢ e â‡“ Ï€}

**(P-Place-Expr)**
IsPlace(p)    Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ p â‡“ Ï€

**(P-Literal)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ Literal(_) â‡“ âŠ¥

**(P-Move)**
Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ MoveExpr(p) â‡“ Ï€

**(P-AddrOf)**
Î“; Î© âŠ¢ p â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ AddressOf(p) â‡“ Ï€

**(P-Alloc)**
Î“; Î© âŠ¢ e â‡“ Ï€_e    AllocTag(RS, r_opt) = tag
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ AllocExpr(r_opt, e) â‡“ Ï€_Region(tag)

**(P-Region-Alloc-Method)**
name = `alloc`    (r : T_r) âˆˆ Î“    RegionActiveType(T_r)    AllocTag(RS, r) = tag
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ MethodCall(Identifier(r), name, args) â‡“ Ï€_Region(tag)

**(P-If)**
Î“; Î© âŠ¢ b_t â‡“ Ï€_t    Î“; Î© âŠ¢ b_f â‡“ Ï€_f    JoinProv(Ï€_t, Ï€_f) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ IfExpr(c, b_t, b_f) â‡“ Ï€

**(P-If-No-Else)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ IfExpr(_, b_t, âŠ¥) â‡“ âŠ¥

ArmBodyProv(e, Î©) = Ï€ â‡” Î“; Î© âŠ¢ e â‡“ Ï€
ArmBodyProv(b, Î©) = Ï€ â‡” Î“; Î© âŠ¢ b â‡“ Ï€

ArmEnv(âŸ¨Î£_Ï€, RSâŸ©, pat) = âŸ¨Î£_Ï€', RSâŸ© â‡” Î“ âŠ¢ PatNames(pat) â‡“ N âˆ§ Ï€_b = BindProv(âŸ¨Î£_Ï€, RSâŸ©, âŠ¥) âˆ§ Î£_Ï€' = IntroAll_Ï€(Î£_Ï€, N, Ï€_b)

ArmProv(âŸ¨pat, _, bodyâŸ©) = Ï€ â‡” ArmEnv(Î©, pat) = Î©' âˆ§ ArmBodyProv(body, Î©') = Ï€

**(P-Match)**
âˆ€ i, ArmProv(arm_i.body) = Ï€_i    JoinAllProv([Ï€_1, â€¦, Ï€_n]) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ MatchExpr(_, arms) â‡“ Ï€

FrameProv(Î“, âŸ¨Î£_Ï€, RSâŸ©) =
  { Ï€_Region(r)    if InnermostActiveRegion(Î“) = r
    StackProv(Î£_Ï€) otherwise }

AsyncCreateExpr(Call(_, _)) â‡” AsyncSig(ExprType(Call(_, _))) â‰  âŠ¥
AsyncCreateExpr(MethodCall(_, _, _)) â‡” AsyncSig(ExprType(MethodCall(_, _, _))) â‰  âŠ¥
AsyncCreateExpr(RaceExpr(_)) â‡” AsyncSig(ExprType(RaceExpr(_))) â‰  âŠ¥
AsyncCreateExpr(_) â‡” false

AsyncCaptureArgs(Call(_, args)) = [e | âŸ¨_, e, _âŸ© âˆˆ args]
AsyncCaptureArgs(MethodCall(base, _, args)) = [base] ++ [e | âŸ¨_, e, _âŸ© âˆˆ args]
AsyncCaptureArgs(RaceExpr(arms)) = [e | âŸ¨e, _, _âŸ© âˆˆ arms]
AsyncCaptureArgs(_) = []

ASYNC_LARGE_CAPTURE_THRESHOLD_BYTES = WIDEN_LARGE_PAYLOAD_THRESHOLD_BYTES
AsyncCaptureSize(args) = Î£_{e âˆˆ args} sizeof(ExprType(e))
AsyncCaptureWarnCond(e) â‡” AsyncCreateExpr(e) âˆ§ AsyncCaptureSize(AsyncCaptureArgs(e)) > ASYNC_LARGE_CAPTURE_THRESHOLD_BYTES

**(Warn-Async-LargeCapture)**
AsyncCaptureWarnCond(e)    sp = span(e)    Î“ âŠ¢ Emit(W-CON-0201, sp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WarnAsyncCapture(e) â‡“ ok

**(Warn-Async-LargeCapture-Ok)**
Â¬ AsyncCaptureWarnCond(e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WarnAsyncCapture(e) â‡“ ok

**(Async-Capture-Err)**
AsyncCreateExpr(e)    AsyncCaptureArgs(e) = args    âˆƒ e_i âˆˆ args. Î“; Î© âŠ¢ e_i â‡“ Ï€_i âˆ§ Ï€_i < FrameProv(Î“, Î©)    c = Code(E-CON-0280)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ e â‡‘ c

**(P-Async-Create)**
AsyncCreateExpr(e)    AsyncCaptureArgs(e) = args    âˆ€ e_i âˆˆ args, Î“; Î© âŠ¢ e_i â‡“ Ï€_i    âˆ€ e_i âˆˆ args, Â¬(Ï€_i < FrameProv(Î“, Î©))    Î“ âŠ¢ WarnAsyncCapture(e) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ e â‡“ FrameProv(Î“, Î©)

ProvExprRules = {P-Place-Expr, P-Literal, P-Move, P-AddrOf, P-Alloc, P-Region-Alloc-Method, P-If, P-If-No-Else, P-Match, P-Async-Create, P-Block, P-Loop-Infinite, P-Loop-Conditional, P-Loop-Iter, P-Expr-Sub}

NoSpecificProvExpr(e) â‡” Â¬ âˆƒ r âˆˆ ProvExprRules \ {P-Expr-Sub}. PremisesHold(r, e)

**(P-Expr-Sub)**
NoSpecificProvExpr(e)    Children_LTR(e) = [e_1, â€¦, e_n]    âˆ€ i, Î“; Î© âŠ¢ e_i â‡“ Ï€_i    JoinAllProv([Ï€_1, â€¦, Ï€_n]) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ e â‡“ Ï€

**Provenance of Statements.**

ProvStmtJudg = {Î“; Î© âŠ¢ s â‡’ Î©' â–· âŸ¨Res, Brk, BrkVoidâŸ©, Î“; Î© âŠ¢ ss â‡’ Î©' â–· âŸ¨Res, Brk, BrkVoidâŸ©}

LetOrVarStmt(binding) âˆˆ {LetStmt(binding), VarStmt(binding)}

**(Prov-Seq-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ [] â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-Seq-Cons)**
Î“; Î© âŠ¢ s â‡’ Î©_1 â–· âŸ¨Res_1, Brk_1, B_1âŸ©    Î“; Î©_1 âŠ¢ ss â‡’ Î©_2 â–· âŸ¨Res_2, Brk_2, B_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ s :: ss â‡’ Î©_2 â–· âŸ¨Res_1 ++ Res_2, Brk_1 ++ Brk_2, B_1 âˆ¨ B_2âŸ©

**(Prov-LetVar)**
binding = âŸ¨pat, _, _, init, _âŸ©    Î“; Î© âŠ¢ init â‡“ Ï€_init    Î“ âŠ¢ PatNames(pat) â‡“ N    Ï€_bind = BindProv(Î©, Ï€_init)    Î£_Ï€' = IntroAll_Ï€(Î£_Ï€, N, Ï€_bind)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ LetOrVarStmt(binding) â‡’ âŸ¨Î£_Ï€', RSâŸ© â–· âŸ¨[], [], falseâŸ©

**(Prov-ShadowLet)**
Î“; Î© âŠ¢ init â‡“ Ï€_init    Ï€_bind = BindProv(Î©, Ï€_init)    Î£_Ï€' = ShadowAll_Ï€(Î£_Ï€, [x], Ï€_bind)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ ShadowLetStmt(x, _, init) â‡’ âŸ¨Î£_Ï€', RSâŸ© â–· âŸ¨[], [], falseâŸ©

**(Prov-ShadowVar)**
Î“; Î© âŠ¢ init â‡“ Ï€_init    Ï€_bind = BindProv(Î©, Ï€_init)    Î£_Ï€' = ShadowAll_Ï€(Î£_Ï€, [x], Ï€_bind)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ ShadowVarStmt(x, _, init) â‡’ âŸ¨Î£_Ï€', RSâŸ© â–· âŸ¨[], [], falseâŸ©

**(Prov-Assign)**
Î“; Î© âŠ¢ p â‡“ Ï€_x    Î“; Î© âŠ¢ e â‡“ Ï€_e    Â¬(Ï€_e < Ï€_x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ AssignStmt(p, e) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-CompoundAssign)**
Î“; Î© âŠ¢ p â‡“ Ï€_x    Î“; Î© âŠ¢ e â‡“ Ï€_e    Â¬(Ï€_e < Ï€_x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ CompoundAssignStmt(p, _, e) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-Async-Escape-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, _, e)}    Î“; Î© âŠ¢ p â‡“ Ï€_x    Î“; Î© âŠ¢ e â‡“ Ï€_e    Ï€_e < Ï€_x    AsyncSig(ExprType(e)) â‰  âŠ¥    c = Code(E-CON-0281)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ stmt â‡‘ c

**(Prov-Escape-Err)**
stmt âˆˆ {AssignStmt(p, e), CompoundAssignStmt(p, _, e)}    Î“; Î© âŠ¢ p â‡“ Ï€_x    Î“; Î© âŠ¢ e â‡“ Ï€_e    Ï€_e < Ï€_x    AsyncSig(ExprType(e)) = âŠ¥    c = Code(Prov-Escape-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ stmt â‡‘ c

**(Prov-ExprStmt)**
Î“; Î© âŠ¢ e â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ ExprStmt(e) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-Return)**
Î“; Î© âŠ¢ e â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ ReturnStmt(e) â‡’ Î© â–· âŸ¨[Ï€], [], falseâŸ©

**(Prov-Return-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ ReturnStmt(âŠ¥) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-Break)**
Î“; Î© âŠ¢ e â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ BreakStmt(e) â‡’ Î© â–· âŸ¨[], [Ï€], falseâŸ©

**(Prov-Break-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ BreakStmt(âŠ¥) â‡’ Î© â–· âŸ¨[], [], trueâŸ©

**(Prov-Continue)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ ContinueStmt â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-UnsafeStmt)**
Î“; Î© âŠ¢ b â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ UnsafeBlockStmt(b) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**(Prov-DeferStmt)**
Î“; Î© âŠ¢ b â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ DeferStmt(b) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

FrameTarget(Î“, âŠ¥) = r â‡” InnermostActiveRegion(Î“) = r
FrameTarget(Î“, r) = r â‡” Î“; R; L âŠ¢ Identifier(r) : T_r âˆ§ RegionActiveType(T_r)

**(Prov-RegionStmt)**
RegionOptsExpr(opts_opt) = opts    Î“; Î© âŠ¢ opts â‡“ Ï€_opts    r = RegionBindName(Î“, alias_opt)    Î£_Ï€^0 = PushScope_Ï€(Î£_Ï€)    Ï€_r = BindProv(âŸ¨Î£_Ï€^0, RSâŸ©, âŠ¥)    Î£_Ï€' = Intro_Ï€(Î£_Ï€^0, r, Ï€_r)    RS' = âŸ¨r, râŸ© :: RS    Î“; âŸ¨Î£_Ï€', RS'âŸ© âŠ¢ b â‡“ Ï€_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ RegionStmt(opts_opt, alias_opt, b) â‡’ âŸ¨Î£_Ï€, RSâŸ© â–· âŸ¨[], [], falseâŸ©

**(Prov-FrameStmt)**
FrameTarget(Î“, target_opt) = r    F = FreshRegion(Î“)    Î£_Ï€^0 = PushScope_Ï€(Î£_Ï€)    Ï€_F = BindProv(âŸ¨Î£_Ï€^0, RSâŸ©, âŠ¥)    Î£_Ï€' = Intro_Ï€(Î£_Ï€^0, F, Ï€_F)    RS' = âŸ¨F, râŸ© :: RS    Î“; âŸ¨Î£_Ï€', RS'âŸ© âŠ¢ b â‡“ Ï€_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ FrameStmt(target_opt, b) â‡’ âŸ¨Î£_Ï€, RSâŸ© â–· âŸ¨[], [], falseâŸ©

**(Prov-ErrorStmt)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ ErrorStmt(_) â‡’ Î© â–· âŸ¨[], [], falseâŸ©

**Block Provenance.**

BlockProvJudg = {Î“; Î© âŠ¢ BlockProv(stmts, tail_opt) â‡“ Ï€}

Î©_0 = âŸ¨PushScope_Ï€(Î£_Ï€), RSâŸ©

**(BlockProv-Res)**
Î“; Î©_0 âŠ¢ stmts â‡’ Î©_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Res â‰  []    JoinAllProv(Res) = Ï€    (tail_opt = e â‡’ Î“; Î©_1 âŠ¢ e â‡“ Ï€_t)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ BlockProv(stmts, tail_opt) â‡“ Ï€

**(BlockProv-Tail)**
Î“; Î©_0 âŠ¢ stmts â‡’ Î©_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Res = []    tail_opt = e    Î“; Î©_1 âŠ¢ e â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ BlockProv(stmts, tail_opt) â‡“ Ï€

**(BlockProv-Unit)**
Î“; Î©_0 âŠ¢ stmts â‡’ Î©_1 â–· âŸ¨Res, Brk, BrkVoidâŸ©    Res = []    tail_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; âŸ¨Î£_Ï€, RSâŸ© âŠ¢ BlockProv(stmts, âŠ¥) â‡“ âŠ¥

**(P-Block)**
Î“; Î© âŠ¢ BlockProv(stmts, tail_opt) â‡“ Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ BlockExpr(stmts, tail_opt) â‡“ Ï€

**Loop Provenance.**

BreakProv(body, Î©) = âŸ¨Brk, BrkVoidâŸ© â‡” body = BlockExpr(stmts, tail_opt) âˆ§ Î©_0 = âŸ¨PushScope_Ï€(Î£_Ï€), RSâŸ© âˆ§ Î“; Î©_0 âŠ¢ stmts â‡’ Î©_1 â–· âŸ¨Res, Brk, BrkVoidâŸ© âˆ§ (tail_opt = e â‡’ Î“; Î©_1 âŠ¢ e â‡“ Ï€_t)

IterElemProv(iter, Î©) = Ï€ â‡” Î“; Î© âŠ¢ iter â‡“ Ï€

LoopProvInf(Brk, BrkVoid) = âŠ¥ â‡” Brk = []
LoopProvInf(Brk, BrkVoid) = Ï€ â‡” Brk = [Ï€_1, â€¦, Ï€_n] âˆ§ BrkVoid = false âˆ§ JoinAllProv([Ï€_1, â€¦, Ï€_n]) = Ï€

LoopProvFin(Brk, BrkVoid) = âŠ¥ â‡” Brk = []
LoopProvFin(Brk, BrkVoid) = Ï€ â‡” Brk = [Ï€_1, â€¦, Ï€_n] âˆ§ BrkVoid = false âˆ§ JoinAllProv([Ï€_1, â€¦, Ï€_n]) = Ï€

ExtendProv(âŸ¨Î£_Ï€, RSâŸ©, pat, Ï€) = âŸ¨Î£_Ï€', RSâŸ© â‡” Î“ âŠ¢ PatNames(pat) â‡“ N âˆ§ Î£_Ï€' = IntroAll_Ï€(Î£_Ï€, N, Ï€)

**(P-Loop-Infinite)**
BreakProv(body, Î©) = âŸ¨Brk, BrkVoidâŸ©    LoopProvInf(Brk, BrkVoid) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ LoopInfinite(body) â‡“ Ï€

**(P-Loop-Conditional)**
BreakProv(body, Î©) = âŸ¨Brk, BrkVoidâŸ©    LoopProvFin(Brk, BrkVoid) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ LoopConditional(cond, body) â‡“ Ï€

**(P-Loop-Iter)**
IterElemProv(iter, Î©) = Ï€_elem    ExtendProv(Î©, pat, Ï€_elem) = Î©'    BreakProv(body, Î©') = âŸ¨Brk, BrkVoidâŸ©    LoopProvFin(Brk, BrkVoid) = Ï€
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; Î© âŠ¢ LoopIter(pat, ty_opt, iter, body) â‡“ Ï€


EscapeOk(Ï€_e, Ï€_x) â‡” Â¬(Ï€_e < Ï€_x)

BindProv(âŸ¨Î£_Ï€, RSâŸ©, Ï€_init) =
  { StackProv(Î£_Ï€)    if Ï€_init = âŠ¥
    Ï€_init            otherwise }

StaticBindProv = Ï€_Global

AssignProvOk(Î©, p, e) â‡” Î“; Î© âŠ¢ p â‡“ Ï€_x âˆ§ Î“; Î© âŠ¢ e â‡“ Ï€_e âˆ§ EscapeOk(Ï€_e, Ï€_x)

### 5.3. Classes and Record Methods (Cursive0)

#### 5.3.1. Classes (Cursive0)

**Common Method-Signature Definitions.**

Distinct(xs) â‡” âˆ€ i â‰  j. xs[i] â‰  xs[j]
Disjoint(xs, ys) â‡” âˆ€ x âˆˆ xs. x âˆ‰ ys

ReturnType(m) =
  { m.return_type_opt        if m.return_type_opt â‰  âŠ¥
    TypePrim("()")           if m.return_type_opt = âŠ¥ }

SelfVar = TypePath([`Self`])

SubstSelf(T, TypePath([`Self`])) = T
SubstSelf(T, TypePerm(p, ty)) = TypePerm(p, SubstSelf(T, ty))
SubstSelf(T, TypeTuple([t_1, â€¦, t_n])) = TypeTuple([SubstSelf(T, t_1), â€¦, SubstSelf(T, t_n)])
SubstSelf(T, TypeArray(ty, e)) = TypeArray(SubstSelf(T, ty), e)
SubstSelf(T, TypeSlice(ty)) = TypeSlice(SubstSelf(T, ty))
SubstSelf(T, TypeUnion([t_1, â€¦, t_n])) = TypeUnion([SubstSelf(T, t_1), â€¦, SubstSelf(T, t_n)])
SubstSelf(T, TypeFunc([âŸ¨m_1, t_1âŸ©, â€¦, âŸ¨m_n, t_nâŸ©], r)) = TypeFunc([âŸ¨m_1, SubstSelf(T, t_1)âŸ©, â€¦, âŸ¨m_n, SubstSelf(T, t_n)âŸ©], SubstSelf(T, r))
SubstSelf(T, TypePtr(ty, s)) = TypePtr(SubstSelf(T, ty), s)
SubstSelf(T, TypeRawPtr(q, ty)) = TypeRawPtr(q, SubstSelf(T, ty))
SubstSelf(T, TypeString(state_opt)) = TypeString(state_opt)
SubstSelf(T, TypeBytes(state_opt)) = TypeBytes(state_opt)
SubstSelf(T, TypeModalState(modal_ref, S)) = TypeModalState(modal_ref, S)
SubstSelf(T, TypeDynamic(p)) = TypeDynamic(p)
SubstSelf(T, TypePrim(n)) = TypePrim(n)
SubstSelf(T, TypePath(p)) = TypePath(p)    if p â‰  [`Self`]

RecvType(T, ReceiverShorthand(`const`)) = TypePerm(`const`, T)
RecvType(T, ReceiverShorthand(`unique`)) = TypePerm(`unique`, T)
RecvType(T, ReceiverShorthand(`shared`)) = TypePerm(`shared`, T)
RecvType(T, ReceiverExplicit(mode_opt, ty)) = SubstSelf(T, ty)

RecvMode(ReceiverShorthand(_)) = âŠ¥
RecvMode(ReceiverExplicit(mode_opt, _)) = mode_opt

PermOf(TypePerm(p, _)) = p
PermOf(ty) = `const`    otherwise

RecvPerm(T, r) = PermOf(RecvType(T, r))

ParamSig_T(T, params) = [âŸ¨mode, SubstSelf(T, ty)âŸ© | âŸ¨mode, name, tyâŸ© âˆˆ params]
ParamBinds_T(T, params) = [âŸ¨x_1, SubstSelf(T, T_1)âŸ©, â€¦, âŸ¨x_n, SubstSelf(T, T_n)âŸ©]
ReturnType_T(T, m) = SubstSelf(T, ReturnType(m))

Sig_T(T, m) = âŸ¨RecvType(T, m.receiver), ParamSig_T(T, m.params), SubstSelf(T, ReturnType(m))âŸ©

SigSelf(m) = Sig_T(SelfVar, m)

SigMatch(T, m_impl, m_decl) â‡” Sig_T(T, m_impl) = âŸ¨recv_i, params_i, ret_iâŸ© âˆ§ Sig_T(T, m_decl) = âŸ¨recv_d, params_d, ret_dâŸ© âˆ§ recv_i = recv_d âˆ§ params_i = params_d âˆ§ Î“ âŠ¢ ret_i <: ret_d

**Class Declarations.**

ClassItems(Cl) = Cl.items
ClassMethods(Cl) = [ m | m âˆˆ ClassItems(Cl) âˆ§ âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. m = ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) ]
ClassFields(Cl) = [ f | f âˆˆ ClassItems(Cl) âˆ§ âˆƒ attrs, vis, boundary, name, ty, span, doc. f = ClassFieldDecl(attrs, vis, boundary, name, ty, span, doc) ]
MethodNames(Cl) = [ m.name | m âˆˆ ClassMethods(Cl) ]
FieldNames(Cl) = [ f.name | f âˆˆ ClassFields(Cl) ]

**Class Path Well-Formedness.**

**(WF-ClassPath)**
p âˆˆ dom(Î£.Classes)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : ClassPath

**(WF-ClassPath-Err)**
p âˆ‰ dom(Î£.Classes)    c = Code(Superclass-Undefined)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ p : ClassPath â‡‘ c

**Superclass Linearization (C3).**

Supers(Cl) = [S_1, â€¦, S_n]

**(Lin-Base)**
Supers(Cl) = []
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linearize(Cl) â‡“ [Cl]

Head(h :: t) = h
Tail([]) = []
Tail(h :: t) = t
HeadOk(h, Ls) â‡” âˆƒ L âˆˆ Ls. L = h :: t âˆ§ âˆ€ L' âˆˆ Ls. h âˆ‰ Tail(L')
SelectHead(Ls) = h â‡” Ls = [L_1, â€¦, L_n] âˆ§ L_i = h :: t âˆ§ HeadOk(h, Ls) âˆ§ âˆ€ j < i. Â¬ HeadOk(Head(L_j), Ls)
SelectHead(Ls) = âŠ¥ â‡” Â¬ âˆƒ h. HeadOk(h, Ls)
PopHead(h, L) = t â‡” L = h :: t
PopHead(h, L) = L â‡” Â¬(L = h :: t)
PopAll(h, Ls) = [PopHead(h, L) | L âˆˆ Ls]

**(Merge-Empty)**
âˆ€ L âˆˆ Ls, L = []
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Merge(Ls) â‡“ []

**(Merge-Step)**
SelectHead(Ls) = h    Î“ âŠ¢ Merge(PopAll(h, Ls)) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Merge(Ls) â‡“ [h] ++ L

**(Merge-Fail)**
Â¬ âˆƒ h. HeadOk(h, Ls)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Merge(Ls) â‡‘

**(Lin-Ok)**
Î“ âŠ¢ Merge([Linearize(S_1), â€¦, Linearize(S_n), [S_1, â€¦, S_n]]) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linearize(Cl) â‡“ [Cl] ++ L

**(Lin-Fail)**
Î“ âŠ¢ Merge(â‹¯) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linearize(Cl) â‡‘

**(Superclass-Cycle)**
Î“ âŠ¢ Linearize(Cl) â‡‘    c = Code(Superclass-Cycle)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl â‡‘ c

**Effective Method Set.**

Linearize(Cl) = [C_0, C_1, â€¦, C_k] âˆ§ C_0 = Cl

EffMethods(Cl) = FirstByName(++_{i=0..k} ClassMethods(C_i))

FirstByName(ms) = FirstByName(ms, âˆ…)

FirstByName([], Seen) = []
FirstByName(m :: ms, Seen) =
  { m :: FirstByName(ms, Seen âˆª { m.name â†¦ SigSelf(m) })    if m.name âˆ‰ dom(Seen)
    FirstByName(ms, Seen)                                  if Seen[m.name] = SigSelf(m)
    â‡‘                                                      otherwise }

**(EffMethods-Conflict)**
FirstByName(ms) â‡‘    c = Code(EffMethods-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

**Effective Field Set.**

FieldSig(f) = SubstSelf(SelfVar, f.type)

EffFields(Cl) = FirstFieldByName(++_{i=0..k} ClassFields(C_i))

FirstFieldByName(fs) = FirstFieldByName(fs, âˆ…)

FirstFieldByName([], Seen) = []
FirstFieldByName(f :: fs, Seen) =
  { f :: FirstFieldByName(fs, Seen âˆª { f.name â†¦ FieldSig(f) })    if f.name âˆ‰ dom(Seen)
    FirstFieldByName(fs, Seen)                                   if Seen[f.name] = FieldSig(f)
    â‡‘                                                            otherwise }

**(EffFields-Conflict)**
FirstFieldByName(fs) â‡‘    c = Code(EffFields-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Emit(c)

**Dispatchability.**

SelfOccurs(TypePath([`Self`])) = true
SelfOccurs(TypePerm(p, ty)) = SelfOccurs(ty)
SelfOccurs(TypeTuple([t_1, â€¦, t_n])) = âˆ¨_i SelfOccurs(t_i)
SelfOccurs(TypeArray(ty, e)) = SelfOccurs(ty)
SelfOccurs(TypeSlice(ty)) = SelfOccurs(ty)
SelfOccurs(TypeUnion([t_1, â€¦, t_n])) = âˆ¨_i SelfOccurs(t_i)
SelfOccurs(TypeFunc([âŸ¨m_1, t_1âŸ©, â€¦, âŸ¨m_n, t_nâŸ©], r)) = (âˆ¨_i SelfOccurs(t_i)) âˆ¨ SelfOccurs(r)
SelfOccurs(TypePtr(ty, s)) = SelfOccurs(ty)
SelfOccurs(TypeRawPtr(q, ty)) = SelfOccurs(ty)
SelfOccurs(TypeString(state_opt)) = false
SelfOccurs(TypeBytes(state_opt)) = false
SelfOccurs(TypeModalState(modal_ref, S)) = false
SelfOccurs(TypeDynamic(p)) = false
SelfOccurs(TypePrim(n)) = false
SelfOccurs(TypePath(p)) = false    if p â‰  [`Self`]

SelfOccurs(m) â‡” SelfOccurs(ReturnType(m)) âˆ¨ âˆƒ âŸ¨_, _, tyâŸ© âˆˆ m.params. SelfOccurs(ty)
HasReceiver(m) â‡” m.receiver â‰  âŠ¥
vtable_eligible(m) â‡” HasReceiver(m) âˆ§ Â¬ SelfOccurs(m)

dispatchable(Cl) â‡” âˆ€ m âˆˆ EffMethods(Cl). vtable_eligible(m)

**Class Method Well-Formedness.**

SelfTypeClass(ty) â‡” ty = SelfVar âˆ¨ âˆƒ p. ty = TypePerm(p, SelfVar)

**(WF-Class-Method)**
params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_m = BindTypeParams(Î“, params_gen)    (r = ReceiverExplicit(mode_opt, ty) â‡’ SelfTypeClass(ty))    (r = ReceiverShorthand(_) â‡’ true)    Î“_m âŠ¢ RecvType(SelfVar, r) wf    self âˆ‰ ParamNames(params)    Distinct(ParamNames(params))    âˆ€ âŸ¨_, _, T_iâŸ© âˆˆ params, Î“_m âŠ¢ T_i wf    (return_type_opt = âŠ¥ âˆ¨ Î“_m âŠ¢ return_type_opt wf)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ âŸ¨ClassMethodDecl, _, _, name, gen_params_opt, r, params, return_type_opt, _, body_opt, _, _âŸ© : ClassMethodOK(Cl)

**(T-Class-Method-Body-Abstract)**
m.body_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ m : ClassMethodBodyOK

**(T-Class-Method-Body)**
m.body_opt = body    T_self = RecvType(SelfVar, m.receiver)    R_m = ReturnType_T(SelfVar, m)    R_b = BodyReturnType(R_m)    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, [âŸ¨`self`, T_selfâŸ©] ++ ParamBinds_T(SelfVar, m.params)) â‡“ Î“_1    Î“_1; R_m; âŠ¥ âŠ¢ body : T_b    Î“ âŠ¢ T_b <: R_b    (R_b â‰  TypePrim("()") â‡’ ExplicitReturn(body))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ m : ClassMethodBodyOK

**(WF-Class)**
Distinct(MethodNames(Cl))    Distinct(FieldNames(Cl))    Disjoint(MethodNames(Cl), FieldNames(Cl))    Distinct(Supers(Cl))    âˆ€ S âˆˆ Supers(Cl), Î“ âŠ¢ S : ClassPath    âˆ€ m âˆˆ ClassMethods(Cl), Î“ âŠ¢ m : ClassMethodOK(Cl)    Î“ âŠ¢ m : ClassMethodBodyOK    Î“ âŠ¢ Linearize(Cl) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl : ClassOk

**(Class-Method-Dup)**
Â¬ Distinct(MethodNames(Cl))    c = Code(Class-Method-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl â‡‘ c

**(Class-AbstractField-Dup)**
Â¬ Distinct(FieldNames(Cl))    c = Code(Class-AbstractField-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl â‡‘ c

**(Class-Name-Conflict)**
Â¬ Disjoint(MethodNames(Cl), FieldNames(Cl))    c = Code(Class-Name-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl â‡‘ c

**(Superclass-Undefined)**
S âˆˆ Supers(Cl)    Â¬(Î“ âŠ¢ S : ClassPath)    c = Code(Superclass-Undefined)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl â‡‘ c

**Class Implementation.**

Implements(T) = impls â‡” T = RecordDecl(_, _, _, _, _, impls, _, _, _, _) âˆ¨ T = EnumDecl(_, _, _, _, _, impls, _, _, _, _) âˆ¨ T = ModalDecl(_, _, _, _, _, impls, _, _, _, _) âˆ¨ T = ClassDecl(_, _, _, _, _, _, impls, _, _, _)

**Implements Clause Constraints.**
NoDefaultMethods(Cl) â‡” âˆ€ m âˆˆ ClassMethods(Cl). m.body = âŠ¥
AbstractsImplemented(T) â‡” âˆ€ Cl âˆˆ Implements(T). âˆ€ m âˆˆ ClassMethodTable(Cl). (m.body = âŠ¥ â‡’ MethodByName(T, m.name) â‰  âŠ¥)

**(Impl-Duplicate-Class-Err)**
Â¬ Distinct(Implements(T))    c = Code(Impl-Duplicate-Class-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

Fields(T) = Fields(R) â‡” T = TypePath(p) âˆ§ RecordDecl(p) = R
Methods(T) = Methods(R) â‡” T = TypePath(p) âˆ§ RecordDecl(p) = R
Fields(T) = [] â‡” (T = TypePath(p) âˆ§ EnumDecl(p) = E) âˆ¨ (T = ModalRefType(modal_ref))
Methods(T) = [] â‡” (T = TypePath(p) âˆ§ EnumDecl(p) = E) âˆ¨ (T = ModalRefType(modal_ref))
MethodByName(T, name) = m' â‡” m' âˆˆ Methods(T) âˆ§ m'.name = name
MethodByName(T, name) = âŠ¥ â‡” Â¬ âˆƒ m' âˆˆ Methods(T). m'.name = name
ClassMethodTable(Cl) = EffMethods(Cl)
ClassFieldTable(Cl) = EffFields(Cl)

**(Impl-Abstract-Method)**
m âˆˆ ClassMethodTable(Cl)    m.body = âŠ¥    MethodByName(T, m.name) = m'    SigMatch(T, m', m)    m'.override = false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T implements abstract m

**(Impl-Missing-Method)**
m âˆˆ ClassMethodTable(Cl)    m.body = âŠ¥    MethodByName(T, m.name) = âŠ¥    c = Code(Impl-Missing-Method)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Impl-Sig-Err)**
m âˆˆ ClassMethodTable(Cl)    m.body = âŠ¥    MethodByName(T, m.name) = m'    Â¬ SigMatch(T, m', m)    c = Code(Impl-Missing-Method)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Override-Abstract-Err)**
m âˆˆ ClassMethodTable(Cl)    m.body = âŠ¥    MethodByName(T, m.name) = m'    SigMatch(T, m', m)    m'.override = true    c = Code(Override-Abstract-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Impl-Concrete-Default)**
m âˆˆ ClassMethodTable(Cl)    m.body â‰  âŠ¥    MethodByName(T, m.name) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T uses default m

**(Impl-Concrete-Override)**
m âˆˆ ClassMethodTable(Cl)    m.body â‰  âŠ¥    MethodByName(T, m.name) = m'    SigMatch(T, m', m)    m'.override = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T overrides m

**(Override-Missing-Err)**
m âˆˆ ClassMethodTable(Cl)    m.body â‰  âŠ¥    MethodByName(T, m.name) = m'    SigMatch(T, m', m)    m'.override = false    c = Code(Override-Missing-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Impl-Sig-Err-Concrete)**
m âˆˆ ClassMethodTable(Cl)    m.body â‰  âŠ¥    MethodByName(T, m.name) = m'    Â¬ SigMatch(T, m', m)    c = Code(Impl-Missing-Method)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Override-NoConcrete)**
m' âˆˆ Methods(T)    m'.override = true    Â¬ âˆƒ Cl âˆˆ Implements(T). âˆƒ m âˆˆ ClassMethodTable(Cl). m.name = m'.name âˆ§ m.body â‰  âŠ¥    c = Code(Override-NoConcrete)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Impl-Field)**
f : T_c âˆˆ ClassFieldTable(Cl)    f : T_i âˆˆ Fields(T)    T_i <: T_c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T satisfies field f

**(Impl-Field-Missing)**
f : T_c âˆˆ ClassFieldTable(Cl)    Â¬ âˆƒ T_i. f : T_i âˆˆ Fields(T)    c = Code(Impl-Field-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(Impl-Field-Type-Err)**
f : T_c âˆˆ ClassFieldTable(Cl)    f : T_i âˆˆ Fields(T)    Â¬(Î“ âŠ¢ T_i <: T_c)    c = Code(Impl-Field-Type-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

**(WF-Impl)**
âˆ€ Cl âˆˆ Implements(T), Î“ âŠ¢ Cl : ClassOk    Distinct(Implements(T))    Î“ âŠ¢ T : BitcopyDropOk    âˆ€ Cl âˆˆ Implements(T), âˆ€ m âˆˆ ClassMethodTable(Cl), (Î“ âŠ¢ T implements abstract m âˆ¨ Î“ âŠ¢ T overrides m âˆ¨ Î“ âŠ¢ T uses default m)    âˆ€ Cl âˆˆ Implements(T), âˆ€ f âˆˆ ClassFieldTable(Cl), Î“ âŠ¢ T satisfies field f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk

**(Impl-Dup)**
Â¬ Distinct(Implements(T))    c = Code(Impl-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : ImplementsOk â‡‘ c

Î“ âŠ¢ T <: Cl â‡” Cl âˆˆ Implements(T) âˆ§ Î“ âŠ¢ T : ImplementsOk

**Superclass Closure.**
S âˆˆ Supers(Cl) âˆ¨ (S âˆˆ Linearize(Cl) âˆ§ S â‰  Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cl <: S

Î“ âŠ¢ T <: Cl    Î“ âŠ¢ Cl <: S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: S

**Dynamic Class Types.**

**(T-Dynamic-Form)**
Î“; R; L âŠ¢ e :place T    IsPlace(e)    AddrOfOk(e)    Î“ âŠ¢ Cl : ClassPath    Î“ âŠ¢ StripPerm(T) <: Cl    dispatchable(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e `as` TypeDynamic(Cl) : TypeDynamic(Cl)

**(Dynamic-NonDispatchable)**
Î“; R; L âŠ¢ e :place T    IsPlace(e)    Î“ âŠ¢ Cl : ClassPath    Î“ âŠ¢ StripPerm(T) <: Cl    Â¬ dispatchable(Cl)    c = Code(Dynamic-NonDispatchable)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e `as` TypeDynamic(Cl) â‡‘ c

**Method Lookup for Concrete Types.**

ClassDefaults(T, name) = { m | âˆƒ Cl âˆˆ Implements(T). m âˆˆ ClassMethodTable(Cl) âˆ§ m.name = name âˆ§ m.body â‰  âŠ¥ }
LookupMethod(T, name) = m â‡” MethodByName(T, name) = m
LookupMethod(T, name) = m â‡” MethodByName(T, name) = âŠ¥ âˆ§ |ClassDefaults(T, name)| = 1 âˆ§ m âˆˆ ClassDefaults(T, name)
LookupMethod(T, name) = âŠ¥ â‡” MethodByName(T, name) = âŠ¥ âˆ§ (|ClassDefaults(T, name)| = 0 âˆ¨ |ClassDefaults(T, name)| > 1)

**(LookupMethod-NotFound)**
Î“; R; L âŠ¢ base : T_b    MethodByName(StripPerm(T_b), name) = âŠ¥    ClassDefaults(StripPerm(T_b), name) = âˆ…    c = Code(LookupMethod-NotFound)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

**(LookupMethod-Ambig)**
Î“; R; L âŠ¢ base : T_b    MethodByName(StripPerm(T_b), name) = âŠ¥    |ClassDefaults(StripPerm(T_b), name)| > 1    c = Code(LookupMethod-Ambig)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

**(Drop-Call-Err)**
Î“; R; L âŠ¢ base : T_b    LookupMethod(StripPerm(T_b), name) = m    MethodName(m) = `drop`    Sig_T(StripPerm(T_b), m) = âŸ¨TypePerm(`unique`, StripPerm(T_b)), [], TypePrim("()")âŸ©    c = Code(Drop-Call-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

**(Drop-Call-Err-Dyn)**
Î“; R; L âŠ¢ base : TypeDynamic(Cl)    LookupClassMethod(Cl, name) = m    MethodName(m) = `drop`    Sig_T(SelfVar, m) = âŸ¨TypePerm(`unique`, SelfVar), [], TypePrim("()")âŸ©    c = Code(Drop-Call-Err-Dyn)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

**(MethodCall-Packed-Unsafe-Err)**
RecvArgMode(base) = âŠ¥    PackedField(base)    Â¬ UnsafeSpan(span(base))    c = Code(Packed-Field-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

**(T-MethodCall)**
RecvBaseType(base, RecvMode(m.receiver)) = P_caller T    LookupMethod(T, name) = m    RecvPerm(T, m.receiver) = P_method    PermSub(P_caller, P_method)    RecvArgOk(base, RecvMode(m.receiver))    Î“; R; L âŠ¢ ArgsOk(m.params, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) : ReturnType(m)

**(MethodCall-RecvPerm-Err)**
RecvBaseType(base, RecvMode(m.receiver)) = P_caller T    LookupMethod(T, name) = m    RecvPerm(T, m.receiver) = P_method    Â¬ PermSub(P_caller, P_method)    c = Code(MethodCall-RecvPerm-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c
**(T-Dynamic-MethodCall)**
RecvBaseType(base, RecvMode(m.receiver)) = P_caller TypeDynamic(Cl)    LookupClassMethod(Cl, name) = m    RecvPerm(SelfVar, m.receiver) = P_method    PermSub(P_caller, P_method)    RecvArgOk(base, RecvMode(m.receiver))    Î“; R; L âŠ¢ ArgsOk(m.params, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) : ReturnType(m)

**(LookupClassMethod-NotFound)**
Î“; R; L âŠ¢ base : TypeDynamic(Cl)    LookupClassMethod(Cl, name) undefined    c = Code(LookupMethod-NotFound)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c


#### 5.3.2. Record Methods (Cursive0)

**Definitions.**

Fields(R) = [ f | f âˆˆ R.members âˆ§ âˆƒ attrs, vis, boundary, name, ty, init, span, doc. f = FieldDecl(attrs, vis, boundary, name, ty, init, span, doc) ]
Methods(R) = [ m | m âˆˆ R.members âˆ§ âˆƒ attrs, vis, override, name, gen_params, recv, params, ret, contract, body, span, doc. m = MethodDecl(attrs, vis, override, name, gen_params, recv, params, ret, contract, body, span, doc) ]
Self_R = TypePath(RecordPath(R))
SelfType(R, ty) â‡” ty = Self_R âˆ¨ âˆƒ p. ty = TypePerm(p, Self_R)

**Static Semantics**

**(Recv-Explicit)**
SelfType(R, ty)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReceiverExplicit(mode_opt, ty) : Recv(R, PermOf(ty), mode_opt)

**(Record-Method-RecvSelf-Err)**
Â¬ SelfType(R, ty)    c = Code(Record-Method-RecvSelf-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReceiverExplicit(mode_opt, ty) â‡‘ c

**(Recv-Const)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReceiverShorthand(`const`) : Recv(R, `const`, âŠ¥)

**(Recv-Unique)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReceiverShorthand(`unique`) : Recv(R, `unique`, âŠ¥)

**(Recv-Shared)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReceiverShorthand(`shared`) : Recv(R, `shared`, âŠ¥)

ParamNames(params) = [x | âŸ¨_, x, _âŸ© âˆˆ params]

**(WF-Record-Method)**
params_gen = TypeParamsOpt(gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_m = BindTypeParams(Î“, params_gen)    Î“_m âŠ¢ r : Recv(R, P, mode)    self âˆ‰ ParamNames(params)    Distinct(ParamNames(params))    âˆ€ âŸ¨_, _, T_iâŸ© âˆˆ params, Î“_m âŠ¢ T_i wf    (return_type_opt = âŠ¥ âˆ¨ Î“_m âŠ¢ return_type_opt wf)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ âŸ¨MethodDecl, _, _, _, name, gen_params_opt, r, params, return_type_opt, _, body, _, _âŸ© : MethodOK(R, P, mode)

**(T-Record-Method-Body)**
Î“ âŠ¢ m : MethodOK(R, P, mode)    T_self = RecvType(Self_R, m.receiver)    R_m = ReturnType_T(Self_R, m)    R_b = BodyReturnType(R_m)    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, [âŸ¨`self`, T_selfâŸ©] ++ ParamBinds_T(Self_R, m.params)) â‡“ Î“_1    Î“_1; R_m; âŠ¥ âŠ¢ m.body : T_b    Î“ âŠ¢ T_b <: R_b    (R_b â‰  TypePrim("()") â‡’ ExplicitReturn(m.body))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ m : MethodBodyOK(R)

**(T-Record-Method-Builtin)**
BuiltinRecord(R.name)    m âˆˆ Methods(R)    m.body = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ m : MethodBodyOK(R)

MethodNames(R) = [ m.name | m âˆˆ Methods(R) ]

**(WF-Record-Methods)**
Distinct(MethodNames(R))    âˆ€ m âˆˆ Methods(R), Î“ âŠ¢ m : MethodOK(R, _, _)    Î“ âŠ¢ m : MethodBodyOK(R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Methods(R) : ok

**(Record-Method-Dup)**
Â¬ Distinct(MethodNames(R))    c = Code(Record-Method-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Methods(R) â‡‘ c

**Method Lookup.**

LookupMethodRules = RulesIn({"5.3.1"})

**Argument Compatibility.**

ArgsOkJudg = {Î“; R; L âŠ¢ ArgsOk(params, args)}

RecvBaseType(base, mode) = P T â‡” (mode = âŠ¥ âˆ§ Î“; R; L âŠ¢ base :place P T) âˆ¨ (mode = `move` âˆ§ Î“; R; L âŠ¢ base : P T)

**(Args-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk([], [])

**(Args-Cons)**
Î“; R; L âŠ¢ MovedArg(moved, e) â‡ T_p âŠ£ âˆ…    moved = true    Î“; R; L âŠ¢ ArgsOk(ps, as)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk([âŸ¨`move`, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as)

**(Args-Cons-Ref)**
Î“; R; L âŠ¢ e â‡_place T_p    AddrOfOk(e)    moved = false    Î“; R; L âŠ¢ ArgsOk(ps, as)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ ArgsOk([âŸ¨âŠ¥, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as)

RecvArgOk(base, mode) â‡” (mode = âŠ¥ âˆ§ AddrOfOk(base)) âˆ¨ (mode = `move` âˆ§ âˆƒ p. base = MoveExpr(p))
ArgsOkDiagRules = RulesIn({"5.2.4"})

**(T-Record-MethodCall)**
RecvBaseType(base, RecvMode(m.receiver)) = P_caller R_rec    LookupMethod(R_rec, name) = m    RecvPerm(R_rec, m.receiver) = P_method    PermSub(P_caller, P_method)    RecvArgOk(base, RecvMode(m.receiver))    Î“; R; L âŠ¢ ArgsOk(m.params, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) : ReturnType(m)

BindParams(m, v_self, vecv) = {`self` â†¦ v_self} âˆª { x_i â†¦ v_i | m.params = [âŸ¨_, x_i, _âŸ©], vecv = [v_i] }
BindStmt(x, e) = LetStmt(âŸ¨IdentifierPattern(x), âŠ¥, Operator("="), e, âŠ¥âŸ©)
BindStmts(m, v_self, vecv) = [BindStmt(`self`, v_self)] ++ [BindStmt(x_i, v_i) | m.params = [âŸ¨_, x_i, _âŸ©], vecv = [v_i]]
ApplyMethod(m, v_self, vecv) = BlockExpr(bs ++ ss, t) â‡” BindStmts(m, v_self, vecv) = bs âˆ§ m.body = BlockExpr(ss, t)

**(Step-MethodCall)**
Î“ âŠ¢ v_self : P_caller R    LookupMethod(R, name) = m
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨MethodCall(v_self, name, vecv)âŸ© â†’ âŸ¨ApplyMethod(m, v_self, vecv)âŸ©


### 5.4. Modal Types (Definitions)

StateBlocks(M) = M.states
StateList(M) = [ b.name | b âˆˆ StateBlocks(M) ]
StateNames(M) = { S | S âˆˆ StateList(M) }
States(M) = StateNames(M)
States(M) â‰  âˆ…
StateBlockOf(M, S) = b â‡” b âˆˆ StateBlocks(M) âˆ§ b.name = S
StateMembers(M, S) = b.members â‡” StateBlockOf(M, S) = b
Payload(M, S) = [âŸ¨f, TâŸ© | StateFieldDecl(_, _, _, f, T, _, _) âˆˆ StateMembers(M, S)]
ModalSelfRef(M) =
  { TypePath(ModalPath(M))    if params_gen = []
    TypeApply(ModalPath(M), [TypePath([P_i.name]) | P_i âˆˆ params_gen])    otherwise
  }    where params_gen = TypeParamsOpt(M.gen_params_opt)
ModalSelfType(M, S) = TypeModalState(ModalSelfRef(M), S)
ModalSelfBase(M) = ModalRefType(ModalSelfRef(M))
ð’¯_M = {ModalSelfBase(M)} âˆª { ModalSelfType(M, S) | S âˆˆ States(M) }
Notation: M@S = ModalSelfType(M, S), and M = ModalSelfBase(M).

**Payload Map.**

PayloadMap(M, S) =
 { f_i â†¦ T_i | âŸ¨f_i, T_iâŸ© âˆˆ Payload(M, S) }    if Distinct([f_i | âŸ¨f_i, T_iâŸ© âˆˆ Payload(M, S)])
 âŠ¥    otherwise

ModalRefPath(TypePath(p)) = p
ModalRefPath(TypeApply(p, _)) = p
ModalRefArgs(TypePath(_)) = []
ModalRefArgs(TypeApply(_, args)) = args
ModalDeclOf(modal_ref) = M â‡” ModalRefPath(modal_ref) = p âˆ§ Î£.Types[p] = `modal` M
ModalRefSubst(modal_ref, M) = Î¸ â‡” params_gen = TypeParamsOpt(M.gen_params_opt) âˆ§ DefaultArgs(params_gen, ModalRefArgs(modal_ref)) = args' âˆ§ Î¸ = [args'_i / params_gen[i].name]
ModalPayload(modal_ref, S) = [âŸ¨f, TypeSubst(Î¸, T)âŸ© | âŸ¨f, TâŸ© âˆˆ Payload(M, S)] where ModalDeclOf(modal_ref) = M and Î¸ = ModalRefSubst(modal_ref, M)
ModalPayloadMap(modal_ref, S) =
 { f_i â†¦ T_i | âŸ¨f_i, T_iâŸ© âˆˆ ModalPayload(modal_ref, S) }    if Distinct([f_i | âŸ¨f_i, T_iâŸ© âˆˆ ModalPayload(modal_ref, S)])
 âŠ¥    otherwise

ModalRefType(TypePath(p)) = TypePath(p)
ModalRefType(TypeApply(p, args)) = TypeApply(p, args)

**(WF-Modal-Payload)**
âˆ€ i, Î“ âŠ¢ T_i wf    âˆ€ i â‰  j, f_i â‰  f_j
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Payload(M, S) wf

**(Modal-Payload-DupField)**
âˆƒ i â‰  j. f_i = f_j    c = Code(Modal-Payload-DupField)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Payload(M, S) wf â‡‘ c

**Type Well-Formedness (Cursive0).**

TypesMap = Î£.Types
ClassesMap = Î£.Classes

TypeWFJudg = {Î“ âŠ¢ T wf}

TypeParamsOf(p) =
  TypeParamsOpt(R.gen_params_opt)    if RecordDecl(p) = R
  TypeParamsOpt(E.gen_params_opt)    if EnumDecl(p) = E
  TypeParamsOpt(M.gen_params_opt)    if ModalDecl(p) = M
  TypeParamsOpt(gen_params_opt)      if Î£.Types[p] = TypeAliasDecl(_, _, _, gen_params_opt, _, _, _, _)

TypeWhereOf(p) =
  R.where_clause_opt    if RecordDecl(p) = R
  E.where_clause_opt    if EnumDecl(p) = E
  M.where_clause_opt    if ModalDecl(p) = M
  where_clause_opt      if Î£.Types[p] = TypeAliasDecl(_, _, _, _, where_clause_opt, _, _, _)

AsyncParams = [âŸ¨`Out`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`In`, [], TypePrim("()"), âŠ¥âŸ©, âŸ¨`Result`, [], TypePrim("()"), âŠ¥âŸ©, âŸ¨`E`, [], TypePrim("!"), âŠ¥âŸ©]

AsyncSig(T) = âŸ¨Out, In, Result, EâŸ© â‡” AliasNorm(T) = TypeApply(["Async"], args) âˆ§ DefaultArgs(AsyncParams, args) = [Out, In, Result, E]
AsyncSig(T) = âŠ¥    otherwise

BodyReturnType(R) =
  { Result    if AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©
    R         otherwise }

**(WF-Prim)**
T = TypePrim(name)    name âˆˆ PrimTypes_C0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Perm)**
T = TypePerm(p, T_0)    Î“ âŠ¢ T_0 wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Tuple)**
T = TypeTuple([T_1, â€¦, T_n])    âˆ€ i, Î“ âŠ¢ T_i wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Array)**
T = TypeArray(T_0, e)    Î“ âŠ¢ ConstLen(e) â‡“ n    Î“ âŠ¢ T_0 wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Slice)**
T = TypeSlice(T_0)    Î“ âŠ¢ T_0 wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Union)**
T = TypeUnion([T_1, â€¦, T_n])    n â‰¥ 2    âˆ€ i, Î“ âŠ¢ T_i wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Union-TooFew)**
T = TypeUnion([T_1, â€¦, T_n])    n < 2    c = Code(WF-Union-TooFew)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Func)**
T = TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)    Î“ âŠ¢ R wf    âˆ€ i, Î“ âŠ¢ T_i wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Path)**
T = TypePath(p)    p âˆˆ dom(Î£.Types)    TypeParamsOf(p) = []
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Path-Generic-Err)**
T = TypePath(p)    p âˆˆ dom(Î£.Types)    TypeParamsOf(p) â‰  []    c = Code(E-TYP-2303)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Apply)**
T = TypeApply(p, args)    p âˆˆ dom(Î£.Types)    params_gen = TypeParamsOf(p)    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    âˆ€ i, Î“ âŠ¢ args'_i wf    âˆ€ i, Î“ âŠ¢ args'_i satisfies Bounds(params_gen[i])    Î“ âŠ¢ TypeWhereOf(p)[Î¸] ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Apply-ArgCount-Err)**
T = TypeApply(p, args)    p âˆˆ dom(Î£.Types)    params_gen = TypeParamsOf(p)    DefaultArgs(params_gen, args) = âŠ¥    c = Code(E-TYP-2303)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Async)**
T = TypeApply(["Async"], args)    DefaultArgs(AsyncParams, args) = args'    âˆ€ i, Î“ âŠ¢ args'_i wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Async-ArgCount-Err)**
T = TypeApply(["Async"], args)    DefaultArgs(AsyncParams, args) = âŠ¥    c = Code(E-CON-0201)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Async-Arg-WF-Err)**
T = TypeApply(["Async"], args)    DefaultArgs(AsyncParams, args) = args'    âˆƒ i. Î“ âŠ¢ args'_i wf â‡‘    c = Code(E-CON-0201)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Async-Path-Err)**
T = TypePath(["Async"])    c = Code(E-CON-0201)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-Dynamic)**
T = TypeDynamic(p)    p âˆˆ dom(Î£.Classes)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Dynamic-Err)**
T = TypeDynamic(p)    p âˆ‰ dom(Î£.Classes)    c = Code(Superclass-Undefined)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-String)**
T = TypeString(state_opt)    state_opt âˆˆ {âŠ¥, `View`, `Managed`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf


**(WF-Bytes)**
T = TypeBytes(state_opt)    state_opt âˆˆ {âŠ¥, `View`, `Managed`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-Ptr)**
T = TypePtr(T_0, state_opt)    state_opt âˆˆ {âŠ¥, `Valid`, `Null`, `Expired`}    Î“ âŠ¢ T_0 wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-ModalState)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    params_gen = TypeParamsOpt(M.gen_params_opt)    DefaultArgs(params_gen, ModalRefArgs(modal_ref)) = args'    Î¸ = [args'_i / params_gen[i].name]    âˆ€ i, Î“ âŠ¢ args'_i wf    âˆ€ i, Î“ âŠ¢ args'_i satisfies Bounds(params_gen[i])    Î“ âŠ¢ M.where_clause_opt[Î¸] ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**(WF-ModalState-ArgCount-Err)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    params_gen = TypeParamsOpt(M.gen_params_opt)    DefaultArgs(params_gen, ModalRefArgs(modal_ref)) = âŠ¥    c = Code(E-TYP-2303)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf â‡‘ c

**(WF-RawPtr)**
T = TypeRawPtr(q, T_0)    Î“ âŠ¢ T_0 wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T wf

**Static Semantics**

**(Modal-WF)**
n â‰¥ 1    âˆ€ i âˆˆ 1..n, S_i unique    âˆ€ i, Î“ âŠ¢ Payload(M, S_i) wf    âˆ€ i, S_i â‰  M
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `modal` M { @S_1 ... @S_n } wf

**(Modal-NoStates-Err)**
n = 0    c = Code(Modal-NoStates-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `modal` M { @S_1 ... @S_n } wf â‡‘ c

**(Modal-DupState-Err)**
Â¬ Distinct([S_1, â€¦, S_n])    c = Code(Modal-DupState-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `modal` M { @S_1 ... @S_n } wf â‡‘ c

**(Modal-StateName-Err)**
âˆƒ i. S_i = M    c = Code(Modal-StateName-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `modal` M { @S_1 ... @S_n } wf â‡‘ c

**(State-Specific-WF)**
S âˆˆ States(M)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ M@S wf

PayloadNames(M, S) = [ f | âŸ¨f, _âŸ© âˆˆ Payload(M, S) ]
PayloadNameSet(M, S) = Set(PayloadNames(M, S))
ModalPayloadNames(modal_ref, S) = [ f | âŸ¨f, _âŸ© âˆˆ ModalPayload(modal_ref, S) ]
ModalPayloadNameSet(modal_ref, S) = Set(ModalPayloadNames(modal_ref, S))

**(T-Modal-State-Intro)**
ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    ModalRefPath(modal_ref) âˆ‰ {["File"], ["DirIter"], ["CancelToken"], ["Spawned"], ["Tracked"], ["Async"]}    ModalPayloadNameSet(modal_ref, S) = FieldInitSet(fields)    Distinct(FieldInitNames(fields))    âˆ€ âŸ¨f, eâŸ© âˆˆ fields, ModalPayloadMap(modal_ref, S)(f) = T_f âˆ§ Î“; R; L âŠ¢ e â‡ T_f âŠ£ âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(ModalStateRef(modal_ref, S), fields) : TypeModalState(modal_ref, S)

**(Modal-Incomparable)**
S_A â‰  S_B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ M@S_A not<: M@S_B âˆ§ Î“ âŠ¢ M@S_B not<: M@S_A

#### 5.4.1. Built-in Modal Type `Region` (Cursive0)

["Region"] âˆˆ dom(Î£.Types)
States(`Region`) = { `@Active`, `@Frozen`, `@Freed` }

RegionPayloadFields = [âŸ¨`handle`, TypePrim("usize")âŸ©]

Payload(`Region`, `@Active`) = RegionPayloadFields    Payload(`Region`, `@Frozen`) = RegionPayloadFields    Payload(`Region`, `@Freed`) = RegionPayloadFields

RegionProcs = {`Region::new_scoped`, `Region::alloc`, `Region::reset_unchecked`, `Region::freeze`, `Region::thaw`, `Region::free_unchecked`}

RegionProcSig(`Region::new_scoped`) = âŸ¨[âŸ¨âŠ¥, `options`, TypePath(["RegionOptions"])âŸ©], TypeModalState(["Region"], `@Active`)âŸ©
RegionProcSig(`Region::alloc`) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©, âŸ¨âŠ¥, `value`, TâŸ©], T_{Ï€_Region(`self`)}âŸ©    (T âˆˆ Type)
RegionProcSig(`Region::reset_unchecked`) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©], TypeModalState(["Region"], `@Active`)âŸ©
RegionProcSig(`Region::freeze`) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©], TypeModalState(["Region"], `@Frozen`)âŸ©
RegionProcSig(`Region::thaw`) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Frozen`))âŸ©], TypeModalState(["Region"], `@Active`)âŸ©
RegionProcSig(`Region::free_unchecked`) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeUnion([TypeModalState(["Region"], `@Active`), TypeModalState(["Region"], `@Frozen`)]))âŸ©], TypeModalState(["Region"], `@Freed`)âŸ©

ProvType(T, Ï€) = T_Ï€
BaseType(T_Ï€) = T    ProvOf(T_Ï€) = Ï€

Â¬ BitcopyType(TypePath(["Region"]))

**Region Arena Requirements.**
1. `Region::alloc` MUST yield a value with provenance Ï€_Region(r) where r is the receiver arena. The provenance tag is determined by the binding identifier introduced by RegionBindName and the current region stack (see AllocTag, Prov-RegionStmt, Prov-FrameStmt).
2. After `Region::reset_unchecked` or `Region::free_unchecked`, any dereference through a `Ptr<T>@Valid` whose address has an inactive `RegionTag` MUST behave as `Expired` per PtrState/ReadPtr. Uses of non-pointer values with provenance Ï€_Region(r) after reset/free are OutsideConformance.
3. `Region::free_unchecked` MUST be invoked exactly once on any `Region` that remains in `@Active` or `@Frozen` at scope exit. Implementations MAY invoke `Region::free_unchecked` implicitly during RegionStmt cleanup.

**(Region-Unchecked-Unsafe-Err)**
Î“; R; L âŠ¢ base : T    StripPerm(T) = TypeModalState(["Region"], S)    S âˆˆ {`Active`, `Frozen`}    name âˆˆ {"reset_unchecked", "free_unchecked"}    Â¬ UnsafeSpan(span(MethodCall(base, name, args)))    c = Code(Region-Unchecked-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, name, args) â‡‘ c

#### 5.4.2. Built-in Modal Type `CancelToken` (Cursive0)

["CancelToken"] âˆˆ dom(Î£.Types)
States(`CancelToken`) = { `@Active`, `@Cancelled` }

CancelTokenFields = [âŸ¨`id`, TypePrim("usize")âŸ©]

Payload(`CancelToken`, `@Active`) = CancelTokenFields
Payload(`CancelToken`, `@Cancelled`) = CancelTokenFields

CancelTokenActiveMembers = [
  StateFieldDecl(âŠ¥, `private`, false, `id`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "cancel", âŠ¥, ReceiverShorthand(`shared`), [], TypePrim("()"), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "is_cancelled", âŠ¥, ReceiverShorthand(`const`), [], TypePrim("bool"), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "wait_cancelled", âŠ¥, ReceiverShorthand(`const`), [], TypeApply(["Async"], [TypePrim("()")]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "child", âŠ¥, ReceiverShorthand(`const`), [], TypeModalState(["CancelToken"], `@Active`), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
CancelTokenCancelledMembers = [
  StateFieldDecl(âŠ¥, `private`, false, `id`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "is_cancelled", âŠ¥, ReceiverShorthand(`const`), [], TypePrim("bool"), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
CancelTokenStates = [
  StateBlock(`@Active`, CancelTokenActiveMembers, âŠ¥, âŠ¥),
  StateBlock(`@Cancelled`, CancelTokenCancelledMembers, âŠ¥, âŠ¥)
]
CancelTokenDecl = ModalDecl(âŠ¥, `public`, `CancelToken`, âŠ¥, âŠ¥, [], CancelTokenStates, âŠ¥, âŠ¥, âŠ¥)

Î£.Types["CancelToken"] = `modal` CancelTokenDecl

CancelTokenProcs = {`CancelToken::new`}
CancelTokenProcSig(`CancelToken::new`) = âŸ¨[], TypeModalState(["CancelToken"], `@Active`)âŸ©

#### 5.4.3. Built-in Modal Type `Spawned` (Cursive0)

["Spawned"] âˆˆ dom(Î£.Types)
States(`Spawned`) = { `@Pending`, `@Ready` }

SpawnedParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©]

SpawnedReadyFields = [âŸ¨`value`, TypePath(["T"])âŸ©]

Payload(`Spawned`, `@Pending`) = []
Payload(`Spawned`, `@Ready`) = SpawnedReadyFields

SpawnedPendingMembers = []
SpawnedReadyMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `value`, TypePath(["T"]), âŠ¥, âŠ¥)
]
SpawnedStates = [
  StateBlock(`@Pending`, SpawnedPendingMembers, âŠ¥, âŠ¥),
  StateBlock(`@Ready`, SpawnedReadyMembers, âŠ¥, âŠ¥)
]
SpawnedDecl = ModalDecl(âŠ¥, `public`, `Spawned`, SpawnedParams, âŠ¥, [], SpawnedStates, âŠ¥, âŠ¥, âŠ¥)

Î£.Types["Spawned"] = `modal` SpawnedDecl

#### 5.4.4. Built-in Modal Type `Tracked` (Cursive0)

["Tracked"] âˆˆ dom(Î£.Types)
States(`Tracked`) = { `@Pending`, `@Ready` }

TrackedParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`E`, [], âŠ¥, âŠ¥âŸ©]

TrackedReadyFields = [âŸ¨`value`, TypeUnion([TypePath(["T"]), TypePath(["E"])])âŸ©]

Payload(`Tracked`, `@Pending`) = []
Payload(`Tracked`, `@Ready`) = TrackedReadyFields

TrackedPendingMembers = []
TrackedReadyMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `value`, TypeUnion([TypePath(["T"]), TypePath(["E"])]), âŠ¥, âŠ¥)
]
TrackedStates = [
  StateBlock(`@Pending`, TrackedPendingMembers, âŠ¥, âŠ¥),
  StateBlock(`@Ready`, TrackedReadyMembers, âŠ¥, âŠ¥)
]
TrackedDecl = ModalDecl(âŠ¥, `public`, `Tracked`, TrackedParams, âŠ¥, [], TrackedStates, âŠ¥, âŠ¥, âŠ¥)

Î£.Types["Tracked"] = `modal` TrackedDecl

#### 5.4.5. Built-in Modal Type `Async` (Cursive0)

["Async"] âˆˆ dom(Î£.Types)
States(`Async`) = { `@Suspended`, `@Completed`, `@Failed` }

AsyncParams = [âŸ¨`Out`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`In`, [], TypePrim("()"), âŠ¥âŸ©, âŸ¨`Result`, [], TypePrim("()"), âŠ¥âŸ©, âŸ¨`E`, [], TypePrim("!"), âŠ¥âŸ©]

AsyncRef = TypeApply(["Async"], [TypePath(["Out"]), TypePath(["In"]), TypePath(["Result"]), TypePath(["E"])])

AsyncSuspendedFields = [âŸ¨`output`, TypePath(["Out"])âŸ©]
AsyncCompletedFields = [âŸ¨`value`, TypePath(["Result"])âŸ©]
AsyncFailedFields = [âŸ¨`error`, TypePath(["E"])âŸ©]

Payload(`Async`, `@Suspended`) = AsyncSuspendedFields
Payload(`Async`, `@Completed`) = AsyncCompletedFields
Payload(`Async`, `@Failed`) = AsyncFailedFields

AsyncSuspendedMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `output`, TypePath(["Out"]), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "resume", âŠ¥, ReceiverShorthand(`unique`), [âŸ¨âŠ¥, `input`, TypePath(["In"])âŸ©], TypeUnion([TypeModalState(AsyncRef, `@Suspended`), TypeModalState(AsyncRef, `@Completed`), TypeModalState(AsyncRef, `@Failed`)]), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
AsyncCompletedMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `value`, TypePath(["Result"]), âŠ¥, âŠ¥)
]
AsyncFailedMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `error`, TypePath(["E"]), âŠ¥, âŠ¥)
]

AsyncStates = [
  StateBlock(`@Suspended`, AsyncSuspendedMembers, âŠ¥, âŠ¥),
  StateBlock(`@Completed`, AsyncCompletedMembers, âŠ¥, âŠ¥),
  StateBlock(`@Failed`, AsyncFailedMembers, âŠ¥, âŠ¥)
]
AsyncDecl = ModalDecl(âŠ¥, `public`, `Async`, AsyncParams, âŠ¥, [], AsyncStates, âŠ¥, âŠ¥, âŠ¥)

Î£.Types["Async"] = `modal` AsyncDecl

When `E = !`, values of `Async@Failed` are uninhabited. The implementation MAY omit the `@Failed` state from concrete storage layouts per Â§9.3.

SequenceParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©]
SequenceBody = TypeApply(["Async"], [TypePath(["T"]), TypePrim("()"), TypePrim("()"), TypePrim("!")])
SequenceDecl = TypeAliasDecl(âŠ¥, `public`, `Sequence`, SequenceParams, âŠ¥, SequenceBody, âŠ¥, âŠ¥)

FutureParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`E`, [], TypePrim("!"), âŠ¥âŸ©]
FutureBody = TypeApply(["Async"], [TypePrim("()"), TypePrim("()"), TypePath(["T"]), TypePath(["E"])])
FutureDecl = TypeAliasDecl(âŠ¥, `public`, `Future`, FutureParams, âŠ¥, FutureBody, âŠ¥, âŠ¥)

StreamParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`E`, [], âŠ¥, âŠ¥âŸ©]
StreamBody = TypeApply(["Async"], [TypePath(["T"]), TypePrim("()"), TypePrim("()"), TypePath(["E"])])
StreamDecl = TypeAliasDecl(âŠ¥, `public`, `Stream`, StreamParams, âŠ¥, StreamBody, âŠ¥, âŠ¥)

PipeParams = [âŸ¨`In`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`Out`, [], âŠ¥, âŠ¥âŸ©]
PipeBody = TypeApply(["Async"], [TypePath(["Out"]), TypePath(["In"]), TypePrim("()"), TypePrim("!")])
PipeDecl = TypeAliasDecl(âŠ¥, `public`, `Pipe`, PipeParams, âŠ¥, PipeBody, âŠ¥, âŠ¥)

ExchangeParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©]
ExchangeBody = TypeApply(["Async"], [TypePath(["T"]), TypePath(["T"]), TypePath(["T"]), TypePrim("!")])
ExchangeDecl = TypeAliasDecl(âŠ¥, `public`, `Exchange`, ExchangeParams, âŠ¥, ExchangeBody, âŠ¥, âŠ¥)

Î£.Types["Sequence"] = SequenceDecl
Î£.Types["Future"] = FutureDecl
Î£.Types["Stream"] = StreamDecl
Î£.Types["Pipe"] = PipeDecl
Î£.Types["Exchange"] = ExchangeDecl

### 5.5. State-Specific Fields

ModalFieldVisible(m, modal_ref) â‡” ModalDeclOf(modal_ref) = M âˆ§ ModuleOfPath(ModalPath(M)) = m

**(T-Modal-Field)**
Î“; R; L âŠ¢ e : TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    ModalPayloadMap(modal_ref, S)(f) = T    ModalFieldVisible(m, modal_ref)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e.f : T

**(T-Modal-Field-Perm)**
Î“; R; L âŠ¢ e : TypePerm(p', TypeModalState(modal_ref, S))    ModalDeclOf(modal_ref) = M    ModalPayloadMap(modal_ref, S)(f) = T    ModalFieldVisible(m, modal_ref)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e.f : TypePerm(p', T)

**(Modal-Field-Missing)**
Î“; R; L âŠ¢ e : TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    ModalPayloadMap(modal_ref, S)(f) undefined    c = Code(Modal-Field-Missing)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e.f â‡‘ c

**(Modal-Field-General-Err)**
Î“; R; L âŠ¢ e : T    StripPerm(T) = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    c = Code(Modal-Field-General-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e.f â‡‘ c

**(Modal-Field-NotVisible)**
Î“; R; L âŠ¢ e : TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    ModalPayloadMap(modal_ref, S)(f) = T    Â¬ ModalFieldVisible(m, modal_ref)    c = Code(Modal-Field-NotVisible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e.f â‡‘ c

### 5.6. Transitions and State-Specific Methods

Methods(M, S) = [ m | m âˆˆ StateMembers(M, S) âˆ§ âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. m = StateMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) ]
Transitions(M, S) = [ t | t âˆˆ StateMembers(M, S) âˆ§ âˆƒ attrs, vis, name, params, target, body, span, doc. t = TransitionDecl(attrs, vis, name, params, target, body, span, doc) ]
StateMethodNames(M, S) = [ m.name | m âˆˆ Methods(M, S) ]
TransitionNames(M, S) = [ t.name | t âˆˆ Transitions(M, S) ]
StateMemberNames(M, S) = StateMethodNames(M, S) ++ TransitionNames(M, S)

**(StateMethod-Dup)**
Â¬ Distinct(StateMethodNames(M, S))    c = Code(StateMethod-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S â‡‘ c

**(Transition-Dup)**
Â¬ Distinct(TransitionNames(M, S))    c = Code(Transition-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S â‡‘ c

**(StateMember-Name-Conflict)**
Â¬ Disjoint(StateMethodNames(M, S), TransitionNames(M, S))    c = Code(StateMember-Name-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ S â‡‘ c

LookupStateMethod(M, S, name) = m â‡” m âˆˆ Methods(M, S) âˆ§ m.name = name
LookupStateMethod(M, S, name) = âŠ¥ â‡” Â¬ âˆƒ m âˆˆ Methods(M, S). m.name = name
LookupTransition(M, S, name) = t â‡” t âˆˆ Transitions(M, S) âˆ§ t.name = name
LookupTransition(M, S, name) = âŠ¥ â‡” Â¬ âˆƒ t âˆˆ Transitions(M, S). t.name = name
StateMemberVisible(mod, M, vis) â‡” vis âˆˆ {`public`, `internal`} âˆ¨ (vis âˆˆ {`private`, `protected`} âˆ§ ModuleOfPath(ModalPath(M)) = mod)
MethodSig(M, S, m).recv = RecvType(ModalSelfType(M, S), m.receiver)
MethodSig(M, S, m).params = m.params
MethodSig(M, S, m).ret = ReturnType(m)
TransitionSig(M, S_src, t).recv = TypePerm(`unique`, ModalSelfType(M, S_src))
TransitionSig(M, S_src, t).params = t.params
S_tgt = t.target
TransitionSig(M, S_src, t).ret = ModalSelfType(M, S_tgt)
TransitionSig(M, S_src, t).target = S_tgt
TransitionSig(M, S_src, t).mode = `move`

**State Method and Transition Well-Formedness.**

**(WF-State-Method)**
params_gen = TypeParamsOpt(md.gen_params_opt)    params_gen = [P_1, â€¦, P_n]    Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf    Î“_m = BindTypeParams(Î“, params_gen)    Î“_m âŠ¢ md.receiver : Recv(ModalSelfType(M, S), P, mode)    self âˆ‰ ParamNames(md.params)    Distinct(ParamNames(md.params))    âˆ€ âŸ¨_, _, T_iâŸ© âˆˆ md.params, Î“_m âŠ¢ T_i wf    (md.return_type_opt = âŠ¥ âˆ¨ Î“_m âŠ¢ md.return_type_opt wf)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ md : StateMethodOK(M, S)

**(WF-Transition)**
self âˆ‰ ParamNames(tr.params)    Distinct(ParamNames(tr.params))    âˆ€ âŸ¨_, _, T_iâŸ© âˆˆ tr.params, Î“ âŠ¢ T_i wf    tr.target âˆˆ States(M)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ tr : TransitionOK(M, S_src)

**(Transition-Target-Err)**
tr.target âˆ‰ States(M)    c = Code(Transition-Target-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ tr â‡‘ c

**(T-Modal-Transition)**
Î“; R; L âŠ¢ e_self : TypePerm(`unique`, TypeModalState(modal_ref, S_src))    ModalDeclOf(modal_ref) = M    LookupTransition(M, S_src, t) = tr    StateMemberVisible(mod, M, tr.vis)    TransitionSig(M, S_src, tr).params = ps    TransitionSig(M, S_src, tr).target = S_tgt    Î“; R; L âŠ¢ ArgsOk(ps, args)    RecvArgOk(e_self, `move`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e_self ~> t(args) : TypeModalState(modal_ref, S_tgt)

**(Transition-Source-Err)**
Î“; R; L âŠ¢ e_self : T    (PermOf(T) â‰  `unique` âˆ¨ StripPerm(T) â‰  TypeModalState(_, _))    c = Code(Transition-Source-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e_self ~> t(args) â‡‘ c

**(Transition-NotVisible)**
Î“; R; L âŠ¢ e_self : TypePerm(`unique`, TypeModalState(modal_ref, S_src))    ModalDeclOf(modal_ref) = M    LookupTransition(M, S_src, t) = tr    Â¬ StateMemberVisible(mod, M, tr.vis)    c = Code(Transition-NotVisible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e_self ~> t(args) â‡‘ c


**(T-Modal-Transition-Body)**
Î£.Types[p] = `modal` M    S_src âˆˆ States(M)    tr âˆˆ Transitions(M, S_src)    tr.body = body    tr.target = S_tgt    S_tgt âˆˆ States(M)    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, [âŸ¨`self`, TypePerm(`unique`, ModalSelfType(M, S_src))âŸ©] ++ ParamBinds(tr.params)) â‡“ Î“_1    Î“_1; ModalSelfType(M, S_tgt); âŠ¥ âŠ¢ body : T_b    Î“ âŠ¢ T_b <: ModalSelfType(M, S_tgt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ tr : TransitionBodyOK(p, S_src)

**(Transition-Body-Err)**
Î£.Types[p] = `modal` M    S_src âˆˆ States(M)    tr âˆˆ Transitions(M, S_src)    tr.body = body    tr.target = S_tgt    S_tgt âˆˆ States(M)    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, [âŸ¨`self`, TypePerm(`unique`, ModalSelfType(M, S_src))âŸ©] ++ ParamBinds(tr.params)) â‡“ Î“_1    Î“_1; ModalSelfType(M, S_tgt); âŠ¥ âŠ¢ body : T_b    Â¬(Î“ âŠ¢ T_b <: ModalSelfType(M, S_tgt))    c = Code(Transition-Body-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ tr â‡‘ c

**(T-Modal-Method)**
Î“; R; L âŠ¢ e : P_caller TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupStateMethod(M, S, m) = md    P_method = RecvPerm(ModalSelfType(M, S), md.receiver)    PermSub(P_caller, P_method)    StateMemberVisible(mod, M, md.vis)    MethodSig(M, S, md).params = ps    Î“; R; L âŠ¢ ArgsOk(ps, args)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e ~> m(args) : ReturnType(md)

**(Modal-Method-RecvPerm-Err)**
Î“; R; L âŠ¢ e : P_caller TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupStateMethod(M, S, m) = md    P_method = RecvPerm(ModalSelfType(M, S), md.receiver)    Â¬ PermSub(P_caller, P_method)    c = Code(MethodCall-RecvPerm-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e ~> m(args) â‡‘ c

**(Modal-Method-NotFound)**
Î“; R; L âŠ¢ e : P_caller TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupStateMethod(M, S, m) undefined    c = Code(Modal-Method-NotFound)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e ~> m(args) â‡‘ c

**(Modal-Method-NotVisible)**
Î“; R; L âŠ¢ e : P_caller TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupStateMethod(M, S, m) = md    Â¬ StateMemberVisible(mod, M, md.vis)    c = Code(Modal-Method-NotVisible)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ e ~> m(args) â‡‘ c

**(T-Modal-Method-Body)**
Î£.Types[p] = `modal` M    S âˆˆ States(M)    md âˆˆ Methods(M, S)    md.body = body    T_self = RecvType(ModalSelfType(M, S), md.receiver)    Î“_0 = PushScope(Î“)    IntroAll(Î“_0, [âŸ¨`self`, T_selfâŸ©] ++ ParamBinds(md.params)) â‡“ Î“_1    R_m = ReturnType(md)    R_b = BodyReturnType(R_m)    Î“_1; R_m; âŠ¥ âŠ¢ body : T_b    Î“ âŠ¢ T_b <: R_b    (R_b â‰  TypePrim("()") â‡’ ExplicitReturn(body))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ md : StateMethodBodyOK(p, S)

### 5.7. Modal Widening (`widen`)

WIDEN_LARGE_PAYLOAD_THRESHOLD_BYTES = 256

**(T-Modal-Widen)**
Î“; R; L âŠ¢ e : TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    Î“ âŠ¢ WarnWidenLargePayload(e, modal_ref, S) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `widen` e : ModalRefType(modal_ref)

**(T-Modal-Widen-Perm)**
Î“; R; L âŠ¢ e : TypePerm(p', TypeModalState(modal_ref, S))    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    Î“ âŠ¢ WarnWidenLargePayload(e, modal_ref, S) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `widen` e : TypePerm(p', ModalRefType(modal_ref))

**(Widen-AlreadyGeneral)**
Î“; R; L âŠ¢ e : T    StripPerm(T) = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    c = Code(Widen-AlreadyGeneral)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `widen` e â‡‘ c

**(Widen-NonModal)**
Î“; R; L âŠ¢ e : T    StripPerm(T) = U    U â‰  TypeModalState(_, _)    Â¬ âˆƒ modal_ref, M. (U = ModalRefType(modal_ref) âˆ§ ModalDeclOf(modal_ref) = M)    c = Code(Widen-NonModal)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `widen` e â‡‘ c

**Niche-Layout-Compatible Conditions**

NicheCompatible(modal_ref, S) â‡” ModalDeclOf(modal_ref) = M âˆ§ NicheApplies(modal_ref) âˆ§ PayloadState(modal_ref) = S âˆ§ sizeof(TypeModalState(modal_ref, S)) = sizeof(ModalRefType(modal_ref)) âˆ§ alignof(TypeModalState(modal_ref, S)) = alignof(ModalRefType(modal_ref))

WidenWarnCond(modal_ref, S) â‡” ModalDeclOf(modal_ref) = M âˆ§ sizeof(TypeModalState(modal_ref, S)) > WIDEN_LARGE_PAYLOAD_THRESHOLD_BYTES âˆ§ Â¬ NicheCompatible(modal_ref, S)

**(Warn-Widen-LargePayload)**
WidenWarnCond(modal_ref, S)    sp = span(Unary("widen", e))    Î“ âŠ¢ Emit(W-SYS-4010, sp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WarnWidenLargePayload(e, modal_ref, S) â‡“ ok

**(Warn-Widen-Ok)**
Â¬ WidenWarnCond(modal_ref, S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WarnWidenLargePayload(e, modal_ref, S) â‡“ ok

**Size Relationship**

sizeof(M@S) â‰¤ sizeof(M)

### 5.8. String and Bytes Types and States

States(`string`) = { `@Managed`, `@View` }
States(`bytes`) = { `@Managed`, `@View` }

**Modal Widening.**

S âˆˆ {`@Managed`, `@View`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ string@S <: string
S âˆˆ {`@Managed`, `@View`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ bytes@S <: bytes

StringBytesBuiltinTable =
{
 âŸ¨`string::from`, [âŸ¨âŠ¥, `source`, TypeString(`@View`)âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeString(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`string::as_view`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeString(`@Managed`))âŸ©], TypeString(`@View`)âŸ©,
 âŸ¨`string::to_managed`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeString(`@View`))âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeString(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`string::clone_with`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeString(`@Managed`))âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeString(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`string::append`, [âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeString(`@Managed`))âŸ©, âŸ¨âŠ¥, `data`, TypeString(`@View`)âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`string::length`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeString(`@View`))âŸ©], TypePrim("usize")âŸ©,
 âŸ¨`string::is_empty`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeString(`@View`))âŸ©], TypePrim("bool")âŸ©,
 âŸ¨`bytes::with_capacity`, [âŸ¨âŠ¥, `cap`, TypePrim("usize")âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeBytes(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`bytes::from_slice`, [âŸ¨âŠ¥, `data`, TypePerm(`const`, TypeSlice(TypePrim("u8")))âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeBytes(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`bytes::as_view`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeBytes(`@Managed`))âŸ©], TypeBytes(`@View`)âŸ©,
 âŸ¨`bytes::to_managed`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeBytes(`@View`))âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypeBytes(`@Managed`), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`bytes::view`, [âŸ¨âŠ¥, `data`, TypePerm(`const`, TypeSlice(TypePrim("u8")))âŸ©], TypeBytes(`@View`)âŸ©,
 âŸ¨`bytes::view_string`, [âŸ¨âŠ¥, `data`, TypeString(`@View`)âŸ©], TypeBytes(`@View`)âŸ©,
 âŸ¨`bytes::append`, [âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeBytes(`@Managed`))âŸ©, âŸ¨âŠ¥, `data`, TypeBytes(`@View`)âŸ©, âŸ¨âŠ¥, `heap`, TypeDynamic(`HeapAllocator`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["AllocationError"])])âŸ©,
 âŸ¨`bytes::length`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeBytes(`@View`))âŸ©], TypePrim("usize")âŸ©,
 âŸ¨`bytes::is_empty`, [âŸ¨âŠ¥, `self`, TypePerm(`const`, TypeBytes(`@View`))âŸ©], TypePrim("bool")âŸ©
}
StringBytesBuiltinSig(method) = âŸ¨params, retâŸ© â‡” âŸ¨method, params, retâŸ© âˆˆ StringBytesBuiltinTable

ByteSeq = List(`u8`)
SB = âŸ¨StrBuf, BytesBuf, BytesCapâŸ©
StrBuf : `string@Managed` â‡€ ByteSeq
BytesBuf : `bytes@Managed` â‡€ ByteSeq
BytesCap : `bytes@Managed` â‡€ `usize`

ViewBytes : (`string@View` âˆª `bytes@View`) â†’ ByteSeq
ByteSeqOf(SB, v) =
 StrBuf(v)    if v:`string@Managed`
 BytesBuf(v)  if v:`bytes@Managed`
 ViewBytes(v) if v:`string@View` or v:`bytes@View`
ByteLen(SB, v) = |ByteSeqOf(SB, v)|

SliceBytes(data) = [b | b âˆˆ data]

StringBytesJudg = {
 StringFrom(SB, source, heap) â‡“ (r, SB'),
 StringAsView(SB, self) â‡“ v,
 StringToManaged(SB, self, heap) â‡“ (r, SB'),
 StringCloneWith(SB, self, heap) â‡“ (r, SB'),
 StringAppend(SB, self, data, heap) â‡“ (r, SB'),
 StringLength(SB, self) â‡“ n,
 StringIsEmpty(SB, self) â‡“ b,
 BytesWithCapacity(SB, cap, heap) â‡“ (r, SB'),
 BytesFromSlice(SB, data, heap) â‡“ (r, SB'),
 BytesAsView(SB, self) â‡“ v,
 BytesToManaged(SB, self, heap) â‡“ (r, SB'),
 BytesView(SB, data) â‡“ v,
 BytesViewString(SB, data) â‡“ v,
 BytesAppend(SB, self, data, heap) â‡“ (r, SB'),
 BytesLength(SB, self) â‡“ n,
 BytesIsEmpty(SB, self) â‡“ b
}


**(StringFrom-Ok)**
r = v    SB' = âŸ¨StrBuf[v â†¦ ByteSeqOf(SB, source)], BytesBuf, BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringFrom(SB, source, heap) â‡“ (r, SB')

**(StringFrom-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringFrom(SB, source, heap) â‡“ (r, SB')

**(StringAsView-Ok)**
ByteSeqOf(SB, v) = ByteSeqOf(SB, self)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringAsView(SB, self) â‡“ v

**(StringToManaged-Ok)**
r = v    SB' = âŸ¨StrBuf[v â†¦ ByteSeqOf(SB, self)], BytesBuf, BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringToManaged(SB, self, heap) â‡“ (r, SB')

**(StringToManaged-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringToManaged(SB, self, heap) â‡“ (r, SB')

**(StringCloneWith-Ok)**
r = v    SB' = âŸ¨StrBuf[v â†¦ ByteSeqOf(SB, self)], BytesBuf, BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringCloneWith(SB, self, heap) â‡“ (r, SB')

**(StringCloneWith-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringCloneWith(SB, self, heap) â‡“ (r, SB')

**(StringAppend-Ok)**
r = ()    StrBuf' = StrBuf[self â†¦ ByteSeqOf(SB, self) ++ ByteSeqOf(SB, data)]    SB' = âŸ¨StrBuf', BytesBuf, BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringAppend(SB, self, data, heap) â‡“ (r, SB')

**(StringAppend-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringAppend(SB, self, data, heap) â‡“ (r, SB')

**(StringLength)**
n = ByteLen(SB, self)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringLength(SB, self) â‡“ n

**(StringIsEmpty)**
b = (ByteLen(SB, self) = 0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringIsEmpty(SB, self) â‡“ b

**(BytesWithCapacity-Ok)**
r = v    BytesBuf' = BytesBuf[v â†¦ []]    BytesCap' = BytesCap[v â†¦ cap']    cap' â‰¥ cap    SB' = âŸ¨StrBuf, BytesBuf', BytesCap'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesWithCapacity(SB, cap, heap) â‡“ (r, SB')

**(BytesWithCapacity-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesWithCapacity(SB, cap, heap) â‡“ (r, SB')

**(BytesFromSlice-Ok)**
r = v    BytesBuf' = BytesBuf[v â†¦ SliceBytes(data)]    SB' = âŸ¨StrBuf, BytesBuf', BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesFromSlice(SB, data, heap) â‡“ (r, SB')

**(BytesFromSlice-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesFromSlice(SB, data, heap) â‡“ (r, SB')

**(BytesAsView-Ok)**
ByteSeqOf(SB, v) = ByteSeqOf(SB, self)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesAsView(SB, self) â‡“ v

**(BytesToManaged-Ok)**
r = v    BytesBuf' = BytesBuf[v â†¦ ByteSeqOf(SB, self)]    SB' = âŸ¨StrBuf, BytesBuf', BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesToManaged(SB, self, heap) â‡“ (r, SB')

**(BytesToManaged-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesToManaged(SB, self, heap) â‡“ (r, SB')

**(BytesView-Ok)**
ByteSeqOf(SB, v) = SliceBytes(data)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesView(SB, data) â‡“ v

**(BytesViewString-Ok)**
ByteSeqOf(SB, v) = ByteSeqOf(SB, data)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesViewString(SB, data) â‡“ v

**(BytesAppend-Ok)**
r = ()    BytesBuf' = BytesBuf[self â†¦ ByteSeqOf(SB, self) ++ ByteSeqOf(SB, data)]    SB' = âŸ¨StrBuf, BytesBuf', BytesCapâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesAppend(SB, self, data, heap) â‡“ (r, SB')

**(BytesAppend-Err)**
AllocErrorVal(r)    SB' = SB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesAppend(SB, self, data, heap) â‡“ (r, SB')

**(BytesLength)**
n = ByteLen(SB, self)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesLength(SB, self) â‡“ n

**(BytesIsEmpty)**
b = (ByteLen(SB, self) = 0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesIsEmpty(SB, self) â‡“ b

### 5.9. Capabilities and Context (Cursive0)


#### 5.9.1. Capability Access

CapClass = {`FileSystem`, `HeapAllocator`, `ExecutionDomain`, `Reactor`}
CapType(Cl) = TypeDynamic(Cl)

ReactorMethodParams = [âŸ¨`T`, [], âŠ¥, âŠ¥âŸ©, âŸ¨`E`, [], âŠ¥, âŠ¥âŸ©]
ReactorMethods = [
  ClassMethodDecl(âŠ¥, `public`, "run", ReactorMethodParams, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `future`, TypeApply(["Future"], [TypePath(["T"]), TypePath(["E"])])âŸ©], TypeUnion([TypePath(["T"]), TypePath(["E"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  ClassMethodDecl(âŠ¥, `public`, "register", ReactorMethodParams, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `future`, TypeApply(["Future"], [TypePath(["T"]), TypePath(["E"])])âŸ©], TypeApply(["Tracked"], [TypePath(["T"]), TypePath(["E"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
ReactorMethodNames = { m.name | m âˆˆ ReactorMethods }
ReactorDecl = ClassDecl(âŠ¥, `public`, false, `Reactor`, âŠ¥, âŠ¥, [], ReactorMethods, âŠ¥, âŠ¥)
Î£.Classes["Reactor"] = ReactorDecl

CapMethodSig(`FileSystem`, name) = âŸ¨params, retâŸ© â‡” âŸ¨name, recv, params, retâŸ© âˆˆ FileSystemInterface
CapMethodSig(`HeapAllocator`, name) = âŸ¨params, retâŸ© â‡” âŸ¨name, recv, params, retâŸ© âˆˆ HeapAllocatorInterface
CapMethodSig(`Reactor`, name) = âŸ¨params, retâŸ© â‡” LookupClassMethod(`Reactor`, name) = m âˆ§ Sig_T(SelfVar, m) = âŸ¨_, params, retâŸ©
CapRecv(`FileSystem`, name) = recv â‡” âŸ¨name, recv, params, retâŸ© âˆˆ FileSystemInterface
CapRecv(`HeapAllocator`, name) = recv â‡” âŸ¨name, recv, params, retâŸ© âˆˆ HeapAllocatorInterface
CapRecv(`Reactor`, name) = recv â‡” LookupClassMethod(`Reactor`, name) = m âˆ§ RecvPerm(SelfVar, m.receiver) = recv


#### 5.9.2. `FileSystem` Capability Class

BuiltinTypes_FS = {`File`, `DirIter`, `DirEntry`, `FileKind`, `IoError`}

FileSystemInterface =
{
 âŸ¨"open_read", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeModalState(["File"], `@Read`), TypePath(["IoError"])])âŸ©,
 âŸ¨"open_write", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeModalState(["File"], `@Write`), TypePath(["IoError"])])âŸ©,
 âŸ¨"open_append", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeModalState(["File"], `@Append`), TypePath(["IoError"])])âŸ©,
 âŸ¨"create_write", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeModalState(["File"], `@Write`), TypePath(["IoError"])])âŸ©,
 âŸ¨"read_file", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeString(`@Managed`), TypePath(["IoError"])])âŸ©,
 âŸ¨"read_bytes", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeBytes(`@Managed`), TypePath(["IoError"])])âŸ©,
 âŸ¨"write_file", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©, âŸ¨âŠ¥, `data`, TypeBytes(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"write_stdout", ~, [âŸ¨âŠ¥, `data`, TypeString(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"write_stderr", ~, [âŸ¨âŠ¥, `data`, TypeString(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"exists", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypePrim("bool")âŸ©,
 âŸ¨"remove", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"open_dir", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypeModalState(["DirIter"], `@Open`), TypePath(["IoError"])])âŸ©,
 âŸ¨"create_dir", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"ensure_dir", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])])âŸ©,
 âŸ¨"kind", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeUnion([TypePath(["FileKind"]), TypePath(["IoError"])])âŸ©,
 âŸ¨"restrict", ~, [âŸ¨âŠ¥, `path`, TypeString(`@View`)âŸ©], TypeDynamic(`FileSystem`)âŸ©
}

FileKindVariants = [
  VariantDecl(`File`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`Dir`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`Other`, âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
FileKindDecl = EnumDecl(âŠ¥, `public`, `FileKind`, âŠ¥, âŠ¥, [], FileKindVariants, âŠ¥, âŠ¥, âŠ¥)

IoErrorVariants = [
  VariantDecl(`NotFound`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`PermissionDenied`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`AlreadyExists`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`InvalidPath`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`Busy`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`IoFailure`, âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
IoErrorDecl = EnumDecl(âŠ¥, `public`, `IoError`, âŠ¥, âŠ¥, [], IoErrorVariants, âŠ¥, âŠ¥, âŠ¥)

DirEntryFields = [
  âŸ¨âŠ¥, `public`, false, `name`, TypeString(`@Managed`), âŠ¥, âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `path`, TypeString(`@Managed`), âŠ¥, âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `kind`, TypePath(["FileKind"]), âŠ¥, âŠ¥, âŠ¥âŸ©
]
DirEntryDecl = RecordDecl(âŠ¥, `public`, `DirEntry`, âŠ¥, âŠ¥, [], DirEntryFields, âŠ¥, âŠ¥, âŠ¥)

DirIterOpenMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `handle`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "next", âŠ¥, ReceiverShorthand(`const`), [], TypeUnion([TypePath(["DirEntry"]), TypePrim("()"), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  TransitionDecl(âŠ¥, `public`, "close", [], `@Closed`, âŠ¥, âŠ¥, âŠ¥)
]
DirIterClosedMembers = []
DirIterStates = [
  StateBlock(`@Open`, DirIterOpenMembers, âŠ¥, âŠ¥),
  StateBlock(`@Closed`, DirIterClosedMembers, âŠ¥, âŠ¥)
]
DirIterDecl = ModalDecl(âŠ¥, `public`, `DirIter`, âŠ¥, âŠ¥, [], DirIterStates, âŠ¥, âŠ¥, âŠ¥)

FileReadMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `handle`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "read_all", âŠ¥, ReceiverShorthand(`const`), [], TypeUnion([TypeString(`@Managed`), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "read_all_bytes", âŠ¥, ReceiverShorthand(`const`), [], TypeUnion([TypeBytes(`@Managed`), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  TransitionDecl(âŠ¥, `public`, "close", [], `@Closed`, âŠ¥, âŠ¥, âŠ¥)
]
FileWriteMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `handle`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "write", âŠ¥, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `data`, TypeBytes(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "flush", âŠ¥, ReceiverShorthand(`const`), [], TypeUnion([TypePrim("()"), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  TransitionDecl(âŠ¥, `public`, "close", [], `@Closed`, âŠ¥, âŠ¥, âŠ¥)
]
FileAppendMembers = [
  StateFieldDecl(âŠ¥, `public`, false, `handle`, TypePrim("usize"), âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "write", âŠ¥, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `data`, TypeBytes(`@View`)âŸ©], TypeUnion([TypePrim("()"), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  StateMethodDecl(âŠ¥, `public`, "flush", âŠ¥, ReceiverShorthand(`const`), [], TypeUnion([TypePrim("()"), TypePath(["IoError"])]), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  TransitionDecl(âŠ¥, `public`, "close", [], `@Closed`, âŠ¥, âŠ¥, âŠ¥)
]
FileClosedMembers = []
FileStates = [
  StateBlock(`@Read`, FileReadMembers, âŠ¥, âŠ¥),
  StateBlock(`@Write`, FileWriteMembers, âŠ¥, âŠ¥),
  StateBlock(`@Append`, FileAppendMembers, âŠ¥, âŠ¥),
  StateBlock(`@Closed`, FileClosedMembers, âŠ¥, âŠ¥)
]
FileDecl = ModalDecl(âŠ¥, `public`, `File`, âŠ¥, âŠ¥, [], FileStates, âŠ¥, âŠ¥, âŠ¥)

RecordDecl(["DirEntry"]) = DirEntryDecl
EnumDecl(["FileKind"]) = FileKindDecl
EnumDecl(["IoError"]) = IoErrorDecl
Î£.Types["DirEntry"] = DirEntryDecl
Î£.Types["FileKind"] = FileKindDecl
Î£.Types["IoError"] = IoErrorDecl
Î£.Types["DirIter"] = `modal` DirIterDecl
Î£.Types["File"] = `modal` FileDecl

**(Record-FileDir-Err)**
ModalRefPath(modal_ref) âˆˆ {["File"], ["DirIter"], ["CancelToken"], ["Spawned"], ["Tracked"], ["Async"]}    c = Code(Record-FileDir-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RecordExpr(ModalStateRef(modal_ref, S), fields) â‡‘ c

#### 5.9.3. `HeapAllocator` Capability Class

HeapAllocatorInterface =
{
 âŸ¨"with_quota", ~!, [âŸ¨âŠ¥, `size`, TypePrim("usize")âŸ©], TypeDynamic(`HeapAllocator`)âŸ©,
 âŸ¨"alloc_raw", ~, [âŸ¨âŠ¥, `count`, TypePrim("usize")âŸ©], TypeRawPtr(`mut`, TypePrim("u8"))âŸ©,
 âŸ¨"dealloc_raw", ~, [âŸ¨âŠ¥, `ptr`, TypeRawPtr(`mut`, TypePrim("u8"))âŸ©, âŸ¨âŠ¥, `count`, TypePrim("usize")âŸ©], TypePrim("()")âŸ©
}

**(AllocRaw-Unsafe-Err)**
Î“; R; L âŠ¢ base : TypeDynamic(`HeapAllocator`)    Â¬ UnsafeSpan(span(MethodCall(base, "alloc_raw", args)))    c = Code(AllocRaw-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, "alloc_raw", args) â‡‘ c

**(DeallocRaw-Unsafe-Err)**
Î“; R; L âŠ¢ base : TypeDynamic(`HeapAllocator`)    Â¬ UnsafeSpan(span(MethodCall(base, "dealloc_raw", args)))    c = Code(DeallocRaw-Unsafe-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ MethodCall(base, "dealloc_raw", args) â‡‘ c

AllocationErrorVariants = [
  VariantDecl(`OutOfMemory`, TuplePayload([TypePrim("usize")]), âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`QuotaExceeded`, TuplePayload([TypePrim("usize")]), âŠ¥, âŠ¥, âŠ¥)
]
AllocationErrorDecl = EnumDecl(âŠ¥, `public`, `AllocationError`, âŠ¥, âŠ¥, [], AllocationErrorVariants, âŠ¥, âŠ¥, âŠ¥)
EnumDecl(["AllocationError"]) = AllocationErrorDecl
Î£.Types["AllocationError"] = AllocationErrorDecl
AllocErrorVal(r) â‡” âˆƒ s. r = EnumValue(["AllocationError", "OutOfMemory"], TuplePayload([s])) âˆ¨ r = EnumValue(["AllocationError", "QuotaExceeded"], TuplePayload([s]))

#### 5.9.4. `Context` Record (Cursive0)

ContextFields = [
  âŸ¨âŠ¥, `public`, false, `fs`, TypeDynamic(`FileSystem`), âŠ¥, âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `heap`, TypeDynamic(`HeapAllocator`), âŠ¥, âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `sys`, TypePath(["System"]), âŠ¥, âŠ¥, âŠ¥âŸ©,
  âŸ¨âŠ¥, `public`, false, `reactor`, TypeDynamic(`Reactor`), âŠ¥, âŠ¥, âŠ¥âŸ©
]
ContextMethods = [
  MethodDecl(âŠ¥, `public`, false, "cpu", âŠ¥, ReceiverShorthand(`const`), [], TypeDynamic(`ExecutionDomain`), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  MethodDecl(âŠ¥, `public`, false, "gpu", âŠ¥, ReceiverShorthand(`const`), [], TypeDynamic(`ExecutionDomain`), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  MethodDecl(âŠ¥, `public`, false, "inline", âŠ¥, ReceiverShorthand(`const`), [], TypeDynamic(`ExecutionDomain`), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
ContextMembers = ContextFields ++ ContextMethods
ContextDecl = RecordDecl(âŠ¥, `public`, `Context`, âŠ¥, âŠ¥, [], ContextMembers, âŠ¥, âŠ¥, âŠ¥)

SystemInterface =
{
 âŸ¨"exit", [âŸ¨âŠ¥, `code`, TypePrim("i32")âŸ©], TypePrim("!")âŸ©,
 âŸ¨"get_env", [âŸ¨âŠ¥, `key`, TypeString(`@View`)âŸ©], TypeString(âŠ¥)âŸ©
}
SystemMembers = [
  MethodDecl(âŠ¥, `public`, false, "exit", âŠ¥, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `code`, TypePrim("i32")âŸ©], TypePrim("!"), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  MethodDecl(âŠ¥, `public`, false, "get_env", âŠ¥, ReceiverShorthand(`const`), [âŸ¨âŠ¥, `key`, TypeString(`@View`)âŸ©], TypeString(âŠ¥), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
SystemDecl = RecordDecl(âŠ¥, `public`, `System`, âŠ¥, âŠ¥, [], SystemMembers, âŠ¥, âŠ¥, âŠ¥)
SystemMethodSig(name) = âŸ¨params, retâŸ© â‡” âŸ¨name, params, retâŸ© âˆˆ SystemInterface

RecordDecl(["Context"]) = ContextDecl
RecordDecl(["System"]) = SystemDecl
Î£.Types["Context"] = ContextDecl
Î£.Types["System"] = SystemDecl
BuiltInContext(T) â‡” T = TypePath(["Context"]) âˆ§ RecordDecl(["Context"]) = ContextDecl

CpuSetDecl = TypeAliasDecl(âŠ¥, `public`, `CpuSet`, âŠ¥, âŠ¥, TypePrim("u64"), âŠ¥, âŠ¥)
PriorityVariants = [
  VariantDecl(`Low`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`Normal`, âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  VariantDecl(`High`, âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
PriorityDecl = EnumDecl(âŠ¥, `public`, `Priority`, âŠ¥, âŠ¥, [], PriorityVariants, âŠ¥, âŠ¥, âŠ¥)

Î£.Types["CpuSet"] = CpuSetDecl
EnumDecl(["Priority"]) = PriorityDecl
Î£.Types["Priority"] = PriorityDecl
### 5.10. Enum Discriminant Defaults

Variants(E) = E.variants
disc_opt(v) = v.discriminant_opt

DiscValue(tok) = IntValue(tok)

DiscOf(v, n) =
 n    if disc_opt(v) = âŠ¥
 DiscValue(tok)    if disc_opt(v) = tok
DiscSeq([], n) = []
DiscSeq(v::vs, n) = [DiscOf(v, n)] ++ DiscSeq(vs, DiscOf(v, n) + 1)

EnumDiscriminants(E) â‡“ ds â‡” ds = DiscSeq(Variants(E), 0) âˆ§ Distinct(ds) âˆ§ âˆ€ d âˆˆ ds. d â‰¥ 0

**(Enum-Disc-NotInt)**
âˆƒ v âˆˆ Variants(E). disc_opt(v) = tok    tok.kind â‰  IntLiteral    c = Code(Enum-Disc-NotInt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumDiscriminants(E) â‡‘ c

**(Enum-Disc-Invalid)**
âˆƒ v âˆˆ Variants(E). disc_opt(v) = tok    DiscValue(tok) undefined    c = Code(Enum-Disc-Invalid)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumDiscriminants(E) â‡‘ c

**(Enum-Disc-Negative)**
âˆƒ v âˆˆ Variants(E). disc_opt(v) = tok    DiscValue(tok) = d    d < 0    c = Code(Enum-Disc-Negative)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumDiscriminants(E) â‡‘ c

**(Enum-Disc-Dup)**
ds = DiscSeq(Variants(E), 0)    Â¬ Distinct(ds)    c = Code(Enum-Disc-Dup)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumDiscriminants(E) â‡‘ c

MaxDisc(E) = max(ds) â‡” EnumDiscriminants(E) â‡“ ds

DiscType(E) =
 `u8`    if 0 â‰¤ MaxDisc(E) â‰¤ 255
 `u16`   if 256 â‰¤ MaxDisc(E) â‰¤ 65,535
 `u32`   if 65,536 â‰¤ MaxDisc(E) â‰¤ 4,294,967,295
 `u64`   otherwise


### 5.11. Foundational Predicates and Classes (Cursive0)

**Built-in Predicate Names.**

PredicateName = {`Bitcopy`, `Clone`, `Drop`, `FfiSafe`}

**Predicate Judgments.**

BitcopyDropJudg = {Î“ âŠ¢ T : BitcopyDropOk}
BitcopyJudg = {BitcopyType}
CloneJudg = {CloneType}
DropJudg = {DropType}

HasCloneMethod(T) â‡” âˆƒ p, R, m. T = TypePath(p) âˆ§ RecordDecl(p) = R âˆ§ m âˆˆ Methods(R) âˆ§ MethodName(m) = `clone` âˆ§ Sig_T(T, m) = âŸ¨TypePerm(`const`, T), [], TâŸ©
HasDropMethod(T) â‡” âˆƒ p, R, m. T = TypePath(p) âˆ§ RecordDecl(p) = R âˆ§ m âˆˆ Methods(R) âˆ§ MethodName(m) = `drop` âˆ§ Sig_T(T, m) = âŸ¨TypePerm(`unique`, T), [], TypePrim("()")âŸ©

CloneType(T) â‡” BuiltinCloneType(T) âˆ¨ HasCloneMethod(StripPerm(T)) âˆ¨ BitcopyType(T)
DropType(T) â‡” BuiltinDropType(T) âˆ¨ HasDropMethod(StripPerm(T))

**(BitcopyDrop-Ok)**
Â¬(BitcopyType(T) âˆ§ DropType(T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : BitcopyDropOk

**(BitcopyDrop-Conflict)**
BitcopyType(T) âˆ§ DropType(T)    c = Code(BitcopyDrop-Conflict)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T : BitcopyDropOk â‡‘ c

BitcopyType(T) â‡” BitcopyTypeCore(T)

BitcopyTypeCore(T) â‡”
 false    if T = TypePerm(`unique`, _)
 BitcopyTypeCore(T_0)    if T = TypePerm(p, T_0) âˆ§ p â‰  `unique`
 BuiltinBitcopyType(T) âˆ¨
 (T = TypeTuple([T_1, â€¦, T_n]) âˆ§ âˆ€ i âˆˆ 1..n, BitcopyType(T_i)) âˆ¨
 (T = TypeArray(T_0, e) âˆ§ Î“ âŠ¢ ConstLen(e) â‡“ _ âˆ§ BitcopyType(T_0)) âˆ¨
 (T = TypeUnion([T_1, â€¦, T_n]) âˆ§ âˆ€ i âˆˆ 1..n, BitcopyType(T_i)) âˆ¨
 (T = TypePath(p) âˆ§ RecordDecl(p) = R âˆ§ âˆ€ f : T_f âˆˆ Fields(R). BitcopyType(T_f)) âˆ¨
 (T = TypePath(p) âˆ§ EnumDecl(p) = E âˆ§ âˆ€ v âˆˆ Variants(E). âˆ€ T_f âˆˆ PayloadTypes(v). BitcopyType(T_f)) âˆ¨
 (T = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ âˆ€ T_f âˆˆ ModalPayload(modal_ref, S). BitcopyType(T_f)) âˆ¨
 (T = ModalRefType(modal_ref) âˆ§ ModalDeclOf(modal_ref) = M âˆ§ âˆ€ S âˆˆ States(M). âˆ€ T_f âˆˆ ModalPayload(modal_ref, S). BitcopyType(T_f))

BuiltinBitcopyType(T) â‡”
 T = TypePrim(t) âˆ§ t âˆˆ PrimTypes_C0 âˆ¨
 T = TypePtr(U, s) âˆ¨
 T = TypeRawPtr(q, U) âˆ¨
 T = TypeSlice(U) âˆ¨
 T = TypeFunc(ps, R) âˆ¨
 T = TypeDynamic(Cl) âˆ¨
 T = TypeRange âˆ¨
 T = TypeString(`@View`) âˆ¨
 T = TypeBytes(`@View`) âˆ¨
 T = TypePath(["FileKind"]) âˆ¨
 T = TypePath(["IoError"]) âˆ¨
 T = TypePath(["Context"]) âˆ¨
 T = TypePath(["System"])

BuiltinDropType(T) â‡” T = TypeString(`@Managed`) âˆ¨ T = TypeBytes(`@Managed`)

BuiltinCloneType(T) â‡” BuiltinBitcopyType(T)

**Class Signatures (built-in).**

```cursive
class Eq {
    procedure eq(~, other: const Self) -> bool
}

class Hasher {
    procedure write(~!, data: bytes@View) -> ()
    procedure finish(~) -> u64
}

class Hash {
    procedure hash(~, hasher: unique Hasher) -> ()
}

class Iterator {
    type Item
    procedure next(~!) -> Self::Item | ()
}

class Step {
    procedure successor(~) -> Self | ()
    procedure predecessor(~) -> Self | ()
}
```

ImplementsEq(T) â‡” `Eq` âˆˆ Implements(T)
ImplementsHash(T) â‡” `Hash` âˆˆ Implements(T)
ImplementsIterator(T) â‡” `Iterator` âˆˆ Implements(T)
ImplementsStep(T) â‡” `Step` âˆˆ Implements(T)
ImplementsHasher(T) â‡” `Hasher` âˆˆ Implements(T)

**Eq Semantics.** `Eq::eq` MUST be reflexive, symmetric, and transitive.

**Hash Semantics.** `Hash` implementations MUST also implement `Eq`. For any values a, b, and any hasher state h, if a~>eq(b) = true, then invoking a~>hash(h) and b~>hash(h) from identical initial hasher states MUST yield identical final hasher states.

**Hasher Semantics.** A `Hasher` maintains an internal state h : `u64`. `write` appends bytes to the input stream; `finish` returns the FNVâ€‘1a 64-bit hash of the concatenated byte stream, using FNVOffset64 and FNVPrime64 as defined in Â§6.3.1.

**Iterator Semantics.** `Iterator::next` returns `Self::Item` while iteration remains, or `()` when exhausted.

**Step Semantics.** `successor` and `predecessor` define a discrete stepping relation. If successor(x) = y, then predecessor(y) = x, and vice versa, when both are defined.

### 5.12. Initialization Planning

**Module Prefix Resolution.**
P = Project(Î“)
m = CurrentModule(Î“)
Modules = P.modules
PathPrefix(path, pref) â‡” âˆƒ rest. path = pref ++ rest

**Alias Expansion.**

**(AliasExpand-None)**
path = a::rest    a âˆ‰ dom(AliasMap(m))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AliasExpand(path, AliasMap(m)) â‡“ path

**(AliasExpand-Yes)**
path = a::rest    a âˆˆ dom(AliasMap(m))    AliasMap(m)[a] = p_a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AliasExpand(path, AliasMap(m)) â‡“ p_a ++ rest

**(ModulePrefix-Direct)**
Î“ âŠ¢ AliasExpand(path, AliasMap(m)) â‡“ path'    âˆƒ p âˆˆ Modules, PathPrefix(path', p)    p = argmax_{q âˆˆ Modules, PathPrefix(path', q)} |q|
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModulePrefix(path, Modules, AliasMap(m)) â‡“ p

**(ModulePrefix-None)**
Î“ âŠ¢ AliasExpand(path, AliasMap(m)) â‡“ path'    Â¬ âˆƒ p âˆˆ Modules. PathPrefix(path', p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModulePrefix(path, Modules, AliasMap(m)) â†‘

env = âŸ¨self, Modules, AliasMap(m), UsingValueMap, UsingTypeMapâŸ©

**(Reachable-Edge)**
(u, v) âˆˆ E
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Reachable(u, v, E)

**(Reachable-Step)**
(u, w) âˆˆ E    Î“ âŠ¢ Reachable(w, v, E)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Reachable(u, v, E)

**Type References.**
FullPath(path, name) = path ++ [name]
EnumPath(path) = p â‡” SplitLast(path) = (p, n)
VariantName(path) = n â‡” SplitLast(path) = (p, n)

TypeRefsJudg = {TypeRefsTy, TypeRefsRef, TypeRefsExpr, TypeRefsPat, TypeRefsArgs}
Modules = env.Modules
Alias = env.Alias
UsingTypeMap = env.UsingTypeMap

**(TypeRef-Path)**
|path| â‰¥ 2    Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ mp    mp â‰  env.self
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ {mp}

**(TypeRef-Using)**
path = [name]    name âˆˆ dom(UsingTypeMap)    UsingTypeMap[name] â‰  env.self
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ {UsingTypeMap[name]}

**(TypeRef-Path-Local)**
(|path| â‰  1 âˆ¨ (path = [name] âˆ§ name âˆ‰ dom(UsingTypeMap)))    (Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡‘ âˆ¨ Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ env.self)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ âˆ…

**(TypeRef-Dynamic)**
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeDynamic(path), env) â‡“ T

**(TypeRef-ModalState)**
Î“ âŠ¢ TypeRefsRef(modal_ref, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeModalState(modal_ref, state), env) â‡“ T

**(TypeRef-Apply)**
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ T_p    âˆ€ i, Î“ âŠ¢ TypeRefsTy(args_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeApply(path, args), env) â‡“ T_p âˆª â‹ƒ_{i=1}^n T_i

**(TypeRef-Perm)**
Î“ âŠ¢ TypeRefsTy(base, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePerm(perm, base), env) â‡“ T

**(TypeRef-Prim)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePrim(_), env) â‡“ âˆ…

**(TypeRef-Tuple)**
âˆ€ i, Î“ âŠ¢ TypeRefsTy(t_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeTuple([t_1, â€¦, t_n]), env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRef-Array)**
Î“ âŠ¢ TypeRefsTy(elem, env) â‡“ T_e    Î“ âŠ¢ TypeRefsExpr(size_expr, env) â‡“ T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeArray(elem, size_expr), env) â‡“ T_e âˆª T_s

**(TypeRef-Slice)**
Î“ âŠ¢ TypeRefsTy(elem, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeSlice(elem), env) â‡“ T

**(TypeRef-Union)**
âˆ€ i, Î“ âŠ¢ TypeRefsTy(t_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeUnion([t_1, â€¦, t_n]), env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRef-Func)**
âˆ€ i, params_i = âŸ¨m_i, t_iâŸ©    Î“ âŠ¢ TypeRefsTy(t_i, env) â‡“ T_i    Î“ âŠ¢ TypeRefsTy(ret, env) â‡“ T_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeFunc([params_1, â€¦, params_n], ret), env) â‡“ (â‹ƒ_{i=1}^n T_i) âˆª T_r

**(TypeRef-String)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeString(_), env) â‡“ âˆ…

**(TypeRef-Bytes)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeBytes(_), env) â‡“ âˆ…

**(TypeRef-Ptr)**
Î“ âŠ¢ TypeRefsTy(elem, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypePtr(elem, _), env) â‡“ T

**(TypeRef-RawPtr)**
Î“ âŠ¢ TypeRefsTy(elem, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeRawPtr(_, elem), env) â‡“ T

**(TypeRef-Range)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsTy(TypeRange, env) â‡“ âˆ…

**(TypeRef-Ref-Path)**
Î“ âŠ¢ TypeRefsTy(TypePath(path), env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsRef(TypePath(path), env) â‡“ T

**(TypeRef-Ref-Apply)**
Î“ âŠ¢ TypeRefsTy(TypeApply(path, args), env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsRef(TypeApply(path, args), env) â‡“ T

**(TypeRef-Ref-ModalState)**
Î“ âŠ¢ TypeRefsTy(TypeModalState(modal_ref, state), env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsRef(ModalStateRef(modal_ref, state), env) â‡“ T

**(TypeRef-RecordExpr)**
Î“ âŠ¢ TypeRefsRef(r, env) â‡“ T_t    Î“ âŠ¢ TypeRefsExprs(fields, env) â‡“ T_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(RecordExpr(r, fields), env) â‡“ T_t âˆª T_e

**(TypeRef-EnumLiteral)**
Î“ âŠ¢ TypeRefsTy(TypePath(EnumPath(path)), env) â‡“ T_t    Î“ âŠ¢ TypeRefsEnumPayload(payload_opt, env) â‡“ T_p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(EnumLiteral(path, payload_opt), env) â‡“ T_t âˆª T_p

**(TypeRef-QualBrace)**
Î“ âŠ¢ TypeRefsTy(TypePath(FullPath(path, name)), env) â‡“ T_t    Î“ âŠ¢ TypeRefsExprs(fields, env) â‡“ T_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(QualifiedApply(path, name, Brace(fields)), env) â‡“ T_t âˆª T_f

**(TypeRef-Cast)**
Î“ âŠ¢ TypeRefsExpr(e, env) â‡“ T_e    Î“ âŠ¢ TypeRefsTy(ty, env) â‡“ T_t
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(Cast(e, ty), env) â‡“ T_e âˆª T_t

**(TypeRef-Transmute)**
Î“ âŠ¢ TypeRefsExpr(e, env) â‡“ T_e    Î“ âŠ¢ TypeRefsTy(t_1, env) â‡“ T_1    Î“ âŠ¢ TypeRefsTy(t_2, env) â‡“ T_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(TransmuteExpr(t_1, t_2, e), env) â‡“ T_e âˆª T_1 âˆª T_2

**(TypeRef-CallTypeArgs)**
Î“ âŠ¢ TypeRefsExpr(callee, env) â‡“ T_c    Î“ âŠ¢ TypeRefsArgs(args, env) â‡“ T_a    âˆ€ i, Î“ âŠ¢ TypeRefsTy(type_args[i], env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(CallTypeArgs(callee, type_args, args), env) â‡“ T_c âˆª T_a âˆª â‹ƒ_{i=1}^n T_i

TypeRefsExprRules = {TypeRef-RecordExpr, TypeRef-EnumLiteral, TypeRef-QualBrace, TypeRef-Cast, TypeRef-Transmute, TypeRef-CallTypeArgs, TypeRef-Expr-Sub}
NoSpecificTypeRefsExpr(e) â‡” Â¬ âˆƒ r âˆˆ TypeRefsExprRules \ {TypeRef-Expr-Sub}. PremisesHold(r, e)

**(TypeRef-Expr-Sub)**
NoSpecificTypeRefsExpr(e)    Children_LTR(e) = [e_1, â€¦, e_n]    âˆ€ i, Î“ âŠ¢ TypeRefsExpr(e_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExpr(e, env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRef-RecordPattern)**
Î“ âŠ¢ TypeRefsTy(TypePath(tp), env) â‡“ T_t    Î“ âŠ¢ TypeRefsFields(fields, env) â‡“ T_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(RecordPattern(tp, fields), env) â‡“ T_t âˆª T_f

**(TypeRef-EnumPattern)**
Î“ âŠ¢ TypeRefsTy(TypePath(tp), env) â‡“ T_t    Î“ âŠ¢ TypeRefsPayload(payload, env) â‡“ T_p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(EnumPattern(tp, _, payload), env) â‡“ T_t âˆª T_p

**(TypeRef-LiteralPattern)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(LiteralPattern(_), env) â‡“ âˆ…

**(TypeRef-WildcardPattern)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(WildcardPattern, env) â‡“ âˆ…

**(TypeRef-IdentifierPattern)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(IdentifierPattern(_), env) â‡“ âˆ…

**(TypeRef-TypedPattern)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(TypedPattern(_, _), env) â‡“ âˆ…

**(TypeRef-TuplePattern)**
âˆ€ i, Î“ âŠ¢ TypeRefsPat(p_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(TuplePattern([p_1, â€¦, p_n]), env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRef-ModalPattern-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(ModalPattern(_, âŠ¥), env) â‡“ âˆ…

**(TypeRef-ModalPattern-Record)**
Î“ âŠ¢ TypeRefsFields(fields, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(ModalPattern(_, ModalRecordPayload(fields)), env) â‡“ T

**(TypeRef-RangePattern)**
Î“ âŠ¢ TypeRefsPat(p_l, env) â‡“ T_l    Î“ âŠ¢ TypeRefsPat(p_h, env) â‡“ T_h
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(RangePattern(_, p_l, p_h), env) â‡“ T_l âˆª T_h

**(TypeRef-Field-Explicit)**
Î“ âŠ¢ TypeRefsPat(p, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(âŸ¨name, pattern_opt=p, spanâŸ©, env) â‡“ T

**(TypeRef-Field-Implicit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPat(âŸ¨name, pattern_opt=âŠ¥, spanâŸ©, env) â‡“ âˆ…

**(TypeRefsExprs-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExprs([], env) â‡“ âˆ…

**(TypeRefsExprs-Cons)**
f = âŸ¨name, eâŸ©    Î“ âŠ¢ TypeRefsExpr(e, env) â‡“ T_e    Î“ âŠ¢ TypeRefsExprs(fs, env) â‡“ T_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsExprs(f::fs, env) â‡“ T_e âˆª T_f

TypeRefsArgsJudg = {TypeRefsArgs}

**(TypeRefsArgs-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsArgs([], env) â‡“ âˆ…

**(TypeRefsArgs-Cons)**
a = âŸ¨moved, e, spanâŸ©    Î“ âŠ¢ TypeRefsExpr(e, env) â‡“ T_e    Î“ âŠ¢ TypeRefsArgs(rest, env) â‡“ T_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsArgs(a::rest, env) â‡“ T_e âˆª T_r

**(TypeRefsEnumPayload-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsEnumPayload(âŠ¥, env) â‡“ âˆ…

**(TypeRefsEnumPayload-Tuple)**
âˆ€ i, Î“ âŠ¢ TypeRefsExpr(e_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsEnumPayload(Paren([e_1, â€¦, e_n]), env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRefsEnumPayload-Record)**
Î“ âŠ¢ TypeRefsExprs(fields, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsEnumPayload(Brace(fields), env) â‡“ T

**(TypeRefsFields-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsFields([], env) â‡“ âˆ…

**(TypeRefsFields-Cons)**
Î“ âŠ¢ TypeRefsPat(f, env) â‡“ T_f    Î“ âŠ¢ TypeRefsFields(fs, env) â‡“ T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsFields(f::fs, env) â‡“ T_f âˆª T_s

**(TypeRefsPayload-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPayload(âŠ¥, env) â‡“ âˆ…

**(TypeRefsPayload-Tuple)**
âˆ€ i, Î“ âŠ¢ TypeRefsPat(p_i, env) â‡“ T_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPayload(TuplePayloadPattern([p_1, â€¦, p_n]), env) â‡“ â‹ƒ_{i=1}^n T_i

**(TypeRefsPayload-Record)**
Î“ âŠ¢ TypeRefsFields(fields, env) â‡“ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TypeRefsPayload(RecordPayloadPattern(fields), env) â‡“ T

**Value References.**

UsingValueMap = env.UsingValueMap
ValueRefsJudg = {ValueRefs, ValueRefsArgs, ValueRefsFields}

**(ValueRef-Ident)**
name âˆˆ dom(UsingValueMap)    UsingValueMap[name] â‰  env.self
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(Identifier(name), env) â‡“ {UsingValueMap[name]}

**(ValueRef-Ident-Local)**
name âˆ‰ dom(UsingValueMap)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(Identifier(name), env) â‡“ âˆ…

**(ValueRef-Qual)**
Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ mp    mp â‰  env.self
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(QualifiedName(path, _), env) â‡“ {mp}

**(ValueRef-Qual-Local)**
Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡‘ âˆ¨ Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ env.self
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(QualifiedName(path, _), env) â‡“ âˆ…

**(ValueRef-QualApply)**
Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ mp    mp â‰  env.self    Î“ âŠ¢ ValueRefsArgs(args, env) â‡“ V_a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(QualifiedApply(path, _, Paren(args)), env) â‡“ {mp} âˆª V_a

**(ValueRef-QualApply-Local)**
(Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡‘ âˆ¨ Î“ âŠ¢ ModulePrefix(path, Modules, Alias) â‡“ env.self)    Î“ âŠ¢ ValueRefsArgs(args, env) â‡“ V_a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(QualifiedApply(path, _, Paren(args)), env) â‡“ V_a

**(ValueRef-QualApply-Brace)**
Î“ âŠ¢ ValueRefsFields(fields, env) â‡“ V_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(QualifiedApply(path, _, Brace(fields)), env) â‡“ V_f

ValueRefsRules = {ValueRef-Ident, ValueRef-Ident-Local, ValueRef-Qual, ValueRef-Qual-Local, ValueRef-QualApply, ValueRef-QualApply-Local, ValueRef-QualApply-Brace, ValueRef-Expr-Sub}
NoSpecificValueRefsExpr(e) â‡” Â¬ âˆƒ r âˆˆ ValueRefsRules \ {ValueRef-Expr-Sub}. PremisesHold(r, e)

**(ValueRef-Expr-Sub)**
NoSpecificValueRefsExpr(e)    Children_LTR(e) = [e_1, â€¦, e_n]    âˆ€ i, Î“ âŠ¢ ValueRefs(e_i, env) â‡“ V_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefs(e, env) â‡“ â‹ƒ_{i=1}^n V_i

**(ValueRefsArgs-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefsArgs([], env) â‡“ âˆ…

**(ValueRefsArgs-Cons)**
a = âŸ¨moved, e, spanâŸ©    Î“ âŠ¢ ValueRefs(e, env) â‡“ V_e    Î“ âŠ¢ ValueRefsArgs(args, env) â‡“ V_a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefsArgs(a::args, env) â‡“ V_e âˆª V_a

**(ValueRefsFields-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefsFields([], env) â‡“ âˆ…

**(ValueRefsFields-Cons)**
f = âŸ¨name, eâŸ©    Î“ âŠ¢ ValueRefs(e, env) â‡“ V_e    Î“ âŠ¢ ValueRefsFields(fs, env) â‡“ V_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ValueRefsFields(f::fs, env) â‡“ V_e âˆª V_f

**Dependency Sets.**

env_m = âŸ¨self=m, Modules=P.modules, Alias_m, UsingValueMap_m, UsingTypeMap_mâŸ©
Alias_m = AliasMap(m)
UsingValueMap_m = UsingValueMap(m)
UsingTypeMap_m = UsingTypeMap(m)
ASTModule(P, m) = ModuleMap(P, m)

TypeOptSet(âŠ¥) = âˆ…
TypeOptSet(T) = {T}
ParamTypeSet(params) = { t | âˆƒ mode, name. âŸ¨mode, name, tâŸ© âˆˆ params }
RecvTypeSet(ReceiverExplicit(_, t)) = {t}
RecvTypeSet(ReceiverShorthand(_)) = âˆ…
ClassPathTypeSet(paths) = { TypePath(p) | p âˆˆ paths }

RecordFieldTypeSet(members) = { t | âˆƒ attrs, vis, boundary, name, init, span, doc. FieldDecl(attrs, vis, boundary, name, t, init, span, doc) âˆˆ members }
RecordMethodRecvTypes(members) = { t | âˆƒ attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc. MethodDecl(attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ members âˆ§ t âˆˆ RecvTypeSet(recv) }
RecordMethodParamTypes(members) = { t | âˆƒ attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc. MethodDecl(attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ members âˆ§ t âˆˆ ParamTypeSet(params) }
RecordMethodRetTypes(members) = { t | âˆƒ attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc. MethodDecl(attrs, vis, ov, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ members âˆ§ t âˆˆ TypeOptSet(ret) }
RecordMemberTypeSet(members) = RecordFieldTypeSet(members) âˆª RecordMethodRecvTypes(members) âˆª RecordMethodParamTypes(members) âˆª RecordMethodRetTypes(members)

ClassFieldTypeSet(items) = { t | âˆƒ attrs, vis, boundary, name, span, doc. ClassFieldDecl(attrs, vis, boundary, name, t, span, doc) âˆˆ items }
ClassMethodRecvTypes(items) = { t | âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ items âˆ§ t âˆˆ RecvTypeSet(recv) }
ClassMethodParamTypes(items) = { t | âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ items âˆ§ t âˆˆ ParamTypeSet(params) }
ClassMethodRetTypes(items) = { t | âˆƒ attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc. ClassMethodDecl(attrs, vis, name, gen_params, recv, params, ret, contract, body, span, doc) âˆˆ items âˆ§ t âˆˆ TypeOptSet(ret) }
ClassItemTypeSet(items) = ClassFieldTypeSet(items) âˆª ClassMethodRecvTypes(items) âˆª ClassMethodParamTypes(items) âˆª ClassMethodRetTypes(items)

VariantPayloadTypeSet(âŠ¥) = âˆ…
VariantPayloadTypeSet(TuplePayload(tys)) = { t | t âˆˆ tys }
VariantPayloadTypeSet(RecordPayload(fields)) = { t | âˆƒ attrs, vis, boundary, name, init, span, doc. FieldDecl(attrs, vis, boundary, name, t, init, span, doc) âˆˆ fields }
EnumVariantTypeSet(variants) = { t | âˆƒ name, payload, disc, span, doc. VariantDecl(name, payload, disc, span, doc) âˆˆ variants âˆ§ t âˆˆ VariantPayloadTypeSet(payload) }

TypePos_Static(P, m) = { t | âˆƒ attrs, vis, mut, bind, span, doc. âŸ¨StaticDecl, attrs, vis, mut, bind, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ bind.type_opt = t âˆ§ t â‰  âŠ¥ }
TypePos_Proc(P, m) = { t | âˆƒ vis, name, params, ret, body, span, doc. âŸ¨ProcedureDecl, vis, name, params, ret, body, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t âˆˆ (ParamTypeSet(params) âˆª TypeOptSet(ret)) }
TypePos_Record(P, m) = { t | âˆƒ vis, name, impls, members, span, doc. âŸ¨RecordDecl, vis, name, impls, members, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t âˆˆ (ClassPathTypeSet(impls) âˆª RecordMemberTypeSet(members)) }
TypePos_Enum(P, m) = { t | âˆƒ vis, name, impls, variants, span, doc. âŸ¨EnumDecl, vis, name, impls, variants, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t âˆˆ (ClassPathTypeSet(impls) âˆª EnumVariantTypeSet(variants)) }
TypePos_Modal(P, m) = { t | âˆƒ vis, name, impls, states, span, doc. âŸ¨ModalDecl, vis, name, impls, states, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t âˆˆ ClassPathTypeSet(impls) }
TypePos_Class(P, m) = { t | âˆƒ vis, name, supers, items, span, doc. âŸ¨ClassDecl, vis, name, supers, items, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t âˆˆ (ClassPathTypeSet(supers) âˆª ClassItemTypeSet(items)) }
TypePos_Alias(P, m) = { t | âˆƒ vis, name, ty, span, doc. âŸ¨TypeAliasDecl, vis, name, ty, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ t = ty }
TypePositions(P, m) = TypePos_Static(P, m) âˆª TypePos_Proc(P, m) âˆª TypePos_Record(P, m) âˆª TypePos_Enum(P, m) âˆª TypePos_Modal(P, m) âˆª TypePos_Class(P, m) âˆª TypePos_Alias(P, m)

ArraySizeExprs(P, m) = { e | âˆƒ elem. TypeArray(elem, e) âˆˆ TypePositions(P, m) }
EnumDiscriminantExprs(P, m) = { e | âˆƒ vis, name, impls, variants, span, doc. âŸ¨EnumDecl, vis, name, impls, variants, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ âˆƒ v. v = VariantDecl(_, _, e, _, _) âˆˆ variants âˆ§ e â‰  âŠ¥ }
TypePosExprs(P, m) = ArraySizeExprs(P, m) âˆª EnumDiscriminantExprs(P, m)

Elems(v) =
 {v}    if v âˆˆ ASTNode
 {x | x âˆˆ v âˆ§ x âˆˆ ASTNode}    if v âˆˆ [_]
 âˆ…    if v = âŠ¥
 âˆ…    otherwise
Child(x, y) â‡” âˆƒ C, a_1, â€¦, a_k. x = C(a_1, â€¦, a_k) âˆ§ y âˆˆ â‹ƒ_{i=1}^k Elems(a_i)
E_child = { (x, y) | Child(x, y) }
Subnode(x, y) â‡” x = y âˆ¨ Î“ âŠ¢ Reachable(x, y, E_child)
ExprNodes(P, m) = { e | e âˆˆ Expr âˆ§ Subnode(ASTModule(P, m), e) }
PatNodes(P, m) = { p | p âˆˆ Pattern âˆ§ Subnode(ASTModule(P, m), p) }
ExprNodesOf(x) = { e | e âˆˆ Expr âˆ§ Subnode(x, e) }

TypeDeps(P, m) = { n | âˆƒ t âˆˆ TypePositions(P, m). Î“ âŠ¢ TypeRefsTy(t, env_m) â‡“ T âˆ§ n âˆˆ T } âˆª { n | âˆƒ p âˆˆ PatNodes(P, m). Î“ âŠ¢ TypeRefsPat(p, env_m) â‡“ T âˆ§ n âˆˆ T } âˆª { n | âˆƒ e âˆˆ (ExprNodes(P, m) âˆª TypePosExprs(P, m)). Î“ âŠ¢ TypeRefsExpr(e, env_m) â‡“ T âˆ§ n âˆˆ T }

StaticInitExprs(P, m) = { init | âˆƒ attrs, vis, mut, bind, span, doc. âŸ¨StaticDecl, attrs, vis, mut, bind, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ bind.init = init }
RecordFieldInitExprs(P, m) = { init | âˆƒ attrs, vis, name, gen_params, where_clause, impls, members, invariant, span, doc. âŸ¨RecordDecl, attrs, vis, name, gen_params, where_clause, impls, members, invariant, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ âˆƒ f. f = FieldDecl(_, _, _, _, _, init, _, _) âˆˆ members âˆ§ init â‰  âŠ¥ }
ProcBodies(P, m) = { body | âˆƒ attrs, vis, name, gen_params, where_clause, params, ret, contract, body, span, doc. âŸ¨ProcedureDecl, attrs, vis, name, gen_params, where_clause, params, ret, contract, body, span, docâŸ© âˆˆ ASTModule(P, m).items }
RecordMethodBodies(P, m) = { body | âˆƒ attrs, vis, name, gen_params, where_clause, impls, members, invariant, span, doc. âŸ¨RecordDecl, attrs, vis, name, gen_params, where_clause, impls, members, invariant, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ âˆƒ md. md = MethodDecl(_, _, _, _, _, _, _, _, _, body, _, _) âˆˆ members }
ClassMethodBodies(P, m) = { body | âˆƒ attrs, vis, modal, name, gen_params, where_clause, supers, items, span, doc. âŸ¨ClassDecl, attrs, vis, modal, name, gen_params, where_clause, supers, items, span, docâŸ© âˆˆ ASTModule(P, m).items âˆ§ âˆƒ md. md = ClassMethodDecl(_, _, _, _, _, _, _, _, body, _, _) âˆˆ items âˆ§ body â‰  âŠ¥ }

ValueDepsEager(P, m) = { n | âˆƒ e âˆˆ StaticInitExprs(P, m). Î“ âŠ¢ ValueRefs(e, env_m) â‡“ V âˆ§ n âˆˆ V }
ValueDepsLazy(P, m) = { n | âˆƒ e âˆˆ RecordFieldInitExprs(P, m) âˆª â‹ƒ_{b âˆˆ (ProcBodies(P, m) âˆª RecordMethodBodies(P, m) âˆª ClassMethodBodies(P, m))} ExprNodesOf(b). Î“ âŠ¢ ValueRefs(e, env_m) â‡“ V âˆ§ n âˆˆ V }

**Dependency Graph.**

V = Modules

E_type = {(m, n) | n âˆˆ TypeDeps(P, m)}
E_val^{eager} = {(m, n) | n âˆˆ ValueDepsEager(P, m)}
E_val^{lazy} = {(m, n) | n âˆˆ ValueDepsLazy(P, m)}

G = âŸ¨V, E_type, E_val^{eager}, E_val^{lazy}âŸ©
G_e = âŸ¨V, E_val^{eager}âŸ©

**(WF-Acyclic-Eager)**
âˆ€ v âˆˆ V, Â¬ Reachable(v, v, E_val^{eager})
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ G_e : DAG

### 5.13 Attributes and Metadata

#### 5.13.1 Attribute registry and placement

Attribute syntax is defined in Â§3.3.4.
Malformed attribute syntax is ill-formed (`E-MOD-2450`).

AttrTarget = {Record, Enum, Modal, Procedure, Field, Binding, Expression, ExternBlock, TypeAlias}

AttrRegistry = R_spec âŠŽ R_vendor
R_vendor = âˆ…

R_spec = {
  layout, inline, cold, static_dispatch_only, deprecated,
  dynamic, stale_ok,
  relaxed, acquire, release, acqrel, seqcst,
  static, assume, trust,
  symbol, library, no_mangle, unwind,
  reflect, derive, emit, files,
  export, ffi_pass_by_value
}

AttrTargets(layout) = {Record, Enum}
AttrTargets(inline) = {Procedure}
AttrTargets(cold) = {Procedure}
AttrTargets(static_dispatch_only) = {Procedure}
AttrTargets(deprecated) = {Record, Enum, Modal, Procedure, Field, Binding, TypeAlias}
AttrTargets(dynamic) = {Record, Enum, Modal, Procedure, Expression}
AttrTargets(stale_ok) = {Binding}
AttrTargets(relaxed) = {Expression}
AttrTargets(acquire) = {Expression}
AttrTargets(release) = {Expression}
AttrTargets(acqrel) = {Expression}
AttrTargets(seqcst) = {Expression}
AttrTargets(static) = {Procedure}
AttrTargets(assume) = {Procedure}
AttrTargets(trust) = {Procedure, ExternBlock}
AttrTargets(symbol) = {Procedure}
AttrTargets(library) = {ExternBlock}
AttrTargets(no_mangle) = {Procedure}
AttrTargets(unwind) = {Procedure}
AttrTargets(reflect) = {Record, Enum, Modal}
AttrTargets(derive) = {Record, Enum, Modal}
AttrTargets(emit) = {Expression}
AttrTargets(files) = {Expression}
AttrTargets(export) = {Procedure}
AttrTargets(ffi_pass_by_value) = {Record, Enum}

AttrListJudg = {AttrListWf}

**(AttrList-Ok)**
A = [a_1, â€¦, a_n]    âˆ€ i, a_i = âŸ¨name_i, args_iâŸ©    âˆ€ i, name_i âˆˆ R_spec âˆª R_vendor    âˆ€ i, Ï„ âˆˆ AttrTargets(name_i)    âˆ€ i, AttrArgsOk(name_i, args_i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttrListWf(A, Ï„) â‡“ ok

**(AttrList-Unknown)**
A = [a_1, â€¦, a_n]    âˆƒ i, a_i = âŸ¨name_i, _âŸ© âˆ§ name_i âˆ‰ R_spec âˆª R_vendor
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttrListWf(A, Ï„) â‡‘ c    c = Code(Attr-Unknown)

**(AttrList-Target-Err)**
A = [a_1, â€¦, a_n]    âˆƒ i, a_i = âŸ¨name_i, _âŸ© âˆ§ name_i âˆˆ R_spec âˆª R_vendor âˆ§ Ï„ âˆ‰ AttrTargets(name_i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AttrListWf(A, Ï„) â‡‘ c    c = Code(Attr-Target-Err)

AttrArgsOk(name, args) â‡” args satisfy the attribute-specific grammar and constraints in Â§Â§5.13.3â€“5.13.6, or the vendor-defined schema for name âˆˆ R_vendor.
Memory-order attributes are well-formed only when attached to key blocks or expressions that contain key acquisition.

For every declaration or expression with an attribute list A and target kind Ï„, the implementation MUST check Î“ âŠ¢ AttrListWf(A, Ï„) â‡“ ok.

**Placement.** An attribute list MUST appear immediately before the declaration or expression it modifies. Multiple attribute lists on the same target are equivalent to a single list with concatenated entries in source order. Attribute application order is left-to-right in that concatenated list.

**Deferred attributes.** `reflect`, `derive`, `emit`, and `files` require compile-time execution and are deferred in Cursive0 (Phase 2). Their use is rejected as Unsupported-Construct.

**Export and FFI pass-by-value attributes.** `export` and `ffi_pass_by_value` are defined in Â§5.13.6.

#### 5.13.2 Vendor-defined attributes

Vendor-defined attributes in R_vendor MUST use reverse-domain prefixes (`com.vendor.name`). The `cursive.*` namespace is reserved for specification-defined attributes.

Cursive0 defines R_vendor = âˆ…. Any attribute name not in R_spec is rejected as unknown.

#### 5.13.3 Layout attributes

**Syntax**

```ebnf
layout_attribute ::= "[[" "layout" "(" layout_args ")" "]]"
layout_args      ::= layout_kind ("," layout_kind)*
layout_kind      ::= "C" | "packed" | "align" "(" integer_literal ")" | int_type
int_type         ::= "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64"
```

**`[[layout(C)]]`.** Specifies C-compatible memory layout.

For `record` declarations:
1. Fields MUST be laid out in declaration order.
2. Padding MUST be inserted only as required by the target platform's C ABI.
3. Total size MUST be a multiple of the record's alignment.

For `enum` declarations:
1. The discriminant MUST be represented as a C-compatible integer tag.
2. Default tag type is `DiscType(E)` as defined in Â§5.10.
3. Layout MUST conform to a tagged union per the target C ABI.

**`[[layout(IntType)]]` (explicit discriminant).** For an `enum` marked `[[layout(IntType)]]` where `IntType` is `i8`â€“`i64` or `u8`â€“`u64`:
1. The discriminant MUST use the specified integer type.
2. Each variant's discriminant value MUST be representable in that type.
3. This form is valid only on `enum` declarations.

**`[[layout(packed)]]`.** Removes inter-field padding.

For a `record` marked `[[layout(packed)]]`:
1. All inter-field padding is removed.
2. Each field MUST be laid out with alignment 1.
3. The record's overall alignment becomes 1.

Taking a reference to a packed field MUST occur within an `unsafe` block. Outside `unsafe`, the program is ill-formed (`Packed-Field-Unsafe-Err`).

**`[[layout(align(N))]]`.** Sets a minimum alignment.

1. N MUST be a positive integer that is a power of two.
2. Effective alignment is max(N, natural alignment).
3. If N < natural alignment, natural alignment is used.
4. Type size is padded to a multiple of the effective alignment.

**Compile-time layout verification.**

Valid combinations:
- `layout(C)`
- `layout(packed)`
- `layout(align(N))`
- `layout(C, packed)`
- `layout(C, align(N))`
- `layout(u8)` (enum)

Invalid combinations:
- `layout(packed, align(N))`

Applicability constraints:
- `record`: `C`, `packed`, `align(N)`
- `enum`: `C`, `align(N)`, `IntType`
- `modal`: none
- generic (unmonomorphized): none

**Constraints**
1. `layout(packed)` applied to a non-`record` declaration is ill-formed (`E-MOD-2454`).
2. `layout(align(N))` where N is not a power of two is ill-formed (`E-MOD-2453`).
3. Conflicting layout arguments (including `layout(packed, align(N))`) are ill-formed (`E-MOD-2455`).
4. `layout(align(N))` where N < natural alignment emits warning `W-MOD-2451`.

#### 5.13.4 Optimization hints

**Syntax**

```ebnf
inline_attribute ::= "[[" "inline" ("(" inline_mode ")")? "]]"
inline_mode      ::= "always" | "never" | "default"

cold_attribute   ::= "[[" "cold" "]]"
```

**`[[inline]]`.** The implementation SHOULD inline the procedure at call sites when feasible.

**`[[inline(always)]]`.** The implementation SHOULD inline the procedure at all call sites. If inlining is not possible (recursive, address taken), the implementation SHOULD emit warning `W-MOD-2452`.

**`[[inline(default)]]`.** Equivalent to omitting the attribute.

**`[[inline(never)]]`.** The implementation MUST NOT inline the procedure. The procedure body MUST be emitted as a separate callable unit.

**`[[cold]]`.** Marks a procedure as unlikely to execute during typical runs. The implementation MAY use this as an optimization hint.

#### 5.13.5 Diagnostics and metadata attributes

**`[[deprecated]]`.** Marks a declaration as deprecated. When referenced, the implementation MUST emit warning `W-CNF-0601`. If a message argument is present, the diagnostic SHOULD include it.

**`[[dynamic]]`.** Marks a declaration or expression as requiring runtime verification when static verification is insufficient.

Scope determination:
1. e is within a `[[dynamic]]` scope if it is enclosed by a `[[dynamic]]` declaration, or by an attributed expression.
2. Scope is lexical and does not propagate through procedure calls.

**Formal Scope Definition**

ExprAttrList(e) = A    if ExprAttrs(e) = A
ExprAttrList(e) = []   if ExprAttrs(e) = âŠ¥
ExprAttrByName(e, n) = [a | a âˆˆ ExprAttrList(e) âˆ§ a.name = n]
DynamicDecl(d) â‡” AttrByName(d, "dynamic") â‰  []
DynamicExpr(e) â‡” ExprAttrByName(e, "dynamic") â‰  []
DynamicScope(s) â‡” (âˆƒ d. DynamicDecl(d) âˆ§ s âŠ† d.span) âˆ¨ (âˆƒ e. DynamicExpr(e) âˆ§ s âŠ† ExprSpan(e))
InDynamicContext â‡” DynamicScope(s) where s is the span of the syntactic form currently being verified or type-checked.

Effects:
- Key System: runtime synchronization MAY be inserted when static key verification fails (see Â§17.6).
- Contracts: runtime checks MAY be inserted when predicates are not provable (see Â§14.7).
- Refinement types: runtime checks MAY be inserted when predicates are not provable (see Â§13.7).

**Dynamic Target Restrictions**
1. `[[dynamic]]` applied to a contract predicate expression is ill-formed (`E-CON-0410`).
2. `[[dynamic]]` applied to a `type` alias declaration is ill-formed (`E-CON-0411`).
3. `[[dynamic]]` applied to a field declaration is ill-formed (`E-CON-0412`).

If a `[[dynamic]]` scope results in no runtime checks or runtime synchronization, the implementation SHOULD emit warning `W-CON-0401`.

**`[[static_dispatch_only]]`.** Excludes a class procedure from dynamic dispatch. Dispatchability and vtable eligibility are defined in Â§13.5.

**`[[stale_ok]]`.** Suppresses staleness warnings for bindings derived from `shared` data across `release` or `yield release` boundaries (see Â§17.4). Valid only on `let` and `var` bindings.

**Verification-mode attributes.** `[[static]]`, `[[assume]]`, and `[[trust]]` are interpreted only in foreign-contract contexts. Semantics are defined in Â§21.4. `[[dynamic]]` reuses the dynamic verification mode defined above.

#### 5.13.6 FFI attributes

##### 5.13.6.1 `[[symbol]]`

**Syntax**

```ebnf
symbol_attribute ::= "[[" "symbol" "(" string_literal ")" "]]"
```

**Static Semantics**

1. Valid only on extern procedure declarations and exported procedures.
2. The string argument specifies the exact linker symbol name.
3. The symbol name MUST be non-empty and valid for the target platform's linker.
4. `[[symbol]]` overrides any name from `[[export]]` or `[[no_mangle]]`.
5. `[[symbol]]` and `[[no_mangle]]` MUST NOT both appear on the same declaration.


##### 5.13.6.2 `[[library]]`

**Syntax**

```ebnf
library_attribute ::= "[[" "library" "(" library_args ")" "]]"
library_args      ::= "name" ":" string_literal ("," "kind" ":" string_literal)?
```

**Static Semantics**

**Link Kinds**

| Kind          | Meaning                   |
| :------------ | :------------------------ |
| `"dylib"`     | Dynamic library (default) |
| `"static"`    | Static library            |
| `"framework"` | macOS framework           |
| `"raw-dylib"` | Windows delay-load        |

1. Valid only on `extern` blocks.
2. The `name` argument specifies the library name without platform prefix or suffix.
3. If `kind` is omitted, `"dylib"` is assumed.
4. Platform-specific library resolution applies.


##### 5.13.6.3 `[[no_mangle]]`

**Syntax**

```ebnf
no_mangle_attribute ::= "[[" "no_mangle" "]]"
```

**Static Semantics**

Name mangling uses `ScopedSym` as defined in Â§6.3.1. Applying `[[no_mangle]]` sets the link name to the declaration's identifier without mangling.

1. Valid on extern procedure declarations and exported procedures.
2. Implicit for procedures in `extern "C"` or `extern "C-unwind"` blocks (specifying it is redundant but permitted).
3. `[[no_mangle]]` and `[[symbol]]` MUST NOT both appear on the same declaration.


##### 5.13.6.4 `[[unwind]]`

**Syntax**

```ebnf
unwind_attribute ::= "[[" "unwind" "(" unwind_mode ")" "]]"
unwind_mode      ::= string_literal
```

**Static Semantics**

**Modes**

| Mode      | Behavior                                                                                                                                        |
| :-------- | :---------------------------------------------------------------------------------------------------------------------------------------------- |
| `"abort"` | Any panic or foreign unwind that would cross the boundary aborts.                                                                              |
| `"catch"` | Unwinding is caught at the boundary. Imported procedures convert foreign unwinds to Cursive panics; exported procedures convert panics to an error indicator value (Â§21.2.2). |

If `[[unwind]]` is not specified, `"abort"` is assumed.

`[[unwind]]` is valid only on extern procedure declarations and exported procedures.

**Catch ABI Requirement.**

If `UnwindMode(proc) = "catch"`, the ABI at the boundary MUST be `"C-unwind"`:
1. For extern procedures: `ExternAbiName(ExternAbiOf(proc)) = "C-unwind"`.
2. For exported procedures: `ExportAttr(proc) = âŸ¨"C-unwind", _âŸ©`.


##### 5.13.6.5 `[[export]]`

**Syntax**

```ebnf
export_attribute ::= "[[" "export" "(" string_literal ")" "]]"
                  | "[[" "export" "(" string_literal "," export_opts ")" "]]"
export_opts      ::= export_opt ("," export_opt)*
export_opt       ::= "link_name" ":" string_literal
```

**Static Semantics**

1. Valid only on procedure declarations.
2. The procedure MUST be `public`.
3. The ABI string selects the foreign calling convention (see Â§21.2.1).
4. The link name is `link_name` if provided, otherwise `LinkName` (Â§6.3.1).
5. `[[export]]` implies external linkage; if `link_name` is omitted and `[[no_mangle]]` is absent, the default symbol is the mangled name.
6. Export signatures MUST satisfy the FFI safety requirements in Â§21.2.2 and Â§21.3.


##### 5.13.6.6 `[[ffi_pass_by_value]]`

**Syntax**

```ebnf
ffi_pass_by_value_attribute ::= "[[" "ffi_pass_by_value" "]]"
```

**Static Semantics**

This attribute marks a `record` or `enum` that satisfies both `DropType` and `FfiSafeType` as eligible for by-value passing across the FFI boundary. If a `DropType` + `FfiSafeType` type is passed by value in any FFI signature without this attribute, the program is ill-formed (Â§21.1.1).


**FFI Attribute Constraints**

1. `[[symbol]]` is valid only on extern procedure declarations or exported procedures.
2. Duplicate symbol names within a compilation unit are link-time errors.
3. `[[library]]` is valid only on `extern` blocks.
4. Unknown library kinds are ill-formed.
5. `[[no_mangle]]` on a non-FFI procedure is ill-formed.
6. `[[no_mangle]]` on an extern procedure within an `extern "C"` or `extern "C-unwind"` block is redundant and SHOULD emit a warning.
7. `[[unwind]]` on a non-FFI procedure is ill-formed.
8. `[[unwind("abort")]]` is redundant and SHOULD emit a warning.

## 6. Phase 4: Code Generation

### 6.0. Codegen Model and Judgments

ArtifactsOf(P) = Set(Objs) âˆª Set(IRs) âˆª {Exe} â‡” Î“ âŠ¢ OutputPipeline(P) â‡“ (Objs, IRs, Exe)
IRTarget = "LLVM-21.1.8"
ObjTarget = "COFF"
LLVMValid_21.1.8(L) â‡” L âˆˆ LLVMIR_21.1.8
âˆ€ IR, L. Î“ âŠ¢ LowerIR(IR) â‡“ L â‡’ LLVMValid_21.1.8(L)

CodegenJudg = {CodegenProject, CodegenModule, CodegenItem, CodegenExpr, CodegenStmt, CodegenBlock, CodegenPlace}

IRDefined(IR) â‡” âˆ€ Ïƒ. âˆƒ out, Ïƒ'. ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ')

CodegenExprValCorrect â‡” âˆ€ e, IR, v, Ïƒ, v', Ïƒ'. (Î“ âŠ¢ CodegenExpr(e) â‡“ âŸ¨IR, vâŸ© âˆ§ Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v'), Ïƒ')) â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (Val(v'), Ïƒ') âˆ§ v = v')
CodegenExprCtrlCorrect â‡” âˆ€ e, IR, v, Ïƒ, Îº, Ïƒ'. (Î“ âŠ¢ CodegenExpr(e) â‡“ âŸ¨IR, vâŸ© âˆ§ Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ')) â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ'))
CodegenStmtCorrect â‡” âˆ€ s, IR, Ïƒ, sout, Ïƒ'. (Î“ âŠ¢ CodegenStmt(s) â‡“ IR âˆ§ Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (sout, Ïƒ')) â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (sout, Ïƒ'))
CodegenBlockValCorrect â‡” âˆ€ b, IR, v, Ïƒ, v', Ïƒ'. (Î“ âŠ¢ CodegenBlock(b) â‡“ âŸ¨IR, vâŸ© âˆ§ Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (Val(v'), Ïƒ')) â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (Val(v'), Ïƒ') âˆ§ v = v')
CodegenBlockCtrlCorrect â‡” âˆ€ b, IR, v, Ïƒ, Îº, Ïƒ'. (Î“ âŠ¢ CodegenBlock(b) â‡“ âŸ¨IR, vâŸ© âˆ§ Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ')) â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ'))

CodegenCorrect â‡” CodegenExprValCorrect âˆ§ CodegenExprCtrlCorrect âˆ§ CodegenStmtCorrect âˆ§ CodegenBlockValCorrect âˆ§ CodegenBlockCtrlCorrect
CodegenUndefined â‡” âˆƒ e, IR, v. Î“ âŠ¢ CodegenExpr(e) â‡“ âŸ¨IR, vâŸ© âˆ§ Â¬ IRDefined(IR) âˆ¨ âˆƒ s, IR. Î“ âŠ¢ CodegenStmt(s) â‡“ IR âˆ§ Â¬ IRDefined(IR) âˆ¨ âˆƒ b, IR, v. Î“ âŠ¢ CodegenBlock(b) â‡“ âŸ¨IR, vâŸ© âˆ§ Â¬ IRDefined(IR)
CodegenUndefined â‡’ OutsideConformance

IRDecls = [IRDecl]
ModuleIR = IRDecls

**(CG-Project)**
Î“ âŠ¢ OutputPipeline(P) â‡“ (Objs, IRs, Exe)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenProject(P) â‡“ (Set(Objs) âˆª Set(IRs) âˆª {Exe})

Items(P, m) = ASTModule(P, m).items

**(CG-Module)**
Items(Project(Î“), m) = [i_1, â€¦, i_k]    âˆ€ j, Î“ âŠ¢ CodegenItem(i_j) â‡“ ds_j    Î“ âŠ¢ InitFn(m) â‡“ sym_init    Î“ âŠ¢ DeinitFn(m) â‡“ sym_deinit    Î“ âŠ¢ Lower-StaticInit(m) â‡“ IR_init    Î“ âŠ¢ Lower-StaticDeinit(m) â‡“ IR_deinit
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenModule(m) â‡“ ds_1 ++ â€¦ ++ ds_k ++ [ProcIR(sym_init, [PanicOutParam], TypePrim("()"), IR_init), ProcIR(sym_deinit, [PanicOutParam], TypePrim("()"), IR_deinit)]

Î“ âŠ¢ CodegenItem(item) â‡“ ds â‡’ ds âˆˆ IRDecls
ProcIR : Symbol Ã— [Param] Ã— Type Ã— IR â†’ IRDecl

PanicOutParam = âŸ¨`move`, PanicOutName, PanicOutTypeâŸ©
CodegenParams(params) = params ++ [PanicOutParam]

MethodParams(R, m) = [âŸ¨RecvMode(m.receiver), `self`, RecvType(Self_R, m.receiver)âŸ©] ++ m.params
ClassMethodParams(Cl, m) = [âŸ¨RecvMode(m.receiver), `self`, RecvType(SelfVar, m.receiver)âŸ©] ++ m.params

ParamList_T(T, params) = [âŸ¨mode_i, name_i, SubstSelf(T, ty_i)âŸ© | âŸ¨mode_i, name_i, ty_iâŸ© âˆˆ params]
ClassMethodParams_T(T, m) = [âŸ¨RecvMode(m.receiver), `self`, RecvType(T, m.receiver)âŸ©] ++ ParamList_T(T, m.params)

StateMethodParams(M, S, md) = [âŸ¨RecvMode(md.receiver), `self`, RecvType(TypeModalState(ModalPath(M), S), md.receiver)âŸ©] ++ md.params
TransitionParams(M, S, tr) = [âŸ¨`move`, `self`, TypePerm(`unique`, TypeModalState(ModalPath(M), S))âŸ©] ++ tr.params

DefaultImpl : Type Ã— ClassMethodDecl â†’ ASTItem
DefaultUserSet(m) = { T | Î“ âŠ¢ T uses default m }
DefaultUserList(m) = sort_{â‰º_{type}}(DefaultUserSet(m))

**(CG-Item-Using)**
item = UsingDecl(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ []

**(CG-Item-TypeAlias)**
item = TypeAliasDecl(_, _, _, _, _, _, _, _)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ []

**(CG-Item-Procedure-Main)**
item = ProcedureDecl(attrs_opt, vis, "main", gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, span, doc)    Project(Î“) = P    Executable(P)    MainSigOk(item)    R = ProcReturn(ret_opt)    Î“ âŠ¢ EmitInitPlan(P) â‡“ IR_init    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR_body, vâŸ©    Î“ âŠ¢ Mangle(item) â‡“ sym    params' = CodegenParams(params)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ [ProcIR(sym, params', R, SeqIR(IR_init, IR_body))]

**(CG-Item-Procedure)**
item = ProcedureDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, span, doc)    Project(Î“) = P    (name â‰  "main" âˆ¨ Â¬ Executable(P))    R = ProcReturn(ret_opt)    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR, vâŸ©    Î“ âŠ¢ Mangle(item) â‡“ sym    params' = CodegenParams(params)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ [ProcIR(sym, params', R, IR)]

**(CG-Item-Static)**
item = StaticDecl(_, _, _, _, _, _)    Î“ âŠ¢ EmitGlobal(item) â‡“ ds
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ ds

**(CG-Item-Record)**
item = RecordDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, implements, members, invariant_opt, span, doc)    R = item    Methods(R) = [m_1, â€¦, m_k]    âˆ€ i, Î“ âŠ¢ CodegenItem(m_i) â‡“ ds_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ ds_1 ++ â€¦ ++ ds_k

**(CG-Item-Method)**
m âˆˆ Methods(R)    params' = MethodParams(R, m)    R_m = ReturnType(m)    m.body = body    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR, vâŸ©    Î“ âŠ¢ Mangle(m) â‡“ sym    params'' = CodegenParams(params')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(m) â‡“ [ProcIR(sym, params'', R_m, IR)]

**(CG-Item-Modal)**
item = ModalDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, implements, states, invariant_opt, span, doc)    M = item    âˆ€ S âˆˆ StateList(M), âˆ€ md âˆˆ Methods(M, S), Î“ âŠ¢ CodegenItem(md) â‡“ ds_{S,md}    âˆ€ S âˆˆ StateList(M), âˆ€ tr âˆˆ Transitions(M, S), Î“ âŠ¢ CodegenItem(tr) â‡“ ds_{S,tr}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ ++_{S âˆˆ StateList(M)} ( ++_{md âˆˆ Methods(M, S)} ds_{S,md} ++ ++_{tr âˆˆ Transitions(M, S)} ds_{S,tr} )

**(CG-Item-StateMethod)**
S âˆˆ StateList(M)    md âˆˆ Methods(M, S)    params' = StateMethodParams(M, S, md)    R_m = ReturnType(md)    md.body = body    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR, vâŸ©    Î“ âŠ¢ Mangle(md) â‡“ sym    params'' = CodegenParams(params')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(md) â‡“ [ProcIR(sym, params'', R_m, IR)]

**(CG-Item-Transition)**
S âˆˆ StateList(M)    tr âˆˆ Transitions(M, S)    params' = TransitionParams(M, S, tr)    TransitionSig(M, S, tr).target = S_t    tr.body = body    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR, vâŸ©    Î“ âŠ¢ Mangle(tr) â‡“ sym    params'' = CodegenParams(params')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(tr) â‡“ [ProcIR(sym, params'', TypeModalState(ModalPath(M), S_t), IR)]

**(CG-Item-Class)**
item = ClassDecl(attrs_opt, vis, modal_opt, name, gen_params_opt, where_clause_opt, supers, items, span, doc)    Cl = item    ClassMethods(Cl) = [m_1, â€¦, m_k]    âˆ€ i, Î“ âŠ¢ CodegenItem(m_i) â‡“ ds_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ ds_1 ++ â€¦ ++ ds_k

**(CG-Item-ClassMethod-Abstract)**
m âˆˆ ClassMethods(Cl)    m.body_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(m) â‡“ []

**(CG-Item-ClassMethod-Body)**
m âˆˆ ClassMethods(Cl)    m.body_opt = body    DefaultUserList(m) = [T_1, â€¦, T_k]    âˆ€ i, Î“_i = Î“[SelfVar â†¦ T_i]    params_i = ClassMethodParams_T(T_i, m)    R_i = ReturnType_T(T_i, m)    Î“_i âŠ¢ LowerBlock(body) â‡“ âŸ¨IR_i, v_iâŸ©    Î“ âŠ¢ Mangle(DefaultImpl(T_i, m)) â‡“ sym_i    params_i' = CodegenParams(params_i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(m) â‡“ [ProcIR(sym_1, params_1', R_1, IR_1), â€¦, ProcIR(sym_k, params_k', R_k, IR_k)]

**(CG-Item-Enum)**
item = EnumDecl(_, _, _, _, _, _, _, _, _, _)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ []

**(CG-Item-ErrorItem)**
item = ErrorItem(_)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenItem(item) â‡“ []
âˆƒ item, ds. item = ErrorItem(_) âˆ§ Î“ âŠ¢ CodegenItem(item) â‡“ ds â‡’ OutsideConformance

**(CG-Expr)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenExpr(e) â‡“ âŸ¨IR, vâŸ©

**(CG-Stmt)**
Î“ âŠ¢ LowerStmt(s) â‡“ IR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenStmt(s) â‡“ IR

**(CG-Block)**
Î“ âŠ¢ LowerBlock(b) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenBlock(b) â‡“ âŸ¨IR, vâŸ©

**(CG-Place)**
Î“ âŠ¢ LowerPlace(p) â‡“ l
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CodegenPlace(p) â‡“ l


### 6.1. Layout and Representation

#### 6.1.1. Primitive Layout and Encoding

PtrSize = 8
PointerSize = PtrSize
PtrAlign = 8

PrimSize("i8") = 1
PrimSize("i16") = 2
PrimSize("i32") = 4
PrimSize("i64") = 8
PrimSize("i128") = 16
PrimSize("u8") = 1
PrimSize("u16") = 2
PrimSize("u32") = 4
PrimSize("u64") = 8
PrimSize("u128") = 16
PrimSize("f16") = 2
PrimSize("f32") = 4
PrimSize("f64") = 8
PrimSize("bool") = 1
PrimSize("char") = 4
PrimSize("usize") = PtrSize
PrimSize("isize") = PtrSize
PrimSize("()") = 0
PrimSize("!") = 0

PrimAlign("i8") = 1
PrimAlign("i16") = 2
PrimAlign("i32") = 4
PrimAlign("i64") = 8
PrimAlign("i128") = 16
PrimAlign("u8") = 1
PrimAlign("u16") = 2
PrimAlign("u32") = 4
PrimAlign("u64") = 8
PrimAlign("u128") = 16
PrimAlign("f16") = 2
PrimAlign("f32") = 4
PrimAlign("f64") = 8
PrimAlign("bool") = 1
PrimAlign("char") = 4
PrimAlign("usize") = PtrAlign
PrimAlign("isize") = PtrAlign
PrimAlign("()") = 1
PrimAlign("!") = 1

LayoutJudg = {sizeof, alignof, layout}

**(Size-Prim)**
T = TypePrim(name)    PrimSize(name) = n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = n

**(Align-Prim)**
T = TypePrim(name)    PrimAlign(name) = a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = a

**(Layout-Prim)**
T = TypePrim(name)    PrimSize(name) = n    PrimAlign(name) = a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨n, aâŸ©

**Encoding.**

LEBytes(v, n) = LE(v mod 2^{8n}, n)
FloatBits_t(v) = IEEE754Bits(t, v)
EncodeConstJudg = {EncodeConst}
BoolByte(false) = 0x00
BoolByte(true) = 0x01

**(Encode-Bool)**
LiteralValue(lit, TypePrim("bool")) = b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(TypePrim("bool"), lit) â‡“ LEBytes(BoolByte(b), 1)

**(Encode-Char)**
LiteralValue(lit, TypePrim("char")) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(TypePrim("char"), lit) â‡“ LEBytes(c, 4)

**(Encode-Int)**
lit.kind = IntLiteral    T = TypePrim(t)    t âˆˆ IntTypes    v = LiteralValue(lit, T)    x = IntValValue(v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(T, lit) â‡“ LEBytes(x, sizeof(T))

**(Encode-Float)**
lit.kind = FloatLiteral    T = TypePrim(t)    t âˆˆ FloatTypes    v = LiteralValue(lit, T)    x = FloatValValue(v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(T, lit) â‡“ LEBytes(FloatBits_t(x), sizeof(T))

**(Encode-Unit)**
T = TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(T, lit) â‡“ []

**(Encode-Never)**
T = TypePrim("!")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(T, lit) â‡“ []

**(Encode-RawPtr-Null)**
lit.kind = NullLiteral    T = TypeRawPtr(q, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EncodeConst(T, lit) â‡“ LEBytes(0, sizeof(T))

**Validity.**

ValidValueJudg = {ValidValue}

**(Valid-Bool)**
ValidValue(TypePrim("bool"), bits) â‡” bits âˆˆ {[0x00], [0x01]}

**(Valid-Char)**
ValidValue(TypePrim("char"), bits) â‡” âˆƒ c. LEBytes(c, 4) = bits âˆ§ c âˆˆ UnicodeScalar

**(Valid-Scalar)**
ScalarTypes = {"i8", "i16", "i32", "i64", "i128", "u8", "u16", "u32", "u64", "u128", "f16", "f32", "f64", "usize", "isize"}
âˆ€ t âˆˆ ScalarTypes. ValidValue(TypePrim(t), bits) â‡” |bits| = PrimSize(t)

**(Valid-Unit)**
ValidValue(TypePrim("()"), bits) â‡” bits = []

**(Valid-Never)**
ValidValue(TypePrim("!"), bits) â‡” false

#### 6.1.2. Permission, Pointer, and Function Layout

**(Layout-Perm)**
Î“ âŠ¢ layout(T) â‡“ L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(TypePerm(p, T)) â‡“ L

**(Size-Perm)**
Î“ âŠ¢ sizeof(T) = n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(TypePerm(p, T)) = n

**(Align-Perm)**
Î“ âŠ¢ alignof(T) = a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(TypePerm(p, T)) = a

**(Size-Ptr)**
T = TypePtr(T_0, s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = PtrSize

**(Align-Ptr)**
T = TypePtr(T_0, s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-Ptr)**
T = TypePtr(T_0, s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

**(Size-RawPtr)**
T = TypeRawPtr(q, T_0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = PtrSize

**(Align-RawPtr)**
T = TypeRawPtr(q, T_0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-RawPtr)**
T = TypeRawPtr(q, T_0)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

**(Size-Func)**
T = TypeFunc(params, R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = PtrSize

**(Align-Func)**
T = TypeFunc(params, R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-Func)**
T = TypeFunc(params, R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

#### 6.1.3. Record Layout Without `[[layout(C)]]`

AlignUp(x, a) = âŒˆx/aâŒ‰ Ã— a    where a > 0
Offsets([]) = []
Offsets(fields) = [offset_1, â€¦, offset_n] â‡” fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ n â‰¥ 1 âˆ§ offset_1 = 0 âˆ§ âˆ€ i âˆˆ {2, â€¦, n}. offset_i = AlignUp(offset_{i-1} + sizeof(T_{i-1}), alignof(T_i))
RecordAlign([]) = 1
RecordAlign(fields) = max_{i âˆˆ {1, â€¦, n}}(alignof(T_i)) â‡” fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ n â‰¥ 1
RecordSize([]) = 0
RecordSize(fields) = AlignUp(offset_n + sizeof(T_n), RecordAlign(fields)) â‡” fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ n â‰¥ 1 âˆ§ Offsets(fields) = [offset_1, â€¦, offset_n]
RecordLayoutJudg = {RecordLayout}

**(Layout-Record-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RecordLayout([]) â‡“ âŸ¨0, 1, []âŸ©

**(Layout-Record-Cons)**
n â‰¥ 1    offsets = [offset_1, â€¦, offset_n]    align = RecordAlign(fields)    size = RecordSize(fields)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RecordLayout(fields) â‡“ âŸ¨size, align, offsetsâŸ©

**(Size-Record)**
T = TypePath(p)    RecordDecl(p) = R    Fields(R) = fields    RecordLayout(fields) â‡“ âŸ¨size, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Record)**
T = TypePath(p)    RecordDecl(p) = R    Fields(R) = fields    RecordLayout(fields) â‡“ âŸ¨_, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-Record)**
T = TypePath(p)    RecordDecl(p) = R    Fields(R) = fields    RecordLayout(fields) â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

FieldOffset(fields, f_i) = offset_i â‡” fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ 1 â‰¤ i â‰¤ n âˆ§ Offsets(fields) = [offset_1, â€¦, offset_n]

**Type Aliases.**
AliasBody(p) = ty â‡” Î£.Types[p] = TypeAliasDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, ty, span, doc)

**(Size-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ sizeof(ty) = size
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ alignof(ty) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ layout(ty) â‡“ âŸ¨size, alignâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

#### 6.1.4. Union Layout and Discriminants

##### 6.1.4.1. Niche Optimization (Cursive0)

**Niche Sets.**

NicheSet(T) âŠ† { bits | Â¬ ValidValue(T, bits) }
NicheSet(T) = {LEBytes(0, PtrSize)} â‡” âˆƒ U. T = TypePtr(U, `Valid`)
NicheSet(T) = âˆ… â‡” Â¬ âˆƒ U. T = TypePtr(U, `Valid`)

BitsToUInt(bits) = v â‡” LEBytes(v, |bits|) = bits
bits_1 â‰º_u bits_2 â‡” âˆƒ v_1, v_2. BitsToUInt(bits_1) = v_1 âˆ§ BitsToUInt(bits_2) = v_2 âˆ§ v_1 < v_2
NicheOrder(T) = sort_{â‰º_u}(NicheSet(T))
NicheCount(T) = |NicheSet(T)|

**Valid Pointer Non-Zero Invariant.**

ValidValue(TypePtr(T, `Valid`), bits) â‡” |bits| = PtrSize âˆ§ bits â‰  LEBytes(0, PtrSize)
ValidValue(TypePtr(T, `Null`), bits) â‡” bits = LEBytes(0, PtrSize)
ValidValue(TypePtr(T, `Expired`), bits) â‡” |bits| = PtrSize
ValidValue(TypePtr(T, âŠ¥), bits) â‡” |bits| = PtrSize
ValidValue(TypeRawPtr(q, T), bits) â‡” |bits| = PtrSize
ValidValue(T, bits) â‡” T âˆ‰ {TypePrim(_), TypePtr(_, _), TypeRawPtr(_, _)} âˆ§ âˆƒ v. ValueBits(T, v) = bits

**Union Niche Encoding.**

U = TypeUnion([T_1, â€¦, T_n])

**Type Ordering (Cursive0).**

PathOrderKey(p) = âŸ¨Fold(p), pâŸ©
ArrayLen(e) = n â‡” Î“ âŠ¢ ConstLen(e) â‡“ n

TagKey(`prim`) = 0
TagKey(`tuple`) = 1
TagKey(`array`) = 2
TagKey(`slice`) = 3
TagKey(`func`) = 4
TagKey(`path`) = 5
TagKey(`modal_state`) = 6
TagKey(`string`) = 7
TagKey(`bytes`) = 8
TagKey(`dynamic`) = 9
TagKey(`ptr`) = 10
TagKey(`rawptr`) = 11
TagKey(`union`) = 12
TagKey(`perm`) = 13
TagKey(`range`) = 14

PermKey(`const`) = 0
PermKey(`unique`) = 1
PtrStateKey(âŠ¥) = 0
PtrStateKey(`Valid`) = 1
PtrStateKey(`Null`) = 2
PtrStateKey(`Expired`) = 3
QualKey(`imm`) = 0
QualKey(`mut`) = 1
ModeKey(âŠ¥) = 0
ModeKey(`move`) = 1
StateKey(`View`) = 0
StateKey(`Managed`) = 1
StateKey(âŠ¥) = 2

TypeKey(TypePrim(name)) = âŸ¨TagKey(`prim`), nameâŸ©
TypeKey(TypeRange) = âŸ¨TagKey(`range`)âŸ©
TypeKey(TypeTuple([T_1, â€¦, T_n])) = âŸ¨TagKey(`tuple`), n, TypeKey(T_1), â€¦, TypeKey(T_n)âŸ©
TypeKey(TypeArray(T, e)) = âŸ¨TagKey(`array`), TypeKey(T), ArrayLen(e)âŸ©
TypeKey(TypeSlice(T)) = âŸ¨TagKey(`slice`), TypeKey(T)âŸ©
TypeKey(TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)) = âŸ¨TagKey(`func`), n, ModeKey(m_1), TypeKey(T_1), â€¦, ModeKey(m_n), TypeKey(T_n), TypeKey(R)âŸ©
TypeKey(TypePath(p)) = âŸ¨TagKey(`path`), PathOrderKey(p)âŸ©
TypeKey(TypeModalState(modal_ref, S)) = âŸ¨TagKey(`modal_state`), PathOrderKey(ModalRefPath(modal_ref)), SâŸ©
TypeKey(TypeString(st)) = âŸ¨TagKey(`string`), StateKey(st)âŸ©
TypeKey(TypeBytes(st)) = âŸ¨TagKey(`bytes`), StateKey(st)âŸ©
TypeKey(TypeDynamic(p)) = âŸ¨TagKey(`dynamic`), PathOrderKey(p)âŸ©
TypeKey(TypePtr(T, s)) = âŸ¨TagKey(`ptr`), PtrStateKey(s), TypeKey(T)âŸ©
TypeKey(TypeRawPtr(q, T)) = âŸ¨TagKey(`rawptr`), QualKey(q), TypeKey(T)âŸ©
TypeKey(TypeUnion([T_1, â€¦, T_n])) = âŸ¨TagKey(`union`), Sort([TypeKey(T_1), â€¦, TypeKey(T_n)])âŸ©
TypeKey(TypePerm(p, T)) = âŸ¨TagKey(`perm`), PermKey(p), TypeKey(T)âŸ©

Key = { TypeKey(T) | T âˆˆ Type }
KeyList = { [k_1, â€¦, k_n] | âˆ€ i. k_i âˆˆ Key }
a â‰º_{atom} b â‡” (a, b âˆˆ â„• âˆ§ a < b) âˆ¨ (a, b âˆˆ String âˆ§ Utf8LexLess(a, b)) âˆ¨ (a, b âˆˆ Key âˆ§ a â‰º_{key} b) âˆ¨ (a, b âˆˆ KeyList âˆ§ a â‰º_{keylist} b)
LexLess_{â‰º}(L_1, L_2) â‡” (âˆƒ k. 0 â‰¤ k < |L_1| âˆ§ 0 â‰¤ k < |L_2| âˆ§ (âˆ€ i. 0 â‰¤ i < k â‡’ L_1[i] = L_2[i]) âˆ§ L_1[k] â‰º L_2[k]) âˆ¨ (|L_1| < |L_2| âˆ§ âˆ€ i. 0 â‰¤ i < |L_1| â‡’ L_1[i] = L_2[i])
k_1 â‰º_{key} k_2 â‡” LexLess_{â‰º_{atom}}(k_1, k_2)
L_1 â‰º_{keylist} L_2 â‡” LexLess_{â‰º_{key}}(L_1, L_2)
Sorted_{â‰º}(L) â‡” âˆ€ i, j. 0 â‰¤ i < j < |L| â‡’ Â¬(L[j] â‰º L[i])
Sort(L) = L' â‡” Permutation(L', L) âˆ§ Sorted_{â‰º_{key}}(L')
T_1 â‰º_{type} T_2 â‡” TypeKey(T_1) â‰º_{key} TypeKey(T_2)

MemberList(U) = Sort(Members(U))
MemberIndex(U, T) = i â‡” MemberList(U)[i] â‰¡ T
UnionDiscValue(U, T) = i â‡” MemberIndex(U, T) = i
EmptyMember(T) â‡” T â‰¡ TypePrim("()")
EmptyList(U) = [MemberList(U)[i] | 0 â‰¤ i < |MemberList(U)| âˆ§ EmptyMember(MemberList(U)[i])]
PayloadMember(U) = T_p â‡” âˆƒ j. MemberList(U)[j] â‰¡ T_p âˆ§ NicheCount(T_p) > 0 âˆ§ (âˆ€ i. 0 â‰¤ i < |MemberList(U)| âˆ§ i â‰  j â‡’ EmptyMember(MemberList(U)[i])) âˆ§ NicheCount(T_p) â‰¥ |MemberList(U)| - 1
NicheApplies(U) â‡” âˆƒ T_p. PayloadMember(U) = T_p

**ValueBits.**

FieldValueList(fs, f) = v â‡” âŸ¨f, vâŸ© âˆˆ fs
StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], [o_1, â€¦, o_n], size) = bits â‡” |bits| = size âˆ§ âˆ€ i. ValueBits(T_i, v_i) = b_i âˆ§ bits[o_i..o_i+|b_i|) = b_i âˆ§ âˆ€ j. (âˆ€ i. j âˆ‰ [o_i, o_i+|b_i|)) â‡’ bits[j] = 0x00
PadBytes(b, size) = bits â‡” |bits| = size âˆ§ bits[0..|b|) = b âˆ§ âˆ€ i. |b| â‰¤ i < size â‡’ bits[i] = 0x00

ValueBits(TypePrim("bool"), v) = bits â‡” (v = BoolVal(true) âˆ§ bits = [0x01]) âˆ¨ (v = BoolVal(false) âˆ§ bits = [0x00])
ValueBits(TypePrim("char"), v) = bits â‡” v = CharVal(u) âˆ§ LEBytes(u, 4) = bits
ValueBits(TypePrim("()"), v) = bits â‡” v = UnitVal âˆ§ bits = []
ValueBits(TypePrim(t), v) = bits â‡” t âˆˆ IntTypes âˆ§ v = IntVal(t, x) âˆ§ LEBytes(x, sizeof(TypePrim(t))) = bits
ValueBits(TypePrim(t), v) = bits â‡” t âˆˆ FloatTypes âˆ§ v = FloatVal(t, x) âˆ§ LEBytes(IEEE754Bits(t, x), sizeof(TypePrim(t))) = bits
ValueBits(TypePerm(p, T), v) = bits â‡” ValueBits(T, v) = bits

ValueBits(TypePtr(T, `Valid`), v) = bits â‡” v = PtrVal(`Valid`, addr) âˆ§ addr â‰  0x0 âˆ§ bits = LEBytes(addr, PtrSize)
ValueBits(TypePtr(T, `Null`), v) = bits â‡” v = PtrVal(`Null`, addr) âˆ§ addr = 0x0 âˆ§ bits = LEBytes(addr, PtrSize)
ValueBits(TypePtr(T, `Expired`), v) = bits â‡” v = PtrVal(`Expired`, addr) âˆ§ bits = LEBytes(addr, PtrSize)
ValueBits(TypePtr(T, âŠ¥), v) = bits â‡” âˆƒ s. s âˆˆ PtrStateSet âˆ§ ValueBits(TypePtr(T, s), v) = bits
ValueBits(TypeRawPtr(q, T), v) = bits â‡” v = RawPtr(q, addr) âˆ§ bits = LEBytes(addr, PtrSize)

ValueBits(TypeTuple([T_1, â€¦, T_n]), (v_1, â€¦, v_n)) = bits â‡” TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], offsets, size) = bits
ValueBits(TypeArray(T, e), [v_0, â€¦, v_{n-1}]) = bits â‡” ArrayLen(e) = n âˆ§ s = sizeof(T) âˆ§ |bits| = n Ã— s âˆ§ âˆ€ i. 0 â‰¤ i < n â‡’ (ValueBits(T, v_i) = b_i âˆ§ bits[i Ã— s .. i Ã— s + |b_i|) = b_i)
ValueBits(TypeSlice(T), SliceValue(v, r)) = bits â‡” SliceBounds(r, Len(v)) = (start, end) âˆ§ n = end - start âˆ§ âˆƒ addr. ValueBits(TypeRawPtr(`imm`, T), RawPtr(`imm`, addr)) = b_ptr âˆ§ ValueBits(TypePrim("usize"), IntVal("usize", n)) = b_len âˆ§ bits = b_ptr ++ b_len
ValueBits(TypeRange, r) = bits â‡” RangeValFields(r) = [âŸ¨`kind`, v_kâŸ©, âŸ¨`lo`, v_lâŸ©, âŸ¨`hi`, v_hâŸ©] âˆ§ RangeFields = [âŸ¨`kind`, T_kâŸ©, âŸ¨`lo`, T_lâŸ©, âŸ¨`hi`, T_hâŸ©] âˆ§ RecordLayout(RangeFields) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ StructBits([T_k, T_l, T_h], [v_k, v_l, v_h], offsets, size) = bits

ValueBits(TypeModalState(modal_ref, S), v) = bits â‡” ModalDeclOf(modal_ref) = M âˆ§ S âˆˆ States(M) âˆ§ v = RecordValue(ModalStateRef(modal_ref, S), fs) âˆ§ ModalPayload(modal_ref, S) = fields âˆ§ RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ (âˆ€ i. FieldValue(RecordValue(ModalStateRef(modal_ref, S), fs), f_i) = v_i) âˆ§ StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], offsets, size) = bits

EnumPayloadBits(E, name, âŠ¥) = bits â‡” (âˆƒ v âˆˆ Variants(E). v.name = name âˆ§ VariantPayloadOpt(v) = âŠ¥) âˆ§ PadBytes([], PayloadSize(E)) = bits
EnumPayloadBits(E, name, TuplePayload([v_1, â€¦, v_k])) = bits â‡” (âˆƒ v âˆˆ Variants(E). v.name = name âˆ§ VariantPayloadOpt(v) = TuplePayload([T_1, â€¦, T_k])) âˆ§ ValueBits(TypeTuple([T_1, â€¦, T_k]), (v_1, â€¦, v_k)) = b âˆ§ PadBytes(b, PayloadSize(E)) = bits
EnumPayloadBits(E, name, RecordPayload(fs)) = bits â‡” (âˆƒ v âˆˆ Variants(E). v.name = name âˆ§ VariantPayloadOpt(v) = RecordPayload(fields)) âˆ§ RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ (âˆ€ i. FieldValueList(fs, f_i) = v_i) âˆ§ StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], offsets, size) = b âˆ§ PadBytes(b, PayloadSize(E)) = bits

ValueBits(TypePath(p), v) = bits â‡” AliasBody(p) = ty âˆ§ ValueBits(ty, v) = bits
ValueBits(TypePath(p), v) = bits â‡” RecordDecl(p) = R âˆ§ v = RecordValue(TypePath(p), fs) âˆ§ Fields(R) = fields âˆ§ RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ (âˆ€ i. FieldValue(RecordValue(TypePath(p), fs), f_i) = v_i) âˆ§ StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], offsets, size) = bits
ValueBits(TypePath(p), v) = bits â‡” EnumDecl(p) = E âˆ§ v = EnumValue(path, payload) âˆ§ EnumPath(path) = p âˆ§ name = VariantName(path) âˆ§ EnumDisc(E, name) = d âˆ§ EnumPayloadBits(E, name, payload) = payload_bits âˆ§ EnumDiscType(E) = D âˆ§ D = TypePrim(t) âˆ§ ValueBits(D, IntVal(t, d)) = disc_bits âˆ§ TaggedBits(disc_bits, payload_bits, sizeof(D), PayloadSize(E), PayloadAlign(E), EnumSize(E)) = bits
ValueBits(ModalRefType(modal_ref), v) = bits â‡” ModalDeclOf(modal_ref) = M âˆ§ v = âŸ¨S, v_sâŸ© âˆ§ ModalBits(modal_ref, S, v_s) = bits

ValueBits(TypeUnion(U), v) = bits â‡” âˆƒ T. Member(T, TypeUnion(U)) âˆ§ UnionBits(U, T, v) = bits

ValueBits(TypeDynamic(Cl), v) = bits â‡” v = Dyn(Cl, RawPtr(`imm`, addr), T) âˆ§ sym = ScopedSym(VTableDecl(T, Cl)) âˆ§ addr_vt = AddrOfSym(sym) âˆ§ RecordLayout(DynFields(Cl)) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ StructBits([TypeRawPtr(`imm`, TypePrim("()")), TypeRawPtr(`imm`, TypePath(["VTable"]))], [RawPtr(`imm`, addr), RawPtr(`imm`, addr_vt)], offsets, size) = bits
ValueBits(TypeString(st), v) = bits â‡” ValueType(v) = TypeString(st) âˆ§ |bits| = sizeof(TypeString(st))
ValueBits(TypeBytes(st), v) = bits â‡” ValueType(v) = TypeBytes(st) âˆ§ |bits| = sizeof(TypeBytes(st))

ValueBits(T, v) = bits â‡’ ValidValue(T, bits)
UnionNicheBits(U, T, v) = bits â‡” NicheApplies(U) âˆ§ PayloadMember(U) = T_p âˆ§ ((T â‰¡ T_p âˆ§ ValueBits(T_p, v) = bits âˆ§ bits âˆ‰ NicheSet(T_p)) âˆ¨ (âˆƒ i. EmptyList(U)[i] â‰¡ T âˆ§ v = () âˆ§ NicheOrder(T_p)[i] = bits))

**Union Layout.**

k = |MemberList(U)| - 1
UnionDiscType(U) = DiscType(k)
PayloadSize(U) = max_{T âˆˆ MemberList(U)}(sizeof(T))
PayloadAlign(U) = max_{T âˆˆ MemberList(U)}(alignof(T))
UnionAlign(U) = max(alignof(UnionDiscType(U)), PayloadAlign(U))
UnionSize(U) = AlignUp(sizeof(UnionDiscType(U)) + PayloadSize(U), UnionAlign(U))
UnionLayoutJudg = {UnionLayout}

**(Layout-Union-Niche)**
NicheApplies(U)    PayloadMember(U) = T_p    Î“ âŠ¢ layout(T_p) â‡“ âŸ¨size, alignâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UnionLayout(U) â‡“ âŸ¨size, align, âŠ¥, layout(T_p)âŸ©

**(Layout-Union-Tagged)**
Â¬ NicheApplies(U)    size = UnionSize(U)    align = UnionAlign(U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UnionLayout(U) â‡“ âŸ¨size, align, UnionDiscType(U), PayloadSize(U)âŸ©

**(Size-Union)**
T = TypeUnion([T_1, â€¦, T_n])    UnionLayout(T) â‡“ âŸ¨size, _, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Union)**
T = TypeUnion([T_1, â€¦, T_n])    UnionLayout(T) â‡“ âŸ¨_, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-Union)**
T = TypeUnion([T_1, â€¦, T_n])    UnionLayout(T) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

PayloadBits(U, T, v) = bits â‡” ValueBits(T, v) = b âˆ§ |bits| = PayloadSize(U) âˆ§ bits[0..|b|) = b
TaggedBits(disc_bits, payload_bits, disc_size, payload_size, payload_align, size) = bits â‡” |bits| = size âˆ§ payload_off = AlignUp(disc_size, payload_align) âˆ§ bits[0..disc_size) = disc_bits âˆ§ bits[payload_off..payload_off + payload_size) = payload_bits

**Informative.** TaggedBits constrains only the discriminant and payload ranges; bytes outside those ranges are unconstrained.

UnionTaggedBits(U, T, v) = bits â‡” Â¬ NicheApplies(U) âˆ§ UnionDiscType(U) = D âˆ§ UnionDiscValue(U, T) = d âˆ§ ValueBits(D, d) = disc_bits âˆ§ PayloadBits(U, T, v) = payload_bits âˆ§ TaggedBits(disc_bits, payload_bits, sizeof(D), PayloadSize(U), PayloadAlign(U), UnionSize(U)) = bits
UnionBits(U, T, v) = bits â‡” UnionNicheBits(U, T, v) = bits âˆ¨ UnionTaggedBits(U, T, v) = bits

**Modal Niche Encoding.**

SingleFieldPayload(M, S) = T â‡” Payload(M, S) = [âŸ¨f, TâŸ©]
ModalSingleFieldPayload(modal_ref, S) = T' â‡” ModalDeclOf(modal_ref) = M âˆ§ SingleFieldPayload(M, S) = T âˆ§ Î¸ = ModalRefSubst(modal_ref, M) âˆ§ T' = TypeSubst(Î¸, T)
EmptyState(M, S) â‡” Payload(M, S) = []
PayloadState(modal_ref) = S_p â‡” ModalDeclOf(modal_ref) = M âˆ§ S_p âˆˆ States(M) âˆ§ ModalSingleFieldPayload(modal_ref, S_p) = T_p âˆ§ NicheCount(T_p) > 0 âˆ§ (âˆ€ S âˆˆ States(M). S â‰  S_p â‡’ EmptyState(M, S)) âˆ§ NicheCount(T_p) â‰¥ |States(M)| - 1
NicheApplies(modal_ref) â‡” âˆƒ S_p. PayloadState(modal_ref) = S_p
EmptyStates(M) = [ S âˆˆ States(M) | EmptyState(M, S) ]
EmptyRecordVal(v) â‡” âˆƒ tr. v = RecordValue(tr, [])
ModalNicheBits(modal_ref, S, v) = bits â‡” ModalDeclOf(modal_ref) = M âˆ§ NicheApplies(modal_ref) âˆ§ PayloadState(modal_ref) = S_p âˆ§ ModalSingleFieldPayload(modal_ref, S_p) = T_p âˆ§ ((S = S_p âˆ§ ValueBits(T_p, v) = bits âˆ§ bits âˆ‰ NicheSet(T_p)) âˆ¨ (âˆƒ i. EmptyStates(M)[i] = S âˆ§ (v = () âˆ¨ EmptyRecordVal(v)) âˆ§ NicheOrder(T_p)[i] = bits))
ModalBits(modal_ref, S, v) = bits â‡” ModalNicheBits(modal_ref, S, v) = bits âˆ¨ ModalTaggedBits(modal_ref, S, v) = bits

ModalPayloadSize(modal_ref) = s â‡” ModalDeclOf(modal_ref) = M âˆ§ s = max_{S âˆˆ States(M)}(StateSize(modal_ref, S))
ModalPayloadAlign(modal_ref) = a â‡” ModalDeclOf(modal_ref) = M âˆ§ a = max_{S âˆˆ States(M)}(StateAlign(modal_ref, S))
StateRecordBits(modal_ref, S, v) = b â‡” ModalPayload(modal_ref, S) = fields âˆ§ RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ© âˆ§ fields = [âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©] âˆ§ ((n = 0 âˆ§ (v = () âˆ¨ EmptyRecordVal(v)) âˆ§ b = []) âˆ¨ (n > 0 âˆ§ v = RecordValue(tr, fs) âˆ§ (âˆ€ i. FieldValue(RecordValue(tr, fs), f_i) = v_i) âˆ§ StructBits([T_1, â€¦, T_n], [v_1, â€¦, v_n], offsets, size) = b))
ModalPayloadBits(modal_ref, S, v) = bits â‡” StateRecordBits(modal_ref, S, v) = b âˆ§ ModalPayloadSize(modal_ref) = s âˆ§ PadBytes(b, s) = bits

Modal tagged layout is fully defined; all bytes outside the discriminant and payload ranges MUST be zero.
ModalTaggedBits(modal_ref, S, v) = bits â‡” ModalDeclOf(modal_ref) = M âˆ§ Â¬ NicheApplies(modal_ref) âˆ§ ModalDiscType(modal_ref) = D âˆ§ StateIndex(M, S) = i âˆ§ ValueBits(D, i) = disc_bits âˆ§ ModalPayloadBits(modal_ref, S, v) = payload_bits âˆ§ ModalPayloadSize(modal_ref) = psize âˆ§ ModalPayloadAlign(modal_ref) = palign âˆ§ TaggedBits(disc_bits, payload_bits, sizeof(D), psize, palign, ModalSize(modal_ref)) = bits âˆ§ payload_off = AlignUp(sizeof(D), palign) âˆ§ âˆ€ j. 0 â‰¤ j < |bits| âˆ§ j âˆ‰ [0, sizeof(D)) âˆ§ j âˆ‰ [payload_off, payload_off + psize) â‡’ bits[j] = 0x00



#### 6.1.5. String and Bytes Layout

**`string@Managed` Representation**

StringManagedFields = [âŸ¨`pointer`, TypePtr(TypePrim("u8"), `Valid`)âŸ©, âŸ¨`length`, TypePrim("usize")âŸ©, âŸ¨`capacity`, TypePrim("usize")âŸ©]
StringManagedOffsets = [0, PtrSize, 2 Ã— PtrSize]
RecordLayout(StringManagedFields) = âŸ¨3 Ã— PtrSize, PtrAlign, StringManagedOffsetsâŸ©
sizeof(`string@Managed`) = 3 Ã— PtrSize

**`string@View` Representation**

StringViewFields = [âŸ¨`pointer`, TypePtr(TypePerm(`const`, TypePrim("u8")), `Valid`)âŸ©, âŸ¨`length`, TypePrim("usize")âŸ©]
StringViewOffsets = [0, PtrSize]
RecordLayout(StringViewFields) = âŸ¨2 Ã— PtrSize, PtrAlign, StringViewOffsetsâŸ©
sizeof(`string@View`) = 2 Ã— PtrSize

**String Layout Rules.**

**(Size-String-Managed)**
T = TypeString(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 3 Ã— PtrSize

**(Align-String-Managed)**
T = TypeString(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-String-Managed)**
T = TypeString(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨3 Ã— PtrSize, PtrAlignâŸ©

**(Size-String-View)**
T = TypeString(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 2 Ã— PtrSize

**(Align-String-View)**
T = TypeString(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-String-View)**
T = TypeString(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨2 Ã— PtrSize, PtrAlignâŸ©

**`bytes@Managed` Representation**

BytesManagedFields = [âŸ¨`pointer`, TypePtr(TypePrim("u8"), `Valid`)âŸ©, âŸ¨`length`, TypePrim("usize")âŸ©, âŸ¨`capacity`, TypePrim("usize")âŸ©]
BytesManagedOffsets = [0, PtrSize, 2 Ã— PtrSize]
RecordLayout(BytesManagedFields) = âŸ¨3 Ã— PtrSize, PtrAlign, BytesManagedOffsetsâŸ©
sizeof(`bytes@Managed`) = 3 Ã— PtrSize

**`bytes@View` Representation**

BytesViewFields = [âŸ¨`pointer`, TypePtr(TypePerm(`const`, TypePrim("u8")), `Valid`)âŸ©, âŸ¨`length`, TypePrim("usize")âŸ©]
BytesViewOffsets = [0, PtrSize]
RecordLayout(BytesViewFields) = âŸ¨2 Ã— PtrSize, PtrAlign, BytesViewOffsetsâŸ©
sizeof(`bytes@View`) = 2 Ã— PtrSize

**Bytes Layout Rules.**

**(Size-Bytes-Managed)**
T = TypeBytes(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 3 Ã— PtrSize

**(Align-Bytes-Managed)**
T = TypeBytes(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-Bytes-Managed)**
T = TypeBytes(`@Managed`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨3 Ã— PtrSize, PtrAlignâŸ©

**(Size-Bytes-View)**
T = TypeBytes(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 2 Ã— PtrSize

**(Align-Bytes-View)**
T = TypeBytes(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-Bytes-View)**
T = TypeBytes(`@View`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨2 Ã— PtrSize, PtrAlignâŸ©

**(Size-String-Modal)**
T = TypeString(âŠ¥)    Î“ âŠ¢ ModalLayout(`string`) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-String-Modal)**
T = TypeString(âŠ¥)    Î“ âŠ¢ ModalLayout(`string`) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Size-Bytes-Modal)**
T = TypeBytes(âŠ¥)    Î“ âŠ¢ ModalLayout(`bytes`) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Bytes-Modal)**
T = TypeBytes(âŠ¥)    Î“ âŠ¢ ModalLayout(`bytes`) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align


#### 6.1.6. Aggregate Layouts (Tuples, Arrays, Slices, Ranges, Enums)

**Tuples.**

TupleFields([T_1, â€¦, T_n]) = [âŸ¨0, T_1âŸ©, â€¦, âŸ¨n-1, T_nâŸ©]
TupleLayoutJudg = {TupleLayout}

**(Layout-Tuple-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleLayout([]) â‡“ âŸ¨0, 1, []âŸ©

**(Layout-Tuple-Cons)**
n â‰¥ 1    TupleFields([T_1, â€¦, T_n]) = fields    RecordLayout(fields) â‡“ âŸ¨size, align, offsetsâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, align, offsetsâŸ©

**(Size-Tuple)**
TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(TypeTuple([T_1, â€¦, T_n])) = size

**(Align-Tuple)**
TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨_, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(TypeTuple([T_1, â€¦, T_n])) = align

**(Layout-Tuple)**
TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(TypeTuple([T_1, â€¦, T_n])) â‡“ âŸ¨size, alignâŸ©

**Arrays.**

**(Size-Array)**
Î“ âŠ¢ ConstLen(e) â‡“ n    Î“ âŠ¢ sizeof(T_0) = s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(TypeArray(T_0, e)) = n Ã— s

**(Align-Array)**
Î“ âŠ¢ alignof(T_0) = a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(TypeArray(T_0, e)) = a

**(Layout-Array)**
Î“ âŠ¢ sizeof(TypeArray(T_0, e)) = size    Î“ âŠ¢ alignof(TypeArray(T_0, e)) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(TypeArray(T_0, e)) â‡“ âŸ¨size, alignâŸ©

**Slices.**

**(Size-Slice)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 2 Ã— PtrSize

**(Align-Slice)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

**(Layout-Slice)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨2 Ã— PtrSize, PtrAlignâŸ©

**Ranges.**

RangeTag(`To`) = 0
RangeTag(`ToInclusive`) = 1
RangeTag(`Full`) = 2
RangeTag(`From`) = 3
RangeTag(`Exclusive`) = 4
RangeTag(`Inclusive`) = 5
RangeFields = [âŸ¨`kind`, TypePrim("u8")âŸ©, âŸ¨`lo`, TypePrim("usize")âŸ©, âŸ¨`hi`, TypePrim("usize")âŸ©]
OptVal(v_opt) =
 IntVal("usize", 0)    if v_opt = âŠ¥
 v_opt    otherwise
RangeValFields(RangeVal(kind, lo_opt, hi_opt)) = [âŸ¨`kind`, IntVal("u8", RangeTag(kind))âŸ©, âŸ¨`lo`, OptVal(lo_opt)âŸ©, âŸ¨`hi`, OptVal(hi_opt)âŸ©]
RangeLayoutJudg = {RangeLayout}

**(Layout-Range)**
RecordLayout(RangeFields) â‡“ âŸ¨size, align, offsetsâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RangeLayout() â‡“ âŸ¨size, align, offsetsâŸ©

**(Size-Range)**
Î“ âŠ¢ RangeLayout() â‡“ âŸ¨size, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(TypeRange) = size

**(Align-Range)**
Î“ âŠ¢ RangeLayout() â‡“ âŸ¨_, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(TypeRange) = align

**(Layout-Range-SizeAlign)**
Î“ âŠ¢ RangeLayout() â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(TypeRange) â‡“ âŸ¨size, alignâŸ©

**Enums.**

EnumDiscType(E) = DiscType(E)
VariantPayloadOpt(v) = payload_opt â‡” v = âŸ¨name, payload_opt, disc_opt, span, doc_optâŸ©
VariantSize(v) = 0 â‡” VariantPayloadOpt(v) = âŠ¥
VariantAlign(v) = 1 â‡” VariantPayloadOpt(v) = âŠ¥
VariantSize(v) = s â‡” VariantPayloadOpt(v) = TuplePayload([T_1, â€¦, T_k]) âˆ§ TupleLayout([T_1, â€¦, T_k]) â‡“ âŸ¨s, a, _âŸ©
VariantAlign(v) = a â‡” VariantPayloadOpt(v) = TuplePayload([T_1, â€¦, T_k]) âˆ§ TupleLayout([T_1, â€¦, T_k]) â‡“ âŸ¨s, a, _âŸ©
VariantSize(v) = s â‡” VariantPayloadOpt(v) = RecordPayload(fields) âˆ§ RecordLayout(fields) â‡“ âŸ¨s, a, _âŸ©
VariantAlign(v) = a â‡” VariantPayloadOpt(v) = RecordPayload(fields) âˆ§ RecordLayout(fields) â‡“ âŸ¨s, a, _âŸ©
PayloadSize(E) = max_{v âˆˆ Variants(E)}(VariantSize(v))
PayloadAlign(E) = max_{v âˆˆ Variants(E)}(VariantAlign(v))
EnumAlign(E) = max(alignof(EnumDiscType(E)), PayloadAlign(E))
EnumSize(E) = AlignUp(sizeof(EnumDiscType(E)) + PayloadSize(E), EnumAlign(E))
EnumLayoutJudg = {EnumLayout}

**(Layout-Enum-Tagged)**
size = EnumSize(E)    align = EnumAlign(E)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EnumLayout(E) â‡“ âŸ¨size, align, EnumDiscType(E), PayloadSize(E)âŸ©

**(Size-Enum)**
T = TypePath(p)    EnumDecl(p) = E    EnumLayout(E) â‡“ âŸ¨size, _, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Enum)**
T = TypePath(p)    EnumDecl(p) = E    EnumLayout(E) â‡“ âŸ¨_, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-Enum)**
T = TypePath(p)    EnumDecl(p) = E    EnumLayout(E) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

#### 6.1.7. Modal Layout (Codegen)

ModalDiscType(modal_ref) = DiscType(|States(M)| - 1) where ModalDeclOf(modal_ref) = M
StateSize(modal_ref, S) = s â‡” RecordLayout(ModalPayload(modal_ref, S)) â‡“ âŸ¨s, a, _âŸ©
StateAlign(modal_ref, S) = a â‡” RecordLayout(ModalPayload(modal_ref, S)) â‡“ âŸ¨s, a, _âŸ©
ModalAlign(modal_ref) = max(alignof(ModalDiscType(modal_ref)), max_{S âˆˆ States(M)}(StateAlign(modal_ref, S))) where ModalDeclOf(modal_ref) = M
ModalSize(modal_ref) = AlignUp(sizeof(ModalDiscType(modal_ref)) + max_{S âˆˆ States(M)}(StateSize(modal_ref, S)), ModalAlign(modal_ref)) where ModalDeclOf(modal_ref) = M
ModalLayoutJudg = {ModalLayout}

**(Layout-Modal-Niche)**
ModalDeclOf(modal_ref) = M    NicheApplies(modal_ref)    PayloadState(modal_ref) = S_p    ModalSingleFieldPayload(modal_ref, S_p) = T_p    Î“ âŠ¢ layout(T_p) â‡“ âŸ¨size, alignâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModalLayout(modal_ref) â‡“ âŸ¨size, align, âŠ¥, layout(T_p)âŸ©

**(Layout-Modal-Tagged)**
ModalDeclOf(modal_ref) = M    Â¬ NicheApplies(modal_ref)    size = ModalSize(modal_ref)    align = ModalAlign(modal_ref)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ModalLayout(modal_ref) â‡“ âŸ¨size, align, ModalDiscType(modal_ref), max_{S âˆˆ States(M)}(StateSize(modal_ref, S))âŸ©

**(Size-Modal)**
T = ModalRefType(modal_ref)    ModalLayout(modal_ref) â‡“ âŸ¨size, _, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-Modal)**
T = ModalRefType(modal_ref)    ModalLayout(modal_ref) â‡“ âŸ¨_, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-Modal)**
T = ModalRefType(modal_ref)    ModalLayout(modal_ref) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

**(Size-ModalState)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    StateSize(modal_ref, S) = size
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = size

**(Align-ModalState)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    StateAlign(modal_ref, S) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = align

**(Layout-ModalState)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    StateSize(modal_ref, S) = size    StateAlign(modal_ref, S) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ layout(T) â‡“ âŸ¨size, alignâŸ©

#### 6.1.8. Dynamic Class Object Layout

DynFields(Cl) = [âŸ¨`data`, TypeRawPtr(`imm`, TypePrim("()"))âŸ©, âŸ¨`vtable`, TypeRawPtr(`imm`, TypePath(["VTable"]))âŸ©]
DynLayoutJudg = {DynLayout}

**(Layout-DynamicClass)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DynLayout(Cl) â‡“ âŸ¨2 Ã— PtrSize, PtrAlign, DynFields(Cl)âŸ©

**(Size-DynamicClass)**
T = TypeDynamic(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ sizeof(T) = 2 Ã— PtrSize

**(Align-DynamicClass)**
T = TypeDynamic(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ alignof(T) = PtrAlign

### 6.2. ABI Lowering (Cursive0)

#### 6.2.1. Default Calling Convention

**DefaultCallingConvention.**
CallConvDefault = Cursive0ABI


#### 6.2.2. ABI Type Lowering

ABIType = { âŸ¨size, alignâŸ© | size âˆˆ â„• âˆ§ align âˆˆ â„• }
ABITyJudg = {ABITy}

**(ABI-Prim)**
Î“ âŠ¢ sizeof(TypePrim(name)) = s    Î“ âŠ¢ alignof(TypePrim(name)) = a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypePrim(name)) â‡“ âŸ¨s, aâŸ©

**(ABI-Perm)**
Î“ âŠ¢ ABITy(T) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypePerm(p, T)) â‡“ Ï„

**(ABI-Ptr)**
T = TypePtr(U, s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

**(ABI-RawPtr)**
T = TypeRawPtr(q, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

**(ABI-Func)**
T = TypeFunc(params, R)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨PtrSize, PtrAlignâŸ©

**(ABI-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ ABITy(ty) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ Ï„

**(ABI-Record)**
T = TypePath(p)    RecordDecl(p) = R    Fields(R) = fields    RecordLayout(fields) â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨size, alignâŸ©

**(ABI-Tuple)**
TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypeTuple([T_1, â€¦, T_n])) â‡“ âŸ¨size, alignâŸ©

**(ABI-Array)**
Î“ âŠ¢ sizeof(TypeArray(T, e)) = size    Î“ âŠ¢ alignof(TypeArray(T, e)) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypeArray(T, e)) â‡“ âŸ¨size, alignâŸ©

**(ABI-Slice)**
T = TypeSlice(U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨2 Ã— PtrSize, PtrAlignâŸ©

**(ABI-Range)**
Î“ âŠ¢ sizeof(TypeRange) = size    Î“ âŠ¢ alignof(TypeRange) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypeRange) â‡“ âŸ¨size, alignâŸ©

**(ABI-Enum)**
T = TypePath(p)    EnumDecl(p) = E    EnumLayout(E) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨size, alignâŸ©

**(ABI-Union)**
T = TypeUnion([T_1, â€¦, T_n])    UnionLayout(T) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨size, alignâŸ©

**(ABI-Modal)**
T = ModalRefType(modal_ref)    ModalLayout(modal_ref) â‡“ âŸ¨size, align, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨size, alignâŸ©

**(ABI-Dynamic)**
Î“ âŠ¢ DynLayout(Cl) â‡“ âŸ¨size, align, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(TypeDynamic(Cl)) â‡“ âŸ¨size, alignâŸ©

**(ABI-StringBytes)**
T âˆˆ {TypeString(`@View`), TypeString(`@Managed`), TypeBytes(`@View`), TypeBytes(`@Managed`)}    Î“ âŠ¢ sizeof(T) = size    Î“ âŠ¢ alignof(T) = align
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABITy(T) â‡“ âŸ¨size, alignâŸ©

#### 6.2.3. ABI Parameter and Return Passing

PassKind = {`ByValue`, `ByRef`, `SRet`}
ByValMax = 2 Ã— PtrSize
ByValAlign = PtrAlign
ByValOk(T) â‡” Î“ âŠ¢ sizeof(T) = n âˆ§ Î“ âŠ¢ alignof(T) = a âˆ§ n â‰¤ ByValMax âˆ§ a â‰¤ ByValAlign
ABIParamJudg = {ABIParam}
ABIRetJudg = {ABIRet}
ABICallJudg = {ABICall}

**(ABI-Param-ByRef-Alias)**
mode = âŠ¥    Î“ âŠ¢ sizeof(T) = n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABIParam(mode, T) â‡“ `ByRef`

**(ABI-Param-ByValue-Move)**
mode = `move`    Î“ âŠ¢ sizeof(T) = 0 âˆ¨ ByValOk(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABIParam(mode, T) â‡“ `ByValue`

**(ABI-Param-ByRef-Move)**
mode = `move`    Î“ âŠ¢ sizeof(T) = n    n > 0    Â¬ ByValOk(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABIParam(mode, T) â‡“ `ByRef`

**(ABI-Ret-ByValue)**
Î“ âŠ¢ sizeof(T) = 0 âˆ¨ ByValOk(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABIRet(T) â‡“ `ByValue`

**(ABI-Ret-ByRef)**
Î“ âŠ¢ sizeof(T) = n    n > 0    Â¬ ByValOk(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABIRet(T) â‡“ `SRet`

**(ABI-Call)**
âˆ€ i, Î“ âŠ¢ ABIParam(m_i, T_i) â‡“ k_i    Î“ âŠ¢ ABIRet(R) â‡“ k_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ABICall([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R) â‡“ âŸ¨[k_1, â€¦, k_n], k_r, (k_r = `SRet`)âŸ©

**Panic Out-Parameter (Cursive0).**

PanicRecordFields = [âŸ¨`panic`, TypePrim("bool")âŸ©, âŸ¨`code`, TypePrim("u32")âŸ©]
PanicRecordLayout = RecordLayout(PanicRecordFields)
PanicRecordFieldsOf(PanicRecord) = PanicRecordFields
PanicRecordLayoutOf(PanicRecord) = PanicRecordLayout

PanicOutType = TypeRawPtr(`mut`, PanicRecord)
PanicOutName = "__panic"

NeedsPanicOut(callee) â‡” callee â‰  RecordCtor(_) âˆ§ callee â‰  EntrySym âˆ§ RuntimeSig(callee) undefined.

PanicOutParams(params, callee) =
 params ++ [âŸ¨`move`, PanicOutName, PanicOutTypeâŸ©]    if NeedsPanicOut(callee)
 params    otherwise

#### 6.2.4. Call Lowering for Procedures and Methods

LowerCallJudg = {MethodSymbol, BuiltinMethodSym, LowerMethodCall, LowerArgs, LowerRecvArg}
ModalStateOf(T) = TypeModalState(modal_ref, S) â‡” StripPerm(T) = TypeModalState(modal_ref, S)
BuiltinCapClass = {`FileSystem`, `HeapAllocator`, `Reactor`}

**(MethodSymbol-Record-Builtin)**
LookupMethod(T, name) = m    m = MethodDecl(_, _, _, _, _, _, _, _, _, body, _, _)    body = âŠ¥    T = TypePath(p)    RecordDecl(p) = R    R.name âˆˆ BuiltinRecord    Î“ âŠ¢ BuiltinSym(R.name::name) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MethodSymbol(T, name) â‡“ sym

**(MethodSymbol-Record)**
LookupMethod(T, name) = m    m = MethodDecl(_, _, _, _, _, _, _, _, _, body, _, _)    body â‰  âŠ¥    Î“ âŠ¢ Mangle(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MethodSymbol(T, name) â‡“ sym

**(MethodSymbol-Default)**
LookupMethod(T, name) = m    m = ClassMethodDecl(_, _, _, _, _, _, _, _, _, _, _)    m.body_opt â‰  âŠ¥    Î“ âŠ¢ Mangle(DefaultImpl(T, m)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MethodSymbol(T, name) â‡“ sym

**(MethodSymbol-ModalState-Method)**
ModalStateOf(T) = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupStateMethod(M, S, name) = md    Î“ âŠ¢ Mangle(md) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MethodSymbol(T, name) â‡“ sym

**(MethodSymbol-ModalState-Transition)**
ModalStateOf(T) = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    LookupTransition(M, S, name) = tr    Î“ âŠ¢ Mangle(tr) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MethodSymbol(T, name) â‡“ sym

**(BuiltinMethodSym-FileSystem)**
BuiltinSym(`FileSystem`::name) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinMethodSym(`FileSystem`, name) â‡“ sym

**(BuiltinMethodSym-HeapAllocator)**
BuiltinSym(`HeapAllocator`::name) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinMethodSym(`HeapAllocator`, name) â‡“ sym

**(Lower-Args-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerArgs([], []) â‡“ âŸ¨Îµ, []âŸ©

**(Lower-Args-Cons-Move)**
Î“ âŠ¢ LowerExpr(MovedArg(moved, e)) â‡“ âŸ¨IR_e, vâŸ©    Î“ âŠ¢ LowerArgs(ps, as) â‡“ âŸ¨IR_a, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerArgs([âŸ¨`move`, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as) â‡“ âŸ¨SeqIR(IR_e, IR_a), [v] ++ vec_vâŸ©

**(Lower-Args-Cons-Ref)**
Î“ âŠ¢ LowerAddrOf(e) â‡“ âŸ¨IR_e, addrâŸ©    Î“ âŠ¢ LowerArgs(ps, as) â‡“ âŸ¨IR_a, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerArgs([âŸ¨âŠ¥, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as) â‡“ âŸ¨SeqIR(IR_e, IR_a), [Ptr@Valid(addr)] ++ vec_vâŸ©

**(Lower-RecvArg-Move)**
base = MoveExpr(p)    Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_selfâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRecvArg(base) â‡“ âŸ¨IR_b, v_selfâŸ©

**(Lower-RecvArg-Ref)**
base â‰  MoveExpr(_)    Î“ âŠ¢ LowerAddrOf(base) â‡“ âŸ¨IR_b, addrâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRecvArg(base) â‡“ âŸ¨IR_b, Ptr@Valid(addr)âŸ©

**(Lower-MethodCall-Static-PanicOut)**
Î“ âŠ¢ LowerRecvArg(base) â‡“ âŸ¨IR_b, v_selfâŸ©    Î“ âŠ¢ LowerArgs(m.params, args) â‡“ âŸ¨IR_a, vec_vâŸ©    T = ExprType(base)    T â‰  TypeDynamic(_)    LookupMethod(T, name) = m    MethodSymbol(T, name) â‡“ sym    NeedsPanicOut(sym)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMethodCall(MethodCall(base, name, args)) â‡“ âŸ¨SeqIR(IR_b, IR_a, CallIR(sym, [v_self] ++ vec_v ++ [PanicOutName]), PanicCheck), v_callâŸ©

**(Lower-MethodCall-Static-NoPanicOut)**
Î“ âŠ¢ LowerRecvArg(base) â‡“ âŸ¨IR_b, v_selfâŸ©    Î“ âŠ¢ LowerArgs(m.params, args) â‡“ âŸ¨IR_a, vec_vâŸ©    T = ExprType(base)    T â‰  TypeDynamic(_)    LookupMethod(T, name) = m    MethodSymbol(T, name) â‡“ sym    Â¬ NeedsPanicOut(sym)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMethodCall(MethodCall(base, name, args)) â‡“ âŸ¨SeqIR(IR_b, IR_a, CallIR(sym, [v_self] ++ vec_v)), v_callâŸ©

**(Lower-MethodCall-Capability)**
Î“ âŠ¢ LowerRecvArg(base) â‡“ âŸ¨IR_b, v_selfâŸ©    Î“ âŠ¢ LowerArgs(m.params, args) â‡“ âŸ¨IR_a, vec_vâŸ©    ExprType(base) = TypeDynamic(Cl)    Cl âˆˆ BuiltinCapClass    LookupClassMethod(Cl, name) = m    Î“ âŠ¢ BuiltinMethodSym(Cl, name) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMethodCall(MethodCall(base, name, args)) â‡“ âŸ¨SeqIR(IR_b, IR_a, CallIR(sym, [v_self] ++ vec_v)), v_callâŸ©

**(Lower-MethodCall-Dynamic)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_selfâŸ©    Î“ âŠ¢ LowerArgs(m.params, args) â‡“ âŸ¨IR_a, vec_vâŸ©    ExprType(base) = TypeDynamic(Cl)    Cl âˆ‰ BuiltinCapClass    LookupClassMethod(Cl, name) = m    Î“ âŠ¢ LowerDynCall(v_self, name, vec_v ++ [PanicOutName]) â‡“ IR_d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMethodCall(MethodCall(base, name, args)) â‡“ âŸ¨SeqIR(IR_b, IR_a, IR_d), v_callâŸ©

SeqIR() = Îµ
SeqIR(IR) = IR
SeqIR(IR_1, â€¦, IR_n) = SeqIR(IR_1, SeqIR(IR_2, â€¦, IR_n))    (n â‰¥ 2)

### 6.3. Symbols, Mangling, and Linkage

#### 6.3.1. Symbol Names and Mangling

MangleJudg = {Mangle}
VTableDecl(T, Cl) constructor
LiteralData(kind, contents) constructor
DefaultImpl(T, m) constructor

Join(sep, []) = "\""
Join(sep, [s]) = s
Join(sep, [s_1, â€¦, s_n]) = s_1 ++ sep ++ Join(sep, [s_2, â€¦, s_n])    (n â‰¥ 2)
PathSig(p) = mangle(PathString(p))

ItemPath(it) = PathOfModule(ModuleOf(it)) ++ [name] â‡” it = ProcedureDecl(_, _, name, _, _, _, _, _, _, _, _)
ItemPath(it) = PathOfModule(ModuleOf(it)) ++ [name] â‡” it = ExternProcDecl(_, _, name, _, _, _, _, _, _, _, _)
ItemPath(m) = RecordPath(R) ++ [m.name] â‡” m âˆˆ Methods(R)
ItemPath(m) = ClassPath(Cl) ++ [m.name] â‡” m âˆˆ ClassMethods(Cl)
ItemPath(m) = ModalPath(M) ++ [S] ++ [m.name] â‡” S âˆˆ States(M) âˆ§ m âˆˆ Methods(M, S)
ItemPath(tr) = ModalPath(M) ++ [S] ++ [tr.name] â‡” S âˆˆ States(M) âˆ§ tr âˆˆ Transitions(M, S)
ItemPath(it) = PathOfModule(ModuleOf(it)) ++ [StaticName(binding)] â‡” it = StaticDecl(_, _, _, binding, span, doc) âˆ§ StaticName(binding) â‰  âŠ¥
ItemPath(StaticBinding(StaticDecl(attrs_opt, vis, mut, binding, span, doc), x)) = PathOfModule(ModuleOf(StaticDecl(attrs_opt, vis, mut, binding, span, doc))) ++ [x]
ItemPath(VTableDecl(T, Cl)) = ["vtable"] ++ PathOfType(T) ++ ["cl"] ++ ClassPath(Cl)
ItemPath(DefaultImpl(T, m)) = ["default"] ++ PathOfType(T) ++ ["cl"] ++ ClassPath(Cl) ++ [m.name] â‡” m âˆˆ ClassMethods(Cl)

TypeStateName(`View`) = "view"
TypeStateName(`Managed`) = "managed"
PathOfType(TypePrim(name)) = ["prim", name]
PathOfType(TypeString(st)) = ["string", TypeStateName(st)]
PathOfType(TypeBytes(st)) = ["bytes", TypeStateName(st)]
PathOfType(TypePath(p)) = p
PathOfType(TypeModalState(modal_ref, S)) = ModalRefPath(modal_ref) ++ [S]
PathOfType(T) = âŠ¥ â‡” T âˆ‰ {TypePrim(_), TypeString(_), TypeBytes(_), TypePath(_), TypeModalState(_, _)}
ClassPath(Cl) = p â‡” Î£.Classes[p] = Cl

**Literal Identity.**

FNVOffset64 = 14695981039346656037
FNVPrime64 = 1099511628211
FNV1a64([]) = FNVOffset64
FNV1a64([b_1, â€¦, b_n]) = h_n â‡” h_0 = FNVOffset64 âˆ§ âˆ€ i âˆˆ 0..n-1. h_{i+1} = ((h_i âŠ• b_{i+1}) Ã— FNVPrime64) mod 2^64
Hex64(h) = Join("\"", [Hex2(b_1), â€¦, Hex2(b_8)]) â‡” rev(LEBytes(h, 8)) = [b_1, â€¦, b_8]
LiteralID(kind, contents) = mangle(kind) ++ "_" ++ Hex64(FNV1a64(contents))

**Mangle Rules.**

ScopedSym(item) = PathSig(ItemPath(item))
RawSym(s) = s

AttrListOf(item) = attrs    if item.attrs_opt = attrs
AttrListOf(item) = []       if item.attrs_opt = âŠ¥
AttrByName(item, n) = [a | a âˆˆ AttrListOf(item) âˆ§ a.name = n]
SymbolAttr(item) = s â‡” âˆƒ a âˆˆ AttrByName(item, "symbol"). a.args = [StringLiteral(s)]
NoMangleAttr(item) â‡” AttrByName(item, "no_mangle") â‰  []
ExportAttr(item) = âŸ¨abi, link_name_optâŸ© â‡” âˆƒ a âˆˆ AttrByName(item, "export"). ExportArgs(a) = âŸ¨abi, link_name_optâŸ©

ExportArgs(a) = âŸ¨abi, link_name_optâŸ© â‡”
 a.args = [StringLiteral(abi)] âˆ§ link_name_opt = âŠ¥
 a.args = [StringLiteral(abi), âŸ¨"link_name", StringLiteral(s)âŸ©] âˆ§ link_name_opt = s

StringText(tok) = s â‡” tok.kind = StringLiteral âˆ§ T = Lexeme(tok) âˆ§ StringBytesFrom(T, 1, |T|-1) = bytes âˆ§ DecodeUTF8(bytes) = s
ExternAbiName(abi_opt) = "C"    if abi_opt = âŠ¥
ExternAbiName(abi_opt) = s      if abi_opt = IdentAbi(s)
ExternAbiName(abi_opt) = s      if abi_opt = StringAbi(tok) âˆ§ StringText(tok) = s
ExternAbiExplicit(abi_opt) â‡” abi_opt â‰  âŠ¥
ExternAbiOf(proc) = abi_opt â‡” ExternBlockOf(proc) = ExternBlock(_, _, abi_opt, _, _, _)
ExternRawName(proc) â‡” proc = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ§ ExternAbiName(ExternAbiOf(proc)) âˆˆ {"C", "C-unwind"}

LinkName(item) = sym â‡”
 SymbolAttr(item) = s                          âˆ§ sym = RawSym(s)
 SymbolAttr(item) undefined âˆ§ ExportAttr(item) = âŸ¨_, sâŸ© âˆ§ s â‰  âŠ¥ âˆ§ sym = RawSym(s)
 SymbolAttr(item) undefined âˆ§ NoMangleAttr(item)          âˆ§ sym = RawSym(ItemName(item))
 SymbolAttr(item) undefined âˆ§ ExternRawName(item)         âˆ§ sym = RawSym(ItemName(item))
 SymbolAttr(item) undefined âˆ§ ExportAttr(item) defined    âˆ§ sym = ScopedSym(item)
 SymbolAttr(item) undefined âˆ§ ExportAttr(item) undefined  âˆ§ sym = ScopedSym(item)

ItemName(item) = name â‡” item = ProcedureDecl(_, _, name, _, _, _, _, _, _, _, _)
ItemName(item) = name â‡” item = ExternProcDecl(_, _, name, _, _, _, _, _, _, _, _)
ItemName(item) = name â‡” item = StaticDecl(_, _, _, âŸ¨IdentifierPattern(name), _, _, _, _âŸ©, _, _)

**(Mangle-Proc)**
item = ProcedureDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, span, doc)    name â‰  "main"    LinkName(item) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ sym

**(Mangle-ExternProc)**
item = ExternProcDecl(attrs_opt, vis, name, gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, foreign_contracts_opt, span, doc)    LinkName(item) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ sym

**(Mangle-Main)**
item = ProcedureDecl(attrs_opt, vis, "main", gen_params_opt, where_clause_opt, params, ret_opt, contract_opt, body, span, doc)    MainSigOk(item)    LinkName(item) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ sym

**(Mangle-Record-Method)**
item = MethodDecl(attrs_opt, vis, override, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body, span, doc_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-Class-Method)**
item = ClassMethodDecl(attrs_opt, vis, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body_opt, span, doc_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-State-Method)**
item = StateMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-Transition)**
item = TransitionDecl(attrs_opt, vis, name, params, target, body, span, doc_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-Static)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    StaticName(binding) â‰  âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-StaticBinding)**
item = StaticBinding(StaticDecl(_, _, _, binding, _, _), x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-VTable)**
item = VTableDecl(T, Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

**(Mangle-Literal)**
item = LiteralData(kind, contents)    LiteralID(kind, contents) = id
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ PathSig(["cursive", "runtime", "literal", id])

**(Mangle-DefaultImpl)**
item = DefaultImpl(T, m)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Mangle(item) â‡“ ScopedSym(item)

#### 6.3.4. Linkage for Generated Symbols

LinkageKind = {`internal`, `external`}
LinkageJudg = {Linkage}

**(Linkage-UserItem)**
item âˆˆ {ProcedureDecl, StaticDecl, MethodDecl}    Vis(item) âˆˆ {`public`, `internal`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-ExternProc)**
item = ExternProcDecl(_, _, _, _, _, _, _, _, _, _, _)    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-UserItem-Internal)**
item âˆˆ {ProcedureDecl, StaticDecl, MethodDecl}    Vis(item) = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-StaticBinding)**
item = StaticBinding(StaticDecl(_, vis, _, _, _, _), x)    vis âˆˆ {`public`, `internal`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-StaticBinding-Internal)**
item = StaticBinding(StaticDecl(_, vis, _, _, _, _), x)    vis = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-ClassMethod)**
item = ClassMethodDecl(attrs_opt, vis, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body_opt, span, doc_opt)    body_opt â‰  âŠ¥    Vis(item) âˆˆ {`public`, `internal`, `protected`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-ClassMethod-Internal)**
item = ClassMethodDecl(attrs_opt, vis, name, gen_params_opt, receiver, params, ret_opt, contract_opt, body_opt, span, doc_opt)    body_opt â‰  âŠ¥    Vis(item) = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-StateMethod)**
item = StateMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)    Vis(item) âˆˆ {`public`, `internal`, `protected`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-StateMethod-Internal)**
item = StateMethodDecl(attrs_opt, vis, name, gen_params_opt, recv, params, ret_opt, contract_opt, body, span, doc_opt)    Vis(item) = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-Transition)**
item = TransitionDecl(attrs_opt, vis, name, params, target, body, span, doc_opt)    Vis(item) âˆˆ {`public`, `internal`, `protected`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-Transition-Internal)**
item = TransitionDecl(attrs_opt, vis, name, params, target, body, span, doc_opt)    Vis(item) = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-InitFn)**
InitFn(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-DeinitFn)**
DeinitFn(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-VTable)**
Mangle(VTableDecl(T, Cl)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-LiteralData)**
Mangle(LiteralData(kind, contents)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-DropGlue)**
DropGlueSym(T) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-DefaultImpl)**
item = DefaultImpl(T, m)    Vis(m) âˆˆ {`public`, `internal`, `protected`}    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

**(Linkage-DefaultImpl-Internal)**
item = DefaultImpl(T, m)    Vis(m) = `private`    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-PanicSym)**
PanicSym â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-RegionSym)**
RegionSym(proc) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-BuiltinSym)**
BuiltinSym(method) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `internal`

**(Linkage-EntrySym)**
EntrySym â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Linkage(sym) â‡“ `external`

### 6.4. Expression Lowering and Evaluation Order

EvalOrderJudg = {Children_LTR}

**(ArgsExprs-Empty)**
ArgsExprs([]) = []

**(ArgsExprs-Cons)**
ArgsExprs([âŸ¨moved, e, spanâŸ©] ++ rest) = [e] ++ ArgsExprs(rest)

**(FieldExprs-Empty)**
FieldExprs([]) = []

**(FieldExprs-Cons)**
FieldExprs([âŸ¨f, eâŸ©] ++ rest) = [e] ++ FieldExprs(rest)

**(OptExprs-None)**
OptExprs(âŠ¥, âŠ¥) = []

**(OptExprs-Lo)**
OptExprs(e, âŠ¥) = [e]

**(OptExprs-Hi)**
OptExprs(âŠ¥, e) = [e]

**(OptExprs-Both)**
OptExprs(e_1, e_2) = [e_1, e_2]

ParallelOptExprs([]) = []
ParallelOptExprs(Cancel(e) :: os) = [e] ++ ParallelOptExprs(os)
ParallelOptExprs(Name(_) :: os) = ParallelOptExprs(os)

SpawnOptExprs([]) = []
SpawnOptExprs(Name(_) :: os) = SpawnOptExprs(os)
SpawnOptExprs(Affinity(e) :: os) = [e] ++ SpawnOptExprs(os)
SpawnOptExprs(Priority(e) :: os) = [e] ++ SpawnOptExprs(os)

DispatchOptExprs([]) = []
DispatchOptExprs(Reduce(_) :: os) = DispatchOptExprs(os)
DispatchOptExprs(Ordered :: os) = DispatchOptExprs(os)
DispatchOptExprs(Chunk(e) :: os) = [e] ++ DispatchOptExprs(os)

KeySegExprs([]) = []
KeySegExprs(Field(_, _) :: ss) = KeySegExprs(ss)
KeySegExprs(Index(_, e) :: ss) = [e] ++ KeySegExprs(ss)
KeyPathExprs(âŸ¨root, segsâŸ©) = KeySegExprs(segs)
KeyClauseExprs(âŠ¥) = []
KeyClauseExprs(âŸ¨path, modeâŸ©) = KeyPathExprs(path)

RaceArmExprs([]) = []
RaceArmExprs(âŸ¨e, _, _âŸ© :: as) = [e] ++ RaceArmExprs(as)

LowerExprJudg = {LowerExpr, LowerUnOp, LowerBinOp, LowerCast, LowerList, LowerFieldInits, LowerOpt, LowerReadPlace, LowerWritePlace, LowerMovePlace, LowerAddrOf, LowerPlace}

**(EvalOrder-Literal)** `Children_LTR(Literal(Ã¢â€žâ€œ)) = []`.

**(EvalOrder-PtrNull)** `Children_LTR(PtrNullExpr) = []`.
  
**(EvalOrder-Ident)** `Children_LTR(Identifier(x)) = []`.
  
**(EvalOrder-Path)** `Children_LTR(Path(path, name)) = []`.
  
**(EvalOrder-Tuple)** `Children_LTR(TupleExpr(es)) = es`.
  
**(EvalOrder-Array)** `Children_LTR(ArrayExpr(es)) = es`.
  
**(EvalOrder-Record)** `Children_LTR(RecordExpr(tr, fields)) = FieldExprs(fields)`.
  
**(EvalOrder-Enum-Unit)** `Children_LTR(EnumLiteral(path, Ã¢Å Â¥)) = []`.
  
**(EvalOrder-Enum-Tuple)** `Children_LTR(EnumLiteral(path, Paren(es))) = es`.
  
**(EvalOrder-Enum-Record)** `Children_LTR(EnumLiteral(path, Brace(fields))) = FieldExprs(fields)`.
  
**(EvalOrder-FieldAccess)** `Children_LTR(FieldAccess(base, f)) = [base]`.
  
**(EvalOrder-TupleAccess)** `Children_LTR(TupleAccess(base, i)) = [base]`.
  
**(EvalOrder-IndexAccess)** `Children_LTR(IndexAccess(base, idx)) = [base, idx]`.
  
**(EvalOrder-Call)** `Children_LTR(Call(callee, args)) = [callee] ++ ArgsExprs(args)`.
**(EvalOrder-Call-TypeArgs)** `Children_LTR(CallTypeArgs(callee, type_args, args)) = [callee] ++ ArgsExprs(args)`.
  
**(EvalOrder-MethodCall)** `Children_LTR(MethodCall(base, name, args)) = [base] ++ ArgsExprs(args)`.
  
**(EvalOrder-Unary)** `Children_LTR(Unary(op, e)) = [e]`.
  
**(EvalOrder-Binary)** `Children_LTR(Binary(op, e_1, e_2)) = [e_1, e_2]`.
  
**(EvalOrder-Cast)** `Children_LTR(Cast(e, T)) = [e]`.
  
**(EvalOrder-Transmute)** `Children_LTR(TransmuteExpr(T_1, T_2, e)) = [e]`.
  
**(EvalOrder-Propagate)** `Children_LTR(Propagate(e)) = [e]`.
  
**(EvalOrder-Range)** `Children_LTR(Range(kind, lo_opt, hi_opt)) = OptExprs(lo_opt, hi_opt)`.
  
**(EvalOrder-If)** `Children_LTR(IfExpr(cond, b1, b2)) = [cond]`.
  
**(EvalOrder-Match)** `Children_LTR(MatchExpr(scrut, arms)) = [scrut]`.
  
**(EvalOrder-Loop)** `Children_LTR(LoopInfinite(body)) = [body]`, `Children_LTR(LoopConditional(cond, body)) = [cond, body]`, `Children_LTR(LoopIter(pat, ty_opt, iter, body)) = [iter, body]`.
  
**(EvalOrder-Block)** `Children_LTR(BlockExpr(stmts, tail_opt)) = []`.
  
**(EvalOrder-UnsafeBlock)** `Children_LTR(UnsafeBlockExpr(b)) = []`.
  
**(EvalOrder-Move)** `Children_LTR(MoveExpr(p)) = []`.
  
**(EvalOrder-AddressOf)** `Children_LTR(AddressOf(p)) = []`.
  
**(EvalOrder-Deref)** `Children_LTR(Deref(e)) = [e]`.
  
**(EvalOrder-Alloc)** `Children_LTR(AllocExpr(r_opt, e)) = [e]`.

**(EvalOrder-Parallel)** `Children_LTR(ParallelExpr(domain, opts, body)) = [domain] ++ ParallelOptExprs(opts)`.

**(EvalOrder-Spawn)** `Children_LTR(SpawnExpr(opts, body)) = SpawnOptExprs(opts)`.

**(EvalOrder-Dispatch)** `Children_LTR(DispatchExpr(pat, range, key_clause_opt, opts, body)) = [range] ++ KeyClauseExprs(key_clause_opt) ++ DispatchOptExprs(opts)`.

**(EvalOrder-Wait)** `Children_LTR(WaitExpr(handle)) = [handle]`.

**(EvalOrder-Yield)** `Children_LTR(YieldExpr(release_opt, e)) = [e]`.

**(EvalOrder-YieldFrom)** `Children_LTR(YieldFromExpr(release_opt, e)) = [e]`.

**(EvalOrder-Sync)** `Children_LTR(SyncExpr(e)) = [e]`.

**(EvalOrder-Race)** `Children_LTR(RaceExpr(arms)) = RaceArmExprs(arms)`.

**(EvalOrder-All)** `Children_LTR(AllExpr(es)) = es`.

RetType(Î“) = R â‡” ProcRet(Î“) = R

**(Lower-Expr-Correctness)**
âˆ€ Ïƒ, Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (out, Ïƒ') â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ©

ExprForms0 = {Literal(_), PtrNullExpr, Identifier(_), Path(_, _), ErrorExpr(_), TupleExpr(_), ArrayExpr(_), RecordExpr(_, _), EnumLiteral(_, _), FieldAccess(_, _), TupleAccess(_, _), IndexAccess(_, _), Call(_, _), MethodCall(_, _, _), Unary(_, _), Binary(_, _, _), Cast(_, _), TransmuteExpr(_, _, _), Propagate(_), Range(_, _, _), IfExpr(_, _, _), MatchExpr(_, _), LoopInfinite(_), LoopConditional(_, _), LoopIter(_, _, _, _), BlockExpr(_, _), UnsafeBlockExpr(_), MoveExpr(_), AddressOf(_), Deref(_), AllocExpr(_, _)}
LowerExprTotal(Î“) â‡” âˆ€ e. e âˆˆ ExprForms0 â‡’ âˆƒ IR, v. Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ©

ExecIRJudg = {ExecIRSigma, MoveStateSigma}

**(ExecIR-ReadVar)**
LookupVal(Ïƒ, x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ReadVarIR(x), Ïƒ) â‡“ (Val(v), Ïƒ)

**(ExecIR-ReadPath)**
LookupValPath(Ïƒ, path, name) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ReadPathIR(path, name), Ïƒ) â‡“ (Val(v), Ïƒ)

**(ExecIR-StoreVar)**
Î“ âŠ¢ WritePlaceSigma(Identifier(x), v, Ïƒ) â‡“ (sout, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(StoreVarIR(x, v), Ïƒ) â‡“ (sout, Ïƒ')

**(ExecIR-StoreVarNoDrop)**
Î“ âŠ¢ WritePlaceSubSigma(Identifier(x), v, Ïƒ) â‡“ (sout, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(StoreVarNoDropIR(x, v), Ïƒ) â‡“ (sout, Ïƒ')

**(ExecIR-BindVar)**
BindVal(Ïƒ, x, v) â‡“ (Ïƒ', b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(BindVarIR(x, v), Ïƒ) â‡“ (ok, Ïƒ')

**(ExecIR-ReadPtr)**
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ReadPtrIR(v_ptr), Ïƒ) â‡“ (out, Ïƒ')

**(ExecIR-WritePtr)**
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (sout, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(WritePtrIR(v_ptr, v), Ïƒ) â‡“ (sout, Ïƒ')

AllocTarget(Ïƒ, âŠ¥) = ActiveTarget(Ïƒ)
AllocTarget(Ïƒ, r) = ResolveTarget(Ïƒ, r)

**(ExecIR-Alloc)**
AllocTarget(Ïƒ, r_opt) = r    RegionAlloc(Ïƒ, r, v) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(AllocIR(r_opt, v), Ïƒ) â‡“ (Val(v'), Ïƒ')

**(MoveState-Root)**
PlaceRoot(p) = x    FieldHead(p) = âŠ¥    LookupBind(Ïƒ, x) = b    SetState(Ïƒ, b, Moved) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MoveStateSigma(p, Ïƒ) â‡“ Ïƒ'

**(MoveState-Field)**
PlaceRoot(p) = x    FieldHead(p) = f    LookupBind(Ïƒ, x) = b    BindState(Ïƒ, b) = s    PM(s, f) = s'    SetState(Ïƒ, b, s') â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MoveStateSigma(p, Ïƒ) â‡“ Ïƒ'

**(ExecIR-MoveState)**
Î“ âŠ¢ MoveStateSigma(p, Ïƒ) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(MoveStateIR(p), Ïƒ) â‡“ (ok, Ïƒ')

**(ExecIR-Return)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ReturnIR(v), Ïƒ) â‡“ (Ctrl(Return(v)), Ïƒ)

**(ExecIR-Result)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ResultIR(v), Ïƒ) â‡“ (Ctrl(Result(v)), Ïƒ)

**(ExecIR-Break)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(BreakIR(v_opt), Ïƒ) â‡“ (Ctrl(Break(v_opt)), Ïƒ)

**(ExecIR-Continue)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(ContinueIR, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ)

**(ExecIR-Defer)**
AppendCleanup(Ïƒ, DeferBlock(b)) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(DeferIR(b), Ïƒ) â‡“ (ok, Ïƒ')

ExecBlockBodyIRSigma(IR_s, IR_t, Ïƒ) â‡“ (out, Ïƒ') â‡” ExecIRSigma(IR_s, Ïƒ) â‡“ (sout, Ïƒ_1) âˆ§ ((sout = ok âˆ§ IR_t = Îµ âˆ§ out = Val(()) âˆ§ Ïƒ' = Ïƒ_1) âˆ¨ (sout = ok âˆ§ ExecIRSigma(IR_t, Ïƒ_1) â‡“ (out, Ïƒ')) âˆ¨ (sout = Ctrl(Result(v)) âˆ§ out = Val(v) âˆ§ Ïƒ' = Ïƒ_1) âˆ¨ (sout = Ctrl(Îº) âˆ§ Îº â‰  Result(_) âˆ§ out = Ctrl(Îº) âˆ§ Ïƒ' = Ïƒ_1))
Î“ âŠ¢ ExecInScopeIRSigma(IR_b, Ïƒ, scope) â‡“ (out, Ïƒ') â‡” CurrentScopeId(Ïƒ) = scope âˆ§ ExecIRSigma(IR_b, Ïƒ) â‡“ (out, Ïƒ')
Î“ âŠ¢ ExecBlockBindIRSigma(pat, v, IR_b, Ïƒ) â‡“ (out', Ïƒ'') â‡” BindPatternVal(pat, v) â‡“ B âˆ§ BindOrder(pat, B) = binds âˆ§ BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope) âˆ§ ExecIRSigma(IR_b, Ïƒ_1) â‡“ (out, Ïƒ_2) âˆ§ BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ'')

**(ExecIR-If-True)**
v_c = true    ExecIRSigma(IR_t, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(IfIR(v_c, IR_t, v_t, IR_f, v_f), Ïƒ) â‡“ (out, Ïƒ')

**(ExecIR-If-False)**
v_c = false    ExecIRSigma(IR_f, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(IfIR(v_c, IR_t, v_t, IR_f, v_f), Ïƒ) â‡“ (out, Ïƒ')

**(ExecIR-Block)**
BlockEnter(Ïƒ, []) â‡“ (Ïƒ_1, scope)    ExecBlockBodyIRSigma(IR_s, IR_t, Ïƒ_1) â‡“ (out, Ïƒ_2)    BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(BlockIR(IR_s, IR_t, v_t), Ïƒ) â‡“ (out', Ïƒ_3)

**(ExecIR-Match)**
Î“ âŠ¢ MatchArmsSigma(arms, v_s, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(MatchIR(v_s, arms), Ïƒ) â‡“ (out, Ïƒ')

**(ExecIR-Loop-Infinite-Step)**
ExecIRSigma(IR_b, Ïƒ) â‡“ (Val(v), Ïƒ_1)    ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ) â‡“ (out, Ïƒ_2)

**(ExecIR-Loop-Infinite-Continue)**
ExecIRSigma(IR_b, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ_1)    ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ) â‡“ (out, Ïƒ_2)

**(ExecIR-Loop-Infinite-Break)**
ExecIRSigma(IR_b, Ïƒ) â‡“ (Ctrl(Break(v_opt)), Ïƒ_1)    v = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ) â‡“ (Val(v), Ïƒ_1)

**(ExecIR-Loop-Infinite-Ctrl)**
ExecIRSigma(IR_b, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopInfinite, IR_b, v_b), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecIR-Loop-Cond-False)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Val(false), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (Val(()), Ïƒ_1)

**(ExecIR-Loop-Cond-True-Step)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Val(true), Ïƒ_1)    ExecIRSigma(IR_b, Ïƒ_1) â‡“ (Val(v), Ïƒ_2)    ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (out, Ïƒ_3)

**(ExecIR-Loop-Cond-Continue)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Val(true), Ïƒ_1)    ExecIRSigma(IR_b, Ïƒ_1) â‡“ (Ctrl(Continue), Ïƒ_2)    ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (out, Ïƒ_3)

**(ExecIR-Loop-Cond-Break)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Val(true), Ïƒ_1)    ExecIRSigma(IR_b, Ïƒ_1) â‡“ (Ctrl(Break(v_opt)), Ïƒ_2)    v = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (Val(v), Ïƒ_2)

**(ExecIR-Loop-Cond-Ctrl)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecIR-Loop-Cond-Body-Ctrl)**
ExecIRSigma(IR_c, Ïƒ) â‡“ (Val(true), Ïƒ_1)    ExecIRSigma(IR_b, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

LoopIterIRJudg = {Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (out, Ïƒ')}

**(ExecIR-Loop-Iter)**
ExecIRSigma(IR_i, Ïƒ) â‡“ (Val(v_iter), Ïƒ_1)    IterInit(v_iter) â‡“ it    Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopIter, pat, ty_opt, IR_i, v_iter, IR_b, v_b), Ïƒ) â‡“ (out, Ïƒ_2)

**(ExecIR-Loop-Iter-Ctrl)**
ExecIRSigma(IR_i, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(LoopIR(LoopIter, pat, ty_opt, IR_i, v_iter, IR_b, v_b), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(LoopIterIR-Done)**
IterNext(it) â‡“ (âŠ¥, it')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (Val(()), Ïƒ)

**(LoopIterIR-Step-Val)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ ExecBlockBindIRSigma(pat, v, IR_b, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it', Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (out, Ïƒ_2)

**(LoopIterIR-Step-Continue)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ ExecBlockBindIRSigma(pat, v, IR_b, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ_1)    Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it', Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (out, Ïƒ_2)

**(LoopIterIR-Step-Break)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ ExecBlockBindIRSigma(pat, v, IR_b, Ïƒ) â‡“ (Ctrl(Break(v_opt)), Ïƒ_1)    v' = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (Val(v'), Ïƒ_1)

**(LoopIterIR-Step-Ctrl)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ ExecBlockBindIRSigma(pat, v, IR_b, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExecIRSigma(pat, IR_b, it, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecIR-Region)**
RegionNew(Ïƒ, v_o) â‡“ (Ïƒ_1, r, scope)    BindRegionAlias(Ïƒ_1, alias_opt, r) â‡“ Ïƒ_2    Î“ âŠ¢ ExecInScopeIRSigma(IR_b, Ïƒ_2, scope) â‡“ (out, Ïƒ_3)    RegionRelease(Ïƒ_3, r, scope, out) â‡“ (out', Ïƒ_4)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(RegionIR(v_o, alias_opt, IR_b, v_b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_4)

**(ExecIR-Frame-Implicit)**
ActiveTarget(Ïƒ) = r    FrameEnter(Ïƒ, r) â‡“ (Ïƒ_1, F, scope, mark)    Î“ âŠ¢ ExecInScopeIRSigma(IR_b, Ïƒ_1, scope) â‡“ (out, Ïƒ_2)    FrameReset(Ïƒ_2, r, scope, mark, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(FrameIR(âŠ¥, IR_b, v_b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_3)

**(ExecIR-Frame-Explicit)**
RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ, h) = r_t    FrameEnter(Ïƒ, r_t) â‡“ (Ïƒ_1, F, scope, mark)    Î“ âŠ¢ ExecInScopeIRSigma(IR_b, Ïƒ_1, scope) â‡“ (out, Ïƒ_2)    FrameReset(Ïƒ_2, r_t, scope, mark, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ExecIRSigma(FrameIR(v_r, IR_b, v_b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_3)

**Lowering Helpers.**

**(LowerList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerList([]) â‡“ âŸ¨Îµ, []âŸ©

**(LowerList-Cons)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    Î“ âŠ¢ LowerList(es) â‡“ âŸ¨IR_s, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerList(e::es) â‡“ âŸ¨SeqIR(IR_e, IR_s), [v] ++ vec_vâŸ©

**(LowerFieldInits-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerFieldInits([]) â‡“ âŸ¨Îµ, []âŸ©

**(LowerFieldInits-Cons)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    Î“ âŠ¢ LowerFieldInits(fs) â‡“ âŸ¨IR_s, vec_fâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerFieldInits([âŸ¨f, eâŸ©] ++ fs) â‡“ âŸ¨SeqIR(IR_e, IR_s), [âŸ¨f, vâŸ©] ++ vec_fâŸ©

**(LowerOpt-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerOpt(âŠ¥) â‡“ âŸ¨Îµ, âŠ¥âŸ©

**(LowerOpt-Some)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerOpt(e) â‡“ âŸ¨IR_e, vâŸ©

IsRangeExpr(e) â‡” ExprType(e) = TypeRange

**Expression Lowering.** The rules below define `LowerExpr`.

**(Lower-Expr-Literal)**
T = ExprType(Literal(â„“))    LiteralValue(â„“, T) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Literal(â„“)) â‡“ âŸ¨Îµ, vâŸ©

**(Lower-Expr-PtrNull)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(PtrNullExpr) â‡“ âŸ¨Îµ, Ptr@Null(0x0)âŸ©

**(Lower-Expr-Ident-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥    Î“ âŠ¢ LowerReadPlace(Identifier(x)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Identifier(x)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Identifier(x)) â‡“ âŸ¨ReadPathIR(path, name), vâŸ©

**(Lower-Expr-Path)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Path(path, name)) â‡“ âŸ¨ReadPathIR(path, name), vâŸ©

**(Lower-Expr-Error)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(ErrorExpr(span)) â‡“ âŸ¨LowerPanic(ErrorExpr(span)), v_unreachâŸ©

**(Lower-Expr-Tuple)**
Î“ âŠ¢ LowerList(es) â‡“ âŸ¨IR, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(TupleExpr(es)) â‡“ âŸ¨IR, (v_1, â€¦, v_n)âŸ©

**(Lower-Expr-Array)**
Î“ âŠ¢ LowerList(es) â‡“ âŸ¨IR, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(ArrayExpr(es)) â‡“ âŸ¨IR, [v_1, â€¦, v_n]âŸ©

**(Lower-Expr-Record)**
Î“ âŠ¢ LowerFieldInits(fields) â‡“ âŸ¨IR, vec_fâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(RecordExpr(tr, fields)) â‡“ âŸ¨IR, RecordValue(tr, vec_f)âŸ©

**(Lower-Expr-Enum-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(EnumLiteral(path, âŠ¥)) â‡“ âŸ¨Îµ, EnumValue(path, âŠ¥)âŸ©

**(Lower-Expr-Enum-Tuple)**
Î“ âŠ¢ LowerList(es) â‡“ âŸ¨IR, vec_vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(EnumLiteral(path, Paren(es))) â‡“ âŸ¨IR, EnumValue(path, TuplePayload(vec_v))âŸ©

**(Lower-Expr-Enum-Record)**
Î“ âŠ¢ LowerFieldInits(fields) â‡“ âŸ¨IR, vec_fâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(EnumLiteral(path, Brace(fields))) â‡“ âŸ¨IR, EnumValue(path, RecordPayload(vec_f))âŸ©

**(Lower-Expr-FieldAccess)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    FieldValue(v_b, f) = v_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(FieldAccess(base, f)) â‡“ âŸ¨IR_b, v_fâŸ©

**(Lower-Expr-TupleAccess)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    TupleValue(v_b, i) = v_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(TupleAccess(base, i)) â‡“ âŸ¨IR_b, v_iâŸ©

**(Lower-Expr-Index-Scalar)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Î“ âŠ¢ CheckIndex(Len(v_b), v_i) â‡“ ok    IndexValue(v_b, v_i) = v_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(IndexAccess(base, idx)) â‡“ âŸ¨SeqIR(IR_b, IR_i), v_eâŸ©

**(Lower-Expr-Index-Scalar-OOB)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Â¬(0 â‰¤ v_i < Len(v_b))    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(IndexAccess(base, idx)) â‡“ âŸ¨SeqIR(IR_b, IR_i, IR_k), v_unreachâŸ©

**(Lower-Expr-Index-Range)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    Î“ âŠ¢ CheckRange(Len(v_b), v_r) â‡“ ok    SliceValue(v_b, v_r) = v_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(IndexAccess(base, idx)) â‡“ âŸ¨SeqIR(IR_b, IR_i), v_sâŸ©

**(Lower-Expr-Index-Range-OOB)**
Î“ âŠ¢ LowerExpr(base) â‡“ âŸ¨IR_b, v_bâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_b)) = âŠ¥    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(IndexAccess(base, idx)) â‡“ âŸ¨SeqIR(IR_b, IR_i, IR_k), v_unreachâŸ©

**(Lower-Expr-Call-PanicOut)**
Î“ âŠ¢ LowerExpr(callee) â‡“ âŸ¨IR_c, v_câŸ©    Î“ âŠ¢ LowerArgs(Params(Call(callee, args)), args) â‡“ âŸ¨IR_a, vec_vâŸ©    NeedsPanicOut(callee)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Call(callee, args)) â‡“ âŸ¨SeqIR(IR_c, IR_a, CallIR(v_c, vec_v ++ [PanicOutName]), PanicCheck), v_callâŸ©

**(Lower-Expr-Call-NoPanicOut)**
Î“ âŠ¢ LowerExpr(callee) â‡“ âŸ¨IR_c, v_câŸ©    Î“ âŠ¢ LowerArgs(Params(Call(callee, args)), args) â‡“ âŸ¨IR_a, vec_vâŸ©    Â¬ NeedsPanicOut(callee)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Call(callee, args)) â‡“ âŸ¨SeqIR(IR_c, IR_a, CallIR(v_c, vec_v)), v_callâŸ©

**(Lower-Expr-MethodCall)**
Î“ âŠ¢ LowerMethodCall(MethodCall(base, name, args)) â‡“ âŸ¨IR, v_callâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(MethodCall(base, name, args)) â‡“ âŸ¨IR, v_callâŸ©

**(Lower-Expr-Unary)**
Î“ âŠ¢ LowerUnOp(op, e) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Unary(op, e)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Bin-And)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Binary("&&", e_1, e_2)) â‡“ âŸ¨SeqIR(IR_1, IfIR(v_1, IR_2, v_2, Îµ, false)), v_andâŸ©

**(Lower-Expr-Bin-Or)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Binary("||", e_1, e_2)) â‡“ âŸ¨SeqIR(IR_1, IfIR(v_1, Îµ, true, IR_2, v_2)), v_orâŸ©

**(Lower-Expr-Binary)**
op âˆ‰ {"&&", "||"}    Î“ âŠ¢ LowerBinOp(op, e_1, e_2) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Binary(op, e_1, e_2)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Cast)**
Î“ âŠ¢ LowerCast(e, T) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Cast(e, T)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Transmute)**
Î“ âŠ¢ LowerTransmute(T_1, T_2, e) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(TransmuteExpr(T_1, T_2, e)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Propagate-Success)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    U = ExprType(e)    SuccessMember(RetType(Î“), U) = T_s    UnionCase(v) = âŸ¨T_s, v_sâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Propagate(e)) â‡“ âŸ¨IR_e, v_sâŸ©

**(Lower-Expr-Propagate-Return)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    U = ExprType(e)    SuccessMember(RetType(Î“), U) = T_s    UnionCase(v) = âŸ¨T_e, v_eâŸ©    T_e â‰  T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Propagate(e)) â‡“ âŸ¨SeqIR(IR_e, ReturnIR(v_e)), v_unreachâŸ©

**(Lower-Expr-Range)**
Î“ âŠ¢ LowerRangeExpr(Range(kind, lo_opt, hi_opt)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Range(kind, lo_opt, hi_opt)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-If)**
Î“ âŠ¢ LowerExpr(cond) â‡“ âŸ¨IR_c, v_câŸ©    Î“ âŠ¢ LowerBlock(b_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerBlock(b_2) â‡“ âŸ¨IR_2, v_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(IfExpr(cond, b_1, b_2)) â‡“ âŸ¨SeqIR(IR_c, IfIR(v_c, IR_1, v_1, IR_2, v_2)), v_ifâŸ©

**(Lower-Expr-Match)**
Î“ âŠ¢ LowerMatch(scrut, arms) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(MatchExpr(scrut, arms)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-LoopInf)**
Î“ âŠ¢ LowerLoop(LoopInfinite(body)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(LoopInfinite(body)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-LoopCond)**
Î“ âŠ¢ LowerLoop(LoopConditional(cond, body)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(LoopConditional(cond, body)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-LoopIter)**
Î“ âŠ¢ LowerLoop(LoopIter(pat, ty_opt, iter, body)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(LoopIter(pat, ty_opt, iter, body)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Block)**
Î“ âŠ¢ LowerBlock(BlockExpr(stmts, tail_opt)) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(BlockExpr(stmts, tail_opt)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-UnsafeBlock)**
Î“ âŠ¢ LowerBlock(b) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(UnsafeBlockExpr(b)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-Move)**
Î“ âŠ¢ LowerMovePlace(p) â‡“ âŸ¨IR, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(MoveExpr(p)) â‡“ âŸ¨IR, vâŸ©

**(Lower-Expr-AddressOf)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR, addrâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(AddressOf(p)) â‡“ âŸ¨IR, Ptr@Valid(addr)âŸ©

**(Lower-Expr-Deref)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, v_ptrâŸ©    Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨IR_d, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(Deref(e)) â‡“ âŸ¨SeqIR(IR_e, IR_d), vâŸ©

**(Lower-Expr-Alloc)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerExpr(AllocExpr(r_opt, e)) â‡“ âŸ¨SeqIR(IR_e, AllocIR(r_opt, v)), v_allocâŸ©

**Operator and Cast Lowering.**

OpPanicReason(op, v) = r
OpPanicReason(op, v_1, v_2) = r
OpPanicReason(op, v) =
 Overflow    if op = "-"
 Other       otherwise
OpPanicReason(op, v_1, v_2) =
 DivZero     if op âˆˆ {"/", "%"} âˆ§ IntValue(v_1, t) âˆ§ IntValue(v_2, t) âˆ§ v_2 = 0
 Overflow    if op âˆˆ {"/", "%"} âˆ§ IntValue(v_1, t) âˆ§ IntValue(v_2, t) âˆ§ v_2 â‰  0
 Shift       if op âˆˆ ShiftOps
 Overflow    if op âˆˆ {"+", "-", "*", "**"} âˆ§ IntValue(v_1, t) âˆ§ IntValue(v_2, t)
 Other       otherwise

**(Lower-UnOp-Ok)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    UnOp(op, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerUnOp(op, e) â‡“ âŸ¨IR_e, v'âŸ©

**(Lower-UnOp-Panic)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    UnOp(op, v) undefined    OpPanicReason(op, v) = r    Î“ âŠ¢ LowerPanic(r) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerUnOp(op, e) â‡“ âŸ¨SeqIR(IR_e, IR_k), v_unreachâŸ©

**(Lower-BinOp-Ok)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©    BinOp(op, v_1, v_2) â‡“ v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBinOp(op, e_1, e_2) â‡“ âŸ¨SeqIR(IR_1, IR_2), vâŸ©

**(Lower-BinOp-Panic)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©    BinOp(op, v_1, v_2) undefined    OpPanicReason(op, v_1, v_2) = r    Î“ âŠ¢ LowerPanic(r) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBinOp(op, e_1, e_2) â‡“ âŸ¨SeqIR(IR_1, IR_2, IR_k), v_unreachâŸ©

**(Lower-Cast)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ©    S = ExprType(e)    CastVal(S, T, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerCast(e, T) â‡“ âŸ¨IR, v'âŸ©

**(Lower-Cast-Panic)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ©    S = ExprType(e)    CastVal(S, T, v) undefined    Î“ âŠ¢ LowerPanic(Cast) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerCast(e, T) â‡“ âŸ¨SeqIR(IR, IR_k), v_unreachâŸ©

PlaceForms0 = {Identifier(_), FieldAccess(_, _), TupleAccess(_, _), IndexAccess(_, _), Deref(_)}
LowerPlaceTotal(Î“) â‡” âˆ€ p. p âˆˆ PlaceForms0 â‡’ âˆƒ l. Î“ âŠ¢ LowerPlace(p) â‡“ l
LowerPlacePreserve(Î“) â‡”
 âˆ€ p, l. Î“ âŠ¢ LowerPlace(p) â‡“ l â‡’ (âˆ€ Ïƒ, out, Ïƒ'. Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (out, Ïƒ') â‡’ Î“ âŠ¢ ReadPlaceSigma(l, Ïƒ) â‡“ (out, Ïƒ')) âˆ§ (âˆ€ Ïƒ, v, sout, Ïƒ'. Î“ âŠ¢ WritePlaceSigma(p, v, Ïƒ) â‡“ (sout, Ïƒ') â‡’ Î“ âŠ¢ WritePlaceSigma(l, v, Ïƒ) â‡“ (sout, Ïƒ'))

**Place Lowering Rules.**

**(Lower-Place-Ident)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerPlace(Identifier(x)) â‡“ Identifier(x)

**(Lower-Place-Field)**
Î“ âŠ¢ LowerPlace(p) â‡“ l
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerPlace(FieldAccess(p, f)) â‡“ FieldAccess(l, f)

**(Lower-Place-Tuple)**
Î“ âŠ¢ LowerPlace(p) â‡“ l
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerPlace(TupleAccess(p, i)) â‡“ TupleAccess(l, i)

**(Lower-Place-Index)**
Î“ âŠ¢ LowerPlace(p) â‡“ l
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerPlace(IndexAccess(p, idx)) â‡“ IndexAccess(l, idx)

**(Lower-Place-Deref)**
Î“ âŠ¢ LowerPlace(p) â‡“ l
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerPlace(Deref(p)) â‡“ Deref(l)

**Place Access Lowering.**

DropOnAssignRoot(p) â‡” PlaceRoot(p) = x âˆ§ ((Î“ âŠ¢ ResolveValueName(x) â‡“ ent âˆ§ ent.origin_opt = âŠ¥ âˆ§ BindInfo(x).mov = immov âˆ§ BindInfo(x).resp = resp) âˆ¨ (Î“ âŠ¢ ResolveValueName(x) â‡“ ent âˆ§ ent.origin_opt = mp âˆ§ name = (ent.target_opt if present, else x) âˆ§ path = PathOfModule(mp) âˆ§ StaticBindInfo(path, name).mov = immov âˆ§ StaticBindInfo(path, name).resp = resp))

**(Lower-ReadPlace-Ident-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(Identifier(x)) â‡“ âŸ¨ReadVarIR(x), vâŸ©

**(Lower-ReadPlace-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(Identifier(x)) â‡“ âŸ¨ReadPathIR(path, name), vâŸ©

**(Lower-ReadPlace-Field)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    FieldValue(v_p, f) = v_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(FieldAccess(p, f)) â‡“ âŸ¨IR_p, v_fâŸ©

**(Lower-ReadPlace-Tuple)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    TupleValue(v_p, i) = v_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(TupleAccess(p, i)) â‡“ âŸ¨IR_p, v_iâŸ©

**(Lower-ReadPlace-Index-Scalar)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Î“ âŠ¢ CheckIndex(Len(v_p), v_i) â‡“ ok    IndexValue(v_p, v_i) = v_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_i), v_eâŸ©

**(Lower-ReadPlace-Index-Scalar-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Â¬(0 â‰¤ v_i < Len(v_p))    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_i, IR_k), v_unreachâŸ©

**(Lower-ReadPlace-Index-Range)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    Î“ âŠ¢ CheckRange(Len(v_p), v_r) â‡“ ok    SliceValue(v_p, v_r) = v_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_i), v_sâŸ©

**(Lower-ReadPlace-Index-Range-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_p)) = âŠ¥    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_i, IR_k), v_unreachâŸ©

**(Lower-ReadPlace-Deref)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©    Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨IR_d, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerReadPlace(Deref(p)) â‡“ âŸ¨SeqIR(IR_p, IR_d), vâŸ©

**(Lower-AddrOf-Ident-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Identifier(x)) â‡“ âŸ¨Îµ, AddrOfBind(x)âŸ©

**(Lower-AddrOf-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticSymPath(path, name) = sym    StaticAddr(path, name) = addr    IR_p = CheckPoison(m) if ProcModule(sym) = m, otherwise Îµ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Identifier(x)) â‡“ âŸ¨IR_p, addrâŸ©

**(Lower-AddrOf-Field)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©    T_b = ExprType(p)    FieldAddr(T_b, addr, f) = addr'    IR_t = CallIR(RegionAddrTagFromSym, [addr', addr])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(FieldAccess(p, f)) â‡“ âŸ¨SeqIR(IR_p, IR_t), addr'âŸ©

**(Lower-AddrOf-Tuple)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©    T_b = ExprType(p)    TupleAddr(T_b, addr, i) = addr'    IR_t = CallIR(RegionAddrTagFromSym, [addr', addr])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(TupleAccess(p, i)) â‡“ âŸ¨SeqIR(IR_p, IR_t), addr'âŸ©


**(Lower-AddrOf-Index)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©    Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_r, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    T_b = ExprType(p)    Î“ âŠ¢ CheckIndex(Len(v_p), v_i) â‡“ ok    IndexAddr(T_b, addr, v_i) = addr'    IR_t = CallIR(RegionAddrTagFromSym, [addr', addr])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_r, IR_i, IR_t), addr'âŸ©

**(Lower-AddrOf-Index-OOB)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©    Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_r, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Â¬(0 â‰¤ v_i < Len(v_p))    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(IndexAccess(p, idx)) â‡“ âŸ¨SeqIR(IR_p, IR_r, IR_i, IR_k), v_unreachâŸ©

**(Lower-AddrOf-Deref)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©    PtrType(v_ptr) = TypePtr(T, `Valid`)    PtrAddr(v_ptr) = addr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Deref(p)) â‡“ âŸ¨IR_p, addrâŸ©

**(Lower-AddrOf-Deref-Null)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©    PtrType(v_ptr) = TypePtr(T, `Null`)    PtrAddr(v_ptr) = addr    Î“ âŠ¢ LowerPanic(NullDeref) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Deref(p)) â‡“ âŸ¨SeqIR(IR_p, IR_k), addrâŸ©

**(Lower-AddrOf-Deref-Expired)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©    PtrType(v_ptr) = TypePtr(T, `Expired`)    PtrAddr(v_ptr) = addr    Î“ âŠ¢ LowerPanic(ExpiredDeref) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Deref(p)) â‡“ âŸ¨SeqIR(IR_p, IR_k), addrâŸ©

**(Lower-AddrOf-Deref-Raw)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©    PtrType(v_ptr) = TypeRawPtr(q, T)    PtrAddr(v_ptr) = addr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerAddrOf(Deref(p)) â‡“ âŸ¨IR_p, addrâŸ©

**(Lower-WritePlace-Ident-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(Identifier(x), v) â‡“ StoreVarIR(x, v)

**(Lower-WritePlace-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticSymPath(path, name) = sym    IR_p = CheckPoison(m) if ProcModule(sym) = m, otherwise Îµ    IR_d = EmitDrop(StaticType(path, name), Load(@sym, StaticType(path, name))) if StaticBindInfo(path, name).resp = resp, otherwise Îµ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(Identifier(x), v) â‡“ SeqIR(IR_p, IR_d, StoreGlobal(sym, v))

**(Lower-WritePlace-Field)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    FieldValue(v_p, f) = v_f    T_f = ExprType(FieldAccess(p, f))    IR_d = EmitDrop(T_f, v_f) if DropOnAssignRoot(p), otherwise Îµ    FieldUpdate(v_p, f, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(FieldAccess(p, f), v) â‡“ SeqIR(IR_p, IR_d, IR_w)

**(Lower-WritePlace-Tuple)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    TupleValue(v_p, i) = v_i    T_i = ExprType(TupleAccess(p, i))    IR_d = EmitDrop(T_i, v_i) if DropOnAssignRoot(p), otherwise Îµ    TupleUpdate(v_p, i, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(TupleAccess(p, i), v) â‡“ SeqIR(IR_p, IR_d, IR_w)

**(Lower-WritePlace-Index-Scalar)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Î“ âŠ¢ CheckIndex(Len(v_p), v_i) â‡“ ok    IndexValue(v_p, v_i) = v_e    T_e = ExprType(IndexAccess(p, idx))    IR_d = EmitDrop(T_e, v_e) if DropOnAssignRoot(p), otherwise Îµ    IndexUpdate(v_p, v_i, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_d, IR_w)

**(Lower-WritePlace-Index-Scalar-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Â¬(0 â‰¤ v_i < Len(v_p))    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(Lower-WritePlace-Index-Range)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    Î“ âŠ¢ CheckRange(Len(v_p), v_r) â‡“ ok    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n = end - start    SliceUpdate(v_p, start, v) â‡“ v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_w)

**(Lower-WritePlace-Index-Range-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_p)) = âŠ¥    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(Lower-WritePlace-Index-Range-Len)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n â‰  end - start    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(Lower-WritePlace-Deref)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlace(Deref(p), v) â‡“ SeqIR(IR_p, WritePtrIR(v_ptr, v))

**Write-Subplace Lowering.**

**(LowerWriteSub-Ident-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(Identifier(x), v) â‡“ StoreVarNoDropIR(x, v)

**(LowerWriteSub-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticSymPath(path, name) = sym    IR_p = CheckPoison(m) if ProcModule(sym) = m, otherwise Îµ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(Identifier(x), v) â‡“ SeqIR(IR_p, StoreGlobal(sym, v))

**(LowerWriteSub-Field)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    FieldUpdate(v_p, f, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(FieldAccess(p, f), v) â‡“ SeqIR(IR_p, IR_w)

**(LowerWriteSub-Tuple)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    TupleUpdate(v_p, i, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(TupleAccess(p, i), v) â‡“ SeqIR(IR_p, IR_w)

**(LowerWriteSub-Index-Scalar)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Î“ âŠ¢ CheckIndex(Len(v_p), v_i) â‡“ ok    IndexUpdate(v_p, v_i, v) = v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_w)

**(LowerWriteSub-Index-Scalar-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_iâŸ©    ExprType(idx) = TypePrim("usize")    Â¬(0 â‰¤ v_i < Len(v_p))    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(LowerWriteSub-Index-Range)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    Î“ âŠ¢ CheckRange(Len(v_p), v_r) â‡“ ok    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n = end - start    SliceUpdate(v_p, start, v) â‡“ v_p'    Î“ âŠ¢ LowerWritePlaceSub(p, v_p') â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_w)

**(LowerWriteSub-Index-Range-OOB)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_p)) = âŠ¥    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(LowerWriteSub-Index-Range-Len)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(idx) â‡“ âŸ¨IR_i, v_râŸ©    IsRangeExpr(idx)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n â‰  end - start    Î“ âŠ¢ LowerPanic(Bounds) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(IndexAccess(p, idx), v) â‡“ SeqIR(IR_p, IR_i, IR_k)

**(LowerWriteSub-Deref)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, v_ptrâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerWritePlaceSub(Deref(p), v) â‡“ SeqIR(IR_p, WritePtrIR(v_ptr, v))

**(Lower-MovePlace)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMovePlace(p) â‡“ âŸ¨SeqIR(IR_p, MoveStateIR(p)), vâŸ©

### 6.5. Statement and Block Lowering

LowerStmtJudg = {LowerStmt, LowerStmtList, LowerBlock, LowerLoop}

**(Lower-Stmt-Correctness)**
âˆ€ Ïƒ, Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (sout, Ïƒ') â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (sout, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(s) â‡“ IR

**(Lower-Block-Correctness)**
âˆ€ Ïƒ, out, Ïƒ'. Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (out, Ïƒ') â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ') âˆ§ (out = Val(v') â‡’ v = v'))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBlock(b) â‡“ âŸ¨IR, vâŸ©

**(Lower-Loop-Correctness)**
âˆ€ Ïƒ, Î“ âŠ¢ EvalSigma(loop, Ïƒ) â‡“ (out, Ïƒ') â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerLoop(loop) â‡“ âŸ¨IR, vâŸ©

StmtForms0 = {LetStmt(_), VarStmt(_), ShadowLetStmt(_, _, _), ShadowVarStmt(_, _, _), AssignStmt(_, _), CompoundAssignStmt(_, _, _), ExprStmt(_), DeferStmt(_), RegionStmt(_, _, _), FrameStmt(_, _), ReturnStmt(_), BreakStmt(_), ContinueStmt, UnsafeBlockStmt(_), ErrorStmt(_)}
LowerStmtTotal(Î“) â‡” âˆ€ s. s âˆˆ StmtForms0 â‡’ âˆƒ IR. Î“ âŠ¢ LowerStmt(s) â‡“ IR

**(Lower-StmtList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmtList([]) â‡“ Îµ

**(Lower-StmtList-Cons)**
Î“ âŠ¢ LowerStmt(s) â‡“ IR_s    Î“ âŠ¢ LowerStmtList(ss) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmtList(s::ss) â‡“ SeqIR(IR_s, IR_r)

BindingParts(binding) = âŸ¨pat, ty_opt, op, init, spanâŸ©

**(Lower-Stmt-Let)**
BindingParts(binding) = âŸ¨pat, ty_opt, op, init, spanâŸ©    Î“ âŠ¢ LowerExpr(init) â‡“ âŸ¨IR_i, vâŸ©    Î“ âŠ¢ LowerBindPattern(pat, v) â‡“ IR_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(LetStmt(binding)) â‡“ SeqIR(IR_i, IR_b)

**(Lower-Stmt-Var)**
BindingParts(binding) = âŸ¨pat, ty_opt, op, init, spanâŸ©    Î“ âŠ¢ LowerExpr(init) â‡“ âŸ¨IR_i, vâŸ©    Î“ âŠ¢ LowerBindPattern(pat, v) â‡“ IR_b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(VarStmt(binding)) â‡“ SeqIR(IR_i, IR_b)

**(Lower-Stmt-ShadowLet)**
Î“ âŠ¢ LowerExpr(init) â‡“ âŸ¨IR_i, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ShadowLetStmt(x, ty_opt, init)) â‡“ SeqIR(IR_i, BindVarIR(x, v))

**(Lower-Stmt-ShadowVar)**
Î“ âŠ¢ LowerExpr(init) â‡“ âŸ¨IR_i, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ShadowVarStmt(x, ty_opt, init)) â‡“ SeqIR(IR_i, BindVarIR(x, v))

**(Lower-Stmt-Assign)**
Î“ âŠ¢ LowerExpr(expr) â‡“ âŸ¨IR_e, vâŸ©    Î“ âŠ¢ LowerWritePlace(place, v) â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(AssignStmt(place, expr)) â‡“ SeqIR(IR_e, IR_w)

**(Lower-Stmt-CompoundAssign)**
Î“ âŠ¢ LowerReadPlace(place) â‡“ âŸ¨IR_p, v_pâŸ©    Î“ âŠ¢ LowerExpr(expr) â‡“ âŸ¨IR_e, v_eâŸ©    BinOp(op, v_p, v_e) â‡“ v    Î“ âŠ¢ LowerWritePlace(place, v) â‡“ IR_w
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(CompoundAssignStmt(place, op, expr)) â‡“ SeqIR(IR_p, IR_e, IR_w)


**(Lower-Stmt-Expr)**
Î“ âŠ¢ LowerExpr(expr) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ExprStmt(expr)) â‡“ IR_e

**(Lower-Stmt-Defer)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(DeferStmt(block)) â‡“ DeferIR(block)

**(Lower-Stmt-Region)**
opts = RegionOptsExpr(opts_opt)    Î“ âŠ¢ LowerExpr(opts) â‡“ âŸ¨IR_o, v_oâŸ©    Î“ âŠ¢ LowerBlock(block) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(RegionStmt(opts_opt, alias_opt, block)) â‡“ SeqIR(IR_o, RegionIR(v_o, alias_opt, IR_b, v_b))

**(Lower-Stmt-Frame-Implicit)**
Î“ âŠ¢ LowerBlock(block) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(FrameStmt(âŠ¥, block)) â‡“ FrameIR(âŠ¥, IR_b, v_b)

**(Lower-Stmt-Frame-Explicit)**
Î“ âŠ¢ LowerExpr(Identifier(r)) â‡“ âŸ¨IR_r, v_râŸ©    Î“ âŠ¢ LowerBlock(block) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(FrameStmt(r, block)) â‡“ SeqIR(IR_r, FrameIR(v_r, IR_b, v_b))

**(Lower-Stmt-Return)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ReturnStmt(e)) â‡“ SeqIR(IR_e, ReturnIR(v))

**(Lower-Stmt-Return-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ReturnStmt(âŠ¥)) â‡“ ReturnIR(())

**(Lower-Stmt-Break)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(BreakStmt(e)) â‡“ SeqIR(IR_e, BreakIR(v))

**(Lower-Stmt-Break-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(BreakStmt(âŠ¥)) â‡“ BreakIR(âŠ¥)

**(Lower-Stmt-Continue)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ContinueStmt) â‡“ ContinueIR

**(Lower-Stmt-UnsafeBlock)**
Î“ âŠ¢ LowerBlock(block) â‡“ âŸ¨IR_b, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(UnsafeBlockStmt(block)) â‡“ IR_b

**(Lower-Stmt-Error)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerStmt(ErrorStmt(span)) â‡“ LowerPanic(ErrorStmt(span))

**Temporary Cleanup in Lowering.**

Let TempDropOrder(s) = [e_1, â€¦, e_k]. For each i, let
Î“ âŠ¢ LowerExpr(e_i) â‡“ âŸ¨IR_i, v_iâŸ©
denote the unique invocation of LowerExpr(e_i) in the derivation of
Î“ âŠ¢ LowerStmt(s) â‡“ IR_s, and let ExprType(e_i) = T_i.

TempCleanupIR(s) =
 Îµ    if k = 0
 SeqIRList([EmitDrop(T_k, v_k), â€¦, EmitDrop(T_1, v_1)])    otherwise

For s âˆ‰ {ReturnStmt(_), BreakStmt(_), ContinueStmt}, the lowering MUST produce
Î“ âŠ¢ LowerStmt(s) â‡“ SeqIR(IR_s, TempCleanupIR(s)).

For control-flow statements, the lowering MUST emit temporary cleanup immediately before the control transfer:

Î“ âŠ¢ LowerStmt(ReturnStmt(e)) â‡“ SeqIR(IR_e, TempCleanupIR(s), ReturnIR(v))
Î“ âŠ¢ LowerStmt(BreakStmt(e)) â‡“ SeqIR(IR_e, TempCleanupIR(s), BreakIR(v))
Î“ âŠ¢ LowerStmt(BreakStmt(âŠ¥)) â‡“ SeqIR(TempCleanupIR(s), BreakIR(âŠ¥))
Î“ âŠ¢ LowerStmt(ContinueStmt) â‡“ SeqIR(TempCleanupIR(s), ContinueIR)

BlockForms0 = {BlockExpr(_, _)}
LoopForms0 = {LoopInfinite(_), LoopConditional(_, _), LoopIter(_, _, _, _)}
LowerBlockTotal(Î“) â‡” âˆ€ b. b âˆˆ BlockForms0 â‡’ âˆƒ IR, v. Î“ âŠ¢ LowerBlock(b) â‡“ âŸ¨IR, vâŸ©
LowerLoopTotal(Î“) â‡” âˆ€ l. l âˆˆ LoopForms0 â‡’ âˆƒ IR, v. Î“ âŠ¢ LowerLoop(l) â‡“ âŸ¨IR, vâŸ©

**(Lower-Block-Tail)**
tail â‰  âŠ¥    Î“ âŠ¢ LowerStmtList(stmts) â‡“ IR_s    Î“ âŠ¢ LowerExpr(tail) â‡“ âŸ¨IR_t, v_tâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBlock(BlockExpr(stmts, tail)) â‡“ âŸ¨BlockIR(IR_s, IR_t, v_t), v_blockâŸ©

**(Lower-Block-Unit)**
Î“ âŠ¢ LowerStmtList(stmts) â‡“ IR_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBlock(BlockExpr(stmts, âŠ¥)) â‡“ âŸ¨BlockIR(IR_s, Îµ, ()), v_blockâŸ©

**(Lower-Loop-Infinite)**
Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerLoop(LoopInfinite(body)) â‡“ âŸ¨LoopIR(LoopInfinite, IR_b, v_b), v_loopâŸ©

**(Lower-Loop-Cond)**
Î“ âŠ¢ LowerExpr(cond) â‡“ âŸ¨IR_c, v_câŸ©    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerLoop(LoopConditional(cond, body)) â‡“ âŸ¨LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b), v_loopâŸ©

**(Lower-Loop-Iter)**
Î“ âŠ¢ LowerExpr(iter) â‡“ âŸ¨IR_i, v_iterâŸ©    Î“ âŠ¢ LowerBlock(body) â‡“ âŸ¨IR_b, v_bâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerLoop(LoopIter(pat, ty_opt, iter, body)) â‡“ âŸ¨LoopIR(LoopIter, pat, ty_opt, IR_i, v_iter, IR_b, v_b), v_loopâŸ©


### 6.6. Pattern Matching Lowering

PatternLowerJudg = {LowerBindPattern, LowerBindList, LowerMatch, TagOf}

**(Lower-Pat-Correctness)**
âˆ€ v, Î“ âŠ¢ MatchPattern(pat, v) â‡“ B â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (ok, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBindPattern(pat, v) â‡“ IR
MatchValueCorrect(Î“, scrut, arms, v) â‡” âˆ€ Ïƒ, v', Ïƒ'. Î“ âŠ¢ EvalSigma(MatchExpr(scrut, arms), Ïƒ) â‡“ (Val(v'), Ïƒ') â‡’ v = v'

**(Lower-Match-Correctness)**
âˆ€ Ïƒ, Î“ âŠ¢ EvalSigma(MatchExpr(scrut, arms), Ïƒ) â‡“ (out, Ïƒ') â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ')    MatchValueCorrect(Î“, scrut, arms, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMatch(scrut, arms) â‡“ âŸ¨IR, vâŸ©

EnumValuePath(v) = path â‡” v = EnumValue(path, payload)
VariantIndex(E, name) = i â‡” Variants(E) = [v_0, â€¦, v_k] âˆ§ v_i.name = name
EnumDisc(E, name) = d â‡” EnumDiscriminants(E) â‡“ ds âˆ§ VariantIndex(E, name) = i âˆ§ ds[i] = d
StateIndex(M, S) = i â‡” States(M) = [S_0, â€¦, S_k] âˆ§ S_i = S

**(TagOf-Enum)**
EnumValuePath(v) = path    EnumPath(path) = p    T = TypePath(p)    EnumDecl(p) = E    VariantName(path) = name    EnumDisc(E, name) = d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TagOf(v, T) â‡“ d

**(TagOf-Modal)**
v = âŸ¨S, v_SâŸ©    T = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    StateIndex(M, S) = i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ TagOf(v, T) â‡“ i

LowerBindJudg = {LowerBindList, LowerBindPattern, LowerMatch}

**(Lower-BindList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBindList([]) â‡“ Îµ

**(Lower-BindList-Cons)**
Î“ âŠ¢ LowerBindList(bs) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBindList([âŸ¨x, vâŸ©] ++ bs) â‡“ SeqIR(BindVarIR(x, v), IR_r)

**(Lower-Pat-General)**
Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    Î“ âŠ¢ LowerBindList(binds) â‡“ IR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBindPattern(pat, v) â‡“ IR

**(Lower-Pat-Err)**
MatchPattern(pat, v) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerBindPattern(pat, v) â‡‘

**(Lower-Match)**
Î“ âŠ¢ LowerExpr(scrut) â‡“ âŸ¨IR_s, v_sâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerMatch(scrut, arms) â‡“ âŸ¨SeqIR(IR_s, MatchIR(v_s, arms)), v_matchâŸ©


### 6.7. Globals and Initialization

GlobalsJudg = {EmitGlobal, InitFn, DeinitFn, Lower-StaticInit, Lower-StaticInitItem, Lower-StaticInitItems, InitCallIR, Lower-StaticDeinit, Lower-StaticDeinitNames, Lower-StaticDeinitItem, Lower-StaticDeinitItems, DeinitCallIR, EmitInitPlan, EmitDeinitPlan, EmitStringLit, EmitBytesLit, InitPanicHandle}

ConstInitJudg = {ConstInit}

Î“ âŠ¢ ConstInit(e) â‡“ bytes â‡” e = Literal(lit) âˆ§ Î“ âŠ¢ EncodeConst(ExprType(e), lit) â‡“ bytes

StaticName(binding) =
 name    if binding = âŸ¨IdentifierPattern(name), ty_opt, op, init, spanâŸ©
 name    if binding = âŸ¨TypedPattern(name, _), ty_opt, op, init, spanâŸ©
 âŠ¥       otherwise

StaticBindTypes(binding) = B â‡” binding = âŸ¨pat, ty_opt, op, init, _âŸ© âˆ§ Î“ âŠ¢ pat â‡ BindType(binding) âŠ£ B

StaticBindList(binding) = PatNames(pat) â‡” binding = âŸ¨pat, _, _, _, _âŸ©

StaticBinding : StaticDecl Ã— Name â†’ StaticDecl

StaticSym(StaticDecl(_, _, _, binding, _, _), x) =
 Mangle(StaticDecl(_, _, _, binding, _, _))    if StaticName(binding) = x
 Mangle(StaticBinding(StaticDecl(_, _, _, binding, _, _), x))    otherwise

**(Emit-Static-Const)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    StaticName(binding) = name    binding = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ ConstInit(init) â‡“ bytes    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitGlobal(item) â‡“ [GlobalConst(sym, bytes)]

**(Emit-Static-Init)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    StaticName(binding) = name    binding = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ ConstInit(init) â‡‘    T = ExprType(init)    Î“ âŠ¢ Mangle(item) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitGlobal(item) â‡“ [GlobalZero(sym, sizeof(T))]

**(Emit-Static-Multi)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    StaticName(binding) = âŠ¥    StaticBindTypes(binding) = B    StaticBindList(binding) = [x_1, â€¦, x_k]    âˆ€ i, Î“ âŠ¢ Mangle(StaticBinding(item, x_i)) â‡“ sym_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitGlobal(item) â‡“ [GlobalZero(sym_1, sizeof(B[x_1])), â€¦, GlobalZero(sym_k, sizeof(B[x_k]))]

InitSym(m) = PathSig(["cursive", "runtime", "init"] ++ PathOfModule(m))

**(InitFn)**
InitSym(m) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InitFn(m) â‡“ sym

DeinitSym(m) = PathSig(["cursive", "runtime", "deinit"] ++ PathOfModule(m))

**(DeinitFn)**
DeinitSym(m) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DeinitFn(m) â‡“ sym

StaticItems(P, m) = [ item | item âˆˆ ASTModule(P, m).items âˆ§ item = StaticDecl(_, _, _, _, _, _) ]

StaticItemOf(path, name) = item â‡” m = path âˆ§ item âˆˆ StaticItems(Project(Î“), m) âˆ§ item = StaticDecl(_, _, _, binding, _, _) âˆ§ name âˆˆ StaticBindList(binding) âˆ§ âˆ€ item'. (item' âˆˆ StaticItems(Project(Î“), m) âˆ§ item' = StaticDecl(_, _, _, binding', _, _) âˆ§ name âˆˆ StaticBindList(binding')) â‡’ item' = item

StaticSymPath(path, name) = StaticSym(item, name) â‡” StaticItemOf(path, name) = item

StaticAddr(path, name) = addr â‡” âˆƒ sym. StaticSymPath(path, name) = sym âˆ§ AddrOfSym(sym) = addr

AddrOfSym : Symbol â†’ Addr

StaticType(path, name) = StaticBindTypes(binding)[name] â‡” StaticItemOf(path, name) = StaticDecl(_, _, mut, binding, _, _)

StaticBindInfo(path, name) = BindInfoMap(Î» U. RespOfInit(init), StaticBindTypes(binding), MovOf(op), mut)[name] â‡” StaticItemOf(path, name) = StaticDecl(_, _, mut, binding, _, _) âˆ§ binding = âŸ¨_, _, op, init, _âŸ©

SeqIRList([]) = Îµ
SeqIRList([IR] ++ IRs) = SeqIR(IR, SeqIRList(IRs))

StaticStoreIR(item, []) = Îµ
StaticStoreIR(item, [âŸ¨x, vâŸ©] ++ bs) = SeqIR(StoreGlobal(StaticSym(item, x), v), StaticStoreIR(item, bs))

**(Lower-StaticInit-Item)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    binding = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ LowerExpr(init) â‡“ âŸ¨IR_e, vâŸ©    Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    Î“ âŠ¢ InitPanicHandle(m) â‡“ IR_p
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticInitItem(m, item) â‡“ SeqIR(IR_e, StaticStoreIR(item, binds), IR_p)

**(Lower-StaticInitItems-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticInitItems(m, []) â‡“ Îµ

**(Lower-StaticInitItems-Cons)**
Î“ âŠ¢ Lower-StaticInitItem(m, item) â‡“ IR_i    Î“ âŠ¢ Lower-StaticInitItems(m, items) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticInitItems(m, [item] ++ items) â‡“ SeqIR(IR_i, IR_r)

**(Lower-StaticInit)**
StaticItems(Project(Î“), m) = items    Î“ âŠ¢ Lower-StaticInitItems(m, items) â‡“ IR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticInit(m) â‡“ IR

**(InitCallIR)**
Î“ âŠ¢ InitFn(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InitCallIR(m) â‡“ SeqIR(CallIR(sym, [PanicOutName]), PanicCheck)

Rev([]) = []
Rev([x] ++ xs) = Rev(xs) ++ [x]

**(Lower-StaticDeinitNames-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitNames(path, item, []) â‡“ Îµ

**(Lower-StaticDeinitNames-Cons-Resp)**
StaticBindInfo(path, x).resp = resp    sym = StaticSym(item, x)    Î“ âŠ¢ EmitDrop(StaticType(path, x), Load(@sym, StaticType(path, x))) â‡“ IR_d    Î“ âŠ¢ Lower-StaticDeinitNames(path, item, xs) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitNames(path, item, [x] ++ xs) â‡“ SeqIR(IR_d, IR_r)

**(Lower-StaticDeinitNames-Cons-NoResp)**
StaticBindInfo(path, x).resp â‰  resp    Î“ âŠ¢ Lower-StaticDeinitNames(path, item, xs) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitNames(path, item, [x] ++ xs) â‡“ IR_r

**(Lower-StaticDeinit-Item)**
item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)    binding = âŸ¨pat, _, _, _, _âŸ©    xs = Rev(StaticBindList(binding))    Î“ âŠ¢ Lower-StaticDeinitNames(PathOfModule(m), item, xs) â‡“ IR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitItem(m, item) â‡“ IR

**(Lower-StaticDeinitItems-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitItems(m, []) â‡“ Îµ

**(Lower-StaticDeinitItems-Cons)**
Î“ âŠ¢ Lower-StaticDeinitItem(m, item) â‡“ IR_i    Î“ âŠ¢ Lower-StaticDeinitItems(m, items) â‡“ IR_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinitItems(m, [item] ++ items) â‡“ SeqIR(IR_i, IR_r)

**(Lower-StaticDeinit)**
StaticItems(Project(Î“), m) = items    Î“ âŠ¢ Lower-StaticDeinitItems(m, Rev(items)) â‡“ IR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Lower-StaticDeinit(m) â‡“ IR

**(DeinitCallIR)**
Î“ âŠ¢ DeinitFn(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DeinitCallIR(m) â‡“ SeqIR(CallIR(sym, [PanicOutName]), PanicCheck)

**(EmitInitPlan)**
InitOrder = [m_1, â€¦, m_k]    âˆ€ i, Î“ âŠ¢ InitCallIR(m_i) â‡“ IR_i    IR_init = SeqIRList([IR_1, â€¦, IR_k])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitInitPlan(P) â‡“ IR_init

**(EmitInitPlan-Err)**
âˆƒ m âˆˆ InitOrder. Î“ âŠ¢ InitFn(m) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitInitPlan(P) â‡‘

**(EmitDeinitPlan)**
InitOrder = [m_1, â€¦, m_k]    âˆ€ i, Î“ âŠ¢ DeinitCallIR(m_i) â‡“ IR_i    IR_deinit = SeqIRList(Rev([IR_1, â€¦, IR_k]))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitDeinitPlan(P) â‡“ IR_deinit

**(EmitDeinitPlan-Err)**
âˆƒ m âˆˆ InitOrder. Î“ âŠ¢ DeinitFn(m) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitDeinitPlan(P) â‡‘

### 6.8. Cleanup, Drop, and Unwinding

CleanupJudg = {EmitDrop, CleanupPlan, LowerPanic, PanicSym, ClearPanic, PanicCheck}

**(CleanupPlan)**
cs = CleanupList(scope)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CleanupPlan(scope) â‡“ cs

EmitDropSpec(Î“, T, v, IR) â‡” âˆ€ Ïƒ, ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ') âˆ§ Î“ âŠ¢ DropValue(T, v, âˆ…) â‡“ Ïƒ'.
Î“ âŠ¢ EmitDrop(T, v) â‡“ IR â‡” EmitDropSpec(Î“, T, v, IR).

PanicOutAddr(Ïƒ) = addr â‡” LookupVal(Ïƒ, PanicOutName) = RawPtr(`mut`, addr)

PanicRecordOf(Ïƒ) = âŸ¨p, câŸ© â‡” PanicOutAddr(Ïƒ) = addr âˆ§ ReadAddr(Ïƒ, FieldAddr(PanicRecord, addr, "panic")) = p âˆ§ ReadAddr(Ïƒ, FieldAddr(PanicRecord, addr, "code")) = c

WritePanicRecord(Ïƒ, p, c) â‡“ Ïƒ' â‡” WriteAddr(Ïƒ, FieldAddr(PanicRecord, PanicOutAddr(Ïƒ), "panic"), p) â‡“ Ïƒ_1 âˆ§ WriteAddr(Ïƒ_1, FieldAddr(PanicRecord, PanicOutAddr(Ïƒ), "code"), c) â‡“ Ïƒ'

Î“ âŠ¢ InitPanicHandle(m) â‡“ IR â‡” âˆ€ Ïƒ. (PanicRecordOf(Ïƒ) = âŸ¨true, câŸ© â‡’ âˆƒ Ïƒ'. ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ') âˆ§ ExecIRSigma(SeqIR(SetPoison(m), LowerPanic(InitPanic(m))), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ')) âˆ§ (PanicRecordOf(Ïƒ) = âŸ¨false, câŸ© â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (Val(()), Ïƒ))

**(PanicSym)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PanicSym â‡“ PathSig(["cursive", "runtime", "panic"])

PanicReason = {ErrorExpr(span), ErrorStmt(span), DivZero, Overflow, Shift, Bounds, Cast, NullDeref, ExpiredDeref, InitPanic(m), Other}.

PanicCode(ErrorExpr(_)) = 0x0001
PanicCode(ErrorStmt(_)) = 0x0002
PanicCode(DivZero) = 0x0003
PanicCode(Overflow) = 0x0004
PanicCode(Shift) = 0x0005
PanicCode(Bounds) = 0x0006
PanicCode(Cast) = 0x0007
PanicCode(NullDeref) = 0x0008
PanicCode(ExpiredDeref) = 0x0009
PanicCode(InitPanic(_)) = 0x000A
PanicCode(Other) = 0x00FF.

PanicSite = {DivZeroCheck, OverflowCheck, ShiftCheck, BoundsCheck, CastCheck, NullDerefCheck, ExpiredDerefCheck, ErrorExprSite(span), ErrorStmtSite(span), InitPanicSite(m), OtherSite}.
PanicReasonOf(DivZeroCheck) = DivZero
PanicReasonOf(OverflowCheck) = Overflow
PanicReasonOf(ShiftCheck) = Shift
PanicReasonOf(BoundsCheck) = Bounds
PanicReasonOf(CastCheck) = Cast
PanicReasonOf(NullDerefCheck) = NullDeref
PanicReasonOf(ExpiredDerefCheck) = ExpiredDeref
PanicReasonOf(ErrorExprSite(span)) = ErrorExpr(span)
PanicReasonOf(ErrorStmtSite(span)) = ErrorStmt(span)
PanicReasonOf(InitPanicSite(m)) = InitPanic(m)
PanicReasonOf(OtherSite) = Other

Î“ âŠ¢ ClearPanic â‡“ IR â‡” âˆ€ Ïƒ, ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ') âˆ§ WritePanicRecord(Ïƒ, false, 0) â‡“ Ïƒ'.

Î“ âŠ¢ PanicCheck â‡“ IR â‡” âˆ€ Ïƒ, (PanicRecordOf(Ïƒ) = âŸ¨true, câŸ© â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)) âˆ§ (PanicRecordOf(Ïƒ) = âŸ¨false, câŸ© â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (Val(()), Ïƒ)).

Î“ âŠ¢ LowerPanic(reason) â‡“ IR â‡” âˆ€ Ïƒ. âˆƒ Ïƒ'. ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ') âˆ§ WritePanicRecord(Ïƒ, true, PanicCode(reason)) â‡“ Ïƒ'

### 6.9. Built-ins Runtime Interface

RuntimeIfcJudg = {RegionLayout, RegionSym, RegionAddrIsActiveSym, RegionAddrTagFromSym, BuiltinSym}

**(RegionLayout)**
ModalLayout(`Region`) â‡“ âŸ¨size, align, disc, payloadâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionLayout â‡“ âŸ¨size, align, [âŸ¨`disc`, discâŸ©, âŸ¨`payload`, payloadâŸ©]âŸ©

**(RegionSym-NewScoped)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::new_scoped`) â‡“ PathSig(["cursive", "runtime", "region", "new_scoped"])

**(RegionSym-Alloc)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::alloc`) â‡“ PathSig(["cursive", "runtime", "region", "alloc"])

**(RegionSym-Mark)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::mark`) â‡“ PathSig(["cursive", "runtime", "region", "mark"])

**(RegionSym-ResetTo)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::reset_to`) â‡“ PathSig(["cursive", "runtime", "region", "reset_to"])

**(RegionSym-ResetUnchecked)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::reset_unchecked`) â‡“ PathSig(["cursive", "runtime", "region", "reset_unchecked"])

**(RegionSym-Freeze)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::freeze`) â‡“ PathSig(["cursive", "runtime", "region", "freeze"])

**(RegionSym-Thaw)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::thaw`) â‡“ PathSig(["cursive", "runtime", "region", "thaw"])

**(RegionSym-FreeUnchecked)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionSym(`Region::free_unchecked`) â‡“ PathSig(["cursive", "runtime", "region", "free_unchecked"])

**(RegionSym-AddrIsActive)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionAddrIsActiveSym â‡“ PathSig(["cursive", "runtime", "region", "addr_is_active"])

**(RegionSym-AddrTagFrom)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RegionAddrTagFromSym â‡“ PathSig(["cursive", "runtime", "region", "addr_tag_from"])

**(BuiltinSym-FileSystem-OpenRead)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::open_read`) â‡“ PathSig(["cursive", "runtime", "fs", "open_read"])

**(BuiltinSym-FileSystem-OpenWrite)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::open_write`) â‡“ PathSig(["cursive", "runtime", "fs", "open_write"])

**(BuiltinSym-FileSystem-OpenAppend)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::open_append`) â‡“ PathSig(["cursive", "runtime", "fs", "open_append"])

**(BuiltinSym-FileSystem-CreateWrite)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::create_write`) â‡“ PathSig(["cursive", "runtime", "fs", "create_write"])

**(BuiltinSym-FileSystem-ReadFile)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::read_file`) â‡“ PathSig(["cursive", "runtime", "fs", "read_file"])

**(BuiltinSym-FileSystem-ReadBytes)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::read_bytes`) â‡“ PathSig(["cursive", "runtime", "fs", "read_bytes"])

**(BuiltinSym-FileSystem-WriteFile)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::write_file`) â‡“ PathSig(["cursive", "runtime", "fs", "write_file"])

**(BuiltinSym-FileSystem-WriteStdout)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::write_stdout`) â‡“ PathSig(["cursive", "runtime", "fs", "write_stdout"])

**(BuiltinSym-FileSystem-WriteStderr)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::write_stderr`) â‡“ PathSig(["cursive", "runtime", "fs", "write_stderr"])

**(BuiltinSym-FileSystem-Exists)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::exists`) â‡“ PathSig(["cursive", "runtime", "fs", "exists"])

**(BuiltinSym-FileSystem-Remove)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::remove`) â‡“ PathSig(["cursive", "runtime", "fs", "remove"])

**(BuiltinSym-FileSystem-OpenDir)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::open_dir`) â‡“ PathSig(["cursive", "runtime", "fs", "open_dir"])

**(BuiltinSym-FileSystem-CreateDir)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::create_dir`) â‡“ PathSig(["cursive", "runtime", "fs", "create_dir"])

**(BuiltinSym-FileSystem-EnsureDir)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::ensure_dir`) â‡“ PathSig(["cursive", "runtime", "fs", "ensure_dir"])

**(BuiltinSym-FileSystem-Kind)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::kind`) â‡“ PathSig(["cursive", "runtime", "fs", "kind"])

**(BuiltinSym-FileSystem-Restrict)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`FileSystem::restrict`) â‡“ PathSig(["cursive", "runtime", "fs", "restrict"])

**(BuiltinSym-HeapAllocator-WithQuota)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`HeapAllocator::with_quota`) â‡“ PathSig(["cursive", "runtime", "heap", "with_quota"])

**(BuiltinSym-HeapAllocator-AllocRaw)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`HeapAllocator::alloc_raw`) â‡“ PathSig(["cursive", "runtime", "heap", "alloc_raw"])

**(BuiltinSym-HeapAllocator-DeallocRaw)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`HeapAllocator::dealloc_raw`) â‡“ PathSig(["cursive", "runtime", "heap", "dealloc_raw"])

**(BuiltinSym-Reactor-Run)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`Reactor::run`) â‡“ PathSig(["cursive", "runtime", "reactor", "run"])

**(BuiltinSym-Reactor-Register)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(`Reactor::register`) â‡“ PathSig(["cursive", "runtime", "reactor", "register"])

### 6.10. Dynamic Dispatch

DynDispatchJudg = {VTable, VSlot, DynPack, LowerDynCall}

VTableEligible(Cl) = [ m âˆˆ EffMethods(Cl) | vtable_eligible(m) ].

**(DispatchSym-Impl)**
LookupClassMethod(Cl, name) = m    MethodByName(T, name) = m'    SigMatch(T, m', m)    Î“ âŠ¢ Mangle(m') â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DispatchSym(T, Cl, name) â‡“ sym

**(DispatchSym-Default-None)**
LookupClassMethod(Cl, name) = m    MethodByName(T, name) = âŠ¥    m.body_opt â‰  âŠ¥    Î“ âŠ¢ Mangle(DefaultImpl(T, m)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DispatchSym(T, Cl, name) â‡“ sym

**(DispatchSym-Default-Mismatch)**
LookupClassMethod(Cl, name) = m    MethodByName(T, name) = m'    Â¬ SigMatch(T, m', m)    m.body_opt â‰  âŠ¥    Î“ âŠ¢ Mangle(DefaultImpl(T, m)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DispatchSym(T, Cl, name) â‡“ sym

**(VTable-Order)**
VTableEligible(Cl) = [m_1, â€¦, m_k]    âˆ€ i, DispatchSym(T, Cl, m_i.name) = sym_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ VTable(T, Cl) â‡“ [sym_1, â€¦, sym_k]

**(VSlot-Entry)**
VTableEligible(Cl) = [m_0, â€¦, m_{k-1}]    m_i.name = method.name
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ VSlot(Cl, method) â‡“ i

**(Lower-Dynamic-Form)**
IsPlace(e)    Î“ âŠ¢ LowerAddrOf(e) â‡“ âŸ¨IR, addrâŸ©    T_e = ExprType(e)    T = StripPerm(T_e)    Î“ âŠ¢ T <: Cl
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DynPack(T, e) â‡“ âŸ¨RawPtr(`imm`, addr), VTable(T, Cl)âŸ©

**(Lower-DynCall)**
VSlot(Cl, name) â‡“ i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerDynCall(base, name, args) â‡“ SeqIR(CallVTable(base, i, args), PanicCheck)

### 6.11. Checks and Panic

ChecksJudg = {LowerRangeExpr, CheckIndex, CheckRange, LowerTransmute, LowerRawDeref}

**(Lower-Range-Full)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`Full`, âŠ¥, âŠ¥)) â‡“ âŸ¨Îµ, RangeVal(`Full`, âŠ¥, âŠ¥)âŸ©
  
**(Lower-Range-To)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`To`, âŠ¥, e)) â‡“ âŸ¨IR_e, RangeVal(`To`, âŠ¥, v)âŸ©

**(Lower-Range-ToInclusive)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`ToInclusive`, âŠ¥, e)) â‡“ âŸ¨IR_e, RangeVal(`ToInclusive`, âŠ¥, v)âŸ©
  
**(Lower-Range-From)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`From`, e, âŠ¥)) â‡“ âŸ¨IR_e, RangeVal(`From`, v, âŠ¥)âŸ©
  
**(Lower-Range-Inclusive)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`Inclusive`, e_1, e_2)) â‡“ âŸ¨SeqIR(IR_1, IR_2), RangeVal(`Inclusive`, v_1, v_2)âŸ©
  
**(Lower-Range-Exclusive)**
Î“ âŠ¢ LowerExpr(e_1) â‡“ âŸ¨IR_1, v_1âŸ©    Î“ âŠ¢ LowerExpr(e_2) â‡“ âŸ¨IR_2, v_2âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRangeExpr(Range(`Exclusive`, e_1, e_2)) â‡“ âŸ¨SeqIR(IR_1, IR_2), RangeVal(`Exclusive`, v_1, v_2)âŸ©

**(Check-Index-Ok)**
IndexNum(v_i) = i    0 â‰¤ i < L
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckIndex(L, v_i) â‡“ ok

**(Check-Index-Err)**
IndexNum(v_i) = i    Â¬(0 â‰¤ i < L)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckIndex(L, v_i) â‡‘

**(Check-Range-Ok)**
SliceBounds(r, L) defined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckRange(L, r) â‡“ ok

**(Check-Range-Err)**
SliceBounds(r, L) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckRange(L, r) â‡‘

**(Lower-Transmute)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    TransmuteVal(T_1, T_2, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerTransmute(T_1, T_2, e) â‡“ âŸ¨IR_e, v'âŸ©

**(Lower-Transmute-Err)**
Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR_e, vâŸ©    TransmuteVal(T_1, T_2, v) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerTransmute(T_1, T_2, e) â‡‘

**Raw Dereference Lowering.**

**(Lower-RawDeref-Safe)**
PtrType(v_ptr) = TypePtr(T, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨ReadPtrIR(v_ptr), vâŸ©

**(Lower-RawDeref-Raw)**
PtrType(v_ptr) = TypeRawPtr(q, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨ReadPtrIR(v_ptr), vâŸ©

**(Lower-RawDeref-Null)**
PtrType(v_ptr) = TypePtr(T, `Null`)    Î“ âŠ¢ LowerPanic(NullDeref) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨IR_k, v_unreachâŸ©

**(Lower-RawDeref-Expired)**
PtrType(v_ptr) = TypePtr(T, `Expired`)    Î“ âŠ¢ LowerPanic(ExpiredDeref) â‡“ IR_k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerRawDeref(v_ptr) â‡“ âŸ¨IR_k, v_unreachâŸ©

### 6.12. LLVM 21 Backend Requirements

#### 6.12.1. LLVM Module Header

LLVMHeader = [TargetDataLayout(LLVMDataLayout), TargetTriple(LLVMTriple)]

#### 6.12.2. Opaque Pointer Model (LLVM 21)

AddrSpace(T) =
 0                if T = TypePtr(U, s)
 0                if T = TypeRawPtr(q, U)
 0                if T = TypeFunc(params, R)
 AddrSpace(U)     if T = TypePerm(p, U) âˆ§ AddrSpace(U) defined
 âŠ¥                otherwise

LLVMPtrTy(T) = `ptr addrspace(AddrSpace(T))` when AddrSpace(T) defined

#### 6.12.3. LLVM Attribute Mapping (Permissions and Pointer State)

LLVMAttrJudg = {PtrStateOf(T) = s, LLVMPtrAttrs(T) â‡“ A, LLVMArgAttrs(T) â‡“ A}

**(PtrStateOf-Perm)**
PtrStateOf(T) = s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PtrStateOf(TypePerm(p, T)) = s

**(LLVM-PtrAttrs-Valid)**
StripPerm(T) = TypePtr(U, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMPtrAttrs(T) â‡“ {`nonnull`, `dereferenceable`(sizeof(U)), `align`(alignof(U)), `noundef`}

**(LLVM-PtrAttrs-Other)**
StripPerm(T) = TypePtr(U, s)    s âˆˆ {âŠ¥, `Null`, `Expired`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMPtrAttrs(T) â‡“ âˆ…

**(LLVM-PtrAttrs-RawPtr)**
StripPerm(T) = TypeRawPtr(q, U)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMPtrAttrs(T) â‡“ âˆ…

**(LLVM-ArgAttrs-Ptr)**
LLVMArgAttrsPtr(T) = (PermOf(T) = `unique` Sigma {`noalias`} : âˆ…) âˆª (PermOf(T) = `const` Sigma {`readonly`} : âˆ…)
StripPerm(T) âˆˆ {TypePtr(_, _), TypeFunc(_, _)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgAttrs(T) â‡“ LLVMArgAttrsPtr(T)

**(LLVM-ArgAttrs-RawPtr)**
StripPerm(T) = TypeRawPtr(_, _)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgAttrs(T) â‡“ âˆ…

**(LLVM-ArgAttrs-NonPtr)**
StripPerm(T) âˆ‰ {TypePtr(_, _), TypeRawPtr(_, _), TypeFunc(_, _)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgAttrs(T) â‡“ âˆ…

NoEscapeParam(x) predicate
NoEscapeParam(x) â‡” false
OptArgAttrs(x) âŠ† {`nocapture`} âˆ§ (`nocapture` âˆˆ OptArgAttrs(x) â‡’ NoEscapeParam(x))
LLVMArgAttrsExt(x, T) = LLVMArgAttrs(T) âˆª OptArgAttrs(x)

#### 6.12.4. UB and Poison Avoidance (LLVM 21)

LLVMInstrs(LLVMIR) = [i_0, â€¦, i_n]
Opcode(i) = op
UsesOpcode(LLVMIR, op) â‡” âˆƒ i âˆˆ LLVMInstrs(LLVMIR). Opcode(i) = op
Intrinsic(i) = name
UsesIntrinsic(LLVMIR, name) â‡” âˆƒ i âˆˆ LLVMInstrs(LLVMIR). Intrinsic(i) = name
NoUndefPoison(LLVMIR) â‡” Â¬ UsesOpcode(LLVMIR, `undef`) âˆ§ Â¬ UsesOpcode(LLVMIR, `poison`)
NoNSWNUW(LLVMIR) â‡” Â¬ UsesOpcode(LLVMIR, `nsw`) âˆ§ Â¬ UsesOpcode(LLVMIR, `nuw`)
CheckedOverflow(LLVMIR) â‡” Â¬ UsesOpcode(LLVMIR, `add`) âˆ§ Â¬ UsesOpcode(LLVMIR, `sub`) âˆ§ Â¬ UsesOpcode(LLVMIR, `mul`) âˆ§ UsesIntrinsic(LLVMIR, `llvm.*.with.overflow`)
CheckedDivRem(LLVMIR) â‡” UsesIntrinsic(LLVMIR, `llvm.sdiv.with.check`) âˆ§ UsesIntrinsic(LLVMIR, `llvm.udiv.with.check`)
CheckedShifts(LLVMIR) â‡” UsesIntrinsic(LLVMIR, `llvm.shift.with.check`)
FrozenPoisonUses(LLVMIR) â‡” UsesOpcode(LLVMIR, `freeze`)
InboundsGEP(LLVMIR) â‡” Â¬ UsesOpcode(LLVMIR, `getelementptr inbounds`) âˆ¨ UsesOpcode(LLVMIR, `gep.inbounds.checked`)
LLVMUBSafe(LLVMIR) â‡” NoUndefPoison(LLVMIR) âˆ§ CheckedOverflow(LLVMIR) âˆ§ CheckedDivRem(LLVMIR) âˆ§ CheckedShifts(LLVMIR) âˆ§ FrozenPoisonUses(LLVMIR) âˆ§ InboundsGEP(LLVMIR) âˆ§ NoNSWNUW(LLVMIR)

#### 6.12.5. Memory Intrinsics

Memmove(dst, src, n) = [`call` `llvm.memmove`(dst, src, n)]
MemcpyOverlapUnknown(dst, src, n) predicate
MemcpyOverlapUnknown(dst, src, n) â‡” true
MemcpyAllowed(dst, src, n) â‡” Â¬ MemcpyOverlapUnknown(dst, src, n)
AggMemcpy(dst, src, n) =
 Memcpy(dst, src, n)     if MemcpyAllowed(dst, src, n)
 Memmove(dst, src, n)    otherwise
AggZero(dst, n) = Memset(dst, 0, n)
LifetimeOpt(T) âŠ† {`llvm.lifetime.start`(sizeof(T)), `llvm.lifetime.end`(sizeof(T))}

#### 6.12.6. Runtime and BuiltÃ¢â‚¬â€˜in Declarations

RuntimeDeclJudg = {RuntimeSig(sym) â‡“ âŸ¨params, retâŸ©, BuiltinSig(method) â‡“ âŸ¨params, retâŸ©, RuntimeDecls(S) â‡“ decls}

BuiltinSig(`FileSystem`::name) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(CapRecv(`FileSystem`, name), TypeDynamic(`FileSystem`))âŸ©] ++ params, retâŸ© â‡” CapMethodSig(`FileSystem`, name) = âŸ¨params, retâŸ©
BuiltinSig(`HeapAllocator`::name) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(CapRecv(`HeapAllocator`, name), TypeDynamic(`HeapAllocator`))âŸ©] ++ params, retâŸ© â‡” CapMethodSig(`HeapAllocator`, name) = âŸ¨params, retâŸ©
BuiltinSig(`Reactor`::name) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(CapRecv(`Reactor`, name), TypeDynamic(`Reactor`))âŸ©] ++ params, retâŸ© â‡” CapMethodSig(`Reactor`, name) = âŸ¨params, retâŸ©
BuiltinSig(method) = âŸ¨params, retâŸ© â‡” StringBytesBuiltinSig(method) = âŸ¨params, retâŸ©

RuntimeSig(PanicSym) = âŸ¨[âŸ¨âŠ¥, `code`, TypePrim("u32")âŸ©], TypePrim("!")âŸ©
RuntimeSig(ContextInitSym) = âŸ¨[], TypePath(["Context"])âŸ©
RuntimeSig(StringDropSym) = âŸ¨[âŸ¨`move`, `value`, TypeString(`@Managed`)âŸ©], TypePrim("()")âŸ©
RuntimeSig(BytesDropSym) = âŸ¨[âŸ¨`move`, `value`, TypeBytes(`@Managed`)âŸ©], TypePrim("()")âŸ©
RuntimeSig(sym) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©, âŸ¨âŠ¥, `size`, TypePrim("usize")âŸ©, âŸ¨âŠ¥, `align`, TypePrim("usize")âŸ©], TypeRawPtr(`mut`, TypePrim("u8"))âŸ© â‡” sym = RegionSym(`Region::alloc`)
RuntimeSig(sym) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©], TypePrim("usize")âŸ© â‡” sym = RegionSym(`Region::mark`)
RuntimeSig(sym) = âŸ¨[âŸ¨âŠ¥, `self`, TypePerm(`unique`, TypeModalState(["Region"], `@Active`))âŸ©, âŸ¨âŠ¥, `mark`, TypePrim("usize")âŸ©], TypePrim("()")âŸ© â‡” sym = RegionSym(`Region::reset_to`)
RuntimeSig(sym) = âŸ¨[âŸ¨âŠ¥, `addr`, TypeRawPtr(`imm`, TypePrim("u8"))âŸ©], TypePrim("bool")âŸ© â‡” sym = RegionAddrIsActiveSym
RuntimeSig(sym) = âŸ¨[âŸ¨âŠ¥, `addr`, TypeRawPtr(`imm`, TypePrim("u8"))âŸ©, âŸ¨âŠ¥, `base`, TypeRawPtr(`imm`, TypePrim("u8"))âŸ©], TypePrim("()")âŸ© â‡” sym = RegionAddrTagFromSym
RuntimeSig(sym) = âŸ¨params, retâŸ© â‡” sym = RegionSym(proc) âˆ§ proc â‰  `Region::alloc` âˆ§ RegionProcSig(proc) = âŸ¨params, retâŸ©
RuntimeSig(sym) = âŸ¨params, retâŸ© â‡” sym = BuiltinSym(method) âˆ§ BuiltinSig(method) = âŸ¨params, retâŸ©

LLVMDecl : Symbol Ã— Sig â†’ LLVMDecl

**(RuntimeDecls)**
âˆ€ sym âˆˆ S, RuntimeSig(sym) = âŸ¨params, retâŸ©    LLVMCallSig(params, ret) â‡“ sig
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ RuntimeDecls(S) â‡“ [LLVMDecl(sym, sig) | sym âˆˆ S]
DeclAttrs : Symbol â†’ AttrSet
DeclSyms(LLVMIR) = { sym | LLVMDecl(sym, _) âˆˆ LLVMIR âˆ¨ LLVMDefine(sym, _, _) âˆˆ LLVMIR }
DeclAttrsOk(sym) â‡” (sym = PanicSym â‡’ {`noreturn`, `nounwind`} âŠ† DeclAttrs(sym)) âˆ§ (sym â‰  PanicSym â‡’ `nounwind` âˆˆ DeclAttrs(sym))
RuntimeDeclsOk(decls) â‡” âˆ€ sym âˆˆ DeclSyms(decls). DeclAttrsOk(sym)
RuntimeDeclsCover(LLVMIR, IR) â‡” RuntimeRefs(IR) âŠ† DeclSyms(LLVMIR)

#### 6.12.7. LLVM Toolchain Version

LLVMToolchain = "21.1.8"

#### 6.12.8. LLVM Type Mapping

LLVMTyJudg = {LLVMTy(T) â‡“ Ï„}

LLVMZST = {}
Pad(n) =
 []        if n = 0
 [n Ã— i8]  if n â‰  0

LLVMPrim(name) =
 i8        if name âˆˆ {i8, u8}
 i16       if name âˆˆ {i16, u16}
 i32       if name âˆˆ {i32, u32}
 i64       if name âˆˆ {i64, u64}
 i128      if name âˆˆ {i128, u128}
 `half`    if name = f16
 `float`   if name = f32
 `double`  if name = f64
 i8        if name = `bool`
 i32       if name = `char`
 i64       if name âˆˆ {`usize`, `isize`}
 LLVMZST   if name âˆˆ {`()`, `!`}
 âŠ¥         otherwise

LLVMStruct([t_1, â€¦, t_k]) = { t_1, â€¦, t_k }
LLVMArray(n, t) = [n Ã— t]
LLVMArrayConst(n, t, elems) constructor
SlicePtrTy(T) = LLVMPtrTy(TypeRawPtr(`imm`, T))

StructElems([], [], 0) = []
StructElems([âŸ¨f_1, T_1âŸ©, â€¦, âŸ¨f_n, T_nâŸ©], [o_1, â€¦, o_n], size) = Pad(pad_1) ++ [Ï„_1] ++ â€¦ ++ Pad(pad_n) ++ [Ï„_n] ++ Pad(pad_tail)
pad_1 = o_1
pad_i = o_i - (o_{i-1} + sizeof(T_{i-1}))    for i = 2..n
pad_tail = size - (o_n + sizeof(T_n))
Ï„_i = LLVMTy(T_i)

TaggedElems(disc, payload_size, payload_align, size) = [LLVMTy(disc)] ++ Pad(pad_mid) ++ [LLVMArray(payload_size, i8)] ++ Pad(pad_tail)
disc_size = sizeof(disc)
payload_off = AlignUp(disc_size, payload_align)
pad_mid = payload_off - disc_size
pad_tail = size - (payload_off + payload_size)

**(LLVMTy-Prim)**
T = TypePrim(name)    LLVMPrim(name) = Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Perm)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(TypePerm(p, T)) â‡“ Ï„

**(LLVMTy-Ptr)**
T = TypePtr(U, s)    LLVMPtrTy(T) = Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-RawPtr)**
T = TypeRawPtr(q, U)    LLVMPtrTy(T) = Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Func)**
T = TypeFunc(params, R)    LLVMPtrTy(T) = Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ LLVMTy(ty) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Record)**
T = TypePath(p)    RecordDecl(p) = R    Fields(R) = fields    RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ©    StructElems(fields, offsets, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct(elems)

**(LLVMTy-Tuple)**
TupleLayout([T_1, â€¦, T_n]) â‡“ âŸ¨size, _, offsetsâŸ©    StructElems([âŸ¨0, T_1âŸ©, â€¦, âŸ¨n-1, T_nâŸ©], offsets, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(TypeTuple([T_1, â€¦, T_n])) â‡“ LLVMStruct(elems)

**(LLVMTy-Array)**
T = TypeArray(T_0, e)    Î“ âŠ¢ ConstLen(e) â‡“ n    Î“ âŠ¢ LLVMTy(T_0) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMArray(n, Ï„)

**(LLVMTy-Slice)**
T = TypeSlice(T_0)    Î“ âŠ¢ LLVMTy(TypePrim("usize")) â‡“ Ï„_u
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct([SlicePtrTy(T_0), Ï„_u])

**(LLVMTy-Range)**
Î“ âŠ¢ RangeLayout() â‡“ âŸ¨size, _, offsetsâŸ©    StructElems(RangeFields, offsets, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(TypeRange) â‡“ LLVMStruct(elems)

**(LLVMTy-Enum)**
T = TypePath(p)    EnumDecl(p) = E    EnumLayout(E) â‡“ âŸ¨size, _, disc, payload_sizeâŸ©    payload_align = PayloadAlign(E)    TaggedElems(disc, payload_size, payload_align, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct(elems)

**(LLVMTy-Union-Niche)**
T = TypeUnion([T_1, â€¦, T_n])    NicheApplies(T)    PayloadMember(T) = T_p    Î“ âŠ¢ LLVMTy(T_p) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Union-Tagged)**
T = TypeUnion([T_1, â€¦, T_n])    UnionLayout(T) â‡“ âŸ¨size, _, disc, payload_sizeâŸ©    disc â‰  âŠ¥    payload_align = PayloadAlign(T)    TaggedElems(disc, payload_size, payload_align, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct(elems)

**(LLVMTy-Modal-Niche)**
T = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    NicheApplies(modal_ref)    PayloadState(modal_ref) = S_p    ModalSingleFieldPayload(modal_ref, S_p) = T_p    Î“ âŠ¢ LLVMTy(T_p) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„

**(LLVMTy-Modal-Tagged)**
T = ModalRefType(modal_ref)    ModalDeclOf(modal_ref) = M    ModalLayout(modal_ref) â‡“ âŸ¨size, _, disc, payload_sizeâŸ©    disc â‰  âŠ¥    payload_align = max_{S âˆˆ States(M)}(StateAlign(modal_ref, S))    TaggedElems(disc, payload_size, payload_align, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct(elems)

**(LLVMTy-Modal-StringBytes)**
BaseModal(TypeString(âŠ¥)) = TypePath(["string"])
BaseModal(TypeBytes(âŠ¥)) = TypePath(["bytes"])
T âˆˆ {TypeString(âŠ¥), TypeBytes(âŠ¥)}    ModalLayout(BaseModal(T)) â‡“ âŸ¨size, _, disc, payload_sizeâŸ©    (disc = âŠ¥ â‡’ PayloadState(BaseModal(T)) = S_p âˆ§ ModalSingleFieldPayload(BaseModal(T), S_p) = T_p âˆ§ Î“ âŠ¢ LLVMTy(T_p) â‡“ Ï„)    (disc â‰  âŠ¥ â‡’ ModalDeclOf(BaseModal(T)) = M âˆ§ payload_align = max_{S âˆˆ States(M)}(StateAlign(BaseModal(T), S)) âˆ§ TaggedElems(disc, payload_size, payload_align, size) = elems)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ (Ï„ if disc = âŠ¥ else LLVMStruct(elems))

**(LLVMTy-ModalState)**
T = TypeModalState(modal_ref, S)    ModalDeclOf(modal_ref) = M    S âˆˆ States(M)    ModalPayload(modal_ref, S) = fields    RecordLayout(fields) â‡“ âŸ¨size, _, offsetsâŸ©    StructElems(fields, offsets, size) = elems
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct(elems)

**(LLVMTy-Dynamic)**
DynLayout(Cl) â‡“ âŸ¨_, _, [âŸ¨`data`, T_dâŸ©, âŸ¨`vtable`, T_vâŸ©]âŸ©    Î“ âŠ¢ LLVMTy(T_d) â‡“ Ï„_d    Î“ âŠ¢ LLVMTy(T_v) â‡“ Ï„_v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(TypeDynamic(Cl)) â‡“ LLVMStruct([Ï„_d, Ï„_v])

**(LLVMTy-StringView)**
T = TypeString(`@View`)    Î“ âŠ¢ LLVMTy(TypePrim("usize")) â‡“ Ï„_u
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct([LLVMPtrTy(TypePtr(TypePerm(`const`, TypePrim("u8")), `Valid`)), Ï„_u])

**(LLVMTy-StringManaged)**
T = TypeString(`@Managed`)    Î“ âŠ¢ LLVMTy(TypePrim("usize")) â‡“ Ï„_u
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct([LLVMPtrTy(TypePtr(TypePrim("u8"), `Valid`)), Ï„_u, Ï„_u])

**(LLVMTy-BytesView)**
T = TypeBytes(`@View`)    Î“ âŠ¢ LLVMTy(TypePrim("usize")) â‡“ Ï„_u
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct([LLVMPtrTy(TypePtr(TypePerm(`const`, TypePrim("u8")), `Valid`)), Ï„_u])

**(LLVMTy-BytesManaged)**
T = TypeBytes(`@Managed`)    Î“ âŠ¢ LLVMTy(TypePrim("usize")) â‡“ Ï„_u
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡“ LLVMStruct([LLVMPtrTy(TypePtr(TypePrim("u8"), `Valid`)), Ï„_u, Ï„_u])

**(LLVMTy-Err)**
LLVMTy(T) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMTy(T) â‡‘

#### 6.12.9. LLVM IR Emission Pipeline

LLVMEmitJudg = {LowerIR(ModuleIR) â‡“ LLVMIR, EmitLLVM(LLVMIR) â‡“ bytes, EmitObj(LLVMIR) â‡“ bytes}

RuntimeSyms = {PanicSym, StringDropSym, BytesDropSym, ContextInitSym} âˆª {RegionSym(proc) | proc âˆˆ RegionProcs} âˆª {RegionSym(`Region::mark`), RegionSym(`Region::reset_to`), RegionAddrIsActiveSym, RegionAddrTagFromSym} âˆª {BuiltinSym(method) | method âˆˆ BuiltinMethods}
BuiltinMethods = StringBuiltins âˆª BytesBuiltins âˆª {`FileSystem`::name | âŸ¨name, recv, params, retâŸ© âˆˆ FileSystemInterface} âˆª {`HeapAllocator`::name | âŸ¨name, recv, params, retâŸ© âˆˆ HeapAllocatorInterface} âˆª {`Reactor`::name | name âˆˆ ReactorMethodNames}
RefSyms : IR â†’ ð’«(Symbol)
RefSyms([]) = âˆ…
RefSyms([d] ++ ds) = RefSyms(d) âˆª RefSyms(ds)
RefSyms(ProcIR(_, _, _, IR)) = RefSyms(IR)
RefSyms(GlobalConst(_, _)) = âˆ…
RefSyms(GlobalZero(_, _)) = âˆ…
RefSyms(GlobalVTable(_, header, slots)) = { s | s âˆˆ header âˆ§ s âˆˆ Symbol } âˆª { s | s âˆˆ slots âˆ§ s âˆˆ Symbol }
RefSyms(EmitVTable(T, Cl)) = RefSyms(d) â‡” Î“ âŠ¢ EmitVTable(T, Cl) â‡“ d
RefSyms(EmitDropGlue(T)) = RefSyms(IR) â‡” Î“ âŠ¢ DropGlueIR(T) â‡“ IR
RefSyms(EmitLiteralData(_, _)) = âˆ…
RefSyms(Îµ) = âˆ…
RefSyms(SeqIR(IR_1, IR_2)) = RefSyms(IR_1) âˆª RefSyms(IR_2)
RefSyms(ReadVarIR(_)) = âˆ…
RefSyms(StoreVarIR(_, _)) = âˆ…
RefSyms(StoreVarNoDropIR(_, _)) = âˆ…
RefSyms(BindVarIR(_, _)) = âˆ…
RefSyms(ReadPtrIR(_)) = âˆ…
RefSyms(WritePtrIR(_, _)) = âˆ…
RefSyms(AllocIR(_, _)) = âˆ…
RefSyms(MoveStateIR(_)) = âˆ…
RefSyms(ReturnIR(_)) = âˆ…
RefSyms(ResultIR(_)) = âˆ…
RefSyms(BreakIR(_)) = âˆ…
RefSyms(ContinueIR) = âˆ…
RefSyms(DeferIR(_)) = âˆ…
RefSyms(ReadPathIR(path, name)) = {PathSym(path, name)} âˆª { sym | StaticSymPath(path, name) = sym }
RefSyms(StoreGlobal(sym, _)) = {sym}
RefSyms(CallIR(callee, _)) = { callee | callee âˆˆ Symbol }
RefSyms(IfIR(_, IR_t, _, IR_f, _)) = RefSyms(IR_t) âˆª RefSyms(IR_f)
RefSyms(BlockIR(IR_s, IR_t, _)) = RefSyms(IR_s) âˆª RefSyms(IR_t)
RefSyms(MatchIR(_, _)) = âˆ…
RefSyms(LoopIR(LoopInfinite, IR_b, _)) = RefSyms(IR_b)
RefSyms(LoopIR(LoopConditional, IR_c, _, IR_b, _)) = RefSyms(IR_c) âˆª RefSyms(IR_b)
RefSyms(LoopIR(LoopIter, _, _, IR_i, _, IR_b, _)) = RefSyms(IR_i) âˆª RefSyms(IR_b)
RefSyms(RegionIR(_, _, IR_b, _)) = RefSyms(IR_b)
RefSyms(FrameIR(_, IR_b, _)) = RefSyms(IR_b)
RefSyms(BranchIR(_)) = âˆ…
RefSyms(BranchIR(_, _, _)) = âˆ…
RefSyms(PhiIR(_, _, _)) = âˆ…
RefSyms(CallVTable(_, _, _)) = âˆ…
RefSyms(AddrOfIR(p)) = RefSyms(IR_p) â‡” Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©
RefSyms(ClearPanic) = RefSyms(IR) â‡” Î“ âŠ¢ ClearPanic â‡“ IR
RefSyms(PanicCheck) = RefSyms(IR) â‡” Î“ âŠ¢ PanicCheck â‡“ IR
RefSyms(CheckPoison(m)) = RefSyms(IR) â‡” Î“ âŠ¢ CheckPoison(m) â‡“ IR
RefSyms(LowerPanic(r)) = RefSyms(IR) â‡” Î“ âŠ¢ LowerPanic(r) â‡“ IR
RuntimeRefs(IR) = RefSyms(IR) âˆ© RuntimeSyms
LiteralRef(IR, kind, bytes) predicate
LiteralRef(IR, kind, bytes) â‡” LiteralDataSym(kind, bytes) âˆˆ RefSyms(IR)
LiteralRefs(IR) = {âŸ¨kind, bytesâŸ© | LiteralRef(IR, kind, bytes)}
VTableRefs(IR) = {(T, Cl) | DynPack(T, _) âˆˆ IR âˆ¨ CallVTable(_, _, _) âˆˆ IR}

ExpandIR(IR) = IR ++ ((++_{(T, Cl) âˆˆ VTableRefs(IR)} [EmitDropGlue(T), EmitVTable(T, Cl)]) ) ++ ((++_{âŸ¨kind, bytesâŸ© âˆˆ LiteralRefs(IR)} [EmitLiteralData(kind, bytes)]) )

EmitKey(d) =
 âŸ¨`vtable`, T, ClâŸ©    if d = EmitVTable(T, Cl)
 âŸ¨`drop`, TâŸ©          if d = EmitDropGlue(T)
 âŸ¨`lit`, kind, bytesâŸ©  if d = EmitLiteralData(kind, bytes)
 âŠ¥                    otherwise
EmitKeys(IR) = [EmitKey(d) | d âˆˆ IR âˆ§ EmitKey(d) â‰  âŠ¥]
UniqueEmits(IR) â‡” NoDup(EmitKeys(IR))

**(LowerIR-Module)**
IR' = ExpandIR(IR)    IR' = [d_1, â€¦, d_k]    âˆ€ i, Î“ âŠ¢ LowerIRDecl(d_i) â‡“ ll_i    RuntimeDecls(RuntimeRefs(IR')) = ds    RuntimeDeclsOk(ds)    LLVMIR = LLVMHeader ++ ds ++ ll_1 ++ â€¦ ++ ll_k    LLVMUBSafe(LLVMIR)    RuntimeDeclsCover(LLVMIR, IR')    UniqueEmits(IR')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIR(IR) â‡“ LLVMIR

**(LowerIR-Err)**
âˆƒ i, Î“ âŠ¢ LowerIRDecl(d_i) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIR(IR) â‡‘

**(EmitLLVM-Ok)**
RenderLLVM(LLVMIR) = bytes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLLVM(LLVMIR) â‡“ bytes

LLVMText_21 = { bytes | `llvm-as`_21 accepts bytes }
RenderLLVM(LLVMIR) = bytes â‡’ bytes âˆˆ LLVMText_21

**(EmitLLVM-Err)**
RenderLLVM(LLVMIR) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLLVM(LLVMIR) â‡‘

**(EmitObj-Ok)**
LLVMEmitObj_21(LLVMIR) = bytes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitObj(LLVMIR) â‡“ bytes
LLVMEmitObj_21(LLVMIR) = bytes â‡” LLVMObj_21(LLVMIR, LLVMHeader) = bytes

**(EmitObj-Err)**
LLVMEmitObj_21(LLVMIR) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitObj(LLVMIR) â‡‘

#### 6.12.10. IR Operation Lowering

LowerIRJudg = {LowerIRDecl(d) â‡“ ll, LowerIRInstr(op) â‡“ ll}

LLVMInstrList = [LLVMInstr]
Label(l) âˆˆ LLVMInstr
Br(l) âˆˆ LLVMInstr
BrCond(v, l_t, l_f) âˆˆ LLVMInstr
Phi(Ï„, inc, v) âˆˆ LLVMInstr
HasLabel(I, l) â‡” Label(l) âˆˆ I
HasBrCond(I, v) â‡” âˆƒ l_t, l_f. BrCond(v, l_t, l_f) âˆˆ I
HasPhi(I, v) â‡” âˆƒ Ï„, inc. Phi(Ï„, inc, v) âˆˆ I
FreshLabel(Î“) predicate
FreshSSA(Î“) predicate
LLVMSSA = Name
LLVMLabel = Name
FreshLabel(Î“) âˆˆ LLVMLabel \ dom(Î“)
FreshSSA(Î“) âˆˆ LLVMSSA \ dom(Î“)

IfLabels(Î“) = âŸ¨l_t, l_f, l_mâŸ© âˆ§ Distinct([l_t, l_f, l_m])

LLResult = {âŸ¨I, vâŸ© | I âˆˆ LLVMInstrList âˆ§ v âˆˆ LLVMSSA âˆª {âŠ¥}}
SeqLL(âŸ¨I_1, v_1âŸ©, âŸ¨I_2, v_2âŸ©) = âŸ¨I_1 ++ I_2, v_2âŸ©

**(LowerIRInstr-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(Îµ) â‡“ âŸ¨[], âŠ¥âŸ©

**(LowerIRInstr-Seq)**
Î“ âŠ¢ LowerIRInstr(IR_1) â‡“ ll_1    Î“ âŠ¢ LowerIRInstr(IR_2) â‡“ ll_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(SeqIR(IR_1, IR_2)) â‡“ SeqLL(ll_1, ll_2)

Load(slot, T) = [`load` LLVMTy(T), slot : LLVMPtrTy(T)]
Store(slot, v, T) = [`store` LLVMTy(T) v, slot : LLVMPtrTy(T)]
Memcpy(dst, src, n) = [`call` `llvm.memcpy`(dst, src, n)]
Memset(dst, 0, n) = [`call` `llvm.memset`(dst, 0, n)]
LoadVal(slot, T) â‡“ âŸ¨Load(slot, T), vâŸ©

LEValue(bytes) = âˆ‘_{i=0}^{|bytes|-1} bytes[i] Â· 256^i
ByteInt(bytes) = i{8|bytes|} LEValue(bytes)

AllZero(bytes) â‡” âˆ€ b âˆˆ bytes. b = 0x00
ByteArray(bytes) = LLVMArrayConst(|bytes|, i8, bytes)
ConstBytes(Ï„, bytes) = c â‡” âˆƒ T. Î“ âŠ¢ LLVMTy(T) â‡“ Ï„ âˆ§ |bytes| = sizeof(T) âˆ§ c = ConstBytesCase(Ï„, bytes)
ConstBytesCase(Ï„, bytes) =
 `zeroinitializer`    if |bytes| = 0
 ByteArray(bytes)     if Ï„ = LLVMArray(|bytes|, i8)
 ByteInt(bytes)       if Ï„ = i{8|bytes|}
 `bitcast`(ByteInt(bytes) to Ï„)    if Ï„ âˆˆ {`half`, `float`, `double`}
 `null`               if Ï„ = LLVMPtrTy(U) âˆ§ AllZero(bytes)
 âŠ¥                    otherwise
LLVMGlobalZero(sym, Ï„, align) = LLVMGlobalConst(sym, Ï„, `zeroinitializer`, align)

LenLit(n) = IntLiteral(IntValue = n)
StaticType(sym) =
 TypeArray(TypePrim("u8"), LenLit(|bytes|))    if sym = Mangle(LiteralData(kind, bytes))
 StaticBindTypes(sym)                          otherwise
ProcModule(sym) = m â‡” âˆƒ item, p. item = ProcedureDecl(_, _, _, _, _, _, _, _, _, _, _) âˆ§ ItemPath(item) = p âˆ§ sym = ScopedSym(item) âˆ§ ModuleOfPath(p) = m
SigOf(callee) =
 âŸ¨params, retâŸ©    if callee = Mangle(d) âˆ§ d âˆˆ {ProcedureDecl, MethodDecl, DefaultImpl} âˆ§ Sig(d) = âŸ¨params, retâŸ©
 RuntimeSig(sym)  if callee = sym âˆ§ RuntimeSig(sym) defined
 âŸ¨params, retâŸ©    if ExprType(callee) = TypeFunc(params, ret)
 âŠ¥                otherwise
LoweredSigOf(callee) = âŸ¨params', retâŸ© â‡” âŸ¨params, retâŸ© = SigOf(callee) âˆ§ params' = (NeedsPanicOut(callee) Sigma params ++ [PanicOutParam] : params)

ParamInitIR(sig, params) = ++_{âŸ¨mode, x, TâŸ© âˆˆ params} ParamInit(sig, params, x, mode, T)
ZeroValue(T) = `zeroinitializer` if sizeof(T) = 0
ParamInit(sig, params, x, mode, T) =
 Store(BindSlot(x), LLVMParam(sig, params, x), T)    if ABIParam(mode, T) = `ByValue` âˆ§ sizeof(T) > 0
 Store(BindSlot(x), ZeroValue(T), T)                 if ABIParam(mode, T) = `ByValue` âˆ§ sizeof(T) = 0
 Îµ                                                   if ABIParam(mode, T) = `ByRef`
ParamOrder(params) = [x_i | âŸ¨mode_i, x_i, T_iâŸ© âˆˆ params âˆ§ (ABIParam(mode_i, T_i) = `ByRef` âˆ¨ sizeof(T_i) > 0)]
ParamIndex(params, x) = i â‡” ParamOrder(params)[i] = x
LLVMArgs(sig) = sig.llvm_params
LLVMArg(sig, i) = LLVMArgs(sig)[i]
i' = (sig.sretSigma Sigma ParamIndex(params, x) + 1 : ParamIndex(params, x))
LLVMParam(sig, params, x) = LLVMArg(sig, i')

**(LowerIRDecl-Proc-User)**
LLVMCallSig(params, R) â‡“ sig    ProcModule(sym) = m    IR_p = ParamInitIR(sig, params)    IR_0 = (NeedsPanicOut(sym) Sigma SeqIR(ClearPanic, IR) : IR)    IR' = SeqIR(IR_p, CheckPoison(m), IR_0)    Î“ âŠ¢ LowerIRInstr(IR') â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(ProcIR(sym, params, R, IR)) â‡“ LLVMDefine(sym, sig, ll)

**(LowerIRDecl-Proc-Gen)**
LLVMCallSig(params, R) â‡“ sig    ProcModule(sym) undefined    IR_p = ParamInitIR(sig, params)    Î“ âŠ¢ LowerIRInstr(SeqIR(IR_p, (NeedsPanicOut(sym) Sigma SeqIR(ClearPanic, IR) : IR))) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(ProcIR(sym, params, R, IR)) â‡“ LLVMDefine(sym, sig, ll)

**(LowerIRDecl-GlobalConst)**
T = StaticType(sym)    Î“ âŠ¢ LLVMTy(T) â‡“ Ï„    ConstBytes(Ï„, bytes) = c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(GlobalConst(sym, bytes)) â‡“ LLVMGlobalConst(sym, Ï„, c, alignof(T))

**(LowerIRDecl-GlobalZero)**
T = StaticType(sym)    Î“ âŠ¢ LLVMTy(T) â‡“ Ï„    size = sizeof(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(GlobalZero(sym, size)) â‡“ LLVMGlobalZero(sym, Ï„, alignof(T))

**(LowerIRDecl-VTable)**
GlobalVTable(sym, header, slots) = d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(d) â‡“ LLVMGlobalVTable(sym, header, slots)

**(Lower-AllocIR)**
RegionSym(`Region::alloc`) â‡“ sym    r = InnermostActiveRegion(Î“) if r_opt = âŠ¥, otherwise r_opt    TypeOf(v) = T    sizeof(T) = n    alignof(T) = a    Î“ âŠ¢ LowerIRInstr(CallIR(sym, [r, IntVal(`usize`, n), IntVal(`usize`, a)])) â‡“ âŸ¨I_a, pâŸ©    Store(p, v, T) = I_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(AllocIR(r_opt, v)) â‡“ âŸ¨I_a ++ I_s, pâŸ©

**(Lower-BindVarIR)**
Î“ âŠ¢ BindSlot(x) â‡“ slot    TypeOf(x) = T_x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(BindVarIR(x, v)) â‡“ âŸ¨[Store(slot, v, T_x)], âŠ¥âŸ©

**(Lower-ReadVarIR)**
Î“ âŠ¢ BindSlot(x) â‡“ slot    TypeOf(x) = T_x    Î“ âŠ¢ BindValid(x) â‡“ `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadVarIR(x)) â‡“ âŸ¨[Load(slot, T_x)], vâŸ©

**(Lower-ReadVarIR-Err)**
Î“ âŠ¢ BindValid(x) â‡“ s    s â‰  `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadVarIR(x)) â‡‘

PathSym(path, name) = PathSig(path ++ [name])
ProcSymbol(sym) â‡” âˆƒ item. item âˆˆ {ProcedureDecl, MethodDecl, ClassMethodDecl, StateMethodDecl, TransitionDecl, DefaultImpl} âˆ§ Î“ âŠ¢ Mangle(item) â‡“ sym

**(Lower-ReadPathIR-Static-User)**
StaticSymPath(path, name) = sym    ProcModule(sym) = m    T = StaticType(sym)    Î“ âŠ¢ LowerIRInstr(CheckPoison(m)) â‡“ âŸ¨I_p, âŠ¥âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨I_p ++ [Load(@sym, T)], vâŸ©

**(Lower-ReadPathIR-Static-Gen)**
StaticSymPath(path, name) = sym    ProcModule(sym) undefined    T = StaticType(sym)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨[Load(@sym, T)], vâŸ©

**(Lower-ReadPathIR-Proc-User)**
sym = PathSym(path, name)    ProcSymbol(sym)    ProcModule(sym) = m    Î“ âŠ¢ LowerIRInstr(CheckPoison(m)) â‡“ âŸ¨I_p, âŠ¥âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨I_p, symâŸ©

**(Lower-ReadPathIR-Proc-Gen)**
sym = PathSym(path, name)    ProcSymbol(sym)    ProcModule(sym) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨Îµ, symâŸ©

**(Lower-ReadPathIR-Runtime)**
sym = PathSym(path, name)    RuntimeSig(sym) defined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨Îµ, symâŸ©

**(Lower-ReadPathIR-Record)**
p = path ++ [name]    RecordDecl(p) = R    ModuleOfPath(p) = m    Î“ âŠ¢ LowerIRInstr(CheckPoison(m)) â‡“ âŸ¨I_p, âŠ¥âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPathIR(path, name)) â‡“ âŸ¨I_p, RecordCtor(p)âŸ©

**(Lower-StoreVarIR)**
Î“ âŠ¢ BindSlot(x) â‡“ slot    TypeOf(x) = T_x    Î“ âŠ¢ DropOnAssign(x, slot) â‡“ IR_d
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(StoreVarIR(x, v)) â‡“ âŸ¨IR_d ++ [Store(slot, v, T_x)], âŠ¥âŸ©

**(Lower-StoreVarNoDropIR)**
Î“ âŠ¢ BindSlot(x) â‡“ slot    TypeOf(x) = T_x
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(StoreVarNoDropIR(x, v)) â‡“ âŸ¨[Store(slot, v, T_x)], âŠ¥âŸ©

**(Lower-MoveStateIR)**
x = PlaceRoot(p)    Î“ âŠ¢ UpdateValid(x, MoveStateIR(p)) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(MoveStateIR(p)) â‡“ âŸ¨Îµ, âŠ¥âŸ©

**(Lower-StoreGlobal)**
T = StaticType(sym)    Î“ âŠ¢ LLVMTy(T) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(StoreGlobal(sym, v)) â‡“ âŸ¨[Store(@sym, v, T)], âŠ¥âŸ©

**(Lower-ReadPlaceIR)**
Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR_p, vâŸ©    Î“ âŠ¢ LowerIRInstr(IR_p) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPlaceIR(p)) â‡“ ll

**(Lower-WritePlaceIR)**
Î“ âŠ¢ LowerWritePlace(p, v) â‡“ IR_w    Î“ âŠ¢ LowerIRInstr(IR_w) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePlaceIR(p, v)) â‡“ ll

PtrType(v) = T â‡” (âˆƒ e, IR. Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ© âˆ§ T = ExprType(e)) âˆ¨ (âˆƒ p, IR. Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR, vâŸ© âˆ§ T = ExprType(p))
ValueType(v) = TypePrim("bool") â‡” âˆƒ b. v = BoolVal(b)
ValueType(v) = TypePrim("char") â‡” âˆƒ u. v = CharVal(u)
ValueType(UnitVal) = TypePrim("()")
ValueType(IntVal(t, x)) = TypePrim(t)
ValueType(FloatVal(t, v)) = TypePrim(t)
ValueType(PtrVal(s, addr)) = TypePtr(T, s) â‡” T âˆˆ Type
ValueType(RawPtr(q, addr)) = TypeRawPtr(q, T) â‡” T âˆˆ Type
ValueType((v_1, â€¦, v_n)) = TypeTuple([T_1, â€¦, T_n]) â‡” âˆ€ i. ValueType(v_i) = T_i
ValueType([v_1, â€¦, v_n]) = TypeArray(T, Literal(IntLiteral(n))) â‡” âˆ€ i. ValueType(v_i) = T
ValueType(SliceValue(v, r)) = TypeSlice(T) â‡” ValueType(v) = TypeArray(T, _) âˆ¨ ValueType(v) = TypeSlice(T)
ValueType(RecordValue(TypePath(p), fs)) = TypePath(p)
ValueType(RecordValue(ModalStateRef(modal_ref, S), fs)) = TypeModalState(modal_ref, S)
ValueType(ModalVal(S, v_s)) = ModalRefType(modal_ref) â‡” ValueType(v_s) = TypeModalState(modal_ref, S)
ValueType(EnumValue(path, payload)) = TypePath(p) â‡” EnumPath(path) = p
ValueType(RangeVal(k, lo, hi)) = TypeRange
ValueType(Dyn(Cl, RawPtr(`imm`, addr), T)) = TypeDynamic(Cl)
ValueType(v) = TypeString(`@View`) â‡” v âˆˆ `string@View`
ValueType(v) = TypeString(`@Managed`) â‡” v âˆˆ `string@Managed`
ValueType(v) = TypeBytes(`@View`) â‡” v âˆˆ `bytes@View`
ValueType(v) = TypeBytes(`@Managed`) â‡” v âˆˆ `bytes@Managed`
ValueType(v) = TypeString(âŠ¥) â‡” ValueType(v) = TypeString(`@View`) âˆ¨ ValueType(v) = TypeString(`@Managed`)
ValueType(v) = TypeBytes(âŠ¥) â‡” ValueType(v) = TypeBytes(`@View`) âˆ¨ ValueType(v) = TypeBytes(`@Managed`)
ValueType(v) = U â‡” âˆƒ T. ValueType(v) = T âˆ§ Member(T, U)

**(Lower-ReadPtrIR)**
PtrType(v_ptr) = TypePtr(T, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPtrIR(v_ptr)) â‡“ âŸ¨[Load(PtrAddr(v_ptr), T)], vâŸ©

**(Lower-ReadPtrIR-Raw)**
PtrType(v_ptr) = TypeRawPtr(q, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPtrIR(v_ptr)) â‡“ âŸ¨[Load(PtrAddr(v_ptr), T)], vâŸ©

**(Lower-ReadPtrIR-Null)**
PtrType(v_ptr) = TypePtr(T, `Null`)    Î“ âŠ¢ LowerIRInstr(LowerPanic(NullDeref)) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPtrIR(v_ptr)) â‡“ ll

**(Lower-ReadPtrIR-Expired)**
PtrType(v_ptr) = TypePtr(T, `Expired`)    Î“ âŠ¢ LowerIRInstr(LowerPanic(ExpiredDeref)) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ReadPtrIR(v_ptr)) â‡“ ll

**(Lower-WritePtrIR)**
PtrType(v_ptr) = TypePtr(T, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePtrIR(v_ptr, v)) â‡“ âŸ¨[Store(PtrAddr(v_ptr), v, T)], âŠ¥âŸ©

**(Lower-WritePtrIR-Null)**
PtrType(v_ptr) = TypePtr(T, `Null`)    Î“ âŠ¢ LowerIRInstr(LowerPanic(NullDeref)) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePtrIR(v_ptr, v)) â‡“ ll

**(Lower-WritePtrIR-Expired)**
PtrType(v_ptr) = TypePtr(T, `Expired`)    Î“ âŠ¢ LowerIRInstr(LowerPanic(ExpiredDeref)) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePtrIR(v_ptr, v)) â‡“ ll

**(Lower-WritePtrIR-Raw)**
PtrType(v_ptr) = TypeRawPtr(`mut`, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePtrIR(v_ptr, v)) â‡“ âŸ¨[Store(PtrAddr(v_ptr), v, T)], âŠ¥âŸ©

**(Lower-WritePtrIR-Raw-Err)**
PtrType(v_ptr) = TypeRawPtr(`imm`, T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(WritePtrIR(v_ptr, v)) â‡‘

**(Lower-AddrOfIR)**
Î“ âŠ¢ LowerAddrOf(p) â‡“ âŸ¨IR_p, addrâŸ©    Î“ âŠ¢ LowerIRInstr(IR_p) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(AddrOfIR(p)) â‡“ ll

**(Lower-CallIR-RecordCtor)**
CallTarget(callee) = RecordCtor(p)    args = []    RecordDefaultInits(p) = fields    Î“ âŠ¢ LowerFieldInits(fields) â‡“ âŸ¨IR_f, vec_fâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(CallIR(callee, args)) â‡“ âŸ¨IR_f, RecordValue(TypePath(p), vec_f)âŸ©

CallPoison(f) =
 CheckPoison(m)    if ProcModule(f) = m
 Îµ                if ProcModule(f) undefined

SRetAlloc(R) â‡“ âŸ¨[`alloca` LLVMTy(R)], pâŸ©

CallArgs(sig, params, args, R) â‡“ âŸ¨I_a, vec_a, p_retâŸ© â‡”
 I_a = Îµ âˆ§ vec_a = args âˆ§ p_ret = âŠ¥    if sig.sretSigma = false
 âˆƒ p. SRetAlloc(R) â‡“ âŸ¨I_s, pâŸ© âˆ§ I_a = I_s âˆ§ vec_a = [p] ++ args âˆ§ p_ret = p    if sig.sretSigma = true

CallInstr(sig, f, vec_a) â‡“ âŸ¨[`call` sig f(vec_a)], v_câŸ© â‡”
 v_c = (sig.llvm_ret = `void` Sigma âŠ¥ : call_result)

CallResult(sig, R, p_ret, v_c) â‡“ âŸ¨I_r, vâŸ© â‡”
 I_r = Îµ âˆ§ v = v_c    if sig.sretSigma = false
 LoadVal(p_ret, R) â‡“ âŸ¨I_r, vâŸ©    if sig.sretSigma = true

**(Lower-CallIR-Func)**
CallTarget(callee) = f    LoweredSigOf(f) = âŸ¨params, retâŸ©    LLVMCallSig(params, ret) â‡“ sig    CallPoison(f) = IR_p    Î“ âŠ¢ LowerIRInstr(IR_p) â‡“ âŸ¨I_p, âŠ¥âŸ©    CallArgs(sig, params, args, ret) â‡“ âŸ¨I_a, vec_a, p_retâŸ©    CallInstr(sig, f, vec_a) â‡“ âŸ¨I_c, v_câŸ©    CallResult(sig, ret, p_ret, v_c) â‡“ âŸ¨I_r, v_callâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(CallIR(callee, args)) â‡“ âŸ¨I_p ++ I_a ++ I_c ++ I_r, v_callâŸ©

DynType(v) = TypeDynamic(Cl) â‡” (âˆƒ e, IR. Î“ âŠ¢ LowerExpr(e) â‡“ âŸ¨IR, vâŸ© âˆ§ ExprType(e) = TypeDynamic(Cl)) âˆ¨ (âˆƒ p, IR. Î“ âŠ¢ LowerReadPlace(p) â‡“ âŸ¨IR, vâŸ© âˆ§ ExprType(p) = TypeDynamic(Cl))
DynData(v) = FieldValue(v, `data`) and DynVTable(v) = FieldValue(v, `vtable`)
VTableSlotIndex(i) = i + 3
GEP(ptr, [i_0, â€¦, i_k]) = v_gep
VTableSlotAddr(vt, i) = GEP(vt, [0, VTableSlotIndex(i)])
VTableSlot(vt, i) = Load(VTableSlotAddr(vt, i), TypeRawPtr(`imm`, TypePrim("()")))

**(Lower-CallVTable)**
DynType(base) = TypeDynamic(Cl)    v_d = DynData(base)    v_t = DynVTable(base)    v_s = VTableSlot(v_t, i)    Î“ âŠ¢ LowerIRInstr(CallIR(v_s, [v_d] ++ args)) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(CallVTable(base, i, args)) â‡“ ll

**(LowerIRInstr-ClearPanic)**
Î“ âŠ¢ ClearPanic â‡“ IR    Î“ âŠ¢ LowerIRInstr(IR) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(ClearPanic) â‡“ ll

**(LowerIRInstr-PanicCheck)**
Î“ âŠ¢ PanicCheck â‡“ IR    Î“ âŠ¢ LowerIRInstr(IR) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(PanicCheck) â‡“ ll

**(LowerIRInstr-CheckPoison)**
Î“ âŠ¢ CheckPoison(m) â‡“ IR    Î“ âŠ¢ LowerIRInstr(IR) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(CheckPoison(m)) â‡“ ll

**(LowerIRInstr-LowerPanic)**
Î“ âŠ¢ LowerPanic(r) â‡“ IR    Î“ âŠ¢ LowerIRInstr(IR) â‡“ ll
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(LowerPanic(r)) â‡“ ll

IfPhi(v_t, v_f, l_t, l_f) â‡“ âŸ¨I_phi, v_phiâŸ© â‡”
 I_phi = Îµ âˆ§ v_phi = âŠ¥    if v_t = âŠ¥ âˆ¨ v_f = âŠ¥
 âˆƒ T, Ï„, inc. ValueType(v_t) = T âˆ§ ValueType(v_f) = T âˆ§ Î“ âŠ¢ LLVMTy(T) â‡“ Ï„ âˆ§ inc = [âŸ¨v_t, l_tâŸ©, âŸ¨v_f, l_fâŸ©] âˆ§ I_phi = [Phi(Ï„, inc, v_phi)]    if v_t â‰  âŠ¥ âˆ§ v_f â‰  âŠ¥

IfLowerForm(I, v_c, v_t, v_f, v) â‡” HasBrCond(I, v_c) âˆ§ ((v_t = âŠ¥ âˆ¨ v_f = âŠ¥) â‡’ v = âŠ¥) âˆ§ ((v_t â‰  âŠ¥ âˆ§ v_f â‰  âŠ¥) â‡’ HasPhi(I, v))

**(Lower-IfIR)**
IfLabels(Î“) = âŸ¨l_t, l_f, l_mâŸ©    Î“ âŠ¢ LowerIRInstr(IR_t) â‡“ âŸ¨I_t, v_t'âŸ©    Î“ âŠ¢ LowerIRInstr(IR_f) â‡“ âŸ¨I_f, v_f'âŸ©    v_t' = v_t    v_f' = v_f    IfPhi(v_t, v_f, l_t, l_f) â‡“ âŸ¨I_phi, vâŸ©    I = [BrCond(v_c, l_t, l_f), Label(l_t)] ++ I_t ++ [Br(l_m), Label(l_f)] ++ I_f ++ [Br(l_m), Label(l_m)] ++ I_phi    IfLowerForm(I, v_c, v_t, v_f, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(IfIR(v_c, IR_t, v_t, IR_f, v_f)) â‡“ âŸ¨I, vâŸ©

BlockScope(IR_s, IR_t) = scope
BlockScope(IR_s, IR_t) = scope â‡” (âˆƒ Ïƒ, Ïƒ_1, Ïƒ_2, out, scope_0. BlockEnter(Ïƒ, []) â‡“ (Ïƒ_1, scope_0) âˆ§ ExecBlockBodyIRSigma(IR_s, IR_t, Ïƒ_1) â‡“ (out, Ïƒ_2)) âˆ§ (âˆ€ Ïƒ, Ïƒ_1, Ïƒ_2, out, scope_0. BlockEnter(Ïƒ, []) â‡“ (Ïƒ_1, scope_0) âˆ§ ExecBlockBodyIRSigma(IR_s, IR_t, Ïƒ_1) â‡“ (out, Ïƒ_2) â‡’ CurrentScope(Ïƒ_2) = scope)
EmitCleanupSpec(cs, IR) â‡” âˆ€ Ïƒ, Î“ âŠ¢ Cleanup(cs, Ïƒ) â‡“ (c, Ïƒ') â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ') âˆ§ ((c = panic) â‡’ out = Ctrl(Panic)) âˆ§ ((c = ok) â‡’ out = Val(())))
Î“ âŠ¢ EmitCleanup(cs) â‡“ IR â‡” EmitCleanupSpec(cs, IR)

**(Lower-BlockIR)**
Î“ âŠ¢ LowerIRInstr(IR_s) â‡“ âŸ¨I_s, âŠ¥âŸ©    Î“ âŠ¢ LowerIRInstr(IR_t) â‡“ âŸ¨I_t, v_t'âŸ©    v_t' = v_t    BlockScope(IR_s, IR_t) = scope    Î“ âŠ¢ CleanupPlan(scope) â‡“ cs    Î“ âŠ¢ EmitCleanup(cs) â‡“ IR_c    Î“ âŠ¢ LowerIRInstr(IR_c) â‡“ âŸ¨I_c, âŠ¥âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(BlockIR(IR_s, IR_t, v_t)) â‡“ âŸ¨I_s ++ I_t ++ I_c, v_tâŸ©

LoopLowerForm(I, loop, v) predicate
LoopIRForm(loop) predicate
MatchLowerForm(I, match, v) predicate
MatchIRForm(match) predicate
RegionLowerForm(I, region, v) predicate
RegionIRForm(region) predicate
FrameLowerForm(I, frame, v) predicate
FrameIRForm(frame) predicate
LoopLowerForm(I, loop, v) â‡” âŸ¨I, vâŸ© âˆˆ LLResult
MatchLowerForm(I, match, v) â‡” âŸ¨I, vâŸ© âˆˆ LLResult
RegionLowerForm(I, region, v) â‡” âŸ¨I, vâŸ© âˆˆ LLResult
FrameLowerForm(I, frame, v) â‡” âŸ¨I, vâŸ© âˆˆ LLResult
LoopIRForm(loop) â‡” (âˆƒ IR_b, v_b. loop = LoopIR(LoopInfinite, IR_b, v_b)) âˆ¨ (âˆƒ IR_c, v_c, IR_b, v_b. loop = LoopIR(LoopConditional, IR_c, v_c, IR_b, v_b)) âˆ¨ (âˆƒ pat, ty_opt, IR_i, v_iter, IR_b, v_b. loop = LoopIR(LoopIter, pat, ty_opt, IR_i, v_iter, IR_b, v_b))
MatchIRForm(match) â‡” âˆƒ v_s, arms. match = MatchIR(v_s, arms)
RegionIRForm(region) â‡” âˆƒ v_o, alias_opt, IR_b, v_b. region = RegionIR(v_o, alias_opt, IR_b, v_b)
FrameIRForm(frame) â‡” âˆƒ v_r, IR_b, v_b. frame = FrameIR(v_r, IR_b, v_b)

**(Lower-LoopIR)**
LoopIRForm(loop)    LoopLowerForm(I, loop, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(loop) â‡“ âŸ¨I, vâŸ©

**(Lower-MatchIR)**
MatchIRForm(match)    MatchLowerForm(I, match, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(match) â‡“ âŸ¨I, vâŸ©

**(Lower-RegionIR)**
RegionIRForm(region)    RegionLowerForm(I, region, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(region) â‡“ âŸ¨I, vâŸ©

**(Lower-FrameIR)**
FrameIRForm(frame)    FrameLowerForm(I, frame, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(frame) â‡“ âŸ¨I, vâŸ©

BranchLowerForm(I, target) â‡” Br(target) âˆˆ I
BranchLowerForm(I, v_c, t, f) â‡” BrCond(v_c, t, f) âˆˆ I

**(Lower-BranchIR)**
BranchLowerForm(I, target)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(BranchIR(target)) â‡“ âŸ¨I, âŠ¥âŸ©
BranchLowerForm(I, v_c, t, f)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(BranchIR(v_c, t, f)) â‡“ âŸ¨I, âŠ¥âŸ©

PhiLowerForm(I, T, inc, v) â‡” Î“ âŠ¢ LLVMTy(T) â‡“ Ï„ âˆ§ I = [Phi(Ï„, inc, v)]

**(Lower-PhiIR)**
PhiLowerForm(I, T, inc, v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(PhiIR(T, inc, v)) â‡“ âŸ¨I, vâŸ©

**(LowerIRDecl-Err)**
Î“ âŠ¢ LowerIRDecl(d) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRDecl(d) â‡‘

**(LowerIRInstr-Err)**
Î“ âŠ¢ LowerIRInstr(op) â‡‘
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LowerIRInstr(op) â‡‘

#### 6.12.11. Binding Storage and Validity

BindStorageJudg = {BindSlot(x) â‡“ slot, BindValid(x) â‡“ v, UpdateValid(x, op) â‡“ v', DropOnAssign(x, slot) â‡“ IR}
TypeOf(x) = T â‡” Î“; R; L âŠ¢ Identifier(x) : T
BindInfo(x) = info â‡” BindState(Î“) = ð”… âˆ§ Lookup_B(ð”…, x) = info

ProcParams(Î“) = params â‡” Î“ is lowering ProcIR(_, params, _, _)
ProcRet(Î“) = R â‡” Î“ is lowering ProcIR(_, _, R, _)
ProcSig(Î“) = sig â‡” Î“ âŠ¢ LLVMCallSig(ProcParams(Î“), ProcRet(Î“)) â‡“ sig
ParamEntry(params, x) = âŸ¨mode, TâŸ© â‡” âŸ¨mode, x, TâŸ© âˆˆ params
AllocaSlot(T) = LLVMAlloca(LLVMTy(T))
RegionSlot(r, T) = CallIR(RegionSym(`Region::alloc`), [r, IntVal(`usize`, sizeof(T)), IntVal(`usize`, alignof(T))])
BindState(Î“) = Î“.bind_state

ResolveEntry_Ï€([], tag) = âŠ¥
ResolveEntry_Ï€(âŸ¨tag, targetâŸ© :: es, t) =
 âŸ¨tag, targetâŸ©             if t = tag
 ResolveEntry_Ï€(es, t)      otherwise
ResolveTarget_Ï€(âŸ¨Î£_Ï€, RSâŸ©, tag) = target â‡” ResolveEntry_Ï€(RS, tag) = âŸ¨tag, targetâŸ©
BindProv_Î“(x) = Ï€ â‡” Î“ has provenance environment Î© âˆ§ Î“; Î© âŠ¢ Identifier(x) â‡“ Ï€
BindRegionTarget(x) = r â‡” BindProv_Î“(x) = Ï€_Region(tag) âˆ§ ResolveTarget_Ï€(Î©, tag) = r

**(BindValid-Sigma)**
BindState(Î“) = ð”…    Lookup_B(ð”…, x) = âŸ¨s, _, _, _âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindValid(x) â‡“ s

**(BindSlot-Param-ByValue)**
ProcParams(Î“) = params    ParamEntry(params, x) = âŸ¨mode, TâŸ©    Î“ âŠ¢ ABIParam(mode, T) â‡“ `ByValue`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡“ AllocaSlot(T)

**(BindSlot-Param-ByRef)**
ProcParams(Î“) = params    ParamEntry(params, x) = âŸ¨mode, TâŸ©    Î“ âŠ¢ ABIParam(mode, T) â‡“ `ByRef`    ProcSig(Î“) = sig
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡“ LLVMParam(sig, params, x)

**(BindSlot-Region)**
BindRegionTarget(x) = r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡“ RegionSlot(r, TypeOf(x))

**(BindSlot-Local)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = âŠ¥    ParamEntry(ProcParams(Î“), x) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡“ AllocaSlot(TypeOf(x))

**(BindSlot-Static)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticSymPath(path, name) = sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡“ @sym

**(UpdateValid-BindVar)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UpdateValid(x, BindVarIR(x, v)) â‡“ `Valid`

**(UpdateValid-StoreVar)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UpdateValid(x, StoreVarIR(x, v)) â‡“ `Valid`

**(UpdateValid-StoreVarNoDrop)**
Î“ âŠ¢ BindValid(x) â‡“ s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UpdateValid(x, StoreVarNoDropIR(x, v)) â‡“ s

**(UpdateValid-MoveRoot)**
op = MoveStateIR(p)    PlaceRoot(p) = x    FieldHead(p) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UpdateValid(x, op) â‡“ Moved

**(UpdateValid-PartialMove-Init)**
op = MoveStateIR(p)    PlaceRoot(p) = x    FieldHead(p) = f    BindValid(x) â‡“ `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UpdateValid(x, op) â‡“ PartiallyMoved({f})

**(UpdateValid-PartialMove-Step)**
op = MoveStateIR(p)    PlaceRoot(p) = x    FieldHead(p) = f    BindValid(x) â‡“ PartiallyMoved(F)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UpdateValid(x, op) â‡“ PartiallyMoved(F âˆª {f})

DropOnAssignApplicable(x) â‡” BindInfo(x).mov = immov âˆ§ BindInfo(x).resp = resp
AddrAdd(addr, n) = addr + n
ElemType(T_b) = T â‡” StripPerm(T_b) = TypeArray(T, _) âˆ¨ StripPerm(T_b) = TypeSlice(T)
FieldAddr(T, addr, f) = AddrAdd(addr, FieldOffset(Fields(R), f))    when StripPerm(T) = TypePath(p) âˆ§ RecordDecl(p) = R
TupleAddr(T, addr, i) = AddrAdd(addr, FieldOffset(TupleFields([T_1, â€¦, T_n]), i))    when StripPerm(T) = TypeTuple([T_1, â€¦, T_n])

**(DropOnAssign-NotApplicable)**
Â¬ DropOnAssignApplicable(x)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ Îµ

FieldsRev(R) = rev(Fields(R))
FieldDropIR(slot, p, f, T) = EmitDrop(T, Load(FieldAddr(TypePath(p), slot, f), T))
FieldDropSeq(slot, p, F) = ++_{âŸ¨f_i, T_iâŸ© âˆˆ FieldsRev(RecordDecl(p)), f_i âˆ‰ F} FieldDropIR(slot, p, f_i, T_i)

**(DropOnAssign-Record-Valid)**
DropOnAssignApplicable(x)    TypeOf(x) = TypePath(p)    RecordDecl(p) = R    BindValid(x) â‡“ `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ EmitDrop(TypePath(p), Load(slot, TypePath(p)))

**(DropOnAssign-Record-Partial)**
DropOnAssignApplicable(x)    TypeOf(x) = TypePath(p)    RecordDecl(p) = R    BindValid(x) â‡“ PartiallyMoved(F)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ FieldDropSeq(slot, p, F)

**(DropOnAssign-Record-Moved)**
DropOnAssignApplicable(x)    TypeOf(x) = TypePath(p)    RecordDecl(p) = R    BindValid(x) â‡“ Moved
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ Îµ

**(DropOnAssign-Aggregate-Ok)**
DropOnAssignApplicable(x)    TypeOf(x) âˆˆ {TypeArray(_, _), TypeTuple(_), TypeUnion(_), TypeModalState(_, _)}    BindValid(x) â‡“ s    s â‰  Moved
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ EmitDrop(TypeOf(x), Load(slot, TypeOf(x)))

**(DropOnAssign-Aggregate-Moved)**
DropOnAssignApplicable(x)    TypeOf(x) âˆˆ {TypeArray(_, _), TypeTuple(_), TypeUnion(_), TypeModalState(_, _)}    BindValid(x) â‡“ Moved
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡“ Îµ

**(BindSlot-Err)**
BindSlot(x) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindSlot(x) â‡‘

**(BindValid-Err)**
BindValid(x) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BindValid(x) â‡‘

**(UpdateValid-Err)**
UpdateValid(x, op) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ UpdateValid(x, op) â‡‘

**(DropOnAssign-Err)**
DropOnAssign(x, slot) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropOnAssign(x, slot) â‡‘

#### 6.12.12. Call ABI Mapping

LLVMCallJudg = {LLVMCallSig(params, ret) â‡“ sig, LLVMArgLower(x, T, k) â‡“ ll, LLVMRetLower(T, k) â‡“ ll}

SigLLVMParams(sig) = llvm_params
SigLLVMRet(sig) = llvm_ret
SigLLVMAttrs(sig) = attrs
SigSRet(sig) = sretSigma

**(LLVMArgLower-ByValue-PtrValid)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„    StripPerm(T) = TypePtr(U, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgLower(x, T, `ByValue`) â‡“ âŸ¨Ï„, LLVMArgAttrsExt(x, T) âˆª LLVMPtrAttrs(T)âŸ©

**(LLVMArgLower-ByValue-Other)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„    StripPerm(T) â‰  TypePtr(_, `Valid`)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgLower(x, T, `ByValue`) â‡“ âŸ¨Ï„, LLVMArgAttrsExt(x, T)âŸ©

**(LLVMArgLower-ByRef)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgLower(x, T, `ByRef`) â‡“ âŸ¨LLVMPtrTy(TypePtr(TypePerm(`const`, T), `Valid`)), LLVMPtrAttrs(TypePtr(TypePerm(`const`, T), `Valid`)) âˆª LLVMArgAttrsExt(x, T)âŸ©

**(LLVMRetLower-ByValue-ZST)**
sizeof(T) = 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMRetLower(T, `ByValue`) â‡“ `void`

**(LLVMRetLower-ByValue)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„    sizeof(T) > 0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMRetLower(T, `ByValue`) â‡“ Ï„

**(LLVMRetLower-SRet)**
Î“ âŠ¢ LLVMTy(T) â‡“ Ï„
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMRetLower(T, `SRet`) â‡“ `void`

ArgInclude(k, T) â‡” (k = `ByRef`) âˆ¨ (k = `ByValue` âˆ§ sizeof(T) > 0)
LLVMArgList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]) = [Ï„_i | ArgInclude(k_i, T_i) âˆ§ Î“ âŠ¢ LLVMArgLower(x_i, T_i, k_i) â‡“ âŸ¨Ï„_i, A_iâŸ©]
LLVMAttrList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]) = [A_i | ArgInclude(k_i, T_i) âˆ§ Î“ âŠ¢ LLVMArgLower(x_i, T_i, k_i) â‡“ âŸ¨Ï„_i, A_iâŸ©]

**(LLVMCall-ByValue)**
âŸ¨[k_1, â€¦, k_n], k_r, sretSigmaâŸ© = ABICall([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)    k_r = `ByValue`    âˆ€ i, Î“ âŠ¢ LLVMArgLower(x_i, T_i, k_i) â‡“ âŸ¨Ï„_i, A_iâŸ©    Î“ âŠ¢ LLVMRetLower(R, `ByValue`) â‡“ Ï„_r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMCallSig([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], R) â‡“ âŸ¨LLVMArgList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]), Ï„_r, LLVMAttrList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]), falseâŸ©

**(LLVMCall-SRet)**
âŸ¨[k_1, â€¦, k_n], k_r, sretSigmaâŸ© = ABICall([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R)    k_r = `SRet`    sret_param = LLVMPtrTy(TypePtr(TypePerm(`unique`, R), `Valid`))    A_sret = {`sret`, `noalias`} âˆª LLVMPtrAttrs(TypePtr(TypePerm(`unique`, R), `Valid`))    âˆ€ i, Î“ âŠ¢ LLVMArgLower(x_i, T_i, k_i) â‡“ âŸ¨Ï„_i, A_iâŸ©    Î“ âŠ¢ LLVMRetLower(R, `SRet`) â‡“ `void`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMCallSig([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], R) â‡“ âŸ¨[sret_param] ++ LLVMArgList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]), `void`, [A_sret] ++ LLVMAttrList([âŸ¨m_1, x_1, T_1âŸ©, â€¦, âŸ¨m_n, x_n, T_nâŸ©], [k_1, â€¦, k_n]), trueâŸ©

ByRefAccess(T) =
 `rw`    if PermOf(T) = `unique`
 `ro`    otherwise

**(LLVMArgLower-Err)**
LLVMArgLower(x, T, k) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMArgLower(x, T, k) â‡‘

**(LLVMRetLower-Err)**
LLVMRetLower(T, k) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMRetLower(T, k) â‡‘

**(LLVMCall-Err)**
LLVMCallSig(params, ret) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LLVMCallSig(params, ret) â‡‘

#### 6.12.13. VTable Emission

VTableJudg = {EmitVTable(T, Cl) â‡“ IRDecl, EmitDropGlue(T) â‡“ IRDecl, DropGlueSym(T) â‡“ sym}

DropGlueSym(T) = PathSig(["cursive", "runtime", "drop"] ++ PathOfType(T))
VTableHeader(T) = [sizeof(T), alignof(T), DropGlueSym(T)]
PtrTy = LLVMPtrTy(TypeRawPtr(`imm`, TypePrim("()")))
k = |VTable(T, Cl)|
VTableTy(Cl) = LLVMStruct([LLVMTy(TypePrim("usize")), LLVMTy(TypePrim("usize")), PtrTy] ++ [PtrTy]^k)
GlobalVTable : Symbol Ã— Header Ã— Slots â†’ IRDecl
LLVMGlobalVTable : Symbol Ã— Header Ã— Slots â†’ LLVMDecl

**(EmitVTable-Decl)**
Mangle(VTableDecl(T, Cl)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitVTable(T, Cl) â‡“ GlobalVTable(sym, VTableHeader(T), VTable(T, Cl))

VTableSlots(T, Cl) = [DispatchSym(T, Cl, m.name) | m âˆˆ VTableEligible(Cl)]

DropGlueSpec(T, IR) â‡” âˆ€ Ïƒ, addr, v. LookupVal(Ïƒ, "data") = RawPtr(`imm`, addr) âˆ§ ReadAddr(Ïƒ, addr) = v â‡’ (ExecIRSigma(IR, Ïƒ) â‡“ (out, Ïƒ') âˆ§ Î“ âŠ¢ DropValue(T, v, âˆ…) â‡“ Ïƒ')
Î“ âŠ¢ DropGlueIR(T) â‡“ IR â‡” DropGlueSpec(T, IR)

**(EmitDropGlue-Decl)**
Î“ âŠ¢ DropGlueSym(T) â‡“ sym    Î“ âŠ¢ DropGlueIR(T) â‡“ IR_drop
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitDropGlue(T) â‡“ ProcIR(sym, [âŸ¨`move`, `data`, TypeRawPtr(`imm`, TypePrim("()"))âŸ©, PanicOutParam], TypePrim("()"), IR_drop)

**(EmitVTable-Err)**
EmitVTable(T, Cl) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitVTable(T, Cl) â‡‘

#### 6.12.14. Literal Data Emission

LiteralEmitJudg = {EmitLiteralData(kind, bytes) â‡“ IRDecl, EmitStringLit(lit) â‡“ sym, EmitBytesLit(lit) â‡“ sym}

LiteralDataSym(kind, bytes) = Mangle(LiteralData(kind, bytes))
StringBytes(lit) function
EscapeBytes(e) =
 EscapeValue(e)          if e = `"\u{"` h_1 â€¦ h_n `"}"`
 [EscapeValue(e)]        otherwise
StringBytesFrom(T, p, q) =
 []                                                        if p = q
 EscapeBytes(Lexeme(T, p, r)) ++ StringBytesFrom(T, r, q)   if p < q âˆ§ T[p] = `"\\"` âˆ§ EscapeMatch(T, p, r)
 EncodeUTF8(T[p]) ++ StringBytesFrom(T, p + 1, q)           if p < q âˆ§ T[p] â‰  `"\\"`
StringBytes(lit) = bytes â‡” lit.kind = StringLiteral âˆ§ T = Lexeme(lit) âˆ§ StringBytesFrom(T, 1, |T|-1) = bytes
RawBytes(lit) = bytes â‡” lit.kind = BytesLiteral âˆ§ lit.payload = bytes
RawBytes(lit) = StringBytes(lit) â‡” lit.kind = StringLiteral

**(EmitLiteralData-Decl)**
Î“ âŠ¢ Mangle(LiteralData(kind, bytes)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLiteralData(kind, bytes) â‡“ GlobalConst(sym, bytes)

**(EmitLiteral-String)**
StringBytes(lit) = bytes    Î“ âŠ¢ Mangle(LiteralData("string", bytes)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitStringLit(lit) â‡“ sym
StringBytes(lit) = bytes â‡’ Utf8Valid(bytes)

**(EmitLiteral-Bytes)**
RawBytes(lit) = bytes    Î“ âŠ¢ Mangle(LiteralData("bytes", bytes)) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitBytesLit(lit) â‡“ sym
RawBytes(lit) undefined â‡’ EmitBytesLit(lit) undefined

**(EmitLiteral-Char)**
T = TypePrim("char")    Î“ âŠ¢ EncodeConst(T, lit) â‡“ bytes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLiteralData("char", bytes) â‡“ GlobalConst(Mangle(LiteralData("char", bytes)), bytes)

**(EmitLiteral-Int)**
T = TypePrim(t)    t âˆˆ IntTypes    Î“ âŠ¢ EncodeConst(T, lit) â‡“ bytes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLiteralData("int", bytes) â‡“ GlobalConst(Mangle(LiteralData("int", bytes)), bytes)

**(EmitLiteral-Float)**
T = TypePrim(t)    t âˆˆ FloatTypes    Î“ âŠ¢ EncodeConst(T, lit) â‡“ bytes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLiteralData("float", bytes) â‡“ GlobalConst(Mangle(LiteralData("float", bytes)), bytes)

**(EmitLiteral-Err)**
EmitLiteralData(kind, bytes) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EmitLiteralData(kind, bytes) â‡‘

#### 6.12.15. String/Bytes Built-ins

BuiltinSymJudg = {BuiltinSym(method) â‡“ sym}

StringBuiltins = {`string::from`, `string::as_view`, `string::to_managed`, `string::clone_with`, `string::append`, `string::length`, `string::is_empty`}
BytesBuiltins = {`bytes::with_capacity`, `bytes::from_slice`, `bytes::as_view`, `bytes::to_managed`, `bytes::view`, `bytes::view_string`, `bytes::append`, `bytes::length`, `bytes::is_empty`}
StringMethod(method) â‡” âˆƒ name. method = `string::`name
BytesMethod(method) â‡” âˆƒ name. method = `bytes::`name

BuiltinSym(`string::from`) = PathSig(["cursive", "runtime", "string", "from"])
BuiltinSym(`string::as_view`) = PathSig(["cursive", "runtime", "string", "as_view"])
BuiltinSym(`string::to_managed`) = PathSig(["cursive", "runtime", "string", "to_managed"])
BuiltinSym(`string::clone_with`) = PathSig(["cursive", "runtime", "string", "clone_with"])
BuiltinSym(`string::append`) = PathSig(["cursive", "runtime", "string", "append"])
BuiltinSym(`string::length`) = PathSig(["cursive", "runtime", "string", "length"])
BuiltinSym(`string::is_empty`) = PathSig(["cursive", "runtime", "string", "is_empty"])

BuiltinSym(`bytes::with_capacity`) = PathSig(["cursive", "runtime", "bytes", "with_capacity"])
BuiltinSym(`bytes::from_slice`) = PathSig(["cursive", "runtime", "bytes", "from_slice"])
BuiltinSym(`bytes::as_view`) = PathSig(["cursive", "runtime", "bytes", "as_view"])
BuiltinSym(`bytes::to_managed`) = PathSig(["cursive", "runtime", "bytes", "to_managed"])
BuiltinSym(`bytes::view`) = PathSig(["cursive", "runtime", "bytes", "view"])
BuiltinSym(`bytes::view_string`) = PathSig(["cursive", "runtime", "bytes", "view_string"])
BuiltinSym(`bytes::append`) = PathSig(["cursive", "runtime", "bytes", "append"])
BuiltinSym(`bytes::length`) = PathSig(["cursive", "runtime", "bytes", "length"])
BuiltinSym(`bytes::is_empty`) = PathSig(["cursive", "runtime", "bytes", "is_empty"])

**(BuiltinSym-String-Err)**
StringMethod(method)    method âˆ‰ StringBuiltins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(method) â‡‘

**(BuiltinSym-Bytes-Err)**
BytesMethod(method)    method âˆ‰ BytesBuiltins
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BuiltinSym(method) â‡‘

#### 6.12.16. Managed String/Bytes Drop Hooks

DropHookJudg = {StringDropSym â‡“ sym, BytesDropSym â‡“ sym}

**(StringDropSym-Decl)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringDropSym â‡“ PathSig(["cursive", "runtime", "string", "drop_managed"])

**(BytesDropSym-Decl)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesDropSym â‡“ PathSig(["cursive", "runtime", "bytes", "drop_managed"])

**(StringDropSym-Err)**
StringDropSym undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ StringDropSym â‡‘

**(BytesDropSym-Err)**
BytesDropSym undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ BytesDropSym â‡‘

#### 6.12.17. Entrypoint and Context Construction

EntryJudg = {EntrySym â‡“ sym, ContextInitSym â‡“ sym, EntryStub(P) â‡“ IRDecl}

**(EntrySym-Decl)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EntrySym â‡“ PathSig(["main"])

**(ContextInitSym-Decl)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ContextInitSym â‡“ PathSig(["cursive", "runtime", "context_init"])

PanicRecordInit(Ïƒ) â‡” PanicRecordOf(Ïƒ) = âŸ¨false, 0âŸ©
EntryStubSpec(P, IR_entry) â‡” Executable(P) âˆ§ âˆƒ d, main_sym. MainDecls(P) = [d] âˆ§ Î“ âŠ¢ Mangle(d) â‡“ main_sym âˆ§ âˆ€ Ïƒ. âˆƒ ctx, ret, c, Ïƒ_1, Ïƒ_2, Ïƒ_3, Ïƒ_4.
 ExecIRSigma(CallIR(ContextInitSym, []), Ïƒ) â‡“ (Val(ctx), Ïƒ_1) âˆ§ PanicRecordInit(Ïƒ_2) âˆ§ ExecIRSigma(CallIR(main_sym, [ctx, PanicOutName]), Ïƒ_2) â‡“ (Val(ret), Ïƒ_3) âˆ§
 (PanicRecordOf(Ïƒ_3) = âŸ¨true, câŸ© â‡’ ExecIRSigma(CallIR(PanicSym, [c]), Ïƒ_3) â‡“ (Ctrl(Panic), Ïƒ_4)) âˆ§
 (PanicRecordOf(Ïƒ_3) = âŸ¨false, câŸ© â‡’ âˆƒ IR_d. Î“ âŠ¢ EmitDeinitPlan(P) â‡“ IR_d âˆ§ ExecIRSigma(IR_d, Ïƒ_3) â‡“ (Val(()), Ïƒ_4)) âˆ§
 (PanicRecordOf(Ïƒ_3) = âŸ¨true, câŸ© â‡’ ExecIRSigma(IR_entry, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_4)) âˆ§
 (PanicRecordOf(Ïƒ_3) = âŸ¨false, câŸ© â‡’ ExecIRSigma(IR_entry, Ïƒ) â‡“ (Val(ret), Ïƒ_4))

**(EntryStub-Decl)**
Î“ âŠ¢ EntrySym â‡“ sym    EntryStubSpec(P, IR_entry)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EntryStub(P) â‡“ ProcIR(sym, [], TypePrim("i32"), IR_entry)

**(EntrySym-Err)**
EntrySym undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EntrySym â‡‘

**(EntryStub-Err)**
EntryStub(P) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EntryStub(P) â‡‘

#### 6.12.18. Poisoning Instrumentation

PoisonJudg = {PoisonFlag(m) â‡“ sym, CheckPoison(m) â‡“ IR, SetPoison(m) â‡“ IR}

PoisonSet(m) = {m} âˆª {x | Reachable(x, m, E_val^eager)}

**(PoisonFlag-Decl)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PoisonFlag(m) â‡“ PathSig(["cursive", "runtime", "poison"] ++ PathOfModule(m))

PoisonFlagDecl(m) = GlobalZero(PoisonFlag(m), sizeof(TypePrim("bool")))
StaticType(PoisonFlag(m)) = TypePrim("bool")

**(CheckPoison-Use)**
PoisonFlag(m) â‡“ sym
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckPoison(m) â‡“ IR
Î“ âŠ¢ CheckPoison(m) â‡“ IR â‡” âˆ€ Ïƒ. (ReadAddr(Ïƒ, AddrOfSym(PoisonFlag(m))) â‰  0 â‡’ âˆƒ Ïƒ'. ExecIRSigma(IR, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ') âˆ§ ExecIRSigma(LowerPanic(InitPanic(m)), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ')) âˆ§ (ReadAddr(Ïƒ, AddrOfSym(PoisonFlag(m))) = 0 â‡’ ExecIRSigma(IR, Ïƒ) â‡“ (Val(()), Ïƒ))

**(SetPoison-OnInitFail)**
PoisonSet(m) = {m_1, â€¦, m_k}    âˆ€ i, PoisonFlag(m_i) â‡“ sym_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SetPoison(m) â‡“ SeqIR(StoreGlobal(sym_1, 1), â€¦, StoreGlobal(sym_k, 1))

**(PoisonFlag-Err)**
PoisonFlag(m) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PoisonFlag(m) â‡‘

**(CheckPoison-Err)**
CheckPoison(m) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CheckPoison(m) â‡‘

**(SetPoison-Err)**
SetPoison(m) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ SetPoison(m) â‡‘

## 7. Dynamic Semantics

### 7.1. Initialization Order and Poisoning

Vertices(G_e) = V â‡” G_e = âŸ¨V, EâŸ©
Edges(G_e) = E â‡” G_e = âŸ¨V, EâŸ©
Index(L, x) = i â‡” 0 â‰¤ i < |L| âˆ§ L[i] = x
TopoOrder(G_e, L) â‡” Distinct(L) âˆ§ Set(L) = Vertices(G_e) âˆ§ âˆ€ (u, v) âˆˆ Edges(G_e). Index(L, u) < Index(L, v)
Incomparable_{G_e}(u, v) â‡” Â¬ Reachable(u, v, Edges(G_e)) âˆ§ Â¬ Reachable(v, u, Edges(G_e))
TopoTieBreak(G_e, L, P) â‡” âˆ€ u, v âˆˆ Vertices(G_e). Incomparable_{G_e}(u, v) âˆ§ Index(P.modules, u) < Index(P.modules, v) â‡’ Index(L, u) < Index(L, v)
Cycle(G_e) â‡” âˆƒ v âˆˆ Vertices(G_e). Reachable(v, v, Edges(G_e))

**(Topo-Ok)**
Project(Î“) = P    Î“ âŠ¢ G_e : DAG    TopoOrder(G_e, L)    TopoTieBreak(G_e, L, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Topo(G_e) â‡“ L

**(Topo-Cycle)**
Cycle(G_e)    c = Code(Topo-Cycle)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Topo(G_e) â‡‘ c

P = Project(Î“)
StaticInitOf(item) = init â‡” item = StaticDecl(attrs_opt, vis, mut, binding, span, doc) âˆ§ binding = âŸ¨pat, ty_opt, op, init, spâŸ©
StaticInitOf(item) = âŠ¥ â‡” item âˆ‰ StaticDecl(_, _, _, _, _, _)
InitList(m) = [ init | item âˆˆ Items(P, m) âˆ§ StaticInitOf(item) = init ]

InitOrder(G_e) = L â‡” Î“ âŠ¢ Topo(G_e) â‡“ L
InitPlan(G_e) = ++_{m âˆˆ InitOrder(G_e)} InitList(m)

DeinitOrder(G_e) = rev(InitOrder(G_e))

StaticBindOrder(m) = ++_{item âˆˆ StaticItems(P, m), item = StaticDecl(attrs_opt, vis, mut, binding, span, doc)} [âŸ¨PathOfModule(m), xâŸ© | x âˆˆ StaticBindList(binding)]

GlobalStaticOrder = ++_{m âˆˆ InitOrder(G_e)} StaticBindOrder(m)

DeinitList(P) = rev([ DropStatic(path, name) | âŸ¨path, nameâŸ© âˆˆ GlobalStaticOrder âˆ§ StaticBindInfo(path, name).resp = resp ])

Î“ âŠ¢ Eval(e, Ïƒ) â‡“ v â‡” âˆƒ Ïƒ'. Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ')
Î“ âŠ¢ Eval(e, Ïƒ) â‡‘ panic â‡” âˆƒ Ïƒ'. Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ')

**Initialization (Small-Step).**

InitState = {InitStart(G_e, L, Ïƒ), InitMod(L, mi, ii, P, Ïƒ), InitDone(Ïƒ), InitPanic(P, Ïƒ)}
InitItem(L, mi, ii) = e â‡” mi < |L| âˆ§ L[mi] = m âˆ§ InitList(m)[ii] = e
InitLen(L, mi) = k â‡” mi < |L| âˆ§ L[mi] = m âˆ§ |InitList(m)| = k

**(Init-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨InitStart(G_e, L, Ïƒ)âŸ© â†’ âŸ¨InitMod(L, 0, 0, âˆ…, Ïƒ)âŸ©

**(Init-Step)**
InitItem(L, mi, ii) = e    Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨InitMod(L, mi, ii, P, Ïƒ)âŸ© â†’ âŸ¨InitMod(L, mi, ii + 1, P, Ïƒ')âŸ©

**(Init-Next-Module)**
InitLen(L, mi) = k    ii = k
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨InitMod(L, mi, ii, P, Ïƒ)âŸ© â†’ âŸ¨InitMod(L, mi + 1, 0, P, Ïƒ)âŸ©

**(Init-Panic)**
InitItem(L, mi, ii) = e    Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ')    L[mi] = m    P' = P âˆª {m} âˆª {x | Reachable(x, m, E_val^eager)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨InitMod(L, mi, ii, P, Ïƒ)âŸ© â†’ âŸ¨InitPanic(P', Ïƒ')âŸ©

**(Init-Done)**
mi = |L|
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨InitMod(L, mi, ii, P, Ïƒ)âŸ© â†’ âŸ¨InitDone(Ïƒ)âŸ©

**Initialization (Big-Step).**

**(Init-Ok)**
âŸ¨InitStart(G_e, InitOrder(G_e), Ïƒ)âŸ© â†’* âŸ¨InitDone(Ïƒ')âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Init(G_e, Ïƒ) â‡“ Ïƒ'

**(Init-Fail)**
âŸ¨InitStart(G_e, InitOrder(G_e), Ïƒ)âŸ© â†’* âŸ¨InitPanic(P, Ïƒ')âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Init(G_e, Ïƒ) â‡‘ panic(P)

**Deinitialization (Big-Step).**

**(Deinit-Ok)**
Î“ âŠ¢ Cleanup(DeinitList(P), Ïƒ) â‡“ (ok, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Deinit(P, Ïƒ) â‡“ Ïƒ'

**(Deinit-Panic)**
Î“ âŠ¢ Cleanup(DeinitList(P), Ïƒ) â‡“ (panic, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Deinit(P, Ïƒ) â‡‘ panic

### 7.2. Modal Layout (Dynamic Semantics)

layout(TypeModalState(modal_ref, S)) = layout(`record` {ModalPayload(modal_ref, S)})
ModalPayload(modal_ref, S) = âˆ… â‡’ sizeof(TypeModalState(modal_ref, S)) = 0
layout(ModalRefType(modal_ref)) =
 layout(T_p)    if NicheApplies(modal_ref) âˆ§ PayloadState(modal_ref) = S_p âˆ§ ModalSingleFieldPayload(modal_ref, S_p) = T_p
 layout(`enum` {S_1(ModalPayload(modal_ref, S_1)), â€¦, S_n(ModalPayload(modal_ref, S_n))})    otherwise
ModalDeclOf(modal_ref) = M
sizeof(ModalRefType(modal_ref)) =
 sizeof(T_p)    if NicheApplies(modal_ref) âˆ§ PayloadState(modal_ref) = S_p âˆ§ ModalSingleFieldPayload(modal_ref, S_p) = T_p
 sizeof(Discriminant) + max_{S âˆˆ States(M)}(sizeof(TypeModalState(modal_ref, S))) + Padding    otherwise
alignof(ModalRefType(modal_ref)) =
 alignof(T_p)    if NicheApplies(modal_ref) âˆ§ PayloadState(modal_ref) = S_p âˆ§ ModalSingleFieldPayload(modal_ref, S_p) = T_p
 max(alignof(Discriminant), max_{S âˆˆ States(M)}(alignof(TypeModalState(modal_ref, S))))    otherwise
ValueBits(modal_ref, âŸ¨S, vâŸ©) = bits â‡” ModalBits(modal_ref, S, v) = bits

### 7.3. Modal Pattern Matching

MatchModalJudg = {MatchModal(p, v) â‡“ B}

**(Match-Modal-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchModal(@S, âŸ¨S, vâŸ©) â‡“ âˆ…

**(Match-Modal-Record)**
Î“ âŠ¢ MatchRecord(fs, v) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchModal(@S{fs}, âŸ¨S, vâŸ©) â‡“ B

BindEnv = Ident â‡€ Value
Dom(B) = {x | x âˆˆ Ident âˆ§ B[x] defined}
B_1 âŠŽ B_2 = B â‡” Dom(B_1) âˆ© Dom(B_2) = âˆ… âˆ§ âˆ€ x. (x âˆˆ Dom(B_1) â‡’ B[x] = B_1[x]) âˆ§ (x âˆˆ Dom(B_2) â‡’ B[x] = B_2[x])
MatchPatJudg = {MatchPattern(p, v) â‡“ B}
PatType(LiteralPattern(lit)) =
 TypePrim(t)         if lit.kind = IntLiteral âˆ§ IntSuffix(lit) = t
 TypePrim("i32")     if lit.kind = IntLiteral âˆ§ IntSuffix(lit) = âŠ¥
 TypePrim(t)         if lit.kind = FloatLiteral âˆ§ FloatSuffix(lit) = t âˆ§ t âˆˆ {"f16", "f32", "f64"}
 TypePrim("f32")     if lit.kind = FloatLiteral âˆ§ FloatSuffix(lit) = "f"
 TypePrim("bool")    if lit.kind = BoolLiteral
 TypePrim("char")    if lit.kind = CharLiteral
 TypeString(`@View`) if lit.kind = StringLiteral
 âŠ¥                   if lit.kind = NullLiteral

**(Match-Wildcard)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(_, v) â‡“ âˆ…

**(Match-Ident)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(x, v) â‡“ {x â†¦ v}

**(Match-Typed)**
UnionCase(v) = âŸ¨T', v'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(x : T, v) â‡“ {x â†¦ v'}    if Î“ âŠ¢ T' â‰¡ T else âŠ¥

**(Match-Literal)**
T = PatType(â„“)    LiteralValue(â„“, T) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(â„“, v) â‡“ âˆ…

**(Match-Tuple)**
v = (v_1, â€¦, v_n)    âˆ€ i, Î“ âŠ¢ MatchPattern(p_i, v_i) â‡“ B_i    B = âŠŽ_i B_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern((p_1, â€¦, p_n), v) â‡“ B

**(Match-Record)**
Î“ âŠ¢ MatchRecord(fs, v) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(R{fs}, v) â‡“ B

**(Match-Enum-Unit)**
v = EnumValue(path', âŠ¥)    EnumPath(path') = path    VariantName(path') = name
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(EnumPattern(path, name, âŠ¥), v) â‡“ âˆ…

**(Match-Enum-Tuple)**
v = EnumValue(path', TuplePayload(vec_v))    EnumPath(path') = path    VariantName(path') = name    âˆ€ i, Î“ âŠ¢ MatchPattern(p_i, v_i) â‡“ B_i    B = âŠŽ_i B_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(EnumPattern(path, name, TuplePayloadPattern([p_1, â€¦, p_n])), v) â‡“ B

**(Match-Enum-Record)**
v = EnumValue(path', RecordPayload(vec_f))    EnumPath(path') = path    VariantName(path') = name    Î“ âŠ¢ MatchRecord(fs, RecordPayload(vec_f)) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(EnumPattern(path, name, RecordPayloadPattern(fs)), v) â‡“ B

**(Match-Modal-General)**
Î“ âŠ¢ MatchModal(@S{fs}, âŸ¨S, vâŸ©) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(@S{fs}, âŸ¨S, vâŸ©) â‡“ B

**(Match-Modal-State)**
Î“ âŠ¢ MatchRecord(fs, v) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(@S{fs}, v) â‡“ B

**(Match-Range)**
ConstPat(p_l) = v_l    ConstPat(p_h) = v_h    v_l â‰¤ v â‰¤ v_h
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(p_l `..=` p_h, v) â‡“ âˆ…

ConstPat(p_l) = v_l    ConstPat(p_h) = v_h    v_l â‰¤ v < v_h
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchPattern(p_l `..` p_h, v) â‡“ âˆ…

### 7.4. Deterministic Destruction and Unwinding (Cursive0)

Responsible(b) â‡” BindInfo(b).resp = resp

CleanupItem ::= DropBinding(b) | DropStatic(path, name) | DeferBlock(b)
DropStatus = {ok, panic}
DropJudg = {DropAction(b) â‡“ Ïƒ', DropValue(T, v, F) â‡“ Ïƒ', DropStaticAction(path, name) â‡“ Ïƒ', DropActionOut(b) â‡“ (c, Ïƒ'), DropValueOut(T, v, F) â‡“ (c, Ïƒ'), DropStaticActionOut(path, name) â‡“ (c, Ïƒ')}
DropAction(b) â‡“ Ïƒ' â‡” DropActionOut(b) â‡“ (ok, Ïƒ')
DropValue(T, v, F) â‡“ Ïƒ' â‡” DropValueOut(T, v, F) â‡“ (ok, Ïƒ')
DropStaticAction(path, name) â‡“ Ïƒ' â‡” DropStaticActionOut(path, name) â‡“ (ok, Ïƒ')
RecordType(T) â‡” âˆƒ p. T = TypePath(p) âˆ§ RecordDecl(p) defined
DropCall(T, v, Ïƒ) â‡“ (out, Ïƒ') relation
Â¬ DropType(T) â‡’ DropCall(T, v, Ïƒ) â‡“ (Val(()), Ïƒ)
DropType(T) âˆ§ BuiltinDropType(T) âˆ§ T = TypeString(`@Managed`) âˆ§ Î“ âŠ¢ StringDropSym â‡“ sym âˆ§ ExecIRSigma(CallIR(sym, [v]), Ïƒ) â‡“ (out, Ïƒ') â‡’ DropCall(T, v, Ïƒ) â‡“ (out, Ïƒ')
DropType(T) âˆ§ BuiltinDropType(T) âˆ§ T = TypeBytes(`@Managed`) âˆ§ Î“ âŠ¢ BytesDropSym â‡“ sym âˆ§ ExecIRSigma(CallIR(sym, [v]), Ïƒ) â‡“ (out, Ïƒ') â‡’ DropCall(T, v, Ïƒ) â‡“ (out, Ïƒ')
DropType(T) âˆ§ Â¬ BuiltinDropType(T) âˆ§ LookupMethod(StripPerm(T), "drop") = m âˆ§ Sig_T(StripPerm(T), m) = âŸ¨TypePerm(`unique`, StripPerm(T)), [], TypePrim("()")âŸ© âˆ§ BindParams(MethodParamsDecl(StripPerm(T), m), [v]) = binds âˆ§ BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope) âˆ§ Î“ âŠ¢ EvalBlockBodySigma(m.body, Ïƒ_1) â‡“ (out_1, Ïƒ_2) âˆ§ BlockExit(Ïƒ_2, scope, out_1) â‡“ (out_2, Ïƒ_3) âˆ§ ReturnOut(out_2) = out â‡’ DropCall(T, v, Ïƒ) â‡“ (out, Ïƒ_3)
ReleaseValue(T, v, Ïƒ) â‡“ Ïƒ' relation
ReleaseValue(T, v, Ïƒ) â‡“ Ïƒ' â‡” Ïƒ' = Ïƒ
DropChildren(T, v, F) =
 [âŸ¨T_i, v_iâŸ© | âŸ¨f_i, T_iâŸ© âˆˆ FieldsRev(R), f_i âˆ‰ F, FieldValue(v, f_i) = v_i]    if T = TypePath(p) âˆ§ RecordDecl(p) = R
 [âŸ¨T_i, v_iâŸ© | T = TypeTuple([T_0, â€¦, T_{n-1}]), i âˆˆ rev([0, â€¦, n-1]), TupleValue(v, i) = v_i]    if T = TypeTuple(_)
 [âŸ¨T_e, v_iâŸ© | T = TypeArray(T_e, n), i âˆˆ rev([0, â€¦, n-1]), IndexValue(v, i) = v_i]    if T = TypeArray(_, _)
 [âŸ¨T', v'âŸ© | UnionCase(v) = âŸ¨T', v'âŸ©]    if T = TypeUnion(_)
 [âŸ¨TypeModalState(modal_ref, S), v_sâŸ© | v = âŸ¨S, v_sâŸ©]    if T = ModalRefType(modal_ref) âˆ§ ModalDeclOf(modal_ref) = M
 [âŸ¨T_i, v_iâŸ© | âŸ¨f_i, T_iâŸ© âˆˆ ModalPayload(modal_ref, S), FieldValue(v, f_i) = v_i]    if T = TypeModalState(modal_ref, S) âˆ§ ModalDeclOf(modal_ref) = M
 []    otherwise
DropList([], Ïƒ) â‡“ (ok, Ïƒ)
DropList([âŸ¨T, vâŸ©] ++ xs, Ïƒ) â‡“ (c, Ïƒ'') â‡” DropValueOut(T, v, âˆ…) â‡“ (c_1, Ïƒ') âˆ§ (c_1 = panic â‡’ c = panic âˆ§ Ïƒ'' = Ïƒ') âˆ§ (c_1 = ok â‡’ DropList(xs, Ïƒ') â‡“ (c, Ïƒ''))

**(DropAction-Moved)**
BindState(Ïƒ, b) = Moved
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropActionOut(b) â‡“ (ok, Ïƒ)

**(DropAction-Partial)**
BindState(Ïƒ, b) = PartiallyMoved(F)    Î“ âŠ¢ DropValueOut(TypeOf(b), BindingValue(Ïƒ, b), F) â‡“ (c, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropActionOut(b) â‡“ (c, Ïƒ')

**(DropAction-Valid)**
BindState(Ïƒ, b) = `Valid`    Î“ âŠ¢ DropValueOut(TypeOf(b), BindingValue(Ïƒ, b), âˆ…) â‡“ (c, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropActionOut(b) â‡“ (c, Ïƒ')

**(DropStaticAction)**
StaticAddr(path, name) = addr    ReadAddr(Ïƒ, addr) = v    Î“ âŠ¢ DropValueOut(StaticType(path, name), v, âˆ…) â‡“ (c, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (c, Ïƒ')

NonRecordFOk(T, F) â‡” RecordType(T) âˆ¨ F = âˆ…

**(DropValueOut-DropPanic)**
NonRecordFOk(T, F)    DropCall(T, v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropValueOut(T, v, F) â‡“ (panic, Ïƒ_1)

**(DropValueOut-ChildPanic)**
NonRecordFOk(T, F)    DropCall(T, v, Ïƒ) â‡“ (Val(()), Ïƒ_1)    DropList(DropChildren(T, v, F), Ïƒ_1) â‡“ (panic, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropValueOut(T, v, F) â‡“ (panic, Ïƒ_2)

**(DropValueOut-Ok)**
NonRecordFOk(T, F)    DropCall(T, v, Ïƒ) â‡“ (Val(()), Ïƒ_1)    DropList(DropChildren(T, v, F), Ïƒ_1) â‡“ (ok, Ïƒ_2)    ReleaseValue(T, v, Ïƒ_2) â‡“ Ïƒ_3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropValueOut(T, v, F) â‡“ (ok, Ïƒ_3)

**Cleanup (Small-Step).**

CleanupFlag = {ok, panic}
CleanupState = {CleanupLoop(scope, Ïƒ, c) | c âˆˆ CleanupFlag} âˆª {ExitDone(c, Ïƒ) | c âˆˆ CleanupFlag} âˆª {Abort}

**(Cleanup-Start)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ExitScope(scope, Ïƒ)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ, ok)âŸ©

**(Cleanup-Step-Drop-Ok)**
CleanupList(scope) = rest ++ [DropBinding(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropActionOut(b) â‡“ (ok, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, c)âŸ©

**(Cleanup-Step-Drop-Panic)**
CleanupList(scope) = rest ++ [DropBinding(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropActionOut(b) â‡“ (panic, Ïƒ_2)    c = ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, panic)âŸ©

**(Cleanup-Step-Drop-Abort)**
CleanupList(scope) = rest ++ [DropBinding(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropActionOut(b) â‡“ (panic, Ïƒ_2)    c = panic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨AbortâŸ©

**(Cleanup-Step-DropStatic-Ok)**
CleanupList(scope) = rest ++ [DropStatic(path, name)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (ok, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, c)âŸ©

**(Cleanup-Step-DropStatic-Panic)**
CleanupList(scope) = rest ++ [DropStatic(path, name)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (panic, Ïƒ_2)    c = ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, panic)âŸ©

**(Cleanup-Step-DropStatic-Abort)**
CleanupList(scope) = rest ++ [DropStatic(path, name)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (panic, Ïƒ_2)    c = panic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨AbortâŸ©

**(Cleanup-Step-Defer-Ok)**
CleanupList(scope) = rest ++ [DeferBlock(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ EvalSigma(b, Ïƒ_1) â‡“ (Val(v), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, c)âŸ©

**(Cleanup-Step-Defer-Panic)**
CleanupList(scope) = rest ++ [DeferBlock(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ EvalSigma(b, Ïƒ_1) â‡“ (Ctrl(Panic), Ïƒ_2)    c = ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨CleanupLoop(scope, Ïƒ_2, panic)âŸ©

**(Cleanup-Step-Defer-Abort)**
CleanupList(scope) = rest ++ [DeferBlock(b)]    Ïƒ_1 = SetCleanupList(scope, rest, Ïƒ)    Î“ âŠ¢ EvalSigma(b, Ïƒ_1) â‡“ (Ctrl(Panic), Ïƒ_2)    c = panic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨AbortâŸ©

**(Cleanup-Done)**
CleanupList(scope) = []
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CleanupLoop(scope, Ïƒ, c)âŸ© â†’ âŸ¨ExitDone(c, Ïƒ)âŸ©

**Destruction (Big-Step).**

**(Destroy-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Destroy([], Ïƒ) â‡“ Ïƒ

**(Destroy-Cons)**
Î“ âŠ¢ DropAction(b) â‡“ Ïƒ_1    Î“ âŠ¢ Destroy(bs, Ïƒ_1) â‡“ Ïƒ_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Destroy(b::bs, Ïƒ) â‡“ Ïƒ_2

**Cleanup (Big-Step).**

CleanupJudg_Dyn = {Cleanup(cs, Ïƒ) â‡“ (c, Ïƒ')}

**(Cleanup-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup([], Ïƒ) â‡“ (ok, Ïƒ)

**(Cleanup-Cons-Drop)**
Î“ âŠ¢ DropActionOut(b) â‡“ (ok, Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DropBinding(b)::cs, Ïƒ) â‡“ (c, Ïƒ_2)

**(Cleanup-Cons-Drop-Panic)**
Î“ âŠ¢ DropActionOut(b) â‡“ (panic, Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DropBinding(b)::cs, Ïƒ) â‡“ (panic, Ïƒ_2)

**(Cleanup-Cons-DropStatic)**
Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (ok, Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DropStatic(path, name)::cs, Ïƒ) â‡“ (c, Ïƒ_2)

**(Cleanup-Cons-DropStatic-Panic)**
Î“ âŠ¢ DropStaticActionOut(path, name) â‡“ (panic, Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DropStatic(path, name)::cs, Ïƒ) â‡“ (panic, Ïƒ_2)

**(Cleanup-Cons-Defer-Ok)**
Î“ âŠ¢ EvalSigma(b, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DeferBlock(b)::cs, Ïƒ) â‡“ (c, Ïƒ_2)

**(Cleanup-Cons-Defer-Panic)**
Î“ âŠ¢ EvalSigma(b, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)    Î“ âŠ¢ Cleanup(cs, Ïƒ_1) â‡“ (c, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ Cleanup(DeferBlock(b)::cs, Ïƒ) â‡“ (panic, Ïƒ_2)

**Cleanup Scope (Big-Step).**

CleanupScopeJudg = {CleanupScope(scope, Ïƒ) â‡“ (c, Ïƒ')}

**(CleanupScope-From-SmallStep)**
âŸ¨ExitScope(scope, Ïƒ)âŸ© â†’* âŸ¨ExitDone(c, Ïƒ')âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CleanupScope(scope, Ïƒ) â‡“ (c, Ïƒ')

**Unwinding.**

**(Unwind-Step)**
Î“ âŠ¢ CleanupScope(f_1.scope, Ïƒ) â‡“ (ok, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Unwind(f_1::fs, Ïƒ)âŸ© â†’ âŸ¨Unwind(fs, Ïƒ')âŸ©

**(Unwind-Abort)**
Î“ âŠ¢ CleanupScope(f_1.scope, Ïƒ) â‡“ (panic, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Unwind(f_1::fs, Ïƒ)âŸ© â†’ âŸ¨AbortâŸ©

**Region, Frame, and Allocation Semantics (Cursive0).**

**Dynamic Scope Stack.**

ScopeEntry = âŸ¨scope_id, cleanup, names, vals, statesâŸ©
ScopeId(âŸ¨sid, cleanup, names, vals, statesâŸ©) = sid
ScopeCleanup(âŸ¨sid, cleanup, names, vals, statesâŸ©) = cleanup
ScopeNames(âŸ¨sid, cleanup, names, vals, statesâŸ©) = names
ScopeVals(âŸ¨sid, cleanup, names, vals, statesâŸ©) = vals
ScopeStates(âŸ¨sid, cleanup, names, vals, statesâŸ©) = states
ScopeStack(Ïƒ) âˆˆ [ScopeEntry]
CurrentScope(Ïƒ) = scope â‡” ScopeStack(Ïƒ) = scope :: ss
CurrentScopeId(Ïƒ) = ScopeId(CurrentScope(Ïƒ))
ScopeEmpty(sid) = âŸ¨sid, [], âˆ…, âˆ…, âˆ…âŸ©
FreshScopeId(Ïƒ) = sid â‡’ âˆ€ s âˆˆ ScopeStack(Ïƒ). ScopeId(s) â‰  sid
UpdateScopeStack(Ïƒ, ss) = Ïƒ' â‡” ScopeStack(Ïƒ') = ss âˆ§ AddrTags(Ïƒ') = AddrTags(Ïƒ) âˆ§ RegionStack(Ïƒ') = RegionStack(Ïƒ) âˆ§ RegionArena(Ïƒ') = RegionArena(Ïƒ) âˆ§ PoisonedModules(Ïƒ') = PoisonedModules(Ïƒ)
PushScope_Ïƒ(Ïƒ) â‡“ (Ïƒ', scope) â‡” scope = ScopeEmpty(sid) âˆ§ FreshScopeId(Ïƒ) = sid âˆ§ UpdateScopeStack(Ïƒ, scope :: ScopeStack(Ïƒ)) = Ïƒ'
PopScope_Ïƒ(Ïƒ) â‡“ (Ïƒ', scope) â‡” ScopeStack(Ïƒ) = scope :: ss âˆ§ UpdateScopeStack(Ïƒ, ss) = Ïƒ'
AppendCleanup(Ïƒ, item) â‡“ Ïƒ' â‡” ScopeStack(Ïƒ) = scope :: ss âˆ§ scope = âŸ¨sid, cleanup, names, vals, statesâŸ© âˆ§ scope' = âŸ¨sid, cleanup ++ [item], names, vals, statesâŸ© âˆ§ UpdateScopeStack(Ïƒ, scope' :: ss) = Ïƒ'
CleanupList(scope) = ScopeCleanup(scope)
ScopeById([], sid) = âŠ¥
ScopeById(scope :: ss, sid) =
 scope                 if ScopeId(scope) = sid
 ScopeById(ss, sid)    otherwise
ReplaceScopeById([], sid, scope') = âŠ¥
ReplaceScopeById(scope :: ss, sid, scope') =
 scope' :: ss                                if ScopeId(scope) = sid
 scope :: ReplaceScopeById(ss, sid, scope')  otherwise
SetCleanupList(scope, xs, Ïƒ) â‡“ Ïƒ' â‡” sid = ScopeId(scope) âˆ§ scope' = âŸ¨sid, xs, ScopeNames(scope), ScopeVals(scope), ScopeStates(scope)âŸ© âˆ§ ReplaceScopeById(ScopeStack(Ïƒ), sid, scope') = ss' âˆ§ UpdateScopeStack(Ïƒ, ss') = Ïƒ'

**Poisoned Modules.**

PoisonedModule(Ïƒ, path) â‡” âˆƒ m. PathOfModule(m) = path âˆ§ ReadAddr(Ïƒ, AddrOfSym(PoisonFlag(m))) â‰  0
PoisonedModules(Ïƒ) = {path | PoisonedModule(Ïƒ, path)}

**Dynamic Value Environment.**

Binding = âŸ¨scope_id, bind_id, nameâŸ©
BindingValue = Value âˆª {Alias(addr) | addr âˆˆ Addr}
FreshBindId(Ïƒ) = b â‡’ âˆ€ x. ScopeNames(CurrentScope(Ïƒ))[x] defined â‡’ b âˆ‰ ScopeNames(CurrentScope(Ïƒ))[x]
Last([a]) = a
Last(a::as) = Last(as)    (|as| > 0)
NearestScope([], x) = âŠ¥
NearestScope(scope :: ss, x) =
 scope                  if ScopeNames(scope)[x] defined
 NearestScope(ss, x)    otherwise
LookupBind(Ïƒ, x) = âŸ¨ScopeId(scope), b, xâŸ© â‡” NearestScope(ScopeStack(Ïƒ), x) = scope âˆ§ b = Last(ScopeNames(scope)[x])
BindingValue(Ïƒ, âŸ¨sid, bind_id, xâŸ©) = v â‡” ScopeById(ScopeStack(Ïƒ), sid) = scope âˆ§ ScopeVals(scope)[bind_id] = v
BindState(Ïƒ, âŸ¨sid, bind_id, xâŸ©) = s â‡” ScopeById(ScopeStack(Ïƒ), sid) = scope âˆ§ ScopeStates(scope)[bind_id] = s

**(LookupVal-Bind-Value)**
LookupBind(Ïƒ, x) = b    BindingValue(Ïƒ, b) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupVal(Ïƒ, x) = v

**(LookupVal-Bind-Alias)**
LookupBind(Ïƒ, x) = b    BindingValue(Ïƒ, b) = Alias(addr)    ReadAddr(Ïƒ, addr) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupVal(Ïƒ, x) = v

**(LookupVal-Path)**
LookupBind(Ïƒ, x) undefined    Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    Â¬ PoisonedModule(Ïƒ, PathOfModule(mp))    LookupValPath(Ïƒ, PathOfModule(mp), name) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupVal(Ïƒ, x) = v

**(LookupVal-RecordCtor)**
LookupBind(Ïƒ, x) undefined    Î“ âŠ¢ ResolveValueName(x) â‡‘    Î“ âŠ¢ ResolveTypeName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    Â¬ PoisonedModule(Ïƒ, PathOfModule(mp))    RecordDecl(FullPath(PathOfModule(mp), name)) = R
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupVal(Ïƒ, x) = RecordCtor(FullPath(PathOfModule(mp), name))

**(LookupValPath-Builtin)**
BuiltinValuePath(path, name)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupValPath(Ïƒ, path, name) = ProcRef(path, name)

**(LookupValPath-Static)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent    ent.origin_opt = mp    path' = PathOfModule(mp)    name' = (ent.target_opt if present, else name)    Â¬ PoisonedModule(Ïƒ, path')    StaticAddr(path', name') = addr    ReadAddr(Ïƒ, addr) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupValPath(Ïƒ, path, name) = v

**(LookupValPath-Proc)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent    ent.origin_opt = mp    path' = PathOfModule(mp)    name' = (ent.target_opt if present, else name)    Â¬ PoisonedModule(Ïƒ, path')    DeclOf(path', name') = proc
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupValPath(Ïƒ, path, name) = ProcRef(proc)

**(LookupValPath-RecordCtor)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡‘    Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p    SplitLast(p) = (mp, _)    Â¬ PoisonedModule(Ïƒ, mp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
LookupValPath(Ïƒ, path, name) = RecordCtor(p)

LookupBind(Ïƒ, x) undefined â‡’ IllFormed(LookupBind(Ïƒ, x))
LookupVal(Ïƒ, x) undefined â‡’ IllFormed(LookupVal(Ïƒ, x))

ScopeValsUpdate(âŸ¨sid, cleanup, names, vals, statesâŸ©, bind_id, v) = âŸ¨sid, cleanup, names, vals[bind_id â†¦ v], statesâŸ©
ScopeStatesUpdate(âŸ¨sid, cleanup, names, vals, statesâŸ©, bind_id, s) = âŸ¨sid, cleanup, names, vals, states[bind_id â†¦ s]âŸ©

UpdateVal(Ïƒ, âŸ¨sid, bind_id, xâŸ©, v) â‡“ Ïƒ' â‡” (BindingValue(Ïƒ, âŸ¨sid, bind_id, xâŸ©) = Alias(addr) âˆ§ WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ') âˆ¨ (BindingValue(Ïƒ, âŸ¨sid, bind_id, xâŸ©) â‰  Alias(_) âˆ§ ScopeById(ScopeStack(Ïƒ), sid) = scope âˆ§ scope' = ScopeValsUpdate(scope, bind_id, v) âˆ§ ReplaceScopeById(ScopeStack(Ïƒ), sid, scope') = ss' âˆ§ UpdateScopeStack(Ïƒ, ss') = Ïƒ')
SetState(Ïƒ, âŸ¨sid, bind_id, xâŸ©, s) â‡“ Ïƒ' â‡” ScopeById(ScopeStack(Ïƒ), sid) = scope âˆ§ scope' = ScopeStatesUpdate(scope, bind_id, s) âˆ§ ReplaceScopeById(ScopeStack(Ïƒ), sid, scope') = ss' âˆ§ UpdateScopeStack(Ïƒ, ss') = Ïƒ'

TypeOf(âŸ¨sid, bind_id, xâŸ©) = TypeOf(x)
BindInfo(âŸ¨sid, bind_id, xâŸ©) = BindInfo(x)

BindVal(Ïƒ, x, v) â‡“ (Ïƒ', b) â‡” ScopeStack(Ïƒ) = scope :: ss âˆ§ scope = âŸ¨sid, cleanup, names, vals, statesâŸ© âˆ§ bind_id = FreshBindId(Ïƒ) âˆ§ names' = names[x â†¦ (names[x] if present else []) ++ [bind_id]] âˆ§ vals' = vals[bind_id â†¦ v] âˆ§ states' = states[bind_id â†¦ `Valid`] âˆ§ scope' = âŸ¨sid, cleanup, names', vals', states'âŸ© âˆ§ UpdateScopeStack(Ïƒ, scope' :: ss) = Ïƒ_1 âˆ§ b = âŸ¨sid, bind_id, xâŸ© âˆ§ ((BindInfo(b).resp = resp âˆ§ AppendCleanup(Ïƒ_1, DropBinding(b)) â‡“ Ïƒ') âˆ¨ (BindInfo(b).resp â‰  resp âˆ§ Ïƒ' = Ïƒ_1))

BindPatternVal(p, v) â‡“ B â‡” Î“ âŠ¢ MatchPattern(p, v) â‡“ B
BindOrder(p, B) = [âŸ¨x, B[x]âŸ© | x âˆˆ PatNames(p)]

**(BindList-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BindList(Ïƒ, []) â‡“ (Ïƒ, [])

**(BindList-Cons)**
BindVal(Ïƒ, x, v) â‡“ (Ïƒ_1, b)    BindList(Ïƒ_1, xs) â‡“ (Ïƒ_2, bs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BindList(Ïƒ, [âŸ¨x, vâŸ©] ++ xs) â‡“ (Ïƒ_2, b::bs)

BindPattern(Ïƒ, p, v) â‡“ (Ïƒ', bs) â‡” BindPatternVal(p, v) â‡“ B âˆ§ BindOrder(p, B) = binds âˆ§ BindList(Ïƒ, binds) â‡“ (Ïƒ', bs)

**Runtime Region Stack.**

RegionEntry = âŸ¨tag, target, scope, mark_optâŸ©
RegionTagOf(âŸ¨tag, target, scope, mark_optâŸ©) = tag
RegionTargetOf(âŸ¨tag, target, scope, mark_optâŸ©) = target
RegionScopeOf(âŸ¨tag, target, scope, mark_optâŸ©) = scope
RegionMarkOf(âŸ¨tag, target, scope, mark_optâŸ©) = mark_opt
RuntimeTag = {RegionTag(tag), ScopeTag(sid)}
RegionStack(Ïƒ) âˆˆ [RegionEntry]
AddrTags(Ïƒ) : Addr â‡€ RuntimeTag

**Region Arenas.**

RegionArena(Ïƒ) : usize â‡€ [Addr]
ArenaAllocs(Ïƒ, r) = allocs â‡” RegionArena(Ïƒ)(r) = allocs
UpdateRegionArena(Ïƒ, RA) = Ïƒ' â‡” RegionArena(Ïƒ') = RA âˆ§ ScopeStack(Ïƒ') = ScopeStack(Ïƒ) âˆ§ AddrTags(Ïƒ') = AddrTags(Ïƒ) âˆ§ RegionStack(Ïƒ') = RegionStack(Ïƒ) âˆ§ PoisonedModules(Ïƒ') = PoisonedModules(Ïƒ)
ArenaNew(Ïƒ, r) â‡“ Ïƒ' â‡” UpdateRegionArena(Ïƒ, RegionArena(Ïƒ)[r â†¦ []]) = Ïƒ'

FreshAddr(Ïƒ) = addr â‡’ ReadAddr(Ïƒ, addr) undefined âˆ§ AddrTags(Ïƒ)(addr) undefined
Prefix([a_0, â€¦, a_{n-1}], m) = [a_0, â€¦, a_{m-1}]    (0 â‰¤ m â‰¤ n)

ArenaAppend(Ïƒ, r, addr) â‡“ Ïƒ' â‡” ArenaAllocs(Ïƒ, r) = allocs âˆ§ UpdateRegionArena(Ïƒ, RegionArena(Ïƒ)[r â†¦ allocs ++ [addr]]) = Ïƒ'
ArenaMark(Ïƒ, r) = m â‡” ArenaAllocs(Ïƒ, r) = allocs âˆ§ m = |allocs|
ArenaResetTo(Ïƒ, r, m) â‡“ Ïƒ' â‡” ArenaAllocs(Ïƒ, r) = allocs âˆ§ 0 â‰¤ m â‰¤ |allocs| âˆ§ allocs' = Prefix(allocs, m) âˆ§ UpdateRegionArena(Ïƒ, RegionArena(Ïƒ)[r â†¦ allocs']) = Ïƒ'
ArenaClear(Ïƒ, r) â‡“ Ïƒ' â‡” ArenaResetTo(Ïƒ, r, 0) â‡“ Ïƒ'
ArenaRemove(Ïƒ, r) â‡“ Ïƒ' â‡” RegionArena(Ïƒ') = RegionArena(Ïƒ) \ {r} âˆ§ ScopeStack(Ïƒ') = ScopeStack(Ïƒ) âˆ§ AddrTags(Ïƒ') = AddrTags(Ïƒ) âˆ§ RegionStack(Ïƒ') = RegionStack(Ïƒ) âˆ§ PoisonedModules(Ïƒ') = PoisonedModules(Ïƒ)

**Region Values.**

RegionValue(S, h) = RecordValue(ModalStateRef([`Region`], S), [âŸ¨`handle`, IntVal("usize", h)âŸ©])
RegionHandleOf(v) = h â‡” v = RecordValue(ModalStateRef([`Region`], S), fs) âˆ§ âŸ¨`handle`, IntVal("usize", h)âŸ© âˆˆ fs
RegionHandleOf(v) undefined â‡’ IllFormed(RegionHandleOf(v))

ResolveEntry([], r) = âŠ¥
ResolveEntry(e::es, r) =
 e                     if RegionTargetOf(e) = r
 ResolveEntry(es, r)   otherwise
ActiveEntry(Ïƒ) = e â‡” RegionStack(Ïƒ) = e :: es
ActiveTarget(Ïƒ) = target â‡” ActiveEntry(Ïƒ) = e âˆ§ RegionTargetOf(e) = target
ResolveTarget(Ïƒ, r) = target â‡” ResolveEntry(RegionStack(Ïƒ), r) = e âˆ§ RegionTargetOf(e) = target
ResolveTag(Ïƒ, r) = tag â‡” ResolveEntry(RegionStack(Ïƒ), r) = e âˆ§ RegionTagOf(e) = tag
FreshTag(Ïƒ) = tag â‡’ âˆ€ e âˆˆ RegionStack(Ïƒ). RegionTagOf(e) â‰  tag
FreshArena(Ïƒ) = r â‡’ âˆ€ e âˆˆ RegionStack(Ïƒ). RegionTargetOf(e) â‰  r

ActiveTarget(Ïƒ) undefined â‡’ IllFormed(ActiveTarget(Ïƒ))
ResolveTarget(Ïƒ, r) undefined â‡’ IllFormed(ResolveTarget(Ïƒ, r))

UpdateRegionStack(Ïƒ, rs) = Ïƒ' â‡” RegionStack(Ïƒ') = rs âˆ§ ScopeStack(Ïƒ') = ScopeStack(Ïƒ) âˆ§ AddrTags(Ïƒ') = AddrTags(Ïƒ) âˆ§ RegionArena(Ïƒ') = RegionArena(Ïƒ) âˆ§ PoisonedModules(Ïƒ') = PoisonedModules(Ïƒ)

RegionNew(Ïƒ, opts) â‡“ (Ïƒ', r, scope) â‡” PushScope_Ïƒ(Ïƒ) â‡“ (Ïƒ_1, scope) âˆ§ FreshArena(Ïƒ) = r âˆ§ ArenaNew(Ïƒ_1, r) â‡“ Ïƒ_2 âˆ§ UpdateRegionStack(Ïƒ_2, âŸ¨r, r, scope, âŠ¥âŸ© :: RegionStack(Ïƒ_2)) = Ïƒ'

RegionOpen(Ïƒ, opts) â‡“ (Ïƒ', r) â‡” FreshArena(Ïƒ) = r âˆ§ ArenaNew(Ïƒ, r) â‡“ Ïƒ_1 âˆ§ UpdateRegionStack(Ïƒ_1, âŸ¨r, r, CurrentScopeId(Ïƒ), âŠ¥âŸ© :: RegionStack(Ïƒ_1)) = Ïƒ'

FrameEnter(Ïƒ, r) â‡“ (Ïƒ', F, scope, mark) â‡” PushScope_Ïƒ(Ïƒ) â‡“ (Ïƒ_1, scope) âˆ§ F = FreshTag(Ïƒ) âˆ§ mark = FrameMark(Ïƒ_1, r) âˆ§ UpdateRegionStack(Ïƒ_1, âŸ¨F, r, scope, markâŸ© :: RegionStack(Ïƒ_1)) = Ïƒ'

BindRegionAlias(Ïƒ, âŠ¥, r) â‡“ Ïƒ
BindRegionAlias(Ïƒ, x, r) â‡“ Ïƒ' â‡” BindVal(Ïƒ, x, RegionValue(`@Active`, r)) â‡“ (Ïƒ', b)

TagAddr(Ïƒ, addr, tag) â‡“ Ïƒ' â‡” AddrTags(Ïƒ') = AddrTags(Ïƒ)[addr â†¦ tag] âˆ§ ScopeStack(Ïƒ') = ScopeStack(Ïƒ) âˆ§ RegionStack(Ïƒ') = RegionStack(Ïƒ) âˆ§ RegionArena(Ïƒ') = RegionArena(Ïƒ) âˆ§ PoisonedModules(Ïƒ') = PoisonedModules(Ïƒ)
TagAddrFrom(Ïƒ, base, addr) â‡“ Ïƒ' â‡” (AddrTag(Ïƒ, base) = tag âˆ§ TagAddr(Ïƒ, addr, tag) â‡“ Ïƒ') âˆ¨ (AddrTag(Ïƒ, base) = âŠ¥ âˆ§ Ïƒ' = Ïƒ)

RegionAlloc(Ïƒ, r, v) â‡“ (Ïƒ', v') â‡” ResolveTag(Ïƒ, r) = tag âˆ§ FreshAddr(Ïƒ) = addr âˆ§ WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ_1 âˆ§ ArenaAppend(Ïƒ_1, r, addr) â‡“ Ïƒ_2 âˆ§ TagAddr(Ïƒ_2, addr, RegionTag(tag)) â‡“ Ïƒ' âˆ§ ReadAddr(Ïƒ', addr) = v'

FreshTags(Ïƒ, tags) â‡” Distinct(tags) âˆ§ âˆ€ tag âˆˆ Set(tags). âˆ€ e âˆˆ RegionStack(Ïƒ). RegionTagOf(e) â‰  tag

RetagRegions([], r, tags) = [] â‡” tags = []
RetagRegions(e::es, r, tags) =
 e' :: RetagRegions(es, r, tags')    if RegionTargetOf(e) = r âˆ§ tags = tag :: tags' âˆ§ e' = âŸ¨tag, RegionTargetOf(e), RegionScopeOf(e), RegionMarkOf(e)âŸ©
 e :: RetagRegions(es, r, tags)      otherwise

RegionReset(Ïƒ, r) â‡“ Ïƒ' â‡” ArenaClear(Ïƒ, r) â‡“ Ïƒ_1 âˆ§ FreshTags(Ïƒ_1, tags) âˆ§ RetagRegions(RegionStack(Ïƒ_1), r, tags) = rs' âˆ§ UpdateRegionStack(Ïƒ_1, rs') = Ïƒ'

PopRegions([], r) = []
PopRegions(e::es, r) =
 PopRegions(es, r)    if RegionTargetOf(e) = r
 e :: PopRegions(es, r)    otherwise
RegionFree(Ïƒ, r) â‡“ Ïƒ' â‡” ArenaRemove(Ïƒ, r) â‡“ Ïƒ_1 âˆ§ PopRegions(RegionStack(Ïƒ_1), r) = rs' âˆ§ UpdateRegionStack(Ïƒ_1, rs') = Ïƒ'

**Region Deallocation Order.**
RegionRelease and FrameReset MUST execute CleanupScope before any ArenaResetTo or ArenaRemove.
ArenaResetTo, ArenaClear, and ArenaRemove MUST NOT invoke Drop; they only reclaim arena storage.

**Region Procedures.**

RegionProcJudg = {RegionNewScoped(Ïƒ, opts) â‡“ (Ïƒ', v), RegionAllocProc(Ïƒ, v_r, v) â‡“ (Ïƒ', v'), RegionResetProc(Ïƒ, v_r) â‡“ (Ïƒ', v'), RegionFreezeProc(Ïƒ, v_r) â‡“ (Ïƒ', v'), RegionThawProc(Ïƒ, v_r) â‡“ (Ïƒ', v'), RegionFreeProc(Ïƒ, v_r) â‡“ (Ïƒ', v')}

**(Region-New-Scoped)**
RegionOpen(Ïƒ, opts) â‡“ (Ïƒ', r)    v = RegionValue(`@Active`, r)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionNewScoped(Ïƒ, opts) â‡“ (Ïƒ', v)

**(Region-Alloc-Proc)**
RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ, h) = r_t    RegionAlloc(Ïƒ, r_t, v) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionAllocProc(Ïƒ, v_r, v) â‡“ (Ïƒ', v')

**(Region-Reset-Proc)**
RegionHandleOf(v_r) = h    RegionReset(Ïƒ, h) â‡“ Ïƒ'    v' = RegionValue(`@Active`, h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionResetProc(Ïƒ, v_r) â‡“ (Ïƒ', v')

**(Region-Freeze-Proc)**
RegionHandleOf(v_r) = h    v' = RegionValue(`@Frozen`, h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionFreezeProc(Ïƒ, v_r) â‡“ (Ïƒ, v')

**(Region-Thaw-Proc)**
RegionHandleOf(v_r) = h    v' = RegionValue(`@Active`, h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionThawProc(Ïƒ, v_r) â‡“ (Ïƒ, v')

**(Region-Free-Proc)**
RegionHandleOf(v_r) = h    RegionFree(Ïƒ, h) â‡“ Ïƒ'    v' = RegionValue(`@Freed`, h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RegionFreeProc(Ïƒ, v_r) â‡“ (Ïƒ', v')

PopRegionScope([], scope) = âŠ¥
PopRegionScope(e::es, scope) =
 es                          if RegionScopeOf(e) = scope
 PopRegionScope(es, scope)   otherwise
ReleaseArena(Ïƒ, r) â‡“ Ïƒ' â‡” RegionFree(Ïƒ, r) â‡“ Ïƒ'
ResetArena(Ïƒ, r, scope, mark) â‡“ Ïƒ' â‡” ArenaResetTo(Ïƒ, r, mark) â‡“ Ïƒ_1 âˆ§ PopRegionScope(RegionStack(Ïƒ_1), scope) = rs' âˆ§ UpdateRegionStack(Ïƒ_1, rs') = Ïƒ'

FrameMark(Ïƒ, r) = ArenaMark(Ïƒ, r)

**Control Outcomes.**

Ctrl = {Return(v), Result(v), Break(v_opt), Continue, Panic, Abort}
StmtOut = {ok} âˆª {Ctrl(Îº) | Îº âˆˆ Ctrl}
Outcome = {Val(v)} âˆª {Ctrl(Îº) | Îº âˆˆ Ctrl}
StmtOutOf(Val(v)) = ok
StmtOutOf(Ctrl(Îº)) = Ctrl(Îº)
BreakVal(âŠ¥) = ()
BreakVal(v) = v

**Block Evaluation Helpers.**

BlockEnter(Ïƒ, binds) â‡“ (Ïƒ', scope) â‡” PushScope_Ïƒ(Ïƒ) â‡“ (Ïƒ_1, scope) âˆ§ âˆƒ bs. BindList(Ïƒ_1, binds) â‡“ (Ïƒ', bs)

ExitOutcome(out, ok) = out
ExitOutcome(Ctrl(Abort), c) = Ctrl(Abort)
ExitOutcome(Ctrl(Panic), panic) = Ctrl(Abort)
ExitOutcome(out, panic) = Ctrl(Panic)    (out â‰  Ctrl(Panic) âˆ§ out â‰  Ctrl(Abort))

BlockExit(Ïƒ, scope, out) â‡“ (out', Ïƒ') â‡” Î“ âŠ¢ CleanupScope(scope, Ïƒ) â‡“ (c, Ïƒ_1) âˆ§ out' = ExitOutcome(out, c) âˆ§ ((out' = Ctrl(Abort) âˆ§ Ïƒ' = Ïƒ_1) âˆ¨ (out' â‰  Ctrl(Abort) âˆ§ PopScope_Ïƒ(Ïƒ_1) â‡“ (Ïƒ', scope)))

EvalBlockBodySigma(BlockExpr(stmts, tail_opt), Ïƒ) â‡“ (out, Ïƒ') â‡” Î“ âŠ¢ ExecSeqSigma(stmts, Ïƒ) â‡“ (sout, Ïƒ_1) âˆ§ (
 (sout = ok âˆ§ tail_opt = e âˆ§ Î“ âŠ¢ EvalSigma(e, Ïƒ_1) â‡“ (out, Ïƒ')) âˆ¨
 (sout = ok âˆ§ tail_opt = âŠ¥ âˆ§ out = Val(()) âˆ§ Ïƒ' = Ïƒ_1) âˆ¨
 (sout = Ctrl(Result(v)) âˆ§ out = Val(v) âˆ§ Ïƒ' = Ïƒ_1) âˆ¨
 (sout = Ctrl(Îº) âˆ§ Îº â‰  Result(_) âˆ§ out = Ctrl(Îº) âˆ§ Ïƒ' = Ïƒ_1)
)

EvalBlockSigma(b, Ïƒ) â‡“ (out', Ïƒ'') â‡” BlockEnter(Ïƒ, []) â‡“ (Ïƒ_1, scope) âˆ§ EvalBlockBodySigma(b, Ïƒ_1) â‡“ (out, Ïƒ_2) âˆ§ BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ'')

EvalBlockBindSigma(p, v, b, Ïƒ) â‡“ (out', Ïƒ'') â‡” BindPatternVal(p, v) â‡“ B âˆ§ BindOrder(p, B) = binds âˆ§ BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope) âˆ§ EvalBlockBodySigma(b, Ïƒ_1) â‡“ (out, Ïƒ_2) âˆ§ BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ'')

EvalInScopeSigma(b, Ïƒ, scope) â‡“ (out, Ïƒ') â‡” CurrentScopeId(Ïƒ) = scope âˆ§ EvalBlockBodySigma(b, Ïƒ) â‡“ (out, Ïƒ')

**Place Evaluation Helpers.**

**PlaceJudg.**
PlaceJudg = {Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ WritePlaceSigma(p, v, Ïƒ) â‡“ (sout, Ïƒ'), Î“ âŠ¢ WritePlaceSubSigma(p, v, Ïƒ) â‡“ (sout, Ïƒ'), Î“ âŠ¢ MovePlaceSigma(p, Ïƒ) â‡“ (out, Ïƒ')}

DropOnAssign(b) â‡” BindInfo(b).mov = immov âˆ§ BindInfo(b).resp = resp

DropOnAssignStatic(path, name) â‡” StaticBindInfo(path, name).mov = immov âˆ§ StaticBindInfo(path, name).resp = resp

RootBinding(Sigma, p) =
 Local(b)    if LookupBind(Sigma, PlaceRoot(p)) = b
 Static(path, name)    if LookupBind(Sigma, PlaceRoot(p)) undefined âˆ§ Î“ âŠ¢ ResolveValueName(PlaceRoot(p)) â‡“ ent âˆ§ ent.origin_opt = mp âˆ§ name = (ent.target_opt if present, else PlaceRoot(p)) âˆ§ path = PathOfModule(mp)

DropOnAssignRoot(Sigma, p) â‡” (RootBinding(Sigma, p) = Local(b) âˆ§ DropOnAssign(b)) âˆ¨ (RootBinding(Sigma, p) = Static(path, name) âˆ§ DropOnAssignStatic(path, name))

RootMoved(Sigma, p) â‡” RootBinding(Sigma, p) = Local(b) âˆ§ BindState(Sigma, b) = Moved

**DropSubvalueJudg.**
DropSubvalueJudg = {Î“ âŠ¢ DropSubvalue(p, T, v, Ïƒ) â‡“ Ïƒ'}

**(DropSubvalue-Do)**
DropOnAssignRoot(Sigma, p)    Â¬ RootMoved(Sigma, p)    Î“ âŠ¢ DropValue(T, v, âˆ…) â‡“ Sigma'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropSubvalue(p, T, v, Sigma) â‡“ Sigma'

**(DropSubvalue-Skip)**
Â¬ DropOnAssignRoot(Sigma, p) âˆ¨ RootMoved(Sigma, p)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ DropSubvalue(p, T, v, Sigma) â‡“ Sigma


**(ReadPlace-Ident)**
LookupVal(Ïƒ, x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(Identifier(x), Ïƒ) â‡“ (Val(v), Ïƒ)

**(ReadPlace-Ident-Poison)**
LookupBind(Ïƒ, x) undefined    Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(Identifier(x), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePlace-Ident)**
LookupBind(Ïƒ, x) = b    (DropOnAssign(b) â‡’ Î“ âŠ¢ DropAction(b) â‡“ Ïƒ_1)    (Â¬ DropOnAssign(b) â‡’ Ïƒ_1 = Ïƒ)    UpdateVal(Ïƒ_1, b, v) â‡“ Ïƒ_2    SetState(Ïƒ_2, b, `Valid`) â‡“ Ïƒ_3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(Identifier(x), v, Ïƒ) â‡“ (ok, Ïƒ_3)

**(WritePlace-Ident-Path-Poison)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(Identifier(x), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePlace-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticAddr(path, name) = addr    (DropOnAssignStatic(path, name) â‡’ Î“ âŠ¢ DropStaticAction(path, name) â‡“ Ïƒ_1)    (Â¬ DropOnAssignStatic(path, name) â‡’ Ïƒ_1 = Ïƒ)    WriteAddr(Ïƒ_1, addr, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(Identifier(x), v, Ïƒ) â‡“ (ok, Ïƒ')

TupleValue((v_0, â€¦, v_{n-1}), i) = v_i    (0 â‰¤ i < n)
TupleUpdate((v_0, â€¦, v_{n-1}), i, v') = (v_0, â€¦, v_{i-1}, v', v_{i+1}, â€¦, v_{n-1})    (0 â‰¤ i < n)
FieldValue(RecordValue(tr, fs), f) = v â‡” âŸ¨f, vâŸ© âˆˆ fs
FieldUpdate(RecordValue(tr, fs), f, v') = RecordValue(tr, fs')    where fs' = [âŸ¨f_i, v_i'âŸ© | âŸ¨f_i, v_iâŸ© âˆˆ fs âˆ§ v_i' = v' if f_i = f otherwise v_i]

Len([v_0, â€¦, v_{n-1}]) = n
Len(SliceValue(v, r)) = end - start    (SliceBounds(r, Len(v)) = (start, end))
IndexNum(v) = i â‡” v = IntVal("usize", i)
IndexValue([v_0, â€¦, v_{n-1}], i) = v_i    (0 â‰¤ i < n)
IndexValue(SliceValue(v, r), i) = IndexValue(v, start + i)    (SliceBounds(r, Len(v)) = (start, end) âˆ§ 0 â‰¤ i < end - start)
IndexValue(v, v_i) = v_e â‡” IndexNum(v_i) = i âˆ§ IndexValue(v, i) = v_e
IndexUpdate([v_0, â€¦, v_{n-1}], i, v_e) = [v_0, â€¦, v_{i-1}, v_e, v_{i+1}, â€¦, v_{n-1}]    (0 â‰¤ i < n)
IndexUpdate(SliceValue(v_b, r), i, v_e) = SliceValue(v_b', r)    (SliceBounds(r, Len(v_b)) = (start, end) âˆ§ 0 â‰¤ i < end - start âˆ§ IndexUpdate(v_b, start + i, v_e) = v_b')
IndexUpdate(v, v_i, v_e) = v' â‡” IndexNum(v_i) = i âˆ§ IndexUpdate(v, i, v_e) = v'
SliceValue(v, r) defined â‡” SliceBounds(r, Len(v)) defined
SliceLen([v_0, â€¦, v_{n-1}]) = n
SliceLen(SliceValue(v, r)) = end - start    (SliceBounds(r, Len(v)) = (start, end))
SliceElem(v, i) = IndexValue(v, i)    (IndexValue(v, i) defined)
SliceUpdate(v, start, v_rhs) â‡“ v' â‡” n = SliceLen(v_rhs) âˆ§ âˆƒ v_0, â€¦, v_n. v_0 = v âˆ§ âˆ€ i âˆˆ [0, n-1]. v_{i+1} = IndexUpdate(v_i, start + i, SliceElem(v_rhs, i)) âˆ§ v' = v_n

**PtrAddrJudg.**
PtrAddrJudg = {Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (sout, Ïƒ'), Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (out, Ïƒ')}

AddrPrimJudg = {ReadAddr(Ïƒ, addr) = v, WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ', FieldAddr(T, addr, f) = addr', TupleAddr(T, addr, i) = addr', IndexAddr(T_b, addr, i) = addr'}
IndexLen(Sigma, addr) = Len(v)    (ReadAddr(Sigma, addr) = v âˆ§ Len(v) defined)
IndexAddr(T_b, addr, i) = AddrAdd(addr, i Ã— sizeof(ElemType(T_b)))    (ElemType(T_b) defined)
IndexAddr(T_b, addr, v_i) = addr' â‡” IndexNum(v_i) = i âˆ§ IndexAddr(T_b, addr, i) = addr'
SliceLenFromAddr(Ïƒ, addr) = n â‡” ReadAddr(Ïƒ, addr) = v âˆ§ SliceLen(v) = n

PtrStateSet = {`Valid`, `Null`, `Expired`}
RawQual = {`imm`, `mut`}
PtrAddr(Ptr@Valid(addr)) = addr
PtrAddr(Ptr@Null(addr)) = addr
PtrAddr(Ptr@Expired(addr)) = addr
PtrAddr(RawPtr(q, addr)) = addr

AddrTag(Sigma, addr) =
 ScopeTag(sid)    if addr = BindAddr(âŸ¨sid, bind_id, xâŸ©)
 RegionTag(tag)   if AddrTags(Sigma)(addr) = RegionTag(tag)
 âŠ¥                otherwise
TagActive(Sigma, RegionTag(tag)) â‡” âˆƒ e âˆˆ RegionStack(Sigma). RegionTagOf(e) = tag
TagActive(Sigma, ScopeTag(sid)) â‡” âˆƒ e âˆˆ ScopeStack(Sigma). ScopeId(e) = sid
PtrState(Sigma, Ptr@Null(_)) = `Null`
PtrState(Sigma, Ptr@Expired(_)) = `Expired`
PtrState(Sigma, Ptr@Valid(addr)) =
 `Valid`    if AddrTag(Sigma, addr) = âŠ¥
 `Valid`    if AddrTag(Sigma, addr) = tag â‰  âŠ¥ âˆ§ TagActive(Sigma, tag)
 `Expired`  if AddrTag(Sigma, addr) = tag â‰  âŠ¥ âˆ§ Â¬ TagActive(Sigma, tag)
DynAddrState(Sigma, addr) =
 `Valid`    if AddrTag(Sigma, addr) = âŠ¥
 `Valid`    if AddrTag(Sigma, addr) = tag â‰  âŠ¥ âˆ§ TagActive(Sigma, tag)
 `Expired`  if AddrTag(Sigma, addr) = tag â‰  âŠ¥ âˆ§ Â¬ TagActive(Sigma, tag)
BindAddr(âŸ¨sid, bind_id, xâŸ©) âˆˆ Addr
AddrOfBind(b) =
 addr         if BindingValue(Sigma, b) = Alias(addr)
 BindAddr(b)  if BindingValue(Sigma, b) â‰  Alias(_)
AddrOfBind(x) = addr â‡” âˆƒ b. LookupBind(Ïƒ, x) = b âˆ§ AddrOfBind(b) = addr

**(ReadPtr-Safe)**
PtrState(Ïƒ, v_ptr) = `Valid`    PtrAddr(v_ptr) = addr    ReadAddr(Ïƒ, addr) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (Val(v), Ïƒ)

**(WritePtr-Safe)**
PtrState(Ïƒ, v_ptr) = `Valid`    PtrAddr(v_ptr) = addr    WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (ok, Ïƒ')

**(ReadPtr-Null)**
PtrState(Ïƒ, v_ptr) = `Null`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(ReadPtr-Expired)**
PtrState(Ïƒ, v_ptr) = `Expired`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePtr-Null)**
PtrState(Ïƒ, v_ptr) = `Null`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePtr-Expired)**
PtrState(Ïƒ, v_ptr) = `Expired`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(ReadPtr-Raw)**
v_ptr = RawPtr(q, addr)    ReadAddr(Ïƒ, addr) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (Val(v), Ïƒ)

**(WritePtr-Raw)**
v_ptr = RawPtr(`mut`, addr)    WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (ok, Ïƒ')

**(ReadPtr-Raw-Invalid)**
v_ptr = RawPtr(q, addr)    ReadAddr(Ïƒ, addr) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePtr-Raw-Imm)**
v_ptr = RawPtr(`imm`, addr)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WritePtr-Raw-Invalid)**
v_ptr = RawPtr(`mut`, addr)    Â¬ âˆƒ Ïƒ'. WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)


**(AddrOf-Ident)**
LookupBind(Ïƒ, x) = b    AddrOfBind(b) = addr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Identifier(x), Ïƒ) â‡“ (Val(addr), Ïƒ)

**(AddrOf-Ident-Path-Poison)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Identifier(x), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(AddrOf-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticAddr(path, name) = addr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Identifier(x), Ïƒ) â‡“ (Val(addr), Ïƒ)

**(AddrOf-Field)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    T_b = ExprType(p)    FieldAddr(T_b, addr, f) = addr'    TagAddrFrom(Ïƒ_1, addr, addr') â‡“ Ïƒ_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(FieldAccess(p, f), Ïƒ) â‡“ (Val(addr'), Ïƒ_2)

**(AddrOf-Field-Ctrl)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(FieldAccess(p, f), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(AddrOf-Tuple)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    T_b = ExprType(p)    TupleAddr(T_b, addr, i) = addr'    TagAddrFrom(Ïƒ_1, addr, addr') â‡“ Ïƒ_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(TupleAccess(p, i), Ïƒ) â‡“ (Val(addr'), Ïƒ_2)

**(AddrOf-Tuple-Ctrl)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(TupleAccess(p, i), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(AddrOf-Index)**
**(AddrOfSigma-Index-Ok)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexLen(Ïƒ_2, addr) = L    Î“ âŠ¢ CheckIndex(L, v_i) â‡“ ok    T_b = ExprType(p)    IndexAddr(T_b, addr, v_i) = addr'    TagAddrFrom(Ïƒ_2, addr, addr') â‡“ Ïƒ_3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(IndexAccess(p, i), Ïƒ) â‡“ (Val(addr'), Ïƒ_3)

**(AddrOfSigma-Index-OOB)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    Â¬ (0 â‰¤ v_i < IndexLen(Ïƒ_2, addr))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(IndexAccess(p, i), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(AddrOf-Index-Ctrl-Base)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(IndexAccess(p, i), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(AddrOf-Index-Ctrl-Idx)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(IndexAccess(p, i), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(AddrOf-Deref-Safe)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    PtrState(Ïƒ_1, v_ptr) = `Valid`    PtrAddr(v_ptr) = addr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Deref(p), Ïƒ) â‡“ (Val(addr), Ïƒ_1)

**(AddrOf-Deref-Null)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    PtrState(Ïƒ_1, v_ptr) = `Null`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Deref(p), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)

**(AddrOf-Deref-Expired)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    PtrState(Ïƒ_1, v_ptr) = `Expired`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Deref(p), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)

**(AddrOf-Deref-Raw)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(RawPtr(q, addr)), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Deref(p), Ïƒ) â‡“ (Val(addr), Ïƒ_1)

**(AddrOf-Deref-Ctrl)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ AddrOfSigma(Deref(p), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ReadPlace-Field)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    FieldValue(v_p, f) = v_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(FieldAccess(p, f), Ïƒ) â‡“ (Val(v_f), Ïƒ_1)

**(ReadPlace-Tuple)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    TupleValue(v_p, i) = v_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(TupleAccess(p, i), Ïƒ) â‡“ (Val(v_i), Ïƒ_1)

**(ReadPlace-Index)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexValue(v_p, v_i) = v_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(IndexAccess(p, i), Ïƒ) â‡“ (Val(v_e), Ïƒ_2)

**(ReadPlace-Index-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    Â¬ (0 â‰¤ v_i < Len(v_p))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(IndexAccess(p, i), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(ReadPlace-Index-Range)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceValue(v_p, v_r) = v_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(IndexAccess(p, i), Ïƒ) â‡“ (Val(v_s), Ïƒ_2)

**(ReadPlace-Index-Range-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(IndexAccess(p, i), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(ReadPlace-Deref)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ReadPlaceSigma(Deref(p), Ïƒ) â‡“ (out, Ïƒ_2)

**(WritePlace-Field)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    FieldValue(v_p, f) = v_f    T_f = ExprType(FieldAccess(p, f))    Î“ âŠ¢ DropSubvalue(p, T_f, v_f, Ïƒ_1) â‡“ Ïƒ_1'    FieldUpdate(v_p, f, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_1') â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(FieldAccess(p, f), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(WritePlace-Tuple)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    TupleValue(v_p, i) = v_i    T_i = ExprType(TupleAccess(p, i))    Î“ âŠ¢ DropSubvalue(p, T_i, v_i, Ïƒ_1) â‡“ Ïƒ_1'    TupleUpdate(v_p, i, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_1') â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(TupleAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(WritePlace-Index)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexValue(v_p, v_i) = v_e    T_e = ExprType(IndexAccess(p, i))    Î“ âŠ¢ DropSubvalue(p, T_e, v_e, Ïƒ_2) â‡“ Ïƒ_2'    IndexUpdate(v_p, v_i, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_2') â‡“ (sout, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_3)

**(WritePlace-Index-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    Â¬ (0 â‰¤ v_i < Len(v_p))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WritePlace-Index-Range)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n = end - start    SliceUpdate(v_p, start, v) â‡“ v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_2) â‡“ (sout, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_3)

**(WritePlace-Index-Range-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WritePlace-Index-Range-Len)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n â‰  end - start
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WritePlace-Deref)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSigma(Deref(p), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(WriteSub-Ident)**
LookupBind(Ïƒ, x) = b    UpdateVal(Ïƒ, b, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(Identifier(x), v, Ïƒ) â‡“ (ok, Ïƒ')

**(WriteSub-Ident-Path-Poison)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(Identifier(x), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(WriteSub-Ident-Path)**
Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    name = (ent.target_opt if present, else x)    PathOfModule(mp) = path    StaticAddr(path, name) = addr    WriteAddr(Ïƒ, addr, v) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(Identifier(x), v, Ïƒ) â‡“ (ok, Ïƒ')

**(WriteSub-Field)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    FieldUpdate(v_p, f, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(FieldAccess(p, f), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(WriteSub-Tuple)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    TupleUpdate(v_p, i, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(TupleAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(WriteSub-Index)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexUpdate(v_p, v_i, v) = v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_2) â‡“ (sout, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_3)

**(WriteSub-Index-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    Â¬ (0 â‰¤ v_i < Len(v_p))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WriteSub-Index-Range)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n = end - start    SliceUpdate(v_p, start, v) â‡“ v_p'    Î“ âŠ¢ WritePlaceSubSigma(p, v_p', Ïƒ_2) â‡“ (sout, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (sout, Ïƒ_3)

**(WriteSub-Index-Range-OOB)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WriteSub-Index-Range-Len)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(i, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_p)) = (start, end)    SliceLen(v) = n    n â‰  end - start
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(IndexAccess(p, i), v, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(WriteSub-Deref)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    Î“ âŠ¢ WritePtrSigma(v_ptr, v, Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ WritePlaceSubSigma(Deref(p), v, Ïƒ) â‡“ (sout, Ïƒ_2)

**(MovePlace-Whole)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v), Ïƒ_1)    FieldHead(p) = âŠ¥    LookupBind(Ïƒ_1, PlaceRoot(p)) = b    BindInfo(b).mov = mov    SetState(Ïƒ_1, b, Moved) â‡“ Ïƒ_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MovePlaceSigma(p, Ïƒ) â‡“ (Val(v), Ïƒ_2)

**(MovePlace-Field)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v), Ïƒ_1)    FieldHead(p) = f    LookupBind(Ïƒ_1, PlaceRoot(p)) = b    BindInfo(b).mov = mov    BindState(Ïƒ_1, b) = s    PM(s, f) = s'    SetState(Ïƒ_1, b, s') â‡“ Ïƒ_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MovePlaceSigma(p, Ïƒ) â‡“ (Val(v), Ïƒ_2)

**(MovePlace-Ctrl)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MovePlaceSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)


**Stateful Expression Evaluation.**

**EvalJudg.**
EvalJudg = {Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (out, Ïƒ')}

**Range Helpers.**

RangeVal = {RangeVal(k, lo_opt, hi_opt) | k âˆˆ RangeKind}
Inc(v) = v' â‡” v = IntVal(t, x) âˆ§ x' = x + 1 âˆ§ InRange(x', t) âˆ§ v' = IntVal(t, x')
SliceBoundsRaw(RangeVal(Exclusive, s, e), L) = (start, end) â‡” IndexNum(s) = start âˆ§ IndexNum(e) = end
SliceBoundsRaw(RangeVal(Inclusive, s, e), L) = (start, end) â‡” IndexNum(s) = start âˆ§ Inc(e) = e' âˆ§ IndexNum(e') = end
SliceBoundsRaw(RangeVal(From, s, âŠ¥), L) = (start, L) â‡” IndexNum(s) = start
SliceBoundsRaw(RangeVal(To, âŠ¥, e), L) = (0, end) â‡” IndexNum(e) = end
SliceBoundsRaw(RangeVal(ToInclusive, âŠ¥, e), L) = (0, end) â‡” Inc(e) = e' âˆ§ IndexNum(e') = end
SliceBoundsRaw(RangeVal(Full, âŠ¥, âŠ¥), L) = (0, L)
SliceBounds(r, L) = (start, end) â‡” SliceBoundsRaw(r, L) = (start, end) âˆ§ 0 â‰¤ start â‰¤ end â‰¤ L
SliceBounds(r, L) = âŠ¥ â‡” SliceBoundsRaw(r, L) = âŠ¥ âˆ¨ (âˆƒ start, end. SliceBoundsRaw(r, L) = (start, end) âˆ§ Â¬ (0 â‰¤ start â‰¤ end â‰¤ L))

**EvalOptJudg.**
EvalOptJudg = {Î“ âŠ¢ EvalOptSigma(e_opt, Ïƒ) â‡“ (out, Ïƒ')}

**(EvalOptSigma-None)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalOptSigma(âŠ¥, Ïƒ) â‡“ (Val(âŠ¥), Ïƒ)

**(EvalOptSigma-Some)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalOptSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)

**(EvalOptSigma-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalOptSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Range)**
Î“ âŠ¢ EvalOptSigma(lo_opt, Ïƒ_0) â‡“ (Val(v_lo), Ïƒ_1)    Î“ âŠ¢ EvalOptSigma(hi_opt, Ïƒ_1) â‡“ (Val(v_hi), Ïƒ_2)    r = RangeVal(kind, v_lo, v_hi)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Range(kind, lo_opt, hi_opt), Ïƒ_0) â‡“ (Val(r), Ïƒ_2)

**(EvalSigma-Range-Ctrl)**
Î“ âŠ¢ EvalOptSigma(lo_opt, Ïƒ_0) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Range(kind, lo_opt, hi_opt), Ïƒ_0) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Range-Ctrl-Hi)**
Î“ âŠ¢ EvalOptSigma(lo_opt, Ïƒ_0) â‡“ (Val(v_lo), Ïƒ_1)    Î“ âŠ¢ EvalOptSigma(hi_opt, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Range(kind, lo_opt, hi_opt), Ïƒ_0) â‡“ (Ctrl(Îº), Ïƒ_2)

**Value Constructors and Accessors.**

**Values.**
BoolVal(b) = b â‡” b âˆˆ {true, false}
CharVal(u) = u â‡” u âˆˆ UnicodeScalar
UnitVal = ()
IntVal(t, x) defined â‡” t âˆˆ IntTypes âˆ§ InRange(x, t)
IntValType(IntVal(t, x)) = t
IntValValue(IntVal(t, x)) = x
FloatVal(t, v) defined â‡” t âˆˆ FloatTypes âˆ§ v âˆˆ FloatValueSet(t)
FloatValType(FloatVal(t, v)) = t
FloatValValue(FloatVal(t, v)) = v
PtrVal(s, addr) defined â‡” s âˆˆ PtrStateSet
Ptr@Valid(addr) = PtrVal(`Valid`, addr)
Ptr@Null(addr) = PtrVal(`Null`, addr)
Ptr@Expired(addr) = PtrVal(`Expired`, addr)
TupleVal = {(v_1, â€¦, v_n) | n â‰¥ 0}
ArrayVal = {[v_1, â€¦, v_n] | n â‰¥ 0}
ModalVal(S, v) = âŸ¨S, vâŸ©
Value = {BoolVal(b) | b âˆˆ {true, false}} âˆª {CharVal(u) | u âˆˆ UnicodeScalar} âˆª {UnitVal} âˆª {IntVal(t, x) | IntVal(t, x) defined} âˆª {FloatVal(t, v) | FloatVal(t, v) defined} âˆª {PtrVal(s, addr) | PtrVal(s, addr) defined} âˆª {RawPtr(q, addr)} âˆª TupleVal âˆª ArrayVal âˆª {RecordValue(tr, fs)} âˆª {EnumValue(path, payload)} âˆª RangeVal âˆª {SliceValue(v, r) | SliceValue(v, r) defined} âˆª {ModalVal(S, v)} âˆª {Dyn(Cl, RawPtr(`imm`, addr), T)} âˆª `string@Managed` âˆª `string@View` âˆª `bytes@Managed` âˆª `bytes@View`

**EvalListJudg.**
EvalListJudg = {Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (out, Ïƒ')}

**(EvalListSigma-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalListSigma([], Ïƒ) â‡“ (Val([]), Ïƒ)

**(EvalListSigma-Cons)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ EvalListSigma(es, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalListSigma(e::es, Ïƒ) â‡“ (Val([v] ++ vec_v), Ïƒ_2)

**(EvalListSigma-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalListSigma(e::es, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalFieldInitsSigma-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalFieldInitsSigma([], Ïƒ) â‡“ (Val([]), Ïƒ)

**(EvalFieldInitsSigma-Cons)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ EvalFieldInitsSigma(fs, Ïƒ_1) â‡“ (Val(vec_f), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalFieldInitsSigma([âŸ¨f, eâŸ©] ++ fs, Ïƒ) â‡“ (Val([âŸ¨f, vâŸ©] ++ vec_f), Ïƒ_2)

**(EvalFieldInitsSigma-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalFieldInitsSigma([âŸ¨f, eâŸ©] ++ fs, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

BoolValue(lit) = true â‡” lit.kind = BoolLiteral âˆ§ Lexeme(lit) = "true"
BoolValue(lit) = false â‡” lit.kind = BoolLiteral âˆ§ Lexeme(lit) = "false"
CharValue(lit) = u â‡” lit.kind = CharLiteral âˆ§ T = Lexeme(lit) âˆ§ StringBytesFrom(T, 1, |T|-1) = bytes âˆ§ DecodeUTF8(bytes) = [u]
LiteralValue(â„“, TypePrim("bool")) = BoolVal(b) â‡” â„“.kind = BoolLiteral âˆ§ BoolValue(â„“) = b
LiteralValue(â„“, TypePrim("char")) = CharVal(c) â‡” â„“.kind = CharLiteral âˆ§ CharValue(â„“) = c
LiteralValue(â„“, TypeString(`@View`)) = v â‡” â„“.kind = StringLiteral âˆ§ ViewBytes(v) = StringBytes(â„“)
LiteralValue(â„“, TypePrim(t)) = IntVal(t, x) â‡” â„“.kind = IntLiteral âˆ§ t âˆˆ IntTypes âˆ§ x = IntValue(â„“)
LiteralValue(â„“, TypePrim(t)) = FloatVal(t, v) â‡” â„“.kind = FloatLiteral âˆ§ t âˆˆ FloatTypes âˆ§ v = FloatValue(â„“)
LiteralValue(â„“, TypeRawPtr(q, U)) = RawPtr(q, 0x0) â‡” â„“.kind = NullLiteral
EnumPayloadVal = {âŠ¥, TuplePayload(vec_v), RecordPayload(vec_f)}
RecordValue(tr, fs) defined
EnumValue(path, payload) defined â‡” payload âˆˆ EnumPayloadVal

**(EvalSigma-Literal)**
T = ExprType(Literal(â„“))    LiteralValue(â„“, T) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Literal(â„“), Ïƒ) â‡“ (Val(v), Ïƒ)

**(EvalSigma-Ident-Poison)**
LookupBind(Ïƒ, x) undefined    Î“ âŠ¢ ResolveValueName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Identifier(x), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(EvalSigma-Ident-Poison-RecordCtor)**
LookupBind(Ïƒ, x) undefined    Î“ âŠ¢ ResolveValueName(x) â‡‘    Î“ âŠ¢ ResolveTypeName(x) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Identifier(x), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(EvalSigma-Ident)**
LookupVal(Ïƒ, x) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Identifier(x), Ïƒ) â‡“ (Val(v), Ïƒ)

**(EvalSigma-Path-Poison)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡“ ent    ent.origin_opt = mp    PoisonedModule(Ïƒ, PathOfModule(mp))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Path(path, name), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(EvalSigma-Path-Poison-RecordCtor)**
Î“ âŠ¢ ResolveQualified(path, name, ValueKind) â‡‘    Î“ âŠ¢ ResolveRecordPath(path, name) â‡“ p    SplitLast(p) = (mp, _)    PoisonedModule(Ïƒ, mp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Path(path, name), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(EvalSigma-Path)**
LookupValPath(Ïƒ, path, name) = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Path(path, name), Ïƒ) â‡“ (Val(v), Ïƒ)

**(EvalSigma-ErrorExpr)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(ErrorExpr(_), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**(EvalSigma-Tuple)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Val(vec_v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TupleExpr(es), Ïƒ) â‡“ (Val((v_1, â€¦, v_n)), Ïƒ_1)

**(EvalSigma-Tuple-Ctrl)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TupleExpr(es), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Array)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Val(vec_v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(ArrayExpr(es), Ïƒ) â‡“ (Val([v_1, â€¦, v_n]), Ïƒ_1)

**(EvalSigma-Array-Ctrl)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(ArrayExpr(es), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Record)**
Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Val(vec_f), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(RecordExpr(tr, fields), Ïƒ) â‡“ (Val(RecordValue(tr, vec_f)), Ïƒ_1)

**(EvalSigma-Record-Ctrl)**
Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(RecordExpr(tr, fields), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Enum-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(EnumLiteral(path, âŠ¥), Ïƒ) â‡“ (Val(EnumValue(path, âŠ¥)), Ïƒ)

**(EvalSigma-Enum-Tuple)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Val(vec_v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(EnumLiteral(path, Paren(es)), Ïƒ) â‡“ (Val(EnumValue(path, TuplePayload(vec_v))), Ïƒ_1)

**(EvalSigma-Enum-Tuple-Ctrl)**
Î“ âŠ¢ EvalListSigma(es, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(EnumLiteral(path, Paren(es)), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Enum-Record)**
Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Val(vec_f), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(EnumLiteral(path, Brace(fields)), Ïƒ) â‡“ (Val(EnumValue(path, RecordPayload(vec_f))), Ïƒ_1)

**(EvalSigma-Enum-Record-Ctrl)**
Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(EnumLiteral(path, Brace(fields)), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-FieldAccess)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    FieldValue(v_b, f) = v_f
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(FieldAccess(base, f), Ïƒ) â‡“ (Val(v_f), Ïƒ_1)

**(EvalSigma-FieldAccess-Ctrl)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(FieldAccess(base, f), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-TupleAccess)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    TupleValue(v_b, i) = v_i
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TupleAccess(base, i), Ïƒ) â‡“ (Val(v_i), Ïƒ_1)

**(EvalSigma-TupleAccess-Ctrl)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TupleAccess(base, i), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Index)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ EvalSigma(idx, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexValue(v_b, v_i) = v_e
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Val(v_e), Ïƒ_2)

**(EvalSigma-Index-OOB)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ EvalSigma(idx, Ïƒ_1) â‡“ (Val(v_i), Ïƒ_2)    IndexNum(v_i) = i    Â¬ (0 â‰¤ i < Len(v_b))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(EvalSigma-Index-Range)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ EvalSigma(idx, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceValue(v_b, v_r) = v_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Val(v_s), Ïƒ_2)

**(EvalSigma-Index-Range-OOB)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ EvalSigma(idx, Ïƒ_1) â‡“ (Val(v_r), Ïƒ_2)    SliceBounds(v_r, Len(v_b)) = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(EvalSigma-Index-Ctrl-Base)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Index-Ctrl-Idx)**
Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ EvalSigma(idx, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IndexAccess(base, idx), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**Unary, Binary, Cast, Transmute, Propagate.**

RetType(Î“) âˆˆ Type
OpJudg = {UnOp(op, v) â‡“ v', BinOp(op, v_1, v_2) â‡“ v}
NumericValue(v, t) â‡” ValueType(v) = TypePrim(t) âˆ§ t âˆˆ NumericTypes
IntValue(v, t) â‡” ValueType(v) = TypePrim(t) âˆ§ t âˆˆ IntTypes
FloatValue(v, t) â‡” ValueType(v) = TypePrim(t) âˆ§ t âˆˆ FloatTypes
SignedIntValue(v) â‡” âˆƒ t. t âˆˆ SignedIntTypes âˆ§ ValueType(v) = TypePrim(t)
SignedTypeOf(v) = t â‡” t âˆˆ SignedIntTypes âˆ§ ValueType(v) = TypePrim(t)
U32Value(v) â‡” ValueType(v) = TypePrim("u32")
EqValue(v_1, v_2) â‡” âˆƒ T. ValueType(v_1) = T âˆ§ ValueType(v_2) = T âˆ§ EqType(T)
OrdValue(v_1, v_2) â‡” âˆƒ T. ValueType(v_1) = T âˆ§ ValueType(v_2) = T âˆ§ OrdType(T)
IsNaN(t, v) â‡” t âˆˆ FloatTypes âˆ§ v = FloatVal(t, x) âˆ§ IEEE754Encode(t, x) = CanonicalNaNBits(t)
OrdScalar(v) = x â‡” (âˆƒ t. v = IntVal(t, x) âˆ§ t âˆˆ IntTypes) âˆ¨ (âˆƒ u. v = CharVal(u) âˆ§ x = u)
Cmp("==", v_1, v_2) = b â‡” EqValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = false) âˆ¨ (Â¬ âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = (v_1 = v_2)))
Cmp("!=", v_1, v_2) = b â‡” EqValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = true) âˆ¨ (Â¬ âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = (v_1 â‰  v_2)))
Cmp("<", v_1, v_2) = b â‡” OrdValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ ((IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = false) âˆ¨ (Â¬ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ x_1 = FloatValValue(v_1) âˆ§ x_2 = FloatValValue(v_2) âˆ§ b = (x_1 < x_2))) âˆ¨ (âˆƒ x_1, x_2. OrdScalar(v_1) = x_1 âˆ§ OrdScalar(v_2) = x_2 âˆ§ b = (x_1 < x_2)))
Cmp("<=", v_1, v_2) = b â‡” OrdValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ ((IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = false) âˆ¨ (Â¬ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ x_1 = FloatValValue(v_1) âˆ§ x_2 = FloatValValue(v_2) âˆ§ b = (x_1 â‰¤ x_2))) âˆ¨ (âˆƒ x_1, x_2. OrdScalar(v_1) = x_1 âˆ§ OrdScalar(v_2) = x_2 âˆ§ b = (x_1 â‰¤ x_2)))
Cmp(">", v_1, v_2) = b â‡” OrdValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ ((IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = false) âˆ¨ (Â¬ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ x_1 = FloatValValue(v_1) âˆ§ x_2 = FloatValValue(v_2) âˆ§ b = (x_1 > x_2))) âˆ¨ (âˆƒ x_1, x_2. OrdScalar(v_1) = x_1 âˆ§ OrdScalar(v_2) = x_2 âˆ§ b = (x_1 > x_2)))
Cmp(">=", v_1, v_2) = b â‡” OrdValue(v_1, v_2) âˆ§ ((âˆƒ t. FloatValue(v_1, t) âˆ§ FloatValue(v_2, t) âˆ§ ((IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ b = false) âˆ¨ (Â¬ (IsNaN(t, v_1) âˆ¨ IsNaN(t, v_2)) âˆ§ x_1 = FloatValValue(v_1) âˆ§ x_2 = FloatValValue(v_2) âˆ§ b = (x_1 â‰¥ x_2))) âˆ¨ (âˆƒ x_1, x_2. OrdScalar(v_1) = x_1 âˆ§ OrdScalar(v_2) = x_2 âˆ§ b = (x_1 â‰¥ x_2)))
BitAt(u, i) = b â‡” b âˆˆ {0, 1} âˆ§ âˆƒ q, r. u = q Â· 2^{i + 1} + b Â· 2^i + r âˆ§ 0 â‰¤ r < 2^i
BitNot(v) = v' â‡” âˆƒ t, x, w, u, u'. v = IntVal(t, x) âˆ§ w = IntWidth(t) âˆ§ u = ToUnsigned(w, x) âˆ§ u' = (2^w - 1) - u âˆ§ ((t âˆˆ SignedIntTypes âˆ§ v' = IntVal(t, ToSigned(w, u'))) âˆ¨ (t âˆˆ UnsignedIntTypes âˆ§ v' = IntVal(t, u')))
BitOp(op, t, v_1, v_2) = v â‡” v_1 = IntVal(t, x_1) âˆ§ v_2 = IntVal(t, x_2) âˆ§ w = IntWidth(t) âˆ§ u_1 = ToUnsigned(w, x_1) âˆ§ u_2 = ToUnsigned(w, x_2) âˆ§ u = âˆ‘_{i=0}^{w-1} b_i 2^i âˆ§ âˆ€ i. 0 â‰¤ i < w â‡’ ((op = "&" âˆ§ b_i = BitAt(u_1, i) Â· BitAt(u_2, i)) âˆ¨ (op = "|" âˆ§ b_i = max(BitAt(u_1, i), BitAt(u_2, i))) âˆ¨ (op = "^" âˆ§ b_i = (BitAt(u_1, i) + BitAt(u_2, i)) mod 2)) âˆ§ ((t âˆˆ SignedIntTypes âˆ§ v = IntVal(t, ToSigned(w, u))) âˆ¨ (t âˆˆ UnsignedIntTypes âˆ§ v = IntVal(t, u)))
ShiftOp(op, t, v_1, v_2) = v â‡” v_1 = IntVal(t, x_1) âˆ§ v_2 = IntVal("u32", n) âˆ§ w = IntWidth(t) âˆ§ 0 â‰¤ n < w âˆ§ u_1 = ToUnsigned(w, x_1) âˆ§ ((op = "<<" âˆ§ u = (u_1 Â· 2^n) mod 2^w) âˆ¨ (op = ">>" âˆ§ u = âŒŠu_1 / 2^nâŒ‹)) âˆ§ ((t âˆˆ SignedIntTypes âˆ§ v = IntVal(t, ToSigned(w, u))) âˆ¨ (t âˆˆ UnsignedIntTypes âˆ§ v = IntVal(t, u)))
PowInt(x, n) = y â‡” n âˆˆ â„• âˆ§ ((n = 0 âˆ§ y = 1) âˆ¨ (n > 0 âˆ§ y = x Â· PowInt(x, n - 1)))
PowFloat(t, x_1, x_2) = x â‡” t âˆˆ FloatTypes âˆ§ x_1 âˆˆ FloatValueSet(t) âˆ§ x_2 âˆˆ FloatValueSet(t) âˆ§ x is the IEEE 754-2019 pow result of x_1, x_2 in format FloatFormat(t)
IEEEArith(op, t, v_1, v_2) = v â‡” v_1 = FloatVal(t, x_1) âˆ§ v_2 = FloatVal(t, x_2) âˆ§ op âˆˆ ArithOps âˆ§ ((op âˆˆ {"+", "-", "*", "/"} âˆ§ x is the IEEE 754-2019 result of applying op to x_1, x_2 in format FloatFormat(t)) âˆ¨ (op = "%" âˆ§ x is the IEEE 754-2019 remainder of x_1, x_2 in format FloatFormat(t)) âˆ¨ (op = "**" âˆ§ PowFloat(t, x_1, x_2) = x)) âˆ§ v = FloatVal(t, x)
âˆ€ t âˆˆ FloatTypes, v_1, v_2, op âˆˆ ArithOps. âˆƒ v. IEEEArith(op, t, v_1, v_2) = v
UnOp("!", false) â‡“ true
UnOp("!", true) â‡“ false
UnOp("!", v) â‡“ v' â‡” IntValue(v, t) âˆ§ v' = BitNot(v)
UnOp("-", v) â‡“ v' â‡” v = IntVal(t, x) âˆ§ t âˆˆ SignedIntTypes âˆ§ x' = -x âˆ§ InRange(x', t) âˆ§ v' = IntVal(t, x')
UnOp("-", v) â‡“ v' â‡” v = FloatVal(t, x) âˆ§ v' = FloatVal(t, -x)
UnOp("widen", v) â‡“ ModalVal(S, v) â‡” v = RecordValue(ModalStateRef(modal_ref, S), fs)
BinOp(op, v_1, v_2) â‡“ v â‡” op âˆˆ ArithOps âˆ§ NumericValue(v_1, t) âˆ§ NumericValue(v_2, t) âˆ§ ArithEval(op, t, v_1, v_2) â‡“ v
BinOp(op, v_1, v_2) â‡“ v â‡” op âˆˆ BitOps âˆ§ IntValue(v_1, t) âˆ§ IntValue(v_2, t) âˆ§ BitEval(op, t, v_1, v_2) â‡“ v
BinOp(op, v_1, v_2) â‡“ v â‡” op âˆˆ ShiftOps âˆ§ IntValue(v_1, t) âˆ§ U32Value(v_2) âˆ§ ShiftEval(op, t, v_1, v_2) â‡“ v
BinOp(op, v_1, v_2) â‡“ v â‡” op âˆˆ {"==", "!="} âˆ§ EqValue(v_1, v_2) âˆ§ v = Cmp(op, v_1, v_2)
BinOp(op, v_1, v_2) â‡“ v â‡” op âˆˆ {"<", "<=", ">", ">="} âˆ§ OrdValue(v_1, v_2) âˆ§ v = Cmp(op, v_1, v_2)
ArithEval(op, t, v_1, v_2) â‡“ v â‡” t âˆˆ IntTypes âˆ§ v_1 = IntVal(t, x_1) âˆ§ v_2 = IntVal(t, x_2) âˆ§ ((op âˆˆ {"+", "-", "*"} âˆ§ x = x_1 op x_2) âˆ¨ (op âˆˆ {"/", "%"} âˆ§ x_2 â‰  0 âˆ§ x = x_1 op x_2) âˆ¨ (op = "**" âˆ§ x_2 â‰¥ 0 âˆ§ PowInt(x_1, x_2) = x)) âˆ§ InRange(x, t) âˆ§ v = IntVal(t, x)
ArithEval(op, t, v_1, v_2) â‡“ v â‡” t âˆˆ FloatTypes âˆ§ v = IEEEArith(op, t, v_1, v_2)
BitEval(op, t, v_1, v_2) â‡“ v â‡” t âˆˆ IntTypes âˆ§ v = BitOp(op, t, v_1, v_2)
ShiftEval(op, t, v_1, v_2) â‡“ v â‡” t âˆˆ IntTypes âˆ§ v = ShiftOp(op, t, v_1, v_2)

**(EvalSigma-Unary)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    UnOp(op, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Unary(op, e), Ïƒ) â‡“ (Val(v'), Ïƒ_1)

**(EvalSigma-Unary-Panic)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    UnOp(op, v) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Unary(op, e), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)

**(EvalSigma-Unary-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Unary(op, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Bin-And-False)**
Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(false), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary("&&", e_1, e_2), Ïƒ) â‡“ (Val(false), Ïƒ_1)

**(EvalSigma-Bin-And-True)**
Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e_2, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary("&&", e_1, e_2), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Bin-Or-True)**
Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(true), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary("||", e_1, e_2), Ïƒ) â‡“ (Val(true), Ïƒ_1)

**(EvalSigma-Bin-Or-False)**
Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(false), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e_2, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary("||", e_1, e_2), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Binary)**
op âˆ‰ {"&&", "||"}    Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(v_1), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e_2, Ïƒ_1) â‡“ (Val(v_2), Ïƒ_2)    BinOp(op, v_1, v_2) â‡“ v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary(op, e_1, e_2), Ïƒ) â‡“ (Val(v), Ïƒ_2)

**(EvalSigma-Binary-Panic)**
op âˆ‰ {"&&", "||"}    Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(v_1), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e_2, Ïƒ_1) â‡“ (Val(v_2), Ïƒ_2)    BinOp(op, v_1, v_2) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary(op, e_1, e_2), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_2)

**(EvalSigma-Bin-Ctrl-L)**
Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary(op, e_1, e_2), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Bin-Ctrl-R)**
op âˆ‰ {"&&", "||"}    Î“ âŠ¢ EvalSigma(e_1, Ïƒ) â‡“ (Val(v_1), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e_2, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Binary(op, e_1, e_2), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

ExprType : Expr â†’ Type
R = RetType(Î“)

CastValJudg = {CastVal(S, T, v) â‡“ v'}
UnsignedIntTypes = {`u8`, `u16`, `u32`, `u64`, `u128`, `usize`}
IntWidth(`i8`) = 8    IntWidth(`i16`) = 16    IntWidth(`i32`) = 32    IntWidth(`i64`) = 64    IntWidth(`i128`) = 128
IntWidth(`u8`) = 8    IntWidth(`u16`) = 16    IntWidth(`u32`) = 32    IntWidth(`u64`) = 64    IntWidth(`u128`) = 128
IntWidth(`isize`) = 8 Ã— PointerSize    IntWidth(`usize`) = 8 Ã— PointerSize
Mod_w(x) = x mod 2^w
ToSigned(w, x) = y â‡” y âˆˆ [-2^{w-1}, 2^{w-1}-1] âˆ§ y â‰¡ x mod 2^w
ToUnsigned(w, x) = y â‡” y âˆˆ [0, 2^w-1] âˆ§ y â‰¡ x mod 2^w
CodePoint : `char` â†’ â„•
IsScalar(u) â‡” u âˆˆ CharValueRange
IntToFloat(t, x) function
FloatToFloat(s, t, v) function
Trunc(v) function
CharOf(u) = u â‡” IsScalar(u)
CodePoint(CharOf(u)) = u    (IsScalar(u))
IEEE754Bits(t, v) = bits â‡” v âˆˆ FloatValueSet(t) âˆ§ IEEE754Encode(t, v) = bits
IntToFloat(t, x) = v â‡” v âˆˆ NonNaNValueSet(t) âˆ§ âˆ€ v' âˆˆ NonNaNValueSet(t). |v - x| < |v' - x| âˆ¨ (|v - x| = |v' - x| âˆ§ EvenSignificandLSB(t, v))
FloatToFloat(s, t, v) = v' â‡” IEEE754Encode(s, v) = CanonicalNaNBits(s) âˆ§ v' = CanonicalNaN(t)
FloatToFloat(s, t, v) = v' â‡” IEEE754Encode(s, v) â‰  CanonicalNaNBits(s) âˆ§ v' âˆˆ NonNaNValueSet(t) âˆ§ âˆ€ u âˆˆ NonNaNValueSet(t). |v' - v| < |u - v| âˆ¨ (|v' - v| = |u - v| âˆ§ EvenSignificandLSB(t, v'))
Trunc(v) =
 âŒŠvâŒ‹    if v â‰¥ 0
 âŒˆvâŒ‰    if v < 0

**(CastVal-Id)**
StripPerm(S) = StripPerm(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v

**(CastVal-Int-Int-Signed)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(s)    T' = TypePrim(t)    s âˆˆ IntTypes    t âˆˆ SignedIntTypes    v = IntVal(s, x)    w = IntWidth(t)    x' = ToSigned(w, x)    v' = IntVal(t, x')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Int-Int-Unsigned)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(s)    T' = TypePrim(t)    s âˆˆ IntTypes    t âˆˆ UnsignedIntTypes    v = IntVal(s, x)    w = IntWidth(t)    x' = ToUnsigned(w, x)    v' = IntVal(t, x')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Int-Float)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(s)    T' = TypePrim(t)    s âˆˆ IntTypes    t âˆˆ FloatTypes    v = IntVal(s, x)    v' = FloatVal(t, IntToFloat(t, x))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Float-Float)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(s)    T' = TypePrim(t)    s âˆˆ FloatTypes    t âˆˆ FloatTypes    v = FloatVal(s, x)    v' = FloatVal(t, FloatToFloat(s, t, x))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Float-Int)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(s)    T' = TypePrim(t)    s âˆˆ FloatTypes    t âˆˆ IntTypes    v = FloatVal(s, x)    x' = Trunc(x)    InRange(x', t)    v' = IntVal(t, x')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Bool-Int)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim("bool")    T' = TypePrim(t)    t âˆˆ IntTypes    v' =
 IntVal(t, 0)    if v = false
 IntVal(t, 1)    if v = true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Int-Bool)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim(t)    t âˆˆ IntTypes    T' = TypePrim("bool")    v = IntVal(t, x)    v' =
 false    if x = 0
 true     if x â‰  0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-Char-U32)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim("char")    T' = TypePrim("u32")    v' = IntVal("u32", CodePoint(v))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(CastVal-U32-Char)**
S' = StripPerm(S)    T' = StripPerm(T)    S' = TypePrim("u32")    T' = TypePrim("char")    v = IntVal("u32", x)    IsScalar(x)    v' = CharVal(CharOf(x))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CastVal(S, T, v) â‡“ v'

**(EvalSigma-Cast)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    S = ExprType(e)    CastVal(S, T, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Cast(e, T), Ïƒ) â‡“ (Val(v'), Ïƒ_1)

**(EvalSigma-Cast-Panic)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    S = ExprType(e)    CastVal(S, T, v) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Cast(e, T), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)

**(EvalSigma-Cast-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Cast(e, T), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

TransmuteVal(S, T, v) â‡“ v' â‡” ValueBits(S, v) = bits âˆ§ ValueBits(T, v') = bits

**(EvalSigma-Transmute)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    S = t_1    T = t_2    TransmuteVal(S, T, v) â‡“ v'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TransmuteExpr(t_1, t_2, e), Ïƒ) â‡“ (Val(v'), Ïƒ_1)

**(EvalSigma-Transmute-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(TransmuteExpr(t_1, t_2, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

UnionCaseJudg = {UnionCase(v) = âŸ¨T, v_TâŸ©}
UnionCase(v) = âŸ¨T, v_TâŸ© â‡” âˆƒ U, bits. ValueBits(TypeUnion(U), v) = bits âˆ§ UnionBits(U, T, v_T) = bits

**(EvalSigma-Propagate-Success)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    U = ExprType(e)    SuccessMember(RetType(Î“), U) = T_s    UnionCase(v) = âŸ¨T_s, v_sâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Propagate(e), Ïƒ) â‡“ (Val(v_s), Ïƒ_1)

**(EvalSigma-Propagate-Error)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    U = ExprType(e)    SuccessMember(RetType(Î“), U) = T_s    UnionCase(v) = âŸ¨T_e, v_eâŸ©    T_e â‰  T_s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Propagate(e), Ïƒ) â‡“ (Ctrl(Return(v_e)), Ïƒ_1)

**(EvalSigma-Propagate-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Propagate(e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**Conditionals and Match.**

**(EvalSigma-If-True)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(then_block, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IfExpr(cond, then_block, else_opt), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-If-False-None)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(false), Ïƒ_1)    else_opt = âŠ¥
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IfExpr(cond, then_block, else_opt), Ïƒ) â‡“ (Val(()), Ïƒ_1)

**(EvalSigma-If-False-Some)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(false), Ïƒ_1)    else_opt = e    Î“ âŠ¢ EvalSigma(e, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IfExpr(cond, then_block, else_opt), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-If-Ctrl)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(IfExpr(cond, then_block, else_opt), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

ArmResult = {Match(out), NoMatch}
MatchArmJudg = {Î“ âŠ¢ MatchArmSigma(arm, v, Ïƒ) â‡“ (res, Ïƒ')}

**(EvalArmBody-Block)**
body = b    Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArmBodySigma(body, Ïƒ) â‡“ (out, Ïƒ')

**(EvalArmBody-Expr)**
body = e    Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArmBodySigma(body, Ïƒ) â‡“ (out, Ïƒ')

**(MatchArm-Fail)**
Î“ âŠ¢ MatchPattern(pat, v) undefined
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmSigma(âŸ¨pat, guard_opt, bodyâŸ©, v, Ïƒ) â‡“ (NoMatch, Ïƒ)

**(MatchArm-Guard-False)**
Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    guard_opt = g    Î“ âŠ¢ EvalSigma(g, Ïƒ_1) â‡“ (Val(false), Ïƒ_2)    BlockExit(Ïƒ_2, scope, Val(())) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmSigma(âŸ¨pat, guard_opt, bodyâŸ©, v, Ïƒ) â‡“ (NoMatch, Ïƒ_3)

**(MatchArm-Guard-True)**
Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    guard_opt = g    Î“ âŠ¢ EvalSigma(g, Ïƒ_1) â‡“ (Val(true), Ïƒ_2)    Î“ âŠ¢ EvalArmBodySigma(body, Ïƒ_2) â‡“ (out, Ïƒ_3)    BlockExit(Ïƒ_3, scope, out) â‡“ (out', Ïƒ_4)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmSigma(âŸ¨pat, guard_opt, bodyâŸ©, v, Ïƒ) â‡“ (Match(out'), Ïƒ_4)

**(MatchArm-NoGuard)**
Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    guard_opt = âŠ¥    Î“ âŠ¢ EvalArmBodySigma(body, Ïƒ_1) â‡“ (out, Ïƒ_2)    BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmSigma(âŸ¨pat, guard_opt, bodyâŸ©, v, Ïƒ) â‡“ (Match(out'), Ïƒ_3)

**(MatchArm-Ctrl)**
Î“ âŠ¢ MatchPattern(pat, v) â‡“ B    BindOrder(pat, B) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    guard_opt = g    Î“ âŠ¢ EvalSigma(g, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)    BlockExit(Ïƒ_2, scope, Ctrl(Îº)) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmSigma(âŸ¨pat, guard_opt, bodyâŸ©, v, Ïƒ) â‡“ (Match(out'), Ïƒ_3)

**(MatchArms-Head)**
Î“ âŠ¢ MatchArmSigma(a, v, Ïƒ) â‡“ (Match(out), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmsSigma(a::as, v, Ïƒ) â‡“ (out, Ïƒ_1)

**(MatchArms-Tail)**
Î“ âŠ¢ MatchArmSigma(a, v, Ïƒ) â‡“ (NoMatch, Ïƒ_1)    Î“ âŠ¢ MatchArmsSigma(as, v, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchArmsSigma(a::as, v, Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Match)**
Î“ âŠ¢ EvalSigma(scrutinee, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ MatchArmsSigma(arms, v, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MatchExpr(scrutinee, arms), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Match-Ctrl)**
Î“ âŠ¢ EvalSigma(scrutinee, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MatchExpr(scrutinee, arms), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**Pointer and Move Expressions.**

**(EvalSigma-PtrNull)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(PtrNullExpr, Ïƒ) â‡“ (Val(Ptr@Null(0x0)), Ïƒ)

**(EvalSigma-AddressOf)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Val(addr), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AddressOf(p), Ïƒ) â‡“ (Val(Ptr@Valid(addr)), Ïƒ_1)

**(EvalSigma-AddressOf-Ctrl)**
Î“ âŠ¢ AddrOfSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AddressOf(p), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Deref)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v_ptr), Ïƒ_1)    Î“ âŠ¢ ReadPtrSigma(v_ptr, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Deref(e), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Deref-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Deref(e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Move)**
Î“ âŠ¢ MovePlaceSigma(p, Ïƒ) â‡“ (out, Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MoveExpr(p), Ïƒ) â‡“ (out, Ïƒ_1)

**Call and Method Application.**

CallJudg = {Î“ âŠ¢ EvalArgsSigma(params, args, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ ApplyCancelProc(name, vec_v, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ ApplyProcSigma(proc, vec_v, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ ApplyRecordCtorSigma(p, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ ApplyMethodSigma(base, name, v_self, v_arg, vec_v, Ïƒ) â‡“ (out, Ïƒ')}
CallTarget(ProcRef(proc)) = proc
CallTarget(RecordCtor(p)) = RecordCtor(p)
MethodTarget(RecordValue(TypePath(p), fs), name) = m â‡” LookupMethod(TypePath(p), name) = m
MethodTarget(RecordValue(ModalStateRef(modal_ref, S), fs), name) = md â‡” ModalDeclOf(modal_ref) = M âˆ§ LookupStateMethod(M, S, name) = md
MethodTarget(RecordValue(ModalStateRef(modal_ref, S), fs), name) = tr â‡” ModalDeclOf(modal_ref) = M âˆ§ LookupTransition(M, S, name) = tr
MethodTarget(Dyn(Cl, RawPtr(`imm`, addr), T), name) = Dispatch(T, Cl, name)
MethodTarget(v_self, name) = m âˆ§ m.body = âŠ¥ âˆ§ Â¬ âˆƒ vec_v, out. Î“ âŠ¢ PrimCall(MethodOwner(m), MethodName(m), v_self, vec_v) â‡“ out â‡’ IllFormed(MethodTarget(v_self, name))
ArgVal = {v, Alias(addr)}
BindParams([âŸ¨mode_1, x_1, T_1âŸ©, â€¦, âŸ¨mode_n, x_n, T_nâŸ©], [v_1, â€¦, v_n]) = [âŸ¨x_1, v_1âŸ©, â€¦, âŸ¨x_n, v_nâŸ©]
RecordDefaultInits(p) = [âŸ¨f_1, e_1âŸ©, â€¦, âŸ¨f_n, e_nâŸ©] â‡” RecordDecl(p) = R âˆ§ Fields(R) = [âŸ¨vis_1, f_1, T_1, e_1, span_1, doc_1âŸ©, â€¦, âŸ¨vis_n, f_n, T_n, e_n, span_n, doc_nâŸ©] âˆ§ âˆ€ i. e_i â‰  âŠ¥
ReturnOut(Val(v)) = Val(v)
ReturnOut(Ctrl(Return(v))) = Val(v)
ReturnOut(Ctrl(Panic)) = Ctrl(Panic)
ReturnOut(Ctrl(Abort)) = Ctrl(Abort)
ReturnOut(Ctrl(Break(v_opt))) = âŠ¥
ReturnOut(Ctrl(Continue)) = âŠ¥
ReturnOut(out) = âŠ¥ â‡’ IllFormed(ReturnOut(out))
RecvArgMode(base) = `move` â‡” âˆƒ p. base = MoveExpr(p)
RecvArgMode(base) = âŠ¥ â‡” Â¬ âˆƒ p. base = MoveExpr(p)

**(EvalArgsSigma-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArgsSigma([], [], Ïƒ) â‡“ (Val([]), Ïƒ)

**(EvalArgsSigma-Cons-Move)**
Î“ âŠ¢ EvalSigma(MovedArg(moved, e), Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ EvalArgsSigma(ps, as, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArgsSigma([âŸ¨`move`, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as, Ïƒ) â‡“ (Val([v] ++ vec_v), Ïƒ_2)

**(EvalArgsSigma-Cons-Ref)**
Î“ âŠ¢ AddrOfSigma(e, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    Î“ âŠ¢ EvalArgsSigma(ps, as, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArgsSigma([âŸ¨âŠ¥, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as, Ïƒ) â‡“ (Val([Alias(addr)] ++ vec_v), Ïƒ_2)

**(EvalArgsSigma-Ctrl-Move)**
Î“ âŠ¢ EvalSigma(MovedArg(moved, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArgsSigma([âŸ¨`move`, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalArgsSigma-Ctrl-Ref)**
Î“ âŠ¢ AddrOfSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalArgsSigma([âŸ¨âŠ¥, x, T_pâŸ©] ++ ps, [âŸ¨moved, e, _âŸ©] ++ as, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalRecvSigma-Move)**
mode = `move`    Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Val(v_self), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Val(âŸ¨v_self, v_selfâŸ©), Ïƒ_1)

**(EvalRecvSigma-Ref-Dyn)**
mode = âŠ¥    Î“ âŠ¢ AddrOfSigma(base, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    ReadAddr(Ïƒ_1, addr) = Dyn(Cl, RawPtr(`imm`, addr_d), T)    DynAddrState(Ïƒ_1, addr_d) = `Valid`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Val(âŸ¨Dyn(Cl, RawPtr(`imm`, addr_d), T), Alias(addr_d)âŸ©), Ïƒ_1)

**(EvalRecvSigma-Ref-Dyn-Expired)**
mode = âŠ¥    Î“ âŠ¢ AddrOfSigma(base, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    ReadAddr(Ïƒ_1, addr) = Dyn(Cl, RawPtr(`imm`, addr_d), T)    DynAddrState(Ïƒ_1, addr_d) = `Expired`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Ctrl(Panic), Ïƒ_1)

**(EvalRecvSigma-Ref)**
mode = âŠ¥    Î“ âŠ¢ AddrOfSigma(base, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    ReadAddr(Ïƒ_1, addr) = v_self    Â¬ (âˆƒ Cl, addr_d, T. v_self = Dyn(Cl, RawPtr(`imm`, addr_d), T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Val(âŸ¨v_self, Alias(addr)âŸ©), Ïƒ_1)

**(EvalRecvSigma-Ctrl-Move)**
mode = `move`    Î“ âŠ¢ EvalSigma(base, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalRecvSigma-Ctrl-Ref)**
mode = âŠ¥    Î“ âŠ¢ AddrOfSigma(base, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

RegionProcParams(name) = params â‡” RegionProcSig(`Region::`name) = âŸ¨params, retâŸ©
CancelProcParams(name) = params â‡” CancelTokenProcSig(`CancelToken::`name) = âŸ¨params, retâŸ©

**(ApplyRegionProc-NewScoped)**
name = `new_scoped`    vec_v = [opts]    RegionNewScoped(Ïƒ, opts) â‡“ (Ïƒ', v)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v), Ïƒ')

**(ApplyRegionProc-Alloc)**
name = `alloc`    vec_v = [v_r, v]    RegionAllocProc(Ïƒ, v_r, v) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v'), Ïƒ')

**(ApplyRegionProc-Reset)**
name = `reset_unchecked`    vec_v = [v_r]    RegionResetProc(Ïƒ, v_r) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v'), Ïƒ')

**(ApplyRegionProc-Freeze)**
name = `freeze`    vec_v = [v_r]    RegionFreezeProc(Ïƒ, v_r) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v'), Ïƒ')

**(ApplyRegionProc-Thaw)**
name = `thaw`    vec_v = [v_r]    RegionThawProc(Ïƒ, v_r) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v'), Ïƒ')

**(ApplyRegionProc-Free)**
name = `free_unchecked`    vec_v = [v_r]    RegionFreeProc(Ïƒ, v_r) â‡“ (Ïƒ', v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ) â‡“ (Val(v'), Ïƒ')

**(ApplyCancelProc-New)**
name = `new`    vec_v = []    CancelNew() â‡“ v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyCancelProc(name, vec_v, Ïƒ) â‡“ (Val(v), Ïƒ)

**(ApplyProcSigma)**
BindParams(proc.params, vec_v) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    Î“ âŠ¢ EvalBlockBodySigma(proc.body, Ïƒ_1) â‡“ (out, Ïƒ_2)    BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyProcSigma(proc, vec_v, Ïƒ) â‡“ (ReturnOut(out'), Ïƒ_3)

**(ApplyRecordCtorSigma)**
RecordDefaultInits(p) = fields    Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Val(vec_f), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRecordCtorSigma(p, Ïƒ) â‡“ (Val(RecordValue(TypePath(p), vec_f)), Ïƒ_1)

**(ApplyRecordCtorSigma-Ctrl)**
RecordDefaultInits(p) = fields    Î“ âŠ¢ EvalFieldInitsSigma(fields, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyRecordCtorSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ApplyMethodSigma-Prim)**
m = MethodTarget(v_self, name)    MethodOwner(m) = owner    MethodName(m) = name    Î“ âŠ¢ PrimCall(owner, name, v_self, vec_v) â‡“ out
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyMethodSigma(base, name, v_self, v_arg, vec_v, Ïƒ) â‡“ (out, Ïƒ)

**(ApplyMethodSigma)**
m = MethodTarget(v_self, name)    BindParams(RecvParams(base, name), [v_arg] ++ vec_v) = binds    BlockEnter(Ïƒ, binds) â‡“ (Ïƒ_1, scope)    Î“ âŠ¢ EvalBlockBodySigma(m.body, Ïƒ_1) â‡“ (out, Ïƒ_2)    BlockExit(Ïƒ_2, scope, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyMethodSigma(base, name, v_self, v_arg, vec_v, Ïƒ) â‡“ (ReturnOut(out'), Ïƒ_3)

**(EvalSigma-Call-RegionProc)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(ProcRef([`Region`], name)), Ïƒ_1)    RegionProcParams(name) = params    Î“ âŠ¢ EvalArgsSigma(params, args, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)    Î“ âŠ¢ ApplyRegionProc(name, vec_v, Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Call-RegionProc-Ctrl-Args)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(ProcRef([`Region`], name)), Ïƒ_1)    RegionProcParams(name) = params    Î“ âŠ¢ EvalArgsSigma(params, args, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(EvalSigma-Call-CancelProc)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(ProcRef([`CancelToken`], name)), Ïƒ_1)    CancelProcParams(name) = params    Î“ âŠ¢ EvalArgsSigma(params, args, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)    Î“ âŠ¢ ApplyCancelProc(name, vec_v, Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Call-CancelProc-Ctrl-Args)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(ProcRef([`CancelToken`], name)), Ïƒ_1)    CancelProcParams(name) = params    Î“ âŠ¢ EvalArgsSigma(params, args, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(EvalSigma-Call-Proc)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(v_c), Ïƒ_1)    proc = CallTarget(v_c)    Î“ âŠ¢ EvalArgsSigma(proc.params, args, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)    Î“ âŠ¢ ApplyProcSigma(proc, vec_v, Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Call-Record)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(v_c), Ïƒ_1)    Î“ âŠ¢ EvalArgsSigma([], args, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)    vec_v = []    RecordCtor(p) = CallTarget(v_c)    Î“ âŠ¢ ApplyRecordCtorSigma(p, Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Call-Ctrl)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Call-Ctrl-Args)**
Î“ âŠ¢ EvalSigma(callee, Ïƒ) â‡“ (Val(v_c), Ïƒ_1)    proc = CallTarget(v_c)    Î“ âŠ¢ EvalArgsSigma(proc.params, args, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(Call(callee, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(EvalSigma-MethodCall)**
mode = RecvArgMode(base)    Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Val(âŸ¨v_self, v_argâŸ©), Ïƒ_1)    m = MethodTarget(v_self, name)    Î“ âŠ¢ EvalArgsSigma(m.params, args, Ïƒ_1) â‡“ (Val(vec_v), Ïƒ_2)    Î“ âŠ¢ ApplyMethodSigma(base, name, v_self, v_arg, vec_v, Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MethodCall(base, name, args), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-MethodCall-Ctrl)**
mode = RecvArgMode(base)    Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MethodCall(base, name, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-MethodCall-Ctrl-Args)**
mode = RecvArgMode(base)    Î“ âŠ¢ EvalRecvSigma(base, mode, Ïƒ) â‡“ (Val(âŸ¨v_self, v_argâŸ©), Ïƒ_1)    m = MethodTarget(v_self, name)    Î“ âŠ¢ EvalArgsSigma(m.params, args, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(MethodCall(base, name, args), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(EvalSigma-Alloc-Implicit)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    ActiveTarget(Ïƒ_1) = r    RegionAlloc(Ïƒ_1, r, v) â‡“ (Ïƒ_2, v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AllocExpr(âŠ¥, e), Ïƒ) â‡“ (Val(v'), Ïƒ_2)

**(EvalSigma-Alloc-Implicit-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AllocExpr(âŠ¥, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Alloc-Explicit)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    LookupVal(Ïƒ_1, r) = v_r    RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ_1, h) = r_t    RegionAlloc(Ïƒ_1, r_t, v) â‡“ (Ïƒ_2, v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AllocExpr(r, e), Ïƒ) â‡“ (Val(v'), Ïƒ_2)

**(EvalSigma-Alloc-Explicit-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(AllocExpr(r, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Block)**
Î“ âŠ¢ EvalBlockSigma(BlockExpr(stmts, tail_opt), Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(BlockExpr(stmts, tail_opt), Ïƒ) â‡“ (out, Ïƒ')

**(EvalSigma-UnsafeBlock)**
Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(UnsafeBlockExpr(b), Ïƒ) â‡“ (out, Ïƒ')

**Loop Iteration Helpers.**

IterJudg = {IterInit(v) â‡“ it, IterNext(it) â‡“ (opt(v), it')}
Iter = {âŸ¨v, iâŸ© | Len(v) defined âˆ§ i âˆˆ â„•}
IterInit(v) â‡“ âŸ¨v, 0âŸ© â‡” Len(v) defined
IterNext(âŸ¨v, iâŸ©) â‡“ (âŠ¥, âŸ¨v, iâŸ©) â‡” Â¬ (0 â‰¤ i < Len(v))
IterNext(âŸ¨v, iâŸ©) â‡“ (v_i, âŸ¨v, i + 1âŸ©) â‡” 0 â‰¤ i < Len(v) âˆ§ IndexValue(v, i) = v_i

LoopIterJudg = {Î“ âŠ¢ LoopIterExec(p, b, it, Ïƒ) â‡“ (out, Ïƒ')}

**(EvalSigma-Loop-Infinite-Step)**
Î“ âŠ¢ EvalSigma(body, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Loop-Infinite-Continue)**
Î“ âŠ¢ EvalSigma(body, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ_1)    Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Loop-Infinite-Break)**
Î“ âŠ¢ EvalSigma(body, Ïƒ) â‡“ (Ctrl(Break(v_opt)), Ïƒ_1)    v = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ) â‡“ (Val(v), Ïƒ_1)

**(EvalSigma-Loop-Infinite-Ctrl)**
Î“ âŠ¢ EvalSigma(body, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopInfinite(body), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Loop-Cond-False)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(false), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (Val(()), Ïƒ_1)

**(EvalSigma-Loop-Cond-True-Step)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(body, Ïƒ_1) â‡“ (Val(v), Ïƒ_2)    Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Loop-Cond-Continue)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(body, Ïƒ_1) â‡“ (Ctrl(Continue), Ïƒ_2)    Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ_2) â‡“ (out, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (out, Ïƒ_3)

**(EvalSigma-Loop-Cond-Break)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(body, Ïƒ_1) â‡“ (Ctrl(Break(v_opt)), Ïƒ_2)    v = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (Val(v), Ïƒ_2)

**(EvalSigma-Loop-Cond-Ctrl)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(EvalSigma-Loop-Cond-Body-Ctrl)**
Î“ âŠ¢ EvalSigma(cond, Ïƒ) â‡“ (Val(true), Ïƒ_1)    Î“ âŠ¢ EvalSigma(body, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopConditional(cond, body), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(EvalSigma-Loop-Iter)**
Î“ âŠ¢ EvalSigma(iter, Ïƒ) â‡“ (Val(v_iter), Ïƒ_1)    IterInit(v_iter) â‡“ it    Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopIter(pat, ty_opt, iter, body), Ïƒ) â‡“ (out, Ïƒ_2)

**(EvalSigma-Loop-Iter-Ctrl)**
Î“ âŠ¢ EvalSigma(iter, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(LoopIter(pat, ty_opt, iter, body), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(LoopIter-Done)**
IterNext(it) â‡“ (âŠ¥, it')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ) â‡“ (Val(()), Ïƒ)

**(LoopIter-Step-Val)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ EvalBlockBindSigma(pat, v, body, Ïƒ) â‡“ (Val(v_b), Ïƒ_1)    Î“ âŠ¢ LoopIterExec(pat, body, it', Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ) â‡“ (out, Ïƒ_2)

**(LoopIter-Step-Continue)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ EvalBlockBindSigma(pat, v, body, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ_1)    Î“ âŠ¢ LoopIterExec(pat, body, it', Ïƒ_1) â‡“ (out, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ) â‡“ (out, Ïƒ_2)

**(LoopIter-Step-Break)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ EvalBlockBindSigma(pat, v, body, Ïƒ) â‡“ (Ctrl(Break(v_opt)), Ïƒ_1)    v' = BreakVal(v_opt)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ) â‡“ (Val(v'), Ïƒ_1)

**(LoopIter-Step-Ctrl)**
IterNext(it) â‡“ (v, it')    Î“ âŠ¢ EvalBlockBindSigma(pat, v, body, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)    Îº âˆˆ {Return(_), Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ LoopIterExec(pat, body, it, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**Stateful Small-Step (Expressions).**

ExprState = {âŸ¨e, ÏƒâŸ©, âŸ¨Val(v), ÏƒâŸ©, âŸ¨Ctrl(Îº), ÏƒâŸ©}
TerminalExpr(âŸ¨Val(v), ÏƒâŸ©)
TerminalExpr(âŸ¨Ctrl(Îº), ÏƒâŸ©)

**(StepSigma-Pure)**
âŸ¨eâŸ© â†’ âŸ¨e'âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨e, ÏƒâŸ© â†’ âŸ¨e', ÏƒâŸ©

**(StepSigma-Alloc-Implicit)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    ActiveTarget(Ïƒ_1) = r    RegionAlloc(Ïƒ_1, r, v) â‡“ (Ïƒ_2, v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨AllocExpr(âŠ¥, e), ÏƒâŸ© â†’ âŸ¨Val(v'), Ïƒ_2âŸ©

**(StepSigma-Alloc-Implicit-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨AllocExpr(âŠ¥, e), ÏƒâŸ© â†’ âŸ¨Ctrl(Îº), Ïƒ_1âŸ©

**(StepSigma-Alloc-Explicit)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    LookupVal(Ïƒ_1, r) = v_r    RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ_1, h) = r_t    RegionAlloc(Ïƒ_1, r_t, v) â‡“ (Ïƒ_2, v')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨AllocExpr(r, e), ÏƒâŸ© â†’ âŸ¨Val(v'), Ïƒ_2âŸ©

**(StepSigma-Alloc-Explicit-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨AllocExpr(r, e), ÏƒâŸ© â†’ âŸ¨Ctrl(Îº), Ïƒ_1âŸ©

**(StepSigma-Block)**
Î“ âŠ¢ EvalBlockSigma(BlockExpr(stmts, tail_opt), Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨BlockExpr(stmts, tail_opt), ÏƒâŸ© â†’ âŸ¨out, Ïƒ'âŸ©

**(StepSigma-UnsafeBlock)**
Î“ âŠ¢ EvalBlockSigma(b, Ïƒ) â‡“ (out, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨UnsafeBlockExpr(b), ÏƒâŸ© â†’ âŸ¨out, Ïƒ'âŸ©

**(StepSigma-Loop)**
Î“ âŠ¢ EvalSigma(â„“, Ïƒ) â‡“ (out, Ïƒ')    â„“ âˆˆ {LoopInfinite(_), LoopConditional(_, _), LoopIter(_, _, _, _)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨â„“, ÏƒâŸ© â†’ âŸ¨out, Ïƒ'âŸ©

**(StepSigma-Stateful-Other)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (out, Ïƒ')    e âˆ‰ {AllocExpr(_, _), BlockExpr(_, _), UnsafeBlockExpr(_), LoopInfinite(_), LoopConditional(_, _), LoopIter(_, _, _, _)}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨e, ÏƒâŸ© â†’ âŸ¨out, Ïƒ'âŸ©

**Statement Execution (Cursive0).**

ExecJudg = {Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (sout, Ïƒ'), Î“ âŠ¢ ExecSeqSigma(ss, Ïƒ) â‡“ (sout, Ïƒ')}

**(ExecSeq-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSeqSigma([], Ïƒ) â‡“ (ok, Ïƒ)

**(ExecSeq-Cons-Ok)**
Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (ok, Ïƒ_1)    Î“ âŠ¢ ExecSeqSigma(ss, Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSeqSigma(s::ss, Ïƒ) â‡“ (sout, Ïƒ_2)

**(ExecSeq-Cons-Ctrl)**
Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSeqSigma(s::ss, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

BindingForm(binding) = âŸ¨pat, ty_opt, op, init, _âŸ©

**(ExecSigma-Let)**
BindingForm(binding) = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Val(v), Ïƒ_1)    BindPattern(Ïƒ_1, pat, v) â‡“ (Ïƒ_2, bs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(LetStmt(binding), Ïƒ) â‡“ (ok, Ïƒ_2)

**(ExecSigma-Let-Ctrl)**
BindingForm(binding) = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(LetStmt(binding), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-Var)**
BindingForm(binding) = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Val(v), Ïƒ_1)    BindPattern(Ïƒ_1, pat, v) â‡“ (Ïƒ_2, bs)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(VarStmt(binding), Ïƒ) â‡“ (ok, Ïƒ_2)

**(ExecSigma-Var-Ctrl)**
BindingForm(binding) = âŸ¨pat, ty_opt, op, init, _âŸ©    Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(VarStmt(binding), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-ShadowLet)**
Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Val(v), Ïƒ_1)    BindVal(Ïƒ_1, x, v) â‡“ (Ïƒ_2, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ShadowLetStmt(x, ty_opt, init), Ïƒ) â‡“ (ok, Ïƒ_2)

**(ExecSigma-ShadowLet-Ctrl)**
Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ShadowLetStmt(x, ty_opt, init), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-ShadowVar)**
Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Val(v), Ïƒ_1)    BindVal(Ïƒ_1, x, v) â‡“ (Ïƒ_2, b)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ShadowVarStmt(x, ty_opt, init), Ïƒ) â‡“ (ok, Ïƒ_2)

**(ExecSigma-ShadowVar-Ctrl)**
Î“ âŠ¢ EvalSigma(init, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ShadowVarStmt(x, ty_opt, init), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-Assign)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)    Î“ âŠ¢ WritePlaceSigma(p, v, Ïƒ_1) â‡“ (sout, Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(AssignStmt(p, e), Ïƒ) â‡“ (sout, Ïƒ_2)

**(ExecSigma-Assign-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(AssignStmt(p, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)


**(ExecSigma-CompoundAssign)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e, Ïƒ_1) â‡“ (Val(v_e), Ïƒ_2)    BinOp(op, v_p, v_e) â‡“ v    Î“ âŠ¢ WritePlaceSigma(p, v, Ïƒ_2) â‡“ (sout, Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(CompoundAssignStmt(p, op, e), Ïƒ) â‡“ (sout, Ïƒ_3)

**(ExecSigma-CompoundAssign-Left-Ctrl)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(CompoundAssignStmt(p, op, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-CompoundAssign-Right-Ctrl)**
Î“ âŠ¢ ReadPlaceSigma(p, Ïƒ) â‡“ (Val(v_p), Ïƒ_1)    Î“ âŠ¢ EvalSigma(e, Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(CompoundAssignStmt(p, op, e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(ExecSigma-ExprStmt)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (out, Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ExprStmt(e), Ïƒ) â‡“ (StmtOutOf(out), Ïƒ_1)

**(ExecSigma-UnsafeStmt)**
Î“ âŠ¢ EvalSigma(b, Ïƒ) â‡“ (out, Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(UnsafeBlockStmt(b), Ïƒ) â‡“ (StmtOutOf(out), Ïƒ_1)

**(ExecSigma-Defer)**
AppendCleanup(Ïƒ, DeferBlock(b)) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(DeferStmt(b), Ïƒ) â‡“ (ok, Ïƒ')

opts = RegionOptsExpr(opts_opt)

**(ExecSigma-Region)**
Î“ âŠ¢ EvalSigma(opts, Ïƒ) â‡“ (Val(v_o), Ïƒ_1)    RegionNew(Ïƒ_1, v_o) â‡“ (Ïƒ_2, r, scope)    BindRegionAlias(Ïƒ_2, alias_opt, r) â‡“ Ïƒ_3    Î“ âŠ¢ EvalInScopeSigma(b, Ïƒ_3, scope) â‡“ (out, Ïƒ_4)    RegionRelease(Ïƒ_4, r, scope, out) â‡“ (out', Ïƒ_5)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(RegionStmt(opts_opt, alias_opt, b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_5)

**(ExecSigma-Region-Ctrl)**
Î“ âŠ¢ EvalSigma(opts, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(RegionStmt(opts_opt, alias_opt, b), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

RegionRelease(Î£, r, scope, out) â‡“ (out', Î£') â‡” Î“ âŠ¢ CleanupScope(scope, Î£) â‡“ (c, Î£_1) âˆ§ out' = ExitOutcome(out, c) âˆ§ ((out' = Ctrl(Abort) âˆ§ Î£' = Î£_1) âˆ¨ (out' â‰  Ctrl(Abort) âˆ§ ReleaseArena(Î£_1, r) â‡“ Î£_2 âˆ§ PopScope_Ïƒ(Î£_2) â‡“ (Î£', scope)))

**(ExecSigma-Frame-Implicit)**
ActiveTarget(Ïƒ) = r    FrameEnter(Ïƒ, r) â‡“ (Ïƒ_1, F, scope, mark)    Î“ âŠ¢ EvalInScopeSigma(b, Ïƒ_1, scope) â‡“ (out, Ïƒ_2)    FrameReset(Ïƒ_2, r, scope, mark, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(FrameStmt(âŠ¥, b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_3)

**(ExecSigma-Frame-Explicit)**
LookupVal(Ïƒ, r) = v_r    RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ, h) = r_t    FrameEnter(Ïƒ, r_t) â‡“ (Ïƒ_1, F, scope, mark)    Î“ âŠ¢ EvalInScopeSigma(b, Ïƒ_1, scope) â‡“ (out, Ïƒ_2)    FrameReset(Ïƒ_2, r_t, scope, mark, out) â‡“ (out', Ïƒ_3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(FrameStmt(r, b), Ïƒ) â‡“ (StmtOutOf(out'), Ïƒ_3)

FrameReset(Î£, r, scope, mark, out) â‡“ (out', Î£') â‡” Î“ âŠ¢ CleanupScope(scope, Î£) â‡“ (c, Î£_1) âˆ§ out' = ExitOutcome(out, c) âˆ§ ((out' = Ctrl(Abort) âˆ§ Î£' = Î£_1) âˆ¨ (out' â‰  Ctrl(Abort) âˆ§ ResetArena(Î£_1, r, scope, mark) â‡“ Î£_2 âˆ§ PopScope_Ïƒ(Î£_2) â‡“ (Î£', scope)))

**(ExecSigma-Return)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ReturnStmt(e), Ïƒ) â‡“ (Ctrl(Return(v)), Ïƒ_1)

**(ExecSigma-Return-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ReturnStmt(âŠ¥), Ïƒ) â‡“ (Ctrl(Return(())), Ïƒ)

**(ExecSigma-Return-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ReturnStmt(e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-Break)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Val(v), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(BreakStmt(e), Ïƒ) â‡“ (Ctrl(Break(v)), Ïƒ_1)

**(ExecSigma-Break-Unit)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(BreakStmt(âŠ¥), Ïƒ) â‡“ (Ctrl(Break(âŠ¥)), Ïƒ)

**(ExecSigma-Break-Ctrl)**
Î“ âŠ¢ EvalSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(BreakStmt(e), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**(ExecSigma-Continue)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ContinueStmt, Ïƒ) â‡“ (Ctrl(Continue), Ïƒ)

**(ExecSigma-Error)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExecSigma(ErrorStmt(_), Ïƒ) â‡“ (Ctrl(Panic), Ïƒ)

**Stateful Small-Step (Statements).**

ExecState = {Exec(s, Ïƒ), ExecSeq(ss, Ïƒ), ExecCtrl(Îº, Ïƒ), ExecDone(Ïƒ), RegionBody(r, scope, b, Ïƒ), RegionExit(r, scope, out, Ïƒ), FrameBody(r, scope, mark, b, Ïƒ), FrameExit(r, scope, mark, out, Ïƒ)}

**(Step-Exec-Other-Ok)**
s âˆ‰ {DeferStmt(_), RegionStmt(_, _, _), FrameStmt(_, _)}    Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (ok, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(s, Ïƒ)âŸ© â†’ âŸ¨ExecDone(Ïƒ')âŸ©

**(Step-Exec-Other-Ctrl)**
s âˆ‰ {DeferStmt(_), RegionStmt(_, _, _), FrameStmt(_, _)}    Î“ âŠ¢ ExecSigma(s, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(s, Ïƒ)âŸ© â†’ âŸ¨ExecCtrl(Îº, Ïƒ')âŸ©

**(Step-ExecSeq-Ok)**
Î“ âŠ¢ ExecSeqSigma(ss, Ïƒ) â‡“ (ok, Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ExecSeq(ss, Ïƒ)âŸ© â†’ âŸ¨ExecDone(Ïƒ')âŸ©

**(Step-ExecSeq-Ctrl)**
Î“ âŠ¢ ExecSeqSigma(ss, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ExecSeq(ss, Ïƒ)âŸ© â†’ âŸ¨ExecCtrl(Îº, Ïƒ')âŸ©

**(Step-Exec-Defer)**
AppendCleanup(Ïƒ, DeferBlock(b)) â‡“ Ïƒ'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(DeferStmt(b), Ïƒ)âŸ© â†’ âŸ¨ExecDone(Ïƒ')âŸ©

**(Step-Exec-Region-Enter)**
opts = RegionOptsExpr(opts_opt)    Î“ âŠ¢ EvalSigma(opts, Ïƒ) â‡“ (Val(v_o), Ïƒ_1)    RegionNew(Ïƒ_1, v_o) â‡“ (Ïƒ_2, r, scope)    BindRegionAlias(Ïƒ_2, alias_opt, r) â‡“ Ïƒ_3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(RegionStmt(opts_opt, alias_opt, b), Ïƒ)âŸ© â†’ âŸ¨RegionBody(r, scope, b, Ïƒ_3)âŸ©

**(Step-Exec-Region-Enter-Ctrl)**
opts = RegionOptsExpr(opts_opt)    Î“ âŠ¢ EvalSigma(opts, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(RegionStmt(opts_opt, alias_opt, b), Ïƒ)âŸ© â†’ âŸ¨ExecCtrl(Îº, Ïƒ_1)âŸ©

**(Step-Exec-Region-Body)**
Î“ âŠ¢ EvalInScopeSigma(b, Ïƒ, scope) â‡“ (out, Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨RegionBody(r, scope, b, Ïƒ)âŸ© â†’ âŸ¨RegionExit(r, scope, out, Ïƒ_1)âŸ©

**(Step-Exec-Region-Exit-Ok)**
RegionRelease(Ïƒ, r, scope, out) â‡“ (out', Ïƒ')    StmtOutOf(out') = ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨RegionExit(r, scope, out, Ïƒ)âŸ© â†’ âŸ¨ExecDone(Ïƒ')âŸ©

**(Step-Exec-Region-Exit-Ctrl)**
RegionRelease(Ïƒ, r, scope, out) â‡“ (out', Ïƒ')    StmtOutOf(out') = Ctrl(Îº)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨RegionExit(r, scope, out, Ïƒ)âŸ© â†’ âŸ¨ExecCtrl(Îº, Ïƒ')âŸ©

**(Step-Exec-Frame-Enter-Implicit)**
ActiveTarget(Ïƒ) = r    FrameEnter(Ïƒ, r) â‡“ (Ïƒ_1, F, scope, mark)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(FrameStmt(âŠ¥, b), Ïƒ)âŸ© â†’ âŸ¨FrameBody(r, scope, mark, b, Ïƒ_1)âŸ©

**(Step-Exec-Frame-Enter-Explicit)**
LookupVal(Ïƒ, r) = v_r    RegionHandleOf(v_r) = h    ResolveTarget(Ïƒ, h) = r_t    FrameEnter(Ïƒ, r_t) â‡“ (Ïƒ_1, F, scope, mark)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨Exec(FrameStmt(r, b), Ïƒ)âŸ© â†’ âŸ¨FrameBody(r_t, scope, mark, b, Ïƒ_1)âŸ©

**(Step-Exec-Frame-Body)**
Î“ âŠ¢ EvalInScopeSigma(b, Ïƒ, scope) â‡“ (out, Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨FrameBody(r, scope, mark, b, Ïƒ)âŸ© â†’ âŸ¨FrameExit(r, scope, mark, out, Ïƒ_1)âŸ©

**(Step-Exec-Frame-Exit-Ok)**
FrameReset(Ïƒ, r, scope, mark, out) â‡“ (out', Ïƒ')    StmtOutOf(out') = ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨FrameExit(r, scope, mark, out, Ïƒ)âŸ© â†’ âŸ¨ExecDone(Ïƒ')âŸ©

**(Step-Exec-Frame-Exit-Ctrl)**
FrameReset(Ïƒ, r, scope, mark, out) â‡“ (out', Ïƒ')    StmtOutOf(out') = Ctrl(Îº)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨FrameExit(r, scope, mark, out, Ïƒ)âŸ© â†’ âŸ¨ExecCtrl(Îº, Ïƒ')âŸ©

ConstPat(p) = v â‡” p = LiteralPattern(â„“) âˆ§ v = LiteralValue(â„“, PatType(p))

**MatchRecord.**
MatchRecordJudg = {Î“ âŠ¢ MatchRecord(fs, v) â‡“ B}

**(MatchRecord-Empty)**
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchRecord([], v) â‡“ âˆ…

**(MatchRecord-Cons-Implicit)**
FieldValue(v, f) = v_f    Î“ âŠ¢ MatchRecord(fs, v) â‡“ B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchRecord([f] ++ fs, v) â‡“ (B âŠŽ {f â†¦ v_f})

**(MatchRecord-Cons-Explicit)**
FieldValue(v, f) = v_f    Î“ âŠ¢ MatchPattern(p, v_f) â‡“ B_1    Î“ âŠ¢ MatchRecord(fs, v) â‡“ B_2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ MatchRecord([âŸ¨f, pâŸ©] ++ fs, v) â‡“ (B_1 âŠŽ B_2)

### 7.5. String Literal Semantics

StringLiteralVal(lit) = v â‡” LiteralValue(lit, TypeString(`@View`)) = v

**String Literal Storage.**
For any string literal `lit`, evaluation MUST allocate `StringBytes(lit)` in static, read-only storage. The resulting `string@View` value MUST reference that storage and MUST have length `|StringBytes(lit)|`. The backing storage MUST have static duration and MUST NOT be deallocated. See Ã‚Â§6.1.5 for the `string@View` layout.
<!-- Source: "Literal content is allocated in static, read-only memory at compilation ... A string@View value is constructed with pointer to static memory and byte length ... String literals have static storage duration; backing memory is never deallocated." -->

### 7.6. Dynamic Class Objects

DynValue(Cl, addr, T) = Dyn(Cl, RawPtr(`imm`, addr), T)
DynLayout(Cl, addr, T) = âŸ¨RawPtr(`imm`, addr), VTable(T, Cl)âŸ©

**(Eval-Dynamic-Form)**
IsPlace(e)    Î“ âŠ¢ AddrOfSigma(e, Ïƒ) â‡“ (Val(addr), Ïƒ_1)    T_e = ExprType(e)    T = StripPerm(T_e)    Î“ âŠ¢ T <: Cl
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(e `as` TypeDynamic(Cl), Ïƒ) â‡“ (Val(Dyn(Cl, RawPtr(`imm`, addr), T)), Ïƒ_1)

**(Eval-Dynamic-Form-Ctrl)**
Î“ âŠ¢ AddrOfSigma(e, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ EvalSigma(e `as` TypeDynamic(Cl), Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_1)

**Dynamic Dispatch.**

Dispatch(T, Cl, name) = m' â‡” m = LookupClassMethod(Cl, name) âˆ§ MethodByName(T, name) = m' âˆ§ SigMatch(T, m', m)
Dispatch(T, Cl, name) = m â‡” m = LookupClassMethod(Cl, name) âˆ§ (MethodByName(T, name) = âŠ¥ âˆ¨ (âˆƒ m'. MethodByName(T, name) = m' âˆ§ Â¬ SigMatch(T, m', m))) âˆ§ m.body â‰  âŠ¥
Dispatch(T, Cl, name) = âŠ¥ â‡” m = LookupClassMethod(Cl, name) âˆ§ (MethodByName(T, name) = âŠ¥ âˆ¨ (âˆƒ m'. MethodByName(T, name) = m' âˆ§ Â¬ SigMatch(T, m', m))) âˆ§ m.body = âŠ¥


### 7.7. FileSystem and File Operations

**Primitive Relations.**

FSJudg = {FSOpenRead(fs, path) â‡“ r, FSOpenWrite(fs, path) â‡“ r, FSOpenAppend(fs, path) â‡“ r, FSCreateWrite(fs, path) â‡“ r, FSReadFile(fs, path) â‡“ r, FSReadBytes(fs, path) â‡“ r, FSWriteFile(fs, path, data) â‡“ r, FSWriteStdout(fs, data) â‡“ r, FSWriteStderr(fs, data) â‡“ r, FSExists(fs, path) â‡“ b, FSRemove(fs, path) â‡“ r, FSOpenDir(fs, path) â‡“ r, FSCreateDir(fs, path) â‡“ r, FSEnsureDir(fs, path) â‡“ r, FSKind(fs, path) â‡“ r, FSRestrict(fs, path) â‡“ fs', FileReadAll(handle) â‡“ r, FileReadAllBytes(handle) â‡“ r, FileWrite(handle, data) â‡“ r, FileFlush(handle) â‡“ r, FileClose(handle) â‡“ ok, DirNext(handle) â‡“ r, DirClose(handle) â‡“ ok}
FSResType(FSOpenRead) = `File@Read` | `IoError`
FSResType(FSOpenWrite) = `File@Write` | `IoError`
FSResType(FSOpenAppend) = `File@Append` | `IoError`
FSResType(FSCreateWrite) = `File@Write` | `IoError`
FSResType(FSReadFile) = `string@Managed` | `IoError`
FSResType(FSReadBytes) = `bytes@Managed` | `IoError`
FSResType(FSWriteFile) = `()` | `IoError`
FSResType(FSWriteStdout) = `()` | `IoError`
FSResType(FSWriteStderr) = `()` | `IoError`
FSResType(FSExists) = `bool`
FSResType(FSRemove) = `()` | `IoError`
FSResType(FSOpenDir) = `DirIter@Open` | `IoError`
FSResType(FSCreateDir) = `()` | `IoError`
FSResType(FSEnsureDir) = `()` | `IoError`
FSResType(FSKind) = `FileKind` | `IoError`
FSResType(FSRestrict) = `$FileSystem`
FSResType(FileReadAll) = `string@Managed` | `IoError`
FSResType(FileReadAllBytes) = `bytes@Managed` | `IoError`
FSResType(FileWrite) = `()` | `IoError`
FSResType(FileFlush) = `()` | `IoError`
FSResType(FileClose) = `ok`
FSResType(DirNext) = `DirEntry` | `()` | `IoError`
FSResType(DirClose) = `ok`

Handle = â„•
Entry ::= FileEntry(bytes) | DirEntry(names) | OtherEntry
FSState = âŸ¨entries, handles, diriters, flushed, failmapâŸ©
Entries(âŸ¨entries, handles, diriters, flushed, failmapâŸ©) = entries
Handles(âŸ¨entries, handles, diriters, flushed, failmapâŸ©) = handles
DirIters(âŸ¨entries, handles, diriters, flushed, failmapâŸ©) = diriters
FlushedSet(âŸ¨entries, handles, diriters, flushed, failmapâŸ©) = flushed
FailMap(âŸ¨entries, handles, diriters, flushed, failmapâŸ©) = failmap
EntryKind(Ï‰, path) =
 `File`  if Entries(Ï‰)[path] = FileEntry(_)
 `Dir`   if Entries(Ï‰)[path] = DirEntry(_)
 `Other` if Entries(Ï‰)[path] = OtherEntry
 `Other` otherwise
FileBytes(Ï‰, path) = bytes â‡” Entries(Ï‰)[path] = FileEntry(bytes)
DirNames(Ï‰, path) = names â‡” Entries(Ï‰)[path] = DirEntry(names)
HandleStateOf(Ï‰, h) =
 Handles(Ï‰)[h].state  if Handles(Ï‰)[h] defined
 `Closed`             otherwise
HandlePos(Ï‰, h) =
 Handles(Ï‰)[h].pos  if Handles(Ï‰)[h] defined
 0                  otherwise
HandleLen(Ï‰, h) =
 Handles(Ï‰)[h].len  if Handles(Ï‰)[h] defined
 0                  otherwise
HandlePath(Ï‰, h) =
 Handles(Ï‰)[h].path  if Handles(Ï‰)[h] defined
 "\""                otherwise
DirIterFS(Ï‰, h) =
 DirIters(Ï‰)[h].fs  if DirIters(Ï‰)[h] defined
 âŠ¥                  otherwise
DirIterPath(Ï‰, h) =
 DirIters(Ï‰)[h].path  if DirIters(Ï‰)[h] defined
 "\""                 otherwise
DirIterEntries(Ï‰, h) =
 DirIters(Ï‰)[h].entries  if DirIters(Ï‰)[h] defined
 []                      otherwise
DirIterPos(Ï‰, h) =
 DirIters(Ï‰)[h].pos  if DirIters(Ï‰)[h] defined
 0                    otherwise
DirIterOpen(Ï‰, h) â‡” DirIters(Ï‰)[h] defined
Flushed(Ï‰, h) â‡” h âˆˆ FlushedSet(Ï‰)
FSJudg_Ï‰ = {FSOpenRead(fs, path, Ï‰) â‡“ (r, Ï‰'), FSOpenWrite(fs, path, Ï‰) â‡“ (r, Ï‰'), FSOpenAppend(fs, path, Ï‰) â‡“ (r, Ï‰'), FSCreateWrite(fs, path, Ï‰) â‡“ (r, Ï‰'), FSReadFile(fs, path, Ï‰) â‡“ (r, Ï‰'), FSReadBytes(fs, path, Ï‰) â‡“ (r, Ï‰'), FSWriteFile(fs, path, data, Ï‰) â‡“ (r, Ï‰'), FSWriteStdout(fs, data, Ï‰) â‡“ (r, Ï‰'), FSWriteStderr(fs, data, Ï‰) â‡“ (r, Ï‰'), FSExists(fs, path, Ï‰) â‡“ (b, Ï‰'), FSRemove(fs, path, Ï‰) â‡“ (r, Ï‰'), FSOpenDir(fs, path, Ï‰) â‡“ (r, Ï‰'), FSCreateDir(fs, path, Ï‰) â‡“ (r, Ï‰'), FSEnsureDir(fs, path, Ï‰) â‡“ (r, Ï‰'), FSKind(fs, path, Ï‰) â‡“ (r, Ï‰')}
FileJudg_Ï‰ = {FileReadAll(h, Ï‰) â‡“ (r, Ï‰'), FileReadAllBytes(h, Ï‰) â‡“ (r, Ï‰'), FileWrite(h, data, Ï‰) â‡“ (r, Ï‰'), FileFlush(h, Ï‰) â‡“ (r, Ï‰'), FileClose(h, Ï‰) â‡“ (ok, Ï‰')}
DirJudg_Ï‰ = {DirNext(h, Ï‰) â‡“ (r, Ï‰'), DirClose(h, Ï‰) â‡“ (ok, Ï‰')}

FSOpenRead(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSOpenRead(fs, path, Ï‰) â‡“ (r, Ï‰')
FSOpenWrite(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSOpenWrite(fs, path, Ï‰) â‡“ (r, Ï‰')
FSOpenAppend(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSOpenAppend(fs, path, Ï‰) â‡“ (r, Ï‰')
FSCreateWrite(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSCreateWrite(fs, path, Ï‰) â‡“ (r, Ï‰')
FSReadFile(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSReadFile(fs, path, Ï‰) â‡“ (r, Ï‰')
FSReadBytes(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSReadBytes(fs, path, Ï‰) â‡“ (r, Ï‰')
FSWriteFile(fs, path, data) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSWriteFile(fs, path, data, Ï‰) â‡“ (r, Ï‰')
FSWriteStdout(fs, data) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSWriteStdout(fs, data, Ï‰) â‡“ (r, Ï‰')
FSWriteStderr(fs, data) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSWriteStderr(fs, data, Ï‰) â‡“ (r, Ï‰')
FSExists(fs, path) â‡“ b â‡” âˆƒ Ï‰, Ï‰'. FSExists(fs, path, Ï‰) â‡“ (b, Ï‰')
FSRemove(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSRemove(fs, path, Ï‰) â‡“ (r, Ï‰')
FSOpenDir(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSOpenDir(fs, path, Ï‰) â‡“ (r, Ï‰')
FSCreateDir(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSCreateDir(fs, path, Ï‰) â‡“ (r, Ï‰')
FSEnsureDir(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSEnsureDir(fs, path, Ï‰) â‡“ (r, Ï‰')
FSKind(fs, path) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FSKind(fs, path, Ï‰) â‡“ (r, Ï‰')
FileReadAll(h) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FileReadAll(h, Ï‰) â‡“ (r, Ï‰')
FileReadAllBytes(h) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FileReadAllBytes(h, Ï‰) â‡“ (r, Ï‰')
FileWrite(h, data) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FileWrite(h, data, Ï‰) â‡“ (r, Ï‰')
FileFlush(h) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. FileFlush(h, Ï‰) â‡“ (r, Ï‰')
FileClose(h) â‡“ ok â‡” âˆƒ Ï‰, Ï‰'. FileClose(h, Ï‰) â‡“ (ok, Ï‰')
DirNext(h) â‡“ r â‡” âˆƒ Ï‰, Ï‰'. DirNext(h, Ï‰) â‡“ (r, Ï‰')
DirClose(h) â‡“ ok â‡” âˆƒ Ï‰, Ï‰'. DirClose(h, Ï‰) â‡“ (ok, Ï‰')

**Restriction Semantics.**

RestrictPath(base, path) = p â‡” Â¬ AbsPath(path) âˆ§ b = Canon(Normalize(base)) âˆ§ b â‰  âŠ¥ âˆ§ p = Canon(Normalize(Join(b, path))) âˆ§ p â‰  âŠ¥ âˆ§ prefix(p, b)
RestrictPath(base, path) = âŠ¥ â‡” AbsPath(path) âˆ¨ Canon(Normalize(base)) = âŠ¥ âˆ¨ Canon(Normalize(Join(Canon(Normalize(base)), path))) = âŠ¥ âˆ¨ Â¬ prefix(Canon(Normalize(Join(Canon(Normalize(base)), path))), Canon(Normalize(base)))
FSOp = {FSOpenRead, FSOpenWrite, FSOpenAppend, FSCreateWrite, FSReadFile, FSReadBytes, FSWriteFile, FSWriteStdout, FSWriteStderr, FSExists, FSRemove, FSOpenDir, FSCreateDir, FSEnsureDir, FSKind}
FSRestrict(fs, base) â‡“ fs' âˆ§ Op âˆˆ FSOp âˆ§ RestrictPath(base, p) = q â‡’ Op(fs', p) = Op(fs, q)
FSRestrict(fs, base) â‡“ fs' âˆ§ Op âˆˆ FSOp âˆ§ RestrictPath(base, p) = âŠ¥ âˆ§ Op â‰  FSExists â‡’ Op(fs', p) = IoError::InvalidPath
FSRestrict(fs, base) â‡“ fs' âˆ§ RestrictPath(base, p) = âŠ¥ â‡’ FSExists(fs', p) = false

**IoError Mapping.**

FSPathOp_0 = {FSOpenRead, FSOpenWrite, FSOpenAppend, FSCreateWrite, FSReadFile, FSReadBytes, FSExists, FSRemove, FSOpenDir, FSCreateDir, FSEnsureDir, FSKind}
FSPathOp_1 = {FSWriteFile}
FSRequiresExisting = {FSOpenRead, FSOpenWrite, FSOpenAppend, FSReadFile, FSReadBytes, FSOpenDir, FSKind, FSRemove}
PathInvalid(fs, path, Ï‰) â‡” Canon(Normalize(path)) = âŠ¥
EntryExists(Ï‰, path) â‡” Entries(Ï‰)[path] defined
EntryKind(Ï‰, path) âˆˆ {`File`, `Dir`, `Other`}
PermissionDenied(fs, path, Op, Ï‰) â‡” FailMap(Ï‰)[âŸ¨Op, pathâŸ©] = IoError::PermissionDenied
Busy(fs, path, Op, Ï‰) â‡” FailMap(Ï‰)[âŸ¨Op, pathâŸ©] = IoError::Busy
OtherFailure(fs, path, Op, Ï‰) â‡” FailMap(Ï‰)[âŸ¨Op, pathâŸ©] = IoError::IoFailure

Op âˆˆ FSPathOp_0 âˆ§ PathInvalid(fs, path, Ï‰) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::InvalidPath, Ï‰)
Op âˆˆ FSPathOp_1 âˆ§ PathInvalid(fs, path, Ï‰) â‡’ Op(fs, path, data, Ï‰) â‡“ (IoError::InvalidPath, Ï‰)
Op âˆˆ FSRequiresExisting âˆ§ Â¬ EntryExists(Ï‰, path) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::NotFound, Ï‰)
PermissionDenied(fs, path, Op, Ï‰) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::PermissionDenied, Ï‰)
Op = FSCreateWrite âˆ§ EntryExists(Ï‰, path) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::AlreadyExists, Ï‰)
Op âˆˆ {FSCreateDir, FSEnsureDir} âˆ§ EntryExists(Ï‰, path) âˆ§ EntryKind(Ï‰, path) â‰  `Dir` â‡’ Op(fs, path, Ï‰) â‡“ (IoError::AlreadyExists, Ï‰)
Op = FSOpenDir âˆ§ EntryExists(Ï‰, path) âˆ§ EntryKind(Ï‰, path) â‰  `Dir` â‡’ Op(fs, path, Ï‰) â‡“ (IoError::InvalidPath, Ï‰)
Busy(fs, path, Op, Ï‰) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::Busy, Ï‰)
OtherFailure(fs, path, Op, Ï‰) â‡’ Op(fs, path, Ï‰) â‡“ (IoError::IoFailure, Ï‰)

FSReadFile(fs, path, Ï‰) â‡“ (r, Ï‰') âˆ§ FSReadBytes(fs, path, Ï‰) â‡“ (bytes, Ï‰'') âˆ§ Â¬ Utf8Valid(bytes) â‡’ r = IoError::IoFailure
FileReadAll(h, Ï‰) â‡“ (r, Ï‰') âˆ§ FileReadAllBytes(h, Ï‰) â‡“ (bytes, Ï‰'') âˆ§ Â¬ Utf8Valid(bytes) â‡’ r = IoError::IoFailure

FSExists(fs, path, Ï‰) â‡“ (true, Ï‰') â‡’ EntryExists(Ï‰, path) âˆ§ Â¬ PathInvalid(fs, path, Ï‰)
FSExists(fs, path, Ï‰) â‡“ (false, Ï‰') â‡’ PathInvalid(fs, path, Ï‰) âˆ¨ Â¬ EntryExists(Ï‰, path)

**File and Directory Operation Semantics.**

HandleState = {`OpenRead`, `OpenWrite`, `OpenAppend`, `Closed`}
HandleOpen(Ï‰, h) â‡” HandleStateOf(Ï‰, h) â‰  `Closed`
HandleMode(Ï‰, h) =
 `Read`    if HandleStateOf(Ï‰, h) = `OpenRead`
 `Write`   if HandleStateOf(Ï‰, h) = `OpenWrite`
 `Append`  if HandleStateOf(Ï‰, h) = `OpenAppend`
FileLenAt(Ï‰, path) =
 ByteLen(bytes)  if Entries(Ï‰)[path] = FileEntry(bytes)
 0               otherwise
ByteLen(data) =
 |data|       if data âˆˆ Bytes
 |Utf8(data)| if data âˆˆ String
 0            otherwise

LexBytes(b_1, b_2) â‡” (âˆƒ k. 0 â‰¤ k < min(|b_1|, |b_2|) âˆ§ (âˆ€ i < k. b_1[i] = b_2[i]) âˆ§ b_1[k] < b_2[k]) âˆ¨ (|b_1| < |b_2| âˆ§ âˆ€ i < |b_1|. b_1[i] = b_2[i])
EntryKey(name) = CaseFold(NFC(name))
EntryOrder(a, b) â‡” LexBytes(Utf8(EntryKey(a)), Utf8(EntryKey(b))) âˆ¨ (EntryKey(a) = EntryKey(b) âˆ§ LexBytes(Utf8(a), Utf8(b)))
DirSnapshot(fs, path, Ï‰) =
 DirNames(Ï‰, path)  if Entries(Ï‰)[path] = DirEntry(_)
 []                 otherwise
DirEntries(fs, path, Ï‰) = sort_{EntryOrder}(DirSnapshot(fs, path, Ï‰))
âˆ€ name âˆˆ DirSnapshot(fs, path, Ï‰). name â‰  "." âˆ§ name â‰  ".."

FSOpenRead(fs, path, Ï‰) â‡“ (`File@Read`{`handle`: h}, Ï‰') â‡’ HandleStateOf(Ï‰', h) = `OpenRead` âˆ§ HandlePos(Ï‰', h) = 0 âˆ§ HandlePath(Ï‰', h) = path âˆ§ HandleLen(Ï‰', h) = FileLenAt(Ï‰, path)
FSOpenWrite(fs, path, Ï‰) â‡“ (`File@Write`{`handle`: h}, Ï‰') â‡’ HandleStateOf(Ï‰', h) = `OpenWrite` âˆ§ HandlePos(Ï‰', h) = 0 âˆ§ HandlePath(Ï‰', h) = path âˆ§ HandleLen(Ï‰', h) = FileLenAt(Ï‰, path)
FSOpenAppend(fs, path, Ï‰) â‡“ (`File@Append`{`handle`: h}, Ï‰') â‡’ HandleStateOf(Ï‰', h) = `OpenAppend` âˆ§ HandlePos(Ï‰', h) = FileLenAt(Ï‰, path) âˆ§ HandlePath(Ï‰', h) = path âˆ§ HandleLen(Ï‰', h) = FileLenAt(Ï‰, path)
FSCreateWrite(fs, path, Ï‰) â‡“ (`File@Write`{`handle`: h}, Ï‰') â‡’ HandleStateOf(Ï‰', h) = `OpenWrite` âˆ§ HandlePos(Ï‰', h) = 0 âˆ§ HandlePath(Ï‰', h) = path âˆ§ HandleLen(Ï‰', h) = 0

FSReadFile(fs, path, Ï‰) â‡“ (r, Ï‰') â‡” âˆƒ h, Ï‰_1, Ï‰_2. FSOpenRead(fs, path, Ï‰) â‡“ (`File@Read`{`handle`: h}, Ï‰_1) âˆ§ FileReadAll(h, Ï‰_1) â‡“ (r, Ï‰_2) âˆ§ FileClose(h, Ï‰_2) â‡“ (ok, Ï‰')
FSReadBytes(fs, path, Ï‰) â‡“ (r, Ï‰') â‡” âˆƒ h, Ï‰_1, Ï‰_2. FSOpenRead(fs, path, Ï‰) â‡“ (`File@Read`{`handle`: h}, Ï‰_1) âˆ§ FileReadAllBytes(h, Ï‰_1) â‡“ (r, Ï‰_2) âˆ§ FileClose(h, Ï‰_2) â‡“ (ok, Ï‰')

Â¬ HandleOpen(Ï‰, h) â‡’ FileReadAll(h, Ï‰) â‡“ (IoError::IoFailure, Ï‰)
Â¬ HandleOpen(Ï‰, h) â‡’ FileReadAllBytes(h, Ï‰) â‡“ (IoError::IoFailure, Ï‰)
Â¬ HandleOpen(Ï‰, h) â‡’ FileWrite(h, data, Ï‰) â‡“ (IoError::IoFailure, Ï‰)
Â¬ HandleOpen(Ï‰, h) â‡’ FileFlush(h, Ï‰) â‡“ (IoError::IoFailure, Ï‰)

FileReadAll(h, Ï‰) â‡“ (r, Ï‰') âˆ§ r â‰  IoError::IoFailure â‡’ HandlePos(Ï‰', h) = HandleLen(Ï‰, h)
FileReadAllBytes(h, Ï‰) â‡“ (r, Ï‰') âˆ§ r â‰  IoError::IoFailure â‡’ HandlePos(Ï‰', h) = HandleLen(Ï‰, h)

FileWrite(h, data, Ï‰) â‡“ (ok, Ï‰') â‡’ HandleOpen(Ï‰, h) âˆ§ (HandleMode(Ï‰, h) = `Append` â‡’ HandlePos(Ï‰', h) = HandleLen(Ï‰, h) + ByteLen(data)) âˆ§ (HandleMode(Ï‰, h) â‰  `Append` â‡’ HandlePos(Ï‰', h) = HandlePos(Ï‰, h) + ByteLen(data))
FileWrite(h, data, Ï‰) â‡“ (ok, Ï‰') â‡’ HandleLen(Ï‰', h) = max(HandleLen(Ï‰, h), HandlePos(Ï‰', h))

FileFlush(h, Ï‰) â‡“ (ok, Ï‰') â‡’ Flushed(Ï‰', h)
FileClose(h, Ï‰) â‡“ (ok, Ï‰') â‡’ HandleStateOf(Ï‰', h) = `Closed`

FSOpenDir(fs, path, Ï‰) â‡“ (`DirIter@Open`{`handle`: h}, Ï‰') â‡’ DirIterOpen(Ï‰', h) âˆ§ DirIterFS(Ï‰', h) = fs âˆ§ DirIterPath(Ï‰', h) = path âˆ§ DirIterEntries(Ï‰', h) = DirEntries(fs, path, Ï‰) âˆ§ DirIterPos(Ï‰', h) = 0

Â¬ DirIterOpen(Ï‰, h) â‡’ DirNext(h, Ï‰) â‡“ (IoError::IoFailure, Ï‰)
DirIterOpen(Ï‰, h) âˆ§ DirIterPos(Ï‰, h) = i âˆ§ i â‰¥ |DirIterEntries(Ï‰, h)| â‡’ DirNext(h, Ï‰) â‡“ ((), Ï‰)
DirIterOpen(Ï‰, h) âˆ§ DirIterPos(Ï‰, h) = i âˆ§ i < |DirIterEntries(Ï‰, h)| âˆ§ name = DirIterEntries(Ï‰, h)[i] âˆ§ path = Join(DirIterPath(Ï‰, h), name) âˆ§ FSKind(DirIterFS(Ï‰, h), path, Ï‰) â‡“ (k, Ï‰_1) â‡’ DirNext(h, Ï‰) â‡“ (`DirEntry`{`path`: path, `name`: name, `kind`: k}, Ï‰_2) âˆ§ DirIterPos(Ï‰_2, h) = i + 1

DirClose(h, Ï‰) â‡“ (ok, Ï‰') â‡’ Â¬ DirIterOpen(Ï‰', h)

**System Operations.**

SysState = âŸ¨env, exit_code_optâŸ©
Env(âŸ¨env, exit_code_optâŸ©) = env
ExitCode(âŸ¨env, exit_code_optâŸ©) = exit_code_opt
SetExitCode(âŸ¨env, _âŸ©, code) = âŸ¨env, codeâŸ©

SystemJudg = {SystemGetEnv(key) â‡“ r, SystemExit(code) â‡“ ok}
SystemJudg_sys = {SystemGetEnv(key, sys) â‡“ (r, sys'), SystemExit(code, sys) â‡“ sys'}

SystemGetEnv(key) â‡“ r â‡” âˆƒ sys, sys'. SystemGetEnv(key, sys) â‡“ (r, sys')
SystemExit(code) â‡“ ok â‡” âˆƒ sys, sys'. SystemExit(code, sys) â‡“ sys'

EmptyStringVal = v â‡” âˆƒ lit. lit.kind = StringLiteral âˆ§ StringBytes(lit) = [] âˆ§ LiteralValue(lit, TypeString(`@View`)) = v

**(System-GetEnv-Ok)**
Env(sys)[key] = v
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SystemGetEnv(key, sys) â‡“ (v, sys)

**(System-GetEnv-None)**
key âˆ‰ dom(Env(sys))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SystemGetEnv(key, sys) â‡“ (v, sys)    EmptyStringVal = v

**(System-Exit)**
sys' = SetExitCode(sys, code)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SystemExit(code, sys) â‡“ sys'

**Handle Extraction.**

HandleOf(v) = h â‡” v = `File@Read`{`handle`: h} âˆ¨ v = `File@Write`{`handle`: h} âˆ¨ v = `File@Append`{`handle`: h}
DirHandleOf(v) = h â‡” v = `DirIter@Open`{`handle`: h}

**Primitive Method Application.**

MethodName(MethodDecl(_, _, _, name, _, _, _, _, _, _, _, _)) = name
MethodName(ClassMethodDecl(_, _, name, _, _, _, _, _, _, _, _)) = name
MethodName(StateMethodDecl(_, _, name, _, _, _, _, _, _, _, _)) = name
MethodName(TransitionDecl(_, _, name, _, _, _, _, _)) = name
MethodOwner(m) = owner â‡” âˆƒ T. MethodByName(T, MethodName(m)) = m âˆ§ owner = T
MethodOwner(m) = ModalStateRef(modal_ref, S) â‡” ModalDeclOf(modal_ref) = M âˆ§ (m âˆˆ Methods(M, S) âˆ¨ m âˆˆ Transitions(M, S))
PrimCallJudg = {PrimCall(Owner, name, v_self, args) â‡“ out}

**(Prim-FS-OpenRead)**
Î“ âŠ¢ FSOpenRead(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `open_read`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-OpenWrite)**
Î“ âŠ¢ FSOpenWrite(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `open_write`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-OpenAppend)**
Î“ âŠ¢ FSOpenAppend(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `open_append`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-CreateWrite)**
Î“ âŠ¢ FSCreateWrite(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `create_write`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-ReadFile)**
Î“ âŠ¢ FSReadFile(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `read_file`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-ReadBytes)**
Î“ âŠ¢ FSReadBytes(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `read_bytes`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-WriteFile)**
Î“ âŠ¢ FSWriteFile(v_fs, p, d) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `write_file`, v_fs, [p, d]) â‡“ Val(r)

**(Prim-FS-WriteStdout)**
Î“ âŠ¢ FSWriteStdout(v_fs, d) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `write_stdout`, v_fs, [d]) â‡“ Val(r)

**(Prim-FS-WriteStderr)**
Î“ âŠ¢ FSWriteStderr(v_fs, d) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `write_stderr`, v_fs, [d]) â‡“ Val(r)

**(Prim-FS-Exists)**
Î“ âŠ¢ FSExists(v_fs, p) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `exists`, v_fs, [p]) â‡“ Val(b)

**(Prim-FS-Remove)**
Î“ âŠ¢ FSRemove(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `remove`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-OpenDir)**
Î“ âŠ¢ FSOpenDir(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `open_dir`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-CreateDir)**
Î“ âŠ¢ FSCreateDir(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `create_dir`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-EnsureDir)**
Î“ âŠ¢ FSEnsureDir(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `ensure_dir`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-Kind)**
Î“ âŠ¢ FSKind(v_fs, p) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `kind`, v_fs, [p]) â‡“ Val(r)

**(Prim-FS-Restrict)**
Î“ âŠ¢ FSRestrict(v_fs, p) â‡“ v_fs'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`FileSystem`, `restrict`, v_fs, [p]) â‡“ Val(v_fs')

**(Prim-File-ReadAll)**
HandleOf(v) = h    Î“ âŠ¢ FileReadAll(h) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Read`), `read_all`, v, []) â‡“ Val(r)

**(Prim-File-ReadAllBytes)**
HandleOf(v) = h    Î“ âŠ¢ FileReadAllBytes(h) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Read`), `read_all_bytes`, v, []) â‡“ Val(r)

**(Prim-File-Write)**
HandleOf(v) = h    Î“ âŠ¢ FileWrite(h, d) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Write`), `write`, v, [d]) â‡“ Val(r)

**(Prim-File-Flush)**
HandleOf(v) = h    Î“ âŠ¢ FileFlush(h) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Write`), `flush`, v, []) â‡“ Val(r)

**(Prim-File-Write-Append)**
HandleOf(v) = h    Î“ âŠ¢ FileWrite(h, d) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Append`), `write`, v, [d]) â‡“ Val(r)

**(Prim-File-Flush-Append)**
HandleOf(v) = h    Î“ âŠ¢ FileFlush(h) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Append`), `flush`, v, []) â‡“ Val(r)

**(Prim-File-Close-Read)**
HandleOf(v) = h    Î“ âŠ¢ FileClose(h) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Read`), `close`, v, []) â‡“ Val(`File@Closed`{})

**(Prim-File-Close-Write)**
HandleOf(v) = h    Î“ âŠ¢ FileClose(h) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Write`), `close`, v, []) â‡“ Val(`File@Closed`{})

**(Prim-File-Close-Append)**
HandleOf(v) = h    Î“ âŠ¢ FileClose(h) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["File"], `@Append`), `close`, v, []) â‡“ Val(`File@Closed`{})

**(Prim-Dir-Next)**
DirHandleOf(v) = h    Î“ âŠ¢ DirNext(h) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["DirIter"], `@Open`), `next`, v, []) â‡“ Val(r)

**(Prim-Dir-Close)**
DirHandleOf(v) = h    Î“ âŠ¢ DirClose(h) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["DirIter"], `@Open`), `close`, v, []) â‡“ Val(`DirIter@Closed`{})

**(Prim-Cancel-Cancel)**
Î“ âŠ¢ CancelDoCancel(v) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["CancelToken"], `@Active`), `cancel`, v, []) â‡“ Val(())

**(Prim-Cancel-IsCancelled-Active)**
Î“ âŠ¢ CancelIsCancelled(v) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["CancelToken"], `@Active`), `is_cancelled`, v, []) â‡“ Val(b)

**(Prim-Cancel-IsCancelled-Cancelled)**
Î“ âŠ¢ CancelIsCancelled(v) â‡“ b
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["CancelToken"], `@Cancelled`), `is_cancelled`, v, []) â‡“ Val(b)

**(Prim-Cancel-Child)**
Î“ âŠ¢ CancelChild(v) â‡“ v_c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["CancelToken"], `@Active`), `child`, v, []) â‡“ Val(v_c)

**(Prim-Cancel-WaitCancelled)**
Î“ âŠ¢ CancelWaitCancelled(v) â‡“ v_a
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(ModalStateRef(["CancelToken"], `@Active`), `wait_cancelled`, v, []) â‡“ Val(v_a)

**(Prim-System-GetEnv)**
Î“ âŠ¢ SystemGetEnv(k) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`System`, `get_env`, v_sys, [k]) â‡“ Val(r)

**(Prim-System-Exit)**
Î“ âŠ¢ SystemExit(code) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`System`, `exit`, v_sys, [code]) â‡“ Ctrl(Abort)

When `PrimCall(System, exit, ...)` yields `Ctrl(Abort)`, program execution terminates and the observable exit status is `code`.

**Heap Allocator Operations**

HeapJudg = {HeapWithQuota(v_heap, quota) â‡“ v_heap', HeapAllocRaw(v_heap, count) â‡“ ptr, HeapDeallocRaw(v_heap, ptr, count) â‡“ ok}

`HeapWithQuota`, `HeapAllocRaw`, and `HeapDeallocRaw` are runtime host-primitive relations. Their concrete behavior is implementation-defined, but a conforming implementation MUST satisfy the attenuation requirements in Â§1.3.3:
- `HeapWithQuota(v_heap, q)` MUST NOT yield an allocator whose effective quota exceeds that of `v_heap`.
- Allocations performed through an allocator derived by `with_quota` MUST respect that quota (by trapping, returning null, or failing in an implementation-defined manner for the unsafe raw interface).

**(Prim-Heap-WithQuota)**
Î“ âŠ¢ HeapWithQuota(v_heap, quota) â‡“ v_heap'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`HeapAllocator`, `with_quota`, v_heap, [quota]) â‡“ Val(v_heap')

**(Prim-Heap-AllocRaw)**
Î“ âŠ¢ HeapAllocRaw(v_heap, count) â‡“ ptr
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`HeapAllocator`, `alloc_raw`, v_heap, [count]) â‡“ Val(ptr)

**(Prim-Heap-DeallocRaw)**
Î“ âŠ¢ HeapDeallocRaw(v_heap, ptr, count) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`HeapAllocator`, `dealloc_raw`, v_heap, [ptr, count]) â‡“ Val(UnitVal)

**Reactor Operations**

ReactorJudg = {ReactorRun(v_reactor, f) â‡“ r, ReactorRegister(v_reactor, f) â‡“ h}

`ReactorRun` and `ReactorRegister` are runtime host-primitive relations that interface the async model (Â§19) with a concrete event loop.

**(Prim-Reactor-Run)**
Î“ âŠ¢ ReactorRun(v_reactor, f) â‡“ r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`Reactor`, `run`, v_reactor, [f]) â‡“ Val(r)

**(Prim-Reactor-Register)**
Î“ âŠ¢ ReactorRegister(v_reactor, f) â‡“ h
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ PrimCall(`Reactor`, `register`, v_reactor, [f]) â‡“ Val(h)

**(ApplyMethod-Prim)**
MethodOwner(m) = owner    MethodName(m) = name    Î“ âŠ¢ PrimCall(owner, name, v_self, vec_v) â‡“ out
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ApplyMethod(m, v_self, vec_v) â‡“ out

**(ApplyMethod-Prim-Step)**
MethodOwner(m) = owner    MethodName(m) = name    Î“ âŠ¢ PrimCall(owner, name, v_self, vec_v) â‡“ out
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨ApplyMethod(m, v_self, vec_v)âŸ© â†’ âŸ¨outâŸ©

### 7.8. Interpreter Entrypoint (Project-Level)

**Interpreter Judgments.**

InterpJudg = {Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ'), Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡“ (out, Ïƒ'), Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡‘ panic(P_s)}
ContextValue(v) â‡” âˆƒ bits. ValueBits(TypePath(["Context"]), v) = bits

**(ContextInitSigma)**
ContextValue(v_ctx)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ)

**(Interpret-Project-Ok)**
Executable(P)    MainDecls(P) = [d]    MainSigOk(d)    Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ_0)    Î“ âŠ¢ Init(G_e, Ïƒ_0) â‡“ Ïƒ_1    Î“ âŠ¢ ApplyProcSigma(d, [v_ctx], Ïƒ_1) â‡“ (Val(v), Ïƒ_2)    Î“ âŠ¢ Deinit(P, Ïƒ_2) â‡“ Ïƒ_3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡“ (Val(v), Ïƒ_3)

**(Interpret-Project-Init-Panic)**
Executable(P)    MainDecls(P) = [d]    MainSigOk(d)    Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ_0)    Î“ âŠ¢ Init(G_e, Ïƒ_0) â‡‘ panic(P_s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡‘ panic(P_s)

**(Interpret-Project-Main-Ctrl)**
Executable(P)    MainDecls(P) = [d]    MainSigOk(d)    Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ_0)    Î“ âŠ¢ Init(G_e, Ïƒ_0) â‡“ Ïƒ_1    Î“ âŠ¢ ApplyProcSigma(d, [v_ctx], Ïƒ_1) â‡“ (Ctrl(Îº), Ïƒ_2)    Îº âˆˆ {Panic, Abort}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡“ (Ctrl(Îº), Ïƒ_2)

**(Interpret-Project-Deinit-Panic)**
Executable(P)    MainDecls(P) = [d]    MainSigOk(d)    Î“ âŠ¢ ContextInitSigma(Ïƒ) â‡“ (Val(v_ctx), Ïƒ_0)    Î“ âŠ¢ Init(G_e, Ïƒ_0) â‡“ Ïƒ_1    Î“ âŠ¢ ApplyProcSigma(d, [v_ctx], Ïƒ_1) â‡“ (Val(v), Ïƒ_2)    Î“ âŠ¢ Deinit(P, Ïƒ_2) â‡‘ panic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ InterpretProject(P, Ïƒ) â‡‘ panic
## 8. Appendix A - Diagnostic Codes

### 8.0. DiagIdÃ¢â‚¬â€œCode Map

DiagTable = {`E-PRJ`, `E-MOD`, `E-OUT`, `E-SRC`, `E-CNF`, `W-CNF`, `E-UNS`, `E-MEM`, `E-CON`, `I-CON`, `W-CON`, `E-SYS`, `W-MOD`, `W-SRC`, `E-TYP`, `W-SYS`, `E-SEM`, `W-SEM`, `P-TYP`, `P-SEM`}
DiagRow = âŸ¨code, sev, det, cond, idsâŸ©
RowCode(âŸ¨code, sev, det, cond, idsâŸ©) = code
RowSev(âŸ¨code, sev, det, cond, idsâŸ©) = sev
RowDet(âŸ¨code, sev, det, cond, idsâŸ©) = det
RowCond(âŸ¨code, sev, det, cond, idsâŸ©) = cond
RowIds(âŸ¨code, sev, det, cond, idsâŸ©) = ids
SeverityColumn(c) = sev â‡” âˆƒ row âˆˆ DiagRows. RowCode(row) = c âˆ§ RowSev(row) = sev
ConditionColumn(c) = cond â‡” âˆƒ row âˆˆ DiagRows. RowCode(row) = c âˆ§ RowCond(row) = cond
TableRows(t) = {row | row appears in table t}
DiagRows = â‹ƒ_{t âˆˆ DiagTable} TableRows(t)
C0Code(id) = c â‡” âˆƒ row âˆˆ DiagRows. id âˆˆ RowIds(row) âˆ§ RowCode(row) = c
C0Code(id) = âŠ¥ â‡” Â¬ âˆƒ row âˆˆ DiagRows. id âˆˆ RowIds(row)

### 8.1. E-PRJ (Project)

| Code         | Severity | Detection    | Condition                                                                                   | DiagId                                                                                             |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| `E-PRJ-0101` | Error    | Compile-time | `Cursive.toml` not found at project root                                                    | Parse-Manifest-Missing                                                                             |
| `E-PRJ-0102` | Error    | Compile-time | `Cursive.toml` is not valid TOML                                                            | Parse-Manifest-Err                                                                                 |
| `E-PRJ-0103` | Error    | Compile-time | Missing required `assembly` table, empty assembly list, required keys, or required key type | WF-Assembly-Table-Err, WF-Assembly-Count-Err, WF-Assembly-Required-Types-Err                       |
| `E-PRJ-0104` | Error    | Compile-time | Unknown key in `assembly` table or unknown top-level key                                    | WF-Assembly-Keys-Err, WF-TopKeys-Err                                                               |
| `E-PRJ-0201` | Error    | Compile-time | `assembly.kind` is not in `{ "executable", "library" }`                                     | WF-Assembly-Kind-Err                                                                               |
| `E-PRJ-0202` | Error    | Compile-time | Duplicate `assembly.name` values                                                            | WF-Assembly-Name-Dup                                                                               |
| `E-PRJ-0203` | Error    | Compile-time | `assembly.name` is not a valid identifier                                                   | WF-Assembly-Name-Err                                                                               |
| `E-PRJ-0204` | Error    | Compile-time | `emit_ir` has invalid value or type                                                         | WF-Assembly-EmitIR-Err, WF-Assembly-EmitIRType-Err                                                 |
| `E-PRJ-0205` | Error    | Compile-time | Assembly selection failed (missing target or target not found)                              | Assembly-Select-Err                                                                                |
| `E-PRJ-0301` | Error    | Compile-time | `assembly.root` or `out_dir` has invalid type, is absolute, or resolves outside root        | WF-Assembly-Root-Path-Err, WF-Assembly-OutDir-Path-Err, WF-Assembly-OutDirType-Err, WF-RelPath-Err |
| `E-PRJ-0302` | Error    | Compile-time | `assembly.root` does not exist or is not a directory                                        | WF-Source-Root-Err                                                                                 |
| `E-PRJ-0303` | Error    | Compile-time | Relative path derivation failed during deterministic ordering (file or directory)           | FileOrder-Rel-Fail, DirSeq-Rel-Fail                                                                |
| `E-PRJ-0304` | Error    | Compile-time | Path canonicalization or module path derivation failed due to filesystem error              | Disc-Rel-Fail, Resolve-Canonical-Err                                                               |
| `E-PRJ-0305` | Error    | Compile-time | Directory enumeration failed during module discovery                                        | DirSeq-Read-Err                                                                                    |

### 8.2. E-MOD (Module)

| Code         | Severity | Detection    | Condition                                                       | DiagId                                                                                                                                 |
| ------------ | -------- | ------------ | --------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `E-MOD-1104` | Error    | Compile-time | Module path collision after NFC + case folding                  | WF-Module-Path-Collision, Disc-Collision                                                                                               |
| `E-MOD-1105` | Error    | Compile-time | Module path component is a reserved keyword                     | WF-Module-Path-Reserved                                                                                                                |
| `E-MOD-1106` | Error    | Compile-time | Module path component is not a valid identifier                 | WF-Module-Path-Ident-Err                                                                                                               |
| `E-MOD-1201` | Error    | Compile-time | External `using` path without required `import`                 | Import-Using-Missing                                                                                                                   |
| `E-MOD-1202` | Error    | Compile-time | Import of non-existent assembly or module                       | Resolve-Import-Err                                                                                                                     |
| `E-MOD-1203` | Error    | Compile-time | Name introduced by `using` or `import as` conflicts with existing | Import-Using-Name-Conflict                                                                                                             |
| `E-MOD-1204` | Error    | Compile-time | Using path does not resolve to a module or item                 | Resolve-Using-None                                                                                                                     |
| `E-MOD-1205` | Error    | Compile-time | Attempt to `public using` a non-public item                     | Using-Path-Item-Public-Err, Using-List-Public-Err                                                                                      |
| `E-MOD-1206` | Error    | Compile-time | Duplicate item in a `using` list                                | Using-List-Dup                                                                                                                         |
| `E-MOD-1207` | Error    | Compile-time | Cannot access a non-public item from this scope                 | Access-Err                                                                                                                             |
| `E-MOD-1208` | Error    | Compile-time | Using path is ambiguous between module and item                 | Resolve-Using-Ambig                                                                                                                    |
| `E-MOD-1301` | Error    | Compile-time | Unresolved name: identifier not found in any accessible scope   | ResolveExpr-Ident-Err, ResolveQual-Name-Err, ResolveQual-Apply-Err, ResolveQual-Apply-Brace-Err, Expr-Unresolved-Err                   |
| `E-MOD-1302` | Error    | Compile-time | Duplicate declaration in module scope                           | Collect-Dup, Names-Step-Dup                                                                                                            |
| `E-MOD-1303` | Error    | Compile-time | Shadowing without `shadow` keyword                              | Intro-Shadow-Required                                                                                                                  |
| `E-MOD-1304` | Error    | Compile-time | Unresolved module: path prefix did not resolve to a module      | ResolveModulePath-Err                                                                                                                  |
| `E-MOD-1306` | Error    | Compile-time | Unnecessary `shadow` keyword: no binding is being shadowed      | Shadow-Unnecessary                                                                                                                     |
| `E-MOD-1307` | Error    | Compile-time | Ambiguous method resolution; disambiguation required            | LookupMethod-Ambig                                                                                                                     |
| `E-MOD-1401` | Error    | Compile-time | Cyclic module dependency detected in eager initializers         | Topo-Cycle                                                                                                                             |
| `E-MOD-2401` | Error    | Compile-time | Reassignment of immutable `let` binding                         | Assign-Immutable-Err                                                                                                                   |
| `E-MOD-2402` | Error    | Compile-time | Type annotation incompatible with inferred type                 | WF-StaticDecl-Ann-Mismatch, T-LetStmt-Ann-Mismatch, T-VarStmt-Ann-Mismatch, T-ShadowLetStmt-Ann-Mismatch, T-ShadowVarStmt-Ann-Mismatch |
| `E-MOD-2411` | Error    | Compile-time | Missing move expression at call site for transferring parameter | B-ArgPass-Move-Missing                                                                                                                 |
| `E-MOD-2430` | Error    | Compile-time | Multiple `main` procedures defined                              | Main-Multiple                                                                                                                          |
| `E-MOD-2431` | Error    | Compile-time | Invalid `main` signature                                        | Main-Signature-Err                                                                                                                     |
| `E-MOD-2432` | Error    | Compile-time | `main` is generic (has type parameters)                         | Main-Generic-Err                                                                                                                       |
| `E-MOD-2433` | Error    | Compile-time | Module-scope `var` declaration with `public` visibility         | StaticVisOk-Err                                                                                                                        |
| `E-MOD-2434` | Error    | Compile-time | Missing `main` procedure                                        | Main-Missing                                                                                                                           |
| `E-MOD-2440` | Error    | Compile-time | `protected` used on top-level declaration                       | Protected-TopLevel-Err                                                                                                                 |
| `E-MOD-2450` | Error    | Compile-time | Malformed attribute syntax                                      | Attr-Syntax-Err                                                                                                                        |
| `E-MOD-2451` | Error    | Compile-time | Unknown attribute name                                          | Attr-Unknown                                                                                                                           |
| `E-MOD-2452` | Error    | Compile-time | Attribute not valid on target declaration kind                  | Attr-Target-Err                                                                                                                        |
| `E-MOD-2453` | Error    | Compile-time | `align(N)` where N is not a power of two                        | Attr-Align-NotPow2                                                                                                                     |
| `E-MOD-2454` | Error    | Compile-time | `packed` applied to non-record                                  | Attr-Packed-NonRecord                                                                                                                  |
| `E-MOD-2455` | Error    | Compile-time | Conflicting layout arguments                                    | Attr-Layout-Conflict                                                                                                                   |

### 8.3. E-OUT (Output and Linking)

| Code         | Severity | Detection    | Condition                                                                | DiagId                                                                           |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |
| `E-OUT-0401` | Error    | Compile-time | Failed to create output directory                                        | Out-Dirs-Err                                                                     |
| `E-OUT-0402` | Error    | Compile-time | Failed to emit object file (codegen or write)                            | Out-Obj-Err, EmitObj-Err                                                         |
| `E-OUT-0403` | Error    | Compile-time | Failed to emit IR/bitcode (codegen, assemble, tool resolution, or write) | Out-IR-Err, EmitLLVM-Err                                                         |
| `E-OUT-0404` | Error    | Compile-time | Linker invocation failed                                                 | Out-Link-Fail                                                                    |
| `E-OUT-0405` | Error    | Compile-time | Required linker tool not found                                           | Out-Link-NotFound                                                                |
| `E-OUT-0406` | Error    | Compile-time | Output path collision detected                                           | Out-Obj-Collision, Out-IR-Collision                                              |
| `E-OUT-0407` | Error    | Compile-time | Runtime library missing or unreadable                                    | Out-Link-Runtime-Missing                                                         |
| `E-OUT-0408` | Error    | Compile-time | Runtime library missing required symbol(s)                               | Out-Link-Runtime-Incompatible                                                    |
| `E-OUT-0410` | Error    | Compile-time | LLVM type mapping failed                                                 | LLVMTy-Err                                                                       |
| `E-OUT-0411` | Error    | Compile-time | LLVM IR lowering failed                                                  | LowerIR-Err, LowerIRDecl-Err, LowerIRInstr-Err                                   |
| `E-OUT-0412` | Error    | Compile-time | Binding storage/validity lowering failed                                 | BindSlot-Err, BindValid-Err, UpdateValid-Err, DropOnAssign-Err                   |
| `E-OUT-0413` | Error    | Compile-time | LLVM call ABI lowering failed                                            | LLVMCall-Err, LLVMArgLower-Err, LLVMRetLower-Err                                 |
| `E-OUT-0414` | Error    | Compile-time | VTable emission failed                                                   | EmitVTable-Err                                                                   |
| `E-OUT-0415` | Error    | Compile-time | Literal data emission failed                                             | EmitLiteral-Err                                                                  |
| `E-OUT-0416` | Error    | Compile-time | Runtime built-in symbol resolution failed                                | BuiltinSym-String-Err, BuiltinSym-Bytes-Err, StringDropSym-Err, BytesDropSym-Err |
| `E-OUT-0417` | Error    | Compile-time | Entrypoint or context construction lowering failed                       | EntrySym-Err, EntryStub-Err, EmitInitPlan-Err, EmitDeinitPlan-Err                |
| `E-OUT-0418` | Error    | Compile-time | Poisoning instrumentation failed                                         | PoisonFlag-Err, CheckPoison-Err, SetPoison-Err                                   |

### 8.4. E-SRC (Source)

| Code         | Severity | Detection    | Condition                                                    | DiagId                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------ | ---------------------------------------- |
| `E-SRC-0101` | Error    | Compile-time | Invalid UTF-8 byte sequence                                  | Step-Decode-Err                          |
| `E-SRC-0102` | Error    | Compile-time | Failed to read source file                                   | ReadBytes-Err                            |
| `E-SRC-0103` | Error    | Compile-time | Embedded BOM found after the first position                  | Step-EmbeddedBOM-Err                     |
| `E-SRC-0104` | Error    | Compile-time | Forbidden control character or null byte                     | Step-Prohibited-Err                      |
| `E-SRC-0301` | Error    | Compile-time | Unterminated string literal                                  | Lex-String-Unterminated                  |
| `E-SRC-0302` | Error    | Compile-time | Invalid escape sequence                                      | Lex-String-BadEscape, Lex-Char-BadEscape |
| `E-SRC-0303` | Error    | Compile-time | Invalid character literal                                    | Lex-Char-Invalid, Lex-Char-Unterminated  |
| `E-SRC-0304` | Error    | Compile-time | Malformed numeric literal                                    | Lex-Numeric-Err                          |
| `E-SRC-0306` | Error    | Compile-time | Unterminated block comment                                   | Block-Comment-Unterminated               |
| `E-SRC-0307` | Error    | Compile-time | Invalid Unicode in identifier                                | Lex-Ident-InvalidUnicode                 |
| `E-SRC-0308` | Error    | Compile-time | Lexically sensitive Unicode character outside `unsafe` block | LexSecure-Err                            |
| `E-SRC-0309` | Error    | Compile-time | Tokenization failed to classify a character sequence         | Max-Munch-Err                            |
| `E-SRC-0510` | Error    | Compile-time | Missing statement terminator                                 | Missing-Terminator-Err                   |
| `E-SRC-0520` | Error    | Compile-time | Generic syntax error (unexpected token)                      | Parse-Syntax-Err                         |
| `E-SRC-0521` | Error    | Compile-time | Trailing comma in single-line list                           | Trailing-Comma-Err                       |

### 8.5. E-CNF (Conformance / Limits)

| Code         | Severity | Detection    | Condition                                                                                                            | DiagId                                                                                    |
| ------------ | -------- | ------------ | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `E-CNF-0401` | Error    | Compile-time | Reserved keyword used as identifier                                                                                  | Validate-Module-Keyword-Err                                                               |
| `E-CNF-0402` | Error    | Compile-time | Reserved namespace `cursive.*` used by user code                                                                     | Validate-ModulePath-Reserved-Err, Intro-Reserved-Cursive-Err, Shadow-Reserved-Cursive-Err |
| `E-CNF-0403` | Error    | Compile-time | Primitive type name shadowed at module scope                                                                         | Validate-Module-Prim-Shadow-Err                                                           |
| `E-CNF-0404` | Error    | Compile-time | Shadowing of `Self`, `Drop`, `Bitcopy`, `Clone`, `Eq`, `Hash`, `Hasher`, `Iterator`, `Step`, `FfiSafe`, `string`, `bytes`, `Modal`, `Region`, `RegionOptions`, `CancelToken`, `Context`, `System`, `ExecutionDomain`, `CpuSet`, `Priority`, or `Reactor` | Validate-Module-Special-Shadow-Err                                                        |
| `E-CNF-0405` | Error    | Compile-time | Shadowing of async type alias (`Async`, `Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`, `Tracked`)               | Validate-Module-Async-Shadow-Err                                                          |
| `E-CNF-0406` | Error    | Compile-time | User declaration uses `gen_` prefix                                                                                  | Intro-Reserved-Gen-Err, Shadow-Reserved-Gen-Err                                           |

### 8.6. W-CNF (Conformance Warnings)

| Code         | Severity | Detection    | Condition                                                     |
| ------------ | -------- | ------------ | ------------------------------------------------------------- |
| `W-CNF-0601` | Warning  | Compile-time | Reference to declaration marked `[[deprecated]]`             |

### 8.7. E-UNS (Unsupported Constructs)

| Code         | Severity | Detection    | Condition                                              | DiagId                   |
| ------------ | -------- | ------------ | ------------------------------------------------------ | ------------------------ |
| `E-UNS-0101` | Error    | Compile-time | Unsupported construct in Cursive0 subset               | Unsupported-Construct    |
| `E-UNS-0102` | Error    | Compile-time | Array index must be a compile-time constant            | Index-Array-NonConst-Err |
| `E-UNS-0103` | Error    | Compile-time | Array index out of bounds                              | Index-Array-OOB-Err      |
| `E-UNS-0104` | Error    | Compile-time | `transmute` source and target alignments differ        | T-Transmute-AlignEq      |
| `E-UNS-0105` | Error    | Compile-time | `override` used with no concrete procedure to override | Override-NoConcrete      |
| `E-UNS-0106` | Error    | Compile-time | Conflicting procedure signatures from multiple classes | EffMethods-Conflict      |
| `E-UNS-0107` | Error    | Compile-time | Non-`Bitcopy` place expression used as value           | ValueUse-NonBitcopyPlace |
| `E-UNS-0108` | Error    | Compile-time | Range expression used as index in Cursive0 subset      | Range-NonIndex-Err       |

### 8.8. E-MEM (Memory)

| Code         | Severity | Detection    | Condition                                                            | DiagId                                                                                   |
| ------------ | -------- | ------------ | -------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| `E-MEM-1206` | Error    | Compile-time | Named region not found for allocation                                | Alloc-Region-NotFound-Err                                                                |
| `E-MEM-1207` | Error    | Compile-time | `frame` used with no active region in scope                          | Frame-NoActiveRegion-Err                                                                 |
| `E-MEM-1208` | Error    | Compile-time | `r.frame` target is not in `Region@Active` state                     | Frame-Target-NotActive-Err                                                               |
| `E-MEM-3001` | Error    | Compile-time | Read or move of a binding in Moved or PartiallyMoved state           | B-Place-Moved-Err, B-Move-Whole-Moved-Err, B-Move-Field-Moved-Err                        |
| `E-MEM-3003` | Error    | Compile-time | Reassignment of immutable binding                                    | B-Assign-Immutable-Err                                                                   |
| `E-MEM-3004` | Error    | Compile-time | Partial move from binding without `unique` permission                | B-Move-Field-NonUnique-Err                                                               |
| `E-MEM-3005` | Error    | Compile-time | Explicit call to `drop` method with destructor signature             | Drop-Call-Err, Drop-Call-Err-Dyn                                                         |
| `E-MEM-3006` | Error    | Compile-time | Attempt to move from immovable binding (`:=`)                        | B-Move-Whole-Immovable-Err, B-Move-Field-Immovable-Err                                   |
| `E-MEM-3007` | Error    | Compile-time | `unique` binding from place expression requires explicit `move`      | B-LetVar-UniqueNonMove-Err, B-ShadowLet-UniqueNonMove-Err, B-ShadowVar-UniqueNonMove-Err |
| `E-MEM-3020` | Error    | Compile-time | Value with shorter-lived provenance escapes to longer-lived location | Prov-Escape-Err                                                                          |
| `E-MEM-3021` | Error    | Compile-time | Region allocation `^` outside region scope                           | Alloc-Implicit-NoRegion-Err                                                              |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Transmute-Unsafe-Err                                                                     |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | AllocRaw-Unsafe-Err                                                                      |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | DeallocRaw-Unsafe-Err                                                                    |
| `E-MEM-3030` | Error    | Compile-time | Unsafe operation outside block                                       | Region-Unchecked-Unsafe-Err                                                              |

### 8.9. E-CON (Concurrency and Contracts)

| Code         | Severity | Detection    | Condition                                                        | DiagId      |
| ------------ | -------- | ------------ | ---------------------------------------------------------------- | ----------- |
| `E-CON-0001` | Error    | Compile-time | Access to `shared` path outside valid key context                | E-CON-0001 |
| `E-CON-0002` | Error    | Compile-time | `#` annotation on non-`shared` path                              | E-CON-0002 |
| `E-CON-0003` | Error    | Compile-time | Multiple `#` markers in single path expression                   | E-CON-0003 |
| `E-CON-0004` | Error    | Compile-time | Key escapes its defining scope                                   | E-CON-0004 |
| `E-CON-0005` | Error    | Compile-time | Write access required but only Read available                    | E-CON-0005 |
| `E-CON-0006` | Error    | Compile-time | Key acquisition in `defer` escapes to outer scope                | E-CON-0006 |
| `E-CON-0010` | Error    | Compile-time | Potential conflict on dynamic indices (same statement)           | E-CON-0010 |
| `E-CON-0011` | Error    | Compile-time | Detectable key ordering cycle within procedure                   | E-CON-0011 |
| `E-CON-0012` | Error    | Compile-time | Nested mode change without `release` modifier                    | E-CON-0012 |
| `E-CON-0014` | Error    | Compile-time | `ordered` modifier on paths with different array bases           | E-CON-0014 |
| `E-CON-0017` | Error    | Compile-time | `release` modifier without target mode                           | E-CON-0017 |
| `E-CON-0018` | Error    | Compile-time | `release` with target mode matching outer mode                   | E-CON-0018 |
| `E-CON-0020` | Error    | Compile-time | Key safety not statically provable outside `[[dynamic]]`         | E-CON-0020 |
| `E-CON-0030` | Error    | Compile-time | `#` immediately before method name                               | E-CON-0030 |
| `E-CON-0031` | Error    | Compile-time | `#` block path not in scope                                      | E-CON-0031 |
| `E-CON-0032` | Error    | Compile-time | `#` block path is not `shared`                                   | E-CON-0032 |
| `E-CON-0033` | Error    | Compile-time | `#` on field of non-record type                                  | E-CON-0033 |
| `E-CON-0034` | Error    | Compile-time | Key path root cannot be derived for shared access                | E-CON-0034 |
| `E-CON-0060` | Error    | Compile-time | Read-then-write on same `shared` path without covering Write key | E-CON-0060 |
| `E-CON-0070` | Error    | Compile-time | Write operation in `#` block without `write` modifier            | E-CON-0070 |
| `E-CON-0083` | Error    | Compile-time | `shared $Class` where class has `~%`/`~!` methods                | E-CON-0083 |
| `E-CON-0085` | Error    | Compile-time | Escaping closure with `shared` capture lacks dependency set      | E-CON-0085 |
| `E-CON-0086` | Error    | Compile-time | Escaping closure outlives captured `shared` binding              | E-CON-0086 |
| `E-CON-0090` | Error    | Compile-time | Nested key block inside speculative block                        | E-CON-0090 |
| `E-CON-0091` | Error    | Compile-time | Write to path outside keyed set in speculative block             | E-CON-0091 |
| `E-CON-0092` | Error    | Compile-time | `wait` expression inside speculative block                       | E-CON-0092 |
| `E-CON-0093` | Error    | Compile-time | `defer` statement inside speculative block                       | E-CON-0093 |
| `E-CON-0094` | Error    | Compile-time | `speculative` combined with `release`                            | E-CON-0094 |
| `E-CON-0095` | Error    | Compile-time | `speculative` without `write` modifier                           | E-CON-0095 |
| `E-CON-0096` | Error    | Compile-time | Memory ordering annotation inside speculative block              | E-CON-0096 |
| `E-CON-0101` | Error    | Compile-time | `spawn` or `dispatch` outside parallel                           | E-CON-0101 |
| `E-CON-0102` | Error    | Compile-time | Domain expression not `ExecutionDomain`                          | E-CON-0102 |
| `E-CON-0103` | Error    | Compile-time | Invalid domain parameter type                                    | E-CON-0103 |
| `E-CON-0120` | Error    | Compile-time | Implicit capture of `unique` binding                             | E-CON-0120 |
| `E-CON-0121` | Error    | Compile-time | Move of already-moved binding                                    | E-CON-0121 |
| `E-CON-0122` | Error    | Compile-time | Move of binding from outer parallel scope                        | E-CON-0122 |
| `E-CON-0130` | Error    | Compile-time | Invalid spawn attribute type                                     | E-CON-0130 |
| `E-CON-0131` | Error    | Compile-time | `spawn` in escaping closure                                      | E-CON-0131 |
| `E-CON-0132` | Error    | Compile-time | `wait` operand is not Spawned or Tracked                        | E-CON-0132 |
| `E-CON-0133` | Error    | Compile-time | `wait` while key is held                                         | E-CON-0133 |
| `E-CON-0140` | Error    | Compile-time | Dispatch outside parallel block                                  | E-CON-0140 |
| `E-CON-0141` | Error    | Compile-time | Key inference failed; explicit key required                      | E-CON-0141 |
| `E-CON-0142` | Error    | Compile-time | Cross-iteration dependency detected                              | E-CON-0142 |
| `E-CON-0143` | Error    | Compile-time | Non-associative reduction without `[ordered]`                    | E-CON-0143 |
| `E-CON-0150` | Error    | Compile-time | Host memory access in GPU code                                   | E-CON-0150 |
| `E-CON-0151` | Error    | Compile-time | `shared` capture in GPU dispatch                                 | E-CON-0151 |
| `E-CON-0152` | Error    | Compile-time | Nested GPU parallel block                                        | E-CON-0152 |
| `E-CON-0201` | Error    | Compile-time | `Async` type parameter is not well-formed                        | E-CON-0201 |
| `E-CON-0203` | Error    | Compile-time | `result` type mismatch with `Result` parameter                   | E-CON-0203 |
| `E-CON-0210` | Error    | Compile-time | `yield` outside async-returning procedure                        | E-CON-0210 |
| `E-CON-0211` | Error    | Compile-time | `yield` operand type does not match `Out`                        | E-CON-0211 |
| `E-CON-0212` | Error    | Compile-time | `yield` inside `sync` expression                                 | E-CON-0212 |
| `E-CON-0213` | Error    | Compile-time | `yield` while key is held (without `release`)                    | E-CON-0213 |
| `E-CON-0220` | Error    | Compile-time | `yield from` outside async-returning procedure                   | E-CON-0220 |
| `E-CON-0221` | Error    | Compile-time | Incompatible `Out` parameter in `yield from`                     | E-CON-0221 |
| `E-CON-0222` | Error    | Compile-time | Incompatible `In` parameter in `yield from`                      | E-CON-0222 |
| `E-CON-0223` | Error    | Compile-time | `yield from` inside `sync` expression                            | E-CON-0223 |
| `E-CON-0224` | Error    | Compile-time | `yield from` while key is held (without `release`)               | E-CON-0224 |
| `E-CON-0225` | Error    | Compile-time | Error type not compatible in `yield from`                        | E-CON-0225 |
| `E-CON-0230` | Error    | Compile-time | Error propagation in infallible async procedure                  | E-CON-0230 |
| `E-CON-0240` | Error    | Compile-time | Iteration over async with `In â‰  ()`                              | E-CON-0240 |
| `E-CON-0250` | Error    | Compile-time | `sync` inside async-returning procedure                          | E-CON-0250 |
| `E-CON-0251` | Error    | Compile-time | `sync` operand has `Out â‰  ()`                                    | E-CON-0251 |
| `E-CON-0252` | Error    | Compile-time | `sync` operand has `In â‰  ()`                                     | E-CON-0252 |
| `E-CON-0260` | Error    | Compile-time | `race` with fewer than 2 arms                                    | E-CON-0260 |
| `E-CON-0261` | Error    | Compile-time | `race` arms have incompatible types                              | E-CON-0261 |
| `E-CON-0262` | Error    | Compile-time | Non-streaming `race` operand has `Out â‰  ()`                      | E-CON-0262 |
| `E-CON-0263` | Error    | Compile-time | Mixed yield/non-yield handlers in race                           | E-CON-0263 |
| `E-CON-0270` | Error    | Compile-time | `all` operand has `Out â‰  ()`                                     | E-CON-0270 |
| `E-CON-0271` | Error    | Compile-time | `all` operand has `In â‰  ()`                                      | E-CON-0271 |
| `E-CON-0280` | Error    | Compile-time | Captured binding does not outlive async                          | E-CON-0280 |
| `E-CON-0281` | Error    | Compile-time | Async operation escapes its region                               | E-CON-0281 |
| `E-CON-0410` | Error    | Compile-time | `[[dynamic]]` applied to contract clause directly                | E-CON-0410 |
| `E-CON-0411` | Error    | Compile-time | `[[dynamic]]` applied to type alias declaration                  | E-CON-0411 |
| `E-CON-0412` | Error    | Compile-time | `[[dynamic]]` applied to field declaration                       | E-CON-0412 |

### 8.10. I-CON (Concurrency and Contracts Info)

| Code         | Severity | Detection    | Condition                                     |
| ------------ | -------- | ------------ | --------------------------------------------- |
| `I-CON-0011` | Info     | Compile-time | Runtime synchronization emitted under `[[dynamic]]`            |
| `I-CON-0013` | Info     | Compile-time | Static key safety proven under `[[dynamic]]` (no runtime sync) |

### 8.11. W-CON (Concurrency and Contracts Warnings)

| Code         | Severity | Detection    | Condition                                                         |
| ------------ | -------- | ------------ | ----------------------------------------------------------------- |
| `W-CON-0001` | Warning  | Compile-time | Fine-grained keys in tight loop (performance hint)                |
| `W-CON-0002` | Warning  | Compile-time | Redundant key acquisition (already covered)                       |
| `W-CON-0003` | Warning  | Compile-time | `#` redundant (matches type boundary)                             |
| `W-CON-0004` | Warning  | Compile-time | Read-then-write may cause contention if parallelized              |
| `W-CON-0005` | Warning  | Compile-time | Callee access pattern unknown; assuming full access               |
| `W-CON-0006` | Warning  | Compile-time | Explicit read-then-write form used; compound assignment available |
| `W-CON-0009` | Warning  | Compile-time | Closure captures `shared` data                                    |
| `W-CON-0010` | Warning  | Compile-time | `release` block permits interleaving                              |
| `W-CON-0011` | Warning  | Compile-time | Access to potentially stale binding after release                 |
| `W-CON-0012` | Warning  | Compile-time | Nested `#` blocks with potential order cycle                      |
| `W-CON-0013` | Warning  | Compile-time | `ordered` modifier used with statically-comparable indices        |
| `W-CON-0020` | Warning  | Compile-time | Speculative block on large struct (may be inefficient)            |
| `W-CON-0021` | Warning  | Compile-time | Speculative block body may be expensive to re-execute             |
| `W-CON-0140` | Warning  | Compile-time | Dynamic key pattern; runtime serialization                        |
| `W-CON-0201` | Warning  | Compile-time | Large captured state (performance)                                |
| `W-CON-0401` | Warning  | Compile-time | `[[dynamic]]` present but all proofs succeed statically           |

### 8.12. E-SYS (System)

| Code         | Severity | Detection    | Condition                                          | DiagId       |
| ------------ | -------- | ------------ | -------------------------------------------------- | ------------ |
| `E-SYS-3340` | Error    | Compile-time | `[[symbol]]` on non-FFI procedure                   | E-SYS-3340 |
| `E-SYS-3341` | Error    | Compile-time | Empty symbol string                                 | E-SYS-3341 |
| `E-SYS-3342` | Error    | Link-time    | Duplicate symbol name in compilation unit           | E-SYS-3342 |
| `E-SYS-3345` | Error    | Compile-time | `[[library]]` outside `extern` block                | E-SYS-3345 |
| `E-SYS-3346` | Error    | Compile-time | Unknown library kind                                | E-SYS-3346 |
| `E-SYS-3347` | Error    | Link-time    | Library not found                                   | E-SYS-3347 |
| `E-SYS-3350` | Error    | Compile-time | `[[no_mangle]]` on non-exportable procedure         | E-SYS-3350 |
| `E-SYS-3351` | Error    | Compile-time | `[[no_mangle]]` combined with `[[symbol]]`          | E-SYS-3351 |
| `E-SYS-3352` | Error    | Compile-time | Unsupported extern ABI string                       | ExternAbi-Unknown-Err |
| `E-SYS-3353` | Error    | Compile-time | `[[export]]` requires `public` visibility           | Export-Vis-Err |
| `E-SYS-3355` | Error    | Compile-time | Unknown unwind mode                                 | E-SYS-3355 |
| `E-SYS-3356` | Error    | Compile-time | `[[unwind]]` on non-FFI procedure                   | E-SYS-3356 |

### 8.13. W-MOD (Module Warnings)

| Code         | Severity | Detection    | Condition                                                      |
| ------------ | -------- | ------------ | -------------------------------------------------------------- |
| `W-MOD-1101` | Warning  | Compile-time | Potential module path collision on case-insensitive filesystem |
| `W-MOD-1201` | Warning  | Compile-time | Wildcard `using` in a module exposing public API               |
| `W-MOD-2451` | Warning  | Compile-time | `align(N)` where N < natural alignment                         |
| `W-MOD-2452` | Warning  | Compile-time | `inline(always)` but inlining failed                           |

### 8.14. W-SRC (Source Warnings)

| Code         | Severity | Detection    | Condition                                                   |
| ------------ | -------- | ------------ | ----------------------------------------------------------- |
| `W-SRC-0101` | Warning  | Compile-time | UTF-8 BOM present at the start of the file                  |
| `W-SRC-0301` | Warning  | Compile-time | Leading zeros in decimal literal                            |
| `W-SRC-0308` | Warning  | Compile-time | Lexically sensitive Unicode character within `unsafe` block |

### 8.15. E-TYP (Types)

| Code         | Severity | Detection    | Condition                                                                                              | DiagId                                                                                                                                   |
| ------------ | -------- | ------------ | ------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `E-TYP-1505` | Error    | Compile-time | Missing required type annotation at module scope                                                       | WF-StaticDecl-MissingType, WF-ProcedureDecl-MissingReturnType, WF-ExternProcDecl-MissingReturnType                                       |
| `E-TYP-1530` | Error    | Compile-time | Type inference failed; unable to determine type                                                        | T-LetStmt-Infer-Err, T-VarStmt-Infer-Err, T-ShadowLetStmt-Infer-Err, T-ShadowVarStmt-Infer-Err, PtrNull-Infer-Err, NullLiteral-Infer-Err |
| `E-TYP-1531` | Error    | Compile-time | Float literal explicit suffix does not match expected type                                             | Chk-Float-Literal-Mismatch-Err                                                                                                           |
| `E-TYP-1506` | Error    | Compile-time | Type alias cycle detected                                                                              | TypeAlias-Recursive-Err                                                                                                                  |
| `E-TYP-1507` | Error    | Compile-time | Procedure with non-unit return type requires explicit return statement                                 | WF-ProcBody-ExplicitReturn-Err                                                                                                           |
| `E-TYP-1520` | Error    | Compile-time | Variance violation in generic type instantiation                                                        | E-TYP-1520 |
| `E-TYP-1521` | Error    | Compile-time | Invariant type parameter requires exact type match                                                       | E-TYP-1521 |
| `E-TYP-1601` | Error    | Compile-time | Mutation through `const` path                                                                          | B-Assign-Const-Err                                                                                                                       |
| `E-TYP-1602` | Error    | Compile-time | `unique` exclusion violation (aliasing or inactive use)                                                | B-Place-Unique-Err                                                                                                                       |
| `E-TYP-1603` | Error    | Compile-time | Non-`move` argument must be a place expression                                                         | Call-Arg-NotPlace                                                                                                                        |
| `E-TYP-1604` | Error    | Compile-time | Direct field mutation through `shared` path without key                                                 | E-TYP-1604 |
| `E-TYP-1605` | Error    | Compile-time | Receiver permission incompatible with caller                                                           | MethodCall-RecvPerm-Err                                                                                                                  |
| `E-TYP-1801` | Error    | Compile-time | Tuple index out of bounds                                                                              | TupleIndex-OOB                                                                                                                           |
| `E-TYP-1802` | Error    | Compile-time | Tuple index is not a compile-time constant integer literal                                             | TupleIndex-NonConst                                                                                                                      |
| `E-TYP-1803` | Error    | Compile-time | Tuple arity mismatch in assignment or pattern                                                          | Pat-Tuple-Arity-Err, Pat-Tuple-R-Arity-Err                                                                                               |
| `E-TYP-1810` | Error    | Compile-time | Array length is not a compile-time constant                                                            | ConstLen-Err                                                                                                                             |
| `E-TYP-1812` | Error    | Compile-time | Array index expression has non-`usize` type                                                            | Index-Array-NonUsize, AddrOf-Index-Array-NonUsize                                                                                        |
| `E-TYP-1820` | Error    | Compile-time | Slice index expression has non-`usize` type                                                            | Index-Slice-NonUsize, AddrOf-Index-Slice-NonUsize                                                                                        |
| `E-TYP-1821` | Error    | Compile-time | Direct slice indexing not permitted in Cursive0 subset                                                 | Index-Slice-Direct-Err                                                                                                                   |
| `E-TYP-1901` | Error    | Compile-time | Duplicate field name in record declaration                                                             | WF-Record-DupField                                                                                                                       |
| `E-TYP-1902` | Error    | Compile-time | Missing field initializer in record literal                                                            | Record-FieldInit-Missing                                                                                                                 |
| `E-TYP-1903` | Error    | Compile-time | Duplicate field initializer in record literal                                                          | Record-FieldInit-Dup                                                                                                                     |
| `E-TYP-1904` | Error    | Compile-time | Access to nonexistent field                                                                            | FieldAccess-Unknown, Record-Field-Unknown                                                                                                |
| `E-TYP-1905` | Error    | Compile-time | Access to field not visible in current scope                                                           | FieldAccess-NotVisible, Record-Field-NotVisible                                                                                          |
| `E-TYP-1906` | Error    | Compile-time | Field visibility exceeds record visibility                                                             | FieldVisOk-Err                                                                                                                           |
| `E-TYP-1907` | Error    | Compile-time | Non-`Bitcopy` field requires move source expression                                                    | Record-Field-NonBitcopy-Move                                                                                                             |
| `E-TYP-1911` | Error    | Compile-time | Default record construction requires default initializer for every field                               | Record-Default-Init-Err                                                                                                                  |
| `E-TYP-1912` | Error    | Compile-time | Explicit receiver type must be `Self` for record methods                                               | Record-Method-RecvSelf-Err                                                                                                               |
| `E-TYP-1920` | Error    | Compile-time | Enum discriminant is not an integer literal                                                            | Enum-Disc-NotInt                                                                                                                         |
| `E-TYP-1921` | Error    | Compile-time | Enum discriminant literal is invalid                                                                   | Enum-Disc-Invalid                                                                                                                        |
| `E-TYP-1922` | Error    | Compile-time | Enum discriminant must be non-negative                                                                 | Enum-Disc-Negative                                                                                                                       |
| `E-TYP-1923` | Error    | Compile-time | Duplicate enum discriminant value                                                                      | Enum-Disc-Dup                                                                                                                            |
| `E-TYP-1953` | Error    | Compile-time | Refinement not provable outside `[[dynamic]]` scope                                                     | E-TYP-1953 |
| `E-TYP-1954` | Error    | Compile-time | Impure expression in refinement predicate                                                               | E-TYP-1954 |
| `E-TYP-1955` | Error    | Compile-time | Predicate does not evaluate to `bool`                                                                   | E-TYP-1955 |
| `E-TYP-1956` | Error    | Compile-time | `self` used in inline parameter constraint                                                              | E-TYP-1956 |
| `E-TYP-1957` | Error    | Compile-time | Circular type dependency in refinement predicate                                                        | E-TYP-1957 |
| `E-TYP-2050` | Error    | Compile-time | Modal type declares zero states                                                                        | Modal-NoStates-Err                                                                                                                       |
| `E-TYP-2051` | Error    | Compile-time | Duplicate state name within modal type                                                                 | Modal-DupState-Err                                                                                                                       |
| `E-TYP-2052` | Error    | Compile-time | Field access for field not present in current state's payload                                          | Modal-Field-Missing                                                                                                                      |
| `E-TYP-2053` | Error    | Compile-time | Method invocation for method not available in current state                                            | Modal-Method-NotFound                                                                                                                    |
| `E-TYP-2054` | Error    | Compile-time | State name collides with modal type name                                                               | Modal-StateName-Err                                                                                                                      |
| `E-TYP-2055` | Error    | Compile-time | Transition body returns value not matching declared target state                                       | Transition-Body-Err                                                                                                                      |
| `E-TYP-2056` | Error    | Compile-time | Transition invoked on value not of declared source state                                               | Transition-Source-Err                                                                                                                    |
| `E-TYP-2057` | Error    | Compile-time | Direct field access on general modal type without pattern matching                                     | Modal-Field-General-Err                                                                                                                  |
| `E-TYP-2058` | Error    | Compile-time | Duplicate field name in modal state payload                                                            | Modal-Payload-DupField                                                                                                                   |
| `E-TYP-2059` | Error    | Compile-time | Transition target state not declared in modal type                                                     | Transition-Target-Err                                                                                                                    |
| `E-TYP-2060` | Error    | Compile-time | Non-exhaustive match on general modal type                                                             | Match-Modal-NonExhaustive                                                                                                                |
| `E-TYP-2061` | Error    | Compile-time | Duplicate method name in modal state                                                                   | StateMethod-Dup                                                                                                                          |
| `E-TYP-2062` | Error    | Compile-time | Duplicate transition name in modal state                                                               | Transition-Dup                                                                                                                           |
| `E-TYP-2063` | Error    | Compile-time | State member visibility exceeds modal visibility                                                       | StateMemberVisOk-Err                                                                                                                     |
| `E-TYP-2064` | Error    | Compile-time | State member not visible in current scope                                                              | Modal-Field-NotVisible, Transition-NotVisible, Modal-Method-NotVisible                                                                   |
| `E-TYP-2065` | Error    | Compile-time | State method name conflicts with transition name in the same modal state                               | StateMember-Name-Conflict                                                                                                                |
| `E-TYP-2070` | Error    | Compile-time | Implicit widening on non-niche-layout-compatible type                                                  | Chk-Subsumption-Modal-NonNiche                                                                                                           |
| `E-TYP-2071` | Error    | Compile-time | `widen` applied to non-modal type                                                                      | Widen-NonModal                                                                                                                           |
| `E-TYP-2072` | Error    | Compile-time | `widen` applied to already-general modal type                                                          | Widen-AlreadyGeneral                                                                                                                     |
| `E-TYP-2073` | Error    | Compile-time | Record literal whose type is `File@S`, `DirIter@S`, or `CancelToken@S` for any state `S` in the corresponding modal type | Record-FileDir-Err                                                                                                                       |
| `E-TYP-2101` | Error    | Compile-time | Dereference of pointer in `@Null` state                                                                | Deref-Null                                                                                                                               |
| `E-TYP-2102` | Error    | Compile-time | Dereference of pointer in `@Expired` state                                                             | Deref-Expired                                                                                                                            |
| `E-TYP-2103` | Error    | Compile-time | Dereference of raw pointer outside `unsafe`                                                            | Deref-Raw-Unsafe                                                                                                                         |
| `E-TYP-2104` | Error    | Compile-time | Address-of applied to non-place expression                                                             | AddrOf-NonPlace                                                                                                                          |
| `E-TYP-2105` | Error    | Compile-time | Reference to packed field outside `unsafe`                                                             | Packed-Field-Unsafe-Err                                                                                                                   |
| `E-TYP-2106` | Error    | Compile-time | Call to `extern` procedure outside `unsafe`                                                            | Call-Extern-Unsafe-Err                                                                                                                    |
| `E-MEM-3031` | Error    | Compile-time | `transmute` source and target sizes differ                                                             | T-Transmute-SizeEq                                                                                                                       |
| `E-TYP-2201` | Error    | Compile-time | Union type has fewer than two member types                                                             | WF-Union-TooFew                                                                                                                          |
| `E-TYP-2202` | Error    | Compile-time | Direct access on union value without pattern matching                                                  | Union-DirectAccess-Err                                                                                                                   |
| `E-TYP-2301` | Error    | Compile-time | Type arguments cannot be inferred; explicit instantiation required                                    | E-TYP-2301 |
| `E-TYP-2302` | Error    | Compile-time | Type argument does not satisfy required class bound or predicate                                      | E-TYP-2302 |
| `E-TYP-2303` | Error    | Compile-time | Wrong number of type arguments                                                                         | E-TYP-2303 |
| `E-TYP-2304` | Error    | Compile-time | Duplicate type parameter name in generic declaration                                                  | E-TYP-2304 |
| `E-TYP-2305` | Error    | Compile-time | Class bound references a non-class type                                                               | E-TYP-2305 |
| `E-TYP-2306` | Error    | Compile-time | Generic parameter in `extern` procedure signature                                                     | ExternProc-Generic-Err                                                                                                                   |
| `E-TYP-2307` | Error    | Compile-time | Infinite monomorphization recursion                                                                   | E-TYP-2307 |
| `E-TYP-2308` | Error    | Compile-time | Monomorphization depth limit exceeded                                                                 | E-TYP-2308 |
| `E-TYP-2401` | Error    | Compile-time | Non-modal type implements modal class                                                                   | E-TYP-2401 |
| `E-TYP-2402` | Error    | Compile-time | Implementing type missing required field                                                               | Impl-Field-Missing                                                                                                                       |
| `E-TYP-2403` | Error    | Compile-time | Implementing modal missing required state                                                              | E-TYP-2403 |
| `E-TYP-2404` | Error    | Compile-time | Implementing field has incompatible type                                                               | Impl-Field-Type-Err                                                                                                                      |
| `E-TYP-2405` | Error    | Compile-time | Implementing state missing required payload field                                                      | E-TYP-2405 |
| `E-TYP-2406` | Error    | Compile-time | Conflicting field names from multiple classes                                                          | EffFields-Conflict                                                                                                                       |
| `E-TYP-2407` | Error    | Compile-time | Conflicting state names from multiple classes                                                          | E-TYP-2407 |
| `E-TYP-2408` | Error    | Compile-time | Duplicate abstract field name in class                                                                 | Class-AbstractField-Dup                                                                                                                  |
| `E-TYP-2409` | Error    | Compile-time | Duplicate abstract state name in class                                                                 | E-TYP-2409 |
| `E-TYP-2500` | Error    | Compile-time | Duplicate procedure name in class                                                                      | Class-Method-Dup                                                                                                                         |
| `E-TYP-2501` | Error    | Compile-time | `override` used on abstract procedure implementation                                                   | Override-Abstract-Err                                                                                                                    |
| `E-TYP-2502` | Error    | Compile-time | Missing `override` on concrete procedure replacement                                                   | Override-Missing-Err                                                                                                                     |
| `E-TYP-2503` | Error    | Compile-time | Type does not implement required procedure from class or has incompatible signature                    | Impl-Missing-Method, Impl-Sig-Err, Impl-Sig-Err-Concrete                                                                                 |
| `E-TYP-2504` | Error    | Compile-time | Duplicate associated type name in class                                                                | E-TYP-2504 |
| `E-TYP-2505` | Error    | Compile-time | Name conflict among class members                                                                      | Class-Name-Conflict                                                                                                                      |
| `E-TYP-2506` | Error    | Compile-time | Coherence violation: duplicate class implementation                                                    | Impl-Dup, Impl-Duplicate-Class-Err                                                                                                       |
| `E-TYP-2507` | Error    | Compile-time | Orphan rule violation: neither type nor class is local                                                 | E-TYP-2507 |
| `E-TYP-2508` | Error    | Compile-time | Cyclic superclass dependency detected                                                                  | Superclass-Cycle                                                                                                                         |
| `E-TYP-2509` | Error    | Compile-time | Superclass bound refers to undefined class                                                             | Superclass-Undefined                                                                                                                     |
| `E-TYP-2510` | Error    | Compile-time | Accessing member not defined on opaque type's class                                                    | E-TYP-2510 |
| `E-TYP-2511` | Error    | Compile-time | Opaque return type does not implement required class                                                   | E-TYP-2511 |
| `E-TYP-2512` | Error    | Compile-time | Attempting to assign incompatible opaque types                                                         | E-TYP-2512 |
| `E-TYP-2530` | Error    | Compile-time | Type argument does not satisfy class constraint                                                        | E-TYP-2530 |
| `E-TYP-2531` | Error    | Compile-time | Unconstrained type parameter used in class method                                                      | E-TYP-2531 |
| `E-TYP-2540` | Error    | Compile-time | Procedure with `[[static_dispatch_only]]` called on `$`                                                 | E-TYP-2540 |
| `E-TYP-2541` | Error    | Compile-time | Dynamic class type created from non-dispatchable class                                                 | Dynamic-NonDispatchable                                                                                                                  |
| `E-TYP-2542` | Error    | Compile-time | Generic procedure in class without `[[static_dispatch_only]]` attribute                               | E-TYP-2542 |
| `E-TYP-2621` | Error    | Compile-time | Type satisfies both `BitcopyType` and `DropType`                                                       | BitcopyDrop-Conflict                                                                                                                     |
| `E-TYP-2622` | Error    | Compile-time | `BitcopyType` has non-`BitcopyType` field                                                              | Bitcopy-Field-NonBitcopy                                                                                                                 |
| `E-TYP-2623` | Error    | Compile-time | Prohibited type category in `FfiSafeType`                                                              | FfiSafe-Prohibited-Err                                                                                                                   |
| `E-TYP-2624` | Error    | Compile-time | `FfiSafeType` record without `[[layout(C)]]`                                                           | FfiSafe-Record-LayoutC-Err                                                                                                               |
| `E-TYP-2625` | Error    | Compile-time | `FfiSafeType` enum without `[[layout(C)]]`                                                             | FfiSafe-Enum-LayoutC-Err                                                                                                                 |
| `E-TYP-2626` | Error    | Compile-time | `FfiSafeType` record has non-`FfiSafeType` field                                                       | FfiSafe-Record-Field-Err                                                                                                                 |
| `E-TYP-2627` | Error    | Compile-time | `FfiSafeType` enum has non-`FfiSafeType` payload field                                                 | FfiSafe-Enum-Field-Err                                                                                                                   |
| `E-TYP-2628` | Error    | Compile-time | `FfiSafeType` requires complete layout                                                                 | FfiSafe-Incomplete-Err                                                                                                                   |
| `E-TYP-2629` | Error    | Compile-time | Generic `FfiSafeType` with unconstrained parameter                                                     | FfiSafe-Generic-Unbounded-Err                                                                                                            |
| `E-TYP-2630` | Error    | Compile-time | By-value FFI use of `DropType` without `[[ffi_pass_by_value]]`                                         | FfiByValue-Err                                                                                                                           |
| `E-TYP-2631` | Error    | Compile-time | `[[export]]` with `unwind = "catch"` requires zeroable return type                                    | Export-Return-NotZeroable-Err                                                                                                            |

### 8.16. W-SYS (System Warnings)

| Code         | Severity | Detection    | Condition                                               |
| ------------ | -------- | ------------ | ------------------------------------------------------- |
| `W-SYS-4010` | Warning  | Compile-time | Modal widening involves large payload copy (>256 bytes) |
| `W-SYS-3350` | Warning  | Compile-time | `[[no_mangle]]` in `extern "C"` (redundant)             |
| `W-SYS-3355` | Warning  | Compile-time | `[[unwind("abort")]]` (redundant)                       |

### 8.17. E-SEM (Semantics)

| Code         | Severity | Detection    | Condition                                            | DiagId                                            |
| ------------ | -------- | ------------ | ---------------------------------------------------- | ------------------------------------------------- |
| `E-SEM-2524` | Error    | Compile-time | Tuple access on non-tuple                            | TupleAccess-NotTuple                              |
| `E-SEM-2527` | Error    | Compile-time | Indexing applied to non-indexable type               | Index-NonIndexable                                |
| `E-SEM-2531` | Error    | Compile-time | Callee expression is not of FUNCTION type            | Call-Callee-NotFunc                               |
| `E-SEM-2532` | Error    | Compile-time | Argument count mismatch                              | Call-ArgCount-Err                                 |
| `E-SEM-2533` | Error    | Compile-time | Argument type incompatible with parameter type       | Call-ArgType-Err                                  |
| `E-SEM-2534` | Error    | Compile-time | `move` argument required but not provided            | Call-Move-Missing                                 |
| `E-SEM-2535` | Error    | Compile-time | `move` argument provided but parameter is not `move` | Call-Move-Unexpected                              |
| `E-SEM-2536` | Error    | Compile-time | Method not found for receiver type                   | LookupMethod-NotFound, LookupClassMethod-NotFound |
| `E-SEM-2705` | Error    | Compile-time | `match` expression is not exhaustive for union type  | Match-Union-NonExhaustive                         |
| `E-SEM-2711` | Error    | Compile-time | Refutable pattern in irrefutable context (`let`)     | Let-Refutable-Pattern-Err                         |
| `E-SEM-2713` | Error    | Compile-time | Duplicate binding identifier within single pattern   | Pat-Dup-Err, Pat-Dup-R-Err                        |
| `E-SEM-2721` | Error    | Compile-time | Range pattern bounds are not compile-time constants  | RangePattern-NonConst                             |
| `E-SEM-2801` | Error    | Compile-time | Contract predicate not provable outside `[[dynamic]]` scope | E-SEM-2801 |
| `E-SEM-2802` | Error    | Compile-time | Impure expression in contract predicate              | E-SEM-2802 |
| `E-SEM-2803` | Error    | Compile-time | Implementation strengthens class precondition        | E-SEM-2803 |
| `E-SEM-2804` | Error    | Compile-time | Implementation weakens class postcondition           | E-SEM-2804 |
| `E-SEM-2805` | Error    | Compile-time | `@entry()` result type not `BitcopyType` or `CloneType` | E-SEM-2805 |
| `E-SEM-2806` | Error    | Compile-time | `@result` used outside postcondition                 | E-SEM-2806 |
| `E-SEM-2820` | Error    | See Â§14.7    | Type invariant violated at construction              | E-SEM-2820 |
| `E-SEM-2821` | Error    | See Â§14.7    | Type invariant violated at public entry              | E-SEM-2821 |
| `E-SEM-2822` | Error    | See Â§14.7    | Type invariant violated at mutator return            | E-SEM-2822 |
| `E-SEM-2823` | Error    | See Â§14.7    | Type invariant violated at private-to-public return  | E-SEM-2823 |
| `E-SEM-2824` | Error    | Compile-time | Public mutable field on type with invariant          | E-SEM-2824 |
| `E-SEM-2830` | Error    | See Â§14.7    | Loop invariant not established at initialization     | E-SEM-2830 |
| `E-SEM-2831` | Error    | See Â§14.7    | Loop invariant not maintained across iteration       | E-SEM-2831 |
| `E-SEM-2850` | Error    | Compile-time | Cannot prove `@foreign_assumes` predicate            | E-SEM-2850 |
| `E-SEM-2851` | Error    | Compile-time | Invalid predicate in foreign contract                | E-SEM-2851 |
| `E-SEM-2852` | Error    | Compile-time | Predicate references out-of-scope value              | E-SEM-2852 |
| `E-SEM-2853` | Error    | Compile-time | Invalid predicate in `@foreign_ensures`              | E-SEM-2853 |
| `E-SEM-2854` | Error    | Compile-time | `@result` used in non-return context                 | E-SEM-2854 |
| `E-SEM-2855` | Error    | Compile-time | `@error` predicate on void-returning procedure       | E-SEM-2855 |
| `E-SEM-3004` | Error    | Compile-time | Impure expression in contract clause                 | E-SEM-3004 |
| `E-SEM-2722` | Error    | Compile-time | Range pattern start exceeds end (empty range)        | RangePattern-Empty                                |
| `E-SEM-2731` | Error    | Compile-time | Record pattern references non-existent field         | RecordPattern-UnknownField                        |
| `E-SEM-3011` | Error    | Compile-time | Method defined outside of type context               | Method-Context-Err                                |
| `E-SEM-3012` | Error    | Compile-time | Duplicate method name in type                        | Record-Method-Dup                                 |
| `E-SEM-3131` | Error    | Compile-time | Assignment target is not a place expression          | Assign-NotPlace                                   |
| `E-SEM-3132` | Error    | Compile-time | Assignment through `const` permission                | Assign-Const-Err                                  |
| `E-SEM-3133` | Error    | Compile-time | Assignment type mismatch                             | Assign-Type-Err                                   |
| `E-SEM-3151` | Error    | Compile-time | Defer block has non-unit type                        | Defer-NonUnit-Err                                 |
| `E-SEM-3152` | Error    | Compile-time | Non-local control flow in defer block                | Defer-NonLocal-Err                                |
| `E-SEM-3161` | Error    | Compile-time | `return` type mismatch with procedure                | Return-Type-Err                                   |
| `E-SEM-3162` | Error    | Compile-time | `break` outside `loop`                               | Break-Outside-Loop                                |
| `E-SEM-3163` | Error    | Compile-time | `continue` outside `loop`                            | Continue-Outside-Loop                             |
| `E-SEM-3165` | Error    | Compile-time | `return` at module scope                             | Return-At-Module-Err                              |

### 8.18. P-TYP (Runtime Panics - Types)

| Code         | Severity | Detection | Condition                                  | DiagId       |
| ------------ | -------- | --------- | ------------------------------------------ | ------------ |
| `P-TYP-1953` | Panic    | Runtime   | Refinement predicate failed at runtime     | P-TYP-1953 |

### 8.20. P-SEM (Runtime Panics - Semantics)

| Code         | Severity | Detection | Condition                                   | DiagId       |
| ------------ | -------- | --------- | ------------------------------------------- | ------------ |
| `P-SEM-2850` | Panic    | Runtime   | Contract predicate failed at runtime        | P-SEM-2850 |
| `P-SEM-2860` | Panic    | Runtime   | Foreign precondition failed at runtime      | P-SEM-2860 |
| `P-SEM-2861` | Panic    | Runtime   | Foreign postcondition failed at runtime     | P-SEM-2861 |

## 9. Appendix B - Notation and Glossary

### 9.1. Notation Conventions
F(x_1, â€¦, x_n) = F^(n)(x_1, â€¦, x_n)
n â‰  m â‡’ F^(n) â‰  F^(m)

### 9.2. Helper Functions and Relations
UnicodeNFC_15.0.0 and UnicodeCaseFold_15.0.0 are defined by the Unicode Standard 15.0.0 and are normative for this document
LLVMText_21 and LLVMObj_21 are defined by LLVM 21 tool acceptance for textual IR and object emission respectively

**HelperRef.**
HelperRef(Fold) = `"2.3.2"`
HelperRef(DirSeq) = `"2.3.3"`
HelperRef(Modules) = `"2.4"`
HelperRef(ModuleList) = `"2.5"`
HelperRef(OutputRoot) = `"2.5"`
HelperRef(OutputPaths) = `"2.5"`
HelperRef(SearchDirs) = `"2.6"`
HelperRef(ResolveTool) = `"2.6"`
HelperRef(AssembleIR) = `"2.6"`
HelperRef(IdKey) = `"3.1.6"`
HelperRef(IdEq) = `"3.1.6"`
HelperRef(CaseFold) = `"3.1.6"`
HelperRef(Span) = `"1.6"`
HelperRef(SpanOf) = `"1.6"`
HelperRef(ClampSpan) = `"1.6"`
HelperRef(AliasExpand) = `"5.12"`
HelperRef(ModulePrefix) = `"5.12"`
HelperRef(Reachable) = `"5.12"`
HelperRef(TypeRefsTy) = `"5.12"`
HelperRef(TypeRefsRef) = `"5.12"`
HelperRef(TypeRefsExpr) = `"5.12"`
HelperRef(TypeRefsPat) = `"5.12"`
HelperRef(ValueRefs) = `"5.12"`
HelperRef(ValueRefsArgs) = `"5.12"`
HelperRef(ValueRefsFields) = `"5.12"`
HelperRef(Topo) = `"7.1"`
HelperRef(EntryKey) = `"7.7"`
HelperRef(PathOrderKey) = `"6.1.4.1"`
HelperRef(TypeKey) = `"6.1.4.1"`
HelperRef(â‰º_type) = `"6.1.4.1"`
HelperRef(Members) = `"5.2.7"`
HelperRef(MemberList) = `"6.1.4.1"`
HelperRef(DistinctMembers) = `"6.1.4.1"`
HelperRef(SingleFieldPayload) = `"6.1.4.1"`
HelperRef(PayloadState) = `"6.1.4.1"`
HelperRef(EmptyState) = `"6.1.4.1"`
HelperRef(NicheSet) = `"6.1.4.1"`
HelperRef(NicheCount) = `"6.1.4.1"`
HelperRef(NicheOrder) = `"6.1.4.1"`
HelperRef(NicheApplies) = `"6.1.4.1"`
HelperRef(StaticJudgments) = `"1.2"`
HelperRef(PremisesHold) = `"1.2"`
HelperRef(PermSyntax) = `"5.2.2"`
HelperRef(Behavior) = `"1.2"`
HelperRef(ResourceExhaustion) = `"1.3"`
HelperRef(OutsideConformance) = `"1.3"`
HelperRef(SpanRange) = `"1.6.1"`
HelperRef(SeverityColumn) = `"8"`
HelperRef(ConditionColumn) = `"8"`
HelperRef(HasError) = `"1.6.3"`
HelperRef(CompileStatus) = `"1.6.3"`
HelperRef(NoDiag) = `"1.6.4"`
HelperRef(HostPrim) = `"1.7"`
HelperRef(FSPrim) = `"1.7"`
HelperRef(FilePrim) = `"1.7"`
HelperRef(DirPrim) = `"1.7"`
HelperRef(MapsToDiagOrRuntime) = `"1.7"`
HelperRef(WinSep) = `"2.1"`
HelperRef(AbsPath) = `"2.1"`
HelperRef(DriveRooted) = `"2.1"`
HelperRef(UNC) = `"2.1"`
HelperRef(RootRelative) = `"2.1"`
HelperRef(FoldPath) = `"2.3"`
HelperRef(FileKey) = `"2.3"`
HelperRef(DirKey) = `"2.3"`
HelperRef(Basename) = `"2.3"`
HelperRef(FileExt) = `"2.1"`
HelperRef(Utf8LexLess) = `"2.3"`
HelperRef(BMap) = `"2.5"`
HelperRef(Hex2) = `"2.5"`
HelperRef(Concat) = `"2.5"`
HelperRef(Overwrites) = `"2.5"`
HelperRef(IsDir) = `"2.5"`
Overwrites(p, b) â‡” âˆƒ fs, Ï‰, Ï‰'. FSWriteFile(fs, p, b, Ï‰) â‡“ (ok, Ï‰')
IsDir(p) â‡” âˆƒ fs, Ï‰, Ï‰'. FSKind(fs, p, Ï‰) â‡“ (`Dir`, Ï‰')

**Auxiliary String/Sequence Operators.**
At(s, i) = s[i]
StartsWith(s, p) â‡” s[0..|p|) = p
EndsWith(s, p) â‡” s[|s| - |p|..|s|) = p
Remove(s, c) = [ s[i] | 0 â‰¤ i < |s| âˆ§ s[i] â‰  c ]
Concat([]) = `"\""`
Concat([s]) = s
Concat(s::ss) = s ++ Concat(ss)    (|ss| > 0)
HexDigit(0) = `"0"` â€¦ HexDigit(9) = `"9"` â€¦ HexDigit(15) = `"f"`
Hex2(b) = HexDigit(âŒŠb/16âŒ‹) ++ HexDigit(b mod 16)


**Hex Values.**
HexDigitValue(`'0'`) = 0    HexDigitValue(`'1'`) = 1    HexDigitValue(`'2'`) = 2    HexDigitValue(`'3'`) = 3    HexDigitValue(`'4'`) = 4    HexDigitValue(`'5'`) = 5    HexDigitValue(`'6'`) = 6    HexDigitValue(`'7'`) = 7    HexDigitValue(`'8'`) = 8    HexDigitValue(`'9'`) = 9
HexDigitValue(`'a'`) = 10    HexDigitValue(`'b'`) = 11    HexDigitValue(`'c'`) = 12    HexDigitValue(`'d'`) = 13    HexDigitValue(`'e'`) = 14    HexDigitValue(`'f'`) = 15
HexDigitValue(`'A'`) = 10    HexDigitValue(`'B'`) = 11    HexDigitValue(`'C'`) = 12    HexDigitValue(`'D'`) = 13    HexDigitValue(`'E'`) = 14    HexDigitValue(`'F'`) = 15
HexValue(h_1â€¦h_n) = âˆ‘_{k=1}^{n} HexDigitValue(h_k) Â· 16^(n-k)
DecDigitValue(`'0'`) = 0    DecDigitValue(`'1'`) = 1    DecDigitValue(`'2'`) = 2    DecDigitValue(`'3'`) = 3    DecDigitValue(`'4'`) = 4    DecDigitValue(`'5'`) = 5    DecDigitValue(`'6'`) = 6    DecDigitValue(`'7'`) = 7    DecDigitValue(`'8'`) = 8    DecDigitValue(`'9'`) = 9
OctDigitValue(`'0'`) = 0    OctDigitValue(`'1'`) = 1    OctDigitValue(`'2'`) = 2    OctDigitValue(`'3'`) = 3    OctDigitValue(`'4'`) = 4    OctDigitValue(`'5'`) = 5    OctDigitValue(`'6'`) = 6    OctDigitValue(`'7'`) = 7
BinDigitValue(`'0'`) = 0    BinDigitValue(`'1'`) = 1
DecValue(d_1â€¦d_n) = âˆ‘_{k=1}^{n} DecDigitValue(d_k) Â· 10^(n-k)
OctValue(d_1â€¦d_n) = âˆ‘_{k=1}^{n} OctDigitValue(d_k) Â· 8^(n-k)
BinValue(d_1â€¦d_n) = âˆ‘_{k=1}^{n} BinDigitValue(d_k) Â· 2^(n-k)

**Rule-Section Map.**
SectionId(r) âˆˆ String
RulesIn(Î£) = { r | SectionId(r) âˆˆ Î£ }

**EmitList.**
EmitList([]) = ok
EmitList([d] ++ ds) = (Î“ âŠ¢ Emit(d)) âˆ§ EmitList(ds)

**ArgMax.**
argmax_{x âˆˆ C} g(x) = x* â‡” x* âˆˆ C âˆ§ âˆ€ y âˆˆ C. g(x*) â‰¥ g(y) âˆ§ (âˆ€ z âˆˆ C. g(z) = g(x*) â‡’ z = x*)

### 9.3. Variance

**Variance.** Specifies how subtyping of type arguments relates to subtyping of parameterized types. For a generic type constructor F with parameter X, variance determines whether F[A] <: F[B] when A <: B, when B <: A, both, or neither.

**Static Semantics**

**Variance Classifications**

| Variance      | Symbol | Condition for F[A] <: F[B] | Position Requirement                              |
| :------------ | :----- | :------------------------- | :----------------------------------------------- |
| Covariant     | `+`    | A <: B                     | Output positions (return types, immutable fields) |
| Contravariant | `-`    | B <: A                     | Input positions (parameter types)                 |
| Invariant     | `=`    | A â‰¡ B                      | Both input and output, or mutable storage         |
| Bivariant     | `Â±`    | Always                     | Parameter does not appear in type structure       |

**Generic Subtyping Rule**

For a generic type NameâŸ¨T_1, â€¦, T_nâŸ© to be a subtype of NameâŸ¨U_1, â€¦, U_nâŸ©, each type argument pair (T_i, U_i) MUST satisfy the variance of the corresponding parameter:
- Covariant (`+`): T_i <: U_i
- Contravariant (`-`): U_i <: T_i
- Invariant (`=`): T_i â‰¡ U_i
- Bivariant (`Â±`): always compatible

**Function Type Variance**

Function types are contravariant in their parameter types and covariant in their return types: (U) -> R_1 is a subtype of (T) -> R_2 iff T <: U and R_1 <: R_2.

**Permission Interaction**

The `const` permission enables covariance for otherwise invariant generic types: `const` CâŸ¨AâŸ© <: `const` CâŸ¨BâŸ© if A <: B. This relaxation MUST NOT apply to `unique` or `shared` permissions.

**Constraints**

An implementation MUST reject a subtyping judgment that violates variance rules.

When a type parameter has invariant variance, the implementation MUST require exact type equivalence for that parameter in subtyping checks.

**Diagnostics:** See Appendix A, codes `E-TYP-1520`, `E-TYP-1521`.

### 9.4. Type Inference

#### 9.4.1. Bidirectional Type Checking

**Type Inference.** The process by which type information not explicitly annotated in the source program is derived. Cursive employs bidirectional type inference, combining synthesis and checking.

**Static Semantics**

**Judgment Classes**

| Judgment        | Name       | Meaning                                              |
| :-------------- | :--------- | :--------------------------------------------------- |
| Î“ âŠ¢ e â‡’ T       | Synthesis  | Type T is derived from the structure of e            |
| Î“ âŠ¢ e â‡ T       | Checking   | Expression e is validated against expected type T    |

In synthesis mode, type information flows from expression to context. In checking mode, expected type flows inward to guide inference.

#### 9.4.2. Local Type Inference

**Static Semantics**

Type inference MUST be local: inference operates within a single procedure body and MUST NOT propagate type information across procedure boundaries.

An implementation MUST NOT infer types for public API boundaries.

#### 9.4.3. Inference Constraints

**Static Semantics**

**Mandatory Annotations**

The following positions MUST have explicit type annotations:
- Procedure parameter types
- Procedure return types
- Public and protected module-scope bindings

**Permitted Omissions**

The following positions MAY omit type annotations when the type is inferable:
- Local bindings within procedure bodies (`let`, `var`)
- Closure parameter types when the closure expression is checked against an expected function type.

**(Infer-Closure-Params)**
Î“; R; L âŠ¢ C â‡ TypeFunc([âŸ¨m_1, T_1âŸ©, â€¦, âŸ¨m_n, T_nâŸ©], R_t) âŠ£ âˆ…    Params(C) = [p_1, â€¦, p_n]    âˆ€ i. (Annot(p_i) = âŠ¥ â‡’ ParamType(p_i) = T_i) âˆ§ (Annot(p_i) = T_i' â‡’ Î“ âŠ¢ T_i' â‰¡ T_i)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ InferClosureParams(C) â‡“ ok

If a closure parameter lacks an annotation and no expected function type is available, inference fails.

Params(C) is the parameter list of closure expression C. Annot(p) is the optional type annotation on parameter p.

**Diagnostics:** See Appendix A, code `E-TYP-1505`.

#### 9.4.4. Inference Failures

**Static Semantics**

An implementation MUST reject a program if inference fails to derive a unique type for any expression.

When type arguments are not inferred, explicit type arguments MUST be supplied at the call site.
Explicit type arguments are supplied using the generic call syntax `callee<type_arg_list>(...)` (see Â§13.1.2). This form parses to `CallTypeArgs`.

**Diagnostics:** See Appendix A, code `E-TYP-1530`.

## 10. The Permission System

---

### 10.1 Permission Lattice (`const`, `unique`, `shared`)


#### 10.1.1 `const` Permission (Read-Only)

**Permission.** A type qualifier governing access, mutation, and aliasing of data referenced by a binding. When no permission is specified, `const` is the default.

**`const` Permission.** Grants read-only access to data with unlimited aliasing. Mutation through a `const` path is forbidden.

**Syntax**

```ebnf
permission       ::= "const" | "unique" | "shared"
permission_type  ::= type
```


**Static Semantics**

Let ð’« denote the set of permissions:

ð’« = {`const`, `unique`, `shared`}

A **permission-qualified type** is a pair (P, T) where P âˆˆ ð’« and T is a base type. The notation P T denotes this qualification.

**Operations Permitted:**

| Operation | Permitted |
| :-------- | :-------- |
| Read      | Yes       |
| Write     | No        |
| Aliasing  | Unlimited |


#### 10.1.2 `unique` Permission (Exclusive Read-Write)

**`unique` Permission.** Grants exclusive read-write access to data. A live `unique` path to an object precludes any other path to that object or its sub-components.

**Static Semantics**

**Exclusivity Invariant:**

âˆ€ p_1, p_2 âˆˆ Paths. (perm(p_1) = `unique` âˆ§ overlaps(p_1, p_2)) â‡’ p_1 = p_2

**Operations Permitted:**

| Operation | Permitted  |
| :-------- | :--------- |
| Read      | Yes        |
| Write     | Yes        |
| Aliasing  | No aliases |

The `unique` permission does **not** imply cleanup responsibility. A parameter of type `unique T` (without `move`) grants exclusive access while the caller retains responsibility.


#### 10.1.3 `shared` Permission (Synchronized Access)

**`shared` Permission.** Grants mutable access through implicit key acquisition. See Â§17 for complete key system semantics.

**Static Semantics**

**Operations Permitted:**

| Operation                   | Permitted | Key Mode  |
| :-------------------------- | :-------- | :-------- |
| Field read                  | Yes       | Read key  |
| Field mutation              | Yes       | Write key |
| Method call (`~` receiver)  | Yes       | Read key  |
| Method call (`~%` receiver) | Yes       | Write key |
| Method call (`~!` receiver) | No        | N/A       |

**Key Properties:**

| Property      | Description                                               |
| :------------ | :-------------------------------------------------------- |
| Path-specific | Keys acquired at accessed path granularity                |
| Implicit      | Accessing `shared` path acquires necessary key            |
| Minimal       | Keys held for minimal duration                            |
| Reentrant     | Covering key permits nested access without re-acquisition |

The `shared` permission does **not** imply cleanup responsibility.


#### 10.1.4 Lattice Ordering

**Lattice Ordering.** The permission lattice orders permissions by aliasing guarantee strength.

**Static Semantics**

`unique` <: `shared` <: `const`

**Lattice Diagram:**



### 10.2 Exclusivity and Aliasing Rules

**Aliasing.** Two paths alias when they refer to overlapping storage locations: aliases(p_1, p_2) â‡” storage(p_1) âˆ© storage(p_2) â‰  âˆ….

**Binding State Machine**

A binding b with `unique` permission exists in one of two states:

| State    | Definition                                        | Operations Permitted         |
| :------- | :------------------------------------------------ | :--------------------------- |
| Active   | No downgraded references to b are live          | Read, write, move, downgrade |
| Inactive | One or more downgraded references to b are live | No operations                |

**Static Semantics**

**(Inactive-Enter)**
b : `unique` T    b is Active    downgrade to P where P âˆˆ {`const`, `shared`}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
b becomes Inactive

**(Inactive-Exit)**
b is Inactive    all downgraded references to b go out of scope
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
b becomes Active with `unique` permission restored

**Constraints**

1. During the inactive period, the original `unique` binding MUST NOT be read, written, or moved.
2. The transition back to Active occurs deterministically when the downgrade scope ends.

**Coexistence Matrix**

| Active Permission | May Add `unique` | May Add `shared` | May Add `const` |
| :---------------- | :--------------- | :--------------- | :-------------- |
| `unique`          | No               | No               | No              |
| `shared`          | No               | Yes              | Yes             |
| `const`           | No               | Yes              | Yes             |


### 10.3 Permission Subtyping and Coercion

**Permission Subtyping.** This section formalizes the subtype relation between permission-qualified types. General subtyping is defined in Â§9.2.

**Subtyping Rules**

Permission subtyping allows treating a stronger permission as a weaker one:
- `unique T <: shared T`
- `unique T <: const T`
- `shared T <: const T`

Permissions coerce implicitly in one direction only: from stronger to weaker. Upgrade from weaker to stronger is forbidden.

**Diagnostics:** See Appendix A, codes `E-TYP-1601`, `E-TYP-1602`, `E-TYP-1604`.

**Method Receiver Permissions**

*[REF: Shorthand syntax (`~`, `~!`, `~%`) is defined in Â§14.2.2.]*

A method with receiver permission P_method is callable through a path with permission P_caller iff:

P_caller <: P_method

| Caller Permission | May Call `~` | May Call `~%` | May Call `~!` |
| :---------------- | :----------- | :------------ | :------------ |
| `const`           | Yes          | No            | No            |
| `shared`          | Yes          | Yes           | No            |
| `unique`          | Yes          | Yes           | Yes           |

**Diagnostics:** See Appendix A, code `E-TYP-1605`.

---

## 13. Abstraction and Polymorphism

---

### 13.1 Generics


#### 13.1.1 Generic Type Parameters

**Generic Declaration.** Introduces one or more **type parameters** that serve as placeholders for concrete types supplied at instantiation.

A generic declaration D is defined by:

D = (Name, Params, Body)

where:
- Name is the declaration's identifier
- Params = âŸ¨P_1, P_2, â€¦, P_nâŸ© is an ordered sequence of type parameters
- Body is the declaration body (type definition or procedure body)

Each type parameter P_i is defined by:

P_i = (name_i, Bounds_i, Default_i)

where:
- name_i is an identifier serving as the parameter name
- Bounds_i âŠ† ð’¯_class is a (possibly empty) set of class bounds
- Default_i âˆˆ Type âˆª {âŠ¥} is an optional default type

Inline bounds (`<:`) are class bounds only. Predicate bounds are specified exclusively in `where` clauses (Â§13.1.3).

A type parameter with Bounds_i = âˆ… is **unconstrained**. A type parameter with Bounds_i â‰  âˆ… is **constrained**; it MUST be instantiated only with types implementing all classes in Bounds_i.

**Syntax**

```ebnf
generic_params     ::= "<" generic_param_list ">"
generic_param_list ::= generic_param (";" generic_param)*
generic_param      ::= identifier bound_clause? default_clause?
bound_clause       ::= "<:" class_bound_list
default_clause     ::= "=" type
class_bound_list   ::= class_bound ("," class_bound)*

generic_args       ::= "<" type_arg_list ">"
type_arg_list      ::= type ("," type)*
```


**Static Semantics**

DefaultSuffix(params) â‡” âˆ€ i < j. (params[i].default_opt â‰  âŠ¥ â‡’ params[j].default_opt â‰  âŠ¥)
DefaultRefsOk(params) â‡” âˆ€ i. params[i].default_opt = T_i â‡’ TypeParamsIn(T_i, params) âŠ† {params[j].name | j < i}
DefaultWF(Î“, params) â‡” âˆ€ i. params[i].default_opt = T_i â‡’ (Î“_i âŠ¢ T_i wf âˆ§ Î“_i âŠ¢ T_i satisfies Bounds(params[i])) where Î“_i = BindTypeParams(Î“, [params[j] | j < i])

**(WF-Generic-Param)**

âˆ€ i â‰  j, name_i â‰  name_j    âˆ€ i, âˆ€ B âˆˆ Bounds_i, Î“ âŠ¢ B : ClassPath    DefaultSuffix([P_1, â€¦, P_n])    DefaultRefsOk([P_1, â€¦, P_n])    DefaultWF(Î“, [P_1, â€¦, P_n])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ âŸ¨P_1; â€¦; P_nâŸ© wf

**(WF-Generic-Type)**

Î“ âŠ¢ âŸ¨P_1, â€¦, P_nâŸ© wf    Î“, T_1 : P_1, â€¦, T_n : P_n âŠ¢ Body wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `type` NameâŸ¨P_1, â€¦, P_nâŸ© Body wf

**Constraints**

| Separator | Role                                  | Scope                            |
| :-------- | :------------------------------------ | :------------------------------- |
| `;`       | Separates type parameters             | Between `<` and `>`              |
| `,`       | Separates bounds within one parameter | After `<:` until next `;` or `>` |

**Diagnostics:** See Appendix A, code `E-TYP-2304`.


#### 13.1.2 Generic Procedures

**Generic Procedure.** A procedure parameterized by type parameters. Type arguments MAY be explicit or inferred.

**Syntax**

```ebnf
generic_procedure ::= "procedure" identifier generic_params "(" param_list? ")" ("->" type)? block
generic_call      ::= callee generic_args "(" arg_list? ")"
```


**Static Semantics**

**(WF-Generic-Proc)**

Î“ âŠ¢ âŸ¨P_1, â€¦, P_nâŸ© wf    Î“' = Î“, T_1 : P_1, â€¦, T_n : P_n    Î“' âŠ¢ signature wf    Î“' âŠ¢ body wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `procedure` fâŸ¨P_1, â€¦, P_nâŸ©(...) â†’ R {â€¦} wf

**(T-Generic-Call)**

procedure fâŸ¨T_1, â€¦, T_nâŸ©(x_1 : S_1, â€¦, x_m : S_m) â†’ R where W declared
DefaultArgs([T_1, â€¦, T_n], [A_1, â€¦, A_k]) = [A_1', â€¦, A_n']
Î¸ = [A_1'/T_1, â€¦, A_n'/T_n]
âˆ€ i âˆˆ 1..n, Î“ âŠ¢ A_i' satisfies Bounds(T_i)
Î“ âŠ¢ W[Î¸] ok
âˆ€ j âˆˆ 1..m, Î“ âŠ¢ e_j : S_j[Î¸]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CallTypeArgs(Identifier(f), [A_1, â€¦, A_k], [e_1, â€¦, e_m]) : R[Î¸]

**(Generic-Call-ArgCount-Err)**
DefaultArgs([T_1, â€¦, T_n], [A_1, â€¦, A_k]) = âŠ¥    c = Code(E-TYP-2303)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ CallTypeArgs(Identifier(f), [A_1, â€¦, A_k], [e_1, â€¦, e_m]) â‡‘ c

After substituting type arguments, a `CallTypeArgs` expression is elaborated to a monomorphic `Call`; subsequent phases operate on the elaborated form.

**Type Argument Inference**

When type arguments are not explicitly provided, the implementation MUST infer them using bidirectional type inference (Â§9.4). Inference sources:
1. Types of value arguments at the call site
2. Expected return type from the surrounding context

Generic procedures in classes MUST NOT participate in dynamic dispatch. Such procedures MUST be marked with `[[static_dispatch_only]]` (see Â§5.13.5) and MUST be called only through concrete type references, not through `$Class` references.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2301`, `E-TYP-2306`.


#### 13.1.3 Generic Constraints

**Constraint Satisfaction.** Determines whether a type argument satisfies the bounds declared for a type parameter.

**Syntax**

```ebnf
where_clause         ::= "where" where_predicate_list
where_predicate_list ::= where_predicate (predicate_separator where_predicate)* predicate_separator?
where_predicate      ::= predicate_name "(" type ")"
predicate_name       ::= "Bitcopy" | "Clone" | "Drop" | "FfiSafe"
predicate_separator  ::= terminator
```


**Static Semantics**

WherePreds(âŠ¥) = []
WherePreds(W) = W

TypeParamsOpt(âŠ¥) = []
TypeParamsOpt(ps) = ps
TypeParamNames(params) = [p.name | p âˆˆ params]
BindTypeParams(Î“, params) = Î“, T_1 : P_1, â€¦, T_n : P_n    where params = [P_1, â€¦, P_n] âˆ§ âˆ€ i. T_i = P_i.name

DefaultArgs(params, args) = args' â‡” params = [P_1, â€¦, P_n] âˆ§ args = [A_1, â€¦, A_k] âˆ§ k â‰¤ n âˆ§
  (âˆ€ i â‰¤ k. A_i' = A_i) âˆ§
  (âˆ€ i âˆˆ k+1..n. P_i.default_opt = T_i âˆ§ A_i' = TypeSubst([A_1'/P_1.name, â€¦, A_{i-1}'/P_{i-1}.name], T_i)) âˆ§
  args' = [A_1', â€¦, A_n']

DefaultArgs(params, args) = âŠ¥ â‡” Â¬âˆƒ args'. DefaultArgs(params, args) = args'

**(WherePred-WF-Predicate)**

wp = PredWherePred(pred, ty)    pred âˆˆ PredicateName    Î“' = BindTypeParams(Î“, params)    Î“' âŠ¢ ty wf
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; params âŠ¢ wp wf

Î“; params âŠ¢ W wf â‡” âˆ€ wp âˆˆ WherePreds(W). Î“; params âŠ¢ wp wf

PredOk(`Bitcopy`, T) â‡” BitcopyType(T)
PredOk(`Clone`, T) â‡” CloneType(T)
PredOk(`Drop`, T) â‡” DropType(T)
PredOk(`FfiSafe`, T) â‡” Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(T-Constraint-Sat)**

âˆ€ B âˆˆ Bounds, Î“ âŠ¢ A <: B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ A satisfies Bounds

**(WherePred-Predicate)**

wp = âŸ¨pred, tyâŸ©    PredOk(pred, ty[Î¸])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ wp[Î¸] ok

Î“ âŠ¢ W[Î¸] ok â‡” âˆ€ wp âˆˆ WherePreds(W). Î“ âŠ¢ wp[Î¸] ok

**(T-Generic-Inst)**

NameâŸ¨P_1, â€¦, P_nâŸ© where W declared    DefaultArgs([P_1, â€¦, P_n], [A_1, â€¦, A_k]) = [A'_1, â€¦, A'_n]    Î¸ = [A'_i / P_i.name]
âˆ€ i âˆˆ 1..n, Î“ âŠ¢ A'_i satisfies Bounds(P_i)    Î“ âŠ¢ W[Î¸] ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ NameâŸ¨A_1, â€¦, A_kâŸ© wf

When both inline bounds and a `where` clause specify constraints for the same parameter, the effective constraint is the conjunction of the inline class bounds and the `where` predicates.

**Constraints**

1. A class bound MUST reference a valid class type; bounding by non-class types is forbidden.
2. A where predicate MUST use a predicate name from PredicateName.
3. A generic instantiation MUST satisfy DefaultArgs(params, args) â‰  âŠ¥.
4. Type arguments MUST satisfy all inline bounds and all `where` predicates.

**Diagnostics:** See Appendix A, codes `E-TYP-2302`, `E-TYP-2303`, `E-TYP-2305`.


#### 13.1.4 Monomorphization

**Monomorphization.** The process of generating specialized code for each concrete instantiation of a generic type or procedure.

Given a generic declaration DâŸ¨T_1, â€¦, T_nâŸ© and concrete type arguments A_1, â€¦, A_n, monomorphization produces a specialized declaration D[A_1/T_1, â€¦, A_n/T_n] where each occurrence of T_i in the body is replaced with A_i.

**Static Semantics**

**Monomorphization Requirements**

1. **Specialization:** For each instantiation DâŸ¨A_1, â€¦, A_nâŸ©, produce code equivalent to substituting each type argument for its corresponding parameter throughout the declaration body.

2. **Zero Overhead:** Calls to generic procedures MUST compile to direct static calls to the specialized instantiation. Virtual dispatch is prohibited for static polymorphism.

3. **Independent Instantiation:** Each distinct instantiation is an independent type or procedure. `Container<i32>` and `Container<i64>` are distinct types.

**Recursion Depth**

Monomorphization MAY produce recursive instantiations. Implementations MUST detect and reject infinite monomorphization recursion. The maximum instantiation depth is 128.

**Variance**

The variance of each type parameter is determined by its usage within the type definition. See Â§9.3 for variance specification.

**Dynamic Semantics**

**Layout Independence**

Each monomorphized instantiation has an independent memory layout:

sizeof(NameâŸ¨A_1, â€¦, A_nâŸ©) = sizeof(Name[A_1/T_1, â€¦, A_n/T_n])

alignof(NameâŸ¨A_1, â€¦, A_nâŸ©) = alignof(Name[A_1/T_1, â€¦, A_n/T_n])

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2307`, `E-TYP-2308`.


### 13.2 Classes (Forms)


#### 13.2.1 Class Declaration Syntax

**Class.** A named declaration that defines an abstract interface consisting of procedure signatures, associated type declarations, abstract fields, and abstract states.

A class Cl is defined as a tuple:

Cl = (N, G, S, P_abs, P_con, A_abs, A_con, F, St)

where:
- N is the class name
- G is the (possibly empty) set of generic type parameters
- S is the (possibly empty) set of superclass bounds
- P_abs is the set of abstract procedure signatures
- P_con is the set of concrete procedure definitions (default implementations)
- A_abs is the set of abstract associated type declarations
- A_con is the set of concrete associated type bindings
- F is the (possibly empty) set of abstract field declarations
- St is the (possibly empty) set of abstract state declarations

A class with St â‰  âˆ… is a **modal class**. Only modal types MUST implement modal classes.

A type T **implements** class Cl (written T <: Cl) when:

T <: Cl â‡” âˆ€ p âˆˆ P_abs. T defines p âˆ§ âˆ€ a âˆˆ A_abs. T binds a âˆ§ âˆ€ f âˆˆ F. T has f âˆ§ âˆ€ s âˆˆ St. T has s

**Syntax**

```ebnf
class_declaration ::=
    visibility? "class" identifier generic_params?
    ("<:" superclass_bounds)? "{"
        class_item*
    "}"

superclass_bounds ::= class_bound ("+" class_bound)*
class_bound       ::= type_path generic_args?

class_item ::=
    abstract_procedure
  | concrete_procedure
  | associated_type
  | abstract_field
  | abstract_state

abstract_procedure ::= "procedure" identifier signature contract_clause?
concrete_procedure ::= "procedure" identifier signature contract_clause? block
abstract_field     ::= identifier ":" type
abstract_state     ::= "@" identifier "{" field_list? "}"
field_list         ::= abstract_field ("," abstract_field)*
```


**Static Semantics**

**(WF-Class)**

unique(N)    âˆ€ p âˆˆ P. Î“, Self : Type âŠ¢ p wf    Â¬ cyclic(S)    names_disjoint(P, A, F, St)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ class N [<: S] {P, A, F, St} wf

**(T-Superclass)**

class A <: B    T <: A
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: B

Within a class declaration, `Self` denotes the (unknown) implementing type.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2500`, `E-TYP-2504`, `E-TYP-2505`, `E-TYP-2508`, `E-TYP-2509`, `E-TYP-2408`, `E-TYP-2409`.


#### 13.2.2 Associated Methods

**Abstract Procedure.** A procedure signature within a class that lacks a body. Implementing types MUST provide a concrete implementation.

**Concrete Procedure.** A procedure definition within a class that includes a body. Implementing types automatically inherit this procedure but MAY override it using the `override` keyword.

**Static Semantics**

**(WF-Class-Self)**

Î“, Self : Type âŠ¢ body : ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ class T { body } : Class


#### 13.2.3 Associated Types

**Associated Type.** A type declaration within a class:
- If abstract (no `= T`): implementing types MUST provide a concrete type binding
- If concrete (`= T`): provides a default type that MAY be overridden

**Syntax**

```ebnf
associated_type ::= "type" identifier ("=" type)?
```



**Static Semantics**

Generic class parameters (`class Foo<T>`) are specified at use-site. Associated types are specified by the implementer within the type body.

**Class Alias Equivalence (T-Alias-Equiv)**

type Alias = A + B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: Alias â‡” Î“ âŠ¢ T <: A âˆ§ Î“ âŠ¢ T <: B


### 13.3 Class Implementation


#### 13.3.1 Implementation Blocks

**Class Implementation.** A type implements a class by:
1. Declaring the class in its "implements clause" using the `<:` operator
2. Providing implementations for all abstract procedures
3. Providing type bindings for all abstract associated types
4. Having fields with matching names and compatible types for all abstract fields
5. Having states with matching names and required payload fields for all abstract states (modal classes only)

Class implementation MUST occur at the type's definition site. Extension implementations are prohibited.

**Syntax**

```ebnf
impl_procedure    ::= visibility? "override"? "procedure" identifier signature block
```


**Static Semantics**

**(T-Impl-Complete)**

T <: Cl    âˆ€ p âˆˆ P_abs(Cl). T defines p    âˆ€ a âˆˆ A_abs(Cl). T binds a    âˆ€ f âˆˆ F(Cl). T has f    âˆ€ s âˆˆ St(Cl). T has s
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T implements Cl

**(WF-Impl)**

Î“ âŠ¢ T wf    Î“ âŠ¢ Cl wf    St(Cl) â‰  âˆ… â‡’ T is modal
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ T <: Cl wf

**Override Semantics**

- **Implementing an abstract procedure**: `override` keyword MUST NOT be used
- **Overriding a concrete procedure**: `override` keyword MUST be used

**Coherence Rule**

A type `T` MAY implement a class `Cl` at most once.

**Orphan Rule**

For `T <: Cl`, at least one of `T` or `Cl` MUST be defined in the current assembly.

**(T-Field-Compat)**

f : T_c âˆˆ F(Cl)    f : T_i âˆˆ fields(R)    T_i <: T_c
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
R âŠ¢ f present

**(T-Modal-Class)**

St(Cl) â‰  âˆ…    T <: Cl    T is not a modal type
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ill-formed: E-TYP-2401

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2501`â€“`E-TYP-2507`, `E-TYP-2401`â€“`E-TYP-2407`.


### 13.4 Class Constraints


#### 13.4.1 Single Constraints

**Class Constraint.** A generic parameter `T <: Cl` restricts valid type arguments to types implementing class `Cl`.

**Static Semantics**

**Constraint Satisfaction**

A generic instantiation is well-formed only if every constrained parameter `T <: Cl` is instantiated with a type that implements `Cl`.

**Method Availability**

Within the body of a generic item, methods of `Cl` are callable on values of type `T` via static dispatch; calls resolve at monomorphization with no vtable lookup.


#### 13.4.2 Multiple Constraints (`+`)

**Multiple Constraints.** A type parameter MAY have multiple class bounds using the `+` separator or comma-separated bounds after `<:`.

**Syntax**


**Static Semantics**

The type argument must implement all specified classes.


#### 13.4.3 Where Clauses

**Where Clauses.** As an alternative to inline bounds, constraints MAY be specified in a `where` clause. See Â§13.1.3 for full grammar.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2530`, `E-TYP-2531`.


### 13.5 Dynamic Polymorphism (`$`)


#### 13.5.1 Dynamic Class Objects

**Dynamic Class Type.** A `$Class` is a concrete, sized type representing any value implementing a dispatchable class. Implemented as a dense pointer.

**Syntax**

```ebnf
dynamic_type ::= "$" class_path
class_path   ::= type_path
```


**Static Semantics**

**(T-Dynamic-Form)**

Î“ âŠ¢ v : T    Î“ âŠ¢ T <: Cl    dispatchable(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ v : $Cl

**Dispatchability**

A class is **dispatchable** if every procedure in the class is either:
1. VTable-eligible, OR
2. Explicitly excluded via `[[static_dispatch_only]]`

**VTable Eligibility**

A procedure is **vtable-eligible** if ALL of the following are true:
1. Has a receiver parameter (`self`, `~`, `~!`, `~%`)
2. Has NO generic type parameters
3. Does NOT return `Self` by value (except via pointer indirection)
4. Does NOT use `Self` in parameter types (except via pointer indirection)

**Formal Definition**

dispatchable(Cl) â‡” âˆ€ p âˆˆ procedures(Cl). vtable_eligible(p) âˆ¨ has_static_dispatch_attr(p)

**Dynamic Semantics**

**Dynamic Class Type Creation**

1. Let `v` be a value of concrete type `T` where `T <: Cl` and `dispatchable(Cl)`.
2. Let `dp` be a pointer to the storage of `v`.
3. Let `vt` be the static vtable for the `(T, Cl)` type-class pair.
4. Construct the dynamic class value as the pair `(dp, vt)`.

**(E-Dynamic-Form)**

Î“ âŠ¢ v : T    T <: Cl    dispatchable(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
v â‡’_$ (ptr(v), vtable(T, Cl))

**Memory Layout**

A dynamic class type (`$Class`) is represented as a two-word structure:

- **Size**: `2 * sizeof(usize)` (16 bytes on 64-bit platforms)
- **Alignment**: `alignof(usize)`



#### 13.5.2 Virtual Method Dispatch

**Virtual Method Dispatch.** A procedure call on a dynamic class type dispatches through the vtable.

**Dynamic Semantics**

**VTable Dispatch Algorithm**

A procedure call `w~>method(args)` on dynamic class type `w: $Cl` executes as follows:

1. Let `(dp, vt)` be the data pointer and vtable pointer components of `w`.
2. Let `offset` be the vtable offset for `method`.
3. Let `fp` be the function pointer at `vt + header_size + offset * sizeof(usize)`.
4. Return the result of calling `fp(dp, args)`.

**(E-Dynamic-Dispatch)**

w = (dp, vt)    method âˆˆ interface(Cl)    vt[offset(method)] = fp
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
w~>method(args) â†’ fp(dp, args)

**VTable Layout (Stable ABI)**

For non-modal classes (header size = 3):
1. `size: usize` â€” Size of concrete type
2. `align: usize` â€” Alignment requirement
3. `drop: *imm fn` â€” Destructor function pointer (null if DropType of the concrete type does not hold)
4. `methods[..]` â€” Function pointers in class declaration order

For modal classes (header size = 4): includes additional `state_map` pointer.


#### 13.5.3 Object Safety

**Object Safety.** Determines whether a class MAY be used as a dynamic class type (dispatchability).

**Static Semantics**

A class that contains non-vtable-eligible procedures without `[[static_dispatch_only]]` is NOT dispatchable.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2540`â€“`E-TYP-2542`.


### 13.6 Opaque Polymorphism (`opaque`)


#### 13.6.1 Opaque Return Types

**Opaque Return Type.** An `opaque Class` exposes only the class's interface while hiding the concrete implementation type.

**Syntax**
*[REF: Return-type grammar is defined in Â§14.1.1.]*


**Static Semantics**

**(T-Opaque-Return)**

Î“ âŠ¢ body : T    Î“ âŠ¢ T <: Cl    return_type(f) = opaque Cl
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f : () â†’ opaque Cl

**(T-Opaque-Project)**

At call sites, the opaque type is treated as an existential; callers MUST invoke only class methods:

Î“ âŠ¢ f() : opaque Cl    m âˆˆ interface(Cl)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f()~>m(args) : R_m

**Type Encapsulation**

For a procedure returning `opaque Class`:
- The callee returns a concrete type implementing `Class`
- The caller observes only `Class` members
- Access to concrete type members is forbidden


#### 13.6.2 Type Erasure

**Type Erasure.** Opaque types provide type encapsulation without runtime overhead.

**Static Semantics**

**Opaque Type Equality**

Two opaque types `opaque Cl` are equivalent if and only if they originate from the same procedure definition:

f â‰  g
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
typeof(f()) â‰  typeof(g())

**Zero Overhead**

Opaque types MUST incur zero runtime overhead. The returned value is the concrete type, not a dense pointer. Type encapsulation is enforced statically.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-TYP-2510`â€“`E-TYP-2512`.


### 13.7 Refinement Types


#### 13.7.1 Refinement Syntax

**Refinement Type.** A type constructed by attaching a predicate constraint to a base type. The refinement type `T where { P }` denotes the subset of values of type `T` for which predicate `P` evaluates to `true`.

A refinement type R is defined by:

R = (T_base, P)

where:
- T_base âˆˆ ð’¯ is the base type being refined
- P : T_base â†’ `bool` is a pure predicate constraining the value set

Values(T where {P}) = { v âˆˆ Values(T) | P(v) = `true` }

A refinement type is a **proper subtype** of its base type.

**Syntax**

```ebnf
refinement_type       ::= type "where" "{" predicate_expr "}"
type_alias_decl       ::= visibility? "type" identifier "=" type "where" "{" predicate_expr "}"
param_with_constraint ::= identifier ":" type "where" "{" predicate_expr "}"
```


Within standalone refinement types, `self` refers to the constrained value. In parameter constraints, the parameter name is used instead.


#### 13.7.2 Refinement Constraints

**Static Semantics**

**(WF-Refine-Type)**

Î“ âŠ¢ T wf    Î“, `self` : T âŠ¢ P : `bool`    Pure(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (T where {P}) wf

**(T-Refine-Intro)**

Î“ âŠ¢ e : T    Î“ âŠ¢ F(P[e/`self`], L)    L dominates current location
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : T where {P}

**(T-Refine-Elim)**

Î“ âŠ¢ e : T where {P}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ e : T

**Subtyping Rules**

Î“ âŠ¢ (T where {P}) <: T

Î“ âŠ¢ P â‡’ Q
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ (T where {P}) <: (T where {Q})

**Nested Refinements**

(T where {P}) where {Q} â‰¡ T where {P âˆ§ Q}

**Decidable Predicate Subset**

Implementations MUST support:
1. Literal comparisons
2. Bound propagation from control flow
3. Syntactic equality (up to alpha-renaming)
4. Transitive inequalities (linear arithmetic over integers)
5. Boolean combinations of decidable predicates


#### 13.7.3 Refinement Verification

**Static Semantics**

Refinement predicates require static proof by default:

1. Implementation attempts static verification
2. If verification succeeds, no runtime code is generated
3. If verification fails and not in `[[dynamic]]` scope: ill-formed (E-TYP-1953)
4. If verification fails in `[[dynamic]]` scope: runtime check is generated

**Dynamic Semantics**

**Representation**

sizeof(T where {P}) = sizeof(T)

alignof(T where {P}) = alignof(T)

The predicate is a compile-time and runtime constraint only; it does not affect physical representation.

**Constraints**

Failed runtime checks trigger a panic (`P-TYP-1953`).

**Diagnostics:** See Appendix A.


### 13.8 Capability Classes

*[REF: Capability fundamentals defined in Â§1.3 (Authority Model). This section covers type-system integration only.]*


#### 13.8.1 Capability Class

**Capability Class.** Regular classes that define system authority interfaces. The dynamic dispatch operator `$` applies uniformly to all classes, including capability classes.

**Syntax**


**Static Semantics**

A parameter of type `$Class` accepts any concrete type `T` implementing `Class`. This is the same mechanism as for any other classâ€”capability classes have no special type-system behavior.

See Â§1.3 for capability propagation, attenuation, and no-ambient-authority rules.


#### 13.8.2 Capability Bounds

**Capability Bounds.** Capability classes MAY be used as bounds in generics like any other class.

**Syntax**


**Static Semantics**

No syntactic distinction exists between capability class bounds and regular class bounds. The capability nature is semantic (enforcement of no-ambient-authority), not syntactic.


### 13.9 Foundational Predicates and Classes

*[REF: Built-in predicate definitions and class signatures are defined in Â§5.11. This section specifies their role in the type system.]*

Foundational predicate and class names are reserved at module scope (see Â§3.2.3).


#### 13.9.1 `Drop` Predicate

**Drop Predicate.** `DropType(T)` holds for types with built-in drop behavior or a `drop` method with the required signature (Â§5.11). The `drop` method is invoked implicitly when a binding goes out of scope.

**Static Semantics**

- The `drop` method MUST NOT be called directly by user code (`E-MEM-3005`, Â§5.3.1).
- `BitcopyType` and `DropType` are mutually exclusive on the same type.

**Constraints**

**Diagnostics:** See Appendix A, code `E-TYP-2621`.


#### 13.9.2 `Bitcopy` Predicate

**Bitcopy Predicate.** `BitcopyType(T)` holds for types that MAY be implicitly duplicated via bitwise copy (Â§5.11).

**Static Semantics**

- `BitcopyType` values are duplicated (not moved) on assignment and parameter passing.
- `BitcopyType` requires all fields to satisfy `BitcopyType`.
- `BitcopyType(T)` implies `CloneType(T)`. For such values, `clone()` performs a bitwise copy identical to the implicit copy operation.

**Constraints**

**Diagnostics:** See Appendix A, code `E-TYP-2622`.


#### 13.9.3 `Clone` Predicate

**Clone Predicate.** `CloneType(T)` holds for types with built-in cloning behavior or a `clone` method with the required signature (Â§5.11).

**Static Semantics**

For `BitcopyType` values, `clone()` performs a bitwise copy identical to the implicit copy operation.


#### 13.9.4 `Eq` and `Hash` Classes

**Eq and Hash Classes.** Define equality comparison and hashing for use in collections.

**Static Semantics**

See Â§5.11 for `Eq` and `Hash` signatures and semantic requirements, including equivalence properties and hash consistency.

Types implementing `Hash` MUST also implement `Eq`. If two values are equal per `Eq::eq`, they MUST produce the same hash value.


#### 13.9.5 `Iterator` Class

**Iterator Class.** Defines the iteration protocol for `loop ... in` expressions.

**Syntax**

```cursive
class Iterator {
    type Item
    procedure next(~!) -> Self::Item | ()
}
```


**Static Semantics**

Range types implement `Iterator` when their element type implements `Step`.


#### 13.9.6 `Step` Class

**Step Class.** Defines discrete stepping for range iteration.

**Syntax**

```cursive
class Step {
    procedure successor(~) -> Self | ()
    procedure predecessor(~) -> Self | ()
}
```


---

## 14. Procedures and Contracts

### 14.4 Contract Syntax

#### 14.4.1 Contract Clause Position

**Contract.** A specification attached to a procedure declaration that asserts logical predicates over program state. Contracts govern logical validity through preconditions (caller obligations) and postconditions (callee guarantees).

A contract C is a pair (P_pre, P_post) where:
- P_pre is a conjunction of boolean predicates representing preconditions
- P_post is a conjunction of boolean predicates representing postconditions

**Syntax**

```ebnf
contract_clause    ::= "|=" contract_body
contract_body      ::= precondition_expr
                     | precondition_expr "=>" postcondition_expr
                     | "=>" postcondition_expr

precondition_expr  ::= predicate_expr
postcondition_expr ::= predicate_expr
predicate_expr     ::= logical_or_expr
contract_intrinsic ::= "@result" | "@entry" "(" expression ")"
```

A contract clause (`|=`) MUST appear after the return type annotation (or after the parameter list if no return type) and before the procedure body.




**Static Semantics**

**(WF-Contract)**

Î“_pre âŠ¢ P_pre : `bool`    pure(P_pre)
Î“_post âŠ¢ P_post : `bool`    pure(P_post)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `|=` P_pre â‡’ P_post : WF

**Logical Operators**

Predicates use standard boolean operators with precedence (highest to lowest):
1. `!` (logical NOT) â€” right-associative
2. `&&` (logical AND) â€” left-associative, short-circuit
3. `||` (logical OR) â€” left-associative, short-circuit


#### 14.4.2 Purity Constraints

**Pure Expression.** An expression whose evaluation produces no observable side effects. All expressions within a contract MUST be pure.

**Static Semantics**

An expression e satisfies pure(e) iff:
1. e MUST NOT invoke any procedure that accepts capability parameters
2. e MUST NOT mutate state observable outside the expression's evaluation
3. Built-in operators on primitive types and `comptime` procedures are always pure


#### 14.4.3 Evaluation Contexts

**Evaluation Context.** Defines the set of bindings available for reference within a predicate expression.

**Static Semantics**

**Precondition Evaluation Context (Î“_pre)**

Includes:
- All procedure parameters at their entry state
- The receiver binding (if present)
- All bindings visible in the enclosing scope accessible without side effects

MUST NOT include:
- The `@result` intrinsic
- The `@entry` operator
- Any binding introduced within the procedure body

**Postcondition Evaluation Context (Î“_post)**

Includes:
- All procedure parameters:
  - Immutable parameters (`const`, `~`): same value as at entry
  - Mutable parameters (`unique`, `shared`): post-state value
- The receiver binding (post-state for mutable receivers)
- The `@result` intrinsic
- The `@entry` operator
- All bindings visible in the enclosing scope

**Mutable Parameter State Semantics**

| Location in Contract          | State Referenced |
| :---------------------------- | :--------------- |
| Left of `=>`                  | Entry state      |
| Right of `=>` (bare)          | Post-state       |
| Right of `=>` with `@entry()` | Entry state      |


### 14.5 Pre/Postconditions

#### 14.5.1 Precondition Syntax (`|=`)

**Precondition.** The logical expression appearing to the left of `=>` in a `|=` contract clause, or the entire expression if `=>` is absent. The caller MUST ensure this expression evaluates to `true` prior to the call.

**Static Semantics**

**(Pre-Satisfied)**

Î“ âŠ¢ f : (T_1, â€¦, T_n) â†’ R    precondition(f) = P_pre    StaticProof(Î“_S, P_pre)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ f(a_1, â€¦, a_n) @ S : valid

Failure to satisfy a precondition is diagnosed at the **caller**. The diagnostic MUST identify the call site.

**Elision Rules**

| Contract Form        | Precondition              |
| :------------------- | :------------------------ |
| `|= P`              | P                         |
| `|= P => Q`         | P                         |
| `|= => Q`           | `true` (always satisfied) |
| (no contract clause) | `true` (always satisfied) |


#### 14.5.2 Postcondition Syntax (`=>`)

**Postcondition.** The logical expression appearing to the right of `=>` in a `|=` contract clause. The callee MUST ensure this expression evaluates to `true` immediately before returning.

**Static Semantics**

**(Post-Valid)**

postcondition(f) = P_post    âˆ€ r âˆˆ ReturnPoints(f). Î“_r âŠ¢ P_post : satisfied
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
f : postcondition-valid

Failure to satisfy a postcondition is diagnosed at the **callee**. The diagnostic MUST identify the return point.

**Elision Rules**

| Contract Form        | Postcondition             |
| :------------------- | :------------------------ |
| `|= P`              | `true` (no postcondition) |
| `|= P => Q`         | Q                         |
| `|= => Q`           | Q                         |
| (no contract clause) | `true` (always satisfied) |


#### 14.5.3 `@result` Binding in Postconditions

**@result Intrinsic.** Refers to the return value in postcondition expressions.

**Static Semantics**

| Property     | Specification                                  |
| :----------- | :--------------------------------------------- |
| Availability | Postcondition expressions only (right of `=>`) |
| Type         | The return type of the enclosing procedure     |
| Value        | The value being returned from the procedure    |
| Unit Returns | If procedure returns `()`, `@result` has `()`  |

**Constraints**

Use of `@result` outside postcondition expressions is ill-formed (`E-SEM-2806`).

**Dynamic Semantics**

At each return point r with returned value v_r, postconditions are evaluated with `@result` bound to v_r.


#### 14.5.4 `@entry()` Expression

**@entry Operator.** Evaluates `expr` in the entry state of the procedure.

**Static Semantics**

| Property              | Specification                                             |
| :-------------------- | :-------------------------------------------------------- |
| Availability          | Postcondition expressions only (right of `=>`)            |
| Semantics             | Evaluates `expr` in entry state of the procedure          |
| Evaluation Point      | After parameter binding, before body execution            |
| Expression Constraint | `expr` MUST be pure                                       |
| Expression Scope      | `expr` MUST reference only parameters and receiver        |
| Type Constraint       | Result type of `expr` MUST satisfy `BitcopyType` or `CloneType` |

**(Entry-Type)**

Î“_post âŠ¢ e : T    (BitcopyType(T) âˆ¨ CloneType(T))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“_post âŠ¢ @entry(e) : T

**Dynamic Semantics**

**Capture Semantics**

When `@entry(expr)` appears in a postcondition:
1. The implementation evaluates `expr` immediately after parameter binding
2. The result is captured: `BitcopyType` types use bitwise copy; other `CloneType` types invoke `clone()`
3. In the postcondition, `@entry(expr)` refers to this captured value

**Constraints**

If the result type of `expr` does not satisfy `BitcopyType` or `CloneType`, the program is ill-formed (`E-SEM-2805`).


### 14.6 Invariants

#### 14.6.1 Type Invariants

**Type Invariant.** A `where` clause attached to a `record`, `enum`, or `modal` type declaration. The invariant constrains all instances of the type.

**Syntax**

```ebnf
type_invariant ::= "where" "{" predicate_expr "}"
```


**Static Semantics**

**Invariant Predicate Context**

Within a type invariant predicate:
- `self` refers to an instance of the type being defined
- Field access on `self` is permitted
- Method calls on `self` are permitted if the method is pure

**Enforcement Points**

| Enforcement Point   | Description                                       |
| :------------------ | :------------------------------------------------ |
| Post-Construction   | After constructor or literal initialization       |
| Pre-Call (Public)   | Before any public procedure with receiver         |
| Post-Call (Mutator) | Before any procedure taking `unique self` returns |

**Public Field Constraint**

Types with type invariants MUST NOT declare public mutable fields.

**Private Procedure Exemption**

Private procedures (`internal` or less) are exempt from the Pre-Call enforcement point. The type invariant MUST be verified when a private procedure returns to a public caller.


#### 14.6.2 Loop Invariants

**Loop Invariant.** A `where` clause attached to a `loop` expression. The invariant specifies a predicate that MUST hold at the beginning of every iteration and after termination.

**Syntax**

```ebnf
loop_expression ::= "loop" loop_condition? loop_invariant? block_expr
loop_condition  ::= expression
loop_invariant  ::= "where" "{" predicate_expr "}"
```


**Static Semantics**

**Enforcement Points**

| Point          | Description                               | Formal                                                 |
| :------------- | :---------------------------------------- | :----------------------------------------------------- |
| Initialization | Before the first iteration begins         | Î“_0 âŠ¢ Inv                                              |
| Maintenance    | At the start of each subsequent iteration | Î“_i âŠ¢ Inv â‡’ Î“_(i+1) âŠ¢ Inv                               |
| Termination    | Immediately after loop terminates         | Î“_exit âŠ¢ Inv                                           |

**Verification Fact Generation**

Upon successful verification at the Termination point, the implementation generates a Verification Fact F(Inv, L_exit) for use as a postcondition of the loop.


#### 14.6.3 Invariant Verification

**Static Semantics**

Invariant verification follows the same rules as contract verification (Â§14.7):
- Static verification required by default
- `[[dynamic]]` attribute permits runtime verification when static proof fails


### 14.7 Verification Logic

#### 14.7.1 Contract Verification Modes

**Contract Verification.** Determines how predicates are ensured to hold. By default, **static verification is required**. The `[[dynamic]]` attribute permits runtime verification as an explicit opt-in.

**Static Semantics**

**Default: Static Verification Required**

**(Contract-Static-OK)**

StaticProof(Î“_S, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
P : verified (no runtime check)

**(Contract-Static-Fail)**

Â¬ StaticProof(Î“_S, P)    Â¬ InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
program is ill-formed (E-SEM-2801)

**With `[[dynamic]]`: Runtime Verification Permitted**

**(Contract-Dynamic-Elide)**

StaticProof(Î“_S, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
P : verified (no runtime check)

**(Contract-Dynamic-Check)**

Â¬ StaticProof(Î“_S, P)    InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
emit runtime check ContractCheck(P, k, s, Ï)

Here k is the ContractKind at verification location s, and Ï is the corresponding contract environment.

**Mandatory Proof Techniques**

| Technique                | Description                                        |
| :----------------------- | :------------------------------------------------- |
| Constant propagation     | Evaluate expressions with compile-time constants   |
| Linear integer reasoning | Prove inequalities over bounded integer arithmetic |
| Boolean algebra          | Simplify and prove boolean expressions             |
| Control flow analysis    | Track predicates established by conditionals       |
| Type-derived bounds      | Use type constraints (e.g., `usize >= 0`)          |
| Verification facts       | Use facts established by prior checks (Â§14.7.2)    |

**StaticProof Definition**

Let FactsAt(S) = { P | F(P, L) âˆˆ Facts âˆ§ L dom S }.

Define Decidable(P) as the smallest set closed under:

1. `true`, `false`
2. Comparisons of linear integer expressions over literals and variables
3. Syntactic equality (up to alpha-renaming) between identifiers and literal constants
4. Boolean combinations of decidable predicates using `!`, `&&`, `||`

Define entailment FactsAt(S) âŠ¢ P by the rules:

**(Ent-True)**
P â‰¡ `true`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P

**(Ent-Fact)**
P âˆˆ FactsAt(S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P

**(Ent-And)**
FactsAt(S) âŠ¢ P    FactsAt(S) âŠ¢ Q
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P âˆ§ Q

**(Ent-Or-L)**  
FactsAt(S) âŠ¢ P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P âˆ¨ Q

**(Ent-Or-R)**  
FactsAt(S) âŠ¢ Q
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P âˆ¨ Q

**(Ent-Linear)**
LinearEntails(FactsAt(S), P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FactsAt(S) âŠ¢ P

**Linear Integer Entailment**

Let LinExpr be expressions of the form âˆ‘_i a_i x_i + c where a_i, c âˆˆ â„¤ and each x_i is an integer-typed variable. Let LinPred be predicates comparing two LinExpr with `==`, `!=`, `<`, `<=`, `>`, or `>=`.

Define LinFactsAt(S) = { P âˆˆ FactsAt(S) | P âˆˆ LinPred }.

Then:

LinearEntails(FactsAt(S), P) â‡” P âˆˆ LinPred âˆ§ â‹€ LinFactsAt(S) âŠ¨_â„¤ P

Implementations MAY use any sound decision procedure; they MUST be complete for LinPred entailment.

Then:

StaticProof(Î“_S, P) â‡” Decidable(P) âˆ§ FactsAt(S) âŠ¢ P

where S is the verification location for P (Table Â§14.7.1), and Î“_S is the typing environment at S.

**Satisfaction Judgment**

Î“_S âŠ¢ P : satisfied â‡” StaticProof(Î“_S, P)

**Verification Location**

| Contract Type  | Verified Where    | `[[dynamic]]` Context Determined By  |
| :------------- | :---------------- | :----------------------------------- |
| Precondition   | Call site         | The call expression's context        |
| Postcondition  | Definition site   | The procedure's `[[dynamic]]` status |
| Type invariant | Enforcement point | The expression's context             |
| Loop invariant | Enforcement point | The enclosing scope's context        |

**Dynamic Semantics**

**Runtime Check Failure**

When a runtime-checked predicate evaluates to `false`:
1. The runtime MUST trigger a Panic
2. The panic payload MUST include predicate text, source location, and contract type
3. Normal panic propagation rules apply

**Diagnostics:** See Appendix A.


#### 14.7.2 Verification Facts

**Verification Fact.** A static guarantee that a predicate P holds at program location L. Used for static analysis, contract elision, and type narrowing.

A Verification Fact is a triple F(P, L, S) where:
- P is a predicate expression
- L is a program location (CFG node)
- S is the source of the fact (control flow, runtime check, or assumption)

**Static Semantics**

**Zero-Size Property**

Verification Facts:
- Have zero runtime size
- Have no runtime representation
- MUST NOT be stored in variables, passed as parameters, or returned

**Fact Dominance**

**(Fact-Dominate)**

F(P, L) âˆˆ Facts    L dom S    L â‰  S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
P satisfied at S

**Fact Generation Rules**

| Construct                    | Generated Fact                  | Location             |
| :--------------------------- | :------------------------------ | :------------------- |
| `if P { ... }`               | F(P, _)                | Entry of then-branch |
| `if !P { } else { ... }`     | F(P, _)                | Entry of else-branch |
| `match x { Pat => ... }`     | F(x matches Pat, _)    | Entry of match arm   |
| Runtime check for P          | F(P, _)                | After check          |
| Loop invariant Inv at exit   | F(Inv, _)              | After loop           |


#### 14.7.3 Fact Propagation

**Static Semantics**

**Type Narrowing**

When a Verification Fact F(P, L) is active for binding x at location L:

typeof(x) -[F(P, L)]-> typeof(x) `where` {P}

**Dynamic Semantics**

**Dynamic Fact Injection**

When a `[[dynamic]]` scope requires a runtime check and no static fact dominates:

1. Identify requirement P at program point S
2. Construct check block: `if !P { panic("Contract violation: {P}") }`
3. Insert check into CFG such that it dominates S
4. Successful execution establishes F(P, exit(C))


#### 14.7.4 Small-Step and Big-Step Semantics

At each verification location (Table Â§14.7.1), any required runtime check is elaborated to `ContractCheck(P, k, s, Ï)` (with Ï determined by ContractKind) and inserted so that it dominates the guarded program point.

**Definitions**

Let `ContractKind = Pre | Post | TypeInv | LoopInv | ForeignPre | ForeignPost`.

Define the meta-expression:

ContractCheck(P, k, s, Ï) = `if` !P[Ï] { `panic`(ContractViolation(k, P, s)) }

where `P[Ï]` denotes capture-by-value substitution of `@result` and `@entry(expr)` with values in Ï. If `P` contains an intrinsic not bound in Ï, the program is ill-formed. `ContractViolation(k, P, s)` is the tuple âŸ¨k, PredText(P), sâŸ© where PredText(P) is the exact source text of the predicate expression `P` as written in the enclosing contract clause after source normalization (Â§2.2). The panic payload is exactly this tuple.

**Contract Environments**

Let Ï_emptyset = âˆ….

Let EntryCapture(f, Ïƒ_entry) be a map from each syntactically distinct `@entry(expr)` in `postcondition(f)` to its captured value, where each `expr` is evaluated in the entry state Ïƒ_entry using Î“_pre; if any capture panics, the panic propagates.

`EntryCapture` is computed once per procedure invocation and reused for all postcondition checks in that invocation.

For a procedure return at point r with returned value v_r:

- Ï_post = EntryCapture(f, Ïƒ_entry) âˆª {`@result` â†¦ v_r}
- Ï_foreign_post = {`@result` â†¦ v_r}

Then use the following environments:

| ContractKind | Environment |
| :----------- | :---------- |
| `Pre`        | Ï_emptyset |
| `Post`       | Ï_post |
| `TypeInv`    | Ï_emptyset |
| `LoopInv`    | Ï_emptyset |
| `ForeignPre` | Ï_emptyset |
| `ForeignPost`| Ï_foreign_post |

**Small-Step (Contract Check Machine)**

CheckState = {CheckStart(P, k, s, Ï, Ïƒ), CheckDone(Ïƒ), CheckPanic(Ïƒ)}

**(Check-True)**
Î“ âŠ¢ EvalSigma(P[Ï], Ïƒ) â‡“ (Val(true), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CheckStart(P, k, s, Ï, Ïƒ)âŸ© â†’ âŸ¨CheckDone(Ïƒ')âŸ©

**(Check-False)**
Î“ âŠ¢ EvalSigma(P[Ï], Ïƒ) â‡“ (Val(false), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CheckStart(P, k, s, Ï, Ïƒ)âŸ© â†’ âŸ¨CheckPanic(Ïƒ')âŸ©

**(Check-Panic)**
Î“ âŠ¢ EvalSigma(P[Ï], Ïƒ) â‡“ (Ctrl(Panic), Ïƒ')
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŸ¨CheckStart(P, k, s, Ï, Ïƒ)âŸ© â†’ âŸ¨CheckPanic(Ïƒ')âŸ©

`CheckPanic` denotes a panic with payload `ContractViolation(k, P, s)` when the predicate evaluates to `false`, and it propagates any inner panic produced by evaluating `P`.

**Big-Step**

**(Check-Ok)**
âŸ¨CheckStart(P, k, s, Ï, Ïƒ)âŸ© â†’* âŸ¨CheckDone(Ïƒ')âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ContractCheck(P, k, s, Ï, Ïƒ) â‡“ Ïƒ'

**(Check-Fail)**
âŸ¨CheckStart(P, k, s, Ï, Ïƒ)âŸ© â†’* âŸ¨CheckPanic(Ïƒ')âŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ContractCheck(P, k, s, Ï, Ïƒ) â‡‘ panic


### 14.8 Behavioral Subtyping

#### 14.8.1 Liskov Substitution Principle

**Liskov Substitution.** When a type implements a class, procedure implementations MUST adhere to the Liskov Substitution Principle with respect to class-defined contracts.

**Static Semantics**

**Precondition Weakening**

An implementation MAY weaken (require less than) the preconditions defined in the class. An implementation MUST NOT strengthen (require more than) the preconditions.

**Postcondition Strengthening**

An implementation MAY strengthen (guarantee more than) the postconditions defined in the class. An implementation MUST NOT weaken (guarantee less than) the postconditions.

**Verification Strategy**

Behavioral subtyping constraints are verified **statically at compile-time**:

1. **Precondition Check**: Verify that the implementation's precondition logically implies the class's precondition
2. **Postcondition Check**: Verify that the class's postcondition logically implies the implementation's postcondition

No runtime checks are generated for behavioral subtyping; violations are structural errors.


#### 14.8.2 Contract Inheritance

*[REF: Behavioral subtyping constraints in Â§14.8.1 govern contract inheritance.]*


## 17. The Key System

### 17.1 Keys

#### 17.1.1 Key Definition

**Key.** A static proof of access rights to a specific path within `shared` data.

**Static Semantics**

Keys are a compile-time verification mechanism. Key state is tracked during type checking. Runtime synchronization is introduced only when static analysis fails to prove safety (see Â§17.6).

**Key Invariants**

1. **Path-specificity:** A key to path P grants access only to P and paths for which P is a prefix.
2. **Implicit acquisition:** Accessing a `shared` path logically acquires the necessary key.
3. **Scoped lifetime:** Keys are valid for a bounded lexical scope and become invalid when that scope exits.
4. **Reentrancy:** If a key covering path P is already held, nested access to P or any path prefixed by P succeeds without conflict.
5. **Task locality:** Keys are associated with tasks. A key held by a task remains valid until its scope exits.


#### 17.1.2 Key Triple (Path, Mode, Scope)

**Key Triple.** A key consists of: **Path** (the memory location being accessed), **Mode** (`Read` or `Write`), and **Scope** (the lexical scope during which the key is valid).

**Syntax**

**Path Expression Grammar**

```ebnf
key_path_expr   ::= root_segment ("." path_segment)*
root_segment    ::= key_marker? identifier index_suffix?
path_segment    ::= key_marker? identifier index_suffix?
key_marker      ::= "#"
index_suffix    ::= "[" expression "]"
```

**Static Semantics**

**Path Well-Formedness**

A path expression is well-formed if each segment is valid for the type of the previous segment (field access on records, indexing on arrays/slices). A path expression MUST contain at most one `#` marker.

**Key Analysis Requirement**

Key analysis is performed if and only if the path's root has `shared` permission. Paths with `const` or `unique` permission do not require keys.



#### 17.1.3 Read Mode

**Read Mode.** A key mode that permits read-only access to a path. Multiple Read keys to overlapping paths MAY coexist.

**Static Semantics**

**(K-Mode-Read)**
Î“ âŠ¢ e : `shared` T    ReadContext(e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequiredMode(e) = Read

**Read Context Classification**

| Syntactic Position                           | Context |
| :------------------------------------------- | :------ |
| Right-hand side of `let`/`var` initializer   | Read    |
| Right-hand side of assignment (`=`)          | Read    |
| Operand of arithmetic/logical operator       | Read    |
| Argument to `const` or `shared` parameter    | Read    |
| Condition expression (`if`, `loop`, `match`) | Read    |
| Receiver of method with `~` receiver         | Read    |


#### 17.1.4 Write Mode

**Write Mode.** A key mode that permits read and write access to a path. A Write key excludes all other keys to overlapping paths.

**Static Semantics**

**(K-Mode-Write)**
Î“ âŠ¢ e : `shared` T    WriteContext(e)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RequiredMode(e) = Write

**Write Context Classification**

| Syntactic Position                                 | Context |
| :------------------------------------------------- | :------ |
| Left-hand side of assignment (`=`)                 | Write   |
| Left-hand side of compound assignment (`+=`, etc.) | Write   |
| Receiver of method with `~!` receiver              | Write   |
| Receiver of method with `~%` receiver              | Write   |
| Argument to `unique` parameter                     | Write   |

**Disambiguation Rule**

If an expression appears in multiple contexts, the more restrictive context (Write) applies.

**Mode Ordering**

Read < Write

A held mode is sufficient for a required mode when:

ModeSufficient(M_held, M_required) â‡” M_required â‰¤ M_held

**Constraints**

**Diagnostics:** See Appendix A, code `E-CON-0005`.


#### 17.1.5 Key State Context

**Key State Context.** A mapping Î“_keys : ProgramPoint â†’ â„˜(Key) that associates each program point with the set of keys logically held at that point.

**Static Semantics**

**Key Set Operations**

Let Î“_keys be the current key set, a collection of (P, M, S) triples.

**(Acquire)**
Acquire(P, M, S, Î“_keys) = Î“_keys âˆª {(P, M, S)}

**(Release)**
Release(P, Î“_keys) = Î“_keys \ {(P, M, S) : (P, M, S) âˆˆ Î“_keys}

**(Release by Scope)**
ReleaseScope(S, Î“_keys) = Î“_keys \ {(P, M, S') : S' = S}

**(Mode Transition)**
ModeTransition(P, M_new, Î“_keys) = (Î“_keys \ {(P, M_old, S)}) âˆª {(P, M_new, S)}

**Panic Release Semantics**

PanicRelease(S, Î“_keys) = Î“_keys \ {(P, M, S') : S' â‰¤_nest S}

All keys held by the panicking scope and its nested scopes are released atomically before panic unwinding proceeds.


#### 17.1.6 Held Predicate

**Held Predicate.** A key is held at a program point if it is a member of the key state context at that point: Held(P, M, S, Î“_keys, p) â‡” (P, M, S) âˆˆ Î“_keys(p).

**Static Semantics**

**Key Compatibility**

Two keys K_1 = (P_1, M_1, S_1) and K_2 = (P_2, M_2, S_2) are **compatible** if and only if:

Compatible(K_1, K_2) â‡” Disjoint(P_1, P_2) âˆ¨ (M_1 = Read âˆ§ M_2 = Read)

**Compatibility Matrix**

| Key A Mode | Key B Mode | Paths Overlap? | Compatible? |
| :--------- | :--------- | :------------- | :---------- |
| Read       | Read       | Yes            | Yes         |
| Read       | Write      | Yes            | No          |
| Write      | Read       | Yes            | No          |
| Write      | Write      | Yes            | No          |
| Any        | Any        | No (disjoint)  | Yes         |

**Dynamic Semantics**

**Progress Guarantee**

Implementations MUST guarantee eventual progress: any task blocked waiting for a key MUST eventually acquire that key, provided the holder eventually releases it.

Blocked(t, K) âˆ§ Held(K, t') âˆ§ â—‡ Released(K, t') â‡’ â—‡ Acquired(K, t)

**Wait Suspension Restriction**

A `wait` expression is a suspension point. The key set MUST be empty at the suspension point.

**(K-Wait-No-Keys)**
WaitExpr(h) at program point p    Î“_keys(p) â‰  âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0133`)


#### 17.1.7 Key Roots and Key Path Formation

**Key Root.** The base storage location from which a key path is derived. Key roots arise from: (1) **Lexical roots**: identifiers bound in the current scope; (2) **Boundary roots**: runtime object identities created at key boundaries (pointer indirection and type-level boundaries). For any place expression e with `shared` permission, the **key path** KeyPath(e) is the normalized `key_path_expr` used for key acquisition and conflict analysis.

**Static Semantics**

**Path Root Extraction**

Define Root(e) for place expressions (Â§3.4.2) recursively:
Root(e) =
 x                 if e = x
 Root(e')          if e = e'.f
 Root(e')          if e = e'[i]
 Root(e')          if e = e' ~> m(...)
 âŠ¥_boundary        if e = (*e')

where âŠ¥_boundary indicates a **key boundary** introduced by pointer dereference.

**Object Identity**

The **identity** of a reference or pointer r, written id(r), is a unique runtime value denoting the storage location referred to by r.

Implementations MUST ensure:
1. **Uniqueness:** id(r_1) = id(r_2) iff r_1 and r_2 refer to overlapping storage.
2. **Stability:** id(r) remains constant for the lifetime of the referent.
3. **Opacity:** identities are not directly observable except through key semantics.

**KeyPath Formation**

Let e be a place expression accessing `shared` data and let eâ€™s field/index tail be p_2 â€¦ p_n.

- **Lexical root case:** If Root(e) = x, then
  KeyPath(e) = x.p_2 â€¦ p_n truncated by any type-level boundary.

- **Boundary root case:** If Root(e) = âŠ¥_boundary and e = (*e').p_2 â€¦ p_n, then
  KeyPath(e) = id(*e').p_2 â€¦ p_n truncated by any type-level boundary.

Type-level boundaries are defined in Â§17.2.4.

**Pointer Indirection**

A pointer dereference establishes a new key boundary. Key paths do not extend across pointer indirections.

For `(*e').p` where `e' : shared Ptr<T>@Valid`:
1. Dereferencing `e'` requires a key to KeyPath(e') in Read mode.
2. Accessing `.p` on the dereferenced value uses a fresh key rooted at id(*e').

**Constraints**

**Diagnostics:** See Appendix A, code `E-CON-0034`.

### 17.2 Acquisition and `#` Blocks


#### 17.2.1 Implicit Key Acquisition

**Implicit Acquisition.** Keys are logically acquired on demand during expression evaluation and released at scope exit.

**Static Semantics**

**Key Lifecycle Phases**

1. **Acquisition Phase:** Keys are logically acquired as `shared` paths are evaluated, in evaluation order
2. **Execution Phase:** The statement or block body executes with all keys logically held
3. **Release Phase:** All keys become invalid when the scope exits

**Covered Predicate**

An access to path Q requiring mode M_Q is covered by the current key state if:

Covered(Q, M_Q, Î“_keys) â‡” âˆƒ (P, M_P, S) âˆˆ Î“_keys : Prefix(P, Q) âˆ§ ModeSufficient(M_P, M_Q)

**Acquisition Rules**

**(K-Acquire-New)**
Î“ âŠ¢ P : `shared` T    M = RequiredMode(P)    Â¬ Covered(P, M, Î“_keys)    S = CurrentScope
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“'_keys = Î“_keys âˆª {(P, M, S)}

**(K-Acquire-Covered)**
Î“ âŠ¢ P : `shared` T    M = RequiredMode(P)    Covered(P, M, Î“_keys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“'_keys = Î“_keys

**Evaluation Order**

Subexpressions are evaluated left-to-right, depth-first. Key acquisition follows evaluation order.

**(K-Eval-Order)**
eval(e_1 âŠ• e_2) â†’ eval(e_1); eval(e_2); apply(âŠ•)

**Constraints**

**Diagnostics:** See Appendix A, codes `W-CON-0001`, `W-CON-0002`.


#### 17.2.2 Key Release

**Key Release.** Keys are released when their defining scope exits.

**Static Semantics**

**(K-Release-Scope)**
ScopeExit(S)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“'_keys = Î“_keys \ {(P, M, S') : S' = S}

**(K-Release-Order)**

Keys acquired within a scope are released per LIFO semantics (Â§3.5.2).

**Dynamic Semantics**

**Release Guarantee**

Keys are released when their scope exits, regardless of exit mechanism:

| Exit Mechanism    | Keys Released? |
| :---------------- | :------------- |
| Normal completion | Yes            |
| `return`          | Yes            |
| `break`           | Yes            |
| `continue`        | Yes            |
| Panic propagation | Yes            |
| Task cancellation | Yes            |

**Key and RAII Cleanup Interaction**

Keys are released at scope exit before any drop actions for bindings in that scope (see Â§3.5).

**Scope Definitions**

| Construct                      | Key Scope                  | Release Point          |
| :----------------------------- | :------------------------- | :--------------------- |
| Expression statement (`expr;`) | The statement              | Semicolon              |
| `let`/`var` declaration        | The declaration            | Semicolon              |
| Assignment statement           | The statement              | Semicolon              |
| `if` condition                 | The condition only         | Before entering branch |
| `match` scrutinee              | The scrutinee only         | Before entering arm    |
| `loop` condition               | Each iteration's condition | Before entering body   |
| `#path { ... }` block          | The entire block           | Closing brace          |
| Procedure body                 | Callee's body              | Procedure return       |
| `defer` body                   | The defer block            | Defer completion       |

**Constraints**

**Diagnostics:** See Appendix A, code `E-CON-0006`.


#### 17.2.3 `#` Block Syntax

**Key Block.** The `#` key block is the explicit key acquisition construct. It acquires a key to one or more paths at block entry and holds those keys until block exit.

**Syntax**

```ebnf
key_block       ::= "#" path_list mode_modifier* block
path_list       ::= key_path_expr ("," key_path_expr)*
mode_modifier   ::= "write" | "read" | release_modifier | "ordered" | "speculative"
release_modifier ::= "release" ("write" | "read")
```

**Mode Semantics**

| Block Form        | Key Mode | Mutation Permitted |
| :---------------- | :------- | :----------------- |
| `#path { }`       | Read     | No                 |
| `#path write { }` | Write    | Yes                |

**Static Semantics**

**(K-Block-Acquire)**
Î“ âŠ¢ P_1, â€¦, P_m : `shared` T_i    M = BlockMode(B)    (Q_1, â€¦, Q_m) = CanonicalSort(P_1, â€¦, P_m)    S = NewScope
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“'_keys = Î“_keys âˆª {(Q_i, M, S) : i âˆˆ 1..m}

**(K-Read-Block-No-Write)**
BlockMode(B) = Read    P âˆˆ KeyedPaths(B)    WriteOf(P) âˆˆ Body(B)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0070`)

**Dynamic Semantics**

**Execution Order**

1. Acquire keys (mode per block specification) to all listed paths in canonical order
2. Execute the block body
3. Release all keys in reverse acquisition order

**Concurrent Access**

| Block A        | Block B        | Same/Overlapping Path | Result                          |
| :------------- | :------------- | :-------------------- | :------------------------------ |
| `#p { }`       | `#p { }`       | Yes                   | Both proceed concurrently       |
| `#p { }`       | `#p write { }` | Yes                   | One blocks until other releases |
| `#p write { }` | `#p write { }` | Yes                   | One blocks until other releases |

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0001`â€“`E-CON-0004`, `E-CON-0030`â€“`E-CON-0032`, `E-CON-0070`, `W-CON-0003`.


#### 17.2.4 Key Coarsening

**Key Coarsening.** The `#` marker in a path expression sets the key granularity. The key is acquired at the marked position, covering all subsequent segments.

**Syntax**

**Inline Coarsening**

```ebnf
coarsened_path  ::= path_segment* "#" path_segment+
```

**Static Semantics**

**(K-Coarsen-Inline)**
P = p_1 â€¦ p_(k-1).#p_k â€¦ p_n    Î“ âŠ¢ P : `shared` T    M = RequiredMode(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AcquireKey(p_1 â€¦ p_k, M, Î“_keys)

**Type-Level Key Boundary**

A field declared with `#` establishes a permanent key boundary:

```ebnf
key_field_decl      ::= "#"? visibility? identifier ":" type
```

**(K-Type-Boundary)**
Î“ âŠ¢ r : R    R.fields âˆ‹ (#f : U)    P = r.f.q_1 â€¦ q_n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
KeyPath(P) = r.f

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0033`, `W-CON-0013`.


#### 17.2.5 Closure Capture of `shared` Bindings

**Shared Closure Capture.** Closures that capture `shared` bindings participate in key analysis. Because a closure MAY be invoked outside its defining scope, key path roots depend on whether the closure escapes.

**Classification**

A closure expression C is **local** if it appears only in:
1. Argument position of an immediate procedure or method call
2. The body of a `spawn` expression
3. The body of a `dispatch` expression
4. Operand of immediate invocation

A closure is **escaping** if it is:
1. Bound to a `let` or `var` binding
2. Returned from a procedure
3. Stored into a record or enum field

Let SharedCaptures(C) be the set of captured bindings with `shared` permission.

**Static Semantics**

**Local Closure Key Paths**

For a local closure, key analysis treats the closure body as if it executed in the defining scope. Any access `x.p` where `x âˆˆ SharedCaptures(C)` uses lexical rooting (Â§17.1.7):

KeyPath(C, x.p) = KeyPath(x.p)

Keys are acquired at invocation, not at definition.

**Escaping Closure Type Requirement**

An escaping closure that captures `shared` bindings MUST carry a shared dependency set in its closure type (Â§12.4.3):

**(K-Closure-Escape-Type)**
C is escaping    SharedCaptures(C) = {x_1, â€¦, x_n}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Type(C) = |vec_T| â†’ R [`shared`: {x_1 : `shared` T_1, â€¦, x_n : `shared` T_n}]

The dependency set MAY be inferred when the closure is assigned to a binding with an expected closure type; otherwise it MUST be written explicitly.

**Escaping Closure Key Paths**

For an escaping closure, key paths are rooted at runtime identities of captured references:

**(K-Closure-Escape-Keys)**
C : |vec_T| â†’ R [`shared`: {x : `shared` T}]    Access(x.p, M) âˆˆ C.body
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
KeyPath(C, x.p) = id(C.x).p    KeyMode = M

where C.x denotes the captured reference to x stored in the closure environment.

**Lifetime Constraint**

An escaping closure MUST NOT outlive any captured `shared` binding. Implementations MUST reject any flow where the closureâ€™s lifetime exceeds the lifetime of a captured `shared` root.

**Dynamic Semantics**

**Local Closure Invocation**

1. Determine accessed `shared` paths in the closure body.
2. Acquire required keys using lexical roots.
3. Execute the closure body.
4. Release keys at the end of the invocation.

**Escaping Closure Invocation**

1. For each dependency (x : shared T) in the closure type, let r = C.x.
2. Acquire required keys for paths rooted at id(r).
3. Execute the closure body.
4. Release keys at the end of the invocation.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0085`, `E-CON-0086`, `W-CON-0009`.


#### 17.2.6 `shared` Dynamic Class Objects (`shared $Class`)

**Shared Dynamic Class.** Dynamic class objects (`$Cl`, Â§13.5) erase the concrete type at runtime. When such an object is viewed with `shared` permission, key analysis does not inspect the concrete method bodies chosen by vtable dispatch. Therefore, `shared $Cl` is restricted to read-only dynamic interfaces.

**Static Semantics**

**Well-Formedness**

A dynamic class object type MAY be qualified with `shared` permission only if every vtable-eligible procedure in the class (including inherited ones) has a `const` receiver (`~`):

Let DynMethods(Cl) denote the set of procedures callable via vtable dispatch on `$Cl` (i.e., vtableâ€‘eligible and not marked `[[static_dispatch_only]]`).

**(K-Witness-Shared-WF)**
âˆ€ m âˆˆ DynMethods(Cl). m.receiver = `~`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `shared` $Cl wf

If any method requires `shared` (`~%`) or `unique` (`~!`) receiver permission, `shared $Cl` is illâ€‘formed. Such methods MAY still exist on `Cl` if they are excluded from dynamic dispatch via `[[static_dispatch_only]]`.

**Dynamic Calls Through `shared $Cl`**

For a call `e~>m(args)` where `e : shared $Cl`, the key mode is Read and the key path is the root of `e`:

KeyPath(e~>m(...)) = Root(e)    KeyMode = Read

**Constraints**

**Diagnostics:** See Appendix A, code `E-CON-0083`.


### 17.3 Conflict Detection


#### 17.3.1 Path Prefix and Disjointness

**Path Relations.** The prefix relation and disjointness relation on paths determine key coverage and static safety of concurrent accesses.

**Static Semantics**

**Path Prefix**

Path P is a prefix of path Q (written Prefix(P, Q)) if P is an initial subsequence of Q:

Prefix(p_1 â€¦ p_m, q_1 â€¦ q_n) â‡” m â‰¤ n âˆ§ âˆ€ i âˆˆ 1..m, p_i â‰¡_seg q_i

**Path Disjointness**

Two paths P and Q are disjoint (written Disjoint(P, Q)) if neither is a prefix of the other:

Disjoint(P, Q) â‡” Â¬ Prefix(P, Q) âˆ§ Â¬ Prefix(Q, P)

**Segment Equivalence**

p_i â‰¡_seg q_i â‡” name(p_i) = name(q_i) âˆ§ IndexEquiv(p_i, q_i)

**Index Expression Equivalence**

Two index expressions e_1 and e_2 are provably equivalent (e_1 â‰¡_idx e_2) if:

1. Both are the same integer literal
2. Both are references to the same `const` binding
3. Both are references to the same generic const parameter
4. Both are references to the same variable binding in scope
5. Both normalize to the same canonical form under constant folding

**Disjointness for Static Safety**

**(K-Disjoint-Safe)**
Disjoint(P, Q)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ConcurrentAccess(P, Q) is statically safe

**Prefix for Coverage**

**(K-Prefix-Coverage)**
Prefix(P, Q)    Held(P, M, Î“_keys)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Covers((P, M), Q)


#### 17.3.2 Static Conflict Analysis

**Static Conflict Analysis.** When multiple dynamic indices access the same array within a single statement, they MUST be provably disjoint; otherwise, the program is ill-formed.

**Static Semantics**

**Provable Disjointness for Indices**

Two index expressions are provably disjoint (ProvablyDisjoint(e_1, e_2)) if:

1. **Static Disjointness:** Both are statically resolvable with different values
2. **Control Flow Facts:** A Verification Fact establishes e_1 â‰  e_2
3. **Contract-Based:** A precondition asserts e_1 â‰  e_2
4. **Refinement Types:** An index has a refinement type constraining its relationship
5. **Algebraic Offset:** Expressions share a common base but differ by constant offsets
6. **Dispatch Iteration:** Within a `dispatch` block, accesses indexed by the iteration variable are automatically disjoint
7. **Disjoint Loop Ranges:** Iteration variables from loops with non-overlapping ranges

**(K-Dynamic-Index-Conflict)**
P_1 = a[e_1]    P_2 = a[e_2]    SameStatement(P_1, P_2)    (Dynamic(e_1) âˆ¨ Dynamic(e_2))    Â¬ ProvablyDisjoint(e_1, e_2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0010`)

**Constraints**

**Diagnostics:** See Appendix A, code `E-CON-0010`.


#### 17.3.3 Read-Then-Write Prohibition

**Read-Then-Write.** A pattern that occurs when a statement contains both a read and a write to the same `shared` path without a covering Write key.

**Static Semantics**

**Formal Definition**

ReadThenWrite(P, S) â‡” âˆƒ e_r, e_w âˆˆ Subexpressions(S) : ReadsPath(e_r, P) âˆ§ WritesPath(e_w, P)

**(K-Read-Write-Reject)**
Î“ âŠ¢ P : `shared` T    ReadThenWrite(P, S)    Â¬ âˆƒ (Q, Write, S') âˆˆ Î“_keys : Prefix(Q, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0060`)

**(K-RMW-Permitted)**
Î“ âŠ¢ P : `shared` T    ReadThenWrite(P, S)    âˆƒ (Q, Write, S') âˆˆ Î“_keys : Prefix(Q, P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Permitted

**Pattern Classification**

| Pattern                  | Covering Write Key?         | Action                |
| :----------------------- | :-------------------------- | :-------------------- |
| `p += e`                 | Yes (desugars to `#` block) | Permitted             |
| `#p write { p = p + e }` | Yes                         | Permitted             |
| `p = p + e`              | No                          | **Reject E-CON-0060** |
| `p.a = p.b + 1`          | No, but disjoint paths      | Permitted             |

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0060`, `W-CON-0004`, `W-CON-0006`.


### 17.4 Nested Release


#### 17.4.1 Nested Key Semantics

**Nested Keys.** Nested `#` blocks acquire keys independently. The outer block's keys remain held while the inner block executes.

**Syntax**

The `release` modifier enables mode transitions in nested blocks:

| Outer Mode | `release` Target | Operation                                      |
| :--------- | :--------------- | :--------------------------------------------- |
| Read       | `write`          | Escalation: Release Read â†’ Gap â†’ Acquire Write |
| Write      | `read`           | Downgrade: Release Write â†’ Gap â†’ Acquire Read  |

**Static Semantics**

**(K-Nested-Same-Path)**
Held(P, M_outer, Î“_keys)    #P M_inner { ... }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if M_inner = M_outer:
 Covered (no acquisition)
otherwise if M_inner â‰  M_outer âˆ§ `release` âˆˆ modifiers:
 Release-and-Reacquire per Â§17.4.1
otherwise:
 Emit(`E-CON-0012`)

**Dynamic Semantics**

**Release-and-Reacquire Sequence**

When entering `#path release <target> { body }`:

1. **Release:** Release the outer key held by the enclosing block
2. **Acquire:** Acquire the target mode key to `path` (blocking if contended)
3. **Execute:** Evaluate `body`
4. **Release:** Release the inner key
5. **Reacquire:** Acquire the outer mode key for the enclosing block's remaining scope

**(K-Release-Sequence)**
Held(P, M_outer, S_outer)    #P `release` M_inner { B }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Release(P, Î“_keys);
Acquire(P, M_inner, S_inner);
Eval(B);
Release(P, Î“_keys);
Acquire(P, M_outer, S_outer)

**Interleaving Windows**

Between steps 1 and 2 (entry), and between steps 4 and 5 (exit), other tasks MAY acquire keys to the same path.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0011`, `E-CON-0012`, `E-CON-0017`, `E-CON-0018`, `W-CON-0010`â€“`W-CON-0012`.

**Staleness Suppression (`[[stale_ok]]`)**

`[[stale_ok]]` suppresses warning `W-CON-0011` on a binding derived from `shared` data across a `release` or `yield release` boundary. See Â§5.13.5 for the full definition. The attribute does not affect dynamic semantics.


#### 17.4.2 Key Reentrancy

**Key Reentrancy.** If a caller holds a key covering the callee's access paths, the callee's accesses are covered without additional acquisition.

**Static Semantics**

**(K-Reentrant)**
Held(P, M, Î“_keys)    Prefix(P, Q)    CalleeAccesses(Q)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CalleeCovered(Q)

**(K-Procedure-Boundary)**

Passing a `shared` value as a procedure argument does not constitute key acquisition:

Î“ âŠ¢ f : (`shared` T) â†’ R    Î“ âŠ¢ v : `shared` T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
call(f, v) â†’ no key acquisition at call site

**Constraints**

**Diagnostics:** See Appendix A, code `W-CON-0005`.


### 17.5 Speculative Execution


#### 17.5.1 Speculative Block Semantics

**Speculative Block.** A key block that executes without acquiring an exclusive key, relying on optimistic concurrency control. The block body executes against a snapshot; at block exit, writes are atomically committed if and only if the snapshot values remain unchanged.

**Syntax**

```ebnf
speculative_block ::= "#" path_list "speculative" "write" block
```

**Static Semantics**

**(K-Spec-Write-Required)**
#P `speculative` M {B}    M â‰  `write`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0095`)

**(K-Spec-Pure-Body)**
#P `speculative write` {B}    Writes(B) âŠ„ CoveredPaths(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0091`)

**Permitted Operations**

- Read from keyed paths
- Write to keyed paths
- Pure computation (arithmetic, logic, local bindings)
- Procedure calls to `const` receiver methods on keyed data

**Prohibited Operations**

- Write to paths outside the keyed set
- Nested key blocks
- `wait` expressions
- Procedure calls with side effects
- `defer` statements

**(K-Spec-No-Nested-Key)**
#P `speculative write` {B}    #Q _ {â€¦} âˆˆ Subexpressions(B)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0090`)


#### 17.5.2 Snapshot-Execute-Commit Cycle

**Speculative Commit.** SpeculativeCommit(R, W) â‡” Atomic(â‹€_((p, v) âˆˆ R) p = v â‡’ â‹€_((q, w) âˆˆ W) q := w)

**Dynamic Semantics**

**Execution Model**

1. **Initialize**: Set retries := 0
2. **Snapshot**: Read all paths in the keyed set, recording (path, value) pairs in read set R
3. **Execute**: Evaluate body, collecting writes in write set W
4. **Commit**: Atomically verify â‹€_((p, v) âˆˆ R) (current(p) = v) and, if true, apply all writes in W
5. **On success**: Return the value of body
6. **On failure**: Increment retries; if below limit, goto step 2; otherwise fallback
7. **Fallback**: Acquire a blocking Write key, execute body, release key, return value

**Retry Limit**

`MAX_SPECULATIVE_RETRIES` = 16.

**Interaction with Blocking Keys**

| Concurrent Operation      | Speculative Block Behavior                  |
| :------------------------ | :------------------------------------------ |
| Another speculative block | Race; one commits, others retry             |
| Blocking Read key held    | Speculative MAY commit (compatible)         |
| Blocking Write key held   | Speculative commit fails, retry or fallback |

**Snapshot and Commit Requirements**

The snapshot step MUST be observationally equivalent to an atomic snapshot over the keyed set R. The commit step MUST be atomic with respect to all other key operations on overlapping paths and MUST satisfy `SpeculativeCommit(R, W)`.


#### 17.5.3 Speculation and Panics

**Dynamic Semantics**

If a panic occurs during execution (step 3):

1. The write set W is discarded (no writes are committed)
2. No key is held (nothing to release)
3. The panic propagates normally

**Memory Ordering**

- Snapshot reads: Acquire semantics
- Successful commit: Release semantics
- Failed commit: No ordering guarantees (writes discarded)

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0090`â€“`E-CON-0096`, `W-CON-0020`, `W-CON-0021`.


### 17.6 Runtime Realization (`[[dynamic]]`)


#### 17.6.1 Dynamic Key Verification

**Dynamic Verification.** Keys are a compile-time abstraction. Runtime synchronization is emitted only when the `[[dynamic]]` attribute is present and static verification fails.

**Static Semantics**

**Static Safety Conditions**

| Condition              | Description                                                 | Rule   |
| :--------------------- | :---------------------------------------------------------- | :----- |
| **No escape**          | `shared` value never escapes to another task                | K-SS-1 |
| **Disjoint paths**     | Concurrent accesses target provably disjoint paths          | K-SS-2 |
| **Sequential context** | No `parallel` block encloses the access                     | K-SS-3 |
| **Unique origin**      | Value is `unique` at origin, temporarily viewed as `shared` | K-SS-4 |
| **Dispatch-indexed**   | Access indexed by `dispatch` iteration variable             | K-SS-5 |
| **Speculative-only**   | All accesses within speculative blocks with fallback        | K-SS-6 |

**(K-Static-Safe)**
Access(P, M)    StaticallySafe(P)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NoRuntimeSync(P)

**(K-Static-Safe-Info)**
Access(P, M)    StaticallySafe(P)    InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`I-CON-0013`)

**(K-Static-Required)**
Â¬ StaticallySafe(P)    Â¬ InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0020`)

**(K-Dynamic-Permitted)**
Â¬ StaticallySafe(P)    InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
EmitRuntimeSync(P)

**(K-Dynamic-Permitted-Info)**
Â¬ StaticallySafe(P)    InDynamicContext
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`I-CON-0011`)

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0014`, `E-CON-0020`, `I-CON-0011`, `I-CON-0013`.


#### 17.6.2 Runtime Lock Acquisition

**Dynamic Semantics**

**Runtime Realization**

When runtime synchronization is required:

1. Mutual exclusion per key compatibility rules (Â§17.1.6)
2. Blocking when incompatible keys are held
3. Release on scope exit (including panic)
4. Progress guarantee (no indefinite starvation)

**Canonical Order**

A canonical order on paths defines deterministic acquisition order:

P <_canon Q â‡” âˆƒ k â‰¥ 1 : (âˆ€ i < k, p_i =_seg q_i) âˆ§ (p_k <_seg q_k âˆ¨ (k > m âˆ§ m < n))

**Segment Ordering**

1. **Identifiers:** Lexicographic by UTF-8 byte sequence
2. **Indexed segments:** By index value for statically resolvable indices
3. **Bare vs indexed:** Bare identifier precedes any indexed form

**Dynamic Ordering Guarantee**

Within `[[dynamic]]` scope, incomparable dynamic indices require runtime ordering satisfying:

1. **Totality**: For distinct paths P and Q, exactly one of DynOrder(P, Q) or DynOrder(Q, P) holds
2. **Antisymmetry**: DynOrder(P, Q) âˆ§ DynOrder(Q, P) â‡’ P = Q
3. **Transitivity**: DynOrder(P, Q) âˆ§ DynOrder(Q, R) â‡’ DynOrder(P, R)
4. **Cross-Task Consistency**: All tasks compute the same ordering
5. **Value-Determinism**: Ordering depends only on runtime values, not timing

**Observational Equivalence**

âˆ€ P : Observable(StaticSafe(P)) = Observable(RuntimeSync(P))

**Constraints**

**Diagnostics:** See Appendix A, code `W-CON-0021`.


### 17.7 Memory Ordering


#### 17.7.1 Default Sequential Consistency

**Sequential Consistency.** Key acquisition uses acquire semantics. Key release uses release semantics. Memory accesses default to sequentially consistent ordering.


#### 17.7.2 Relaxed Ordering Levels

**Syntax**


| Ordering  | Guarantee                             |
| :-------- | :------------------------------------ |
| `relaxed` | Atomicity onlyâ€”no ordering            |
| `acquire` | Subsequent reads see prior writes     |
| `release` | Prior writes visible to acquire reads |
| `acqrel` | Both acquire and release              |
| `seqcst` | Total global order (default)          |


#### 17.7.3 Memory Ordering Attributes

**Syntax**

```ebnf
memory_order_attribute ::= "[[" memory_order "]]"
memory_order           ::= "relaxed" | "acquire" | "release" | "acqrel" | "seqcst"
```

**Static Semantics**

Memory ordering annotations are permitted inside standard `#` blocks. The annotation affects only the data access ordering; it does not modify the key's acquire/release semantics at block entry and exit.

Memory ordering annotations MUST NOT appear inside speculative blocks (Â§17.5).


#### 17.7.4 Fence Operations

**Syntax**


---

## 18. Structured Parallelism

---

### 18.1 Parallel Blocks


#### 18.1.1 `parallel` Block Syntax

**Parallel Block.** A scope within which work executes concurrently across multiple workers. A parallel block P is defined as P = (D, A, B) where D is the execution domain expression, A is the set of block options, and B is the block body.

**Syntax**

```ebnf
parallel_block    ::= "parallel" domain_expr block_options? block

domain_expr       ::= expression

block_options     ::= "[" block_option ("," block_option)* "]"

block_option      ::= "cancel" ":" expression
                    | "name" ":" string_literal

block             ::= "{" statement* "}"
```

| Option   | Type          | Effect                                       |
| :------- | :------------ | :------------------------------------------- |
| `cancel` | `CancelToken` | Provides cooperative cancellation capability |
| `name`   | `string`      | Labels the block for debugging and profiling |

**Static Semantics**

**Typing Rule**

BlockOptOk(Name(_)) â‡” true
BlockOptOk(Cancel(e)) â‡” Î“ âŠ¢ e : TypePath(["CancelToken"])
BlockOptsOk(opts) â‡” âˆ€ opt âˆˆ opts. BlockOptOk(opt)

Î“ âŠ¢ D : `$ExecutionDomain`    BlockOptsOk(opts)    Î“_P = Î“[parallel_context â†¦ D]    Î“_P âŠ¢ B : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `parallel` D opts {B} : T    (T-Parallel)

**Well-Formedness**

A parallel block is well-formed if and only if:

1. The domain expression evaluates to a type implementing `ExecutionDomain`.
2. All `spawn` and `dispatch` expressions within the block body reference the enclosing parallel block.
3. No `spawn` or `dispatch` expression appears outside a parallel block.
4. All captured bindings satisfy the permission requirements of Â§18.3.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0101`â€“`E-CON-0103`.


#### 18.1.2 Fork-Join Semantics

**Structured Concurrency Invariant.** Let ð’² denote the set of work items spawned within a parallel block P: âˆ€ w âˆˆ ð’². lifetime(w) âŠ† lifetime(P). A **work item** is a unit of computation queued for execution by a worker (created by `spawn` and `dispatch` expressions). A **worker** is an execution context that executes work items. A **task** is the runtime representation of a work item during execution; tasks MAY suspend and resume, and are associated with key state per Â§17.1.

**Dynamic Semantics**

Evaluation of `parallel D [opts] { B }`:

1. Evaluate domain expression D to obtain d.
2. Initialize the worker pool according to d's configuration.
3. If the `cancel` option is present, associate its token with the block.
4. Evaluate statements in B sequentially; `spawn` and `dispatch` expressions enqueue work items.
5. Block at the closing brace until all enqueued work items complete.
6. If any work item panicked, propagate the first panic (by completion order) after all work settles.
7. Release workers back to the domain.
8. Return the collected results per Â§18.1.3.

Work items MAY execute concurrently. Define EnqueueIndex(w) as the sequential index assigned to each work item when its `spawn` or `dispatch` expression is evaluated in step 4. Define CompletionOrder as the total order on work items induced by the abstract execution in which each work item transitions to its completed state; if two transitions occur in the same abstract step, EnqueueIndex breaks the tie. The parallel block guarantees only that ALL work completes before the block exits.


#### 18.1.3 Parallel Block Completion

**Parallel Completion.** A parallel block is an expression that yields a value. The result type depends on the block's contents.

**Static Semantics**

**Result Type Determination**

| Block Contents                     | Result Type          |
| :--------------------------------- | :------------------- |
| No `spawn` or `dispatch`           | `()`                 |
| Single `spawn { e }` where e : T | T                   |
| Multiple spawns e_1, â€¦, e_n     | (T_1, â€¦, T_n)        |
| `dispatch` without `[reduce]`    | `()`                 |
| `dispatch ... [reduce: op] { e }`| T where e : T        |
| Mixed spawns and reducing dispatch | Tuple of all results |

**Typing Rules**

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `parallel` D {} : ()    (T-Parallel-Empty)

Î“ âŠ¢ `spawn` {e} : SpawnedâŸ¨TâŸ©
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `parallel` D {`spawn` {e}} : T    (T-Parallel-Single)

Î“ âŠ¢ `spawn` {e_i} : SpawnedâŸ¨T_iâŸ©    âˆ€ i âˆˆ 1..n
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `parallel` D {`spawn` {e_1}; â€¦; `spawn` {e_n}} : (T_1, â€¦, T_n)    (T-Parallel-Multi)


### 18.2 Execution Domains


#### 18.2.1 CPU Domain

**CPU Domain.** An execution domain that executes work items on operating system threads managed by the runtime.

**Static Semantics**

`ctx.cpu()` is a `Context` method (see Â§5.9.4) that returns a value of type `$ExecutionDomain`.

`CpuSet` and `Priority` are built-in types (see Â§5.9.4). `CpuSet` is an alias of `u64` interpreted as a bitset: CPU index i is included iff bit i of the mask is 1. `Priority` is an enum with variants `Low`, `Normal`, and `High`; higher discriminant values denote higher scheduling priority.


#### 18.2.2 GPU Domain

**GPU Domain.** An execution domain that executes work items on graphics processing unit compute shaders.

**Static Semantics**

`ctx.gpu()` is a `Context` method (see Â§5.9.4) that returns a value of type `$ExecutionDomain` representing a GPU execution domain. Within GPU-domain work items, capturing `shared` bindings, host pointers, or heapâ€‘provenanced values is illâ€‘formed; only GPUâ€‘accessible data MAY be captured.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0150`â€“`E-CON-0152`.


#### 18.2.3 Inline Domain

**Inline Domain.** An execution domain that executes work items sequentially on the current thread.

**Syntax**

```cursive
ctx.inline()
```

**Static Semantics**

`ctx.inline()` is a `Context` method (see Â§5.9.4) that returns a value of type `$ExecutionDomain` representing the inline domain.

**Dynamic Semantics**

- `spawn { e }` evaluates e immediately and blocks until complete.
- `dispatch i in range { e }` executes as a sequential loop.
- No actual parallelism occurs.
- All capture rules and permission requirements remain enforced.


#### 18.2.4 Domain Selection

**Execution Domain.** A capability that provides access to computational resources. Domains implement the `ExecutionDomain` class.

**Static Semantics**

ExecutionDomainMethods = [
  ClassMethodDecl(âŠ¥, `public`, "name", âŠ¥, ReceiverShorthand(`const`), [], TypeString(âŠ¥), âŠ¥, âŠ¥, âŠ¥, âŠ¥),
  ClassMethodDecl(âŠ¥, `public`, "max_concurrency", âŠ¥, ReceiverShorthand(`const`), [], TypePrim("usize"), âŠ¥, âŠ¥, âŠ¥, âŠ¥)
]
ExecutionDomainDecl = ClassDecl(âŠ¥, `public`, false, `ExecutionDomain`, âŠ¥, âŠ¥, [], ExecutionDomainMethods, âŠ¥, âŠ¥)
Î£.Classes["ExecutionDomain"] = ExecutionDomainDecl

This class is dispatchable, enabling heterogeneous domain handling.


### 18.3 Capture Semantics

See Â§10.1 for permission definitions. This section defines parallel-specific capture constraints.


#### 18.3.1 Capture Rules for `const`

**Const Capture.** Bindings with `const` permission MAY be captured by reference into `spawn` and `dispatch` bodies. Captured `const` references are guaranteed valid because structured concurrency (Â§18.1.2) ensures all work completes before the parallel block exits.

**Static Semantics**

`const` capture does not transfer responsibility. Multiple work items MAY capture the same `const` binding concurrently.


#### 18.3.2 Capture Rules for `shared`

**Shared Capture.** Bindings with `shared` permission MAY be captured by reference into `spawn` and `dispatch` bodies. Accesses are synchronized via the key system (Â§17).

**Static Semantics**

`shared` capture does not transfer responsibility. Concurrent access follows key acquisition semantics per Â§17.2.


#### 18.3.3 Capture Rules for `unique` (Move Required)

See Â§3.4 for move semantics and Â§10.1.2 for `unique` permission rules.

**Unique Capture.** Bindings with `unique` permission MUST NOT be implicitly captured. To use a `unique` binding in a work item, explicit `move` is required. At most one work item MAY receive ownership.

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0120`â€“`E-CON-0122`.


### 18.4 Tasks and Spawning


#### 18.4.1 `spawn` Expression Syntax

**Spawn Expression.** An expression that creates a work item for concurrent execution within the enclosing parallel block.

**Syntax**

```ebnf
spawn_expr      ::= "spawn" spawn_option_list? block

spawn_option_list  ::= "[" spawn_option ("," spawn_option)* "]"

spawn_option       ::= "name" ":" string_literal
                    | "affinity" ":" expression
                    | "priority" ":" expression
```

| Attribute  | Type       | Default            | Effect                         |
| :--------- | :--------- | :----------------- | :----------------------------- |
| `name`     | `string`   | Anonymous          | Labels for debugging/profiling |
| `affinity` | `CpuSet`   | Domain default     | CPU core affinity hint         |
| `priority` | `Priority` | `Priority::Normal` | Scheduling priority hint       |

**Static Semantics**

**Typing Rule**

SpawnOptOk(Name(_)) â‡” true
SpawnOptOk(Affinity(e)) â‡” Î“ âŠ¢ e : TypePath(["CpuSet"])
SpawnOptOk(Priority(e)) â‡” Î“ âŠ¢ e : TypePath(["Priority"])
SpawnOptsOk(opts) â‡” âˆ€ opt âˆˆ opts. SpawnOptOk(opt)

Î“[parallel_context] = D    SpawnOptsOk(opts)    Î“_capture âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `spawn` opts {e} : SpawnedâŸ¨TâŸ©    (T-Spawn)

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0130`, `E-CON-0131`.


#### 18.4.2 Task Creation

**Spawned Type.** A modal type representing a pending or completed spawn result:


**Dynamic Semantics**

Evaluation of `spawn [attrs] { e }`:

1. Capture free variables from enclosing scope per Â§18.3.
2. Package the captured environment with expression e into a work item.
3. If `affinity` is present, restrict worker selection to CPU indices whose bits are set in the `CpuSet` mask; if the set is empty, use the domain default.
4. If `priority` is present, assign the task the given `Priority`. When multiple tasks are ready, workers MUST select any task of maximal priority among those ready.
5. Enqueue the work item to the parallel block's worker pool.
6. Return `Spawned<T>@Pending` immediately (non-blocking).
7. A worker eventually dequeues and evaluates e.
8. Upon completion, the handle transitions to `@Ready` with the result value.


#### 18.4.3 Task Result Collection

**Result Collection.** Spawn results are collected through three mechanisms:

| Mechanism           | Description                                                                 |
| :------------------ | :-------------------------------------------------------------------------- |
| Implicit collection | When a parallel block contains only spawn expressions, results form a tuple |
| Explicit wait       | Use `wait handle` to retrieve a specific result                             |
| Ignored             | Results not collected are discarded; work still completes                   |

**Static Semantics**

**(T-Wait-Spawn)**
Î“; R; L âŠ¢ h : TypeApply(["Spawned"], [T])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `wait` h : T

**(T-Wait-Future)**
Î“; R; L âŠ¢ h : TypeApply(["Tracked"], [T, E])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `wait` h : TypeUnion([T, E])

**(Wait-Handle-Err)**
Î“; R; L âŠ¢ h : T_h    StripPerm(T_h) âˆ‰ {TypeApply(["Spawned"], [_]), TypeApply(["Tracked"], [_, _])}    c = Code(E-CON-0132)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ `wait` h â‡‘ c

**Dynamic Semantics**

`Spawned<T>` and `Tracked<T, E>` support the `wait` expression for result retrieval. Per Â§17, keys MUST NOT be held across `wait` suspension points.

Evaluation of `wait h`:

1. Evaluate h to v.
2. If v is `@Ready { value }`, return value.
3. If v is `@Pending`, block the current task until the handle transitions to `@Ready`, then return its value.
4. For `Spawned<T>`, the returned value has type T. For `Tracked<T, E>`, the returned value has type `T | E`.


### 18.5 Data Parallelism (`dispatch`)


#### 18.5.1 `dispatch` Expression Syntax

**Dispatch Expression.** An expression that expresses data-parallel iteration where each iteration MAY execute concurrently.

**Syntax**

```ebnf
dispatch_expr   ::= "dispatch" pattern "in" range_expression
                    key_clause?
                    dispatch_option_list?
                    block

key_clause      ::= "key" key_path_expr key_mode

key_mode        ::= "read" | "write"

dispatch_option_list  ::= "[" dispatch_option ("," dispatch_option)* "]"

dispatch_option       ::= "reduce" ":" reduce_op
                        | "ordered"
                        | "chunk" ":" expression

reduce_op       ::= "+" | "*" | "min" | "max" | "and" | "or" | identifier
```

| Attribute | Type         | Effect                                        |
| :-------- | :----------- | :-------------------------------------------- |
| `reduce`  | Reduction op | Combines iteration results using specified op |
| `ordered` | (flag)       | Forces sequential side-effect ordering        |
| `chunk`   | `usize`      | Groups iterations into chunks for granularity |

**Static Semantics**

**Typing Rule (Without Reduction)**

Î“ âŠ¢ range : RangeâŸ¨IâŸ©    Î“, i : I âŠ¢ B : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `dispatch` i `in range` {B} : ()    (T-Dispatch)

**Typing Rule (With Reduction)**

Î“ âŠ¢ range : RangeâŸ¨IâŸ©    Î“, i : I âŠ¢ B : T    Î“ âŠ¢ âŠ• : (T, T) â†’ T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ `dispatch` i `in range [reduce: âŠ•]` {B} : T    (T-Dispatch-Reduce)

**Constraints**

**Diagnostics:** See Appendix A, codes `E-CON-0140`â€“`E-CON-0143`, `W-CON-0140`.


#### 18.5.2 Iteration Space

**Dynamic Semantics**

Evaluation of `dispatch i in range [attrs] { B }`:

1. Evaluate `range` to determine iteration count n.
2. Analyze key patterns to partition iterations into conflict-free groups.
3. For each group, enqueue iterations as work items to the worker pool.
4. Workers execute iterations, acquiring required keys per Â§17.2 before the first access to each keyed path in the iteration.
5. If `[reduce: op]` is present, combine partial results using `op`.
6. Block until all iterations complete.
7. Return the reduced value (if reduction) or unit.

**Reduction Semantics**

Reduction operators MUST be associative:

âˆ€ a, b, c. (a âŠ• b) âŠ• c = a âŠ• (b âŠ• c)

For non-associative operations, the `[ordered]` attribute is required, which forces sequential execution.

Parallel reduction:

1. Partition iterations across workers.
2. Each worker reduces its partition to a partial result.
3. Combine partial results in a deterministic tree pattern.
4. Return the final result.


#### 18.5.3 Key-Based Parallelism Determination

See Â§17 for key system definition. This section defines dispatch-specific key usage.

**Static Semantics**

**Key Inference**

When no key clause is provided, the body is analyzed to infer key paths and modes:

| Body Access Pattern       | Inferred Key Path        | Inferred Mode   |
| :------------------------ | :----------------------- | :-------------- |
| `data[i] = ...`           | `data[i]`                | `write`         |
| `... = data[i]`           | `data[i]`                | `read`          |
| `data[i] = data[i] + ...` | `data[i]`                | `write`         |
| `result[i] = source[j]`   | `result[i]`, `source[j]` | `write`, `read` |

**Disjointness Guarantee**

`dispatch` v `in` r { â€¦ a[v] â€¦ }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âˆ€ v_1, v_2 âˆˆ r, v_1 â‰  v_2 â‡’ ProvablyDisjoint(a[v_1], a[v_2])    (K-Disjoint-Dispatch)

**Parallelism Determination**

| Key Pattern   | Keys Generated      | Parallelism Degree    |
| :------------ | :------------------ | :-------------------- |
| `data[i]`     | n distinct keys     | Full parallel         |
| `data[i / 2]` | n/2 distinct keys   | Pairs serialize       |
| `data[i % k]` | k distinct keys     | k-way parallel        |
| `data[f(i)]`  | Unknown at compile  | Runtime serialization |


### 18.6 Cancellation


#### 18.6.1 Cancellation Propagation

**Cancellation.** The cooperative mechanism by which in-progress parallel work MAY be requested to stop early. Work items MUST explicitly check for cancellation; the runtime does not forcibly terminate work.

**Syntax**

**CancelToken Type**

**Static Semantics**

`CancelToken` is a built-in modal type. See Â§5.4.2 for its declaration, method signatures, and the built-in procedure `CancelToken::new`.

**Dynamic Semantics**

When a cancel token is attached to a parallel block via the `cancel` option, the token is implicitly available within all `spawn` and `dispatch` bodies.

**Cancel Token State**

CancelStatus = {Active, Cancelled}
CancelState = âŸ¨parent, statusâŸ©    where parent âˆˆ â„• âˆª {âŠ¥} and status âˆˆ CancelStatus
CancelMap = â„• â‡€ CancelState

CancelStatusOf(Ï‡, id) = s â‡” Ï‡[id] = âŸ¨_, sâŸ©
CancelParentOf(Ï‡, id) = p â‡” Ï‡[id] = âŸ¨p, _âŸ©

Descendant(Ï‡, a, b) â‡” (a = b) âˆ¨ (âˆƒ p. CancelParentOf(Ï‡, b) = p âˆ§ Descendant(Ï‡, a, p))

FreshCancelId(Ï‡) = n â‡” n âˆ‰ dom(Ï‡) âˆ§ âˆ€ m < n. m âˆˆ dom(Ï‡)

CancelVal(n, S) = RecordValue(ModalStateRef(["CancelToken"], S), [âŸ¨`id`, IntVal("usize", n)âŸ©])
CancelId(v) = n â‡” v = RecordValue(ModalStateRef(["CancelToken"], S), fs) âˆ§ FieldValue(v, `id`) = IntVal("usize", n)

CancelJudg = {CancelNew() â‡“ v, CancelChild(v) â‡“ v', CancelIsCancelled(v) â‡“ b, CancelDoCancel(v) â‡“ ok, CancelWaitCancelled(v) â‡“ a}
CancelJudg_Ï‡ = {CancelNew(Ï‡) â‡“ (v, Ï‡'), CancelChild(v, Ï‡) â‡“ (v', Ï‡'), CancelIsCancelled(v, Ï‡) â‡“ b, CancelDoCancel(v, Ï‡) â‡“ Ï‡', CancelWaitCancelled(v, Ï‡) â‡“ a}

CancelNew() â‡“ v â‡” âˆƒ Ï‡, Ï‡'. CancelNew(Ï‡) â‡“ (v, Ï‡')
CancelChild(v) â‡“ v' â‡” âˆƒ Ï‡, Ï‡'. CancelChild(v, Ï‡) â‡“ (v', Ï‡')
CancelIsCancelled(v) â‡“ b â‡” âˆƒ Ï‡. CancelIsCancelled(v, Ï‡) â‡“ b
CancelDoCancel(v) â‡“ ok â‡” âˆƒ Ï‡, Ï‡'. CancelDoCancel(v, Ï‡) â‡“ Ï‡'
CancelWaitCancelled(v) â‡“ a â‡” âˆƒ Ï‡. CancelWaitCancelled(v, Ï‡) â‡“ a

**(Cancel-New)**
FreshCancelId(Ï‡) = n    Ï‡' = Ï‡[n â†¦ âŸ¨âŠ¥, ActiveâŸ©]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelNew(Ï‡) â‡“ (CancelVal(n, `@Active`), Ï‡')

**(Cancel-Child)**
CancelId(v) = p    FreshCancelId(Ï‡) = n    Ï‡' = Ï‡[n â†¦ âŸ¨p, ActiveâŸ©]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelChild(v, Ï‡) â‡“ (CancelVal(n, `@Active`), Ï‡')

**(Cancel-IsCancelled)**
CancelId(v) = n    CancelStatusOf(Ï‡, n) = s    b = (s = Cancelled)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelIsCancelled(v, Ï‡) â‡“ b

**(Cancel-DoCancel)**
CancelId(v) = n    Ï‡' = Ï‡[ k â†¦ âŸ¨CancelParentOf(Ï‡, k), CancelledâŸ© | k âˆˆ dom(Ï‡) âˆ§ Descendant(Ï‡, n, k) ]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelDoCancel(v, Ï‡) â‡“ Ï‡'



**(Cancel-WaitCancelled-Completed)**
CancelId(v) = n    CancelStatusOf(Ï‡, n) = Cancelled
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelWaitCancelled(v, Ï‡) â‡“ RecordValue(ModalStateRef(["Async"], `@Completed`), [âŸ¨`value`, UnitValâŸ©])

**(Cancel-WaitCancelled-Suspended)**
CancelId(v) = n    CancelStatusOf(Ï‡, n) = Active
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CancelWaitCancelled(v, Ï‡) â‡“ RecordValue(ModalStateRef(["Async"], `@Suspended`), [âŸ¨`output`, UnitValâŸ©])

The `Async@Suspended` value produced by `CancelWaitCancelled` is associated with the cancellation token `v`. A conforming implementation MUST ensure that once `v` (or any ancestor token) transitions to `Cancelled`, the corresponding suspended computation becomes eligible to complete and does not fail (its error type is `!`).

#### 18.6.2 Cancellation Cleanup

**Dynamic Semantics**

Cancellation is a request, not a guarantee:

| Scenario                       | Behavior                          |
| :----------------------------- | :-------------------------------- |
| Work checks and returns early  | Iteration completes immediately   |
| Work ignores cancellation      | Iteration runs to completion      |
| Work is queued but not started | MAY be dequeued without executing |
| Work is mid-execution          | Continues until next check point  |


### 18.7 Panic Handling in Parallel


#### 18.7.1 Single Panic Semantics

**Parallel Panic Handling.** When a work item panics within a parallel block, the panic is captured and propagated after all work settles.

**Dynamic Semantics**

1. The panicking work item captures panic information.
2. Other work items continue to completion (or cancellation if a token is attached).
3. After all work settles, the panic is re-raised at the block boundary.


#### 18.7.2 Multiple Panic Handling

**Dynamic Semantics**

1. Each panic is captured independently.
2. All work completes or is cancelled.
3. The first panic (by completion order) is raised.
4. Other panics are discarded; implementations MAY log them.


#### 18.7.3 Panic and Cancellation

**Dynamic Semantics**

If a cancel token is attached to the parallel block, the runtime MUST request cancellation on the first captured panic, exactly once. If no cancel token is attached, the runtime MUST NOT request cancellation solely due to a panic.


### 18.8 Determinism and Nesting


#### 18.8.1 Determinism Guarantees

**Determinism.** Given identical inputs and parallel structure, execution produces identical results.

**Static Semantics**

Dispatch is deterministic when:

1. Key patterns produce identical partitioning across runs.
2. Iterations with the same key execute in index order.
3. Reduction uses deterministic tree combination.

The `[ordered]` attribute forces sequential side-effect ordering. Iterations MAY execute in parallel, but side effects (I/O, shared mutation) are buffered and applied in index order.


#### 18.8.2 Nested Parallelism Rules

**Nested Parallelism.** Parallel blocks MAY be nested. Inner blocks execute within the context established by outer blocks.

**Dynamic Semantics**

**CPU Nesting**

Inner CPU parallel blocks share the worker pool with outer blocks. The `workers` parameter on inner blocks is a hint or limit, not additional workers.

**Heterogeneous Nesting**

CPU and GPU blocks MAY be nested.

**Constraints**

1. GPU parallel blocks MUST NOT be nested inside other GPU parallel blocks.
2. Inner CPU blocks share the outer block's worker pool.
3. Capture rules apply independently at each nesting level.


#### 18.8.3 Memory Allocation in Parallel

**Parallel Allocation.** Work items MAY allocate memory using captured allocator capabilities.

**Dynamic Semantics**

**Captured Allocator**

Work items MAY capture `ctx.heap` and invoke allocation methods.

**Region Allocation**

Work items executing within a `region` block MAY allocate from that region using the `^` operator.

## 19. Asynchronous Operations

### 19.1 Async Model

#### 19.1.1 Built-in Modal Type `Async` (Cursive0)

**Async Modal.** `Async<Out, In, Result, E>` is the built-in modal type defined in Â§5.4.5.

**Type Parameters**

Out: type of values produced at suspension.
In: type of values received on resume.
Result: type of final completion value.
E: type of failure value.

**States**

`@Suspended` carries `output: Out`.
`@Completed` carries `value: Result`.
`@Failed` carries `error: E`.

When `E = !`, `@Failed` is uninhabited; storage omission rules are in Â§5.4.5.

Async parameter defaults and subtyping are defined by `AsyncSig` (Â§5.2.9) and **(Sub-Async)** (Â§5.2.6).

#### 19.1.2 Type Aliases (`Future`, `Sequence`, `Stream`, `Pipe`, `Exchange`)

**Syntax**

```cursive
type Sequence<T> = Async<T, (), (), !>
type Future<T; E = !> = Async<(), (), T, E>
type Pipe<In; Out> = Async<Out, In, (), !>
type Exchange<T> = Async<T, T, T, !>
type Stream<T; E> = Async<T, (), (), E>
```

**Static Semantics**

`Sequence`, `Future`, `Stream`, `Pipe`, and `Exchange` are built-in type aliases (Â§5.4.5) and expand by alias normalization (Â§5.2.7).

#### 19.1.3 Async State Machine

**Async Procedure.** A procedure is async iff `AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©`, where `R` is its declared return type.

**Static Semantics**

SuspendExpr(e) â‡” e = YieldExpr(_, _) âˆ¨ e = YieldFromExpr(_, _)

A binding is **live across suspension** iff there exists a control-flow path from a suspension point to a use of the binding on which the binding is not redefined. The async frame stores every binding that is live across suspension, plus the resumption point and any implementation fields required by the runtime.

If the captured state size exceeds the large-capture threshold, the warning rule in Â§5.2.17 applies (W-CON-0201).

**Dynamic Semantics**

Evaluation of a call to an async procedure:

1. Evaluate arguments left-to-right (Â§6.4).
2. Allocate a fresh async frame, capturing required arguments and initializing the resumption point to the procedure entry.
3. Execute the body until:
   - `yield` or `yield from` is reached: produce `Async@Suspended { output = v }`.
   - `return` is executed: produce `Async@Completed { value = v }`.
   - error propagation via `?` yields an error value: produce `Async@Failed { error = e }`.
4. The call expression evaluates to the produced modal state.

Evaluation of `a~>resume(input)` for `a : Async@Suspended`:

1. Resume execution at the stored resumption point with the yielded input value bound to the suspended `yield` expression.
2. Run until the next suspension or completion, returning the corresponding `Async` state.

### 19.2 Suspension

#### 19.2.1 Suspension Points

**Suspension Point.** A suspension point is any evaluation point of `yield` or `yield from`. At a suspension point, the async computation transitions to `@Suspended` and returns control to its caller.

#### 19.2.2 `yield` Expression

**Syntax**

```ebnf
yield_expr ::= "yield" "release"? expression
```

**Static Semantics**

**(T-Yield)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    Î“; R; L âŠ¢ e : T    Î“ âŠ¢ T <: Out
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldExpr(release_opt, e) : In

**(Yield-NotAsync-Err)**
AsyncSig(R) = âŠ¥    c = Code(E-CON-0210)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldExpr(release_opt, e) â‡‘ c

**(Yield-Out-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, EâŸ©    Î“; R; L âŠ¢ e : T    Â¬(Î“ âŠ¢ T <: Out)    c = Code(E-CON-0211)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldExpr(release_opt, e) â‡‘ c

Key restrictions for `yield` are defined in Â§19.4.2.

**Dynamic Semantics**

Evaluation of `yield e`:

1. Evaluate e to v.
2. If `release_opt = Release`, release all held keys and record the key set (Â§19.4.2).
3. Transition to `Async@Suspended { output = v }`.
4. When resumed with input i:
   - if `release_opt = Release`, reacquire recorded keys in canonical order (Â§17.4.1);
   - bind i as the value of the `yield` expression and continue.

#### 19.2.3 `yield from` Expression

**Syntax**

```ebnf
yield_from_expr ::= "yield" "release"? "from" expression
```

**Static Semantics**

**(T-Yield-From)**
AsyncSig(R) = âŸ¨Out, In, Result, E_1âŸ©    Î“; R; L âŠ¢ e : T_e    AsyncSig(T_e) = âŸ¨Out_e, In_e, Result_e, E_2âŸ©    Î“ âŠ¢ Out_e â‰¡ Out    Î“ âŠ¢ In_e â‰¡ In    Î“ âŠ¢ E_2 <: E_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldFromExpr(release_opt, e) : Result_e

**(YieldFrom-NotAsync-Err)**
AsyncSig(R) = âŠ¥    c = Code(E-CON-0220)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldFromExpr(release_opt, e) â‡‘ c

**(YieldFrom-Out-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, E_1âŸ©    Î“; R; L âŠ¢ e : T_e    (AsyncSig(T_e) = âŠ¥ âˆ¨ (AsyncSig(T_e) = âŸ¨Out_e, In_e, Result_e, E_2âŸ© âˆ§ Â¬(Î“ âŠ¢ Out_e â‰¡ Out)))    c = Code(E-CON-0221)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldFromExpr(release_opt, e) â‡‘ c

**(YieldFrom-In-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, E_1âŸ©    Î“; R; L âŠ¢ e : T_e    AsyncSig(T_e) = âŸ¨Out_e, In_e, Result_e, E_2âŸ©    Î“ âŠ¢ Out_e â‰¡ Out    Â¬(Î“ âŠ¢ In_e â‰¡ In)    c = Code(E-CON-0222)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldFromExpr(release_opt, e) â‡‘ c

**(YieldFrom-ErrType-Err)**
AsyncSig(R) = âŸ¨Out, In, Result, E_1âŸ©    Î“; R; L âŠ¢ e : T_e    AsyncSig(T_e) = âŸ¨Out_e, In_e, Result_e, E_2âŸ©    Î“ âŠ¢ Out_e â‰¡ Out    Î“ âŠ¢ In_e â‰¡ In    Â¬(Î“ âŠ¢ E_2 <: E_1)    c = Code(E-CON-0225)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ YieldFromExpr(release_opt, e) â‡‘ c

Key restrictions for `yield from` are defined in Â§19.4.2.

**Dynamic Semantics**

Evaluation of `yield from source`:

1. Evaluate source to s.
2. Loop:
   - If s is `@Suspended { output }`: evaluate `yield` (or `yield release`) with output; on resumption with input i, set s := s~>resume(i).
   - If s is `@Completed { value }`: evaluate to value and exit.
   - If s is `@Failed { error }`: propagate error and exit.

### 19.3 Consumption and Composition

#### 19.3.1 Iteration (`loop...in`)

**Async Loop.** `loop pat in e { body }` consumes an `Async<Out, (), Result, E>` and iterates over yielded values.

**Static Semantics**

The typing rule is **(T-Loop-Iter-Async)** and error **(Loop-Async-Err)** in Â§5.2.11. Iteration is permitted only in async procedures and requires `In = ()`.

**Dynamic Semantics**

1. Evaluate e to a.
2. Repeat:
   - If a is `@Suspended { output }`: bind output to pat, execute body, then set a := a~>resume(()).
   - If a is `@Completed { value }`: terminate the loop.
   - If a is `@Failed { error }`: propagate error from the enclosing async procedure.

#### 19.3.2 Manual Stepping

**Manual Stepping.** An async value MAY be advanced by pattern matching on its modal state and invoking `~>resume` on the `@Suspended` state. This is required for async values with non-unit `In` types.

#### 19.3.3 Synchronous Execution (`sync`)

**Syntax**

```ebnf
sync_expr ::= "sync" expression
```

**Static Semantics**

YieldInExpr(e) â‡” âˆƒ e' âˆˆ SubExprsList([e]). e' = YieldExpr(_, _)
YieldFromInExpr(e) â‡” âˆƒ e' âˆˆ SubExprsList([e]). e' = YieldFromExpr(_, _)

**(Sync-Yield-Err)**
YieldInExpr(e)    c = Code(E-CON-0212)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) â‡‘ c

**(Sync-YieldFrom-Err)**
YieldFromInExpr(e)    c = Code(E-CON-0223)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) â‡‘ c

**(T-Sync)**
AsyncSig(R) = âŠ¥    Î“; R; L âŠ¢ e : T_e    AsyncSig(T_e) = âŸ¨Out, In, Result, EâŸ©    Out = TypePrim("()")    In = TypePrim("()")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) : TypeUnion([Result, E])

**(Sync-Async-Context-Err)**
AsyncSig(R) â‰  âŠ¥    c = Code(E-CON-0250)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) â‡‘ c

**(Sync-Out-Err)**
AsyncSig(R) = âŠ¥    Î“; R; L âŠ¢ e : T_e    (AsyncSig(T_e) = âŠ¥ âˆ¨ (AsyncSig(T_e) = âŸ¨Out, In, Result, EâŸ© âˆ§ Out â‰  TypePrim("()")))    c = Code(E-CON-0251)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) â‡‘ c

**(Sync-In-Err)**
AsyncSig(R) = âŠ¥    Î“; R; L âŠ¢ e : T_e    AsyncSig(T_e) = âŸ¨Out, In, Result, EâŸ©    Out = TypePrim("()")    In â‰  TypePrim("()")    c = Code(E-CON-0252)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ SyncExpr(e) â‡‘ c

**Dynamic Semantics**

Evaluation of `sync e`:

1. Evaluate e to a.
2. Loop:
   - If a is `@Suspended { output = () }`: set a := a~>resume(()).
   - If a is `@Completed { value }`: return value.
   - If a is `@Failed { error }`: propagate error.

#### 19.3.4 `race` Expression

**Syntax**

```ebnf
race_expr    ::= "race" "{" race_arm ("," race_arm)* "}"
race_arm     ::= expression "->" "|" pattern "|" race_handler
race_handler ::= expression | "yield" expression
```

**Static Semantics**

RaceMode(arms) =
  { `return`    if âˆ€ arm âˆˆ arms. arm.handler = RaceReturn(_)
    `yield`     if âˆ€ arm âˆˆ arms. arm.handler = RaceYield(_)
    âŠ¥           otherwise }

**(T-Race)**
n = |arms|    n â‰¥ 2    RaceMode(arms) = `return`    âˆ€ i, arm_i = âŸ¨e_i, pat_i, RaceReturn(r_i)âŸ©    Î“; R; L âŠ¢ e_i : T_i    AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    Out_i = TypePrim("()")    In_i = TypePrim("()")    Î“ âŠ¢ pat_i â‡ Result_i âŠ£ B_i    Distinct(PatNames(pat_i))    Î“_i = IntroAll(Î“, B_i)    Î“_i; R; L âŠ¢ r_i : T_i^r    AllEq_Î“([T_1^r, â€¦, T_n^r])    T_r = T_1^r
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) : TypeUnion([T_r, E_1, â€¦, E_n])

**(T-Race-Stream)**
n = |arms|    n â‰¥ 2    RaceMode(arms) = `yield`    âˆ€ i, arm_i = âŸ¨e_i, pat_i, RaceYield(r_i)âŸ©    Î“; R; L âŠ¢ e_i : T_i    AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    In_i = TypePrim("()")    Î“ âŠ¢ pat_i â‡ Out_i âŠ£ B_i    Distinct(PatNames(pat_i))    Î“_i = IntroAll(Î“, B_i)    Î“_i; R; L âŠ¢ r_i : U_i    AllEq_Î“([U_1, â€¦, U_n])    U = U_1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) : TypeApply(["Stream"], [U, TypeUnion([E_1, â€¦, E_n])])

**(Race-Arity-Err)**
n = |arms|    n < 2    c = Code(E-CON-0260)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Handler-Mix-Err)**
RaceMode(arms) = âŠ¥    c = Code(E-CON-0263)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Operand-Out-Err)**
RaceMode(arms) = `return`    âˆƒ i. Î“; R; L âŠ¢ e_i : T_i âˆ§ (AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ© âˆ§ Out_i â‰  TypePrim("()"))    c = Code(E-CON-0262)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Operand-Err)**
RaceMode(arms) = `return`    âˆƒ i. Î“; R; L âŠ¢ e_i : T_i âˆ§ (AsyncSig(T_i) = âŠ¥ âˆ¨ (AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ© âˆ§ Out_i = TypePrim("()") âˆ§ In_i â‰  TypePrim("()")))    c = Code(E-CON-0261)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Stream-Operand-Err)**
RaceMode(arms) = `yield`    âˆƒ i. Î“; R; L âŠ¢ e_i : T_i âˆ§ (AsyncSig(T_i) = âŠ¥ âˆ¨ (AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ© âˆ§ In_i â‰  TypePrim("()")))    c = Code(E-CON-0261)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Handler-Type-Err)**
n = |arms|    n â‰¥ 2    RaceMode(arms) = `return`    âˆ€ i, arm_i = âŸ¨e_i, pat_i, RaceReturn(r_i)âŸ©    Î“; R; L âŠ¢ e_i : T_i    AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    Out_i = TypePrim("()")    In_i = TypePrim("()")    Î“ âŠ¢ pat_i â‡ Result_i âŠ£ B_i    Distinct(PatNames(pat_i))    Î“_i = IntroAll(Î“, B_i)    Î“_i; R; L âŠ¢ r_i : T_i^r    Â¬ AllEq_Î“([T_1^r, â€¦, T_n^r])    c = Code(E-CON-0261)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**(Race-Stream-Handler-Type-Err)**
n = |arms|    n â‰¥ 2    RaceMode(arms) = `yield`    âˆ€ i, arm_i = âŸ¨e_i, pat_i, RaceYield(r_i)âŸ©    Î“; R; L âŠ¢ e_i : T_i    AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    In_i = TypePrim("()")    Î“ âŠ¢ pat_i â‡ Out_i âŠ£ B_i    Distinct(PatNames(pat_i))    Î“_i = IntroAll(Î“, B_i)    Î“_i; R; L âŠ¢ r_i : U_i    Â¬ AllEq_Î“([U_1, â€¦, U_n])    c = Code(E-CON-0261)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ RaceExpr(arms) â‡‘ c

**Dynamic Semantics**

**First-Completion Evaluation**

1. Initiate all async expressions concurrently.
2. When any operation reaches `@Completed` or `@Failed`:
   - Execute the corresponding handler.
   - Cancel all other operations.
   - Return the handler result.

**Streaming Evaluation**

1. Initiate all async expressions concurrently.
2. When any arm yields: execute handler, emit its value as the next stream output, resume that arm.
3. When an arm completes: remove it from the race.
4. When all arms complete: the stream completes.
5. If any arm fails: propagate the error and cancel remaining arms.

#### 19.3.5 `all` Expression

**Syntax**

```ebnf
all_expr ::= "all" "{" expression ("," expression)* "}"
```

**Static Semantics**

**(T-All)**
n = |exprs|    âˆ€ i, Î“; R; L âŠ¢ e_i : T_i    AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ©    Out_i = TypePrim("()")    In_i = TypePrim("()")    T_tuple = TypeTuple([Result_1, â€¦, Result_n])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AllExpr([e_1, â€¦, e_n]) : TypeUnion([T_tuple, E_1, â€¦, E_n])

**(All-Out-Err)**
âˆƒ i. Î“; R; L âŠ¢ e_i : T_i âˆ§ (AsyncSig(T_i) = âŠ¥ âˆ¨ (AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ© âˆ§ Out_i â‰  TypePrim("()")))    c = Code(E-CON-0270)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AllExpr(exprs) â‡‘ c

**(All-In-Err)**
âˆƒ i. Î“; R; L âŠ¢ e_i : T_i âˆ§ (AsyncSig(T_i) = âŸ¨Out_i, In_i, Result_i, E_iâŸ© âˆ§ Out_i = TypePrim("()") âˆ§ In_i â‰  TypePrim("()"))    c = Code(E-CON-0271)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ AllExpr(exprs) â‡‘ c

**Dynamic Semantics**

1. Initiate all async expressions concurrently.
2. Wait for all operations to complete.
3. If all succeed: return tuple of results in declaration order.
4. If any fails: cancel remaining operations and propagate the first error.

#### 19.3.6 `until` Expression

**Static Semantics**

`until` is a method on `shared` values:

until : shared T Ã— procedure(const T) -> bool Ã— procedure(unique T) -> R -> Future<R>

**Dynamic Semantics**

Evaluation of `shared_value~>until(pred, action)`:

1. If pred(shared_value) is true:
   - Acquire a Write key for the target path.
   - Execute action(shared_value).
   - Complete the future with the result.
2. Otherwise:
   - Register a waiter record.
   - Transition to `@Suspended { output = () }`.

On key release, registered waiters re-evaluate predicates. Waiters whose predicates return true are scheduled for execution.

#### 19.3.7 Transformations and Combinators

**Static Semantics**

map : Async<Out, In, Result, E> Ã— procedure(Out) -> U -> Async<U, In, Result, E>
filter : Async<T, (), (), E> Ã— procedure(const T) -> bool -> Async<T, (), (), E>
take : Async<T, (), (), E> Ã— usize -> Async<T, (), (), E>
fold : Async<T, (), (), E> Ã— A Ã— procedure(A, T) -> A -> Future<A, E>
chain : Future<T, E> Ã— procedure(T) -> Future<U, E> -> Future<U, E>

**(T-Async-Map)**
Î“; R; L âŠ¢ a : TypeApply(["Async"], [Out, In, Result, E])    Î“; R; L âŠ¢ f : (Out) -> U
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ a~>map(f) : TypeApply(["Async"], [U, In, Result, E])

**(T-Async-Filter)**
Î“; R; L âŠ¢ a : TypeApply(["Async"], [T, TypePrim("()"), TypePrim("()"), E])    Î“; R; L âŠ¢ p : (TypePerm(`const`, T)) -> TypePrim("bool")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ a~>filter(p) : TypeApply(["Async"], [T, TypePrim("()"), TypePrim("()"), E])

**(T-Async-Take)**
Î“; R; L âŠ¢ a : TypeApply(["Async"], [T, TypePrim("()"), TypePrim("()"), E])    Î“; R; L âŠ¢ n : TypePrim("usize")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ a~>take(n) : TypeApply(["Async"], [T, TypePrim("()"), TypePrim("()"), E])

**(T-Async-Fold)**
Î“; R; L âŠ¢ a : TypeApply(["Async"], [T, TypePrim("()"), TypePrim("()"), E])    Î“; R; L âŠ¢ init : A    Î“; R; L âŠ¢ f : (A, T) -> A
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ a~>fold(init, f) : TypeApply(["Future"], [A, E])

**(T-Async-Chain)**
Î“; R; L âŠ¢ a : TypeApply(["Future"], [T, E])    Î“; R; L âŠ¢ f : (T) -> TypeApply(["Future"], [U, E])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“; R; L âŠ¢ a~>chain(f) : TypeApply(["Future"], [U, E])

**Dynamic Semantics**

Combinators return new async values that apply transformations when resumed:

1. map(f): when the source yields v, yield f(v).
2. filter(p): when the source yields v, yield v only if p(v) is true.
3. take(n): yield the first n values, then complete.
4. fold(init, f): consume all values, accumulate, complete with the final accumulator.
5. chain(f): when the source completes with v, delegate to f(v).

### 19.4 Async-Key Integration

#### 19.4.1 Key State at Suspension

**Suspension Key State.** At suspension, the task releases access rights. Other tasks MAY acquire keys to the same paths during the suspension period. Reacquisition behavior for `yield release` is defined in Â§19.2.2.

#### 19.4.2 Key Prohibition in Yield

**Yield Key Prohibition.** `yield` and `yield from` MUST NOT occur while keys are held unless the `release` modifier is present.

**(K-Yield-No-Keys)**
YieldExpr(âŠ¥, _) at program point p    Î“_keys(p) â‰  âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0213`)

**(K-YieldFrom-No-Keys)**
YieldFromExpr(âŠ¥, _) at program point p    Î“_keys(p) â‰  âˆ…
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Emit(`E-CON-0224`)

**Yield Release Mechanism**

If `release` is used, all held keys are released before suspension and reacquired on resume in canonical order (Â§17.4.1).

**Staleness**

Bindings derived from shared data before a `yield release` are potentially stale after resumption. The warning `W-CON-0011` applies unless suppressed by `[[stale_ok]]` (Â§5.13.5).

#### 19.4.3 Async Capability Requirements

Async operations require capabilities corresponding to their effects:

| Category      | Capability Required |
| :------------ | :------------------ |
| Pure sequence | None                |
| I/O operation | Capability providing the invoked I/O method |
| Timing        | `System`            |
| Async runtime | `Reactor`           |

The `$Reactor` capability and its interface are defined in Â§5.9.2.

#### 19.4.4 Async Error Handling

**Static Semantics**

Error propagation in async procedures is defined by **(T-Async-Try)** and **(Async-Try-Infallible-Err)** in Â§5.2.12.

**Dynamic Semantics**

When an async computation fails:

1. The error value is captured.
2. `defer` blocks execute in reverse order.
3. `Drop` implementations run for live bindings.
4. The computation transitions to `@Failed { error }`.

**Constraints**

Async capture and escape constraints are defined in Â§5.2.17 (E-CON-0280, E-CON-0281).

---

*[REF: Procedure declarations, methods, and overloading are defined in Cursive0.md. This appendix specifies contracts, invariants, verification logic, behavioral subtyping, and foreign contract clauses.]*

## 21. Foreign Function Interface

### 21.1 FfiSafe

#### 21.1.1 FfiSafe Definition

**FfiSafe Predicate.** `FfiSafeType(T)` holds when the runtime representation of `T` is compatible with the platform C ABI.

**Static Semantics**

FfiSafeJudg = {FfiSafeType}

FfiPrimTypes = {`i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`, `isize`, `usize`, `f16`, `f32`, `f64`, `char`, `()`}

HasLayoutC(D) â‡” `layout(C)` appears in D.attrs_opt
PayloadTypes(v) = []    if v.payload_opt = âŠ¥
PayloadTypes(v) = ts    if v.payload_opt = TuplePayload(ts)
PayloadTypes(v) = [T_f | âŸ¨_, f, T_f, _, _, _âŸ© âˆˆ fields]    if v.payload_opt = RecordPayload(fields)

TypeParamSet(params) = Set(TypeParamNames(params))

AliasParams(p) = gen_params_opt â‡” Î£.Types[p] = TypeAliasDecl(_, _, _, gen_params_opt, _, _, _, _)
AliasWhere(p) = where_clause_opt â‡” Î£.Types[p] = TypeAliasDecl(_, _, _, _, where_clause_opt, _, _, _)

TypeSubst(Î¸, TypePath([x])) = Î¸(x)    if x âˆˆ dom(Î¸)
TypeSubst(Î¸, TypePath(p)) = TypePath(p)    if p â‰  [x] âˆ¨ x âˆ‰ dom(Î¸)
TypeSubst(Î¸, TypeApply(p, args)) = TypeApply(p, [TypeSubst(Î¸, a) | a âˆˆ args])
TypeSubst(Î¸, TypePerm(p, T)) = TypePerm(p, TypeSubst(Î¸, T))
TypeSubst(Î¸, TypeTuple(ts)) = TypeTuple([TypeSubst(Î¸, t) | t âˆˆ ts])
TypeSubst(Î¸, TypeArray(T, e)) = TypeArray(TypeSubst(Î¸, T), e)
TypeSubst(Î¸, TypeSlice(T)) = TypeSlice(TypeSubst(Î¸, T))
TypeSubst(Î¸, TypeUnion(ts)) = TypeUnion([TypeSubst(Î¸, t) | t âˆˆ ts])
TypeSubst(Î¸, TypeFunc(params, R)) = TypeFunc([âŸ¨m, TypeSubst(Î¸, T)âŸ© | âŸ¨m, TâŸ© âˆˆ params], TypeSubst(Î¸, R))
TypeSubst(Î¸, TypePtr(T, s)) = TypePtr(TypeSubst(Î¸, T), s)
TypeSubst(Î¸, TypeRawPtr(q, T)) = TypeRawPtr(q, TypeSubst(Î¸, T))
TypeSubst(Î¸, TypeString(s)) = TypeString(s)
TypeSubst(Î¸, TypeBytes(s)) = TypeBytes(s)
ModalRefSubst(Î¸, TypePath(p)) = TypePath(p)
ModalRefSubst(Î¸, TypeApply(p, args)) = TypeApply(p, [TypeSubst(Î¸, a) | a âˆˆ args])
TypeSubst(Î¸, TypeModalState(modal_ref, S)) = TypeModalState(ModalRefSubst(Î¸, modal_ref), S)
TypeSubst(Î¸, TypeDynamic(p)) = TypeDynamic(p)
TypeSubst(Î¸, TypeOpaque(p)) = TypeOpaque(p)
TypeSubst(Î¸, TypePrim(n)) = TypePrim(n)
TypeSubst(Î¸, TypeRange) = TypeRange

TypeParamsIn(TypePath([x]), params) = {x}    if x âˆˆ TypeParamSet(params)
TypeParamsIn(TypePath(p), params) = âˆ…        if p â‰  [x] âˆ¨ x âˆ‰ TypeParamSet(params)
TypeParamsIn(TypeApply(_, args), params) = â‹ƒ_{a âˆˆ args} TypeParamsIn(a, params)
TypeParamsIn(TypePerm(_, T), params) = TypeParamsIn(T, params)
TypeParamsIn(TypeTuple(ts), params) = â‹ƒ_{t âˆˆ ts} TypeParamsIn(t, params)
TypeParamsIn(TypeArray(T, _), params) = TypeParamsIn(T, params)
TypeParamsIn(TypeSlice(T), params) = TypeParamsIn(T, params)
TypeParamsIn(TypeUnion(ts), params) = â‹ƒ_{t âˆˆ ts} TypeParamsIn(t, params)
TypeParamsIn(TypeFunc(params_t, R), params) = â‹ƒ_{âŸ¨_, TâŸ© âˆˆ params_t} TypeParamsIn(T, params) âˆª TypeParamsIn(R, params)
TypeParamsIn(TypePtr(T, _), params) = TypeParamsIn(T, params)
TypeParamsIn(TypeRawPtr(_, T), params) = TypeParamsIn(T, params)
TypeParamsInModalRef(TypePath(_), params) = âˆ…
TypeParamsInModalRef(TypeApply(_, args), params) = â‹ƒ_{a âˆˆ args} TypeParamsIn(a, params)
TypeParamsIn(TypeModalState(modal_ref, _), params) = TypeParamsInModalRef(modal_ref, params)
TypeParamsIn(TypeString(_), params) = âˆ…
TypeParamsIn(TypeBytes(_), params) = âˆ…
TypeParamsIn(TypeModalState(_, _), params) = âˆ…
TypeParamsIn(TypeDynamic(_), params) = âˆ…
TypeParamsIn(TypeOpaque(_), params) = âˆ…
TypeParamsIn(TypePrim(_), params) = âˆ…
TypeParamsIn(TypeRange, params) = âˆ…

TypeParamsInFields(fields, params) = â‹ƒ_{f âˆˆ fields} TypeParamsIn(f.type, params)
TypeParamsInPayloads(vars, params) = â‹ƒ_{v âˆˆ vars} â‹ƒ_{T_f âˆˆ PayloadTypes(v)} TypeParamsIn(T_f, params)

HasFfiSafePred(W, x) â‡” âˆƒ wp âˆˆ WherePreds(W). wp = PredWherePred(`FfiSafe`, TypePath([x]))
FfiSafeWhereOk(params, W, Xs) â‡” âˆ€ x âˆˆ Xs. HasFfiSafePred(W, x)

ProhibitedFfiType(T) â‡”
 T = TypePrim("bool") âˆ¨
 T = TypePtr(_, _) âˆ¨
 T = TypeModalState(_, _) âˆ¨
 T = ModalRefType(modal_ref) âˆ¨
 T = TypeDynamic(_) âˆ¨
 T = TypeOpaque(_) âˆ¨
 T = TypeTuple(_) âˆ¨
 T = TypeUnion(_) âˆ¨
 T = TypeSlice(_) âˆ¨
 T = TypeString(_) âˆ¨
 T = TypeBytes(_) âˆ¨
 T = TypeRange âˆ¨
 T = TypePath(["Context"])

FfiByValueType(T) â‡” StripPerm(T) âˆ‰ {TypeRawPtr(_, _), TypePtr(_, _), TypeFunc(_, _)} âˆ§ StripPerm(T) â‰  TypePrim("()")
FfiPassByValueAttr(T) â‡” (T = TypePath(p) âˆ§ RecordDecl(p) = R âˆ§ AttrByName(R, "ffi_pass_by_value") â‰  []) âˆ¨ (T = TypePath(p) âˆ§ EnumDecl(p) = E âˆ§ AttrByName(E, "ffi_pass_by_value") â‰  [])
FfiByValueOk(T) â‡” Â¬(DropType(T) âˆ§ FfiSafeType(T) â‡“ ok âˆ§ FfiByValueType(T)) âˆ¨ FfiPassByValueAttr(StripPerm(T))

**(FfiSafe-Prim)**
T = TypePrim(t)    t âˆˆ FfiPrimTypes
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-RawPtr)**
T = TypeRawPtr(_, _)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Array)**
T = TypeArray(U, n)    Î“ âŠ¢ ConstLen(n) â‡“ _    Î“ âŠ¢ FfiSafeType(U) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Func)**
T = TypeFunc(params, R)    âˆ€ âŸ¨_, T_iâŸ© âˆˆ params. Î“ âŠ¢ FfiSafeType(T_i) â‡“ ok    Î“ âŠ¢ FfiSafeType(R) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Perm)**
T = TypePerm(_, U)    Î“ âŠ¢ FfiSafeType(U) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Alias)**
T = TypePath(p)    AliasBody(p) = ty    Î“ âŠ¢ FfiSafeType(ty) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Alias-Apply)**
T = TypeApply(p, args)    AliasBody(p) = ty    params_gen = TypeParamsOpt(AliasParams(p))    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    Î“ âŠ¢ AliasWhere(p)[Î¸] ok    Î“ âŠ¢ FfiSafeType(TypeSubst(Î¸, ty)) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Record)**
T = TypePath(p)    RecordDecl(p) = R    HasLayoutC(R)    TypeParamsOpt(R.gen_params_opt) = []    Î“ âŠ¢ layout(T) â‡“ _    âˆ€ f : T_f âˆˆ Fields(R). Î“ âŠ¢ FfiSafeType(T_f) â‡“ ok    FfiSafeWhereOk([], R.where_clause_opt, âˆ…)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Record-Apply)**
T = TypeApply(p, args)    RecordDecl(p) = R    params_gen = TypeParamsOpt(R.gen_params_opt)    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    HasLayoutC(R)    Î“ âŠ¢ layout(T) â‡“ _    Î“ âŠ¢ R.where_clause_opt[Î¸] ok    FfiSafeWhereOk(params_gen, R.where_clause_opt, TypeParamsInFields(Fields(R), params_gen))    âˆ€ f : T_f âˆˆ Fields(R). Î“ âŠ¢ FfiSafeType(TypeSubst(Î¸, T_f)) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Enum)**
T = TypePath(p)    EnumDecl(p) = E    HasLayoutC(E)    TypeParamsOpt(E.gen_params_opt) = []    Î“ âŠ¢ layout(T) â‡“ _    âˆ€ v âˆˆ Variants(E). âˆ€ T_f âˆˆ PayloadTypes(v). Î“ âŠ¢ FfiSafeType(T_f) â‡“ ok    FfiSafeWhereOk([], E.where_clause_opt, âˆ…)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Enum-Apply)**
T = TypeApply(p, args)    EnumDecl(p) = E    params_gen = TypeParamsOpt(E.gen_params_opt)    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    HasLayoutC(E)    Î“ âŠ¢ layout(T) â‡“ _    Î“ âŠ¢ E.where_clause_opt[Î¸] ok    FfiSafeWhereOk(params_gen, E.where_clause_opt, TypeParamsInPayloads(Variants(E), params_gen))    âˆ€ v âˆˆ Variants(E). âˆ€ T_f âˆˆ PayloadTypes(v). Î“ âŠ¢ FfiSafeType(TypeSubst(Î¸, T_f)) â‡“ ok
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡“ ok

**(FfiSafe-Prohibited-Err)**
ProhibitedFfiType(T)    c = Code(FfiSafe-Prohibited-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Record-LayoutC-Err)**
(T = TypePath(p) âˆ¨ T = TypeApply(p, _))    RecordDecl(p) = R    Â¬ HasLayoutC(R)    c = Code(FfiSafe-Record-LayoutC-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Enum-LayoutC-Err)**
(T = TypePath(p) âˆ¨ T = TypeApply(p, _))    EnumDecl(p) = E    Â¬ HasLayoutC(E)    c = Code(FfiSafe-Enum-LayoutC-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Record-Field-Err)**
T = TypePath(p)    RecordDecl(p) = R    HasLayoutC(R)    âˆƒ f : T_f âˆˆ Fields(R). Î“ âŠ¢ FfiSafeType(T_f) â‡‘    c = Code(FfiSafe-Record-Field-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Record-Field-Apply-Err)**
T = TypeApply(p, args)    RecordDecl(p) = R    params_gen = TypeParamsOpt(R.gen_params_opt)    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    HasLayoutC(R)    âˆƒ f : T_f âˆˆ Fields(R). Î“ âŠ¢ FfiSafeType(TypeSubst(Î¸, T_f)) â‡‘    c = Code(FfiSafe-Record-Field-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Enum-Field-Err)**
T = TypePath(p)    EnumDecl(p) = E    HasLayoutC(E)    âˆƒ v âˆˆ Variants(E). âˆƒ T_f âˆˆ PayloadTypes(v). Î“ âŠ¢ FfiSafeType(T_f) â‡‘    c = Code(FfiSafe-Enum-Field-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Enum-Field-Apply-Err)**
T = TypeApply(p, args)    EnumDecl(p) = E    params_gen = TypeParamsOpt(E.gen_params_opt)    DefaultArgs(params_gen, args) = args'    Î¸ = [args'_i / params_gen[i].name]    HasLayoutC(E)    âˆƒ v âˆˆ Variants(E). âˆƒ T_f âˆˆ PayloadTypes(v). Î“ âŠ¢ FfiSafeType(TypeSubst(Î¸, T_f)) â‡‘    c = Code(FfiSafe-Enum-Field-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Incomplete-Err)**
(T = TypePath(p) âˆ¨ T = TypeApply(p, _))    (RecordDecl(p) = R âˆ¨ EnumDecl(p) = E)    Â¬ âˆƒ Ï„. Î“ âŠ¢ layout(T) â‡“ Ï„    c = Code(FfiSafe-Incomplete-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Record-Generic-Unbounded-Err)**
T = TypePath(p)    RecordDecl(p) = R    params_gen = TypeParamsOpt(R.gen_params_opt)    params_gen â‰  []    Â¬ FfiSafeWhereOk(params_gen, R.where_clause_opt, TypeParamsInFields(Fields(R), params_gen))    c = Code(FfiSafe-Generic-Unbounded-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Enum-Generic-Unbounded-Err)**
T = TypePath(p)    EnumDecl(p) = E    params_gen = TypeParamsOpt(E.gen_params_opt)    params_gen â‰  []    Â¬ FfiSafeWhereOk(params_gen, E.where_clause_opt, TypeParamsInPayloads(Variants(E), params_gen))    c = Code(FfiSafe-Generic-Unbounded-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Record-Apply-Generic-Unbounded-Err)**
T = TypeApply(p, args)    RecordDecl(p) = R    params_gen = TypeParamsOpt(R.gen_params_opt)    params_gen â‰  []    Â¬ FfiSafeWhereOk(params_gen, R.where_clause_opt, TypeParamsInFields(Fields(R), params_gen))    c = Code(FfiSafe-Generic-Unbounded-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**(FfiSafe-Enum-Apply-Generic-Unbounded-Err)**
T = TypeApply(p, args)    EnumDecl(p) = E    params_gen = TypeParamsOpt(E.gen_params_opt)    params_gen â‰  []    Â¬ FfiSafeWhereOk(params_gen, E.where_clause_opt, TypeParamsInPayloads(Variants(E), params_gen))    c = Code(FfiSafe-Generic-Unbounded-Err)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ FfiSafeType(T) â‡‘ c

**Prohibited Categories**

The following type categories MUST NOT satisfy `FfiSafeType`:

- `bool`
- Modal types
- Safe pointers `Ptr<T>`
- Dynamic class object types `TypeDynamic(_)`
- Opaque types
- Tuples
- Unions
- Slices
- String and bytes types
- `Context`
- Range types

**RAII by-value rule.** If a type satisfies both `DropType` and `FfiSafeType`, then any by-value appearance of that type in an FFI signature requires the defining type to carry `[[ffi_pass_by_value]]`.

**Generic Bounds.** Any type parameter that appears in a field type or variant payload of a type satisfying `FfiSafeType` MUST be bounded by a `where` predicate of the form `FfiSafe(X)`.


### 21.2 Externs and Exports

#### 21.2.1 Extern Procedure Declarations

**Extern Procedure.** A declaration whose implementation is provided by foreign code.

**Static Semantics**

**ABI Strings**

ExternAbiSet = {"C", "C-unwind", "system", "stdcall", "fastcall", "vectorcall"}
ExternAbiOk(abi_opt) â‡” ExternAbiName(abi_opt) âˆˆ ExternAbiSet

**Signature Requirements**

ExternParamTypes(params) = [T_i | âŸ¨_, _, T_iâŸ© âˆˆ params]
ExternSigOk(params, ret_opt) â‡”
 R = ProcReturn(ret_opt) âˆ§
 (R = TypePrim("()") âˆ¨ Î“ âŠ¢ FfiSafeType(R) â‡“ ok) âˆ§
 (âˆ€ T âˆˆ ExternParamTypes(params). Î“ âŠ¢ FfiSafeType(T) â‡“ ok) âˆ§
 (âˆ€ T âˆˆ ExternParamTypes(params). FfiByValueOk(T)) âˆ§
 FfiByValueOk(R)

SparseFuncType(T) â‡” T = TypeFunc(_, _)

**FFI Constraints**

1. Closure types MUST NOT appear in `extern` signatures.
2. Only sparse function pointer types are FFI-safe in `extern` signatures (`SparseFuncType`).
3. Sparse function pointer types in `extern` signatures MUST NOT have generic type parameters.

**Call Safety**

Calls to extern procedures MUST appear within an `unsafe` block.


#### 21.2.2 Exported Procedures

**Exported Procedure.** A Cursive procedure made callable from foreign code via `[[export]]`.

**Static Semantics**

**Error Indicator Value.**

ZeroBits(T) = [0x00, â€¦, 0x00] where |ZeroBits(T)| = sizeof(T)
ZeroValue(T) = v â‡” ValueBits(T, v) = ZeroBits(T) âˆ§ âˆ€ v'. (ValueBits(T, v') = ZeroBits(T) â‡’ v' = v)
ZeroableType(T) â‡” âˆƒ v. ZeroValue(T) = v

If `UnwindMode(proc) = "catch"`, then `ZeroableType(R)` MUST hold for the exported procedure's return type R.

ExportSigJudg = {ExportSigOk}
ExportParamTypes(params) = [T_i | âŸ¨_, _, T_iâŸ© âˆˆ params]

**(ExportSig-Ok)**
proc = ProcedureDecl(_, vis, _, _, _, params, ret_opt, _, _, _, _)    vis = `public`    ExportAttr(proc) = âŸ¨abi, _âŸ©    abi âˆˆ ExternAbiSet    R = ProcReturn(ret_opt)    (R = TypePrim("()") âˆ¨ Î“ âŠ¢ FfiSafeType(R) â‡“ ok)    (âˆ€ T âˆˆ ExportParamTypes(params). Î“ âŠ¢ FfiSafeType(T) â‡“ ok)    (âˆ€ T âˆˆ ExportParamTypes(params). FfiByValueOk(T))    FfiByValueOk(R)    (UnwindMode(proc) â‰  "catch" âˆ¨ ZeroableType(R))
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Î“ âŠ¢ ExportSigOk(proc) â‡“ ok

**Dynamic Semantics (Unwind Catch).**

If `UnwindMode(proc) = "catch"` and a Cursive panic reaches the FFI boundary during execution of an exported procedure with return type R:
1. The panic is caught at the boundary and does not propagate into foreign code.
2. The procedure returns the error indicator value `ZeroValue(R)` to the foreign caller.


### 21.3 Capability Isolation

**Capability Isolation.** Foreign code MUST NOT receive or return capability-bearing values.

**Static Semantics**

1. Any FFI signature containing `Context`, a capability class, or a dynamic class object is ill-formed.
2. A raw pointer derived from region-local storage MUST NOT cross an FFI boundary.


### 21.4 Foreign Contracts

#### 21.4.1 Foreign Preconditions

**Foreign Preconditions.** Conditions that callers must satisfy before invoking foreign procedures, specified using the `@foreign_assumes` clause.

**Syntax**

```ebnf
ffi_verification_attr ::= "[[" ffi_verification_mode "]]"
ffi_verification_mode ::= "static" | "dynamic" | "assume" | "trust"

foreign_contract ::= "|=" "@foreign_assumes" "(" predicate_list ")"

predicate_list   ::= predicate ("," predicate)*

predicate        ::= comparison_expr | null_check | range_check

null_check       ::= expression "!=" null_literal | expression "==" null_literal

range_check      ::= expression "in" range_expression
```


**Static Semantics**

**Predicate Context**

Predicates MAY reference:

- Parameter names from the procedure signature
- Literal constants
- Pure functions and operators
- Fields of parameter values (for record types)

Predicates MUST NOT reference:

- Global mutable state
- Values not in scope at the call site
- Effectful operations

**Verification Modes**

| Mode                   | Behavior                                                   |
| :--------------------- | :--------------------------------------------------------- |
| `[[static]]` (default) | Caller must prove predicates at compile time               |
| `[[dynamic]]`          | Runtime checks inserted before `unsafe` call               |
| `[[assume]]`           | Predicates assumed true without checks (optimization only) |

`[[static]]` uses `StaticProof` as defined in Â§14.7.1. `[[dynamic]]` inserts `ContractCheck(P, ForeignPre, s, Ï_emptyset)` immediately before the foreign call.

**Dynamic Semantics**

A failed `ForeignPre` check triggers a panic (`P-SEM-2860`).


#### 21.4.2 Foreign Postconditions

**Foreign Postconditions.** Conditions that foreign code guarantees upon successful return, specified using the `@foreign_ensures` clause. These are trusted assertions about foreign behavior.

**Syntax**

```ebnf
foreign_ensures ::= "@foreign_ensures" "(" ensures_predicate_list ")"

ensures_predicate_list ::= ensures_predicate ("," ensures_predicate)*

ensures_predicate ::= predicate
                    | "@error" ":" predicate
                    | "@null_result" ":" predicate
```


**Static Semantics**

**Predicate Bindings**

Postcondition predicates MAY reference:

- `@result`: The return value of the foreign procedure
- Parameter names (for checking output parameters)
- `@error`: Predicates that hold when the call fails
- `@null_result`: Predicates that hold when result is null

**Success, Error, and Null Classification**

Let U be the set of unconditional predicates, E the list of `@error` predicates, and N the list of `@null_result` predicates.

Define:

ErrCond =
 â‹€_(P âˆˆ E) P    if E â‰  âˆ…
 `false`        otherwise

NullCond = (`@result` == `null`)

SuccessCond = Â¬ ErrCond

The foreign call is classified as an error iff `ErrCond` holds; otherwise it is classified as success.

Then the foreign postcondition obligations are:

1. For each P âˆˆ U, require SuccessCond â‡’ P
2. For each P âˆˆ E, require ErrCond â‡’ P
3. For each P âˆˆ N, require NullCond â‡’ P

`@null_result` predicates are well-formed only when the return type is a nullable pointer type; otherwise they are invalid (`E-SEM-2853`). A nullable pointer type is one of:
1. `Ptr<T>@Null`
2. `*imm T`
3. `*mut T`

`@error` predicates are well-formed only when the return type is not `()`. Using `@error` on a void-returning foreign procedure is ill-formed (`E-SEM-2855`).

**Verification Modes**

| Mode                   | Behavior                                                      |
| :--------------------- | :------------------------------------------------------------ |
| `[[static]]` (default) | Postconditions available as assumptions for downstream proofs |
| `[[dynamic]]`          | Runtime assertions after foreign call returns                 |
| `[[assume]]`           | Postconditions assumed without checks (optimization only)     |
| `[[trust]]`            | Postconditions trusted without runtime checks (audited code)  |

`[[static]]` uses `StaticProof` as defined in Â§14.7.1 with `SuccessCond` and `ErrCond` gating the obligations.

**Dynamic Semantics**

In `[[dynamic]]` mode, the implementation MUST evaluate `ErrCond` and `NullCond` in left-to-right predicate order and insert runtime checks enforcing the implications above immediately after the foreign call returns. Each inserted check is `ContractCheck(P, ForeignPost, s, Ï_foreign_post)`. A failed runtime check triggers a panic with payload `ContractViolation(ForeignPost, P, s)` at the call site (`P-SEM-2861`).


#### 21.4.3 Trust Boundaries

**Trust Boundaries.** Verification behavior definitions for foreign contracts, controlling the trade-off between safety guarantees and performance.

**Syntax**


**Static Semantics**

**Trust Annotation**

The `[[trust]]` attribute on an extern block suppresses runtime checks for all contracts within that block. Postconditions are assumed true without verification.

**Safety Implications**

Incorrect postconditions under `[[trust]]` place the program outside conformance. The programmer asserts that the foreign code satisfies declared contracts.

**Verification Hierarchy**

| Level         | Precondition Check | Postcondition Check      |
| :------------ | :----------------- | :----------------------- |
| `[[static]]`  | Compile-time proof | Available as assumptions |
| `[[dynamic]]` | Runtime assertion  | Runtime assertion        |
| `[[assume]]`  | No check           | No check                 |
| `[[trust]]`   | No check           | No check (trusted)       |
