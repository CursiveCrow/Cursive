// Cursive0 HelloWorld - feature walkthrough
// Expected output: "Hello, World!"

record Counter {
  value: i32,
  procedure read(~) -> i32 { return self.value; }
}

enum Mood { Happy, Sad }

modal Status {
  @Idle {}
  @Busy {
    code: i32
    procedure code_value() -> i32 { return code; }
    transition reset() -> @Idle { return Status@Idle { }; }
  }
}

procedure sum_to(limit: i32) -> i32 {
  loop {
    break;
  }
  var acc: i32 = 0;
  var i: i32 = 0;
  loop i < limit {
    acc = acc + i;
    i = i + 1;
    continue;
  }
  return acc;
}

procedure classify(m: Mood) -> i32 {
  return match m {
    Mood::Happy => 1,
    Mood::Sad => 0
  };
}

procedure status_code(s: Status) -> i32 {
  return match move s {
    @Idle => 0,
    @Busy { code } => code
  };
}

public procedure main(ctx: Context) -> i32 {
  let greeting: string@View = "Hello, World!";
  let _len: usize = string::length(greeting);
  let _empty: bool = string::is_empty(greeting);
  let _managed: string@Managed = string::to_managed(greeting, ctx.heap);

  let count: const i32 = 3;
  let counter = Counter { value: count };
  let _read = counter~>read();

  let mood = Mood::Happy;
  let _mood_code = classify(mood);

  let status: Status = widen Status@Busy { code: 7 };
  let _status_code = status_code(move status);

  let _sum = sum_to(5);

  let x: i32 = 42;
  let _p_valid: Ptr<i32>@Valid = &x;
  let _p_null: Ptr<i32>@Null = Ptr::null();

  let dir_path: string@View = ".";
  let dir_res = ctx.fs~>open_dir(dir_path);
  let _has_entry: bool = match move dir_res {
    d: unique DirIter@Open => {
      let next_res = d~>next();
      let ok = match move next_res {
        e: DirEntry => true,
        empty: () => false,
        err: IoError => false
      };
      let _ = (move d)~>close();
      ok
    },
    err: IoError => false
  };

  let _ = match ctx.fs~>write_stdout(greeting) {
    ok: () => (),
    err: IoError => ()
  };
  return 0i32;
}
